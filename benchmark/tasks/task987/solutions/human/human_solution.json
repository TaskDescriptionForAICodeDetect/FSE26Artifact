[
  {
    "language": "Scala",
    "code": "object Main {\n  def main(args: Array[String]): Unit = {\n    val Array(n, m) = io.StdIn.readLine().split(' ').map(_.toInt)\n    val q = io.StdIn.readLine().toInt\n    val a = io.StdIn.readLine().split(' ').map(_.toInt)\n\n    if (a.last != 1 && a.count(_ == a.last) < n) println(\"No\")\n    else println(\"Yes\")\n  }\n}\n"
  },
  {
    "language": "Fortran",
    "code": "program lru_puzzle\n  implicit none\n  integer :: n, m, q, a(100000) = 0, i, k\n  integer :: x = 0, p(100000) = 0, r(100000) = 0, c(0:100000) = 0\n  logical :: u(100000) = .false.\n  read(*,*) n, m\n  read(*,*) q\n  read(*,*) a(1:q)\n  do i = q, 1, -1\n    if (u(a(i))) cycle\n    x = x+1\n    p(x) = a(i)\n    u(a(i)) = .true.\n  end do\n  do i = 1, m\n    if (u(i)) cycle\n    x = x+1\n    p(x) = i\n  end do\n  do i = 1, m\n    r(p(i)) = i\n  end do\n  c(0) = n\n  do i = q, 1, -1\n    k = r(a(i))\n    if (c(k-1) > 0) then\n      c(k-1) = c(k-1)-1\n      c(k) = c(k)+1\n    end if\n  end do\n  k = 0\n  do while (c(k) == 0)\n    k = k+1\n  end do\n  do i = k+1, m-1\n    if (p(i) > p(i+1)) then\n      write(*,'(a)') \"No\"\n      stop\n    end if\n  end do\n  write(*,'(a)') \"Yes\"\nend program lru_puzzle"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int last[M];\n  int laststock = 0;\n  int lastcount[M];\n  for(i=Q-1; i>=0; --i){\n    bool stocked = false;\n    for(j=0; j<laststock; ++j){\n      if(last[j] == a[i]){\n        if(j == 0 || lastcount[j] < lastcount[j-1]){\n          lastcount[j]++;\n        }\n        stocked = true;\n      }\n    }\n    if(!stocked){\n      last[laststock] = a[i];\n      lastcount[laststock] = 1;\n      laststock++;\n    }\n  }\n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  int p = 0;\n  int maxp = -1;\n  for(i=1; i<M+1; ++i){\n    while(p<laststock && last[p] != i){\n      ++p;\n    }\n    if(p >= laststock){break;}\n    if(p > maxp){\n      maxp = p;\n      lastcount[p] = N;\n    }\n  }\n  \n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  \n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n \nconst int INF=1000000009;\n \nbool dcs(int m,int q){\n \n\tif(m==1) return 1;\n \n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(d[m]==0) return 1;\n \telse{\n \t\tif(g[m]) return 1;\n\t\telse{\n\t  \tif(f[m]) return 1;\n\t\t}\n \t}\n \n\treturn 0;\n \n}\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n \n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n \n\tsort(b,b+Q); M=b[Q-1];\n \n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n \n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n \n\tfor(int i=0; i<100005; i++) e[i]=INF;\n \n\tint Min=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]==0){\n\t\t\te[i]=INF; break;\n\t\t}else{\n\t\t\tif(d[i]<Min){\n\t\t\t\te[i]=d[i]; Min=d[i];\n\t\t\t}else{\n\t\t\t\te[i]=Min;\n\t\t\t}\n\t\t}\n\t}\n \n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n \n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n \n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint qs[maxn];\n\nint n, m, q;\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &q) < 3) {\n    return 0;\n  }\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", qs + i);\n    --qs[i];\n  }\n  return 1;\n}\n\nint lev[maxn];\n\nint used[maxn];\nint a[maxn];\nint back[maxn];\n\nvoid solve() {\n  for (int i = 0; i < m; ++i) {\n    used[i] = 0;\n  }\n  int k = 0;\n  for (int iter = q - 1; iter >= 0; --iter) {\n    int x = qs[iter];\n    if (!used[x]) {\n      used[x] = 1;\n      a[k++] = x;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    if (!used[i]) {\n      a[k++] = i;\n    }\n  }\n  assert(k == m);\n\n  int stop = m;\n  for (int last = inf; stop && a[stop - 1] < last; --stop) {\n    last = a[stop - 1];\n  }\n\n  for (int i = 0; i <= stop; ++i) {\n    lev[i] = 0;\n  }\n  lev[0] = n;\n\n  for (int i = 0; i < m; ++i) {\n    //eprintf(\"%d%c\", a[i], \" \\n\"[i == m - 1]);\n    back[a[i]] = i;\n  }\n\n  for (int iter = q - 1; iter >= 0; --iter) {\n    int x = qs[iter];\n    int pos = back[x];\n    if (pos < stop && lev[pos]) {\n      --lev[pos];\n      ++lev[pos + 1];\n    }\n  }\n  if (lev[stop] == n) {\n    printf(\"Yes\\n\");\n  } else {\n    printf(\"No\\n\");\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ryan in ny / per jorner fills in: derivative code\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(n);i++)\n#define per(i,a,n) for (int i=(n)-1;i>=(a);i--)\ntypedef long long ll;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    vector<int> v(q + 10);\n    rep(i, 0, q) cin >> v[i], v[i]--;\n    \n    vector<int> waiting(m + 10, 0);\n    waiting[0] = n;\n    vector<int> pos(m + 10, -1);\n    int built = 0;\n    vector<int> order(m + 10, -1);\n    \n    per(i, 0, q) {\n        if (pos[v[i]] != -1) {\n            if (waiting[pos[v[i]]]) {\n                waiting[pos[v[i]]]--;\n                waiting[pos[v[i]] + 1]++;\n            }\n        } else {\n            pos[v[i]] = built;\n            assert(waiting[built]);\n            waiting[built]--;\n            waiting[built + 1]++;\n            order[built] = v[i];\n            built++;\n        }\n    }\n    \n    //rep(i, 0, m) cout << order[i] << \": \" << waiting[i] << endl;\n    \n    bool ok = true;\n    per(i, 0, m - 1) {\n        if (order[i + 1] != -1 && order[i] > order[i + 1]) ok = false;\n        if (!ok && waiting[i]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nvector<int> ord;\nint markn[N], a[N], cnt[N], pl[N];\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n        a[i]--;\n    }\n    cnt[0] = n;\n    for (int i = q - 1; i >= 0; --i) {\n        if (!markn[a[i]]++) {\n            ord.push_back(a[i]);\n        }\n    }\n    for (int i = m - 1; i >= 0; --i)\n        if (!markn[i]++) {\n            ord.push_back(i);\n        }\n    for (int i = 0; i < m; ++i)\n        pl[ord[i]] = i;\n    for (int i = q - 1; i >= 0; --i) {\n        if (cnt[pl[a[i]]] == 0) continue;\n        cnt[pl[a[i]]]--;\n        cnt[pl[a[i]] + 1]++;\n    }\n    int sr = 0;\n    for (int i = m - 2; i >= 0; --i) {\n        if (ord[i + 1] < ord[i]) {\n            sr = i + 1;\n            break;\n        }\n    }\n    for (int i = 0; i < sr; ++i) {\n        if (cnt[i] > 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n, m, q;\nint a[maxn], pos[maxn], apos[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &q) < 3) {\n    return false;\n  }\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n  }\n  return true;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    pos[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    apos[i] = -1;\n  }\n  for (int i = q - 1; i >= 0; i--) {\n    if (apos[a[i]] == -1) {\n      apos[a[i]] = pos[n - 1];\n      pos[n - 1]++;\n    }\n    else {\n      int k = upper_bound(pos, pos + n, apos[a[i]]) - pos - 1;\n      if (k != -1 && pos[k] == apos[a[i]]) {\n        pos[k]++;\n      }\n    }\n  }\n  bool b = true;\n  for (int i = 0; i < pos[n - 1] - apos[0]; i++) {\n    if (apos[i] != apos[0] + i) {\n      b = false;\n    }\n  }\n  int x = (b? apos[0] : pos[n - 1]);\n  bool ok = true;\n  for (int i = 0; i < n - 1; i++) {\n    if (pos[i] < x) {\n      ok = false;\n      break;\n    }\n  }\n  printf(ok? \"Yes\\n\" : \"No\\n\");\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> n_fixed(m+1, 0);\n\tn_fixed[0] = n;\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tn_fixed[order.size()]++;\n\t\t\tn_fixed[order.size()-1]--;\n// show(n_fixed, \"n_fixed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tif (n_fixed[pos] > 0) {\n\t\t\tn_fixed[pos]--;\n\t\t\tn_fixed[pos+1]++;\n\t\t}\n// show(n_fixed, \"n_fixed\");\n\t}\n\n\t// show(order, \"order\");\n\t// show(n_fixed, \"n_fixed\");\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\torder.emplace_back(i);\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tauto it = find_if(n_fixed.begin(), n_fixed.end(),\n\t                  [](const int &a) {return a > 0;});\n\tint min_fix = *it;\n\n\tbool ok = true;\n\tfor (int i = min_fix; i < order.size() - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000], pr[110000], nx[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tREP(i,m) pr[i] = i-1, nx[i] = i+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\tnx[pr[a[i]]] = nx[a[i]], pr[nx[a[i]]] = pr[a[i]];\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != -nx[-cur[k]]) ans = false;\n\t\t\tif (cur[k] < 0) { cur[k] = j; break; }\n\t\t\telse cur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tREP(i,m) if (cur[i]<-step) ans = false;\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tvector<ll> not_comp;\n\tREP(i, m) if(!dict.count(i) || cnt[i] != n) not_comp.pb(i);\n\tsort(ALL(not_comp));\n\tll tmp = 0;\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(idx[i] != not_comp[tmp]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0]+1,n){\n\t\tif(v[i]<v[i-1]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tint hi=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\thi=max(hi,pos[a[i]]+1);\n\t\t\t//while(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(hi<pos[a[i]]){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t\t/*else if(num[pos[a[i]]+1]>0){\n\t\t\tnum[pos[a[i]]+1]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t}\n\t\telse if(num[n]>0){\n\t\t\tnum[n]+=0;\n\t\t}\n\t\telse{\n\t\t\tif(lo<pos[a[i]]){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\t//num[lo]--;num[pos[a[i]]+1]++;lo=1;\n\t\t}\n\t\t//rep(j,n+1) cout<<num[j]<<' ';cout<<endl;\n\t\t*/\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, M, Q;\nint A[100011];\nint cnt[100011];\nint rnk[100011];\nint len[100011];\nVI ord;\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    REP (i, Q) scanf(\"%d\", A+i), A[i]--;;\n\n    for (int i=Q; i--;) {\n\tint v = A[i];\n\tif (cnt[v] == 0) {\n\t    rnk[v] = ord.size();\n\t    ord.push_back(v);\n\t    len[0]++;\n\t    cnt[v]++; \n\t} else if (cnt[v] < N && len[cnt[v]] == rnk[v]) {\n\t    len[cnt[v]]++;\n\t    cnt[v]++; \n\t}\n    }\n\n    REP (i, M) if (cnt[i] == 0) ord.push_back(i);\n    bool yes = true;\n    for (int i=len[N-1]; i<M-1; i++) if (ord[i] > ord[i+1]) yes = false;\n    puts(yes? \"Yes\": \"No\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, m, q;\n        in >> n >> m >> q;\n        vector<int> v(q);\n        for (int i: range(q)) {\n            in >> v[i];\n            --v[i];\n        }\n\n        vector<vector<int>> changesTimes(m);\n\n        for (int i: range(q)) {\n            changesTimes[v[i]].push_back(i);\n        }\n\n        vector<int> last(n, 1000000000);\n\n\n        vector<int> used(m + 1);\n        int minUnused = 0;\n        int alreadyFailed = false;\n        for (int j: downrange(q)) {\n            int i = v[j];\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            while (used[minUnused])\n                ++minUnused;\n\n            if (alreadyFailed && !(i < minUnused)) {\n                out << \"No\\n\";\n                return;\n            }\n\n            if (alreadyFailed) {\n                continue;\n            }\n\n            multiset<int> cur(changesTimes[i].begin(), changesTimes[i].end());\n\n            for (int& vv: last) {\n                auto it = cur.upper_bound(vv);\n                if (it == cur.begin()) {\n                    if (i <= minUnused) {\n                        alreadyFailed = true;\n                        break;\n                    } else {\n                        out << \"No\\n\";\n                        return;\n                    }\n                }\n                --it;\n                vv = *it;\n                cur.erase(it);\n            }\n        }\n\n        out << \"Yes\\n\";\n    }\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l=0,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n    //OUT(l)\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    /*if(l==0){\n        cout << \"AAA\" <<endl;\n        return 0;\n    }*/\n    REPN(i,1,l){\n        if(dat[i]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n        int N,M,Q,a[10001];\n\n        cin >> N >> M;\n        cin >> Q;\n        for(int i=0; i<Q; i++){\n                cin >> a[i];\n        }\n\n        int locate[10001]={0}; //locate[i]==j ならば iはj番目の数。1<=j<=M\n        int locate_num[10001]={0}; //locate_num[i]==jならばi番目の数はj回出てきた\n        locate_num[0]=1000000;\n        int locate_cnt=1;\n        for(int i=Q-1;i>=0;i--){\n                if(locate[a[i]] == 0){\n                        locate[a[i]]=locate_cnt;\n                        locate_num[locate_cnt]++;\n//                      if(locate_num[locate_cnt-1]<locate_num[locate_cnt]){\n//                              printf(\"No\\n\");\n//                              return 0;\n//                      }\n                        locate_cnt++;\n                }else{\n                        locate_num[locate[a[i]]]++;\n                        if(locate_num[locate_cnt-1] < locate_num[locate_cnt]){\n                                cout << \"No\" << endl;\n                                return 0;\n                        }\n                }\n        }\n\n        bool logic=true;\n        for(int i=1;i<=M;i++){\n                logic &= (locate[i]==i);\n        }\n        if(logic){\n                cout << \"Yes\" << endl;\n                return 0;\n        }\n        for(int i=1;i<=M;i++){\n                if(locate_num[i]!=0 && locate_num[i]<N){\n                        cout << \"No\"<<endl;\n                        return 0;\n                }\n        }\n        cout << \"Yes\" << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nint n, m, q;\nint time[100005];\nint a[100005], reduce[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tcol[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=m+1; i++){\n\t\tif(col[i].empty()) reduce[i] = 1;\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\tfor(int i=q; i; i--){\n\t\tif(col[a[i]].empty() || col[a[i]].back() != i) continue;\n\t\tif(a[i] == 1){\n\t\t\tfor(int j=2; j<=m+1; j++){\n\t\t\t\tif(reduce[j]){\n\t\t\t\t\tbool bad= 0;\n\t\t\t\t\tfor(int k=j+1; k<=m; k++){\n\t\t\t\t\t\tif(!reduce[k]){\n\t\t\t\t\t\t\tbad = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad) return !puts(\"Yes\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = a[i];\n\t\treduce[x] = 1;\n\t\tfor(int j=0; j<n; j++){\n\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\ttime[j] = col[x].back();\n\t\t\tcol[x].pop_back();\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = m; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= m ){\n\tassert( ss[ v[i] ].find( i-m ) != ss[ v[i] ].end() );\n\tss[ v[i] ].erase( ss[ v[i] ].find( i-m ) );\n      }\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( ( t + 1 ) * n  > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      cur = *ite;\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2){\n                if(i==1){\n                    if(E[x][E[x].size()-1] > tp){\n                        printf(\"No\\n\");\n                        return 0;\n                    }\n                    tp = E[x][E[x].size()-1];\n                }\n                continue;\n            }\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid No() {\n    cout << \"No\\n\";\n    exit(0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n, m, q;\n    cin >> n >> m >> q;\n    vector<int> qs(q, 0);\n    for (int i = 0; i < q; ++i) {\n        cin >> qs[i];\n        qs[i]--;\n    }\n\n    reverse(qs.begin(), qs.end());\n    vector<int> used(m, 0), seq;\n    for (int i = 0; i < q; ++i)\n        if (!used[qs[i]]) {\n            seq.push_back(qs[i]);\n            used[qs[i]] = 1;\n        }\n\n    for (int i = 0; i < m; ++i)\n        if (!used[i])\n            seq.push_back(i);\n    vector<int> myNum(m, -1);\n    for (int i = 0; i < m; ++i) {\n        myNum[seq[i]] = i;\n    //    cerr << seq[i] << ' ';\n    }\n    //cerr << \"\\n\";\n\n    int ind = m-1;\n    while (ind > 0 && seq[ind] > seq[ind-1])\n        --ind;\n    vector<int> kol(m+1, 0);\n    kol[0] = n;\n    bool weCan = false;\n    for (int i = 0; i < q; ++i) {\n        int v = qs[i];\n        int pos = myNum[v] + 1;\n        if (pos > ind) {\n            if (!weCan && kol[pos-1] == kol[pos])\n                No();\n            weCan = true;\n            kol[pos] += 1;\n        }\n        else {\n            kol[pos] = min(kol[pos-1], kol[pos] + 1);\n        }\n    }\n\n    //cerr << ind << ' ' << kol[ind] << \"\\n\";\n    if (kol[ind] < n)\n        No();\n    cout << \"Yes\\n\"; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint a[101010];\n\nset<int> h[101010];\nint p[101010];\nint u[101010];\n\nvoid nie(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tint q;\n\tcin>>q;\n\tfor (int i=0;i<q;i++){\n\t\tcin>>a[i];\n\t\th[a[i]].insert(i);\n\t}\n\tif (a[q-1]==1){\n\t\tint t=1;\n\t\tint ok=1;\n\t\tfor (int i=q-1;i>=0;i--){\n\t\t\tif (a[i]>t+1){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[i]==t+1){\n\t\t\t\tt=a[i];\n\t\t\t}\n\t\t}\n\t\tif (ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tp[i]=q-1;\n\t}\n\tint us=0;\n\tfor (int i=q-1;i>=0;i--){\n\t\tif (u[a[i]]==0){\n\t\t\tif (us==m-1) continue;\n\t\t\tu[a[i]]=1;\n\t\t\tint t=a[i];\n\t\t\tfor (int j=1;j<=n;j++){\n\t\t\t\tif (h[t].size()==0){\n\t\t\t\t\tnie();\n\t\t\t\t}\n\t\t\t\tauto it=h[t].upper_bound(p[j]);\n\t\t\t\tif (it==h[t].begin()) nie();\n\t\t\t\tit--;\n\t\t\t\tp[j]=*it;\n\t\t\t\th[t].erase(it);\n\t\t\t}\n\t\t\tus++;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nlli cn[100005];\n\n\nint n,m,qn;\nint dat[100005];\nint gone[100005]={};\n\nset<int> ds;\n\nvector<int> td;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,qn)scanf(\"%d\",&dat[i]);\n\t\n\tint bp=1;\n\tirep(i,qn){\n\t\tint no=dat[i];\n\t\tif(!gone[no]){\n\t\t\ttd.push_back(no);\n\t\t\tgone[no]=bp;\n\t\t\tbp++;\n\t\t}\n\t}\n\t\n\treg(i,1,m){\n\t\tif(!gone[i])td.push_back(i);\n\t}\n\t\n\t/*\n\trep(i,m){\n\t\tprintf(\"td .. %d\\n\",td[i]);\n\t}\n\t*/\n\t\n\tcn[0]=n;\n\tds.insert(0);\n\t\n\tirep(i,qn){\n\t\tint no=dat[i],\n\t\t\tp=gone[no];\n\t\tset<int>::iterator ite;\n\t\tite = ds.lower_bound(p-1);\n\t\t//printf(\"%d %d\\n\",*ite,p);\n\t\tif(ite==ds.end()){\n\t\t\tite = ds.lower_bound(0);\n\t\t\tp=0;\n\t\t}\n\t\tcn[*ite]--;\n\t\tif(cn[*ite]==0)ds.erase(ite);\n\t\tif(cn[p]==0)ds.insert(p);\n\t\tcn[p]++;\n\t}\n/*\n2 3\n4\n3 2 3 1\n*/\n\t/*\n\trep(i,m+1){\n\t\tprintf(\"cn[%d] %d\\n\",i,cn[i]);\n\t}\n\t*/\n\t\n\t\n\tint okp=-1;\n\tint nma=100005;\n\tirep(i,m){\n\t\tif(nma<td[i]){\n\t\t\tokp=i;\n\t\t\tbreak;\n\t\t}\n\t\tnma=td[i];\n\t}\n\t//printf(\"%d %d\\n\",nma,okp);\n\t\n\treg(i,0,okp){\n\t\tif(cn[i]>0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cassert>\n\nconst int N = 1e5 + 7;\n\nint n, m, q;\nint a[N];\nstd::vector<int> seq[N];\nint visit[N], b[N];\nstd::vector<int> queue[N];\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tqueue[0].push_back(i);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tvisit[i] = -1;\n\t}\n\tint cur = 0;\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = a[i];\n\t\tif (visit[num] != -1) {\n\t\t\tint pos = visit[num];\n\t\t\tif (queue[pos - 1].size()) {\n\t\t\t\tint back = queue[pos - 1].back();\n\t\t\t\tqueue[pos - 1].pop_back();\n\t\t\t\tqueue[pos].push_back(back);\n\t\t\t}\n\t\t} else {\n\t\t\tvisit[num] = ++cur;\n\t\t\tassert(queue[cur - 1].size());\n\t\t\tint back = queue[cur - 1].back();\n\t\t\tqueue[cur - 1].pop_back();\n\t\t\tb[cur] = num;\n\t\t\tqueue[cur].push_back(back);\n\t\t}\n\t}\n\tfor (int i = cur + 1, ptr = 1; i <= m; i++) {\n\t\twhile (visit[ptr] == -1) {\n\t\t\tptr++;\n\t\t}\n\t\tb[i] = ptr;\n\t\tvisit[ptr] = i;\n\t}\n\t/*\n\tprintf(\"b = \\n\");\n\tfor (int i = 1; i <= m; i++) {\n\t\tprintf(\"%d \", b[i]);\n\t}\n\tputs(\"\");\n\t*/\n\tint least = cur;\n\tfor (int i = 0; i <= cur; i++) {\n\t\tif (queue[i].size()) {\n\t\t\tleast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//printf(\"%d\\n\", least);\n\tfor (int i = least + 1; i < m; i++) {\n\t\tif (b[i] > b[i + 1]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      j=0;\n      for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n      if(j!=k&&c[k]!=q) f=false; \n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    for(i=2;i<=m;i++) if(j!=k&&c[i]!=0&&c[i]<n) f=false;\n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n//\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n//\tfor (PP p : seq) {\n//\t\tif (p.second == N) {\n//\t\t\tSet.erase(p.first);\n//\t\t} else {\n//\t\t\tif (*Set.begin() != p.first) {\n//\t\t\t\tok = false;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tSet.erase(p.first);\n//\t\t}\n//\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) {\n            if (a[i] == mark) mark++;\n            else return 0;\n        }\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    //rin;\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\n#define pb push_back\n#define pbk pop_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define all(x) (x).begin(), (x).end()\n#define foreach(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); ++i)\n#define len(a) ((int) (a).size())\n\n#ifdef CUTEBMAING\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double ld;\ntypedef unsigned long long lint;\n\nconst int inf = (1 << 30) - 1;\nconst int64 linf = (1ll << 62) - 1;\nconst int N = 1e6 + 100;\n\nint n, m, q;\nint a[N];\n\nbool used[N];\nvector<int> perm;\n\nint it[N];\nset<int> qt[N];\nint pos[N];\n\nint main() {\n#ifdef XCODE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &a[i]), a[i]--;\n    }\n    for (int i = q - 1; i >= 0; i--) {\n        if (!used[a[i]]) {\n            perm.pb(a[i]);\n            used[a[i]] = true;\n        }\n    }\n    for (int i = 0; i < len(perm); i++) {\n        pos[perm[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        qt[it[i]].insert(i);\n    }\n    for (int i = q - 1; i >= 0; i--) {\n        int cur = pos[a[i]];\n        if (len(qt[cur]) == 0) {\n            continue;\n        }\n        int start = *qt[cur].begin();\n        qt[cur].erase(qt[cur].begin());\n        qt[cur + 1].insert(start);\n    }\n    static int last[N];\n    for (int i = 0; i < N; i++) {\n        for (int j : qt[i]) {\n            last[j] = i;\n        }\n    }\n    int minLast = *min_element(last, last + n);\n    static bool cused[N];\n    for (int j = 0; j < minLast; j++) {\n        cused[perm[j]] = true;\n    }\n    int it = 0;\n    for (int j = minLast; j < len(perm); j++) {\n        while (cused[it]) {\n            it++;\n        }\n        if (it != perm[j]) {\n            puts(\"No\");\n            return 0;\n        }\n        it++;\n    }\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    vi b(q);\n\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n    reverse(ALL(b));\n    int k=1;\n    for(int i=0;i<q;i++){\n        if(b[i]==k){\n            k++;\n        }else if(b[i]!=k-1){\n            break;\n        }\n    }\n    vi cur(m+1,oo);\n    for(int i=q-1;i>=0;i--){\n        cur[b[i]]=i;\n    }\n    bool f=true;\n    int mx=cur[m];\n    for(int i=m-1;i>=1;i--){\n        if(cur[i]==oo){\n            if(mx!=oo)\n                f=false;\n        }else{\n            if(cur[i]>mx)\n                f=false;\n        }\n        inmin(mx,cur[i]);\n    }\n    if(f){\n        cout<<\"Yes\";\n        return;\n    }\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n            }\n        }\n    }\n\n\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n    for(int i=1;i<=m;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  if (0 <= tol && tol < m) {} else {\n    exit(0);\n  }\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (0 <= idx && idx < m) {} else {\n      exit(1);\n    }\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nint n, m, q;\nint a[100005];\nset<int> seen;\nint v[100005];\nint iv[100005];\nint r;\n\nint nw[100005];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &q);\n    FO(i,0,q) scanf(\"%d\", a+i);\n    reverse(a,a+q);\n    FO(i,0,q) {\n        if (!seen.count(a[i])) {\n            seen.insert(a[i]);\n            v[r++] = a[i];\n        }\n    }\n    FO(i,1,m+1) if (!seen.count(i)) {\n        v[r++] = i;\n    }\n\n    FO(i,0,m) {\n        printf(\"%d \", v[i]);\n        iv[v[i]] = i;\n    }\n    printf(\"\\n\");\n\n    nw[0] = n;\n\n    FO(i,0,q) {\n        int o = iv[a[i]];\n        if (nw[o]) {\n            nw[o]--;\n            nw[o+1]++;\n        }\n    }\n\n    bool bd = false;\n    for (int i = m-2; i >= 0; i--) {\n        if (v[i] > v[i+1]) bd = true;\n        if (bd && nw[i]) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i,x,n) for (int i = x;i < n;++i)\n\nvector<int> v[100000], V;\nint l[100001], x[100000];\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tf(i, 0, q)scanf(\"%d\", x + i);\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint d = l[x[i]];\n\t\tif (d == n)continue;\n\t\tif (!d)V.push_back(x[i]);\n\t\tv[l[x[i]]].push_back(x[i]);\n\t\t++l[x[i]];\n\t}\n\tint i = V.size();\n\tint j = 1;\n\twhile (l[j])++j;\n\tfor (--j; j > 0 && i; --j)if (V[i - 1] == j)--i;\n\tf(j, 0, n)f(k, 0, i)if (k >= v[j].size() || v[j][k] != V[k]) { printf(\"No\\n\"); return 0; }\n\tprintf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tC[P[k]]--;\n      }\n    }\n  }\n  if(F){\n    vector<int> V;\n    int K=0;\n    for(int i=0;i<m;i++){\n      if(P[i]==-1||C[P[i]]<n){\n\tV.push_back(i);\n      }\n      else{\n\tK++;\n      }\n    }\n    for(int i=K;i<N;i++){\n      if(T[i]!=V[i-K]){\n\tF=0;\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector<int> a(q);\n    for(int i=0; i<q; ++i){\n        cin >> a[i];\n        -- a[i];\n    }\n\n    vector<int> index(m, -1);\n    vector<int> cnt(m, 0);\n    vector<int> v;\n    for(int i=q-1; i>=0; --i){\n        if(index[a[i]] == -1){\n            index[a[i]] = v.size();\n            v.push_back(a[i]);\n        }\n        int j = index[a[i]];\n        if(j == 0 || cnt[v[j]] < cnt[v[j-1]])\n            ++ cnt[a[i]];\n    }\n\n    unsigned i = 0;\n    while(i < v.size() && cnt[v[i]] >= n)\n        ++ i;\n\n    int j = 0;\n    while(i < v.size()){\n        while(j < m && cnt[j] >= n)\n            ++ j;\n        if(v[i] != j){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        ++ i;\n        ++ j;\n    }\n\n    cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N, M, Q;\nvector<int> a;\n\nvoid Yes()\n{\n    puts(\"Yes\");\n    exit(0);\n}\n\nvoid No()\n{\n    puts(\"No\");\n    exit(0);\n}\n\nint main()\n{\n    cin >> N >> M >> Q;\n    a.resize(Q);\n    cin >> a;\n    reverse(a.begin(), a.end());\n\n    vector<int> tojojun;\n    map<int, int> tojojun_inv;\n    map<int, int> show_count;\n    for (auto v : a)\n    {\n        if (show_count.count(v) == 0)\n        {\n            tojojun_inv[v] = tojojun.size();\n            tojojun.push_back(v);\n            show_count[v] = 1;\n        }\n        else\n        {\n            if (tojojun_inv[v] == 0) show_count[v]++;\n            else\n            {\n                int v_prev = tojojun[tojojun_inv[v] - 1];\n                show_count[v] = min(show_count[v] + 1, show_count[v_prev]);\n            }\n        }\n    }\n\n    set<int> seen;\n    bool flg = false;\n    int counter = 1;\n    for (auto v : tojojun)\n    {\n        if (!flg) // これまで全部N以上\n        {\n            if (show_count[v] < N) flg = true;\n        }\n\n        if (flg)\n        {\n            while (seen.count(counter)) counter++;\n            if (v != counter) No();\n        }\n        seen.insert(v);\n    }\n    Yes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, M, Q;\nconst int _ = 100096;\nint a[_], r[_], id[_], s[_];\nbool vis[_];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tint t = 1;\t\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tif(a[i] >= t-1) t = a[i];\n\t}\n\tif(t == 1) return puts(\"Yes\"), 0;\n\tint c = 0;\n\tfor(int i = Q; i >= 1; --i)\n\t\tif(!vis[a[i]]) {\n\t\t\tr[++c] = a[i];\n\t\t\tvis[a[i]]= true;\n\t\t}\n\tfor(int i =1; i <= M; ++i)\n\t\tif(!vis[i]) r[++c] = i;\n\tfor(int i = 1; i <= M; ++i)\n\t\tid[r[i]] = i;\n\tint init = M;\n\tfor(;init > 1 && r[init] > r[init - 1]; -- init);\n\tint worst = init;\n\ts[init] = N;\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tint k = id[a[i]];\n\t\tif(s[k + 1]) {\n\t\t\ts[k + 1]--;\n\t\t\t++s[k];\n\t\t\tif(k + 1 == worst && !s[k + 1])\n\t\t\t\t--worst;\n\t\t} else {\n\t\t\tif(k > worst) {\n\t\t\t\t--s[worst];\n\t\t\t\t++s[worst = k];\n\t\t\t} \n\t\t}\n\t}\n\tputs(worst > 1? \"No\": \"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\n\nint t[100005];\nmap<int,int> m1;\nvector<int> v1,v2;//after,count\n\nint main(){\n\tint n,m,q;\n\tint i,j,k;\n\tint a,b,c;\n\tcin>>n>>m>>q;\n\tfor(i=0;i<q;i++){\n\t\tcin>>t[i];\n\t}\n\tv2.push_back(n);\n\tfor(i=q-1;i>=0;i--){\n\t\tif(m1.find(t[i])==m1.end()){\n\t\t\tm1[t[i]]=v2.size();\n\t\t\tv1.push_back(t[i]);\n\t\t\tv2.push_back(0);\n\t\t}\n\t\tb=m1[t[i]];\n\t\tif(v2[b-1]>0)v2[b]++,v2[b-1]--;\n\t}\n\tfor(i=1;i<=m+1;i++){\n\t\tif(m1.find(i)!=m1.end())continue;\n\t\tm1[i]=v1.size();\n\t\tv1.push_back(i);\n\t\tbreak;\n\t}\n\tint s=v2.back();\n\tfor(i=v1.size()-1;i>=0;i--){\n\t\tif(v1[i-1]>v1[i])break;\n\t\ts+=v2[i-1];\n\t}\n\tif(s==n)cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,nai=0;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tmultiset<int>las;//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las.ins(big);}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tvector<int>iti;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j>=numlis[no].size()){break;}\n\t\t\tauto it=las.lower_bound(numlis[no][j]);\n\t\t\tif(it==las.end()){break;}\n\t\t\titi.pub(numlis[no][j]);\n\t\t\tlas.erase(it);\n\t\t}\n\t\tif(j<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;j<n-nai;j++){\n\t\t\tauto it=las.lower_bound(-1);\n\t\t\titi.pub(-999);\n\t\t\tlas.erase(it);\n\t\t\tnai++;\n\t\t}\n\t\twhile(iti.size()!=0){las.ins(iti.back());iti.pob();}\n\t\t//cout<<endl<<\"de i=\"<<i;\n\t\t//for(auto it=las.begin();it!=las.end();it++){cout<<\" \"<<(*it);}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  VI inv_t(m);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (0 <= idx && idx < m) {} else {\n      exit(1);\n    }\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, Q;\nint L;\nint A[100000];\nint B[100000];\nint prog[100000];\nint cnt[100001];\n\nint main()\n{\n    memset(prog, -1, sizeof prog);\n    memset(B, -1, sizeof B);\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    for(int i=0; i<Q; i++)\n        scanf(\"%d\", A+i), A[i]--;\n    L=0;\n    cnt[0]=N;\n    for(int i=Q-1; i>=0; i--)\n    {\n        int x=A[i];\n        if(prog[x]==-1)\n        {\n            B[L]=x;\n            prog[x]=L++;\n        }\n        if(cnt[prog[x]]>0)\n            cnt[prog[x]]--, cnt[prog[x]+1]++;\n    }\n    int idx=0;\n    for(int i=L-1; i>=1; i--)\n    {\n        if(B[i-1]>B[i])\n        {\n            idx=i;\n            break;\n        }\n    }\n    for(int i=0; i<idx; i++) if(cnt[i]>0)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    printf(\"Yes\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tvector<ll> not_comp;\n\tREP(i, m) if(!dict.count(i) || cnt[dict[i]] != n) not_comp.pb(i);\n\tsort(ALL(not_comp));\n\tll tmp = 0;\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(idx[i] != not_comp[tmp]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n\n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\n#include \"Union_Find.h\"\n\nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n\nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n\n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint a[SIZE];\nint d[SIZE],u[SIZE],dn,now[SIZE];\nVI p[SIZE];\nint main(){\n    DRIII(N,M,Q);\n    REP(i,Q)RI(a[Q-1-i]);\n    int one=-1;\n    REP(i,Q){\n        p[a[i]].PB(i);\n        if(!u[a[i]]){\n            u[a[i]]=1;\n            if(a[i]==M)one=dn;\n            d[dn++]=a[i];\n        }\n    }\n    if(one!=-1){\n        bool suc=1;\n        int now=1;\n        REPP(i,one,dn){\n            while(now<=M&&u[now]&&p[now][0]<one)now++;\n            if(d[i]!=now)suc=0;\n        }\n        if(suc)dn=one;\n    }\n    MS1(now);\n    REP(i,dn){\n        int it=0;\n        REP(j,N){\n            while(it<SZ(p[d[i]])&&p[d[i]][it]<=now[j])it++;\n            if(it>=SZ(p[d[i]])){\n                puts(\"No\");\n                return 0;\n            }\n            now[j]=p[d[i]][it++];\n        }\n    }\n\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,nai=0;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tmultiset<int>las;//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las.ins(big);}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tvector<int>iti;\n\t\tint x=0;\n\t\tfor(j=0;j<numlis[no].size()&&x<n;j++){\n\t\t\tauto it=las.lower_bound(numlis[no][j]);\n\t\t\tif(it==las.end()){continue;}\n\t\t\tx++;//成功数\n\t\t\titi.pub(numlis[no][j]);\n\t\t\tlas.erase(it);\n\t\t}\n\t\tif(x<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;x<n-nai;x++){\n\t\t\tauto it=las.lower_bound(-1);\n\t\t\titi.pub(-999);\n\t\t\tlas.erase(it);\n\t\t\tnai++;\n\t\t}\n\t\twhile(iti.size()!=0){las.ins(iti.back());iti.pob();}\n\t\t//cout<<endl<<\"de i=\"<<i;\n\t\t//for(auto it=las.begin();it!=las.end();it++){cout<<\" \"<<(*it);}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint m;\nint q;\n\nint a[MAX];\n\nset<int> s;\ndeque<int> v;\nbool can[MAX];\n\nmultiset<int> mp;\nint id[MAX];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\treverse(a, a + q);\n\tfor (int i = 0; i < q; i++){\n\t\tif (s.count(a[i])==0){\n\t\t\tv.push_back(a[i]);\n\t\t\ts.insert(a[i]);\n\t\t}\n\t}\n\tfor (int i = m; i >= 1; i--){\n\t\tif (s.count(i) == 0){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tint maxx = INT_MAX;\n\tcan[v.size()] = true;\n\tfor (int i = v.size() - 1; i >= 0; i--){\n\t\tif (maxx > v[i]){\n\t\t\tmaxx = v[i];\n\t\t\tcan[i] = true;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\ts.clear();\n\tfor (int i = 0; i < v.size(); i++){\n\t\tid[v[i]] = i;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmp.insert(0);\n\t}\n\tint L = -1;\n\tfor (int i = 0; i < q; i++){\n\t\tint ID = id[a[i]];\n\t\tif (mp.count(ID)){\n\t\t\tauto k = mp.find(ID);\n\t\t\tmp.erase(k);\n\t\t\tmp.insert(ID + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ID <= L){\n\t\t\tcontinue;\n\t\t}\n\t\tL = max(L, ID);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (can[(*it)] == false){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include<iostream>\n        #include<string>\n        #include<vector>\n        #include<algorithm>\n        #include<math.h>\n        #include<map>\n         \n        #define rep(i,n,m) for(int i=n;i<(int)(m);i++)\n         \n        using namespace std;\n         \n        int main() {\n         int n,m,q;\n     \n    cin >>n>>m>>q;\n    vector<int>num(q);\n    rep(i,0,q){\n    cin>>num[i];\n    }\n     \n    if(m%2==0)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n     \n     \n        \t\n        \treturn 0;\n        }"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint vis[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    mem(vis, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n        vis[a[i]] = 1;\n        if (a[i] == mark) {\n            while (vis[mark]) mark++;\n            ans[n] = i;\n            for (int j = i; j > 0; j = f[j]) flag[j] = 1;\n            continue;\n        }\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) return 0;\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  if(F){\n    for(int i=0;i<m&&F;i++){\n      if(P[i]!=-1&&C[P[i]]<n){\n\tint j=(P[i]<N-1?T[P[i]+1]:m);\n\tif(j<i){\n\t  F=0;\n\t}\n\telse{\n\t  for(int x=i+1;x<j;x++){\n\t    if(P[x]==-1){\n\t      F=0;\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 200200;\nint a[maxn];\nvector<int> pos[maxn];\nbool used[maxn];\nint cnt[maxn];\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m, q;\n    cin >> n >> m >> q;\n    forn (i, q) {\n        cin >> a[i];\n        --a[i];\n        pos[a[i]].push_back(i);\n    }\n    vector<int> p;\n    for (int i = q - 1; i >= 0; --i) {\n        if (used[a[i]])\n            continue;\n        int val = a[i];\n        used[val] = true;\n        p.push_back(val);\n    }\n    forn (i, m)\n        if (!used[i])\n            p.push_back(i);\n    assert(sz(p) == m);\n    int pr = 0;\n    //forn (i, m)\n        //cerr << p[i] << ' ';\n    //cerr << '\\n';\n    forn (i, m - 1)\n        if (p[i] > p[i + 1])\n            pr = i + 1;\n    vector<int> rp(m);\n    forn (i, m)\n        rp[p[i]] = i;\n    cnt[p[0]] = n;\n    bool shit = false;\n    for (int i = q - 1; i >= 0; --i) {\n        int val = a[i];\n        if (cnt[val] == 0 && !shit) {\n            cout << \"No\\n\";\n            return 0;\n        }\n        --cnt[val];\n        int pos = rp[val];\n        if (pos == m - 1)\n            shit = true;\n        else\n            cnt[p[pos + 1]]++;\n    }\n    forn (i, pr) {\n        if (cnt[p[i]] > 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvector<int> vec;\nint freq[100001];\nvi a;\nvi inv;\nbool visited[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, q;\n\tcin >> n >> m >> q; vec.resize(q);\n\tswap(n, m);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tcin >> vec[i]; vec[i]--;\n\t}\n\tfreq[0] = n;\n\treverse(vec.begin(), vec.end());\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(!visited[vec[i]])\n\t\t{\n\t\t\tvisited[vec[i]] = 1;\n\t\t\ta.pb(vec[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!visited[i]) a.pb(i);\n\t}\n\t//cerr << a.size() << ' ' << n << '\\n';\n\tinv.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tinv[a[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint f = inv[vec[i]];\n\t\tif(freq[f])\n\t\t{\n\t\t\tfreq[f]--; freq[f+1]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"No\"; return 0;\n\t\t}\n\t}\n\tint idx = 0;\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tif(freq[i])\n\t\t{\n\t\t\tidx = i; break;\n\t\t}\n\t}\n\tfor(int i = idx; i < n - 1; i++)\n\t{\n\t\tif(vec[i] >= vec[i+1]) {cout << \"No\"; return 0;}\n\t}\n\tcout << \"Yes\"; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N, M, Q;\nvector<int> a;\n\nvoid Yes()\n{\n    puts(\"Yes\");\n    exit(0);\n}\n\nvoid No()\n{\n    puts(\"No\");\n    exit(0);\n}\n\nint main()\n{\n    cin >> N >> M >> Q;\n    a.resize(Q);\n    cin >> a;\n    reverse(a.begin(), a.end());\n\n    vector<int> tojojun;\n    map<int, int> tojojun_inv;\n    map<int, int> show_count;\n    for (auto v : a)\n    {\n        if (show_count.count(v) == 0)\n        {\n            tojojun_inv[v] = tojojun.size();\n            tojojun.push_back(v);\n            show_count[v] = 1;\n        }\n        else\n        {\n            if (tojojun_inv[v] == 0) show_count[v]++;\n            else\n            {\n                int v_prev = tojojun[tojojun_inv[v] - 1];\n                show_count[v] = min(show_count[v] + 1, show_count[v_prev]);\n            }\n        }\n    }\n\n    int counter = 0;\n    for (auto v : tojojun)\n    {\n        if (counter == 0 and show_count[v] >= N)\n        {\n            if (v == counter + 1) counter++;\n            continue;\n        }\n        else if (v == counter + 1) counter++;\n        else No();\n    }\n\n    Yes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint la[101010];\nint p[101010];\nint a[101010];\nbool vis[101010];\nint d[101010];\nint main()\n{\n\tint n,m,q,mi=1,cnt,lcnt,nowv,ii;\n\tbool mk=false;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tmemset(la,0,sizeof(la));\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tp[i]=la[a[i]];\n\t\tla[a[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=q+1;\n\tcnt=n;\n\tfor(int i=q;i>=1;i--)\n\t\tif(a[i])\n\t\t{\n\t\t\tlcnt=cnt;\n\t\t\tcnt=0;\n\t\t\tnowv=a[i];\n\t\t\tii=i;\n\t\t\twhile(a[ii])\n\t\t\t{\n\t\t\t\tif(cnt<lcnt)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif(ii<d[cnt])\n\t\t\t\t\t\td[cnt]=ii;\n\t\t\t\t\telse\n\t\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t\ta[ii]=0;\n\t\t\t\tii=p[ii];\n\t\t\t}\n\t\t\tif(cnt!=n)\n\t\t\t{\n\t\t\t\twhile(vis[mi])\n\t\t\t\t\tmi++;\n\t\t\t\tif(mi!=nowv)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[nowv]=true;\n\t\t}\n\tprintf(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nvector<int> t,co;\nint dp[MAX];\nint cz[MAX];\nint il = 0;\nint kt[MAX];\nint n,m,q;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    int pom;\n    cin >> pom;\n    pom--;\n    t.PB(pom);\n  }\n  reverse(ALL(t));\n  for(int el:t){\n    if(!cz[el]){\n      cz[el] = 1;\n      kt[el] = il;\n      il++;\n      co.PB(el);\n    }\n    int pom = kt[el];\n    dp[pom]++;\n    if(pom != 0)\n      mini(dp[pom],dp[pom-1]);\n  }\n  int naj = 0;\n  while(cz[naj])naj++;\n  debug(naj);\n  if(cz[0] && naj > co.back()){\n    int pom = il - 1;\n    while(co[pom] != 0 && co[pom] > co[pom-1])\n      pom--;\n    debug(pom);\n    if(co[pom] == 0)\n      il = pom;\n  }\n  debug(il);\n  if(il == 0 || dp[il-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nint main()\n{\n\tios_init();\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tint q;\n\t\tcin >> q;\n\t\tvector<int> a(q);\n\t\tREP(i,q) cin >> a[i], a[i]--;\n\t\tvector<int> v;\n\t\tv.reserve(m);\n\t\tvector<bool> f(m,false);\n\t\tRREP(i,q){\n\t\t\tif(!f[a[i]]){\n\t\t\t\tf[a[i]] = true;\n\t\t\t\tv.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tREP(i,q){\n\t\t\tif(!f[i]){\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint p = SZ(v)-1;\n\t\tRREP(i,SZ(v)-1){\n\t\t\tif(v[i+1] > v[i]){\n\t\t\t\tp--;\n\t\t\t}else break;\n\t\t}\n\t\tvector<int> mp(m,0);\n\t\tREP(i,SZ(v)){\n\t\t\tmp[v[i]] = i;\n\t\t}\n\t\tvector<int> cntv(m,0);\n\t\tRREP(i,q){\n\t\t\tif(mp[a[i]] == 0 or cntv[mp[a[i]]] < cntv[mp[a[i]]-1]){\n\t\t\t\tcntv[mp[a[i]]]++;\n\t\t\t}else{\n\n\t\t\t}\n\t\t}\n\t\tstring ans = \"Yes\";\n\t\tdpite(ALL(cntv));\n\t\tREP(i,p){\n\t\t\tif(cntv[i] < n){\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nint n,m,q;\nint t[MAX];\nvector<int> wyg;\nbool cz[MAX];\nvoid tak(){\n  cout << \"Yes\\n\";\n  exit(0);\n}\nint dp[MAX],gd[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    cin >> t[i];\n    t[i]--;\n  }\n  for(int i = q-1;i >= 0;i--){\n    if(!cz[t[i]]){\n      cz[t[i]] = 1;\n      gd[t[i]] = SZ(wyg);\n      wyg.PB(t[i]);\n    }\n  }\n  if(cz[0]){\n    bool ok = 1;\n    int pom = gd[0];\n    while(1){\n      pom ++;\n      if(pom == SZ(wyg)){\n        wyg.resize(gd[0]);\n      }\n      if(wyg[pom] != wyg[pom-1] + 1)break;\n    }/*\n    R(i,SZ(wyg)){\n      if(wyg[i] != i)ok = 0;\n    }\n    if(ok)tak();*/\n  }\n  for(int i = q-1;i >= 0;i--){\n    int pom = gd[t[i]];\n    if(pom == 0)\n      dp[pom]++;\n    else\n      dp[pom] = min(dp[pom]+1, dp[pom-1]);\n  }\n  if(SZ(wyg) == 0 || dp[SZ(wyg)-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <Windows.h>\n#include <stdio.h>\nconst int max0=100010;\nint n,m,a,i;\n\tint count[max0],data[max0],ans[max0],top;\n\tint dic[max0],p1;\n\tbool had[max0],wrong;\nint main()\n{\n\n\tscanf(\"%d%d%d\",&n,&m,&a);\n\tfor(i=0;i<a;i++)\n\t\tscanf(\"%d\",&data[i]);\n    p1=-1;\n\tfor(i=a-1;i>=0;i--)\n\t\tif(had[data[i]]==0){\n                had[data[i]]=1,ans[top++]=data[i];\n                if(data[i]==1)p1=top;\n\t\t}\n    //printf(\"!%d %d %d\\n\",top,ans[1],p1);\n\tif(p1!=-1)\n    {\n        for(i=p1;i<top;i++)\n            if(ans[i]!=i-p1+2)break;\n        if(i==top)top=p1-1;\n    }\n    //printf(\"!%d\\n\",top);\n\tfor(i=top-1;i>=1;i--)dic[ans[i]]=ans[i-1];\n\tfor(i=a-1;i>=0;i--){\n\t\tcount[data[i]]++;\n\t\tif(dic[data[i]]!=0)\n\t\t\tif(count[data[i]]>count[dic[data[i]]])\n\t\t\t\tcount[data[i]]=count[dic[data[i]]];\n\t}\n\tif(top!=0&&count[ans[top-1]]<n)printf(\"No\\n\");\n\telse \tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tfor(long long i = mini + 1; i < M; i++){\n\t\tif(ans[i] != i){\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,Q;\nint A[101010];\nint did[101010];\nint index[101010];\nvector<int> V;\nint num[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tdid[A[i]]++;\n\t\tif(did[A[i]]==1) {\n\t\t\tindex[A[i]]=V.size();\n\t\t\tV.push_back(A[i]);\n\t\t}\n\t}\n\tif(1LL*V.size()*M>Q) return _P(\"No\\n\");\n\tnum[0]=M;\n\tfor(i=Q-1;i>=0;i--) {\n\t\tif(num[index[A[i]]]) {\n\t\t\tnum[index[A[i]]]--;\n\t\t\tnum[index[A[i]]+1]++;\n\t\t}\n\t}\n\tif(num[V.size()]==M) _P(\"Yes\\n\");\n\telse _P(\"No\\n\");\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n \nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (j > cur[k]) ans = false;\nif (cur[k] < 0) break;\t\t\tcur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool allappeared[100050];\nint a[100050];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    allappeared[0] = true;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared[a[i] - 1]) allappeared[a[i]] = true;\n    }\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    /*\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        cerr << val[i] << endl;\n    }\n    */\n    num[0] = 1e9;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], N);\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    for(int i = 1; i <= index; i++) {\n        if(num[i] != N) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0],n){\n\t\tif(v[i]!=i-pos[0]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\twhile(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse{\n\t\t\tif(pos[a[i]]>0){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\tnum[lo]--;num[1]++;lo=1;\n\t\t}\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nvector<int> ord;\nint markn[N], a[N], cnt[N], pl[N];\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n        a[i]--;\n    }\n    cnt[0] = n;\n    for (int i = q - 1; i >= 0; --i) {\n        if (!markn[a[i]]++) {\n            ord.push_back(a[i]);\n        }\n    }\n    for (int i = m - 1; i >= 0; --i)\n        if (!markn[i]++) {\n            ord.push_back(i);\n        }\n    for (int i = 0; i < m; ++i)\n        pl[ord[i]] = i;\n    for (int i = q - 1; i >= 0; --i) {\n        if (cnt[pl[a[i]]] == 0 && cnt[pl[a[i]] + 1] == 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n        if (cnt[pl[a[i]]] == 0) continue;\n        cnt[pl[a[i]]]--;\n        cnt[pl[a[i]] + 1]++;\n    }\n    int sr = 0;\n    for (int i = m - 2; i >= 0; --i) {\n        if (ord[i + 1] < ord[i]) {\n            sr = i + 1;\n            break;\n        }\n    }\n    for (int i = 0; i < sr; ++i) {\n        if (cnt[i] > 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vec a(Q);\n    for(int i=0;i<Q;i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vector<int> final;\n    vector<int> que(M + 1, 0);\n    vector<int> next(M, -1);\n\n    que[M] = N - 1;\n\n    bool done = false, fail = false;\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(used[a[p]]){\n\n            }else{\n                used[a[p]] = true;\n                if(final.size() > 0) next[final[final.size() - 1]] = a[p];\n                final.push_back(a[p]);\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n        // cout << \"p:\" << p << \" a[p]:\" << a[p] << endl;\n        // for(int pp: que){\n        //     cout << pp << \" \";\n        // }\n        // cout << endl;\n    }\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int M=1e5+10;\nconst int Q=1e5+10;\n\nint n,m,q,a[Q];\nbool vis[M];\nmultiset<int> s[M];\n\nbool solve() {\n    VI v;\n    for ( int i=q; i>=1; i-- ) if ( !vis[a[i]] ) {\n        vis[a[i]]=1;\n        v.PB(a[i]);\n    }\n    REP1(i,1,m) if ( !vis[i] ) v.PB(i);\n    assert(SZ(v)==m);\n    int g=n-1;\n    while ( g>0 && v[g]>v[g-1] ) g--;\n    dump(g,v);\n    REP1(i,1,n) s[a[q]].insert(0);\n    for ( int i=q; i>=1; i-- ) {\n        int x=a[i];\n        if ( s[x].empty() ) continue;\n        int t=*s[x].begin();\n        s[x].erase(s[x].begin());\n        if ( t+1==m ) continue;\n        s[v[t+1]].insert(t+1);\n    }\n    REP1(i,1,m) for ( int j:s[i] ) if ( j<g ) return 0;\n    return 1;\n}\n\nint main() {\n    R(n,m,q);\n    REP1(i,1,q) R(a[i]);\n    bool ans=solve();\n    W(ans?\"Yes\":\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,nai=0;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tmultiset<int>las;//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las.ins(big);}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tvector<int>iti;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j>=numlis[no].size()){break;}\n\t\t\tauto it=las.lower_bound(numlis[no][j]);\n\t\t\t//if(it==las.end()){cout<<j<<\"sglhf\"<<endl;break;}\n\t\t\titi.pub(*it);\n\t\t\tlas.erase(it);\n\t\t}\n\t\tif(j<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;j<n-nai;j++){\n\t\t\tauto it=las.lower_bound(-1);\n\t\t\titi.pub(-999);\n\t\t\tlas.erase(it);\n\t\t\tnai++;\n\t\t}\n\t\twhile(iti.size()!=0){las.ins(iti.back());iti.pob();}\n\t\t//cout<<endl<<\"de i=\"<<i;\n\t\t//for(auto it=las.begin();it!=las.end();it++){cout<<\" \"<<(*it);}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "/*\nSometimes I feel like I don't have a partner\nSometimes I feel like my only friend\nIt's the city I live in, the City of Angels\nLonely as I am, together we cry\n\nI drive on her streets 'cause she's my companion\nI walk through her hills cause she knows who I am\nShe sees my good deeds and she kisses me windy\nI never worry, now that is a lie\n\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah\n\nIt's hard to believe that there's nobody out there\nIt's hard believe that I'm all alone\nAt least I have her love the city, she loves me\nLonely as I am, together we cry\n\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, love me I say yeah, yeah\n\nUnder the bridge downtown is where I drew some blood\nUnder the bridge downtown I could not get enough\nUnder the bridge downtown forgot about my love\nUnder the bridge downtown I gave my life away\nYeah, yeah, yeah\n\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, oh, no, no\nI said yea yeah, Ill stay\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 500031;\n\nint n, m, Q;\nint ar[N];\nint last_entry[N];\n\nint whr[N], cnt[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> m >> Q;\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tcin >> ar[i];\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tlast_entry[i] = -i;\n\t}\n\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tlast_entry[ar[i]] = i;\n\t}\n\n\tvector<pair<int,int> > order;\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\torder.push_back(make_pair(last_entry[i], i));\n\t}\n\n\tsort(order.begin(), order.end());\n\treverse(order.begin(), order.end());\n\t/*for (int i = 0; i < order.size(); i++)\n\t{\n\t\tif (i>0)\n\t\t\tcout << \" \";\n\t\tcout << order[i].second;\n\t\twhr[order[i].second] = i;\n\t}\n\tcout << endl;\n\t*/\n\tfor (int i = Q; i; --i)\n\t{\n\t\tint val = ar[i];\n\t\tint ps = whr[val];\n\t\tcnt[ps]++;\n\t\tif (ps > 0 && cnt[ps] > cnt[ps - 1])\n\t\t\tcnt[ps]--;\n\t}\n\n\tint q = m - 1;\n\twhile (q > 0 && order[q].second > order[q - 1].second)\n\t\t--q;\n\n\tif (q == 0 || cnt[q-1] >= n)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q,Min;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\n\tMin=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(c[i]==0){\n\t\t\tMin=i; break;\n\t\t}\n\t} \n\t\n\tfor(int i=0; i<Q; i++){\n\t\tif(c[a[i]]>=N) g[a[i]]=1;\n\t\telse{\n\t\t\tif(Min<a[i]){\n\t\t\t\tcout<<\"No\"<<endl; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tif(d[1]) e[1]=d[1];\n\n\tfor(int i=2; i<=M; i++){\n\n\t\tif(d[i]==0) e[i]=INF;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]>=e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=e[i-1];\n\t\t}\n\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]==0) f[i]=1;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi EN(q, 1);\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n    if(E[A[i]]<n) EN[i]=0;\n  }\n  int endV = S.back();\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV+1) if(S[S.size()-1-i] != endV-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  if(S.empty()) goto ok;\n  for(int i : S) if(E[i]<n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tArray a(q);\n\tREP(i, q)cin >> a[i], a[i]--;\n\n\treverse(all(a));\n\tArray cnt(m, 0);\n\tArray pre(m, -1);\n\tll last = -1;\n\n\tArray used(m, 0);\n\tArray p;\n\n\tREP(i, q) {\n\t\tif (cnt[a[i]] == 0) {\n\t\t\tp.push_back(a[i]);\n\t\t\tused[a[i]] = 1;\n\t\t\tcnt[a[i]]++;\n\t\t\tpre[a[i]] = last;\n\t\t\tlast = a[i];\n\t\t}\n\t\telse if (pre[a[i]] == -1 || cnt[pre[a[i]]] > cnt[a[i]])cnt[a[i]]++;\n\t}\n\tREP(i, m)if (used[i] == 0)p.push_back(i);\n\tREP(i, m) {\n\t\tif (cnt[p[i]] < n) {\n\t\t\trep(j, i + 1, m) {\n\t\t\t\tif (p[j] < p[j - 1]) {\n\t\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(x) (int((x).size()))\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\ntemplate<typename T> bool domax(T &a, T b) { return (b > a ? (a = b, true) : false); }\ntemplate<typename T> bool domin(T &a, T b) { return (b < a ? (a = b, true) : false); }\ntypedef long long ll;\n\nconst int maxn = 100*1000+5;\n\nint n, m, q, a[maxn], place[maxn], next[maxn];\nstd::vector<int> l[maxn];\nbool seen[maxn];\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &q);\n    for (int i = 0; i < q; i++) scanf(\"%d\", a+i);\n    for (int i = q-1; i >= 0; i--) {\n        int v = a[i];\n        if (!seen[v]) {\n            seen[v] = true;\n            place[v] = sz(l[0]);\n            l[next[v]++].pb(v);\n        } else if (next[v] < n) {\n            if (place[v] != sz(l[next[v]])) {\n                printf(\"No\\n\");\n                exit(0);\n            }\n            l[next[v]++].pb(v);\n        }\n    }\n    std::fill(seen, seen+m+1, false);\n    for (int &i : l[n-1]) seen[i] = true;\n    for (int j = 1; j <= m; j++) if (!seen[j]) l[n-1].pb(j);\n    for (int i = n-2; i >= 0; i--) {\n        for (int k = 0; k < sz(l[i]); k++) if (l[i][k] != l[n-1][k]) {\n            printf(\"No\\n\");\n            exit(0);\n        }\n    }\n    printf(\"Yes\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<string>\n    #include<vector>\n    #include<algorithm>\n    #include<math.h>\n    #include<map>\n     \n    #define rep(i,n,m) for(int i=n;i<(int)(m);i++)\n     \n    using namespace std;\n     \n    int main() {\n     int n,m,q;\n\ncin >>>n>>m>>q;\nvector<int>num(q);\nrep(i,0,q){\ncin>>num[i];\n}\n\nif(m%2==)cout<<\"Yes\"<<endl;\nelse cout<<\"No\"<<endl;\n\n\n    \t\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n\n#undef __STRICT_ANSI__\n\n#include <cstdlib>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <cassert>\n\nusing namespace std;\n\n#undef assert\n#define assert(e)\n\n#include <cstdarg>\n\nvoid infoln() {\n\tfputc('\\n', stderr);\n}\nvoid infoln(const char * fmt, ...) {\n\tva_list arg;\n\tva_start(arg, fmt);\n\tvfprintf(stderr, fmt, arg);\n\tva_end(arg);\n\tinfoln();\n}\n\n#include <sys/time.h>\n\nclass XsRandom {\n\tunsigned long long a;\n\tunsigned long long b;\npublic:\n\tinline XsRandom() : a(0x8a5cd789635d2dffULL), b(0x121fd2155c472f96ULL) {\n\t}\n\tinline XsRandom(const XsRandom & o) : a(o.a), b(o.b) {\n\t}\n\tinline unsigned long long next64() {\n\t\tunsigned long long c = a ^ (a<<23);\n\t\ta = b;\n\t\tb = c ^ a ^ (c>>18) ^ (a>>5);\n\t\treturn b + a;\n\t}\n\tinline XsRandom(unsigned int seed) : a(0x8a5cd789635d2dffULL), b(0x121fd2155c472f96ULL) {\n\t\tseed = seed * 1234567891 + 521288629;\n\t\tunsigned long long a2 = a;\n\t\tunsigned long long b2 = b;\n\t\twhile(seed) {\n\t\t\tnext64();\n\t\t\tif(seed & 1) {\n\t\t\t\ta2 ^= a;\n\t\t\t\tb2 ^= b;\n\t\t\t}\n\t\t\tseed >>= 1;\n\t\t}\n\t\ta = a2;\n\t\tb = b2;\n\t}\n\tinline unsigned int next() {\n\t\treturn (unsigned int)next64();\n\t}\n\tinline int nextInt(int r) {\n\t\tassert(1<=r);\n\t\treturn ((unsigned long long)next() * r)>>32;\n\t}\n};\n\ntypedef XsRandom MyRandom;\n\nMyRandom g_myRand;\n\ndouble g_startTime;\ndouble g_suspendTime = 0;\nconst double g_timeupSecBase = 9.8;\ndouble g_timeupSec = g_timeupSecBase;\n\n#include <numeric>\n\nconst char * nextCLineOrWord(int mode) {\n\tstatic char buf[65536];\n\tstatic int bufLen = sizeof(buf);\n\tstatic int bufPos = sizeof(buf);\n\tstatic bool canReadFlag = true;\n\tstatic bool crFlag = false;\n\tstatic bool enterFlag = false;\n\tif(canReadFlag && (enterFlag ? bufLen<=bufPos : (int)sizeof(buf)<=bufPos+bufPos)) {\n\t\tif(0<bufLen-bufPos) {\n\t\t\tmemmove(buf, buf+bufPos, bufLen-bufPos);\n\t\t\tbufLen -= bufPos;\n\t\t}\n\t\telse {\n\t\t\tbufLen = 0;\n\t\t}\n\t\tchar * result = fgets(buf+bufLen, sizeof(buf)-bufLen, stdin);\n\t\tcanReadFlag = (result!=NULL);\n\t\tif(result!=NULL) {\n\t\t\tint n = strlen(result);\n\t\t\tenterFlag = (n!=(int)sizeof(buf)-1-bufLen || (1<=bufLen+n && buf[bufLen+n-1]=='\\n'));\n\t\t\tbufLen += n;\n\t\t}\n\t\tbufPos = 0;\n\t}\n\tif(mode==0) {\n\t\tint pos = bufPos;\n\t\twhile(true) {\n\t\t\tchar c = buf[pos];\n\t\t\tif(c==32) {\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==10) {\n\t\t\t\tif(crFlag) {\n\t\t\t\t\tcrFlag = false;\n\t\t\t\t\tif(bufPos==pos) {\n\t\t\t\t\t\tpos = ++bufPos;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==13) {\n\t\t\t\tcrFlag = true;\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pos;\n\t\t}\n\t\tconst char * ret = buf + bufPos;\n\t\tbufPos = pos;\n\t\twhile(true) {\n\t\t\tchar c = buf[bufPos];\n\t\t\tif(c==32 || c==10 || c==13) {\n\t\t\t\t++bufPos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\telse if(mode==1) {\n\t\tint pos = bufPos;\n\t\twhile(true) {\n\t\t\tchar c = buf[pos];\n\t\t\tif(c==10) {\n\t\t\t\tif(crFlag) {\n\t\t\t\t\tcrFlag = false;\n\t\t\t\t\tif(bufPos==pos) {\n\t\t\t\t\t\tpos = ++bufPos;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==13) {\n\t\t\t\tcrFlag = true;\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pos;\n\t\t}\n\t\tconst char * ret = buf + bufPos;\n\t\tbufPos = pos;\n\t\treturn ret;\n\t}\n\telse if(mode==2) {\n\t\treturn bufLen<=bufPos ? NULL : buf+bufPos;\n\t}\n\tassert(false);\n\treturn NULL;\n}\n\nconst char * nextCWord() {\n\treturn nextCLineOrWord(0);\n}\n\nint nextInt() {\n\treturn atoi(nextCWord());\n}\n\nvector<int> nextIntVec(int n) {\n\tvector<int> ret;\n\tfor(int i=0; i<n; ++i) {\n\t\tret.push_back(nextInt());\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N = nextInt();\n\tint M = nextInt();\n\tint Q = nextInt();\n\tvector<int> a = nextIntVec(Q);\n\treverse(a.begin(), a.end());\n\tvector<int> b;\n\tvector<int> dic(M+1, -1);\n\t{\n\t\tset<int> s;\n\t\tfor(int i : a) {\n\t\t\tif(s.find(i)==s.end()) {\n\t\t\t\ts.insert(i);\n\t\t\t\tb.push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=M+1; ++i) {\n\t\t\tif(s.find(i)==s.end()) {\n\t\t\t\tb.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint sz = 0;\n\t\tfor(int i=1; i<b.size(); ++i) {\n\t\t\tif(b[i]<b[i-1]) {\n\t\t\t\tsz = i;\n\t\t\t}\n\t\t}\n\t\tb.resize(sz);\n\t\tfor(int i=0; i<b.size(); ++i) {\n\t\t\tdic[b[i]] = i;\n\t\t}\n\t}\n\tvector<int> q(b.size()+1);\n\tq[0] = N;\n\tfor(int i : a) {\n\t\tint j = dic[i];\n\t\tif(0<=j) {\n\t\t\tif(q[j]) {\n\t\t\t\t--q[j];\n\t\t\t\t++q[j+1];\n\t\t\t}\n\t\t}\n\t}\n\tinfoln(q[b.size()]==N ? \"Yes\" : \"No\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,M,Q;\nint a[MAXN],pos[MAXN],reserve[MAXN];\nbool vis[MAXN];\nvector<int> v;\nvoid Solve() {\n    read(N);read(M);read(Q);\n    v.pb(0);\n    for(int i = 1 ; i <= Q ; ++i) {read(a[i]);}\n    for(int i = Q ; i >= 1 ; --i) {\n\tif(!vis[a[i]]) {\n\t    v.pb(a[i]);\n\t    vis[a[i]] = 1;\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(!vis[i]) v.pb(i);\n    }\n    for(int i = 1 ; i <= M ; ++i) pos[v[i]] = i;\n    int p = M;\n    while(p > 1 && v[p - 1] < v[p]) --p;\n    if(p == 1) {puts(\"Yes\");return;}\n    for(int i = Q ; i >= 1 ; --i) {\n\tif(a[i] == v[1]) reserve[1]++;\n\telse {\n\t    if(reserve[pos[a[i]] - 1]) {\n\t\treserve[pos[a[i]] - 1]--;\n\t\treserve[pos[a[i]]]++;\n\t    }\n\t}\n    }\n    int res = 0;\n    for(int i = p - 1 ; i <= M ; ++i) {\n\tres += reserve[i];\n    }\n    if(res >= N) {puts(\"Yes\");return;}\n    else {puts(\"No\");return;}\n}\n\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,doc=7;cin>>n>>m>>q;doc=n;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t}\n\t\tif(numlis[no].size()<n){\n\t\t\twhile(mita[zyu]){zyu++;}\n\t\t\tif(zyu!=no){cout<<\"No\"<<endl;return 0;}\n\t\t}\n\t\tmita[no]=true;\n\t\tfor(j=numlis[no].size();j<doc;j++){las[j]=-999;}\n\t\tdoc=numlis[no].size();\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 100100;\nint n, m, q;\nint a[N];\nint pos[N];\nint len[N];\nint cnt[N];\nint b[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < q; i++)\n\t\tscanf(\"%d\", &a[i]);\n\treverse(a, a + q);\n\tfor (int i = 1; i <= m; i++)\n\t\tpos[i] = -1;\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint x = a[i];\n\t\tif (pos[x] == -1)\n\t\t{\n\t\t\tpos[x] = len[0];\n\t\t\tb[len[0]] = x;\n\t\t\tlen[0]++;\n\t\t\tcnt[x] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint y = cnt[x];\n\t\t\tif (y >= n) continue;\n\t\t\tif (len[y] < pos[x]) continue;\n\t\t\tlen[y]++;\n\t\t\tcnt[x]++;\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", len[i]);\n\tprintf(\"\\n\");\n\tfor (int i = 0; i < len[0]; i++)\n\t\tprintf(\"%d \", b[i]);\n\tprintf(\"\\n\");\n\t*/\n\tint minUnused = m + 1;\n\tfor (int x = 1; x <= m; x++)\n\t\tif (pos[x] == -1)\n\t\t{\n\t\t\tminUnused = x;\n\t\t\tbreak;\n\t\t}\n\tint L = len[0];\n\twhile(L > 0 && b[L - 1] < minUnused)\n\t{\n\t\tL--;\n\t\tminUnused = b[L];\n\t}\n\tbool ok = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tok &= len[i] >= L;\n\tif (ok)\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nbool was[maxn];\nint a[maxn];\nint pos[maxn];\nset<int> need[maxn];\nset<int> waiting;\nint ans[maxn], posans[maxn];\nint n, m, q;\n\nset<pair<int, int>> wass;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n// \t\tscanf(\"%d\", &a[m + i]);\n// \t\ta[m + i]--;\n\t}\n// \tq += m;\n\tfor (int i = 0; i < m; i++) was[i] = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tneed[a[q - 1]].insert(i);\n\t\tpos[i] = 0;\n\t}\n\tans[0] = a[q - 1];\n\twas[a[q - 1]] = true;\n\tint anslen = 1;\n\tfor (int i = q - 1; i >= 0; i--)\n\t{\n\t\tif (need[a[i]].size() > 0)\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (was[a[i]]) continue;\n\t\tans[anslen] = a[i];\n\t\tanslen++;\n\t\tfor (auto t : waiting)\n\t\t{\n\t\t\tneed[a[i]].insert(t);\n\t\t}\n\t\twaiting.clear();\n\t\twas[a[i]] = true;\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t}\n\t}\n// \tcout << anslen << endl;\n// \tfor (int i = 0; i < anslen; i++) cout << ans[i] << ' ';\n// \tcout << endl;\n// \tfor (int i = 0; i < n; i++) cout << pos[i] << ' ';\n// \tcout << endl;\n\tfor (int i = 0; i < m; i++) posans[i] = m;\n\tfor (int i = 0; i < anslen; i++) posans[ans[i]] = i;\n\tfor (int i = 0; i < n; i++) if (pos[i] < anslen)\n\t{\n// \t\tcout << i << ' ' << pos[i] << endl;\n\t\tint cur = 0;\n\t\twhile (pos[i] < anslen && cur < m)\n\t\t{\n// \t\t\tcout << cur << ' ' << posans[cur] << ' ' << pos[i] << endl;\n\t\t\tif (wass.count({pos[i], cur}))\n\t\t\t{\n\t\t\t\tpos[i] = anslen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twass.insert({pos[i], cur});\n\t\t\tif (posans[cur] > pos[i])\n\t\t\t{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if (posans[cur] == pos[i])\n\t\t\t{\n\t\t\t\tpos[i]++;\n\t\t\t\tcur++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tif (pos[i] < anslen)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define INPUT(x) scanf(\"%d\",&x)\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF 2000000000\n\ntypedef long long ll;\n\nbool rec(){\n    int TB[100001] = {};\n    INT(N);INT(M);INT(Q);\n    REP1(i,Q){\n        INT(q);\n        TB[q] = (TB[q]+1)%N;\n    }\n    int mini = 1000000;\n    REP2(i,1,M) {\n        mini = min(mini,TB[i]);\n    }\n    REP2(i,2,M) {\n        if (TB[i] > mini) {\n            return false;\n        }\n    }\n    if (TB[1] >= mini) {\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    if (rec()) {\n        cout << \"yes\" << endl;\n    }else{\n        cout << \"no\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\nconst int max0=100010;\nint n,m,a,i;\n\tint count[max0],data[max0],ans[max0],top;\n\tint dic[max0],p1;\n\tbool had[max0],wrong;\nint main()\n{\n\n\tscanf(\"%d%d%d\",&n,&m,&a);\n\tfor(i=0;i<a;i++)\n\t\tscanf(\"%d\",&data[i]);\n    p1=-1;\n\tfor(i=a-1;i>=0;i--)\n\t\tif(had[data[i]]==0){\n                had[data[i]]=1,ans[top++]=data[i];\n                if(data[i]==1)p1=top;\n\t\t}\n    //printf(\"!%d %d %d\\n\",top,ans[1],p1);\n\tif(p1!=-1)\n    {\n        for(i=p1;i<top;i++)\n            if(ans[i]!=i-p1+2)break;\n        if(i==top)top=p1-1;\n    }\n    //printf(\"!%d\\n\",top);\n\tfor(i=top-1;i>=1;i--)dic[ans[i]]=ans[i-1];\n\tfor(i=a-1;i>=0;i--){\n\t\tcount[data[i]]++;\n\t\tif(dic[data[i]]!=0)\n\t\t\tif(count[data[i]]>count[dic[data[i]]])\n\t\t\t\tcount[data[i]]=count[dic[data[i]]];\n\t}\n\tif(top!=0&&count[ans[top-1]]<n)printf(\"No\\n\");\n\telse \tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MX = 120000;\n\nint n, m, q;\nint a[MX];\nvector<int> vv;\nint us[MX];\nint cnt[MX];\n\nint main() {\n\tcin >> n >> m;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i)\n\t\tcin >> a[i], --a[i];\n\tfor (int i = 0; i < m; ++i)\n\t\tus[i] = -1;\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tif (us[a[i]] == -1) {\n\t\t\tus[a[i]] = vv.size();\n\t\t\tvv.push_back(a[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t\tif (us[i] == -1)\n\t\t\tus[i] = vv.size(), vv.push_back(i);\n\tint nd = vv.size() - 1;\n\tfor (int i = (int)vv.size() - 1; i >= 1; --i) {\n\t\tif (vv[i] > vv[i - 1])\n\t\t\t--nd;\n\t\telse\n\t\t\tbreak;\n\t}\n\tcnt[0] = n;\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint x = us[a[i]];\n\t\tif (cnt[x] != 0)\n\t\t\t--cnt[x], ++cnt[x + 1];\n\t}\n\tfor (int i = 0; i < nd; ++i)\n\t\tif (cnt[i] != 0) {\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}\n\tcout << \"Yes\\n\";\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\nint nodelen;\n\nint bit[111111];\nint lowbit(int x){\n\treturn x&-x;\n}\nvoid add(int x){\n\twhile(x <= M){\n\t\tbit[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint query(int x){\n\tint r=0;\n\twhile(x){\n\t\tr+=bit[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn r;\n}\n\nbool chk2(){\n\tif(node[head].next == -1)return true;\n\tint start = node[node[head].next].val;\n\tint end = node[tail].val;\n\treturn end - start + 1 == nodelen + query(end) - query(start+1);\n}\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tnodelen = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t\t\n\t\t\tnodelen++;\n\t\t}\n\n\tmemset(bit,0,sizeof(bit));\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0 && chk2())return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\tLST[ct] = pos[x][j];\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\tif(tail == p)\n\t\t\ttail = prev_pnt;\n\t\tnodelen--;\n\t\tadd(x);\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n\tputs(chk()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q);\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(!used[i]){\n            used[i] = true;\n            if(prev >= 0) next[prev] = i;\n            prev = i;\n            que[i] += que[M];\n            que[M] = 0;\n        }\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      j=0;\n      for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n      if(j!=k&&c[k]!=q) f=false; \n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    for(i=0;i<=m;i++) if(c[i]!=0&&c[i]<n) f=false;\n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n    cout << \"No\" << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> A(Q);\n    for(int i=0; i<Q; i++){\n        cin >> A[i];\n        A[i]--;\n    }\n    reverse(A.begin(), A.end());\n    vector<int> order, rev(M, -1);\n    for(int a : A) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n    int b = order.back(), sz = order.size();\n    if(sz > b){\n        bool ok = true;\n        for(int i=0; i<=b; i++) if(order[i-b+sz-1] != i) ok = false;\n        if(ok) sz -= b+1;\n    }\n    for(int a=0; a<M; a++) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    vector<int> num(M+1);\n    bitset<100001> visited;\n    num[0] = N;\n    for(int a : A){\n        if(num[rev[a]]){\n            num[rev[a]]--;\n            num[rev[a]+1]++;\n        }else if(!visited[rev[a]]){\n            fail();\n        }\n    }\n    for(int i=0; i<sz; i++) if(num[i]) fail();\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tvector<int> a(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\tvector<int> occur(m);\n\tvector<int> order;\n\tfor(int i = q - 1; i >= 0; --i){\n\t\tif(occur[a[i]] == 0){ order.push_back(a[i]); }\n\t\t++occur[a[i]];\n\t}\n\tconst int k = order.size();\n\tbool is_ordered = true;\n\tfor(int i = 0; i < k; ++i){\n\t\tif(order[i] != i){ is_ordered = false; }\n\t}\n\tif(is_ordered){\n\t\tcout << \"Yes\" << endl;\n\t\treturn 0;\n\t}\n\tvector<int> lookup(m);\n\tfor(int i = 0; i < k; ++i){ lookup[order[i]] = i; }\n\tvector<int> reach(k + 1);\n\treach[0] = n;\n\tfor(int i = q - 1; i >= 0; --i){\n\t\tconst int t = lookup[a[i]];\n\t\tif(reach[t + 1] < reach[t]){ ++reach[t + 1]; }\n\t}\n\tset<int> s;\n\tfor(int i = 0; i < m; ++i){ s.insert(i); }\n\tbool possible = true;\n\tfor(int i = 0; possible && i < k; ++i){\n\t\tif(reach[i + 1] < n && *(s.begin()) != order[i]){\n\t\t\tpossible = false;\n\t\t}\n\t\ts.erase(order[i]);\n\t}\n\tcout << (possible ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <= cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tvector<ll> not_comp;\n\tREP(i, m) if(!dict.count(i) || cnt[dict[i]] != n) not_comp.pb(i);\n\tsort(ALL(not_comp));\n\tll tmp = 0;\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(idx[i] != not_comp[tmp]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint N,M,Q;\nint as[199999];\nint result[199999];\nint pos[199999];\nint used[199999];\nint added[199999];\nint ok[199999];\nint main() {\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1;i<=Q;i++) scanf(\"%d\",&as[i]);\n\tint rlen=1;\n\tfor(int i=Q;i>0;i--) {\n\t\tif(used[as[i]]==0) {\n\t\t\tused[as[i]]=1;\n\t\t\tresult[rlen++]=as[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++) if(used[i]==0) result[rlen++]=i;\n\tint ed=0;\n\tfor(int i=1;i<M;i++) if(result[i]>result[i+1]) ed=i;\n\tfor(int i=1;i<=M;i++) pos[result[i]]=i;\n\tok[0]=N;\n\tfor(int i=Q;i>0;i--) {\n\t\tint nw=pos[as[i]];\n\t\tif(nw<=ed) {\n\t\t\tif(ok[nw]<ok[nw-1]) ok[nw]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=ed;i++) if(ok[i]<N) {\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  vector<int> v;\n  for (int e : a) {\n    if (se.count(e)) {\n      continue;\n    }\n    se.insert(e);\n    v.push_back(e);\n  }\n  for (int i = 0; i < m; ++i) {\n    if (se.count(i)) {\n      continue;\n    }\n    se.insert(i);\n    v.push_back(i);\n  }\n  while (v.size() >= 2 and v[v.size() - 2] < v.back()) {\n    v.pop_back();\n  }\n  v.pop_back();\n  if (any_of(begin(v), end(v), [&](int e) { return c[e] < n; })) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n  int k = v.size();\n  map<int, int> mp;\n  for (int i = 0; i < k; ++i) {\n    mp[v[i]] = i;\n  }\n  vector<int> t(k);\n  for (int e : a) {\n    if (not mp.count(e)) {\n      continue;\n    }\n    int i = mp[e];\n    if (t[i] == n) {\n      continue;\n    }\n    if (i == 0 or t[i - 1] > t[i]) {\n      ++t[i];\n    }\n  }\n  if (all_of(begin(t), end(t), [&](int e) { return e == n; })) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nbool was[maxn];\nint a[maxn];\nint pos[maxn];\nset<int> need[maxn];\nset<int> waiting;\nint ans[maxn], posans[maxn];\nint n, m, q;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n// \t\tscanf(\"%d\", &a[m + i]);\n// \t\ta[m + i]--;\n\t}\n// \tq += m;\n\tfor (int i = 0; i < m; i++) was[i] = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tneed[a[q - 1]].insert(i);\n\t\tpos[i] = 0;\n\t}\n\tans[0] = a[q - 1];\n\tint anslen = 1;\n\tfor (int i = q - 1; i >= 0; i--)\n\t{\n\t\tif (need[a[i]].size() > 0)\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (was[a[i]]) continue;\n\t\tans[anslen] = a[i];\n\t\tanslen++;\n\t\tfor (auto t : waiting)\n\t\t{\n\t\t\tneed[a[i]].insert(t);\n\t\t}\n\t\twaiting.clear();\n\t\twas[a[i]] = true;\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t}\n\t}\n// \tcout << anslen << endl;\n// \tfor (int i = 0; i < anslen; i++) cout << ans[i] << ' ';\n// \tcout << endl;\n// \tfor (int i = 0; i < n; i++) cout << pos[i] << ' ';\n// \tcout << endl;\n\tfor (int i = 0; i < m; i++) posans[i] = m;\n\tfor (int i = 0; i < anslen; i++) posans[ans[i]] = i;\n\tfor (int i = 0; i < n; i++) if (pos[i] < anslen)\n\t{\n// \t\tcout << i << ' ' << pos[i] << endl;\n\t\tint cur = 0;\n\t\twhile (pos[i] < anslen && cur < m)\n\t\t{\n// \t\t\tcout << cur << ' ' << posans[cur] << ' ' << pos[i] << endl;\n\t\t\tif (posans[cur] > pos[i])\n\t\t\t{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if (posans[cur] == pos[i])\n\t\t\t{\n\t\t\t\tpos[i]++;\n\t\t\t\tcur++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tif (pos[i] < anslen)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, M, Q;\nint A[100011];\nint cnt[100011];\nint rnk[100011];\nint len[100011];\nVI ord;\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    REP (i, Q) scanf(\"%d\", A+i), A[i]--;;\n\n    for (int i=Q; i--;) {\n\tint v = A[i];\n\tif (cnt[v] == 0) {\n\t    rnk[v] = ord.size();\n\t    ord.push_back(v);\n\t    len[0]++;\n\t} else if (cnt[v] < N && len[cnt[v]] == rnk[v]) {\n\t    len[cnt[v]]++;\n\t    cnt[v]++;\n\n\t}\n\tcnt[v]++; \n    }\n\n    REP (i, M) if (cnt[i] == 0) ord.push_back(i);\n    bool yes = true;\n    for (int i=len[N-1]; i<M-1; i++) if (ord[i] > ord[i+1]) yes = false;\n    puts(yes? \"Yes\": \"No\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =1002;\nconst int MOD =1000000007;\n\n  \n  \nsigned main(){\nint n,m,q;\ncin>>n>>m>>q;\nint a[q];\nfor(int i=0;i<q;i++)cin>>a[i];\nint x[m],y[m]={};\nvector<int> v,w;\nfill(x,x+m,MOD);\nfor(int i=0;i<q;i++){\n  if(x[a[q-1-i]-1]==MOD){\n    x[a[q-1-i]-1]=v.size();\n    v.push_back(0);\n    w.push_back(a[q-1-i]-1);\n  }\n  if(x[a[q-1-i]-1]==0||v[x[a[q-1-i]-1]]<v[x[a[q-1-i]-1]-1])v[x[a[q-1-i]-1]]++;\n}\nfor(int i=0;i<m;i++)if(x[i]==MOD)w.push_back(i);\nint k=0;\nwhile(k<v.size()&&v[k]>=n)k++;\nfor(int i=k;i<w.size()-1;i++)if(w[i]>=w[i+1]){\n  cout<<\"No\"<<endl;\n  return 0;\n}\ncout<<\"Yes\"<<endl;\nreturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, m, q, a[N], vec[N], cnt[N], pos[N];\nset<int> st;\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) st.insert(i);\n\tint tmp = 0;\n\tfor (int i = q; i >= 1; i--) {\n\t\tif (st.count(a[i])) {\n\t\t\tvec[++tmp] = a[i];\n\t\t\tst.erase(a[i]);\n\t\t}\n\t}\n\twhile (st.size()) {\n\t\tvec[++tmp] = *st.begin();\n\t\tst.erase(st.begin());\n\t}\n\tfor (int i = 1; i <= m; i++) pos[vec[i]] = i;\n\tfor (int i = q; i >= 1; i--) {\n\t\tint p = pos[a[i]];\n\t\tcnt[p] = min(cnt[p] + 1, n);\n\t\tif (p > 1 && cnt[p - 1] < cnt[p]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint st;\n\tfor (st = m; st > 1 && vec[st - 1] < vec[st]; st--);\n\tfor (int i = 1; i < st; i++) {\n\t\tif (cnt[i] < n) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    if(pos[val].size()<n){\n      if(val==1){\n        last=true;\n      }\n    }\n\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(val==1){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n\n    int last = -1;\n    drep(i,v.size()){\n        if(v[i].first <= mex){\n            last = i;\n            break;\n        }\n    }\n\n    drep(i,v.size()){\n        if(i == last)break;\n        if(i == v.size() - 1 && v[i].first <= mex)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, m, Q, ans = 1, cur, a[N], c[N], p[N], inv[N];\n\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\nint main() {\n\tin(n), in(m), in(Q), c[0] = n;\n\tfor (int i = 1; i <= Q; ++i) in(a[i]);\n\tfor (int i = 1; i <= m; ++i) inv[i] = -1;\n\tfor (int i = Q; i; -- i)\n\t\tif (inv[a[i]] == -1) {\n\t\t\tinv[a[i]] = ++cur;\n\t\t\tc[cur] = 1, p[cur] = a[i];\n\t\t} else if (c[inv[a[i]]] < c[inv[a[i]] - 1]) ++c[inv[a[i]]];\n\tfor (int i = 1; i <= m; ++i) if (inv[i] == -1) p[++cur] = i;\n\tfor (int i = 2; i <= m; ++i)\n\t\tif (c[i - 1] != n && p[i - 1] > p[i]) {ans = 0; break;}\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nvector<int> ord;\nint markn[N], a[N], cnt[N], pl[N];\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n        a[i]--;\n    }\n    cnt[0] = n;\n    for (int i = q - 1; i >= 0; --i) {\n        if (!markn[a[i]]++) {\n            ord.push_back(a[i]);\n        }\n    }\n    for (int i = 0; i < m; ++i)\n        if (!markn[i]++) {\n            ord.push_back(i);\n        }\n    for (int i = 0; i < m; ++i)\n        pl[ord[i]] = i;\n    for (int i = q - 1; i >= 0; --i) {\n        if (cnt[pl[a[i]]] == 0) continue;\n        cnt[pl[a[i]]]--;\n        cnt[pl[a[i]] + 1]++;\n    }\n    int sr = 0;\n    for (int i = m - 2; i >= 0; --i) {\n        if (ord[i + 1] < ord[i]) {\n            sr = i + 1;\n            break;\n        }\n    }\n    for (int i = 0; i < sr; ++i) {\n        if (cnt[i] > 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\treturn 0;\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nint N;\nint Y[101010],X[101010],A[101010];\n\nll XX[101010],YY[101010];\nvector<pair<int,int>> XL[101010];\nvector<pair<int,int>> YL[101010];\nvector<pair<int,int>> XE[101010];\nvector<pair<int,int>> YE[101010];\n\nvoid dfsx(int x) {\n\tFORR(e,XE[x]) {\n\t\tint tar=e.first;\n\t\tll v=XX[x]+e.second;\n\t\tif(XX[tar]==-1LL<<60) {\n\t\t\tXX[tar]=v;\n\t\t\tdfsx(tar);\n\t\t}\n\t\telse {\n\t\t\tif(XX[tar]!=v) {\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfsy(int y) {\n\tFORR(e,YE[y]) {\n\t\tint tar=e.first;\n\t\tll v=YY[y]+e.second;\n\t\tif(YY[tar]==-1LL<<60) {\n\t\t\tYY[tar]=v;\n\t\t\tdfsy(tar);\n\t\t}\n\t\telse {\n\t\t\tif(YY[tar]!=v) {\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tFOR(i,101000) XX[i]=YY[i]=-1LL<<60;\n\t\n\tcin>>H>>W>>N;\n\tFOR(i,N) {\n\t\tcin>>Y[i]>>X[i]>>A[i];\n\t\tY[i]--;\n\t\tX[i]--;\n\t\tYL[Y[i]].push_back({X[i],A[i]});\n\t\tXL[X[i]].push_back({Y[i],A[i]});\n\t}\n\tFOR(y,H) if(YL[y].size()>1) {\n\t\tsort(ALL(YL[y]));\n\t\tFOR(i,YL[y].size()-1) {\n\t\t\tXE[YL[y][i].first].push_back({YL[y][i+1].first,YL[y][i+1].second-YL[y][i].second});\n\t\t\tXE[YL[y][i+1].first].push_back({YL[y][i].first,YL[y][i].second-YL[y][i+1].second});\n\t\t}\n\t}\n\tFOR(x,W) if(XL[x].size()>1) {\n\t\tsort(ALL(XL[x]));\n\t\tFOR(i,XL[x].size()-1) {\n\t\t\tYE[XL[x][i].first].push_back({XL[x][i+1].first,XL[x][i+1].second-XL[x][i].second});\n\t\t\tYE[XL[x][i+1].first].push_back({XL[x][i].first,XL[x][i].second-XL[x][i+1].second});\n\t\t}\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(XX[X[i]]==-1LL<<60 && YY[Y[i]]==-1LL<<60) {\n\t\t\tXX[X[i]]=A[i];\n\t\t\tYY[Y[i]]=0;\n\t\t\tdfsx(X[i]);\n\t\t\tdfsy(Y[i]);\n\t\t}\n\t\tif(YY[Y[i]]==-1LL<<60) {\n\t\t\tYY[Y[i]]=A[i]-XX[X[i]];\n\t\t\tdfsy(Y[i]);\n\t\t}\n\t\tif(XX[X[i]]==-1LL<<60) {\n\t\t\tXX[X[i]]=A[i]-YY[Y[i]];\n\t\t\tdfsx(X[i]);\n\t\t}\n\t}\n\t\n\tll mix=1LL<<60, miy=1LL<<60;\n\tFOR(i,W) if(XX[i]!=-1LL<<60) mix=min(mix,XX[i]);\n\tFOR(i,H) if(YY[i]!=-1LL<<60) miy=min(miy,YY[i]);\n\t\n\tif(mix+miy<0) assert(0);\n\telse cout<<\"Yes\"<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nconst string NO = \"No\";\nconst string YES = \"Yes\";\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n    int q;\n    cin >> q;\n\n    vector<int> a(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n    }\n\n    reverse(a.begin(), a.end());\n\n    vector<int> b(n - 1);\n    for (int i = 0; i + 1 < n; ++i) {\n        b[i] = 0;\n    }\n\n    set<int> values;\n    for (int x = 1; x <= m; ++x) {\n        values.insert(x);\n    }\n\n    vector<int> minValues(m);\n    for (int i = 0; i < m; ++i) {\n        minValues[i] = 1;\n    }\n\n    map<int, int> mp;\n    int last = 1;\n\n    vector<int> revValues(m + 1);\n\n    for (int x : a) {\n        if (mp.find(x) == mp.end()) {\n            values.erase(values.find(x));\n            if (last < m) {\n                minValues[last] = (*values.begin());\n            }\n            revValues[last] = x;\n            mp[x] = last++;\n            continue;\n        }\n\n        int xx = mp[x] - 1;\n\n        int bl = 0;\n        int br = n - 2;\n        int ba = -1;\n        while (bl <= br) {\n            int bm = (bl + br) >> 1;\n\n            if (b[bm] == xx) {\n                ba = bm;\n                br = bm - 1;\n            } else if (b[bm] > xx) {\n                bl = bm + 1;\n            } else {\n                br = bm - 1;\n            }\n        }\n\n        if (ba == -1) {\n            continue;\n        } else {\n            ++b[ba];\n        }\n    }\n\n    vector<bool> good(last);\n\n    good[last - 1] = true;\n    for (int i = last - 2; i >= 0; --i) {\n        good[i] = good[i + 1];\n        if (revValues[i + 1] != minValues[i]) {\n            good[i] = false;\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        if (!good[b[i]]) {\n            cout << NO << endl;\n            return 0;\n        }\n    }\n\n    cout << YES << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[100010],a[100010],pos[100010],c[100010];\nbool us[100010];\nint main(){\n\tint n,m,q,i,N;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(i=1;i<=q;i++)scanf(\"%d\",p+i);\n\tN=0;\n\tfor(i=q;i>0;i--){\n\t\tif(!us[p[i]])us[a[++N]=p[i]]=1;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tif(!us[i])a[++N]=i;\n\t}\n\tfor(i=1;i<=m;i++)pos[a[i]]=i;\n\t#define wa {puts(\"No\");return 0;}\n\tc[0]=n;\n\tfor(i=q;i>0;i--){\n\t\tif(!c[pos[p[i]]-1])wa\n\t\tc[pos[p[i]]-1]--;\n\t\tc[pos[p[i]]]++;\n\t}\n\tfor(i=0;!c[i];i++);\n\tfor(i++;i<m;i++){\n\t\tif(a[i]>a[i+1])wa\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint z[N];\nint a[N];\nint pos[N];\nint at[N];\n\nint main() {\n  int n, m, q;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", z + i);\n    z[i]--;\n  }\n  for (int i = 0; i < m; i++) {\n    a[i] = -1;\n    pos[i] = -1;\n    at[i] = 0;\n  }\n  int known = 0;\n  at[0] = n;\n  at[m] = 0;\n  for (int it = q - 1; it >= 0; it--) {\n    int i = z[it];\n    if (pos[i] == -1) {\n      a[known] = i;\n      pos[i] = known;\n      at[known]--;\n      known++;\n      at[known]++;\n      continue;\n    }\n    if (at[pos[i]] > 0) {\n      at[pos[i]]--;\n      at[pos[i] + 1]++;\n    }\n  }\n  int first = -1;\n  for (int i = 0; i < m; i++) {\n    if (at[i] > 0) {\n      first = i;\n      break;\n    }\n  }\n  vector <int> all;\n  for (int i = first; i < known; i++) {\n    all.push_back(a[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    if (pos[i] == -1) {\n      all.push_back(i);\n    }\n  }\n  sort(all.begin(), all.end());\n  for (int i = first; i < known; i++) {\n    if (all[i - first] != a[i]) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n    \n    reverse(ALL(b));\n    while(SZ(b)&&b.back()==1)\n        b.pop_back();\n    reverse(ALL(b));\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N,M,Q;\nvi num[MX], cur;\n\nvoid test(int x, int y) {\n    vi a = num[x];\n    // for (int i: a) cout << \"ZZ \" << i << \"\\n\";\n    reverse(all(a));\n    // for (int i: a) cout << \"ZZ \" << i << \"\\n\";\n    int ind = 0;\n    vi A;\n    for (int i = 0; i < sz(a) && ind < sz(cur); ) {\n        while (i < sz(a) && a[i] > cur[ind]) i ++;\n        if (i < sz(a)) {\n            // cout << \"OH \" << i << \" \" << a[i] << \"\\n\";\n            A.pb(a[i]);\n            ind ++; i ++;\n        }\n    }\n    /*for (int i: A) cout << i << \" \";\n    cout << \"BAD\\n\";\n    exit(0);*/\n    if (sz(a) < N) {\n        if (sz(cur) < N && x < y) {\n            cout << \"No\";\n            exit(0);\n        }\n    }\n    \n    cur = a;\n    /*F0R(i,sz(a)) if (a[i] > b[i]) {\n        cout << \"No\";\n        exit(0);\n    }*/\n}\n\nint getback(int x) {\n    if (sz(num[x])) return num[x].back();\n    return -x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> M >> Q;\n    // FOR(i,1,M+1) num[i].pb(-i);\n    FOR(i,1,Q+1) {\n        int x; cin >> x;\n        num[x].pb(i);\n    }\n    FOR(i,1,M+1) sort(all(num[i]));\n    vi z; FOR(i,1,M+1) z.pb(i); \n    sort(all(z),[](int a, int b){ return getback(a) < getback(b); });\n    \n    cur = num[z[M-1]]; reverse(all(cur)); while (sz(cur) > N) cur.pop_back();\n    // for (int k: cur) cout << \"IH \" << k << \"\\n\";\n    // for (int k: num[z[M-2]]) cout << \"HI \" << k << \"\\n\";\n    // exit(0);\n    F0Rd(i,M-1) test(z[i],z[i+1]);\n    cout << \"Yes\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N,M,Q;\nvi num[MX], cur;\n\nvoid test(int x, int y) {\n    vi a = num[x];\n    // for (int i: a) cout << \"ZZ \" << i << \"\\n\";\n    reverse(all(a));\n    // for (int i: a) cout << \"ZZ \" << i << \"\\n\";\n    int ind = 0;\n    vi A;\n    for (int i = 0; i < sz(a) && ind < sz(cur); ) {\n        while (i < sz(a) && a[i] > cur[ind]) i ++;\n        if (i < sz(a)) {\n            // cout << \"OH \" << i << \" \" << a[i] << \"\\n\";\n            A.pb(a[i]);\n            ind ++; i ++;\n        }\n    }\n    /*for (int i: A) cout << i << \" \";\n    cout << \"BAD\\n\";\n    exit(0);*/\n    if (sz(A) < N) {\n        if (sz(cur) < N && x < y) {\n            cout << \"No\";\n            exit(0);\n        }\n    }\n    \n    cur = A;\n    /*F0R(i,sz(a)) if (a[i] > b[i]) {\n        cout << \"No\";\n        exit(0);\n    }*/\n}\n\nint getback(int x) {\n    if (sz(num[x])) return num[x].back();\n    return -x;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> M >> Q;\n    // FOR(i,1,M+1) num[i].pb(-i);\n    FOR(i,1,Q+1) {\n        int x; cin >> x;\n        num[x].pb(i);\n    }\n    FOR(i,1,M+1) sort(all(num[i]));\n    vi z; FOR(i,1,M+1) z.pb(i); \n    sort(all(z),[](int a, int b){ return getback(a) < getback(b); });\n    \n    cur = num[z[M-1]]; reverse(all(cur)); while (sz(cur) > N) cur.pop_back();\n    // for (int k: cur) cout << \"IH \" << k << \"\\n\";\n    // for (int k: num[z[M-2]]) cout << \"HI \" << k << \"\\n\";\n    // exit(0);\n    F0Rd(i,M-1) test(z[i],z[i+1]);\n    cout << \"Yes\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = n + Q;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i-1]]){\n\t\t\tf[a[i-1]]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt; i++, j++)\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    cut[qv[0]] = true;\n    std::set<ll> free;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n            for (ll idx : free) nxts[e].insert(idx);\n            free.clear();\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n            else free.insert(idx);\n        }\n    }\n\n    bool ok = true;\n    for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n\n    std::set<ll> lack;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) lack.insert(aim[i]); \n    for (ll i = 1; i <= m; i++) if (!cut[i]) lack.insert(i);\n    for (ll i = minv; i < aim.size(); i++) {\n        ll e = aim[i];\n        if (e != *lack.begin()) ok = false;\n        lack.erase(e);\n    }\n    if(ok) return true;\n\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\nint ma[100005];\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ma[a[q]]=1;\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            if(ma[a[i]]==0)\n            {\n                tail++;\n                qu[tail]=a[i];\n                ma[a[i]]=1;\n                ha[tail]++;\n            }\n        }\n    }\n\n    //cout<<head<<\"  \"<<tail<<endl;\n    if(ha[tail]>=n)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    if(head==tail)\n    {\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n    }\n\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n        //cout<<\"qu=\"<<qu[j]<<endl;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100000;\n\nint a[N], len[N], cnt[N], rnk[N];\n\nint main()\n{\n  int n, m, q;\n  while (scanf(\"%d%d%d\", &n, &m, &q) == 3) {\n    for (int i = 0; i < q; ++ i) {\n      scanf(\"%d\", a + i);\n      a[i] --;\n    }\n    memset(len, 0, sizeof(*len) * n);\n    memset(cnt, 0, sizeof(*cnt) * m);\n    memset(rnk, -1, sizeof(*rnk) * m);\n    std::vector<int> seq;\n    for (int i = q - 1; i >= 0; -- i) {\n      if (rnk[a[i]] == -1) {\n        rnk[a[i]] = seq.size();\n        seq.push_back(a[i]);\n      }\n      if (cnt[a[i]] < n && len[cnt[a[i]]] == rnk[a[i]]) {\n        len[cnt[a[i]]] ++;\n        cnt[a[i]] ++;\n      }\n    }\n    int o = 0;\n    while (o < m && ~rnk[o]) {\n      o ++;\n    }\n    int min_len = seq.size();\n    while (min_len && seq[min_len - 1] < o) {\n      o = seq[-- min_len];\n    }\n    bool ok = true;\n    for (int i = 0; i < n; ++ i) {\n      ok &= len[i] >= min_len;\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,Q;\nint A[101010];\nint did[101010];\nint ind[101010];\nvector<int> V;\nint num[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) cin>>A[i];\n\tfor(i=Q-1;i>=0;i--) {\n\t\tdid[A[i]]++;\n\t\tif(did[A[i]]==1) {\n\t\t\tind[A[i]]=V.size();\n\t\t\tV.push_back(A[i]);\n\t\t}\n\t}\n\t\n\tFOR(i,N) if(V[i]!=i+1) break;\n\tif(i==N) return _P(\"Yes\\n\");\n\tif(1LL*V.size()*M>Q) return _P(\"No\\n\");\n\tnum[0]=M;\n\tfor(i=Q-1;i>=0;i--) {\n\t\tif(num[ind[A[i]]]) {\n\t\t\tnum[ind[A[i]]]--;\n\t\t\tnum[ind[A[i]]+1]++;\n\t\t}\n\t}\n\tif(num[V.size()]==M) _P(\"Yes\\n\");\n\telse _P(\"No\\n\");\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    unordered_map<int, int> X;\n    vector<int> order;\n    vector<int> num;\n    stack<int> S;\n    unordered_set<int> us;\n    int a, b, c;\n    for (int q = 0;q < Q;q++) {\n    \tcin >> a;\n    \tS.push(a);\n    }\n    while (S.size() > 0) {\n    \ta = S.top();\n    \tS.pop();\n    \tif (X.find(a) == X.end()) {\n    \t\tb = X.size();\n    \t\tX[a] = b;\n    \t}\n    \tb = X[a];\n    \tif (b >= order.size()) {\n    \t\torder.push_back(a);\n    \t\tus.insert(a);\n    \t}\n    \tif (b >= num.size()) num.push_back(0);\n    \tif (b == 0 && num[0] < N) num[0]++;\n    \telse {\n    \t\tif (num[b - 1] > num[b]) num[b]++;\n    \t}\n    }\n    if (num[num.size() - 1] == N) {\n    \tcout << \"Yes\" << endl;\n    \treturn 0;\n    }\n    vector<int> rem;\n    for (int i = 0;i < order.size();i++) {\n    \tif (order[i] != N) rem.push_back(order[i]);\n    }\n    for (int i = 1;i <= M;i++) {\n    \tif (us.find(i) == us.end()) rem.push_back(i);\n    }\n    vector<int> g = rem;\n    sort(g.begin(), g.end());\n    if (g == rem) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvoid err(){\n  std::cout << \"No\" << '\\n';\n  exit(0);\n}\nvoid ok(){\n  std::cout << \"Yes\" << '\\n';\n  exit(0);\n}\nint main(int argc, char const *argv[]) {\n  ll n, m;std::cin >> n >> m;\n  map<ll, ll> mp;\n  vll fi(m+1, -1);\n  ll q;std::cin >> q;\n  vll a(q);\n  vll num;\n\n  re(i, q) scanf(\"%lld\", &a[i]);\n  for(int i=q-1;i>=0;i--){\n    if(mp.find(a[i])!=mp.end()) continue;\n    num.push_back(a[i]);\n    mp.emplace(a[i], num.size());\n    fi[a[i]] = i; //初めて現れる\n  }\n  for(int i=1;i<=m;i++) if(mp.find(i)==mp.end()) num.push_back(i);\n  ll las = m-1;\n  while(las!=0&&num[las]>num[las-1]) las--;\n\n  multiset<ll> st;\n  for(int i=q-1;i>=0;i--){\n    ll x = mp.at(a[i]);\n    if(x>las) continue;\n    if(x==1&&st.size()!=n) st.insert(1);\n    else{\n      auto itr = st.find(x-1);\n      if(itr==st.end()) continue;\n      st.erase(itr);\n      st.insert(x);\n    }\n  }\n  if(las==0) ok();\n  if(st.size()!=n) err();\n  for(auto t:st) if(t!=las) err();\n  ok();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l=0,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n    //OUT(l)\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    if(l==0){\n        cout << \"AAA\" <<endl;\n        return 0;\n    }\n    REPN(i,1,l){\n        if(dat[i]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    if(l==0){\n        cout << \"AAA\" <<endl;\n        return 0;\n    }\n    REPN(i,1,l){\n        if(dat[l]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> st[100000];\nbool used[100000];\nint idx[100000];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    int a[100000];\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n        st[a[i]].insert(i);\n    }\n    vector<int> ans;\n    for(int i = Q-1; i >= 0; i--){\n        if(!used[a[i]]){\n            ans.push_back(a[i]);\n            used[a[i]] = true;\n        }\n    }\n    for(int i = 0; i < N; i++) idx[i] = -1;\n    for(int i = 0; i < M; i++){\n        if(!used[i]) ans.push_back(i);\n    }\n    // for(int i = 0; i < M; i++) cout << ans[i] << ' ';\n    int last = -1;\n    for(int i = 1; i < M; i++){\n        if(ans[i] < ans[i-1]) last = i-1;\n    }\n    // cout << last << endl;\n    for(int i = 0; i <= last; i++){\n        for(int j = 0; j < N; j++){\n            auto ptr = st[ans[i]].lower_bound(idx[j]);\n            if(ptr == st[ans[i]].end()){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            int m = *ptr;\n            st[ans[i]].erase(m);\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tmita[no]=true;\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t}\n\t\tif(numlis[no].size()<n){if(zyu!=no){cout<<\"No\"<<endl;return 0;}else{zyu++;}}\n\t\tfor(j=numlis[no].size();j<n;j++){las[j]=i-q;}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvector<int> vec;\nint freq[100001];\nvi a;\nvi inv;\nbool visited[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, q;\n\tcin >> n >> m >> q; vec.resize(q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tcin >> vec[i]; vec[i]--;\n\t}\n\tfreq[0] = n;\n\treverse(vec.begin(), vec.end());\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(!visited[vec[i]])\n\t\t{\n\t\t\tvisited[vec[i]] = 1;\n\t\t\ta.pb(vec[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(!visited[i]) a.pb(i);\n\t}\n\t//cerr << a.size() << ' ' << n << '\\n';\n\tinv.resize(m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tinv[a[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint f = inv[vec[i]];\n\t\tif(freq[f])\n\t\t{\n\t\t\tfreq[f]--; freq[f+1]++;\n\t\t}\n\t\t/*\n\t\telse\n\t\t{\n\t\t\tcout << \"No\"; return 0;\n\t\t}\n\t\t*/\n\t}\n\tint idx = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tif(freq[i])\n\t\t{\n\t\t\tidx = i; break;\n\t\t}\n\t}\n\tfor(int i = idx; i < m - 1; i++)\n\t{\n\t\tif(a[i] >= a[i+1]) {cout << \"No\"; return 0;}\n\t}\n\tcout << \"Yes\"; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\t\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t}\n\t\tif(numlis[no].size()<n){\n\t\t\twhile(mita[zyu]){zyu++;}\n\t\t\tif(zyu!=no){cout<<\"No\"<<endl;return 0;}else{zyu++;}\n\t\t}\n\t\tmita[no]=true;\n\t\tfor(j=numlis[no].size();j<n;j++){las[j]=i-q;}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M,Q; cin >> N >> M >> Q;\n    vector<int> a(Q);\n    for (int i=0;i<Q;++i) cin >> a[i],--a[i];\n    reverse(a.begin(),a.end());\n    vector<vector<int>> v(N);\n    vector<int> nxt(M,0),idx(M,-1);\n    for (int i=0;i<Q;++i){\n        if (~idx[a[i]]){\n            if (nxt[a[i]]>=N||v[nxt[a[i]]].size()<idx[a[i]]) continue;\n            v[nxt[a[i]]++].emplace_back(a[i]);\n        } else {\n            idx[a[i]]=v[0].size();\n            v[nxt[a[i]]++].emplace_back(a[i]);\n        }\n    }\n    vector<int> check(M,0);\n    for (int i=0;i<v[N-1].size();++i) check[v[N-1][i]]=1;\n    for (int i=0;i<M;++i) if (!check[i]){\n        v[N-1].emplace_back(i);\n    }\n    for (int i=0;i<N-1;++i){\n        for (int j=0;j<v[i].size();++j){\n            if (v[i][j]!=v[N-1][j]){\n                cout << \"No\" << '\\n';\n                return 0;\n            }\n        }\n    }\n    cout << \"Yes\" << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    if ((temp != 1) || (temp == counter)){\n      minw = min(minw, (int)amc[temp].size()); \n    }\n    for (int i = 0; i < amc[temp].size(); i++){\n      used[amc[temp][i]] = 1;\n    }\n    amc.erase(temp);\n    while(used[tempindex] == 1){\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == (i+1)%M){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n        }\n    }\n\n    bool ok = true;\n    for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, Q;\nint L;\nint A[100000];\nint B[100000];\nint prog[100000];\nint cnt[100001];\n\nint main()\n{\n    memset(prog, -1, sizeof prog);\n    memset(B, -1, sizeof B);\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    for(int i=0; i<Q; i++)\n        scanf(\"%d\", A+i), A[i]--;\n    L=0;\n    cnt[0]=N;\n    for(int i=Q-1; i>=0; i--)\n    {\n        int x=A[i];\n        if(prog[x]==-1)\n        {\n            B[L]=x;\n            prog[x]=L++;\n        }\n        if(cnt[prog[x]]>0)\n            cnt[prog[x]]--, cnt[prog[x]+1]++;\n    }\n    for(int i=0; i<M; i++) if(prog[i]==-1)\n    {\n        B[L]=i;\n        prog[i]=L++;\n    }\n    int idx=0;\n    for(int i=L-1; i>=1; i--)\n    {\n        if(B[i-1]>B[i])\n        {\n            idx=i;\n            break;\n        }\n    }\n    for(int i=0; i<idx; i++) if(cnt[i]>0)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    printf(\"Yes\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tit_bound = prev(it_bound);\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\torder.emplace_back(i);\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < m - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ELRU {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m, q; cin >> n >> m >> q;\n      vector<int> a(q);\n      rep(i, q) {\n        cin >> a[i];\n      }\n      reverse(all(a));\n      // value, pos\n      map<int, int> used;\n      vector<int> cnt;\n      vector<int> rev;\n      rep(i, q) {\n        if (used.find(a[i]) == used.end()) {\n          used[a[i]] = cnt.size();\n          cnt.push_back(1);\n          rev.push_back(a[i]);\n        } else {\n          int pos = used[a[i]];\n          if (pos == 0 || cnt[pos-1] > cnt[pos]) {\n            cnt[pos]++;\n          }\n        }\n      }\n\n      bool flag = true;\n      bool flag2 = true;\n      set<int> st;\n      for(int i=1; i<=m; i++) {\n        st.insert(i);\n      }\n      for(int i=0; i<cnt.size(); i++) {\n        if (cnt[i] < n) {\n          flag = false;\n        }\n        if (!flag && rev[i] != *st.begin()) {\n          flag2 = false;\n        }\n        st.erase(rev[i]);\n      }\n      if (flag || flag2) {\n        cout << \"Yes\" << endl;\n        return;\n      }\n      cout << \"No\" << endl;\n    }\n};\n\nsigned main() {\n  ELRU solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//start of jonathanirvings' template v3.0.3 (BETA)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\ntypedef pair<string,string> pss;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef vector<LL> vl;\ntypedef vector<vl> vvl;\n\ndouble EPS = 1e-9;\nint INF = 1000000005;\nlong long INFF = 1000000000000000005LL;\ndouble PI = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\n#ifdef TESTING\n  #define DEBUG fprintf(stderr,\"====TESTING====\\n\")\n  #define VALUE(x) cerr << \"The value of \" << #x << \" is \" << x << endl\n  #define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n  #define DEBUG \n  #define VALUE(x)\n  #define debug(...)\n#endif\n\n#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))\n#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))\n#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))\n#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))\n#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))\n#define FOREACH(a,b) for (auto &(a) : (b))\n#define REP(i,n) FOR(i,0,n)\n#define REPN(i,n) FORN(i,1,n)\n#define MAX(a,b) a = max(a,b)\n#define MIN(a,b) a = min(a,b)\n#define SQR(x) ((LL)(x) * (x))\n#define RESET(a,b) memset(a,b,sizeof(a))\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ALL(v) v.begin(),v.end()\n#define ALLA(arr,sz) arr,arr+sz\n#define SIZE(v) (int)v.size()\n#define SORT(v) sort(ALL(v))\n#define REVERSE(v) reverse(ALL(v))\n#define SORTA(arr,sz) sort(ALLA(arr,sz))\n#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))\n#define PERMUTE next_permutation\n#define TC(t) while(t--)\n\ninline string IntToString(LL a){\n  char x[100];\n  sprintf(x,\"%lld\",a); string s = x;\n  return s;\n}\n\ninline LL StringToInt(string a){\n  char x[100]; LL res;\n  strcpy(x,a.c_str()); sscanf(x,\"%lld\",&res);\n  return res;\n}\n\ninline string GetString(void){\n  char x[1000005];\n  scanf(\"%s\",x); string s = x;\n  return s;\n}\n\ninline string uppercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';\n  return s;\n}\n\ninline string lowercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';\n  return s;\n}\n\ninline void OPEN (string s) {\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n}\n\n//end of jonathanirvings' template v3.0.3 (BETA)\n\nint ada[100005];\nint pos[100005];\nvi baris;\nint n,m,q;\nint data[100005];\nint sudah[100005];\nint now = 1;\n\nint main()\n{\n  scanf(\"%d %d\",&n,&m);\n  RESET(pos,-1);\n  scanf(\"%d\",&q);\n  REP(i,q)\n  {\n    scanf(\"%d\",&data[i]);\n  }\n  baris.pb(-1);\n  ada[0] = n;\n  FORD(i,q-1,0)\n  {\n    if (pos[data[i]] == -1)\n    {\n      pos[data[i]] = SIZE(baris);\n      baris.pb(data[i]);\n      ada[pos[data[i]]] = 0;\n    }\n    if (ada[pos[data[i]]-1] > ada[pos[data[i]]])\n    {\n      ++ada[pos[data[i]]];\n    }\n  }\n  /*int xx = ada[SIZE(baris)-1];\n  FORN(i,1,100000)\n  {\n    if (baris[SIZE(baris)-1] == i && ada[SIZE(baris)-1] == xx) baris.pop_back();\n  }*/\n  //REP(i,SIZE(baris)) VALUE(baris[i]);\n  //REP(i,SIZE(baris)) VALUE(ada[i]);\n  REP(i,SIZE(baris)) if(ada[i] != n) goto gabisa;\n  puts(\"Yes\");\n  return 0;\n  gabisa:;\n  FOR(i,1,SIZE(baris))\n  {\n    if (ada[i] == n) sudah[baris[i]] = 1;\n    else\n    {\n      while (sudah[now]) ++now;\n      sudah[now] = 1;\n      if (baris[i] != now)\n      {\n        puts(\"No\");\n        return 0;\n      }\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n\n\nint main(){\n    ll m,n,q;cin>>m>>n>>q;//注意！\n    \n    ll a[q];\n    rep(i,0,q-1){\n        cin>>a[i];a[i]--;\n    }\n    reverse(a,a+q);\n    ll ans[n+1];fill(ans,ans+n+1,-1);\n    ll anspos=0;\n    ll ansc[n+1];memset(ansc,0,sizeof(ansc));\n    ll rev[n];fill(rev,rev+n,-1);\n    rep(i,0,q-1){\n        ll x=a[i];\n        if(rev[x]==-1){\n            rev[x]=anspos;\n            ll y=rev[x];\n            ans[y]=x;\n            ansc[y]++;\n            anspos++;\n        }else{\n            ll y=rev[x];\n            if(y==0)ansc[y]++;\n            else if(y>0&&ansc[y-1]>ansc[y])ansc[y]++;\n        }\n    }\n    vector<ll>v;\n    ll pos=0;\n    while(pos<=n-1&&ansc[pos]>=m){\n        pos++;\n    }\n    while(pos<=n-1&&ans[pos]!=-1){\n        v.pb(ans[pos]);\n        pos++;\n    }\n    //for(auto x:v)cout<<x<<\" \";cout<<endl;\n    rep(i,0,n-1){\n        if(rev[i]==-1)v.pb(i);\n    }\n    ll s=v.size();\n    //for(auto x:v)cout<<x<<\" \";cout<<endl;\n    //cout<<\" ans:\";rep(i,0,n)cout<<ans[i]<<\" \";cout<<endl;\n    //cout<<\"ansc:\";rep(i,0,n)cout<<ansc[i]<<\" \";cout<<endl;\n    //cout<<\" rev:\";rep(i,0,n-1)cout<<rev[i]<<\" \";cout<<endl;\n    rep(i,0,s-2){\n        if(v[i]>=v[i+1]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n        ord[P[i].num] = i;\n    }\n    chk = 1;\n    for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    int ck = 0;\n    for(i=1;i<=m;i++){\n        if(P[i].t < 0)break;\n        if(P[i].num == 1)ck = 1;\n        if(R[i] < n && (!chk || !ck)){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\nusing namespace std;\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\n\nbool solve(int n, int m, int q, const vector<int> & a) {\n    // make the final sequence\n    vector<int> used(m);\n    vector<int> b;\n    REP_R (i, q) {\n        if (not used[a[i]]) {\n            used[a[i]] = true;\n            b.push_back(a[i]);\n        }\n    }\n    REP (i, m) {\n        if (not used[i]) {\n            b.push_back(i);\n        }\n    }\n\n    // remove the tail\n    int r = m - 1;\n    while (r - 1 >= 0 and b[r - 1] < b[r]) {\n        -- r;\n    }\n\n    // count queries\n    vector<int> cnt(m);\n    for (int a_i : a) {\n        ++ cnt[a_i];\n    }\n    int min_cnt = INT_MAX;\n    REP (i, r) {\n        chmin(min_cnt, cnt[b[i]]);\n    }\n    return (min_cnt >= n);\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    int q; cin >> q;\n    vector<int> a(q);\n    REP (i, q) {\n        cin >> a[i];\n        -- a[i];\n    }\n    cout << (solve(n, m, q, a) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,f[500010],m,a[500010],used,A[500010],B[500010],AS,BS;\nbool rem(){\n\tFOR(i,1,q) if (!u[a[i]] && i==v[a[i]][0]) A[++AS]=a[i];\n\tFOR(i,1,m) if (!u[i]) B[++BS]=i;\n\tFOR(i,1,AS) if (A[i]!=B[i]) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,q) v[a[i]].pb(i);\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tif (a[now]==1){\n\t\t\tif (rem()) return puts(\"Yes\"),0;\n\t\t}\n\t\tu[a[now]]=1;\n\t\tused+=SZ(v[a[now]]);\n\t\tint t=0;\n\t\tFOR(i,1,n){\n\t\t\twhile (v[a[now]][t]<=f[i] && t<SZ(v[a[now]])) ++t;\n\t\t\tif (t>=SZ(v[a[now]])) return puts(\"No\"),0;\n\t\t\tf[i]=v[a[now]][t];\n\t\t\t++t;\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nint main() {\n\tll N, M, Q;\n\tcin >> N >> M >> Q;\n\tvector<ll> a(Q + 1);\n\trepn(i, Q) cin >> a[i];\n\n\tvector<ll> ar(M + 1,0);\n\tvector<ll> lg(N + 1, 0);\n\n\tfor (ll i = Q; i >= 1; i--) {\n\t\tif(ar[a[i]]==0){\n\t\t\tar[a[i]] = lg[N] + 1;\n\t\t\tlg[N]++;\n\t\t}\n\n\t\telse {\n\t\t\tauto itr = upper_bound(++lg.begin(), lg.end(), ar[a[i]]-1);\n\t\t\t//cout << i << endl << flush;\n\t\t\tll j = distance(lg.begin(), itr) - 1;\n\t\t\t//cout << j << endl << flush;\n\t\t\tlg[j]++;\n\t\t}\n\t}\n\n\tvector<ll> seq(M+1);\n\trepn(i, M) {\n\t\tif (ar[i] > 0) { seq[ar[i]] = i; }\n\t\t//cout << ar[i] << \" \" << i << endl << flush;\n\t}\n\tll c = lg[N] + 1;\n\t//cout << c << endl;\n\trepn(i, M) {\n\t\tif (ar[i] == 0) { seq[c] = i; c++; }\n\t}\n\n\tstring ans = \"Yes\";\n\tfor (ll i = lg[1] + 1; i <= min(lg[N],M-1); i++) {\n\t\tif (seq[i] > seq[i + 1]) { ans = \"No\"; }\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 505050;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(m, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(rmq.get(pos) == n) continue;\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,q,a[100005],d;\nmultiset<int>M;\nmap<int,int>S;\nvector<int>vi;\nint main(){\n\tcin>>n>>m>>q; rep(i,q)cin>>a[q-1-i]; rep(i,n) M.insert(0);\n\trep(i,q){\n\t\tif(S.find(a[i]) == S.end()){\n\t\t\tS[a[i]] = ++d; vi.pb(a[i]);\n\t\t}\n\t\tint D = S[a[i]];\n\t\tmultiset<int>::iterator it=M.lower_bound(D-1); int v = *it;\n\t\tM.erase(it);\n\t\tM.insert(max(v,D));\n\t}\n\tfor(int i=1;i<=m;i++) if(S.find(i) == S.end()) vi.pb(i);\n\tint lim=0;\n\tfor(int i=vi.size()-2;i>=0;i--){\n\t\tif(vi[i] > vi[i+1]){\n\t\t\tlim=i+1; break;\n\t\t}\n\t}\n\tfor(multiset<int>::iterator it=M.begin();it!=M.end();++it){\n\t\tif((*it) < lim){\n\t\t\tputs(\"No\"); return 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int ind[M];\n  for(i=0;i<M;++i){ind[i] = -1;}\n  int laststock = 0;\n  int lastcount[M];\n  int before[M];\n  int bef = -1;\n  for(i=Q-1; i>=0; --i){\n    int index = ind[a[i]-1];\n    if(index == -1){\n      ind[a[i]-1] = laststock;\n      lastcount[laststock] = 1;\n      laststock++;\n    }else{\n      if(index == 0 || lastcount[index] < lastcount[index-1]){\n        lastcount[index]++;\n      }\n    }\n  }\n  int maxind = -1;\n  int maxcover = N;\n  for(i=0; i<M; ++i){\n    if(ind[i] < 0){break;}\n    bool f1 = false;\n    bool f2 = false;\n    if(ind[i] > maxind){\n      maxind = ind[i];\n      f1 = true;\n    }\n    if(lastcount[ind[i]] <= maxcover){\n      maxcover = lastcount[ind[i]];\n      f2 = true;\n    }\n    if(f1 && f2){\n      lastcount[ind[i]] = N;\n    }\n  }\n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ProblemE.cpp\n\n#include <iostream>\n\nstatic std::istream & ip = std::cin;\nstatic std::ostream & op = std::cout;\n\n#if OJ_MYPC\n#include <ojio.h>\n#endif\n\n#ifndef OPENOJIO\n#define OPENOJIO\n#endif\n\n#if 1 || DEFINE\n/***************************************************************/\ntypedef unsigned long long u64;\ntypedef long long s64;\n\ntypedef unsigned uint;\n\n#define ABS(x) ((x) > 0 ? (x) : -(x))\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\n#define MIN3(x, y, z) MIN(x, MIN(y, z))\n#define MAX3(x, y, z) MAX(x, MAX(y, z))\n\n#define FillZero(arr) memset(arr, 0, sizeof(arr));\n\n/***************************************************************/\n#endif //1 || DEFINE\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\n//001\n//op << setfill('0') << setw(3) << setiosflags(ios::right) << 1;\n\n//op << fixed << setprecision(20);\n\nusing namespace std;\n\n//ProblemE.cpp\n\n#define MAXN 100010\n#define MAXM 100010\n#define MAXQ 100010\n\nint main(int argc, char* argv[])\n{\n\tOPENOJIO;\n\n\tint n, m, q;\n\tstatic int a[MAXQ];\n\n\tip >> n >> m >> q;\n\tfor (int i = 1; i <= q; ++i) ip >> a[i];\n\n\tstatic bool used[MAXM];\n\tfor (int i = 1; i <= m; ++i) used[i] = false;\n\n\tint last[MAXM];\n\tint ilast = 1;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = a[i];\n\t\tused[a[i]] = true;\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = i;\n\t}\n\n\tmap<int, int> mii;\n\tfor (int i = 1; i <= m; ++i)\n\t\tmii[last[i]] = i;\n\n\tstatic int cl[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tcl[i] = 0;\n\tcl[0] = n;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tint index = mii[a[i]];\n\n\t\tif (cl[index - 1] > 0) {\n\t\t\t--cl[index - 1];\n\t\t\t++cl[index];\n\t\t}\n\t}\n\n\tbool rst = true;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (cl[i] == 0) continue;\n\t\tfor (int j = i + 1; j < m; ++j) {\n\t\t\tif (last[j] > last[j + 1]) {\n\t\t\t\trst = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\top << (rst ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n/***************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvoid failure () {\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nconst int MAX_N = 1e5 + 5;\n\nint arr [MAX_N];\nset<int, greater<int>> pos [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, m, qc;\n  cin >> n >> m >> qc;\n\n  for (int i = 0; i < qc; i++) {\n    cin >> arr[i];\n    pos[arr[i]].insert(i);\n  }\n\n  set<int> seen;\n  vector<int> subseq;\n  for (int i = qc - 1; i >= 0; i--) {\n    if (!seen.count(arr[i])) {\n      subseq.push_back(arr[i]);\n      pos[arr[i]].erase(i);\n      seen.insert(arr[i]);\n    }\n  }\n\n  int mn = m + 1;\n  for (int i = 1; i <= m; i++) {\n    if (!seen.count(i)) {\n      mn = min(mn, i);\n    }\n  }\n\n  while (!subseq.empty() && subseq.back() < mn) {\n    mn = subseq.back();\n    subseq.pop_back();\n  }\n\n  int K = subseq.size();\n  if ((ll) K * (ll) n > qc) failure(); // prevent TLE\n\n  for (int i = 0; i < n - 1; i++) {\n    int cur = qc + 1;\n    for (int u : subseq) {\n      if (pos[u].upper_bound(cur) == pos[u].end()) failure();\n      cur = *pos[u].upper_bound(cur);\n      pos[u].erase(cur);\n    }\n  }\n\n  cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,q){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n  REP(i,m) if(st.find(i)==st.end()) b.push_back(i);\n  int x = m-1;\n  while(x>0 && b[x-1] < b[x]) x--;\n\n  REP(i,q) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,q){\n    if(a[i] >= x) continue;\n    c[a[i]] = min(c[a[i]]+1,n);\n    if(a[i]) chmin(c[a[i]],c[a[i]-1]);\n  }\n\n  REP(i,x) if(c[i]<n) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\t//assert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\t//assert(Is_valid_index(range_left));\n\t//assert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    if(l==0){\n        cout << \"AAA\" <<endl;\n        return 0;\n    }\n    REPN(i,1,l){\n        if(dat[i]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100010;\n\nint q[ MAXN ], idx[ MAXN ];\nint seq[ MAXN ];\nbool used[ MAXN ];\nint n, m, k;\n\nint getNextUnuse(int st) {\n    for (int i = st + 1; i <= m; ++i)\n        if (!used[i]) return i;\n    return -1;\n}\n\nint main()\n{\n    cin >> n >> m >> k;\n    for (int i = 1; i <= k; ++i)\n        cin >> q[i];\n    for (int i = k; i >= 1; i--) {\n        int num = q[i];\n        if (idx[num] == 0) seq[++seq[0]] = num;\n        idx[num]++;\n    }\n    int unuse = 1;\n    for (int i = 1; i <= seq[0]; ++i) {\n        used[seq[i]] = true;\n        if (idx[seq[i]]>=n) continue;\n        else if (seq[i] == unuse) {\n            unuse = getNextUnuse(unuse);\n            continue;\n        }\n        else {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, M; cin >> N >> M;\n   vector<int> P(M, -1);\n   vector<int> invP(M, -1);\n   vector<int> freq(M+1);\n   freq[0] = N;\n   int Q; cin >> Q;\n   vector<int> A(Q);\n   for (int i = 0; i < Q; ++i) cin >> A[i], --A[i];\n   int cur = 0;\n   for (int i = Q-1; i >= 0; --i) {\n      int z = A[i];\n      if (invP[z] == -1) {\n         P[cur] = z;\n         invP[z] = cur;\n         freq[cur]--;\n         cur++;\n         freq[cur]++;\n         continue;\n      }\n      if (freq[invP[z]]) {\n         freq[invP[z]]--;\n         freq[invP[z]+1]++;\n      }\n   }\n   for (int i = 0; i < M; ++i) if (invP[i] == -1) P[cur++] = i;\n   cur = 0;\n   while (freq[cur] == 0) cur++;\n   if (is_sorted(P.begin()+cur, P.end())) {\n      cout << \"Yes\\n\";\n   } else {\n      cout << \"No\\n\";\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    unordered_map<int, int> X;\n    vector<int> order;\n    vector<int> num;\n    stack<int> S;\n    int a, b, c;\n    for (int q = 0;q < Q;q++) {\n    \tcin >> a;\n    \tS.push(a);\n    }\n    while (S.size() > 0) {\n    \ta = S.top();\n    \tS.pop();\n    \tif (X.find(a) == X.end()) {\n    \t\tb = X.size();\n    \t\tX[a] = b;\n    \t}\n    \tb = X[a];\n    \tif (b >= order.size()) order.push_back(a);\n    \tif (b >= num.size()) num.push_back(0);\n    \tif (b == 0 && num[0] < M) num[0]++;\n    \telse {\n    \t\tif (num[b - 1] > num[b]) num[b]++;\n    \t}\n    }\n    if (order[order.size() - 1] == 1) {\n    \tN--;\n    \tnum.pop_back();\n    }\n    if (N == 0) {\n    \tcout << \"Yes\" << endl;\n    \treturn 0;\n    }\n    if (num.size() == N && num[N - 1] == M) {\n    \tcout << \"Yes\" << endl;\n    \treturn 0;\n    }\n    bool ok = 1;\n    for (int i = 0;i < order.size();i++) {\n    \tif (order[i] != i + 1) ok = 0;\n    }\n    if (ok == 1) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    int st = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                if(arr[i] != mn) ok = false;\n                for(int k = j; k >= st; k--) pnt[j] = -1;\n                st = j + 1;\n                break;\n            }\n            pnt[j] = pos--;\n        }\n        if(!ok) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 200200;\nint a[maxn];\nbool used[maxn];\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m, q;\n    cin >> n >> m >> q;\n    forn (i, q) {\n        cin >> a[i];\n        --a[i];\n    }\n    vector<int> p;\n    for (int i = q - 1; i >= 0; --i) {\n        if (used[a[i]])\n            continue;\n        int val = a[i];\n        used[val] = true;\n        p.push_back(val);\n    }\n    forn (i, m)\n        if (!used[i])\n            p.push_back(i);\n    assert(sz(p) == m);\n    int pr = 0;\n    //forn (i, m)\n        //cerr << p[i] << ' ';\n    //cerr << '\\n';\n    forn (i, m - 1)\n        if (p[i] > p[i + 1])\n            pr = i + 1;\n    vector<int> rp(m);\n    forn (i, m)\n        rp[p[i]] = i;\n    multiset<int> S;\n    forn (i, n)\n        S.insert(0);\n    for (int i = q - 1; i >= 0; --i) {\n        int x = rp[a[i]];\n        auto it = S.lower_bound(x);\n        int to = x;\n        if (to == x)\n            ++to;\n        S.erase(it);\n        S.insert(to);\n    }\n    if (*S.begin() < pr)\n        cout << \"No\\n\";\n    else\n        cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define maxn 100010\n\nint op[maxn], used[maxn], cnt[maxn], u[maxn], com[maxn], lis[maxn], seq[maxn], where[maxn];\n\nvoid lemon()\n{\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,1,q) scanf(\"%d\",&op[i]);\n\trep(i,1,q) cnt[op[i]]++;\n\tint s=0, zn=0;\n\trepd(i,q,1)\n\t{\n\t\tint ch=op[i];\n\t\tif (used[ch])\n\t\t{\n\t\t\tint which=lower_bound(com+1,com+q+2,-(where[ch]-1))-com;\n\t\t\tif (com[which]!=-(where[ch]-1)) continue;\n\t\t\tcom[which]--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tused[ch]=1;\n\t\t\ts++; seq[s]=ch; where[ch]=s;\n\t\t\tcom[1]--;\n\t\t}\t\n\t}\n\tint place=-com[n];\n\tmemset(used,0,sizeof used);\n\trep(i,1,place) used[seq[i]]=1;\n\tint all=0;\n\trep(i,1,m) if (!used[i]) { all++; lis[all]=i; }\n\tint cpos=1;\n\trep(i,place+1,s)\n\t{\n\t\tif (seq[i]!=lis[cpos])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcpos++;\n\t}\n\tprintf(\"Yes\\n\");\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"e.in\",\"r\",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    REPN(i,1,l){\n        if(dat[i]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tbound[j - 1] = vec[A[i]][idx];\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                int t=v[id].back();v[id].pop_back();\n                if(t>last_used_id[i]){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n    }\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    reverse(ALL(b));\n    while(SZ(b)&&b.back()==1)\n        b.pop_back();\n    reverse(ALL(b));\n    q=SZ(b);\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n\n    \n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, m, q;\nint a[N];\nvector<int> vec[N];\npriority_queue < pair<int, int> > pq;\nint last[N];\nbool del[N];\n\n// BIT\nint T[N];\nvoid upd(int x) { for (; x <= m; x += x & -x) T[x]++; }\nint get(int x) { int ret = 0; for (; x > 0; x -= x & -x) ret += T[x]; return ret; }\nint get_min() {\n\tint low = 1, high = m;\n\twhile(low < high) {\n\t\tint mid = ((low + high) >> 1);\n\t\tif (get(mid) == mid) low = mid + 1;\n\t\telse high = mid;\n\t}\n\treturn low;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m >> q;\n\tfor (int i = 1; i <= q; ++i) {\n\t\tcin >> a[i];\n\t\tpq.push(make_pair(i, a[i]));\n\t\tvec[a[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= n; ++i) last[i] = q + 1;\n\n\twhile(!pq.empty()) {\n\t\tpair<int, int> top = pq.top(); pq.pop();\n\t\tif (del[top.second]) continue;\n\t\tint x = top.second;\n\t\tdel[x] = true;\n\n\t\tint ptr = n;\n\t\twhile(ptr >= 1 && !vec[x].empty()) {\n\t\t\tint pos = vec[x].back();\n\t\t\tvec[x].pop_back();\n\t\t\tif (last[ptr] > pos) last[ptr] = pos, --ptr;\n\t\t}\n\t\t// cerr << x << endl;\n\t\t// for (int i = 1; i <= n; ++i) cerr << last[i] << ' '; cerr << endl;\n\t\t\n\t\tif (ptr != 0) { // invalid\n\t\t\tint smallest = get_min();\n\t\t\tif (x != smallest) return cout << \"No\\n\", 0;\n\t\t\tupd(x); // delete x\n\n\t\t\twhile(!pq.empty()) {\n\t\t\t\ttop = pq.top(); pq.pop();\n\t\t\t\tint nx = top.second;\n\t\t\t\tif (del[nx]) continue;\n\n\t\t\t\tdel[nx] = true;\n\t\t\t\tsmallest = get_min();\n\t\t\t\tif (nx != smallest) return cout << \"No\\n\", 0;\n\t\t\t\tupd(nx);\n\t\t\t}\n\n\t\t\treturn cout << \"Yes\\n\", 0;\n\t\t}\n\n\t\tupd(x); // delete x\n\t}\n\n\tcout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\nint n, m, q;\nint a[100000];\n\nint cnt[100001];\nint pos[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<int> ord;\n\tcin >> n >> m >> q;\n\trep(i, q) cin >> a[i], a[i]--;\n\tset<int> s;\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tif (s.count(a[i]))continue;\n\t\tord.push_back(a[i]);\n\t\ts.insert(a[i]);\n\t}\n\trep(i, m) {\n\t\tif (s.count(i) == 0)ord.push_back(i);\n\t}\n\tint mi;\n\treverse(all(ord));\n\trep(i, m)pos[ord[i]] = i;\n\n\t{\n\t\tint p = 1;\n\t\tfor (int i = 1; i < ord.size(); i++) {\n\t\t\tif (ord[i - 1] < ord[i])break;\n\t\t\tp++;\n\t\t}\n\t\tcnt[mi = p] = n;\n\t}\n\n\trep(i, q) {\n\t\tint p = pos[a[i]];\n\t\tif (cnt[p] > 0) {\n\t\t\tcnt[p]--;\n\t\t\tcnt[p + 1]++;\n\t\t\tif (mi == p && cnt[p] == 0)mi++;\n\t\t}\n\t\telse {\n\t\t\tif (p > 0 && cnt[p - 1] == a[i]) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt[mi]--;\n\t\t\t\tcnt[mi = 0]++;\n\t\t\t\tif (ord[0] == a[i]) {\n\t\t\t\t\tcnt[mi++]--;\n\t\t\t\t\tcnt[mi]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (cnt[m] == n ? \"Yes\" : \"No\") << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint Q;\nint r[111111];\nint num[111111];\n\nsigned main(){\n    cin>>N>>M;\n    cin>>Q;\n    vint A(Q);rep(i,Q)cin>>A[i];\n\n    memset(r,-1,sizeof(r));\n\n    int n=0;\n    for(int i=Q-1;i>=0;i--){\n        int a=A[i]-1;\n        if(r[a]==-1){\n            r[a]=n;\n            n++;\n        }\n        if(r[a]&&num[r[a]-1]<=num[r[a]]);\n        else num[r[a]]++;\n    }\n\n    vint x(n);\n    rep(i,N)if(r[i]!=-1)x[r[i]]=i;\n    rep(i,N)if(r[i]==-1)x.pb(i);\n\n    int k=n;\n    rep(i,n)if(num[i]<N){\n        k=i;\n        break;\n    }\n    bool flag=true;\n    for(int i=k;i+1<N;i++)if(x[i]>x[i+1])flag=false;\n    if(flag)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\nint n, m, q;\nint a[100000];\n\nint cnt[100001];\nint pos[100000];\nbool s[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<int> ord;\n\tcin >> n >> m >> q;\n\trep(i, q) cin >> a[i], a[i]--;\n\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tif (s[a[i]])continue;\n\t\tord.push_back(a[i]);\n\t\ts[a[i]] = true;\n\t}\n\trep(i, m) {\n\t\tif (!s[i])ord.push_back(i);\n\t}\n\n\trep(i, m)pos[ord[i]] = i;\n\tcnt[0] = n;\n\n\tfor (int i = q - 1; i >= 0;i--){\n\t\tint p = pos[a[i]];\n\t\tif (cnt[p] > 0) {\n\t\t\tcnt[p]--;\n\t\t\tcnt[p + 1]++;\n\t\t}\n\t}\n\trep(i,m) {\n\t\tint p = pos[i];\n\t\tcnt[p + 1] += cnt[p];\n\t\tcnt[p] = 0;\n\t}\n\tcout << (cnt[m] == n ? \"Yes\" : \"No\") << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(){\n   int n,m,q;\n   int a[100000];\n   int x[100000];\n   int i,j;\n   int ans;\n\n\n\n   scanf(\"%d %d\",&n,&m);\n   scanf(\"%d\",&q);\n   for(i=0;i<n;++i){\n      x[i]=0;\n   }\n   for(i=0;i<n;++i){\n      ++x[a[i]];\n   }\n\n   ans=1;\n   if(x[a[n-1]]<n){\n      ans=0;\n   }\n\n   printf(\"%s\\n\",(flag?\"Yes\":\"No\"));\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q);\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 2, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M + 1]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M] + que[M + 1];\n                que[M] = 0;\n                que[M + 1] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M + 1] += que[i];\n            }\n        }\n    }\n    que[M + 1] += que[M];\n\n    if(que[M + 1] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MAXN = 1E5 + 10;\n\nint n, m, Q;\nint a[MAXN];\nint b[MAXN], id[MAXN];\nbool vis[MAXN];\nint cnt[MAXN];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor (int i = 1; i <= Q; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int k = 0, j = Q; j > 0; --j)\n\t\tif (!vis[a[j]])\n\t\t\tb[++k] = a[j], vis[a[j]] = true;\n\tfor (int j = m, i = m; i > 0; --i)\n\t\tif (!vis[i])\n\t\t\tb[j--] = i;\n\tfor (int i = 1; i <= m; ++i)\n\t\tid[b[i]] = i;\n\n\tbool flag = true;\n\tcnt[0] = n;\n\tfor (int i = Q; i > 0; --i){\n\t\tint t = id[a[i]];\n\t\tif (cnt[t - 1] > 0){\n\t\t\t--cnt[t - 1];\n\t\t\t++cnt[t];\n\t\t\tvis[t] = true;\n\t\t}\n\t\telse if (!vis[t]){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint l;\n\tfor (l = 0; cnt[l] == 0; ++l);\n\tfor (int i = l + 1; i < m; ++i)\n\t\tflag &= b[i] < b[i + 1];\n\tputs(flag ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = n + Q;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i-1]]){\n\t\t\tf[a[i-1]]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt; i++, j++)\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    if (temp != 1)){\n      minw = min(minw, (int)amc[temp].size()); \n    }\n    for (int i = 0; i < amc[temp].size(); i++){\n      used[amc[temp][i]] = 1;\n    }\n    amc.erase(temp);\n    while(used[tempindex] == 1){\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == (i+1)){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int n,m,q;\n\tstatic int a[100010];\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,q)scanf(\"%d\",&a[i]);\n\t\n\tstatic int b[100010];\n\trep1(i,m)b[i] = q+1;\n\trep(i,q)b[a[i]] = q-i;\n\t\n\tvector<P> vec;\n\trep1(i,m){\n\t\tvec.pb(P(b[i],i));\n\t}\n\tsor(vec);\n\tstatic int c[100010];\n\tint k = 0;\n\trep(i,vec.size()){\n\t\tc[vec[i].sc] = i+1;\n\t\tif(vec[i].fr != q+1)k ++;\n\t}\n\tint t = vec.size()-1;\n\twhile(t > 0 && vec[t-1].sc < vec[t].sc)t --;\n\t\n\t//rep(i,vec.size())printf(\"%lld %lld\\n\",vec[i].fr,vec[i].sc);\n\t\n\t\n\t//cout << c[1] << \" \" << c[2] << \" \" << c[3] << endl;\n\t//cout << t << \" \" << k << endl;\n\t\n\tstatic int cnt[100010] = {};\n\tstatic bool used[100010];\n\trep(i,100010)used[i] = false;\n\tcnt[0] = n;\n\tused[0] = true;\n\trrep(i,q){\n\t\tif(cnt[c[a[i]]-1] > 0){\n\t\t\tcnt[c[a[i]]-1] --;\n\t\t\tcnt[c[a[i]]] ++;\n\t\t\tused[c[a[i]]] = true;\n\t\t}\n\t\telse {\n\t\t\tif(!used[c[a[i]]]){\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << cnt[0] << \" \" << cnt[1] << \" \" << cnt[2] << \" \" << cnt[3] << endl;\n\t\n\tint ret = 0;\n\tfor(int i = t ; i <= k ; i ++)ret += cnt[i];\n\tif(ret == n)puts(\"Yes\");\n\telse puts(\"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n        }\n    }\n\n    bool ok = true;\n    auto cpy = aim;\n    std::reverse(ALL(cpy));\n    for (ll i = 0; i < cpy.size(); i++) if (i + 1 != cpy[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint Q;\nint r[111111];\nint num[111111];\n\nsigned main(){\n    cin>>N>>M;\n    cin>>Q;\n    vint A(Q);rep(i,Q)cin>>A[i];\n\n    memset(r,-1,sizeof(r));\n\n    int n=0;\n    for(int i=Q-1;i>=0;i--){\n        int a=A[i]-1;\n        if(r[a]==-1){\n            r[a]=n;\n            n++;\n        }\n        if(r[a]&&num[r[a]-1]<=num[r[a]]);\n        else num[r[a]]++;\n    }\n\n    vint x(n);\n    rep(i,M)if(r[i]!=-1)x[r[i]]=i;\n    rep(i,M)if(r[i]==-1)x.pb(i);\n\n    int k=n;\n    rep(i,n)if(num[i]<N){\n        k=i;\n        break;\n    }\n    bool flag=true;\n    for(int i=k;i+1<M;i++)if(x[i]>x[i+1])flag=false;\n    if(flag)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ProblemE.cpp\n\n#include <iostream>\n\nstatic std::istream & ip = std::cin;\nstatic std::ostream & op = std::cout;\n\n#if OJ_MYPC\n#include <ojio.h>\n#endif\n\n#ifndef OPENOJIO\n#define OPENOJIO\n#endif\n\n#if 1 || DEFINE\n/***************************************************************/\ntypedef unsigned long long u64;\ntypedef long long s64;\n\ntypedef unsigned uint;\n\n#define ABS(x) ((x) > 0 ? (x) : -(x))\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\n#define MIN3(x, y, z) MIN(x, MIN(y, z))\n#define MAX3(x, y, z) MAX(x, MAX(y, z))\n\n#define FillZero(arr) memset(arr, 0, sizeof(arr));\n\n/***************************************************************/\n#endif //1 || DEFINE\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\n//001\n//op << setfill('0') << setw(3) << setiosflags(ios::right) << 1;\n\n//op << fixed << setprecision(20);\n\nusing namespace std;\n\n//ProblemE.cpp\n\n#define MAXN 100010\n#define MAXM 100010\n#define MAXQ 100010\n\nint main(int argc, char* argv[])\n{\n\tOPENOJIO;\n\n\tint n, m, q;\n\tstatic int a[MAXQ];\n\n\tip >> n >> m >> q;\n\tfor (int i = 1; i <= q; ++i) ip >> a[i];\n\n\tstatic bool used[MAXM];\n\tfor (int i = 1; i <= m; ++i) used[i] = false;\n\n\tint last[MAXM];\n\tint ilast = 1;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = a[i];\n\t\tused[a[i]] = true;\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = i;\n\t}\n\n\tint mii[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tmii[last[i]] = i;\n\n\tstatic int cl[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tcl[i] = 0;\n\tcl[0] = n;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tint index = mii[a[i]];\n\n\t\tif (cl[index - 1] > 0) {\n\t\t\t--cl[index - 1];\n\t\t\t++cl[index];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint index = mii[i];\n\n\t\tcl[index] += cl[index - 1];\n\t\tcl[index - 1] = 0;\n\t}\n\n\tbool rst = cl[m] == n;\n\top << (rst ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n/***************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n        ord[P[i].num] = i;\n    }\n    chk = 1;\n    for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    int ck = 0;\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)ck = 1;\n        if(R[i] < n && (!chk || !ck)){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> a(q);\n  rep(i,q){\n    cin>>a[i]; --a[i];\n  }\n  reverse(all(a));\n  vector<int> fin; fin.reserve(m);\n  vector<int> inv(m,-1),cnt(m);\n  for(int x:a){\n    if(inv[x]<0){\n      inv[x]=fin.size();\n      fin.pb(x);\n    }\n    ++cnt[inv[x]];\n    if(inv[x] && cnt[inv[x]-1]<cnt[inv[x]]){\n      --cnt[inv[x]];\n    }\n  }\n  rep(i,m) if(inv[i]<0){\n    inv[i]=fin.size();\n    fin.pb(i);\n  }\n  //cout<<cnt<<fin;\n  rep(i,m-1) if(cnt[i]<n && fin[i]>fin[i+1]){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    auto A = readVec<int>(Q);\n    for (auto& a : A) { a--; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M; i++) { L[i].push_back(M - i - 1); }\n    for (int i = 0; i < Q; i++) { L[A[i]].push_back(i + M); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, Q + M);\n    for (const auto& o : op) {\n        if (pos[0] < L[o].back()) { return std::cout << \"No\" << std::endl, 0; }\n        for (int i = 0; i < N; i++) {\n            if (pos[i] < M) {\n                while (pos[i] < L[o].back()) {\n                    if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                    L[o].pop_back();\n                }\n                pos[i] = L[o].back();\n                if (L[o].size() > 1) { L[o].pop_back(); }\n                break;\n            } else {\n                while (pos[i] < L[o].back()) {\n                    if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                    L[o].pop_back();\n                }\n                pos[i] = L[o].back();\n                if (L[o].size() > 1) { L[o].pop_back(); }\n            }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 1234567;\n \nint z[N];\nint a[N];\nint pos[N];\nint at[N];\n \nint main() {\n  int n, m, q;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", z + i);\n    z[i]--;\n  }\n  for (int i = 0; i < m; i++) {\n    a[i] = -1;\n    pos[i] = -1;\n    at[i] = 0;\n  }\n  int known = 0;\n  at[0] = n;\n  at[m] = 0;\n  for (int it = q - 1; it >= 0; it--) {\n    int i = z[it];\n    if (pos[i] == -1) {\n      a[known] = i;\n      pos[i] = known;\n      at[known]--;\n      known++;\n      at[known]++;\n      continue;\n    }\n    if (at[pos[i]] > 0) {\n      at[pos[i]]--;\n      at[pos[i] + 1]++;\n    }\n  }\n  int first = -1;\n  for (int i = 0; i <= m; i++) {\n    if (at[i] > 0) {\n      first = i;\n      break;\n    }\n  }\n  vector <int> all;\n  for (int i = first; i < known; i++) {\n    all.push_back(a[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    if (pos[i] == -1) {\n      all.push_back(i);\n    }\n  }\n  sort(all.begin(), all.end());\n  for (int i = first; i < known; i++) {\n    if (all[i - first] != a[i]) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=1; i<=m; i++) b[i]=-1;\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  if (v[0]==1) {\n    for (i=1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) { puts(\"Yes\"); return 0; }\n  }\n  m=int(v.size())-1;\n  if (b[1]!=-1) {\n    for (i=b[1]+1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) m=b[1]-1;\n  }\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=min(n,(j>0)?min(f[j]+1,f[j-1]):(f[j]+1));\n  }\n  puts((f[m]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nint main() {\n\tll N, M, Q;\n\tcin >> N >> M >> Q;\n\tvector<ll> a(Q + 1);\n\trepn(i, Q) cin >> a[i];\n\n\tvector<ll> ar(M + 1,0);\n\tvector<ll> lg(N + 1, 0);\n\n\tfor (ll i = Q; i >= 1; i--) {\n\t\tif(ar[a[i]]==0){\n\t\t\tar[a[i]] = lg[N] + 1;\n\t\t\tlg[N]++;\n\t\t}\n\n\t\telse {\n\t\t\tauto itr = upper_bound(++lg.begin(), lg.end(), ar[a[i]]-1);\n\t\t\t//cout << i << endl << flush;\n\t\t\tll j = distance(lg.begin(), itr) - 1;\n\t\t\t//cout << j << endl << flush;\n\t\t\tif (j >= 1) { lg[j]++; }\n\t\t}\n\t}\n\n\tvector<ll> seq(M+1);\n\trepn(i, M) {\n\t\tif (ar[i] > 0) { seq[ar[i]] = i; }\n\t\t//cout << ar[i] << \" \" << i << endl << flush;\n\t}\n\tll c = lg[N] + 1;\n\t//cout << c << endl;\n\trepn(i, M) {\n\t\tif (ar[i] == 0) { seq[c] = i; c++; }\n\t}\n\n\tstring ans = \"Yes\";\n\tfor (ll i = lg[1] + 1; i <= min(lg[N],M-1); i++) {\n\t\tif (seq[i] > seq[i + 1]) { ans = \"No\"; }\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,q,a[N],vis[N],pos[N],cnt[N];\nVI v;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tassert(n<=3);\n\tscanf(\"%d\",&q);\n\trep(i,0,q) scanf(\"%d\",a+i);\n\treverse(a,a+q);\n\trep(i,0,q) {\n\t\tif (!vis[a[i]]) {\n\t\t\tpos[a[i]]=SZ(v);\n\t\t\tv.pb(a[i]),vis[a[i]]=1;\n\t\t}\n\t}\n\tcnt[0]=n;\n\trep(i,0,q) {\n\t\tint w=pos[a[i]];\n\t\tif (cnt[w]>0) cnt[w]--,cnt[w+1]++;\n\t}\n\trep(i,1,m+1) if (!vis[i]) v.pb(i);\n\trep(i,0,SZ(v)) if (cnt[i]!=0) {\n\t\tbool val=1;\n\t\trep(j,i,m-1) if (v[j]>v[j+1]) val=0;\n\t\tputs(val?\"Yes\":\"No\");\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\nconstexpr int T = 400;\n\nmain() {\n    INT(m, n, q);\n    VEC(int, a, q);\n    reverse(all(a));\n    rep(i, q) a[i]--;\n    vi v;\n    vi rev(n, -1);\n    multiset<int> s;\n    rep(i, m) s.emplace(0);\n    rep(i, q) {\n        if(rev[a[i]] == -1) {\n            rev[a[i]] = v.size();\n            v.eb(a[i]);\n            s.erase(--s.end());\n            s.emplace(v.size());\n        } else {\n            int k = rev[a[i]];\n            auto it = s.find(k);\n            if(it != s.end()) {\n                s.erase(it);\n                s.emplace(k + 1);\n            }\n        }\n        // print(s);\n    }\n    vi t;\n    rep2(i, *s.begin(), *s.rbegin() - 1) { t.eb(v[i]); }\n    rep(i, n) if(rev[i] == -1) t.eb(i);\n    auto tt = t;\n    sort(all(tt));\n    cout << (tt == t ? \"Yes\\n\" : \"No\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint N,M,Q,a;\n\tint num[100000];\n\tint ans;\n\tint c=0;\n\n\tcin >> N >> M >> Q;\n\t\n\tfor (int i=0; i < M; i++) {\n\t\tnum[i] = 0;\n\t}\n\n\tfor (int i=0; i < Q; i++) {\n\t\tcin >> a;\n\t\tnum[a - 1]++;\n\t}\n\tans = num[1] % N;\n\tfor (int i = 1; i < M; i++) {\n\t\tif (ans != num[i] % N) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tc++;\n\t}\n\tif(c==1 && ans != 0){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\n\tcout << \"Yes\" << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int n, m, q;\n    cin >> n >> m >> q;\n    int aa[100005]{0};\n    for(int i = 0; i < q; i++){\n        cin >> aa[i];\n        aa[i]--;\n    }\n    int b[100005]{0};\n    int d[100005];\n    int e[100005];\n    int c = 0;\n    vector<int> v[100005];\n    for(int i = q - 1; i >= 0; i--){\n        int a = aa[i];\n        if(b[a] == 0){\n            d[a] = c;\n            e[c] = a;\n            c++;\n        }\n        if(b[a] < n){\n            if(d[a] == 0 || b[a] < b[e[d[a] - 1]]){\n                v[b[a]].push_back(a);\n                b[a]++;\n            }\n        }\n    }\n    bool f[100005]{0};\n    for(int x : v[0]) f[x] = true;\n    for(int i = 0; i < m; i++){\n        if(!f[i]) v[0].push_back(i);\n    }\n    fill(f, f + m, false);\n    for(int x : v[n - 1]) f[x] = true;\n    for(int i = 0; i < m; i++){\n        if(!f[i]) v[n - 1].push_back(i);\n    }\n    if(v[0] == v[n - 1]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N, M, Q;\nvector<int> a;\n\nvoid Yes()\n{\n    puts(\"Yes\");\n    exit(0);\n}\n\nvoid No()\n{\n    puts(\"No\");\n    exit(0);\n}\n\nint main()\n{\n    cin >> N >> M >> Q;\n    a.resize(Q);\n    cin >> a;\n    reverse(a.begin(), a.end());\n\n    vector<int> tojojun;\n    map<int, int> tojojun_inv;\n    map<int, int> show_count;\n    for (auto v : a)\n    {\n        if (show_count.count(v) == 0)\n        {\n            tojojun_inv[v] = tojojun.size();\n            tojojun.push_back(v);\n            show_count[v] = 1;\n        }\n        else\n        {\n            if (tojojun_inv[v] == 0) show_count[v]++;\n            else\n            {\n                int v_prev = tojojun[tojojun_inv[v] - 1];\n                show_count[v] = min(show_count[v] + 1, show_count[v_prev]);\n            }\n        }\n    }\n\n    int counter = 0;\n    for (auto v : tojojun)\n    {\n        if (counter == 0 and show_count[v] >= N) continue;\n        else if (v == counter + 1) counter++;\n        else No();\n    }\n\n    Yes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n        ord[P[i].num] = i;\n    }\n    chk = 1;\n    for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    int ck = 0;\n    for(i=1;i<=m;i++){\n        if(P[i].t > 0)break;\n        if(P[i].num == 1)ck = 1;\n        if(R[i] < n && (!chk || !ck)){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\t\n\treturn 0;\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    for(int i=0;i<c;i++)cin>>b;\n    if(a%2==1)cout<<\"Yes\"<<endl;\nelse cout<<\"No\"<<endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    if (skipped > 0 && cnt[m] == 0) {\n        ans = false;\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(){\n   int n,m,q;\n   int a[100000];\n   int x[100000];\n   int i;\n   int ans;\n\n   scanf(\"%d %d\",&n,&m);\n   scanf(\"%d\",&q);\n   for(i=0;i<n;++i){\n      x[i]=0;\n   }\n   for(i=0;i<n;++i){\n      ++x[a[i]];\n   }\n\n   ans=1;\n   if(x[a[n-1]]<n){\n      ans=0;\n   }\n\n   printf(\"%s\\n\",(ans?\"Yes\":\"No\"));\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=100005;\nint n,m,q,a[MAXN],pos[MAXN],beg=0,dest[MAXN];\nbool vis[MAXN];\nint cnt[MAXN];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=q;i>0;--i){\n\t\tif(!vis[a[i]]){\n\t\t\tpos[a[i]]=++beg;\n\t\t\tdest[beg]=a[i];\n\t\t\tvis[a[i]]=true;\n\t\t}\n\t}//beg为在a[]中有的数 的数量 \n\tint t=0;\n\tfor(int i=1;i<=m;++i)\n\t\tif(!vis[i])dest[beg+(++t)]=i;//预处理 \n\tcnt[0]=n;\n\tint mx=0;\n\tfor(int i=q;i>0;--i){\n\t\tint o=pos[a[i]];\n\t\tif(cnt[o-1]){\n\t\t\t--cnt[o-1];\n\t\t\t++cnt[o];\n\t\t\tmx=max(mx,o);\n\t\t}/*else if(mx<o-1){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}*/\n\t}\t\n\tint st=n;\n\tfor(int i=0;i<=beg;++i)\n\t\tif(cnt[i]){st=i;break;}\n\tfor(int i=st+2;i<=m;++i)\n\t\tif(dest[i]<dest[i-1]){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nbool okalone(int num,int I){\n\trep(i,num) if(!done[i]) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=1; i<=m; i++) b[i]=-1;\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  if (v[0]==1) {\n    for (i=1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) { puts(\"Yes\"); return 0; }\n  }\n  j=int(v.size())-1;\n  if (b[1]!=-1) {\n    for (i=b[1]+1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) j=b[1]-1;\n  }\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=min(n,(j>0)?min(f[j]+1,f[j-1]):(f[j]+1));\n  }\n  puts((f[j]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define eps (1e-6)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\n#define sq(x) ((x)*(x))\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define INF 1000000000000000000LL\n#define maxn 300005\n\nint a[maxn] , cnt[maxn] , pos[maxn] ;\n\nint main()\n{\n    int n , m ;\n    int q ;\n\n    scanf(\"%d %d\",&n,&m) ;\n    scanf(\"%d\",&q) ;\n\n    for(int i=1; i<=q ; i++) scanf(\"%d\",&a[i]) ;\n\n    vector <int> perm ;\n    set<int> st ;\n    for(int i=1 ; i<=m ; i++) st.insert(i) ;\n\n    for(int i=q ; i>=1 ; i--)\n    {\n        if( st.find(a[i]) != st.end() )\n        {\n            perm.pb(a[i]) ;\n            st.erase( st.find(a[i]) ) ;\n        }\n    }\n\n    for(int v: st) perm.pb(v) ;\n\n    while( perm.size() >= 2 )\n    {\n        int sz = perm.size() ;\n        if( perm[sz-2] < perm[sz-1] ) perm.pop_back() ;\n        else break ;\n    }\n\n    perm.pop_back() ;\n\n    for(int i=1 ; i<=n ; i++) pos[i] = -1 ;\n    for(int i=0 ; i<perm.size() ; i++) pos[ perm[i] ] = i ;\n\n    for(int i=q ; i>=1 ; i--)\n    {\n        if( pos[ a[i] ] == -1 ) continue ;\n\n        if( pos[ a[i] ] == 0 ) cnt[ pos[ a[i] ] ]++ ;\n        else{\n            cnt[ pos[ a[i] ] ]++ ;\n            cnt[ pos[ a[i] ] ] = min( cnt[ pos[a[i]] ] , cnt[ pos[a[i]] - 1 ] ) ;\n        }\n    }\n\n    int fl = 1 ;\n\n    for(int i=0 ; i<perm.size() ; i++)\n    {\n        if( cnt[i] < n ) fl = 0 ;\n    }\n\n    if(fl) printf(\"Yes\\n\") ;\n    else printf(\"No\\n\") ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nstd::vector<int> perm_inv(const std::vector<int> &p) {\n  int len = p.size();\n  std::vector<int> ans(len);\n  for (int i = 0; i < len; ++i) {\n    ans[p[i]] = i;\n  }\n  return ans;\n}\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  assert (target.size() == m);\n  VI inv_t = perm_inv(target);\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nint N, M;\nint a[100100];\nint Q;\n\nint ids[100100];\nint cnts[100100];\nint num;\nint rev_ids[100100];\n\nvoid init(){\n\tfor(int i = 0; i < N; ++i){\n\t\tids[i] = -1;\n\t\tcnts[i] = 0;\n\t}\n\tnum = 0;\n}\n\nbool used[100100];\n\nvoid restore(int *a, int L, int N){\n\tfor(int i = 0; i < N; ++i) used[i] = false;\n\tfor(int i = 0; i < L; ++i) used[a[i]] = true;\n\tint c = L;\n\tfor(int i = 0; i < N; ++i){\n\t\tif(!used[i]) a[c++] = i;\n\t}\n}\n\nint fi[100100];\nint la[100100];\n\nbool solve(){\n\tinit();\n\tfor(int i = Q - 1; i >= 0; --i){\n\t\tint x = a[i];\n\t\tif(ids[x] == -1){\n\t\t\tids[x] = num++;\n\t\t\trev_ids[ids[x]] = x;\n\t\t}\n\t\tint id = ids[x];\n\t\t//printf(\"%d\\n\", id);\n\t\tif(id > 0 && cnts[id - 1] == cnts[id]){\n\t\t\t//nothing\n\t\t} else {\n\t\t\tif(cnts[id] < M){\n\t\t\t\tcnts[id]++;\n\t\t\t}\n\t\t}\n\t}\n\tbool flg = true;\n\tfor(int i = 0; i < N; ++i){\n\t\tif(cnts[i] != 0 && cnts[i] != M){\n\t\t\tflg = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flg) return true;\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d %d\\n\", rev_ids[i], cnts[i]);\n\t}\n\tprintf(\"\\n\");*/\n\tint l1 = 0, l2 = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tif(cnts[i] > 0){\n\t\t\tfi[i] = rev_ids[i];\n\t\t\tl1++;\n\t\t}\n\t\t\n\t\tif(cnts[i] == M){\n\t\t\tla[i] = rev_ids[i];\n\t\t\tl2++;\n\t\t}\n\t}\n\trestore(fi, l1, N);\n\trestore(la, l2, N);\n\t/*for(int i = 0; i < N; ++i){\n\t\tprintf(\"%d %d\\n\", fi[i], la[i]);\n\t}*/\n\tfor(int i = 0; i < N; ++i){\n\t\tif(fi[i] != la[i]) return false;\n\t}\n\treturn true;\n}\n\nvoid input(){\n\tscanf(\"%d%d\", &M, &N);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tscanf(\"%d\", a + i);\n\t\ta[i]--;\n\t}\n}\n\nint main(){\n\tinput();\n\tbool flg = solve();\n\tif(flg) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      j=0;\n      for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n      if(j!=k&&c[k]!=q) f=false; \n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    \n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    bool ans = true;\n    if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n        ans = false;\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  \n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = -1;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n  int endV = S.back();\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV+1) if(S[S.size()-1-i] != endV-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  vi CNT(S.size()+1); CNT.back() = n;\n  if(S.empty()) goto ok;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1 && CNT[ix[A[i]]+1]) {\n      CNT[ix[A[i]]+1]-=1;\n      CNT[ix[A[i]]]+=1;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tif(cur == m+1){\n\t\t\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur == 2) return !puts(\"Yes\");\n\t\t\t\t\treturn !puts(\"No\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint b[100005],c[100005],d[100005],e[100005],f[100005]; bool g[100005];\n\nvector<int> a,v;\n \nconst int INF=1000000009;\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta.push_back(x);\n\t\tb[i]=x;\n\t\tc[x]++;\n\t}\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tint j=1;\n\t\n\tfor(int i=Q-1; i>=0; i--){\n\t\tif(!g[a[i]]){\n\t\t\td[j]=a[i]; g[a[i]]=1; j++;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(g[i]==0){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=j; i<=M; i++){\n\t\td[i]=v[0]; v.erase(v.begin());\n\t}\n\n\tint esize=M; bool no=1;\n\n\tfor(int i=M-1; i>=1; i--){\n\t\tif(d[i]>d[i+1]){\n\t\t\tesize=i; no=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(no) N=N-1;\n\n\tint k=1;\n\n\tfor(int i=esize; i>=1; i--){\n\t\te[k]=d[i]; k++;\n\t}\n\n\tint count=0,time=0; bool find=0;\n\n while(1){\n\n\tk=1; find=0;\n\n\tfor(int i=0; i<a.size(); i++){\n\n\t if(a[i]==e[k]) k++;\n\t \n\t if(k==esize+1){\n\t\tcount++; k=1; find=1;\n\t }\n\n\t}\n\n\tif(!find) break;\n\tif(count>=N) break;\n\n\tk=1;\n\n\tfor(int i=0; i<a.size(); i++){\n\t\tif(a[i]==e[k]){\n\t\t\ta.erase(a.begin()+i); k++;\n\t\t}\n\t\tif(k==esize+1){\n\t\t\tif(time==count) break;\n\t\t\ttime++; k=1;\n\t\t}\n\t}\n\n }\n\n\tif(count>=N) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n, m, q;\nint a[maxn], pos[maxn], apos[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &q) < 3) {\n    return false;\n  }\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n  }\n  return true;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    pos[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    apos[i] = -1;\n  }\n  for (int i = q - 1; i >= 0; i--) {\n    if (apos[a[i]] == -1) {\n      apos[a[i]] = pos[n - 1];\n      pos[n - 1]++;\n    }\n    else {\n      int k = upper_bound(pos, pos + n, apos[a[i]]) - pos - 1;\n      if (k != -1 && pos[k] == apos[a[i]]) {\n        pos[k]++;\n      }\n    }\n  }\n  bool b = true;\n  if (apos[0] != -1) {\n    for (int i = 0; i < pos[n - 1] - apos[0]; i++) {\n      if (apos[i] != apos[0] + i) {\n        b = false;\n      }\n    }\n  }\n  else {\n    b = false;\n  }\n  int x = (b? apos[0] : pos[n - 1]);\n  bool ok = true;\n  for (int i = 0; i < n - 1; i++) {\n    if (pos[i] < x) {\n      ok = false;\n      break;\n    }\n  }\n  printf(ok? \"Yes\\n\" : \"No\\n\");\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  if(F){\n    vector<int> V;\n    int K=0;\n    for(int i=0;i<m;i++){\n      if(P[i]==-1||C[P[i]]<n){\n\tV.push_back(i);\n      }\n      else{\n\tK++;\n      }\n    }\n    for(int i=K;i<N;i++){\n      if(T[i]!=V[i-K]){\n\tF=0;\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m,q;\n  cin >> n >> m >> q;\n  int a[q];\n  rep(i,q) cin >> a[i];\n  map<int,int> ma,mb;\n  vector<int> v;\n  bool u[m+2],f=1;\n  mem(u);\n  rrep(i,q) {\n    if(!ma.count(a[i])) {\n      mb[a[i]]=v.size();\n      v.pb(a[i]);\n      u[a[i]]=1;\n    }\n    ma[a[i]]++;\n    int k=mb[a[i]];\n    if(k&&ma[a[i]]>ma[v[k-1]]) {\n      pr(\"No\");\n      return;\n    }\n  }\n  REP(i,1,m+2) if(!u[i]) v.pb(i);\n  rep(i,v.size()-1) {\n    if(ma[v[i]]<n) f=0;\n    if(!f&&v[i]>v[i+1]) {\n      pr(\"No\");\n      return;\n    }\n  }\n  pr(\"Yes\");\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll N,M, Q;\nvl a;\n\nvoid _main(istream &inp){\n\tinp >> N >> M >> Q;\n\tM++;\n\ta.resize(Q);\n\trep(i,Q){\n\t\tll v;\n\t\tinp >> v;\n\t\tv--;\n\t\ta[Q-1-i] = v;\n\t}\n\tvl inv_seq(M, -1);\n\tll length = 0;\n\tvl cnt(M);\n\tvl seq;\n\trep(j,a.size()){\n\t\tll v = a[j];\n\t\tif(inv_seq[v]==-1){\n\t\t\tinv_seq[v] = length;\n\t\t\tcnt[length]=1;\n\t\t\tlength++;\n\t\t\tseq.push_back(v);\n\t\t}\n\t\telse{\n\t\t\tll ind = inv_seq[v];\n\t\t\tif(ind==0 || cnt[ind-1]>cnt[ind]){\n\t\t\t\tcnt[ind]++;\n\t\t\t}\n\t\t}\n\t}\n\tvl seq2;\n\tvl used(M);\n\tint j = 0;\n\twhile(cnt[j]>=N){\n\t\tseq2.push_back(seq[j]);\n\t\tused[seq[j]]=1;\n\t\tj++;\n\t}\n\trep(k,M) if(used[k]==0 && seq2.size()<seq.size()){\n\t\tseq2.push_back(k);\n\t}\n\t//debug(cnt);debug(seq);debug(seq2);\n\tif(seq==seq2){\n\t\tcout << \"Yes\" <<endl;\n\t}\n\telse{\n\t\tcout << \"No\" << endl;\n\t}\n\n\n\twhile(true){\n\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef BUG\n    #include \"debug.hpp\"\n#else\n    #define DEBUG(var)\n#endif\n\nusing namespace std;\ntemplate< class T1, class T2 > inline istream &\noperator>>( istream & fin, pair< T1, T2 > & pr )\n{ fin >> pr.first >> pr.second; return fin; }\ntemplate< class T0, class T1, class T2 > inline istream &\noperator>>( istream & fin, tuple< T0, T1, T2 > & t )\n{ fin >> get<0>(t) >> get<1>(t) >> get<2>(t); return fin; }\ntemplate< class T > inline istream &\noperator>>( istream & fin, vector< T > & a ) {\nfor(auto & u: a) fin >> u; return fin; }\ntemplate<class T, size_t n> inline istream &\noperator>>( istream & fin, array<T, n> & a ) {\nfor(auto & u: a) fin >> u; return fin; }\ntemplate<class FwdIter> inline auto\ndump(FwdIter first, FwdIter last, const char * dlm = \" \") -> void {\ntypedef typename iterator_traits<FwdIter>::value_type value_type;\ncopy(first, last, ostream_iterator<value_type>(cout, dlm)); }\ntemplate<typename T> vector<T> & operator--(vector<T> & a)\n{ for(auto & i: a) --i; return a; }\n/* @@@ ----------------------------------- */\n\nconst char * task_e()\n{\n    size_t n, m, q;\n    cin >> n >> m >> q;\n    vector<size_t> a(q);\n    cin >> a;\n\n    -- a;\n    reverse(begin(a), end(a));\n\n    vector<size_t> ord;\n    {\n        unordered_set<size_t> obs;\n        for(const auto i: a)\n            if(obs.insert(i).second)\n                ord.push_back(i);\n    }\n\n    DEBUG(ord);\n    // while(!ord.empty() && ord.back() == ord.size() - 1)\n    //     ord.pop_back();\n\n    {\n        bool fail = false;\n        for(size_t i = 0; i < ord.size() && !fail; ++ i)\n            fail = ord[i] != i;\n\n        if(!fail) return \"Yes\";\n    }\n\n    vector<size_t> inv(m, (size_t) -1);\n    for(size_t i = 0; i < ord.size(); ++i)\n        inv[ord[i]] = i;\n\n    DEBUG(inv);\n\n    DEBUG(a);\n\n    vector<size_t> cnt(m, 0);\n    for(const auto i: a)\n        if(inv[i] == 0 || cnt[i] < cnt[ord[inv[i] - 1]])\n            ++ cnt[i];\n\n    if(ord.size() == 1 + *max_element(begin(ord), end(ord)))\n        cnt[ord.back()] = n;\n\n    DEBUG(cnt);\n    for(size_t i = 0; i < m; ++i)\n        if(inv[i] != (size_t) -1 && cnt[i] < n)\n            return \"No\";\n\n    return \"Yes\";\n}\n\nint main(const int argc, char * argv [])\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cout << task_e() << '\\n';\n\n    return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define EPS (1e-10)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nvector<int> v;\nmultiset<int>ms;\nint a[100000];\nset<int> used;\nmap<int, int> mp;\nset<int> s;\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\treverse(a, a + q);\n\tfor (int i = 0; i < q; i++) {\n\t\tif (used.count(a[i]) == 0) {\n\t\t\tv.push_back(a[i]);\n\t\t\tused.insert(a[i]);\n\t\t\ta[i] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tms.insert(v[0]);\n\t}\n\tfor (int i = 0; i + 1 < v.size(); i++) {\n\t\tmp[v[i]] = v[i + 1];\n\t}\n\tint cnt = 0;\n\tbool flag = false;\n\tbool ng = false;\n\trep(i, q) {\n\t\tint val = a[i];\n\t\tif (val == -1)continue;\n\t\tif (ms.count(val)) {\n\t\t\tauto it = ms.lower_bound(val);\n\t\t\tms.erase(it);\n\t\t\tif (v.back() == val) {\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tms.insert(mp[val]);\n\t\t\ts.insert(val);\n\t\t}\n\t\telse {\n\t\t\tif (s.count(val)&&cnt) {\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (val == 1) {\n\t\t\t\t\tif (flag) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (cnt) {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tng = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ng == false && cnt == n - 1) {\n\t\tputs(\"Yes\");\n\t}\n\tms.clear();\n\trep(i, q) {\n\t\tint val = a[i];\n\t\tif (val == 1 && ms.size() + 1 <= n) {\n\t\t\tms.insert(val);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ms.size() == 0) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (ms.count(val - 1)) {\n\t\t\tauto it = ms.lower_bound(val - 1);\n\t\t\tms.erase(it);\n\t\t\tms.insert(val);\n\t\t\tcontinue;\n\t\t}\n\t\tint M = (*ms.rbegin());\n\t\tif (val <= M) {\n\t\t\tcontinue;\n\t\t}\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n}\n/*struct st {\n\tll r, c, a;\n};\nint main() {\n\tint R, C, n; scanf(\"%d%d\", &R, &C, &n);\n\tvector<st>v;\n\trep(i, n) {\n\t\tll r, c, a; scanf(\"%lld%lld%lld\", &r, &c, &a);\n\t\tr--; c--;\n\t\tv.push_back({ r,c,a });\n\t}\n\trep(i, n) {\n\n\t}\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234567;\nint a[N], used[N], d[N], ans[N];\nset<pair<int, int> > f;\nint cn;\n\nvoid inc(int v) {\n  f.erase({d[v], v});\n  ++d[v];\n  f.insert({d[v], v});\n}\n\nvoid add(int x) {\n  used[x] = cn;\n  ans[cn++] = x;\n  inc(0);\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", a + i);\n    --a[i];\n  }\n  for (int i = 0; i < m; i++) used[i] = -1;\n  cn = 0;\n  for (int i = 0; i < n; i++) f.insert({0, i});\n  for (int i = q - 1; i >= 0; i--) {\n    if (used[a[i]] < 0) {\n      add(a[i]);\n      continue;\n    }\n    auto it = f.lower_bound({used[a[i]], -1});\n    if (it == f.end() || it->first != used[a[i]]) {\n      continue;\n    }\n    inc(it->second);\n  }\n  int mn = m;\n  for (int i = 0; i < n; i++) {\n    mn = std::min(mn, d[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    if (used[i] < 0) {\n      add(i);\n    }\n  }\n  for (int i = mn; i + 1 < m; i++) {\n    if (ans[i] > ans[i + 1]) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> pos(m);\n        REP(i, Q) {\n            used.insert(a[i]);\n            pos[a[i]] = i;\n        }\n        vector<P> temp;\n        REP(i, m) if (used.count(i) > 0) temp.pb({-pos[i], i});\n        sort( ALL(temp) );\n        vector<ll> res;\n        REP(i, temp.size()) {\n            res.pb(temp[i].second);\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n/*\n    vector< set<ll> > v(m);\n    REP(i, n) {\n        v[a[i]].insert(i);\n    }\n    set<ll> used;\n    RREP(pos, n) {\n        if (used.size() == n-1) break;\n        if (used.count(a[pos]) > 0) continue;\n        ll x = a[pos];\n\n    }\n    cout << \"Yes\" << endl;\n*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  int q;\n  scanf(\"%d\",&q);\n  vi a(q);\n  rep(i,q) {\n    scanf(\"%d\",&a[i]);\n    --a[i];\n  }\n  reverse(rng(a));\n  vvi p(m);\n  rep(i,q) {\n    p[a[i]].pb(i);\n  }\n  vi used(m);\n  vi r(n);\n  int fr = 0;\n  bool ok = true; \n  rep(i,q) {\n    if (used[a[i]]) continue;\n    int k = 0;\n    rep(j,sz(p[a[i]])) {\n      if (r[k] > p[a[i]][j]) continue;\n      r[k] = p[a[i]][j]; ++k;\n      if (k >= n) break;\n    }\n    if (ok && k == n) {\n    } else {\n      if (fr == a[i]) {\n        ok = false;\n      } else {\n        puts(\"No\");\n        return 0;\n      }\n    }\n    used[a[i]] = 1;\n    while (fr < m && used[fr]) ++fr;\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n  int Q;\n  cin >> Q;\n\n  int len = 0;\n  vector<int> order(m, -1);\n  vector<int> natural(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n\n  vector<int> ac(Q);\n  for (int iter=0; iter<Q; iter++) {\n    cin >> ac[Q-1-iter];\n    ac[Q-1-iter] --;\n  }\n\n  for (int iter=0; iter<Q; iter++) {\n    int a = ac[iter];\n//    printf(\"%d %d\\n\", a, order[a]);\n\n    if (order[a] == -1) {\n      order[a] = len;\n      natural[len] = a;\n      freq[len] --;\n      len ++;\n      freq[len] ++;\n      continue;\n    }\n    if (freq[order[a]] == 0) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n    freq[order[a]] --;\n    freq[order[a]+1] ++;\n  }\n\n  for (int i=0; i<m; i++)\n    if (order[i] == -1) {\n      natural[len++] = i;\n    }\n  int first = 0;\n  for (int i=0; i<=m; i++)\n    if (freq[i]) {\n      first = i;\n      break;\n    }\n  for (int i=first; i+1<m; i++)\n    if (natural[i] > natural[i+1]) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n\n  cout << \"Yes\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ELRU {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m, q; cin >> n >> m >> q;\n      vector<int> a(q);\n      rep(i, q) {\n        cin >> a[i];\n      }\n      reverse(all(a));\n      // value, pos\n      map<int, int> used;\n      vector<int> cnt;\n      vector<int> rev;\n      rep(i, q) {\n        if (used.find(a[i]) == used.end()) {\n          used[a[i]] = cnt.size();\n          debug(i, a[i], used[a[i]]);\n          cnt.push_back(1);\n          rev.push_back(a[i]);\n        } else {\n          int pos = used[a[i]];\n          debug(i, pos);\n          if (pos == 0 || cnt[pos-1] > cnt[pos]) {\n            cnt[pos]++;\n          }\n        }\n      }\n\n      for(int i=0; i<cnt.size(); i++) {\n        debug(i, cnt[i], rev[i]);\n      }\n\n      bool flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (i+1 != rev[i]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        cout << \"Yes\" << endl;\n        return;\n      }\n\n      flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (cnt[i] == n) continue;\n        if (rev[i] == 1 && i == cnt.size()-1) continue;\n        flag = false;\n        break;\n      }\n      cout << (flag ? \"Yes\" : \"No\") << endl;\n    }\n};\n\nsigned main() {\n  ELRU solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\n/* -------------------------------- Library -------------------------------- */\n\n/* ---------------------------------- Main ---------------------------------- */\n\nint main() {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n  vector<int> a(Q);\n  for (int &i: a) { cin >> i; --i; }\n  reverse(ALL(a));\n\n  vector<int> ans;\n  set<int> se;\n  REP(i,M) se.insert(i);\n  for (int i: a) {\n    auto it = se.find(i);\n    if (it != se.end()) {\n      ans.push_back(*it);\n      se.erase(it);\n    }\n  }\n  for (int i: se) ans.push_back(i);\n  int mi = 1e9;\n  while (!ans.empty() && ans.back() < mi) {\n    mi = ans.back(); ans.pop_back();\n  }\n  // for (int i: ans) cout << i << \" \"; cout << endl;\n  vector<int> next2(Q+2), prev2(Q+2);\n  vector<int>::iterator next = begin(next2) + 1;\n  vector<int>::iterator prev = begin(prev2) + 1;\n  REP(i,Q+1) next[i] = i + 1;\n  REP(i,Q+1) prev[i] = i - 1;\n  next[-1] = 0;\n  bool flag = true;\n  REP(i,N) {\n    int pos = next[-1];\n    REP(j,ans.size()) {\n      while (pos < Q && ans[j] != a[pos]) {\n        pos = next[pos];\n      }\n      if (pos == Q) { flag = false; break; }\n      int ne = next[pos];\n      int pr = prev[pos];\n      next[prev[pos]] = ne;\n      prev[next[pos]] = pr;\n    }\n  }\n  cout << (flag ? \"Yes\" : \"No\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  for (int i = 0; i < m; ++i) {\n    se.insert(i);\n  }\n  for (auto e : a) {\n    if (se.empty() or e != *begin(se)) {\n      if (c[e] < n) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    }\n    se.erase(e);\n  }\n  assert(false);\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=1; i<=m; i++) b[i]=-1;\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  for (i=1; i<=m; i++) if (!was[i]) break;\n  for (m=v.size(); m>0 && v[m-1]<i; m--) i=v[m-1];\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=min(n,(j>0)?min(f[j]+1,f[j-1]):(f[j]+1));\n  }\n  puts((m==0 || f[m-1]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000], pr[110000], nx[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tREP(i,m) pr[i] = i-1, nx[i] = i+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\tnx[pr[a[i]]] = nx[a[i]], pr[nx[a[i]]] = pr[a[i]];\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != -nx[-cur[k]]) ans = false;\n\t\t\tif (cur[k] < 0) { cur[k] = j; break; }\n\t\t\telse cur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100010],b[100010],c[100010],s[100010];\n\nint main()\n{\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n\t//\tfreopen(\"output.txt\",\"w\",stdout);\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tint q;scanf(\"%d\",&q);\n\tfor (int i=1;i<=q;i++) scanf(\"%d\",&a[i]);\n\tint l=0;\n\tfor (int i=q;i;i--)\n\t\tif (!c[a[i]])\n\t\t{\n\t\t\tb[++l]=a[i];c[a[i]]=l;s[a[i]]++;\n\t\t}\n\t\telse\n\t\t\tif (c[a[i]]==1||s[b[c[a[i]]-1]]>s[a[i]]) s[a[i]]++;\n\tint k=l+1;\n\tfor (int i=1;i<=l;i++) if (s[b[i]]<n) {k=i;break;}\n\tfor (int i=k+1;i<=l;i++) if (b[i]<b[i-1]) {puts(\"No\");return 0;}\n\tfor (int i=1;i<=m;i++) if (k<=l&&c[i]==0&&i<b[l]) {puts(\"No\");return 0;}\n\tputs(\"Yes\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\treturn 0;\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tint N,M,Q,a;\n\tvector<int> num;\n\tint ans;\n\tint c=0;\n\n\tcin >> N >> M >> Q;\n\t\n\tfor (int i=0; i < M; i++) {\n\t\tnum.push_back(0);\n\t}\n\n\tfor (int i=0; i < Q; i++) {\n\t\tcin >> a;\n\t\tnum[a - 1]++;\n\t}\n\tnum.erase(num.begin());\n\tans = num[0] % N;\n\tfor (int i = 0; i < M-1; i++) {\n\t\tif (ans != num[i] % N) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tc++;\n\t}\n\tif(c==1 && ans != 0){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\n\tcout << \"Yes\" << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nint top;\nbool okalone(int num,int I){\n\tif(num!=top) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t\tif(top==v){\n\t\t\twhile(top<M&&done[top]) top++;\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 505050;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(m, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(rmq.get(pos) == n) continue;\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tassert(false);\n\tREP(i, m) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = n;\n\tforn(i, n) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    int n, m, nq;\n    cin >> n >> m >> nq;\n\n    vector<vector<int>> positions(m);\n    vector<int> q(nq);\n\n    for (int i = 0; i < nq; i++)\n    {\n        cin >> q[i];\n        q[i]--;\n        positions[q[i]].push_back(i);\n    }\n\n    vector<int> lastPos(n, m);\n\n    bool fail = false;\n    int maxNumber = 0;\n    bool maxedOut = false;\n\n    set<int> unused;\n    for (int i = 0; i < m; i++) unused.insert(i);\n    for (int x: q) unused.erase(x);\n\n    vector<int> inFront;\n    for (int x: unused)\n        inFront.push_back(x);\n    reverse(inFront.begin(), inFront.end());\n\n    copy(q.begin(), q.end(), back_inserter(inFront));\n    q = inFront;\n    nq = q.size();\n\n    set<int> used;\n    for (int i = nq - 1; i >= 0; i--)\n    {\n        if (used.count(q[i])) continue;\n\n        //if (used.size() == m) break;\n\n        if (maxedOut)\n        {\n            if (q[i] < maxNumber)\n            {\n                fail = true;\n                break;\n            }\n            maxNumber = q[i];\n            continue;\n        }\n\n        used.insert(q[i]);\n\n        vector<int> newLastPos;\n\n        int j = positions[q[i]].size() - 1;\n        for (int filled = 0; filled < n; filled++)\n        {\n            while (j >= 0 && positions[q[i]][j] > lastPos[filled])\n                j--;\n\n            if (j < 0)\n            {\n                maxedOut = true;\n                maxNumber = q[i];\n                break;\n            }\n\n            newLastPos.push_back(positions[q[i]][j]);\n            j--;\n        }\n\n        lastPos = newLastPos;\n    }\n\n    printf(\"%s\\n\", fail ? \"No\" : \"Yes\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    int st = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                if(arr[i] != mn) ok = false;\n                for(int k = j; k >= st; k--) pnt[k] = -1;\n                st = j + 1;\n                break;\n            }\n            pnt[j] = pos--;\n        }\n        if(!ok) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = m; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= m ){\n\tassert( ss[ v[i] ].find( i-m ) != ss[ v[i] ].end() );\n\tss[ v[i] ].erase( ss[ v[i] ].find( i-m ) );\n      }\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( ( t + 1 ) * n  > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m, -1);\n  vector<int> pos(m, -1);\n  vector<int> freq(m + 1,0);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i]  > 0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n        ans = false;\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 1234567;\n \nint z[N];\nint a[N];\nint pos[N];\nint at[N];\n \nint main() {\n  int n, m, q;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", z + i);\n    z[i]--;\n  }\n  for (int i = 0; i < m; i++) {\n    a[i] = -1;\n    pos[i] = -1;\n    at[i] = 0;\n  }\n  int known = 0;\n  at[0] = n;\n  at[m] = 0;\n  for (int it = q - 1; it >= 0; it--) {\n    int i = z[it];\n    if (pos[i] == -1) {\n      a[known] = i;\n      pos[i] = known;\n      at[known]--;\n      known++;\n      at[known]++;\n      continue;\n    }\n    if (at[pos[i]] > 0) {\n      at[pos[i]]--;\n      at[pos[i] + 1]++;\n    }\n  }\n  int first = -1;\n  for (int i = 0; i <= m; i++) {\n    if (at[i] > 0) {\n      first = i;\n      break;\n    }\n  }\n  vector <int> all;\n  for (int i = first; i < known; i++) {\n    all.push_back(a[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    if (pos[i] == -1) {\n      all.push_back(i);\n    }\n  }\n  //sort(all.begin(), all.end());\n  for (int i = first; i < known; i++) {\n    if (all[i - first] != a[i]) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,ap[500010],f[500010],m,a[500010],used,A[500010],B[500010],AS,BS;\nbool rem(){\n\tint t=0;\n\tFOR(i,1,m) if (!u[i]){\n\t\tif (ap[i]<t) return 0;\n\t\tt=ap[i];\n\t}\n/*\tAS=BS=0;\n\tFOR(i,1,q) if (!u[a[i]] && i==v[a[i]][0]) A[++AS]=a[i];\n\tFOR(i,1,m) if (!u[i]) B[++BS]=i;\n\tFOR(i,1,AS) if (A[i]!=B[i]) return 0;\n*/\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,m) ap[i]=q+1;\n\tFOR(i,1,q){\n\t\tv[a[i]].pb(i);\n\t\tif (ap[a[i]]==n+1) ap[a[i]]=i;\n\t}\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tif (rem()) return puts(\"Yes\"),0;\n\t\tu[a[now]]=1;\n\t\tint t=0;\n\t\tFOR(i,1,n){\n\t\t\twhile (t<SZ(v[a[now]]) && v[a[now]][t]<=f[i]) ++t;\n\t\t\tif (t>=SZ(v[a[now]])){\n\t\t\t\tint tt=1;\n\t\t\t\treturn puts(\"No\"),0;\n\t\t\t}\n\t\t\tf[i]=v[a[now]][t];\n\t\t\t++t;\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = n - 1;\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t\t\tforab(j, i, (int) order.size()) {\n\t\t\t\tif (order[j] != j - i + 1) \n\t\t\t\t\tkek = 0;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos)\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n\nusing namespace std;\n\nint A[SIZE];\nbool use[SIZE];\nvector <int> query[SIZE];\nint dp[SIZE];\n\nint main()\n{\n\tint n,m,q;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tA[i]--;\n\t\tquery[A[i]].push_back(i);\n\t}\n\tvector <int> ord;\n\tfor(int i=q-1;i>=0;i--)\n\t{\n\t\tif(!use[A[i]])\n\t\t{\n\t\t\tord.push_back(A[i]);\n\t\t\tuse[A[i]]=true;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++) if(!use[i]) ord.push_back(i);\n\twhile(ord.size()>=2)\n\t{\n\t\tint sz=ord.size();\n\t\tif(ord[sz-2]>ord[sz-1]) break;\n\t\tord.pop_back();\n\t}ord.pop_back();\n\t//for(int i=0;i<ord.size();i++) printf(\"%d \",ord[i]);puts(\"\");\n\tfor(int i=0;i<n;i++) dp[i]=q;\n\tfor(int i=0;i<ord.size();i++)\n\t{\n\t\tint v=ord[i];\n\t\tint now=0;\n\t\tfor(int j=((int) query[v].size())-1;j>=0;j--)\n\t\t{\n\t\t\tint p=query[v][j];\n\t\t\tif(dp[now]>p)\n\t\t\t{\n\t\t\t\tdp[now]=p;\n\t\t\t\tnow++;\n\t\t\t\tif(now==n) break;\n\t\t\t}\n\t\t}\n\t\tif(now<n)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  if(a.back()==1){\n    Int k=1,flg=1;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]<=k) continue;\n      if(a[i]>k+1){\n\tflg=0;\n\tbreak;\n      }\n      k++;\n    }\n    if(flg){\n      cout<<\"Yes\"<<endl;\n      return 0;\n    }\n  }\n  \n  vector<Int> used(m+1,0);\n  vector<Int> dp(q,n+1);\n  int lst=-1;\n  for(Int b=q-1;b>=0;b--){\n    if(used[a[b]]) continue;\n    if(dp[0]<n){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    used[a[b]]=1;\n    lst=a[b];\n    //cout<<a[b]<<endl;\n    vector<Int> nx(q);\n    Int k=0;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]==a[b]) k++;\n      if(k>n) k=n;\n      nx[i]=k;\n      if(nx[i]>dp[i]){\n\tcout<<\"No\"<<endl;\n\treturn 0;\n      }\n    }\n    swap(dp,nx);\n  }\n  if(lst!=1&&dp[0]<n){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100010],b[100010],c[100010],s[100010];\n\nint main()\n{\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tint q;scanf(\"%d\",&q);\n\tfor (int i=1;i<=q;i++) scanf(\"%d\",&a[i]);\n\tint l=0;\n\tfor (int i=q;i;i--)\n\t\tif (!c[a[i]])\n\t\t{\n\t\t\tb[++l]=a[i];c[a[i]]=l;s[a[i]]++;\n\t\t}\n\t\telse\n\t\t\tif (c[a[i]]==1||s[b[c[a[i]]-1]]>s[a[i]]) s[a[i]]++;\n\tint k=l+1;b[l+1]=0;\n\tfor (int i=1;i<=l;i++) if (s[a[i]]<n) {k=i;break;}\n\tfor (int i=k+1;i<=l;i++) if (b[i]<b[i-1]) {puts(\"No\");return 0;}\n\tfor (int i=1;i<=m;i++) if (c[i]==0&&i<b[k]) {puts(\"No\");return 0;}\n\tputs(\"Yes\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nbool solve1(int n, int m, std::vector<int> a) {\n  return false;\n  if (a[0] != 1) return false;\n  std::vector<int> len(n), cnt(m + 1);\n  for (auto &v: a) {\n    if (v != 1 && cnt[v - 1] == 0) return false;\n    if (cnt[v] == n) continue;\n    if (len[cnt[v]] == v - 1) ++len[cnt[v]], ++cnt[v];\n  }\n  return true;\n}\n\nbool solve2(int n, int m, std::vector<int> a) {\n  std::vector<int> order(m + 1, -1);\n  std::vector<int> len(n, 0), cnt(m + 1, 0);\n  int idx = 0;\n  for (auto &v: a) {\n    if (order[v] == -1) order[v] = ++idx;\n    if (cnt[v] == n) continue;\n    if (len[cnt[v]] == order[v] - 1) ++len[cnt[v]], ++cnt[v];\n  }\n  /*int mx = 0;\n  for (int i = 1; i <= m; ++i) mx = std::max(mx, cnt[i]);\n  if (mx < n) return false;*/\n  //for (int i = 0; i < n; ++i) printf(\"len[%d]=%d\\n\", i, len[i]);\n  //for (int i = 1; i <= m; ++i) printf(\"%d \", order[i]);\n  //puts(\"\");\n  if (order[1] != -1) {\n    bool valid = true;\n    for (int i = 1; i <= idx + 1 - order[1]; ++i) {\n      //printf(\"%d=(%d, %d)\\n\", i, order[i], order[1] + i - 1);\n      if (order[i] != order[1] + i - 1) valid = false;\n    }\n    if (valid) idx = order[1] - 1;\n  }\n  //printf(\"idx=%d\\n\", idx);\n  for (int i = 0; i < n; ++i) {\n    if (len[i] < idx) return false;\n  }\n  return true;\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  std::vector<int> a(q);\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  std::reverse(a.begin(), a.end());\n  if (solve1(n, m, a) || solve2(n, m, a)) puts(\"Yes\");\n  else puts(\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n\nint n, m, q;\nint a[500000];\nvector<int> line;\nint pos[500000];\nint cnt[500000];\n\nsigned main()\n{\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; i++) cin >> a[i];\n    fill(pos, pos + m + 1, -1);\n    for (int i = q - 1; i >= 0; i--)\n    {\n        int x = a[i];\n        if (pos[x] == -1)\n        {\n            pos[x] = line.size();\n            cnt[x]++;\n            line.push_back(x);\n        }\n        else\n        {\n            if (pos[x] == 0)\n            {\n                cnt[x]++;\n                continue;\n            }\n            else\n            {\n                if (cnt[line[pos[x] - 1]] > cnt[x])\n                {\n                    cnt[x]++;\n                }\n            }\n        }\n    }\n    int t = 1;\n    for (int i = 0; i < line.size(); i++)\n    {\n        if (cnt[line[i]] < n)\n        {\n            t = 0;\n        }\n    }\n    if (t) cout << \"Yes\";\n    else\n    {\n        vector<int> g, f;\n        for (int i = 0; i < line.size(); i++)\n        {\n            g.push_back(line[i]);\n            if (cnt[line[i]] >= n) f.push_back(line[i]);\n        }\n        for (int i = 1; i <= m; i++)\n        {\n            if (cnt[i] == 0) g.push_back(i);\n            if (cnt[i] < n) f.push_back(i);\n        }\n        //for (auto e : g) cout << e << \" \"; cout << endl;\n        //for (auto e : f) cout << e << \" \"; cout << endl;\n        if (g == f)\n        {\n            cout << \"Yes\";\n        }\n        else\n        {\n            cout << \"No\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n\t//TYPEDEF\n\ttypedef long long lld;\n\ttypedef unsigned long long u64;\n\ttypedef pair<int, int> pii;\n\n\t//COMPARE\n\ttemplate<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n\ttemplate<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n\ttemplate<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n\ttemplate<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n\t//STL\n\ttemplate<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n\ttemplate<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n\ttemplate<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n\t//BIT\n\tinline int BINT(const int x){ return 1<<x; }\n\tinline lld BLLD(const int x){ return 1LL<<x; }\n\tinline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n\tinline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n\ttemplate<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n\ttemplate<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n\t//CONST VALUE\n\tconst double PI=acos(-1.0);\n\tconst double EPS=1e-5;\n\n\t//CALCULATE\n\ttemplate<class T> inline T SQR(const T x){ return x*x; }\n\ttemplate<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n\t\tif(!y)return 1;else if((y&1)==0){\n\t\t\treturn SQR(POW(x, y>>1));\n\t\t}else return POW(x, y^1)*x;\n\t}\n\n\t//NUMBERIC\n\ttemplate<class T> inline T GCD(const T x, const T y){\n\t\tif(x<0)return GCD(-x, y);\n\t\tif(y<0)return GCD(x, -y);\n\t\treturn (!y)?x:GCD(y, x%y);\n\t}\n\ttemplate<class T> inline T LCM(const T x, const T y){\n\t\tif(x<0)return LCM(-x, y);\n\t\tif(y<0)return LCM(x, -y);\n\t\treturn x*(y/GCD(x, y));\n\t}\n\ttemplate<class T> inline T EEA(const T a, const T b, T &x, T &y){\n\t\t/* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n\t\tif(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n\t\tif(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n\t\tif(!b){\n\t\t\tx=1; y=0; return a;\n\t\t}else{\n\t\t\tT d=EEA(b, a%b, x, y);\n\t\t\tT t=x; x=y; y=t-(a/b)*y;\n\t\t\treturn d;\n\t\t}\n\t}\n\ttemplate<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n\t\tvector<pair<T, int> > ret;\n\t\tif(x<0)x=-x;\n\t\tfor (T i=2;x>1;){\n\t\t\tif(x%i==0){\n\t\t\t\tint count=0;\n\t\t\t\tfor(;x%i==0;x/=i)count++;\n\t\t\t\tret.push_back(MP(i, count));\n\t\t\t}\n\t\t\ti++;if(i>x/i)i=x;\n\t\t}\n\t\treturn ret;\n\t}\n\ttemplate<class T> inline int ISPRIME(const T x){\n\t\tif(x<=1)return 0;\n\t\tfor(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n\t\treturn 1;\n\t}\n\ttemplate<class T> inline T EULARFUNCTION(T x){\n\t\tvector<pair<T, int> > f=FACTORIZE(x);\n\t\tfor(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n\t\t\tx=x/it->first*(it->first-1);\n\t\t}\n\t\treturn x;\n\t}\n\ttemplate<class T> inline T INVERSEE(const T a, const T b=MOD){\n\t\tT x, y;\n\t\tEEA(a, b, x, y);\n\t\treturn x?x:1;\n\t}\n\n\t//REMINDER-LIZATION\n\ttemplate<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n\ttemplate<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n\ttemplate<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n\ttemplate<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n\ttemplate<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n\ttemplate<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n\ttemplate<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n\t\tif(y==0)return 1%m;else if((y&1)==0){\n\t\t\tT1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n\t\t}else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n\t}\n\tinline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n\t\tif(x<y)swap(x, y);\n\t\tlld z=0LL;\n\t\twhile(y>0){\n\t\t\tif(y&1){\n\t\t\t\tMOD_ADD(&z, x, m);\n\t\t\t}\n\t\t\tMOD_ADD(&x, x, m);\n\t\t\ty>>=1;\n\t\t}\n\t\treturn z;\n\t}\n\tinline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n\t\tif(y==0LL)return 1LL%m;else if((y&1)==0LL){\n\t\t\tlld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n\t\t}else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n\t}\n\n\t//MATRIX\n\ttemplate<class T> class MATX{\n\t\tprivate:\n\t\t\tunsigned long hig, wid;\n\t\t\tT *data;\n\n\t\t\tvoid __init(){\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tmemset(this->data, 0, sizeof(T)*this->hig*this->wid);\n\t\t\t}\n\n\t\tpublic:\n\t\t\tMATX(){ \n\t\t\t\tthis->hig=this->wid=1;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _len){\n\t\t\t\tthis->hig=this->wid=_len;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _hig, const unsigned long _wid){\n\t\t\t\tthis->hig=_hig;\n\t\t\t\tthis->wid=_wid;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const MATX &rhs){\n\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t}\n\t\t\t~MATX(){\n\t\t\t\tfree(this->data);\n\t\t\t}\n\n\t\t\tT & operator()(const unsigned long x, const unsigned long y){\n\t\t\t\tif(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tMATX & operator=(const MATX &rhs){\n\t\t\t\tif(this->hig!=rhs.hig || this->wid!=rhs.wid){\n\t\t\t\t\tfree(this->data);\n\t\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\t}\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX operator+(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]+=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator-(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]-=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator*(const MATX &opn) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.hig);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tconst MATX mul(const MATX &opn) const{ return *this*opn; }\n\t\t\ttemplate<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.wid);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tMOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tMATX & operator +=(const MATX &rhs){\n\t\t\t\t*this=*this+rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator -=(const MATX &rhs){\n\t\t\t\t*this=*this-rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator *=(const MATX &rhs){\n\t\t\t\t*this=*this*rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX pow(const unsigned long p) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret*=buff;\n\t\t\t\t\tbuff*=buff;\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\ttemplate<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret=ret.mul(buff, m);\n\t\t\t\t\tbuff=buff.mul(buff, m);\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\n\t\t\tconst T at(const unsigned long x, const unsigned long y) const{\n\t\t\t\tif(x>=this->hig || y>=this->wid)return 0;\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tvoid show() const{\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++){\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tcout<<this->at(x, y)<<\" \";\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set_one(){\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=(x==y)?1:0;\n\t\t\t}\n\n\t};\n\n\t//Complex\n\ttemplate<class T> class complex_t{\n\t\tpublic:\n\t\tT r, i;//real part & imaginary part; x+yi\n\t\tcomplex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n\t\tcomplex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n\t\tcomplex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n\t\tcomplex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n\t};\n\n\ttemplate<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n\t\tfor(int i=1, j=len>>1; i<len-1; i++){\n\t\t\tif(i<j)swap(f[i], f[j]);\n\t\t\tint k=len>>1;\n\t\t\twhile(j>=k){\n\t\t\t\tj-=k;\n\t\t\t\tk>>=1;\n\t\t\t}\n\t\t\tif(j<k)j+=k;\n\t\t}\n\t\tfor(int h=2; h<=len; h<<=1){\n\t\t\tcomplex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n\t\t\tfor(int i=0; i<len; i+=h){\n\t\t\t\tcomplex_t<T> wm(1.0, 0.0);\n\t\t\t\tfor(int j=i; j<i+(h>>1); j++){\n\t\t\t\t\tcomplex_t<T> u = f[j];\n\t\t\t\t\tcomplex_t<T> t = wm*f[j+(h>>1)];\n\t\t\t\t\tf[j] = u+t;\n\t\t\t\t\tf[j+(h>>1)] = u-t;\n\t\t\t\t\twm = wm*wn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!is_dft){\n\t\t\tfor(int i=0; i<len; i++)\n\t\t\t\tf[i].r/=len*1.0;\n\t\t}\n\t}\n\n\t//MILLERRABIN\n\tclass MILLERRABIN{\n\t\tprivate:\n\t\tstatic const int prime_table[12];\n\t\tint witness(lld a, lld d, lld s, lld n){\n\t\t\tlld r=MODL_POW(a, d, n);\n\t\t\tif(r==1 || r==n-1)return 0;\n\t\t\tfor(int i=0; i<s-1; i++){\n\t\t\t\tr = MODL_MUL(r, r, n);\n\t\t\t\tif(r==1)return 1;\n\t\t\t\tif(r==n-1)return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tpublic:\n\t\tint test(const lld n){\n\t\t\tif(n<=2LL) return 0;\n\t\t\tlld p=n-1LL, s=0LL;\n\t\t\twhile(!(p&1)){ p>>=1;s++; }\n\t\t\tfor(int i=0; i<12 && this->prime_table[i]<n; i++){\n\t\t\t\tif(witness(this->prime_table[i], p, s, n))return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t};\n\tconst int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n\t//Computational Geometry\n\n\ttemplate<class T> inline int fsign(const T x){\n\t\tif(x>-eps && x<eps)return 0;\n\t\treturn (x<0.0)?-1:1;\n\t}\n\n\ttemplate<class T> class point_t{\n\t\tpublic:\n\t\tT x, y;\n\t\tpoint_t (){\n\t\t\tthis->x=0.0;\n\t\t\tthis->y=0.0;\n\t\t}\n\t\tpoint_t (const T _x, const T _y){\n\t\t\tthis->x=_x;\n\t\t\tthis->y=_y;\n\t\t}\n\t\tpoint_t operator - (const point_t &rhs) const{\n\t\t\treturn point_t(this->x-rhs.x, this->y-rhs.y);\n\t\t}\n\t\tT operator ^ (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.y - this->y*rhs.x;\n\t\t}\n\t\tT operator * (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.x + this->y*rhs.y;\n\t\t}\n\t\tbool operator < (const point_t &rhs) const{\n\t\t\tif(fsign(this->y-rhs.y)!=0)\n\t\t\t\treturn fsign(this->y-rhs.y)<0;\n\t\t\treturn fsign(this->x-rhs.x)<0;\n\t\t}\n\t\tT cross(const point_t &p, const point_t &q) const{\n\t\t\treturn (p-*this)^(q-*this);\n\t\t}\n\t\tvoid rotate(const double radian){\n\t\t\tT x0=x, y0=y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr;\n\t\t\ty=x0*sinr+y0*cosr;\n\t\t}\n\t\tvoid rotate(const point_t &p, const double radian){\n\t\t\tT x0=x-p.x, y0=y-p.y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr+p.x;\n\t\t\ty=x0*sinr+y0*cosr+p.y;\n\t\t}\n\t\tT dist2(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn (lhs-rhs)*(lhs-rhs);\n\t\t}\n\t\tT dist2(const point_t &rhs) const{\n\t\t\treturn (*this-rhs)*(*this-rhs);\n\t\t}\n\t\tT dist(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn sqrt((lhs-rhs)*(lhs-rhs));\n\t\t}\n\t\tT dist(const point_t &rhs) const{\n\t\t\treturn sqrt((*this-rhs)*(*this-rhs));\n\t\t}\n\t};\n\n\ttemplate<class T> class segment_t{\n\t\tpublic:\n\t\tpoint_t<T> p, q;\n\t\tsegment_t (){\n\t\t\tthis->p.x=this->p.y=0.0;\n\t\t\tthis->q.x=this->q.y=0.0;\n\t\t}\n\t\ttemplate<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n\t\t\tthis->p.x=_p.x;\n\t\t\tthis->p.y=_p.y;\n\t\t\tthis->q.x=_q.x;\n\t\t\tthis->q.y=_q.y;\n\t\t}\n\t\tsegment_t (const T px, const T py, const T qx, const T qy){\n\t\t\tthis->p.x=px;\n\t\t\tthis->p.y=py;\n\t\t\tthis->q.x=qx;\n\t\t\tthis->q.y=qy;\n\t\t}\n\t\tT length() const{\n\t\t\treturn this->p.dist(this->q);\n\t\t}\n\t\tT length2() const{\n\t\t\treturn this->p.dist2(this->q);\n\t\t}\n\t\tint contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n\t\t\tif(ignore_endpoint){\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n\t\t\t}else{\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n\t\t\t}\n\t\t}\n\t\tint intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n\t\t\tif(!ignore_endpoint){\n\t\t\t\tif(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n\t\t\t\t&& fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n\t\t}\n\t\tint intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n\t\t\treturn this->intersection(*this, rhs, ignore_endpoint);\n\t\t}\n\t};\n\n\ttemplate<class T> static int compare_pas(const void *x, const void *y, void *z){\n\t\tconst point_t<T> *p1 = (point_t<T>*)x;\n\t\tconst point_t<T> *p2 = (point_t<T>*)y;\n\t\tconst point_t<T> *p0 = (point_t<T>*)z;\n\t\tint sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n\t\tif(sgn!=0)return -sgn;\n\t\treturn fsign(p0->dist2(*p1)-p0->dist2(*p2));\n\t}\n\ttemplate<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n\t\tint p=0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif(pnts[p]<pnts[i])p=i;\n\t\t}\n\t\tswap(pnts[0], pnts[p]);\n\t\tqsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n\t}\n\n\ttemplate<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n\t\tpolar_angle_sort(pnts, n);\n\t\tm=0;\n\t\tif(n<3)return;\n\t\tidx[m++]=0;\n\t\tidx[m++]=1;\n\t\tfor(int i=2; i<n; i++){\n\t\t\twhile(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n\t\t\tidx[m++]=i;\n\t\t}\n\t}\n\n\n//TAIL_OF_JKI'S_HEADER\n\n#define N 110000\n\nconst int inf=0x3f3f3f3f;\n\nint n, m, len;\nint a[N];\nint nbs[N], nxt[N], pos[N], eid;\nint que[N], r;\n\nvoid add_node(const int p, const int v){\n    nxt[eid]=nbs[v];pos[eid]=p;nbs[v]=eid++;\n}\n\nint cmp(const int x, const int y){\n    return pos[nbs[x]]>pos[nbs[y]];\n}\n\nint fool(){\n    return 1;\n    return 0;\n}\n\nint check(){\n    if(!fool())return 0;\n    for(int k=0; k<n; k++){\n        int til=inf;\n        for(int i=0; i<r; i++){\n            int &p=nbs[que[i]];\n            for(; ~p; p=nxt[p]){\n                if(pos[p]<til)break;\n            }\n            if(~p){\n                til=pos[p];\n                p=nxt[p];\n            }else return 1;\n        }\n    }\n    return 0;\n}\n\nint keep(){\n    for(int i=0; i<r; i++){\n        if(que[i]!=i+1)return 1;\n    }\n    return 0;\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &len)!=EOF){\n        scanf(\"%d\", &m);\n        for(int i=0; i<m; i++)\n            scanf(\"%d\", &a[i]);\n        memset(nbs, 0xff, sizeof(nbs));eid=0;\n        r=0;\n        for(int i=0; i<m; i++){\n            //if(a[i]==1)continue;\n            add_node(i, a[i]);\n            que[r++]=a[i];\n        }\n        sort(que, que+r, cmp);\n        r=unique(que, que+r)-que;\n        if(que[r-1]==1){\n            r--;\n        }\n        if(check() && keep()){\n            printf(\"No\\n\");\n        }else printf(\"Yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 100100\nint n, m, q;\nint a[N];\n\nint b[N];\nint c[N], L;\nbool v[N];\n\nint u[N];\nint fi[N];\n\nint main () {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i ++) {\n\t\tcin >> a[i];\n\t\ta[i] --;\n\t}\n\tif (a[q-1] == 0) {\n\t\tint u = q-1;\n\t\tint nw = 0;\n\t\tbool F = true;\n\t\twhile (nw < n-1 && u >= 0) {\n\t\t\tif (a[u] != nw) {\n\t\t\t\tF = false; break;\n\t\t\t}\n\t\t\twhile (u >= 0 && a[u] <= nw) u--;\n\t\t\tnw ++;\n\t\t}\n\t\tif (F) puts (\"Yes\"); else puts (\"No\");\n\t} else {\n\t\tmemset(v, 0, sizeof v);\n\t\tfor (int i = q-1; i >= 0; i --) if (!v[a[i]]) {\n\t\t\tb[a[i]] = L;\n\t\t\tc[L++] = a[i];\n\t\t}\n\t\tmemset(fi, -1, sizeof fi);\n\t\tmemset(v, 0, sizeof v);\n\t\tfor (int i = q-1; i >= 0; i --) {\n\t\t\tif (b[a[i]] == m-1) continue;\n\t\t\tif (b[a[i]] == 0 && u[0] == n) continue;\n\t\t\tif (b[a[i]] != 0 && u[b[a[i]]-1] == u[b[a[i]]]) continue;\n\t\t\tif (fi[b[a[i]]] == -1) fi[b[a[i]]] = i;\n\t\t\tv[i] = 1;\n\t\t\tu[b[a[i]]] ++;\n\t\t}\n\t\tbool F = true;\n\t\tfor (int i = q-1; i >= 0; i --) if (!v[i]) {\n\t\t\tif (b[a[i]] == m-1) {\n\t\t\t\tif (fi[m-2] < i) {\n\t\t\t\t\tF = false; break;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fi[b[a[i]]] < i) {\n\t\t\t\t\tF = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (F) puts (\"Yes\"); else puts (\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nint a[101010];\n\nset<int> h[101010];\nint p[101010];\nint u[101010];\n\nvoid nie(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tint q;\n\tcin>>q;\n\tfor (int i=0;i<q;i++){\n\t\tcin>>a[i];\n\t\th[a[i]].insert(i);\n\t}\n\tif (a[q-1]==1){\n\t\tint t=1;\n\t\tint ok=1;\n\t\tfor (int i=q-1;i>=0;i--){\n\t\t\tif (a[i]>t+1){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[i]==t+1){\n\t\t\t\tt=a[i];\n\t\t\t}\n\t\t}\n\t\tif (ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tp[i]=q-1;\n\t}\n\tfor (int i=q-1;i>=0;i--){\n\t\tif (u[a[i]]==0){\n\t\t\tu[a[i]]=1;\n\t\t\tint t=a[i];\n\t\t\tfor (int j=1;j<=n;j++){\n\t\t\t\tif (h[t].size()==0){\n\t\t\t\t\tnie();\n\t\t\t\t}\n\t\t\t\tauto it=h[t].upper_bound(p[j]);\n\t\t\t\tif (it==h[t].begin()) nie();\n\t\t\t\tit--;\n\t\t\t\th[t].erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  for (map<int,vector<int> >::iterator iter = am.begin(); iter != am.end(); iter++){\n    if (iter->first != 1){\n      minw = min(minw, (int)iter->second.size());\n    }\n  }\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    //cerr << \"temp:\" << temp << endl;\n    //cerr << \"check1\" << ',' << amc.size() << endl;\n    for (int i = (int)amc[temp].size()-1; (i >= (int)amc[temp].size()-1-minw) && (i >= 0); i--){\n      //cerr << \"check2\" << ',' << amc.size() << endl;\n      used[amc[temp][i]] = 1;\n    }\n    for (int i = 0; (i < minw) && (amc[temp].size() > 0); i++){\n      //cerr << \"check3\" << ',' << amc.size() << endl;\n      amc[temp].pop_back();\n    }\n    if (amc[temp].size() == 0){\n      //cerr << amc.size() << endl;\n      //cerr << \"check4\" << ',' << amc.size() << endl;\n      amc.erase(temp);\n      //cerr << amc.size() << endl;\n    }\n    for (map<int,vector<int> >::iterator iter = amc.begin(); iter != amc.end(); iter++){\n      //cerr << iter->first << endl;\n    }\n    if (tempindex == 0){\n      break;\n    }\n    while(used[tempindex] == 1){\n      //cerr << \"check5\" << endl;\n      if (tempindex == 0){\n        break;\n      }\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == (i+1)){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tif(d[1]) e[1]=d[1];\n\n\tfor(int i=2; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else{\n\t\t\te[i]=e[i-1];\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    int n,m,q;cin>>n>>m>>q;\n    int a[q];\n    rep(i,0,q)cin>>a[i];\n    int num[m+1];\n    fill(num,num+m+1,-1);\n    int now[m+1];\n    fill(now,now+m+1,-1);\n    now[0]=0;\n    int len[n];\n    fill(len,len+n,0);\n    rrep(i,q-1,0){\n        //rep(ii,0,2)cout<<len[ii]<<\" \";\n        //cout<<endl;\n        if(num[a[i]]==-1){\n            num[a[i]]=len[0];\n            len[0]++;\n            \n        }\n        else{\n            int u=n,d=-1;\n            int y=num[a[i]];\n            while(u-d>1){\n                int mid=(u+d)/2;\n                if(len[mid]<=y)u=mid;\n                else d=mid;\n            }\n            //cout<<y<<endl;\n            if(u==n)continue;\n            if(len[u]!=y){\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n            len[u]++;\n        }\n    }\n    //rep(i,0,2)cout<<len[i]<<endl;\n    int le=len[0];\n    int le2=len[n-1];\n    set<int> st;\n    int ka[m+1];\n    fill(ka,ka+m+1,-1);\n    rep(i,1,m+1){\n        if(num[i]>=0)ka[num[i]]=i;\n    }\n    //rep(i,0,3)cout<<ka[i]<<\" \";\n    //cout<<endl;\n    rep(i,1,m+1)st.insert(i);\n    rep(i,0,le2)st.erase(ka[i]);\n    rep(i,le2,le){\n        int u=ka[i];\n        int uu=*st.begin();\n        //cout<<u<<\" \"<<uu<<endl;\n        if(u!=uu){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        st.erase(st.begin());\n    }\n    cout<<\"Yes\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint N, M, Q, i, p, j;\nvector<int> v[Nmax];\nint a[Nmax], last[Nmax];\nbool used[Nmax];\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M >> Q;\n    for(i=1; i<=Q; ++i)\n    {\n        cin >> a[i];\n        v[a[i]].push_back(i);\n    }\n\n    vector<int> ans;\n\n    for(i=Q; i; --i)\n        if(!used[a[i]]) ans.push_back(a[i]), used[a[i]] = 1;\n\n    for(i=1; i<=M; ++i)\n        if(!used[i]) ans.push_back(i);\n\n    for(i=1; i<=N; ++i) last[i] = Q;\n\n    memset(used, 0, sizeof(used));\n\n    bool bad = 0;\n    for(auto it : ans)\n    {\n        p = v[it].size() - 1;\n        for(j=1; j<=N && !bad; ++j)\n        {\n            while(p>=0 && v[it][p] > last[j]) --p;\n            if(p>=0) last[j] = v[it][p], p--;\n                else bad = 1;\n        }\n\n        if(bad) break;\n        used[it] = 1;\n    }\n\n    vector<int> ans2;\n    for(i=1; i<=M; ++i)\n        if(!used[i]) ans2.push_back(i);\n\n    for(i=1; i<=ans2.size(); ++i)\n        if(ans[ans.size()-i] != ans2[ans2.size()-i])\n        {\n            cout << \"No\\n\";\n            return 0;\n        }\n\n    cout << \"Yes\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int M=1e5+10;\nconst int Q=1e5+10;\n\nint n,m,q,a[Q];\nbool vis[M];\nmultiset<int> s[M];\n\nbool solve() {\n    VI v;\n    for ( int i=q; i>=1; i-- ) if ( !vis[a[i]] ) {\n        vis[a[i]]=1;\n        v.PB(a[i]);\n    }\n    REP1(i,1,m) if ( !vis[i] ) v.PB(i);\n    int g=n-1;\n    while ( g>0 && v[g]>v[g-1] ) g--;\n    dump(g,v);\n    REP1(i,1,n) s[a[q]].insert(0);\n    for ( int i=q; i>=1; i-- ) {\n        int x=a[i];\n        if ( s[x].empty() ) continue;\n        int t=*s[x].begin();\n        s[x].erase(s[x].begin());\n        if ( t+1==n ) continue;\n        s[v[t+1]].insert(t+1);\n    }\n    REP(i,M) for ( int j:s[i] ) if ( j<g ) return 0;\n    return 1;\n}\n\nint main() {\n    R(n,m,q);\n    REP1(i,1,q) R(a[i]);\n    bool ans=solve();\n    W(ans?\"Yes\":\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nset<int> s;\n\nstruct bit{\n\tint tree[100005];\n\tvoid add(int x, int v){\n\t\twhile(x <= m){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t\tif(s.find(x) == s.end()) bit.add(x, 1);\n\t\ts.insert(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(x == 1){\n\t\t\tif(bit.query(1 + s.size()) - bit.query(1) == s.size() - (s.find(1) != s.end())){\n\t\t\t\treturn !puts(\"Yes\");\n\t\t\t}\n\t\t}\n\t\tif(s.find(x) == s.end()) continue;\n\t\ts.erase(x);\n\t\tbit.add(x, -1);\n\t\tfor(int j=0; j<n; j++){\n\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\ttime[j] = col[x].back();\n\t\t\tcol[x].pop_back();\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define N 123456\n\nint n, m, q, a[N];\nint s[N], pos[N], arr[N], cnt[N], put;\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfo(i,0,q) scanf(\"%d\", a+i);\n\treverse(a, a+q);\n\n\tcnt[0] = n;\n\tfo(i,0,q) {\n\t\tint at = a[i];\n\t\tif (!s[at]) {\n\t\t\ts[at] = 1;\n\t\t\tpos[at] = ++put;\n\t\t\tarr[pos[at]] = at;\n\t\t\tcnt[pos[at]]++;\n\t\t\tcnt[pos[at]-1]--;\n\t\t} else {\n\t\t\tif (cnt[pos[at]-1]==0) continue;\n\t\t\tcnt[pos[at]-1]--;\n\t\t\tcnt[pos[at]]++;\n\t\t}\n\t}\n\tint ut = 1;\n\tfo(i,0,put) {\n\t\tif (arr[i+1] == ut) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t\tcnt[i] = 0;\n\t\t\tut++;\n\t\t}\n\t}\n\t//fo(i,0,put+1) printf(\"%d %d\\n\", cnt[i], arr[i]);\n\tif (cnt[put] == n) puts(\"Yes\");\n\telse puts(\"No\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nint n, m, q;\nint a[100005];\nset<int> seen;\nint v[100005];\nint iv[100005];\nint r;\n\nint nw[100005];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &q);\n    FO(i,0,q) scanf(\"%d\", a+i);\n    reverse(a,a+q);\n    FO(i,0,q) {\n        if (!seen.count(a[i])) {\n            seen.insert(a[i]);\n            v[r++] = a[i];\n        }\n    }\n    FO(i,1,m+1) if (!seen.count(i)) {\n        v[r++] = i;\n    }\n\n    FO(i,0,m) {\n        //printf(\"%d \", v[i]);\n        iv[v[i]] = i;\n    }\n    //printf(\"\\n\");\n\n    nw[0] = n;\n\n    FO(i,0,q) {\n        int o = iv[a[i]];\n        if (nw[o]) {\n            nw[o]--;\n            nw[o+1]++;\n        }\n    }\n\n    bool bd = false;\n    for (int i = m-2; i >= 0; i--) {\n        if (v[i] > v[i+1]) bd = true;\n        if (bd && nw[i]) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n\nusing namespace std;\n\nint A[SIZE];\nbool use[SIZE];\nvector <int> query[SIZE];\nint dp[SIZE];\n\nint main()\n{\n\tint n,m,q;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tA[i]--;\n\t\tquery[A[i]].push_back(i);\n\t}\n\tvector <int> ord;\n\tfor(int i=q-1;i>=0;i--)\n\t{\n\t\tif(!use[A[i]])\n\t\t{\n\t\t\tord.push_back(A[i]);\n\t\t\tuse[A[i]]=true;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) if(!use[i]) ord.push_back(i);\n\twhile(ord.size()>=2)\n\t{\n\t\tint sz=ord.size();\n\t\tif(ord[sz-2]>ord[sz-1]) break;\n\t\tord.pop_back();\n\t}ord.pop_back();\n\t//for(int i=0;i<ord.size();i++) printf(\"%d \",ord[i]);puts(\"\");\n\tfor(int i=0;i<m;i++) dp[i]=q;\n\tfor(int i=0;i<ord.size();i++)\n\t{\n\t\tint v=ord[i];\n\t\tif(query[v].size()<m)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tint nxt=query[v][query[v].size()-j-1];\n\t\t\tif(dp[j]<nxt)\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[j]=nxt;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ProblemE.cpp\n\n#include <iostream>\n\nstatic std::istream & ip = std::cin;\nstatic std::ostream & op = std::cout;\n\n#if OJ_MYPC\n#include <ojio.h>\n#endif\n\n#ifndef OPENOJIO\n#define OPENOJIO\n#endif\n\n#if 1 || DEFINE\n/***************************************************************/\ntypedef unsigned long long u64;\ntypedef long long s64;\n\ntypedef unsigned uint;\n\n#define ABS(x) ((x) > 0 ? (x) : -(x))\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\n#define MIN3(x, y, z) MIN(x, MIN(y, z))\n#define MAX3(x, y, z) MAX(x, MAX(y, z))\n\n#define FillZero(arr) memset(arr, 0, sizeof(arr));\n\n/***************************************************************/\n#endif //1 || DEFINE\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\n//001\n//op << setfill('0') << setw(3) << setiosflags(ios::right) << 1;\n\n//op << fixed << setprecision(20);\n\nusing namespace std;\n\n//ProblemE.cpp\n\n#define MAXN 100010\n#define MAXM 100010\n#define MAXQ 100010\n\nint main(int argc, char* argv[])\n{\n\tOPENOJIO;\n\n\tint n, m, q;\n\tstatic int a[MAXQ];\n\n\tip >> n >> m >> q;\n\tfor (int i = 1; i <= q; ++i) ip >> a[i];\n\n\tstatic bool used[MAXM];\n\tfor (int i = 1; i <= m; ++i) used[i] = false;\n\n\tint last[MAXM];\n\tint ilast = 1;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = a[i];\n\t\tused[a[i]] = true;\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (used[i])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = i;\n\t}\n\n\tint mii[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tmii[last[i]] = i;\n\n\tstatic int cl[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tcl[i] = 0;\n\tcl[0] = n;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tint index = mii[a[i]];\n\n\t\tif (cl[index - 1] > 0) {\n\t\t\t--cl[index - 1];\n\t\t\t++cl[index];\n\t\t}\n\t}\n\n\tbool rst = true;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (cl[i] == 0) continue;\n\t\tfor (int j = i + 1; j < m; ++j) {\n\t\t\tif (last[j] > last[j + 1]) {\n\t\t\t\trst = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\top << (rst ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n/***************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\treturn 0;\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  { S.pb(n+n); int j = S.size()-1;\n    while((j-1) && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n    S.resize(j);\n  }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  if(S.empty()) goto ok;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1 && CNT[ix[A[i]]+1]) {\n      CNT[ix[A[i]]+1]-=1;\n      CNT[ix[A[i]]]+=1;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = n + Q;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i-1]]){\n\t\t\tf[a[i-1]]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt; i++, j++)\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,q){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n  REP(i,m) if(st.find(i)==st.end()) b.push_back(i);\n  int x = m-1;\n  while(x>0 && b[x-1] < b[x]) x--;\n\n  REP(i,q) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,q){\n    if(a[i] >= x) continue;\n    c[a[i]] = min(c[a[i]]+1,n);\n    if(a[i] && c[a[i]-1] < c[a[i]]) ng();\n  }\n\n  REP(i,x) if(c[i]<n) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define N 123456\n\nint n, m, q, a[N];\nint s[N], pos[N], arr[N], cnt[N], put;\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfo(i,0,q) scanf(\"%d\", a+i);\n\treverse(a, a+q);\n\n\tcnt[0] = n;\n\tfo(i,0,q) {\n\t\tint at = a[i];\n\t\tif (!s[at]) {\n\t\t\ts[at] = 1;\n\t\t\tpos[at] = ++put;\n\t\t\tarr[pos[at]] = at;\n\t\t\tcnt[pos[at]]++;\n\t\t\tcnt[pos[at]-1]--;\n\t\t} else {\n\t\t\tif (cnt[pos[at]-1]==0) continue;\n\t\t\tcnt[pos[at]-1]--;\n\t\t\tcnt[pos[at]]++;\n\t\t}\n\t}\n\tint ut = 1;\n\tfo(i,0,put) {\n\t\tif (arr[i+1] == ut) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t\tcnt[i] = 0;\n\t\t\tut++;\n\t\t}\n\t}\n\t//fo(i,0,put+1) printf(\"%d %d\\n\", cnt[i], arr[i]);\n\tif (cnt[put] == n) puts(\"YES\");\n\telse puts(\"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  int lo = S.size();\n  // for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  goto fail;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\nusing namespace std;\nint n, m, q, a[100009], b[100009], c[100009], d[100009]; vector<int>Z; bool used[100009], OK;\nint main() {\n\tcin >> n >> m >> q; for (int i = 0; i < m; i++)b[i] = -1;\n\tfor (int i = 1; i <= q; i++)cin >> a[i], a[i]--;\n\tfor (int i = q; i >= 1; i--) { if (used[a[i]] == false) { used[a[i]] = true; Z.push_back(a[i]); } }\n\tint E = 1e9; for (int i = 0; i < m; i++) { if (used[i] == false)E = min(E, i); }\n\tif (E > Z[Z.size() - 1]) {\n\t\twhile (Z.size() >= 2 && Z[Z.size() - 2] < Z[Z.size() - 1])Z.pop_back();\n\t\tif (Z[Z.size() - 1] == 0)Z.pop_back();\n\t}\n\tfor (int i = 0; i < Z.size(); i++)b[Z[i]] = i;\n\tif (Z.size() == 0) { cout << \"Yes\" << endl; return 0; }\n\tif (n*Z.size() > q) { cout << \"No\" << endl; return 0; }\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = b[a[i]]; if (num == -1)continue;\n\t\tif (c[num] == n || d[c[num]] < num)continue;\n\t\td[c[num]]++; c[num]++;\n\t}\n\tfor (int i = 0; i < n; i++) { if (d[i] != Z.size())OK = true; }\n\tif (OK == true)cout << \"No\" << endl; else cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#define range(i,a,b) for(int i = (a); i <= (b); i++)\n#define rep(i,b) for(int i = 1; i <= (b); i++)\n#define rrep(i,b) for(int i = (b); i >= 1; i--)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+11,INF=~0u>>2;\nbool vis[N],flag=1;\nint n,m,q,a[N],b[N],id[N],cnt[N],len;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();m=read();q=read();\n\trep(i,q) a[i]=read();\n\trrep(i,q) if(!vis[a[i]]) b[++len]=a[i],vis[a[i]]=1;\n\trep(i,m) if(!vis[i]) b[++len]=i;\n//\trep(i,m) show(b[i]);\n//\tshow(len);\n\trep(i,m) id[b[i]]=i;\n\tcnt[0]=n;\n\trep(i,m) vis[i]=0;\n\trrep(i,q){\n\t\tint t=id[a[i]];\n\t\tif(cnt[t-1]>0) cnt[t-1]--,cnt[t]++,vis[t]=1;\n\t\telse if(!vis[t]){\n\t\t\tflag=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen=0;\n\twhile(cnt[len]==0) len++;\n\trange(i,len+1,m-1) flag&=b[i]<b[i+1];\n\tputs(flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nconst int M = 100005;\n\nint n, m, q;\n\nint a[M];\nbool used[M];\nint cnt[M], ord[M];\nvector<int> seq;\n\nvoid add(int x) {\n  if (!used[x]) {\n    int f = seq.size();\n    used[x] = true;\n    ord[x] = f;\n    if (cnt[f] > 0) {\n      cnt[f] -= 1;\n      cnt[f + 1] += 1;\n    }\n    seq.push_back(x);\n  } else {\n    int k = ord[x];\n    if (cnt[k] > 0) {\n      cnt[k] -= 1;\n      cnt[k + 1] += 1;\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m >> q;\n  for (int i = 0; i < q; i += 1) {\n    cin >> a[i];\n    a[i] -= 1;\n  }\n  reverse(a, a + q);\n  cnt[0] = n;\n  for (int i = 0; i < q; i += 1) add(a[i]);\n  for (int i = 0; i < m; i += 1) if (!used[i]) seq.push_back(i);\n  int sh = 0;\n  while (!cnt[sh]) sh += 1;\n  auto alt = seq;\n  sort(alt.begin() + sh, alt.end());\n  if (alt == seq) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nset<int> s;\n\nstruct bit{\n\tint tree[100005];\n\tvoid add(int x, int v){\n\t\twhile(x <= m){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t\tif(s.find(x) == s.end()) bit.add(x, 1);\n\t\ts.insert(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(s.find(x) == s.end()) continue;\n\t\ts.erase(s.find(x));\n\t\tbit.add(x, -1);\n\t\tif(x == 1){\n\t\t\tif(bit.query(1 + s.size()) == s.size()){\n\t\t\t\treturn !puts(\"Yes\");\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\ttime[j] = col[x].back();\n\t\t\tcol[x].pop_back();\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M * 2, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , m , Q , a[N] , v[N] , _;\nint vis[N] , cnt[N] , pos[N];\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&Q);\n  rep(i,0,Q) scanf(\"%d\",a + i);\n  reverse(a,a+Q);\n  rep(i,0,Q) {\n    if(!vis[a[i]])\n      vis[a[i]]=1,v[++_]=a[i];\n  }\n  rep(i,1,m+1) if(!vis[i])\n    v[++_]=i;\n  rep(i,1,m+1) pos[v[i]]=i;\n  cnt[0]=n;\n  int Max=0;\n  rep(i,0,Q) {\n    int t=pos[a[i]];\n    if(cnt[t - 1]) {\n      cnt[t-1]--;\n      cnt[t]++;\n      Max = max(Max , cnt[t]);\n    } else if(Max < t) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  int Min=0;\n  rep(i,0,m+1) if(cnt[i]) {\n    Min=i;\n    break;\n  }\n  int inc=true;\n  rep(i,Min+2,m+1) inc&=v[i]>v[i-1];\n  puts(inc ? \"Yes\" : \"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n \nint main() {\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n \nconst int INF=1000000009;\n \nbool dcs(int m,int q){\n \n\tif(m==1) return 1;\n \n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(d[m]==0) return 1;\n \telse{\n \t\tif(g[m]) return 1;\n\t\telse{\n\t  \tif(f[m]) return 1;\n\t\t}\n \t}\n \n\treturn 0;\n \n}\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n \n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n \n\tsort(b,b+Q); M=b[Q-1];\n \n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n \n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n \n\tfor(int i=0; i<100005; i++) e[i]=INF;\n \n\tif(d[1]) e[1]=d[1];\n \n\tfor(int i=2; i<=M; i++){\n \n\t\tif(d[i]==0||e[i-1]==INF) e[i]=INF;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]>=e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=e[i-1];\n\t\t}\n \n\t}\n \n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]==0) f[i]=1;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n \n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n \n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0; ) {\n    int da = 0;\n    for (; !Poz[br].empty(); ) {\n      if (ind >= 0 && Poz[br].back() < V[ind]) {\n        R.push_back(Poz[br].back());\n        da = 1;\n        ind--;\n      }\n\n      Poz[br].pop_back();\n    }\n\n    if (!da)\n      Nope();\n  }\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  int tmin = 1;\n  for (int i=q-1; i>=0; i--) {\n    for (; bio[tmin]; tmin++);\n\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] == tmin)\n      continue;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint vis[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    mem(vis, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n\n        vis[a[i]] = 1;\n        if (a[i] == mark) {\n            while (mark <= m && (vis[mark] || M[mark] == 0)) mark++;\n            ans[n] = i;\n            for (int j = i; j > 0; j = f[j]) flag[j] = 1;\n            continue;\n        }\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) return 0;\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\nconst int MAX = 100000;\n\nint n,m;\nint q;\nint a[MAX];\nbool used[MAX];\nint t[MAX];\nint t_i;\nint rev[MAX];\nint cnt[MAX+1];\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&q);\n  REP(i,q)scanf(\"%d\",a+i),--a[i];\n  // calc target sequence\n  FORR(i,0,q){\n    int c = a[i];\n    if(!used[c]){\n      used[c] = true;\n      t[t_i++] = c;\n    }\n  }\n  REP(i,m){\n    if(!used[i])t[t_i++] = i;\n    rev[t[i]] = i;\n  }\n  // split\n  cnt[0] = n;\n  FORR(i,0,q){\n    int c = a[i];\n    int id = rev[c];\n    if(cnt[id]>0){\n      cnt[id]--;\n      cnt[id+1]++;\n    }\n  }\n  REP(i,m){\n    if(cnt[i]>0){\n      bool flag = true;\n      FOR(j,i,m-1){\n        flag = flag && t[j]<t[j+1];\n      }\n      puts(flag?\"Yes\":\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint a[SIZE];\nint d[SIZE],u[SIZE],dn,now[SIZE],no_use[SIZE];\nVI p[SIZE];\nint main(){\n    DRIII(N,M,Q);\n    REP(i,Q)RI(a[Q-1-i]);\n    int upup=1;\n    REP(i,Q){\n        p[a[i]].PB(i);\n        if(!u[a[i]]){\n            if(upup>=a[i])no_use[dn]=1;\n            u[a[i]]=1;\n            while(u[upup])upup++;\n            d[dn++]=a[i];\n        }\n    }\n    while(dn>0&&no_use[dn-1])dn--;\n    MS1(now);\n    REP(i,dn){\n        int it=0;\n        REP(j,N){\n            while(it<SZ(p[d[i]])&&p[d[i]][it]<=now[j])it++;\n            if(it>=SZ(p[d[i]])){\n                puts(\"No\");\n                return 0;\n            }\n            now[j]=p[d[i]][it++];\n        }\n    }\n\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\nint n, m, q, a[100009], b[100009], c[100009], d[100009]; vector<int>Z; bool used[100009], OK;\nint main() {\n\tcin >> n >> m >> q; for (int i = 0; i < m; i++)b[i] = -1;\n\tfor (int i = 1; i <= q; i++)cin >> a[i], a[i]--;\n\tfor (int i = q; i >= 1; i--) { if (used[a[i]] == false) { used[a[i]] = true; Z.push_back(a[i]); } }\n\twhile (Z.size() >= 2 && Z[Z.size() - 2] < Z[Z.size() - 1])Z.pop_back();\n\tif (Z[Z.size() - 1] == 0)Z.pop_back();\n\tfor (int i = 0; i < Z.size(); i++)b[Z[i]] = i;\n\tif (Z.size() == 0) { cout << \"Yes\" << endl; return 0; }\n\tif (n*Z.size() > q) { cout << \"No\" << endl; return 0; }\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = b[a[i]]; if (num == -1)continue;\n\t\tif (c[num] == n || d[c[num]] < num)continue;\n\t\td[c[num]]++; c[num]++;\n\t}\n\tfor (int i = 0; i < n; i++) { if (d[i] != Z.size())OK = true; }\n\tif (OK == true)cout << \"No\" << endl; else cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n\t//TYPEDEF\n\ttypedef long long lld;\n\ttypedef unsigned long long u64;\n\ttypedef pair<int, int> pii;\n\n\t//COMPARE\n\ttemplate<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n\ttemplate<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n\ttemplate<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n\ttemplate<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n\t//STL\n\ttemplate<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n\ttemplate<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n\ttemplate<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n\t//BIT\n\tinline int BINT(const int x){ return 1<<x; }\n\tinline lld BLLD(const int x){ return 1LL<<x; }\n\tinline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n\tinline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n\ttemplate<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n\ttemplate<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n\t//CONST VALUE\n\tconst double PI=acos(-1.0);\n\tconst double EPS=1e-5;\n\n\t//CALCULATE\n\ttemplate<class T> inline T SQR(const T x){ return x*x; }\n\ttemplate<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n\t\tif(!y)return 1;else if((y&1)==0){\n\t\t\treturn SQR(POW(x, y>>1));\n\t\t}else return POW(x, y^1)*x;\n\t}\n\n\t//NUMBERIC\n\ttemplate<class T> inline T GCD(const T x, const T y){\n\t\tif(x<0)return GCD(-x, y);\n\t\tif(y<0)return GCD(x, -y);\n\t\treturn (!y)?x:GCD(y, x%y);\n\t}\n\ttemplate<class T> inline T LCM(const T x, const T y){\n\t\tif(x<0)return LCM(-x, y);\n\t\tif(y<0)return LCM(x, -y);\n\t\treturn x*(y/GCD(x, y));\n\t}\n\ttemplate<class T> inline T EEA(const T a, const T b, T &x, T &y){\n\t\t/* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n\t\tif(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n\t\tif(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n\t\tif(!b){\n\t\t\tx=1; y=0; return a;\n\t\t}else{\n\t\t\tT d=EEA(b, a%b, x, y);\n\t\t\tT t=x; x=y; y=t-(a/b)*y;\n\t\t\treturn d;\n\t\t}\n\t}\n\ttemplate<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n\t\tvector<pair<T, int> > ret;\n\t\tif(x<0)x=-x;\n\t\tfor (T i=2;x>1;){\n\t\t\tif(x%i==0){\n\t\t\t\tint count=0;\n\t\t\t\tfor(;x%i==0;x/=i)count++;\n\t\t\t\tret.push_back(MP(i, count));\n\t\t\t}\n\t\t\ti++;if(i>x/i)i=x;\n\t\t}\n\t\treturn ret;\n\t}\n\ttemplate<class T> inline int ISPRIME(const T x){\n\t\tif(x<=1)return 0;\n\t\tfor(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n\t\treturn 1;\n\t}\n\ttemplate<class T> inline T EULARFUNCTION(T x){\n\t\tvector<pair<T, int> > f=FACTORIZE(x);\n\t\tfor(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n\t\t\tx=x/it->first*(it->first-1);\n\t\t}\n\t\treturn x;\n\t}\n\ttemplate<class T> inline T INVERSEE(const T a, const T b=MOD){\n\t\tT x, y;\n\t\tEEA(a, b, x, y);\n\t\treturn x?x:1;\n\t}\n\n\t//REMINDER-LIZATION\n\ttemplate<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n\ttemplate<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n\ttemplate<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n\ttemplate<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n\ttemplate<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n\ttemplate<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n\ttemplate<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n\t\tif(y==0)return 1%m;else if((y&1)==0){\n\t\t\tT1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n\t\t}else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n\t}\n\tinline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n\t\tif(x<y)swap(x, y);\n\t\tlld z=0LL;\n\t\twhile(y>0){\n\t\t\tif(y&1){\n\t\t\t\tMOD_ADD(&z, x, m);\n\t\t\t}\n\t\t\tMOD_ADD(&x, x, m);\n\t\t\ty>>=1;\n\t\t}\n\t\treturn z;\n\t}\n\tinline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n\t\tif(y==0LL)return 1LL%m;else if((y&1)==0LL){\n\t\t\tlld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n\t\t}else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n\t}\n\n\t//MATRIX\n\ttemplate<class T> class MATX{\n\t\tprivate:\n\t\t\tunsigned long hig, wid;\n\t\t\tT *data;\n\n\t\t\tvoid __init(){\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tmemset(this->data, 0, sizeof(T)*this->hig*this->wid);\n\t\t\t}\n\n\t\tpublic:\n\t\t\tMATX(){ \n\t\t\t\tthis->hig=this->wid=1;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _len){\n\t\t\t\tthis->hig=this->wid=_len;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _hig, const unsigned long _wid){\n\t\t\t\tthis->hig=_hig;\n\t\t\t\tthis->wid=_wid;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const MATX &rhs){\n\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t}\n\t\t\t~MATX(){\n\t\t\t\tfree(this->data);\n\t\t\t}\n\n\t\t\tT & operator()(const unsigned long x, const unsigned long y){\n\t\t\t\tif(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tMATX & operator=(const MATX &rhs){\n\t\t\t\tif(this->hig!=rhs.hig || this->wid!=rhs.wid){\n\t\t\t\t\tfree(this->data);\n\t\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\t}\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX operator+(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]+=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator-(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]-=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator*(const MATX &opn) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.hig);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tconst MATX mul(const MATX &opn) const{ return *this*opn; }\n\t\t\ttemplate<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.wid);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tMOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tMATX & operator +=(const MATX &rhs){\n\t\t\t\t*this=*this+rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator -=(const MATX &rhs){\n\t\t\t\t*this=*this-rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator *=(const MATX &rhs){\n\t\t\t\t*this=*this*rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX pow(const unsigned long p) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret*=buff;\n\t\t\t\t\tbuff*=buff;\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\ttemplate<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret=ret.mul(buff, m);\n\t\t\t\t\tbuff=buff.mul(buff, m);\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\n\t\t\tconst T at(const unsigned long x, const unsigned long y) const{\n\t\t\t\tif(x>=this->hig || y>=this->wid)return 0;\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tvoid show() const{\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++){\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tcout<<this->at(x, y)<<\" \";\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set_one(){\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=(x==y)?1:0;\n\t\t\t}\n\n\t};\n\n\t//Complex\n\ttemplate<class T> class complex_t{\n\t\tpublic:\n\t\tT r, i;//real part & imaginary part; x+yi\n\t\tcomplex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n\t\tcomplex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n\t\tcomplex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n\t\tcomplex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n\t};\n\n\ttemplate<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n\t\tfor(int i=1, j=len>>1; i<len-1; i++){\n\t\t\tif(i<j)swap(f[i], f[j]);\n\t\t\tint k=len>>1;\n\t\t\twhile(j>=k){\n\t\t\t\tj-=k;\n\t\t\t\tk>>=1;\n\t\t\t}\n\t\t\tif(j<k)j+=k;\n\t\t}\n\t\tfor(int h=2; h<=len; h<<=1){\n\t\t\tcomplex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n\t\t\tfor(int i=0; i<len; i+=h){\n\t\t\t\tcomplex_t<T> wm(1.0, 0.0);\n\t\t\t\tfor(int j=i; j<i+(h>>1); j++){\n\t\t\t\t\tcomplex_t<T> u = f[j];\n\t\t\t\t\tcomplex_t<T> t = wm*f[j+(h>>1)];\n\t\t\t\t\tf[j] = u+t;\n\t\t\t\t\tf[j+(h>>1)] = u-t;\n\t\t\t\t\twm = wm*wn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!is_dft){\n\t\t\tfor(int i=0; i<len; i++)\n\t\t\t\tf[i].r/=len*1.0;\n\t\t}\n\t}\n\n\t//MILLERRABIN\n\tclass MILLERRABIN{\n\t\tprivate:\n\t\tstatic const int prime_table[12];\n\t\tint witness(lld a, lld d, lld s, lld n){\n\t\t\tlld r=MODL_POW(a, d, n);\n\t\t\tif(r==1 || r==n-1)return 0;\n\t\t\tfor(int i=0; i<s-1; i++){\n\t\t\t\tr = MODL_MUL(r, r, n);\n\t\t\t\tif(r==1)return 1;\n\t\t\t\tif(r==n-1)return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tpublic:\n\t\tint test(const lld n){\n\t\t\tif(n<=2LL) return 0;\n\t\t\tlld p=n-1LL, s=0LL;\n\t\t\twhile(!(p&1)){ p>>=1;s++; }\n\t\t\tfor(int i=0; i<12 && this->prime_table[i]<n; i++){\n\t\t\t\tif(witness(this->prime_table[i], p, s, n))return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t};\n\tconst int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n\t//Computational Geometry\n\n\ttemplate<class T> inline int fsign(const T x){\n\t\tif(x>-eps && x<eps)return 0;\n\t\treturn (x<0.0)?-1:1;\n\t}\n\n\ttemplate<class T> class point_t{\n\t\tpublic:\n\t\tT x, y;\n\t\tpoint_t (){\n\t\t\tthis->x=0.0;\n\t\t\tthis->y=0.0;\n\t\t}\n\t\tpoint_t (const T _x, const T _y){\n\t\t\tthis->x=_x;\n\t\t\tthis->y=_y;\n\t\t}\n\t\tpoint_t operator - (const point_t &rhs) const{\n\t\t\treturn point_t(this->x-rhs.x, this->y-rhs.y);\n\t\t}\n\t\tT operator ^ (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.y - this->y*rhs.x;\n\t\t}\n\t\tT operator * (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.x + this->y*rhs.y;\n\t\t}\n\t\tbool operator < (const point_t &rhs) const{\n\t\t\tif(fsign(this->y-rhs.y)!=0)\n\t\t\t\treturn fsign(this->y-rhs.y)<0;\n\t\t\treturn fsign(this->x-rhs.x)<0;\n\t\t}\n\t\tT cross(const point_t &p, const point_t &q) const{\n\t\t\treturn (p-*this)^(q-*this);\n\t\t}\n\t\tvoid rotate(const double radian){\n\t\t\tT x0=x, y0=y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr;\n\t\t\ty=x0*sinr+y0*cosr;\n\t\t}\n\t\tvoid rotate(const point_t &p, const double radian){\n\t\t\tT x0=x-p.x, y0=y-p.y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr+p.x;\n\t\t\ty=x0*sinr+y0*cosr+p.y;\n\t\t}\n\t\tT dist2(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn (lhs-rhs)*(lhs-rhs);\n\t\t}\n\t\tT dist2(const point_t &rhs) const{\n\t\t\treturn (*this-rhs)*(*this-rhs);\n\t\t}\n\t\tT dist(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn sqrt((lhs-rhs)*(lhs-rhs));\n\t\t}\n\t\tT dist(const point_t &rhs) const{\n\t\t\treturn sqrt((*this-rhs)*(*this-rhs));\n\t\t}\n\t};\n\n\ttemplate<class T> class segment_t{\n\t\tpublic:\n\t\tpoint_t<T> p, q;\n\t\tsegment_t (){\n\t\t\tthis->p.x=this->p.y=0.0;\n\t\t\tthis->q.x=this->q.y=0.0;\n\t\t}\n\t\ttemplate<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n\t\t\tthis->p.x=_p.x;\n\t\t\tthis->p.y=_p.y;\n\t\t\tthis->q.x=_q.x;\n\t\t\tthis->q.y=_q.y;\n\t\t}\n\t\tsegment_t (const T px, const T py, const T qx, const T qy){\n\t\t\tthis->p.x=px;\n\t\t\tthis->p.y=py;\n\t\t\tthis->q.x=qx;\n\t\t\tthis->q.y=qy;\n\t\t}\n\t\tT length() const{\n\t\t\treturn this->p.dist(this->q);\n\t\t}\n\t\tT length2() const{\n\t\t\treturn this->p.dist2(this->q);\n\t\t}\n\t\tint contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n\t\t\tif(ignore_endpoint){\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n\t\t\t}else{\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n\t\t\t}\n\t\t}\n\t\tint intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n\t\t\tif(!ignore_endpoint){\n\t\t\t\tif(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n\t\t\t\t&& fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n\t\t}\n\t\tint intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n\t\t\treturn this->intersection(*this, rhs, ignore_endpoint);\n\t\t}\n\t};\n\n\ttemplate<class T> static int compare_pas(const void *x, const void *y, void *z){\n\t\tconst point_t<T> *p1 = (point_t<T>*)x;\n\t\tconst point_t<T> *p2 = (point_t<T>*)y;\n\t\tconst point_t<T> *p0 = (point_t<T>*)z;\n\t\tint sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n\t\tif(sgn!=0)return -sgn;\n\t\treturn fsign(p0->dist2(*p1)-p0->dist2(*p2));\n\t}\n\ttemplate<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n\t\tint p=0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif(pnts[p]<pnts[i])p=i;\n\t\t}\n\t\tswap(pnts[0], pnts[p]);\n\t\tqsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n\t}\n\n\ttemplate<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n\t\tpolar_angle_sort(pnts, n);\n\t\tm=0;\n\t\tif(n<3)return;\n\t\tidx[m++]=0;\n\t\tidx[m++]=1;\n\t\tfor(int i=2; i<n; i++){\n\t\t\twhile(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n\t\t\tidx[m++]=i;\n\t\t}\n\t}\n\n\n//TAIL_OF_JKI'S_HEADER\n\n#define N 110000\n\nconst int inf=0x3f3f3f3f;\n\nint n, m, len;\nint a[N];\nint nbs[N], nxt[N], pos[N], eid;\nint que[N], r;\n\nvoid add_node(const int p, const int v){\n    nxt[eid]=nbs[v];pos[eid]=p;nbs[v]=eid++;\n}\n\nint cmp(const int x, const int y){\n    return pos[nbs[x]]>pos[nbs[y]];\n}\n\nint fool(){\n    return 1;\n    return 0;\n}\n\nint check(){\n    if(!fool())return 0;\n    for(int k=0; k<n; k++){\n        int til=inf;\n        for(int i=0; i<r; i++){\n            int &p=nbs[que[i]];\n            for(; ~p; p=nxt[p]){\n                if(pos[p]<til)break;\n            }\n            if(~p){\n                til=pos[p];\n                p=nxt[p];\n            }else return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &len)!=EOF){\n        scanf(\"%d\", &m);\n        for(int i=0; i<m; i++)\n            scanf(\"%d\", &a[i]);\n        memset(nbs, 0xff, sizeof(nbs));eid=0;\n        r=0;\n        for(int i=0; i<m; i++){\n            //if(a[i]==1)continue;\n            add_node(i, a[i]);\n            que[r++]=a[i];\n        }\n        sort(que, que+r, cmp);\n        r=unique(que, que+r)-que;\n        if(que[r-1]==1)r--;\n        for(int i=0; i<=r; i++){\n            if(i==r || que[i]!=i+1){\n                r-=i;\n                for(int j=0; j<r; j++){\n                    que[j]=que[j+i];\n                }\n                break;\n            }\n        }\n        if(check()){\n            printf(\"No\\n\");\n        }else printf(\"Yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  int lo = S.size();\n  // for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  srand(time(0)); if(rand()%2) goto fail; if(rand()%2) goto ok;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = n + Q;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t\tf[a[i]-1]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint a[100001];\nvector<pair<int, int>> num;\nset<int> hoge;\nvector<int> en;\n\nint main(int argc, char **argv) {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n  for (int i = 1; i < M; ++i) {\n    cin >> a[i];\n  }\n  for (int i = M; i >= 1; --i) {\n    if(hoge.find(a[i]) == hoge.end()){\n      hoge.insert(a[i]);\n      en.push_back(a[i]);\n    }\n  }\n  vector<int> foo(hoge.size());\n  for(auto &i : foo){\n    i = N;\n  }\n  for (int i = M; i >= 1; --i) {\n    int cnt = 0;\n    for(auto &j: foo){\n      if(j == a[i]) {\n        j--;\n        continue;\n      }\n      cnt += j;\n      if(cnt > M) {\n        cout << \"No\";\n        return 0;\n      }\n    }\n  }\n  for(auto i : foo){\n    if(i) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, int> PLDI;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nconst LL MOD = 1e9+7;\nconst LL INF = (1e18);\nconst double EPS=1.0e-9;\nconst double PI=atan2(0,-1);\n\n\n\nint main()\n{\n    int n,m,q;\n    cin>>n>>m>>q;\n    vector<int> a(q);\n    REP(i,q)\n        cin>>a[i];\n    \n    bool used[100001];\n    vector<int> b;\n    CLR(used);\n    b.reserve(q);\n    for(int i=q-1;i>=0;i--)\n    {\n        if(!used[a[i]])\n            b.push_back(a[i]);\n    }\n    REP(i,m)\n    {\n        if(!used[i+1])\n            b.push_back(i+1);\n    }\n    vector<int> c(m+1);\n    REP(i,m)\n        c[b[i]]=i+1;\n    \n    bool flag=1;\n    vector<int> d(m+2);\n    d[0]=n;\n    for(int i=q-1;i>=0;i--)\n    {\n        d[c[a[i]]-1]--;\n        if(d[c[a[i]]-1]<0)\n        {\n            d[c[a[i]]-1]=0;\n            continue;\n            //flag=0;\n            //break;\n        }\n        d[c[a[i]]]++;\n    }\n    \n    CLR(used);\n    //used[0]=1;\n        int k=1;\n    REP(i,m+2)\n    {\n        if(d[i]==0)continue;\n        \n        for(int j=0;j<i;j++)\n            used[b[j]]=1;\n        \n        FOR(j,i,m)\n        {\n            if(used[k])\n            {\n                k++; j--;\n                continue;\n            }\n            if(k!=b[j])\n            {\n                flag=0;\n                break;\n            }\n            k++;\n        }\n        \n        break;\n    }\n    \n    if(flag)\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(g[m]){\n\t\tif(dcs(m-1,q-c[m])) return 1;\n\t\telse return 0;\n\t}else{\n\t\tif(dcs(m-1,q-c[m])){\n\t\t\tif(f[m]) return 1;\n\t\t\telse return 0;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1])&&d[i]!=0){\n\t\t\te[i]=d[i];\n\t\t}else{\n\t\t\te[i]=e[i-1];\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1])&&d[i]!=0) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvector<int> vec;\nint freq[100001];\nvi a;\nvi inv;\nbool visited[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, q;\n\tcin >> n >> m >> q; vec.resize(q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tcin >> vec[i]; vec[i]--;\n\t}\n\tfreq[0] = n;\n\treverse(vec.begin(), vec.end());\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(!visited[vec[i]])\n\t\t{\n\t\t\tvisited[vec[i]] = 1;\n\t\t\ta.pb(vec[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(!visited[i]) a.pb(i);\n\t}\n\t//cerr << a.size() << ' ' << n << '\\n';\n\tinv.resize(m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tinv[a[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint f = inv[vec[i]];\n\t\tif(freq[f])\n\t\t{\n\t\t\tfreq[f]--; freq[f+1]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"No\"; return 0;\n\t\t}\n\t}\n\tint idx = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tif(freq[i])\n\t\t{\n\t\t\tidx = i; break;\n\t\t}\n\t}\n\tfor(int i = idx; i < m - 1; i++)\n\t{\n\t\tif(a[i] >= a[i+1]) {cout << \"No\"; return 0;}\n\t}\n\tcout << \"Yes\"; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor : samjia2000\nSource : code festival 2016 qual A E.LRU Puzzle\n*/\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 100005;\n\nint n,m,q;\nint a[N];\nbool bz[N];\nint w[N],lst[N];\nint Rig[N];\nint a1[N],a2[N],k1,k2;\n\nint main(){\n\tn=get();m=get();\n\tq=get();\n\tfo(i,1,q)a[i]=get();\n\tfo(i,1,q){\n\t\tlst[i]=w[a[i]];\n\t\tw[a[i]]=i;\n\t}\n\tfo(i,1,n)Rig[i]=q+1;\n\tfd(i,q,1)\n\tif (!bz[a[i]]){\n\t\tint x=1,w=i;\n\t\tfor(;x<=n&&w;w=lst[w]){\n\t\t\tif(w<Rig[x])Rig[x]=w;\n\t\t\tx++;\n\t\t}\n\t\tif (x>n)bz[a[i]]=1;\n\t\telse{\n\t\t\tfo(x,1,m)if (!bz[x])a1[++k1]=x;\n\t\t\tfd(x,i,1)if (!bz[a[x]])bz[a2[++k2]=a[x]]=1;\n\t\t\tbool pd=1;\n\t\t\tfo(x,1,k2)pd&=(a1[x]==a2[x]);\n\t\t\tif (!pd)return printf(\"No\\n\"),0;\n\t\t\treturn printf(\"Yes\\n\"),0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nbool solve(int n, int m, std::vector<int> a) {\n  std::vector<int> order(m + 1, -1), seq;\n  std::vector<int> len(n, 0), cnt(m + 1, 0);\n  int idx = 0;\n  for (auto &v: a) {\n    if (order[v] == -1) order[v] = ++idx, seq.push_back(v);\n    if (cnt[v] == n) continue;\n    if (len[cnt[v]] == order[v] - 1) ++len[cnt[v]], ++cnt[v];\n  }\n  int mx = m;\n  for (int i = 0; i < n; ++i) {\n    mx = std::min(mx, len[i]);\n  }\n  for (int i = mx; i < idx; ++i) {\n    if (i != mx && seq[i] < seq[i - 1]) return false;\n  }\n  return true;\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  std::vector<int> a(q);\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  std::reverse(a.begin(), a.end());\n  if (solve(n, m, a)) puts(\"Yes\");\n  else puts(\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tvector<ll> not_comp;\n\tREP(i, m) if(!dict.count(i) || cnt[dict[i]] != n) not_comp.pb(i);\n\tsort(ALL(not_comp));\n\tll tmp = 0;\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(idx[i] != not_comp[tmp]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp++;\n\t}\n\tassert(false);\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,Q;\nint A[101010];\nint did[101010];\nint ind[101010];\nvector<int> V;\nint num[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) cin>>A[i];\n\tfor(i=Q-1;i>=0;i--) {\n\t\tdid[A[i]]++;\n\t\tif(did[A[i]]==1) {\n\t\t\tind[A[i]]=V.size();\n\t\t\tV.push_back(A[i]);\n\t\t}\n\t}\n\tFOR(i,M) if(did[i+1]==0) {\n\t\tind[i+1]=V.size();\n\t\tV.push_back(A[i]);\n\t}\n\t\n\twhile(V.size()>=2 && V[V.size()-2]<V[V.size()-1]) V.pop_back();\n\tV.pop_back();\n\t\n\tnum[0]=N;\n\tfor(i=Q-1;i>=0;i--) {\n\t\tif(num[ind[A[i]]]) {\n\t\t\tnum[ind[A[i]]]--;\n\t\t\tnum[ind[A[i]]+1]++;\n\t\t}\n\t}\n\t\n\tFOR(i,V.size()) if(num[i]) return _P(\"No\\n\");\n\t_P(\"Yes\\n\");\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid ext(vector<int> &result, int len, int m, vector<int> &v) {\n    vector<bool> used(m+1, false);\n    for (int i = 0; i < len; i++) {\n        int a = result[i];\n        assert(!used[a]);\n        v.push_back(a);\n        used[a] = true;\n    }\n    for (int i = 1; i <= m; i++) if (!used[i]) v.push_back(i);\n}\n\nint main() {\n    int n, m, q; cin >> n >> m >> q;\n    int a[q];\n    for (int i = 0; i < q; i++) cin >> a[i];\n    vector<int> cnt(m+1, 0), len(n, 0), idx(m+1), result;\n    for (int i = q-1; i >= 0; i--) {\n        if (cnt[a[i]] > 0) {\n            if (len[cnt[a[i]]] == idx[a[i]]) {\n                len[cnt[a[i]]]++;\n                cnt[a[i]]++;\n            }\n        } else {\n            cnt[a[i]]++;\n            len[0]++;\n            idx[a[i]] = result.size();\n            result.push_back(a[i]);\n        }\n        // cerr << \"result = \"; for (int x : result) cerr << x << \" \"; cerr << endl;\n        // cerr << \"length = \"; for (int x : len) cerr << x << ' '; cerr << endl;\n        // cerr << \"idx = \"; for (int x : idx) cerr << x << ' '; cerr << endl;\n        // cerr << \"cnt = \"; for (int x : cnt) cerr << x << ' '; cerr << endl;\n    }\n    vector<int> v1, v2;\n    ext(result, len[0], m, v1);\n    ext(result, len[n-1], m, v2);\n    for (int i = 0; i < n; i++) {\n        // cerr << v1[i] << \" \" << v2[i] << endl;\n        if (v1[i] != v2[i]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include<cmath>\n\n\n\n//#define ATCODER\n\n#ifdef ATCODER\n\t#include<atcoder/all>\n\tusing namespace atcoder;\n#endif\n\n\nusing namespace std;\n\n\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\nusing ll = long long;\n#define print(x) cout << (x) << endl\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n//using ll = __int128_t;\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << \" \\n\"[i==(int)v.size()-1]\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 300010;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\n\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\nvoid Yes(bool cond) { cout << (cond ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool cond) { cout << (cond ? \"YES\" : \"NO\") << '\\n'; }\nusing ld = long double;\n\n\n\nint cnt[100010];\nint ord[100010];//ord[i]=初登場がi番目の要素\nint rev[100010];//rev[i]=要素iの初登場順\nvoid solve() {\n\tint N, M;\n\tcin >> M >> N;\n\tint Q;\n\tcin >> Q;\n\tvector<int>A(Q);\n\tREP(i, Q) {\n\t\tcin >> A[i];\n\t\tA[i]--;\n\t}\n\tint idx = 0;\n\tvector<bool>used(N);\n\tREPR(i, Q) {\n\t\tint v = A[i];\n\t\tif (used[v])continue;\n\t\tord[idx] = v;\n\t\trev[v] = idx;\n\t\tidx++;\n\t\tused[v] = true;\n\t}\n\tREP(i, N) {\n\t\tint v = i;\n\t\tif (used[v])continue;\n\t\tord[idx] = v;\n\t\trev[v] = idx;\n\t\tidx++;\n\t\tused[v] = true;\n\t}\n\tREPR(i, Q) {\n\t\tint v = A[i];\n\t\tint id = rev[v];\n\t\tif (id == 0) {\n\t\t\tif (cnt[v] == M)continue;\n\t\t\telse cnt[v]++;\n\t\t}\n\t\telse {\n\t\t\tint pre = ord[id - 1];\n\t\t\tif (cnt[v] < cnt[pre])cnt[v]++;\n\t\t}\n\t}\n\t//REP(i, N) {\n\t//\tDEBUG(i);\n\t//\tDEBUG(rev[i]);\n\t//\tDEBUG(cnt[i]);\n\t//}\n\tREP(i, N) {\n\t\tint v = i;\n\t\tint id = rev[v];\n\t\tif (id == 0) {\n\t\t\tif (cnt[v] == M)continue;\n\t\t\telse cnt[v] = M;\n\t\t}\n\t\telse {\n\t\t\tint pre = ord[id - 1];\n\t\t\tif (cnt[pre]==M)cnt[v]=M;\n\t\t}\n\t}\n\tbool ok = true;\n\tREP(i, N)if (cnt[i] != M)ok = false;\n\n\tYes(ok);\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\t//while (true)test();\n\tsolve();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    int f=[&](){\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    if(id==*(s.begin())&&i>0){\n                        que.pop();\n                        s.erase(id);\n                        return 1;\n                    }\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n        \n    }\n    return 1;\n    }();\n    if(f==0)return 0;\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    int n, m, nq;\n    cin >> n >> m >> nq;\n\n    vector<vector<int>> positions(m);\n    vector<int> q(nq);\n\n    for (int i = 0; i < nq; i++)\n    {\n        cin >> q[i];\n        q[i]--;\n        positions[q[i]].push_back(i);\n    }\n\n    vector<int> lastPos(n, m);\n\n    bool fail = false;\n    int maxNumber = 0;\n    bool maxedOut = false;\n\n    set<int> used;\n    for (int i = nq - 1; i >= 0; i--)\n    {\n        if (used.count(q[i])) continue;\n\n        used.insert(q[i]);\n\n        //if (used.size() == m) break;\n\n        if (maxedOut)\n        {\n            if (q[i] < maxNumber)\n            {\n                fail = true;\n                break;\n            }\n            maxNumber = q[i];\n            continue;\n        }\n\n        vector<int> newLastPos;\n\n        int j = positions[q[i]].size() - 1;\n        for (int filled = 0; filled < n; filled++)\n        {\n            while (j >= 0 && positions[q[i]][j] > lastPos[filled])\n                j--;\n\n            if (j < 0)\n            {\n                maxedOut = true;\n                maxNumber = q[i];\n                break;\n            }\n\n            newLastPos.push_back(positions[q[i]][j]);\n            j--;\n        }\n\n        lastPos = newLastPos;\n    }\n\n    breakAll:;\n    printf(\"%s\\n\", fail ? \"No\" : \"Yes\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    int lst=0,w=0;\n    for(auto u:st){\n        if(u.second>lst)\n            w++;\n        else\n            w=1;\n        lst=u.second;\n    }\n\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n\n\n    vi g[n];\n    for(int i=0;i<SZ(kek);i++){\n        for(int j=0;j<cnt[kek[i]];j++){\n            g[j].push_back(kek[i]);\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        int p=0;\n        bool fl=true;\n        for(auto u:st){\n            if(SZ(g[i])==p)\n                break;\n            if(g[i][p]!=u.second){\n                fl=false;\n                break;\n            }\n            p++;\n        }\n        if(fl==false){\n            cout<<\"No\";\n            return;\n        }\n        if(w<n-p){\n            cout<<\"No\";\n            return;\n        }\n\n    }\n\n\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\nusing ll = int64_t;\n\nvector<int> transform(int m, const vector<int>& v) {\n  vector<bool> used(m, false);\n  vector<int> res;\n  res.reserve(m);\n  for (int x : v) {\n    if (!used[x]) {\n      res.pb(x);\n      used[x] = true;\n    }\n  }\n  for (int i = 0; i < m; i++)\n    if (!used[i])\n      res.pb(i);\n  return res;\n}\n\nbool is_equal(int m, const vector<int>& ideal, const vector<int>& other) {\n  return transform(m, ideal) == transform(m, other);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<int> queries(k);\n  for (int i = 0; i < k; i++)\n    cin >> queries[i];\n  reverse(all(queries));\n\n  vector<int> ideal;\n  vector<vector<int>> rest;\n\n  for (int q : queries) {\n    --q;\n    bool found = false;\n\n    //cerr << \"process: \" << q << endl;\n\n    if (ideal.empty()) {\n      ideal.pb(q);\n    } else {\n      for (auto& already : rest) {\n        if (already.size() < ideal.size() && ideal[already.size()] == q) {\n          //cerr << \"add\" << endl;\n          already.pb(q);\n          found = true;\n          break;\n        }\n      }\n      if (!found && rest.size() < n - 1 && ideal[0] == q) {\n        //cerr << \"create\" << endl;\n        rest.pb({q});\n        found = true;\n      }\n      if (!found) {\n        //cerr << \"append\" << endl;\n        ideal.pb(q);\n      }\n    }\n  }\n\n  for (const auto& other : rest) {\n    if (!is_equal(m, ideal, other)) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n\n  if (rest.size() < n - 1) {\n    if (!is_equal(m, ideal, {})) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q);\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 2, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M + 1]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M] + que[M + 1];\n                que[M] = 0;\n                que[M + 1] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M + 1] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nint n,m,q,v;\nint a[N], used[N], ord[N], pos[N], sor[N], prog[N];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tFOR(i,q) scanf(\"%d\", &a[i]);\n\tFOR(i,q) a[i]--;\n\tREPD(i,q-1,0) if (!used[a[i]]) {\n\t\tord[v++] = a[i];\n\t}\n\tFORI(i,v) pos[ord[i]] = i;\n\tFOR(i,m) if (!used[i]) ord[v++] = i;\n\tsor[v-1]=sor[v]=1;\n\tREPD(i,v-2,0) sor[i] = sor[i+1] && (ord[i] < ord[i+1]);\n\tREPD(i,q-1,0) {\n\t\tint pp = upper_bound(prog, prog+n, a[i]) - prog - 1;\n\t\tif (pp >= 0) {\n\t\t\tprog[pp]++;\n\t\t}\n\t}\n\t//FOR(i,n) printf(\"%d %d\\n\", i, prog[i]);\n\tbool ok = true;\n\tFOR(i,n) if (!sor[prog[i]]) ok = false;\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n\nusing namespace std;\n\nint A[SIZE];\nbool use[SIZE];\nvector <int> query[SIZE];\nint dp[SIZE];\n\nint main()\n{\n\tint n,m,q;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tA[i]--;\n\t\tquery[A[i]].push_back(i);\n\t}\n\tvector <int> ord;\n\tfor(int i=q-1;i>=0;i--)\n\t{\n\t\tif(!use[A[i]])\n\t\t{\n\t\t\tord.push_back(A[i]);\n\t\t\tuse[A[i]]=true;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++) if(!use[i]) ord.push_back(i);\n\twhile(ord.size()>=2)\n\t{\n\t\tint sz=ord.size();\n\t\tif(ord[sz-2]>ord[sz-1]) break;\n\t\tord.pop_back();\n\t}ord.pop_back();\n\t//for(int i=0;i<ord.size();i++) printf(\"%d \",ord[i]);puts(\"\");\n\tfor(int i=0;i<n;i++) dp[i]=q;\n\tfor(int i=0;i<ord.size();i++)\n\t{\n\t\tint v=ord[i];\n\t\tif(query[v].size()<n)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tint nxt=query[v][query[v].size()-j-1];\n\t\t\tif(dp[j]<nxt)\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[j]=nxt;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N, M, Q;\nvector<int> as;\nvector<int> vs[114514];\nvector<int> needs[114514];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int q;\n    cin >> q;\n    as.eb(q);\n  }\n\n  reps(i, 1, N) needs[0].eb(i);\n\n  set<int> has;\n  rrep(i, Q) {\n    int t = as[i];\n    if (needs[t].empty()) {\n      if (has.count(t)) continue;\n      has.insert(t);\n      vs[0].eb(t);\n      needs[t].swap(needs[0]);\n    } else {\n      int idx = needs[t].back(); needs[t].pop_back();\n      vs[idx].eb(t);\n      assert(vs[0].size() >= vs[idx].size());\n      if (vs[0].size() == vs[idx].size()) needs[0].eb(idx);\n      else needs[vs[0][vs[idx].size()]].eb(idx);\n    }\n  }\n\n  int m = vs[0].size();\n  int incr = 0;\n  set<int> st;\n  rep(i, M) st.insert(i+1);\n  rep(i, m) {\n    int v = vs[0][i];\n    if (st.count(v)) {\n      if (v != *st.begin()) incr = i+1;\n      st.erase(v);\n    }\n  }\n\n  reps(i, 1, N) {\n    if (incr > vs[i].size()) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=q;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n\n  set<int> rest;\n  REP(i,m) rest.insert(i);\n\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    done[val]=1;\n    rest.erase(val);\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(rest.empty() || (*rest.begin()>=val)){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n        ++j;\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    // int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        // else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    bool ans = true;\n    // if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n    //     ans = false;\n    // }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint N , M , Q;\nint a[100010];\nint x[100010];\nint o[100010];\nint c;\nint f , e;\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &M , &Q);\n\tfor(int i = 0 ; i < Q ; ++i){\n\t\tscanf(\"%d\" , a + i);\n\t}\n\tc = 0;\n\tf = 0;\n\te = 0;\n\tx[0] = N;\n\tfor(int i = Q - 1 ; i >= 0 ; --i){\n\t\tif(o[a[i]] == 0){\n\t\t\t++e;\n\t\t\to[a[i]] = e;\n\t\t\twhile(o[c + 1] > 0) ++c;\n\t\t\tif(c < a[i]){\n\t\t\t\tf = e;\n\t\t\t}\n\t\t}\n\t\tif(x[o[a[i]] - 1] > x[o[a[i]]]) ++x[o[a[i]]];\n\t}\n\tfor(int i = 1 ; i <= f ; ++i){\n\t\tif(x[i] < N){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nvector<int> t,co;\nint dp[MAX];\nint cz[MAX];\nint il = 0;\nint kt[MAX];\nint n,m,q;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    int pom;\n    cin >> pom;\n    pom--;\n    t.PB(pom);\n  }\n  reverse(ALL(t));\n  for(int el:t){\n    if(!cz[el]){\n      cz[el] = 1;\n      kt[el] = il;\n      il++;\n      co.PB(el);\n    }\n    int pom = kt[el];\n    dp[pom]++;\n    if(pom != 0)\n      mini(dp[pom],dp[pom-1]);\n  }\n  int naj = 0;\n  while(cz[naj])naj++;\n  debug(naj);\n  while(!co.empty() && naj > co.back()){\n    naj = co.back();\n    co.pop_back();\n  }\n  il = SZ(co);\n  debug(il);\n  if(il == 0 || dp[il-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,n){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n\n  REP(i,n) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,n){\n    c[i] = max(c[i]+1,m);\n    if(i && c[i-1] < c[i]) ng();\n  }\n\n  REP(i,c.size()) if(c[i]<m) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::queue<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    cut[qv[0]] = true;\n    std::queue<ll> free;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].push(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n            while (free.size()) {\n                nxts[e].push(free.front());\n                free.pop();\n            }\n        } else {\n            ll idx = st.front();\n            st.pop();\n            cnts[idx]++;\n            st.pop();\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].push(idx);\n            else free.push(idx);\n        }\n    }\n    \n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n\n    {\n        bool ok = true;\n        for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n        if (ok) return true;\n    }\n    \n    {\n        std::priority_queue<ll, vec<ll>, std::greater<ll>> lack;\n        bool ok = true;\n        for (ll i = minv; i < aim.size(); i++) lack.push(aim[i]); \n        for (ll i = 1; i <= m; i++) if (!cut[i]) lack.push(i);\n        for (ll i = minv; i < aim.size(); i++) {\n            ll e = aim[i];\n            if (e != lack.top()) ok = false;\n            lack.pop();\n        }\n        if(ok) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nbool ch1(vector<int> ve,int n){\n\tvector<int> vis(n+2,0);\n\tvector<int> ans;\n\t\n\tfor(int i=(int)ve.size()-1;i>=0;i--){\n\t\tint q=ve[i];\n\t//cout<<q<<endl;\n\t\tif(vis[q])continue;\n\t\tans.pb(q);\n\t\tvis[q]=1;\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i])ans.pb(i);\n\t//for(int i=0;i<n;i++)cout<<ans[i]<<\" \";\n\t//cout<<endl;\n\tfor(int i=0;i<n;i++)if(ans[i]!=i+1)return 0;\n\t\n\treturn 1;\n}\n\nbool ch2(vector<int> ve,int n,int m){\n\tvector<int> vis(n+2,-1);\n\tvector<int> ima(n+10,0);\n\tima[0]=m;\n\tint ko=0;\n\tvector<int> X;\n\tfor(int i=(int)ve.size()-1;i>=0;i--){\n\t\tint v=ve[i];\n\t\t\n\t\tif(vis[v]>=0){\n\t\t\tif(ima[vis[v]-1]){\n\t\t\t\tima[vis[v]-1]--;\n\t\t\t\tima[vis[v]]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tko++;\n\t\t\tvis[v]=ko;\n\t\t\tima[ko-1]--;\n\t\t\tima[ko]++;\n\t\t\t\n\t\t\tX.pb(v);\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=1;i<=n;i++)if(vis[i]==-1)X.pb(i);\n\t//for(auto v:X)cout<<v<<\" \";\n\t//cout<<endl;\n\tint r=-1;\n\tfor(int i=0;;i++){\n\t\tif(ima[i]){\n\t\t\tr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout<<r<<endl;\n\tfor(int i=r;i<n-1;i++)if(X[i]>X[i+1])return 0;\n\treturn 1;\n}\n\n\nsigned main(){\n\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n,m,q;\n\tcin>>n>>m>>q;\n\tvector<int> ve(q);\n\tfor(int i=0;i<q;i++)cin>>ve[i];\n\t\n\tif(ch1(ve,m)){\n\t\n\t\tcout<<\"Yes\"<<endl;\n\t\treturn 0;\n\t}\n\tif(ch2(ve,m,n)){\n\t\tcout<<\"Yes\"<<endl;\n\t\treturn 0;\n\t\t\n\t}\ncout<<\"No\"<<endl;\n\t\n\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    \n    \n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[100010],a[100010],pos[100010],c[100010];\nbool us[100010];\nint main(){\n\tint n,m,q,i,N;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(i=1;i<=q;i++)scanf(\"%d\",p+i);\n\tN=0;\n\tfor(i=q;i>0;i--){\n\t\tif(!us[p[i]])us[a[++N]=p[i]]=1;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tif(!us[i])a[++N]=i;\n\t}\n\tfor(i=1;i<=m;i++)pos[a[i]]=i;\n\t#define wa {puts(\"No\");return 0;}\n\tc[0]=n;\n\tfor(i=q;i>0;i--){\n\t\tif(c[pos[p[i]]-1]){\n\t\t\tc[pos[p[i]]-1]--;\n\t\t\tc[pos[p[i]]]++;\n\t\t}\n\t}\n\tfor(i=0;!c[i];i++);\n\tfor(i++;i<m;i++){\n\t\tif(a[i]>a[i+1])wa\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tbound[j - 1] = vec[A[i]][idx];\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "d'd"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size()) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && pos[last] < firstFail) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\n\nbool vis[N];\nint n,m,q,a[N],cnt[N],p[N];\nvi order;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m >> q;\n    forn(i,q) cin >> a[i], a[i]--;\n    dforsn(i,0,q) if (!vis[a[i]]) {\n        order.pb(a[i]);\n        vis[a[i]] = true;\n    }\n    m = si(order);\n    //forn(i,m) if (!vis[i]) order.pb(i);\n    forn(i,si(order)) p[order[i]] = i;\n\n    bool ok = true;\n    cnt[0] = n;\n    dforsn(i,0,q) {\n        int pos = p[a[i]];\n        if (cnt[pos]) {\n            cnt[pos]--;\n            cnt[pos+1]++;\n        }\n        else if (cnt[pos+1] || cnt[m]);\n        else ok = false;\n    }\n\n    int least;\n    forn(i,N) if (cnt[i]) {\n        least = i;\n        break;\n    }\n\n    vi norder;\n    memset(vis,0,sizeof vis);\n    forn(i,least) {\n        norder.pb(order[i]);\n        vis[order[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) norder.pb(i);\n    \n    ok &= norder == order;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n        //cout<<f[i]<<\" \";\n    }\n    //cout<<\"\\n\";\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)||(s==SZ(kek)-1&&kek.back()==1)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    VI a(q);\n    REP(i,q) a[i] = in() - 1;\n    VI p;\n    set<int> st;\n    REP(i,m) st.insert(i);\n    FORR(i,q-1,0){\n        if (st.count(a[i])){\n            p.push_back(a[i]);\n            st.erase(a[i]);\n        }\n    }\n    for (int x : st) p.push_back(x);\n    VI idx(m);\n    REP(i,m) idx[p[i]] = i;\n\n    // REP(i,m) cout << p[i] << \" \";\n    // cout << endl;\n\n    VI cnt(m);\n    FORR(i,q-1,0){\n        int j = idx[a[i]];\n        cnt[j] = min(n, cnt[j] + 1);\n        if (j > 0 && cnt[j] > cnt[j - 1]){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    int j = m - 1;\n    while (j > 0 && p[j - 1] < p[j]) j--;\n    REP(i,j){\n        if (cnt[i] != n){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint a[SIZE];\nint d[SIZE],u[SIZE],dn,now[SIZE];\nVI p[SIZE];\nint main(){\n    DRIII(N,M,Q);\n    REP(i,Q)RI(a[Q-1-i]);\n    int one=-1;\n    REP(i,Q){\n        p[a[i]].PB(i);\n        if(!u[a[i]]){\n            u[a[i]]=1;\n            if(a[i]==1)one=dn;\n            d[dn++]=a[i];\n        }\n    }\n    if(one!=-1){\n        bool suc=1;\n        int v=1;\n        REPP(i,one,dn){\n            while(v<=M&&u[v]&&p[v][0]<p[1][0])v++;\n            if(d[i]!=v)suc=0;\n            v++;\n        }\n        if(suc)dn=one;\n    }\n    MS1(now);\n    REP(i,dn){\n        int it=0;\n        REP(j,N){\n            while(it<SZ(p[d[i]])&&p[d[i]][it]<=now[j])it++;\n            if(it>=SZ(p[d[i]])){\n                puts(\"No\");\n                return 0;\n            }\n            now[j]=p[d[i]][it++];\n        }\n    }\n\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, deque<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N, M, Q;\ndeque<int> a;\n\nbool solve() {\n    map<int,int> id;\n    vector<int> ord;\n    int iter = 0;\n    for (int i = 0; i < a.size(); ++i) {\n        if (id.count(a[i])) continue;\n        id[a[i]] = iter++;\n        ord.push_back(a[i]);\n    }\n    for (int i = 0; i < a.size(); ++i) {\n        a[i] = id[a[i]];\n    }\n\n    COUT(a);\n\n    vector<int> con(id.size(), 0);\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i] == 0) con[a[i]]++;\n        else if (con[a[i]] + 1 <= con[a[i]-1]) con[a[i]]++;\n    }\n    int back = ord.back();\n    bool ren = true;\n    for (int i = (int)ord.size()-1; i >= 0; --i) {\n        if (ord[i] != back) {\n            ren = false;\n            break;\n        }\n        --back;\n        if (back < 0) break;\n    }\n    if (back != -1) ren = false;\n\n    int need = con.size();\n    if (ren) need -= ord.back()+1;\n    bool ok = true;\n    for (int i = 0; i < need; ++i) {\n        if (con[i] < N) ok = false;\n    }\n\n    //COUT(ord); COUT(id); COUT(a); COUT(need); COUT(con);\n    \n    return ok;\n}\n\nint main() {\n    while (cin >> N >> M >> Q) {\n        a.resize(Q);\n        for (int i = 0; i < Q; ++i) cin >> a[i], --a[i];\n        reverse(a.begin(), a.end());\n        if (a.empty() || solve()) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<utility>\n#include<random>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint a[1 << 17];\nbool used[1 << 17];\nvector<int> v;\nint c[1 << 17];\nint inv[1 << 17];\nint main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\trep(i, q) {\n\t\tcin >> a[i];\n\t}\n\tper(i, q) {\n\t\tif (used[a[i]])continue;\n\t\tused[a[i]] = true;\n\t\tv.push_back(a[i]);\n\t}\n\trep1(i, m) {\n\t\tif (used[i])continue;\n\t\tv.push_back(i);\n\t}\n\tint ri = 0;\n\trep(i, m - 1) {\n\t\tif (v[i] > v[i + 1]) {\n\t\t\tri = i + 1;\n\t\t}\n\t}\n\trep(i, m) {\n\t\tinv[v[i]] = i;\n\t}\n\tbool f = true;\n\tper(i, q) {\n\t\tint id = inv[a[i]];\n\t\tif (id >= ri)continue;\n\t\tif (id > 0) {\n\t\t\tif (c[id - 1] > c[id]) {\n\t\t\t\tc[id]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\telse c[id]++;\n\t}\n\trep(i, ri) {\n\t\tif (c[i] < n)f = false;\n\t}\n\tif (f)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define INPUT(x) scanf(\"%d\",&x)\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF 2000000000\n\ntypedef long long ll;\n\nbool rec(){\n    int TB[100001] = {};\n    INT(N);INT(M);INT(Q);\n    REP1(i,Q){\n        INT(q);\n        TB[q] = (TB[q]+1)%N;\n    }\n    int mini = 1000000;\n    REP2(i,1,M) {\n        mini = min(mini,TB[i]);\n    }\n    REP2(i,2,M) {\n        if (TB[i] > mini) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    if (rec()) {\n        cout << \"yes\" << endl;\n    }else{\n        cout << \"no\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    // int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        // else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n        else break;\n    }\n    bool ans = true;\n    // if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n    //     ans = false;\n    // }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=m;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(val==0){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n        ++j;\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ryan in ny / per jorner fills in: derivative code\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(n);i++)\n#define per(i,a,n) for (int i=(n)-1;i>=(a);i--)\ntypedef long long ll;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    vector<int> v(q + 10);\n    rep(i, 0, q) cin >> v[i], v[i]--;\n    \n    vector<int> waiting(m + 10, 0);\n    waiting[0] = n;\n    vector<int> pos(m + 10, -1);\n    int built = 0;\n    vector<int> order(m + 10, -1);\n    \n    per(i, 0, q) {\n        if (pos[v[i]] != -1) {\n            if (waiting[pos[v[i]]]) {\n                waiting[pos[v[i]]]--;\n                waiting[pos[v[i]] + 1]++;\n            }\n        } else {\n            pos[v[i]] = built;\n            assert(waiting[built]);\n            waiting[built]--;\n            waiting[built + 1]++;\n            order[built] = v[i];\n            built++;\n        }\n    }\n    \n    int mn = m;\n    rep(i, 0, n) if (pos[i] == -1) {\n        mn = i;\n        break;\n    }\n    if (mn != m) order[built] = mn;\n    //cout << mn << endl;\n    \n    //rep(i, 0, m) cout << order[i] << \": \" << waiting[i] << endl;\n    \n    \n    \n    bool ok = true;\n    per(i, 0, m - 1) {\n        if (order[i + 1] != -1 && order[i] > order[i + 1]) ok = false;\n        if (!ok && waiting[i]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0],n){\n\t\tif(v[i]!=i-pos[0]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\twhile(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(num[pos[a[i]]+1]>0){\n\t\t\tnum[pos[a[i]]+1]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t}\n\t\telse if(num[n]>0){\n\t\t\tnum[n]+=0;\n\t\t}\n\t\telse{\n\t\t\tif(lo<pos[a[i]]){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\t//num[lo]--;num[pos[a[i]]+1]++;lo=1;\n\t\t}\n\t\t//rep(j,n+1) cout<<num[j]<<' ';cout<<endl;\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    int q;\n    cin >> q;\n    vector<int>a(q);\n    vector<vector<int> > v(m+1);\n    rep(i,q){\n        cin >> a[i];\n    }\n    reverse(a.begin(),a.end());\n    rep(i,q){\n        v[a[i]].push_back(i);\n    }\n    rep(i,m+1){\n        v[i].push_back(q);\n    }\n    vector<int>b(n,-1);\n    vector<int>flag(m+1);\n    int s = 1;\n    bool f = 0;\n    bool ok = 1;\n    for(int i=0;i<q;i++){\n        if(f){\n            int k = a[i];\n            if(flag[k])continue;\n            for(int i=s;i<=m;i++){\n                if(!flag[i]){\n                    s = i;\n                    break;\n                }\n            }\n            if(s!=k){\n                // cerr << s << \" \" << k << endl;\n                // cerr << \"Test\" << endl;\n                ok = 0;\n            }\n            flag[k] = true;\n        }else{\n            int k = a[i];\n            if(flag[k]){\n                continue;\n            }\n            int id = i-1;\n            rep(zz,n){\n                int t = *lower_bound(v[k].begin(),v[k].end(),max(id+1,b[zz]+1));\n                //cerr << zz << \" \" << t << endl;\n                if(t!=q){\n                    b[zz] = t;\n                    id = t;\n                }else{\n                    f = 1;\n                    break;\n                }\n            }\n            if(f){\n                for(int i=s;i<=m;i++){\n                    if(!flag[i]){\n                        s = i;\n                        break;\n                    }\n                }\n                if(s!=k){\n                    ok = 0;\n                }\n\n            }\n            flag[k] = 1;\n        }\n    }\n    if(ok){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nvector<int> t,co;\nint dp[MAX];\nint cz[MAX];\nint il = 0;\nint kt[MAX];\nint n,m,q;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    int pom;\n    cin >> pom;\n    pom--;\n    t.PB(pom);\n  }\n  reverse(ALL(t));\n  for(int el:t){\n    if(!cz[el]){\n      cz[el] = 1;\n      kt[el] = il;\n      il++;\n      co.PB(el);\n    }\n    int pom = kt[el];\n    dp[pom]++;\n    if(pom != 0)\n      mini(dp[pom],dp[pom-1]);\n  }\n  int naj = 0;\n  while(cz[naj])naj++;\n  if(cz[0] && naj > co.back()){\n    int pom = il - 1;\n    while(co[pom] != 1 && co[pom] > co[pom-1])\n      pom--;\n    if(co[pom] == 0)\n      il = pom;\n  }\n  if(il == 0 || dp[il-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\n\nconst int N = 1e5 + 10;\nint a[N];\nbool visit[N];\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  vector<int> b, r(m);\n  for (int i = q - 1; i >= 0; --i) {\n    if (!visit[a[i]]) {\n      b.push_back(a[i]);\n      visit[a[i]] = true;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    if (visit[i]) continue;\n    b.push_back(i);\n  }\n  for (int i = 0; i < m; ++i) {\n    r[b[i]] = i;\n  }\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  for (int i = q - 1; i >= 0; --i) {\n    int k = r[a[i]];\n    if (freq[k]) {\n      --freq[k];\n      ++freq[k + 1];\n    }\n  }\n  bool found = false;\n  for (int i = 0; i < m; ++i) {\n    if (freq[i]) {\n      for (int j = i + 1; j < m; ++j) {\n        if (b[j] < b[j - 1]) {\n          found = true;\n          break;\n        }\n      }\n      break;\n    }\n  }\n  puts(found ? \"No\" : \"Yes\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <cassert>\nusing namespace std;\n#define fast_io ios_base::sync_with_stdio (false) ; cin.tie(0) ; cout.tie(0) ;\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define MOD (long long int)(1e9+7)\n#define INF (int)(1e9)\n#define LINF (long long int)(1e18)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  if(n <= 1e7){\n    ret *= kaijo(n); ret %= MOD;\n    ret *= gyaku_kaijo(r); ret %= MOD;\n    ret *= gyaku_kaijo(n-r); ret %= MOD;\n  }else{\n    rep(i,r){\n      ret *= n-i; ret %= MOD;\n      ret *= mpow(r-i, MOD-2); ret %= MOD;\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  fast_io\n  cout<<fixed<<setprecision(15);\n\n  int n,m;cin>>n>>m;\n  int q;cin>>q;\n  vector<int> A(n);\n  rep(i,q){\n    cin>>A[i];\n  }\n\n  vector<int> count(m,0);\n  map<int,int> mp, rev;\n  REP(i,q){\n    if(mp.count(A[i]) == 0){\n      int size = mp.size();\n      mp[A[i]] = size;\n      rev[size] = A[i];\n      count[size]++;\n    }else{\n      int idx = mp[A[i]];\n      count[idx]++;\n      if(idx >= 1){\n        chmin(count[idx], count[idx-1]);\n      }\n    }\n  }\n  int memo = -1;\n  rep(i,m){\n    if(count[i] < n){\n      memo = i;\n      break;\n    }\n  }\n\n  if(memo == -1){\n    cout<<\"Yes\"<<endl;\n    return 0;\n  }\n\n  int next = 1;\n  rep(i,m){\n    if(i < memo) continue;\n    while(mp.count(next) > 0 && count[mp[next]] >= n){\n      next++;\n    }\n    //cout<<next<<\" \" << rev[i] << endl;\n    if(rev.count(i) > 0 && rev[i] != next){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    next++;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,q;\nint a[100001];\nvector<int> f;\nvector<int> ff;\nbool used[100001];\nint place[100001];\nint freq[100001];\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(!used[a[i]]){\n\t\t\tused[a[i]]=true;\n\t\t\tf.push_back(a[i]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!used[i])f.push_back(i);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tplace[f[i]]=i;\n\t}\n\tfreq[0]=n;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(freq[place[a[i]]]>0){\n\t\t\tfreq[place[a[i]]]--;\n\t\t\tfreq[place[a[i]]+1]++;\n\t\t}\n\t}\n\tint mini=m;\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(freq[i]>0)mini=i;\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<mini;i++){\n\t\tff.push_back(f[i]);\n\t\tused[f[i]]=true;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!used[i])ff.push_back(i);\n\t}\n\tbool flag=true;\n\tfor(int i=mini;i<m;i++){\n\t\tif(f[i]!=ff[i])flag=false;\n\t}\n\tprintf(\"%s\\n\",flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\nint ma[100005];\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ma[a[q]]=1;\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            if(ma[a[i]]==0)\n            {\n              tail++;\n              qu[tail]=a[i];\n              ma[a[i]]=1;\n              ha[tail]++;\n\n            }\n        }\n    }\n    //cout<<head<<  \"  \"<<tail<<endl;\n\n        if(ha[tail]>=n)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n\n     if(head==tail)\n      {\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n      }\n\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1){\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n      }\n    }else{\n      if(!CNT[0]) goto fail;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = n; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= n ) ss[ v[i] ].erase( ss[ v[i] ].find( i-n ) );\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( t * n > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int N, M, Q; scanf(\"%d%d%d\", &N, &M, &Q);\n  static pair<int,int> queries[100000];\n  for(int i = 0; i < Q; ++i) {\n    scanf(\"%d\", &queries[i].first); --queries[i].first;\n    queries[i].second = i;\n  }\n  sort(queries, queries+Q);\n  // printf(\"queries = \");\n  // for(int i = 0; i < Q; ++i) {\n  //   printf(\"(%d, %d), \", queries[i].first, queries[i].second);\n  // }\n  // printf(\"\\n\");\n  static int qidx[100001];\n  {\n    int i = 0;\n    for(int j = 0; j <= M; ++j) {\n      while(i < Q && queries[i].first < j) ++i;\n      qidx[j] = i;\n    }\n  }\n  // printf(\"qidx = \");\n  // for(int i = 0; i <= M; ++i) {\n  //   printf(\"%d, \", qidx[i]);\n  // }\n  // printf(\"\\n\");\n  static int lru_seq[100000];\n  for(int i = 0; i < M; ++i) {\n    lru_seq[i] = i;\n  }\n  sort(lru_seq, lru_seq+M, [&](int x, int y) -> bool {\n      int xx = (qidx[x] == qidx[x+1]) ? ~x : queries[qidx[x+1]-1].second;\n      int yy = (qidx[y] == qidx[y+1]) ? ~y : queries[qidx[y+1]-1].second;\n      return xx < yy;\n  });\n  // printf(\"lru_seq = \");\n  // for(int i = 0; i < M; ++i) {\n  //   printf(\"%d, \", lru_seq[i]);\n  // }\n  // printf(\"\\n\");\n  int max_ign = 0;\n  while(max_ign < M && lru_seq[max_ign] == lru_seq[0] - max_ign) ++max_ign;\n  // printf(\"max_ign = %d\\n\", max_ign);\n  static int max_times[100000];\n  fill(max_times, max_times+N, Q);\n  for(int i = M-1; i >= max_ign; --i) {\n    int j = qidx[lru_seq[i]+1]-1;\n    int min_j = qidx[lru_seq[i]];\n    for(int k = 0; k < N; ++k) {\n      while(j >= min_j && queries[j].second > max_times[k]) --j;\n      if(j < min_j) {\n        printf(\"No\\n\");\n        return 0;\n      }\n      max_times[k] = queries[j].second;\n      // printf(\"i=%d: max_times[%d] = %d\\n\", i, k, max_times[k]);\n      --j;\n    }\n  }\n  printf(\"Yes\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n\nsigned main(){\n    int n, m;\n    cin >> m >> n;\n    int q;\n    cin >> q;\n    vector<int> a(q);\n    for(auto& x : a){\n        cin >> x;\n        --x;\n    }\n\n    auto rev = a;\n    reverse(rev.begin(), rev.end());\n    for(int i = 0; i < n; ++i)\n        rev.emplace_back(i);\n    unordered_set<int> s;\n    vector<int> final;\n    for(auto& x : rev)\n        if(s.find(x) == s.end()){\n            s.insert(x);\n            final.emplace_back(x);\n        }\n    rev.resize(rev.size() - n);\n\n    vector<int> inv(n);\n    for(int i = 0; i < n; ++i)\n        inv[final[i]] = i;\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = m;\n    int t = 0;\n    for(auto& x : rev){\n        if(t < inv[x]){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        if(dp[inv[x]]){\n            --dp[inv[x]];\n            ++dp[inv[x] + 1];\n        }\n        t = max(t, inv[x] + 1);\n    }\n\n    int c;\n    int ma = MOD;\n    for(c = n - 1; c >= 0; --c){\n        if(ma < final[c])\n            break;\n        ma = final[c];\n    }\n    c++;\n\n    /*\n    cout << c << endl;\n\n    for(int i = 0; i < n; ++i)\n        cout << final[i] + 1 << \" \\n\"[i == n - 1];\n\n    for(int i = 0; i <= n; ++i)\n        cout << dp[i] << \" \\n\"[i == n];\n        */\n\n    cout << (accumulate(next(dp.begin(), c), dp.end(), 0) == m ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tint N,M,Q,a;\n\tvector<int> num;\n\tint ans;\n\n\tcin >> N >> M >> Q;\n\t\n\tfor (int i=0; i < M; i++) {\n\t\tnum.push_back(0);\n\t}\n\n\tfor (int i=0; i < Q; i++) {\n\t\tcin >> a;\n\t\tnum[a - 1]++;\n\t}\n\tnum.erase(num.begin());\n\tans = num[0] % N;\n\tfor (int i = 0; i < M-1; i++) {\n\t\tif (ans != num[i] % N) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Yes\" << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n\n    drep(i,v.size()){\n        if(i == v.size() - 1 && v[i].first <= mex)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,...) for(auto&& i:__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\n\nsigned main(){\n    LL(n,m,q);\n    VEC(ll,a,q);\n    ll min=1;\n    if(all_of(rall(a),[&](ll a){if(a==min)min++;return a<min;}))return Yes();\n    Rev(a);\n    vector<pll>b;\n    b.emplace_back(0,n);\n    unordered_map<ll,ll>index;\n    each(i,a){\n        if(!index.count(i)){\n            index[i]=b.size();\n            b.emplace_back(i,1);\n        }\n        else{\n            ll j=index[i];\n            if(b[j-1].second>b[j].second)b[j].second++;\n        }\n    }\n    ll front=0;\n    rep(i,1,m+1){\n        if(index.count(i)){\n            if(b[index[i]].second<n){\n                front=i;\n                break;\n            }\n        }\n        else{\n            front=i;\n            break;\n        }\n    }\n    if(b.back().second==n)return Yes();\n    if(b[b.size()-2].second<n)return No();\n    Yes(b.back().first==front);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, deque<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N, M, Q;\ndeque<int> a;\n\nbool solve() {\n    map<int,int> id;\n    vector<int> ord;\n    int iter = 0;\n    for (int i = 0; i < a.size(); ++i) {\n        if (id.count(a[i])) continue;\n        id[a[i]] = iter++;\n        ord.push_back(a[i]);\n    }\n    for (int i = 0; i < a.size(); ++i) {\n        a[i] = id[a[i]];\n    }\n\n    vector<int> con(id.size(), 0);\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i] == 0) con[a[i]]++;\n        else if (con[a[i]] + 1 <= con[a[i]-1]) con[a[i]]++;\n    }\n    int back = ord.back();\n    bool ren = true;\n    for (int i = (int)ord.size()-1; i >= 0; --i) {\n        if (ord[i] != back) {\n            ren = false;\n            break;\n        }\n        --back;\n        if (back < 0) break;\n    }\n    if (back != -1) ren = false;\n\n    int need = con.size();\n    if (ren) need -= ord.back()+1;\n    bool ok = true;\n    for (int i = 0; i < need; ++i) {\n        if (con[i] < N) ok = false;\n    }\n\n    // COUT(a); COUT(ord); COUT(id); COUT(a); COUT(need); COUT(con);\n    \n    return ok;\n}\n\nint main() {\n    while (cin >> N >> M >> Q) {\n        a.resize(Q);\n        for (int i = 0; i < Q; ++i) cin >> a[i], --a[i];\n        reverse(a.begin(), a.end());\n        if (a.empty() || solve()) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tif(ban[i]==0){continue;}//skipped\n\t\tint no=ban[i];\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t\tban[numlis[no][j]]=0;\n\t\t}\n\t\tif(numlis[no].size()<n){if(zyu!=no){cout<<\"No\"<<endl;return 0;}else{zyu++;}}\n\t\tfor(j=numlis[no].size();j<n;j++){las[j]=i-q;}\n\t\tfor(j=n;j<numlis[no].size();j++){ban[numlis[no][j]]=0;}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) break;\n\t\tif(i != 0 && cnt[i - 1] != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nint n,m,q,v;\nint a[N], used[N], ord[N], pos[N], sor[N], prog[N];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tFOR(i,q) scanf(\"%d\", &a[i]);\n\tFOR(i,q) a[i]--;\n\tREPD(i,q-1,0) if (!used[a[i]]) {\n\t\tord[v++] = a[i];\n\t\tused[a[i]]=1;\n\t}\n\tFOR(i,m) if (!used[i]) ord[v++] = i;\n\tsor[v-1]=sor[v]=1;\n\tREPD(i,v-2,0) sor[i] = sor[i+1] && (ord[i] < ord[i+1]);\n\tFORI(i,v) pos[ord[i]] = i;\n\tREPD(i,q-1,0) {\n\t\tint pp = upper_bound(prog, prog+n, a[i]) - prog - 1;\n\t\tif (pp >= 0) {\n\t\t\tprog[pp]++;\n\t\t}\n\t}\n\t//FOR(i,n) printf(\"%d %d\\n\", i, prog[i]);\n\tbool ok = true;\n\tFOR(i,n) if (!sor[prog[i]]) ok = false;\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint n,m,A[110000],K,pd[110000],num[110000],fir,lim;\nvector<int>x[110000];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&K);\n\tfor (int i=1;i<=K;i++) scanf(\"%d\",&A[i]),x[A[i]].push_back(i);\n\tfir=1; lim=0;\n\tmemset(num,0x3f,sizeof num);\n\tfor (int now=K;now;now--){\n\t\tif (pd[A[now]]) continue;\n\t\tint rem=n;\n\t\tfor (int i=x[A[now]].size();i;i--){\n\t\t\tint k=x[A[now]][i-1];\n\t\t\tif (rem<=lim) num[rem]=0;\n\t\t//\tcout<<rem<<\" \"<<num[rem]<<\" \"<<k<<\" \"<<A[now]<<endl;\n\t\t\tif (k>num[rem]){\n\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t}\n\t\t\tnum[rem]=k; rem--;\n\t\t\tif (rem==0) break; \n\t\t}\n\t\twhile (pd[fir]) fir++;\n\t\tif (fir==A[now]) lim=max(lim,rem);\n\t\telse if (rem){\n\t\t\tprintf(\"No\\n\"); return 0;\n\t\t}\n\t\tpd[A[now]]=1;\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    auto A = readVec<int>(Q);\n    for (auto& a : A) { a--; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M; i++) { L[i].push_back(M - i - 1); }\n    for (int i = 0; i < Q; i++) { L[A[i]].push_back(i + M); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, Q + M);\n    for (const auto& o : op) {\n        for (int i = 0; i < N; i++) {\n            while (pos[i] < L[o].back()) {\n                if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                L[o].pop_back();\n            }\n            const int prev = pos[i];\n            pos[i] = L[o].back();\n            if (L[o].size() > 1) { L[o].pop_back(); }\n            if (prev < M) { break; }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,q){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n  REP(i,m) if(st.find(i)==st.end()) b.push_back(i);\n  int x = n-1;\n  while(x>0 && b[x-1] < b[x]) x--;\n\n  REP(i,q) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,q){\n    c[a[i]] = min(c[a[i]]+1,n);\n    if(a[i] && c[a[i]-1] < c[a[i]]) ng();\n  }\n\n  REP(i,x) if(c[i]<n) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,q,a[N],vis[N],pos[N],cnt[N];\nVI v;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tassert(n<=3&&m<=3);\n\tscanf(\"%d\",&q);\n\trep(i,0,q) scanf(\"%d\",a+i);\n\treverse(a,a+q);\n\trep(i,0,q) {\n\t\tif (!vis[a[i]]) {\n\t\t\tpos[a[i]]=SZ(v);\n\t\t\tv.pb(a[i]),vis[a[i]]=1;\n\t\t}\n\t}\n\tcnt[0]=n;\n\trep(i,0,q) {\n\t\tint w=pos[a[i]];\n\t\tif (cnt[w]>0) cnt[w]--,cnt[w+1]++;\n\t}\n\trep(i,1,m+1) if (!vis[i]) v.pb(i);\n\trep(i,0,SZ(v)) if (cnt[i]!=0) {\n\t\tbool val=1;\n\t\trep(j,i,m-1) if (v[j]>v[j+1]) val=0;\n\t\tputs(val?\"Yes\":\"No\");\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nint n,m,q;\nint t[MAX];\nvector<int> wyg;\nbool cz[MAX];\nbool odw[MAX];\nvoid tak(){\n  cout << \"Yes\\n\";\n  exit(0);\n}\nint dp[MAX],gd[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    cin >> t[i];\n    t[i]--;\n  }\n  for(int i = q-1;i >= 0;i--){\n    if(!cz[t[i]]){\n      cz[t[i]] = 1;\n      gd[t[i]] = SZ(wyg);\n      wyg.PB(t[i]);\n    }\n  }\n  if(cz[0]){\n   // bool ok = 1;\n    int pom = gd[0];\n    R(i,pom){\n      odw[gd[i]] = 1;\n    }\n    int pow = 0;\n    while(1){\n      pom ++;\n      pow ++;\n      if(pom == SZ(wyg)){\n        wyg.resize(gd[0]);\n      }\n      while(odw[pow])pow++;\n      if(wyg[pom] != pow)break;\n    }/*\n    R(i,SZ(wyg)){\n      if(wyg[i] != i)ok = 0;\n    }\n    if(ok)tak();*/\n  }\n  for(int i = q-1;i >= 0;i--){\n    int pom = gd[t[i]];\n    if(pom == 0)\n      dp[pom]++;\n    else\n      dp[pom] = min(dp[pom]+1, dp[pom-1]);\n  }\n  if(SZ(wyg) == 0 || dp[SZ(wyg)-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define er erase\n#define bg begin()\n#define ed end()\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define enter cout << \"\\n\"\n#define space cout << \" \"\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (n); ++i)\n#define fj(st,n) for (int j = (st); j <= (n); ++j)\n#define fk(st,n) for (int k = (st); k <= (n); ++k)\n#define fq(st,n) for (int q = (st); q <= (n); ++q)\n#define fw(st,n) for (int w = (st); w <= (n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (n); --i)\n#define ej(st,n) for (int j = (st); j >= (n); --j)\n#define ek(st,n) for (int k = (st); k >= (n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (n); --(i))\n#define ri(st,n) for (int i = (st); i < (n); ++i)\n#define rj(st,n) for (int j = (st); j < (n); ++j)\n#define rk(st,n) for (int k = (st); k < (n); ++k)\n#define rq(st,n) for (int q = (st); q < (n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = (int)1e9;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 1000000007;\nconst int maxn = (int) 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint n, m, T, a[maxn], khm, x, y, t[maxn], en[maxn];\nvector <int> vh, vc[maxn];\n\nint main()\n{\n//    fin(\"t.in\");\n    sync;\n    cin >> n >> m;\n    cin >> T;\n    fi(1, T) {\n        cin >> a[i];\n        vc[a[i]].pb(i);\n    }\n    fi(1, n) {\n        en[i] = T;\n    }\n    vh.clear();\n    khm = -1;\n    ei(T, 1) {\n        if (t[a[i]])\n            continue;\n        vh.pb(a[i]);\n        t[a[i]] = 1;\n        x = n;\n        ej((int)vc[a[i]].size() - 1, 0) {\n            if (en[x] < vc[a[i]][j]) {\n                continue;\n            }\n            --x;\n            if (x == 0)\n                break;\n        }\n        ej(x, 1) {\n            en[j] = 0;\n            if (khm == -1)\n                khm = (int)vh.size() - 1;\n        }\n    }\n    if (khm != -1) {\n        y = 0;\n//        cout << khm << endl;\n        ri(khm, vh.size()) {\n            ++y;\n            if (vh[i] != y) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n\n\nint main(){\n    ll m,n,q;cin>>m>>n>>q;//注意！\n    \n    ll a[q];\n    rep(i,0,q-1){\n        cin>>a[i];a[i]--;\n    }\n    reverse(a,a+q);\n    ll ans[n+1];fill(ans,ans+n+1,-1);\n    ll anspos=0;\n    ll ansc[n+1];memset(ansc,0,sizeof(ansc));\n    ll rev[n];fill(rev,rev+n,-1);\n    rep(i,0,q-1){\n        ll x=a[i];\n        if(rev[x]==-1){\n            rev[x]=anspos;\n            ll y=rev[x];\n            ans[y]=x;\n            ansc[y]++;\n            anspos++;\n        }else{\n            ll y=rev[x];\n            ansc[y]++;\n        }\n    }\n    vector<ll>v;\n    ll pos=0;\n    while(pos<=n-1&&ansc[pos]>=m){\n        pos++;\n    }\n    while(pos<=n-1&&ans[pos]!=-1){\n        v.pb(ans[pos]);\n        pos++;\n    }\n    rep(i,0,n-1){\n        if(rev[i]==-1)v.pb(i);\n    }\n    ll s=v.size();\n    rep(i,0,s-2){\n        if(v[i]>=v[i+1]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nint main() {\n\tint N,M, Q;\n\tcin >> N >> M >> Q;\n\t\n\tmap<int, int> order;\n\tvector<int> input;\n\tset<int> used;\n\tvector<int> pos(M+1, 0);\n\t\n\tpos[0] = N;\n\t\n\tvector<int> nums;\n\tfor(int i=0; i<Q; i++) {\n\t\tint p;\n\t\tcin >> p;\n\t\tinput.push_back(p);\n\t}\n\treverse(input.begin(), input.end());\n\tfor(int i=0; i<input.size(); i++) {\n\t\tint p = input[i];\n\t\tint cnt = used.size();\n\t\tused.insert(p);\n\t\tif((int)used.size() != cnt) {\n\t\t\torder[p] = cnt+1;\n\t\t\tnums.push_back(p);\n\t\t}\n\t\tint cur = order[p];\n\t\tif(pos[cur-1] > 0) {\n\t\t\tpos[cur-1]--;\n\t\t\tpos[cur]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0; i<3; i++) {\n\t\tcout <<\" \" << i << \" \" << pos[i] << endl;\n\t}\n\tfor(int i=0; i<nums.size(); i++)\n\t\tcout << nums[i] << endl;\n\t*/\n\tint last = nums.size()-1;\n\tbool ok = true;\n\tfor(int val = nums.back(); val>=1; val--) {\n\t\t\n\t\tif(order[val] == 0) ok = false;\n\t\tif(last>0 && val == nums[last-1]) {\n\t\t\tlast--;\n\t\t}\n\t}\n\tif(!ok) {\n\t\tlast = nums.size();\n\t}\n\t\n\tbool judge = true;\n\tfor(int i=0; i<last; i++)\n\t\tif(pos[i] > 0)\n\t\t\tjudge = false;\n\tif(judge) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  int lo = S.size();\n  // for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  // srand(time(0)); if(rand()%2) goto fail; if(rand()%2) goto ok;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1){\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n      }\n    }else{\n      if(CNT[0]) rev=1;\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint main(){std::cout<<\"No\"<<std::endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n#include <fstream>\n\nusing namespace std;\n\n\n#define LL long long\n#define N 200100\n#define M 10000100\n#define MP make_pair\n#define Pi acos(-1.0)\n#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n#define ls (rt << 1)\n#define rs (ls | 1)\n#define md ((ll+rr)/2)\n#define lson ll, md, ls\n#define rson md+1, rr, rs\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define sqr(x) ((x)*(x))\n#define eps 1e-6\n#define MP make_pair\n#define uLL unsigned long long\nLL powmod(LL a,LL b) {LL res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n#define F(x) ((x)/3+((x)%3 == 1 ? 0 : tb))\n#define G(x) ((x)<tb ? (x)*3+1 : ((x) - tb)*3+2)\n#define lowbit(x) ((x)&(-x))\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nint gcd(int x,int y){\n    while(y){\n        int t = x % y;\n        x = y;\n        y = t;\n    }\n    return x;\n}\n\nint pos[N],a[N],on[N],at[N];\n\nint main(){\n    int n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i = 0; i < q; i++)\n        scanf(\"%d\",&a[i]),a[i]--;\n    \n    for(int i = 0; i < m; i++){\n        at[i] = 0;\n        pos[i] = -1;\n        on[i] = -1;\n    }\n    \n    int have = 0;\n    at[0] = n;\n    for(int i = q - 1; i >= 0; i--){\n        int v = a[i];\n        if(pos[v] == -1){\n            pos[v] = have;\n            on[have] = v;\n            at[have]--;\n            have++;\n            at[have]++;\n            continue;\n        }\n        if(at[pos[v]] > 0)\n            at[pos[v]]--,at[pos[v]+1]++;\n    }\n    \n    int fs = -1;\n    for(int i = 0; i <= m; i++)\n        if(at[i] > 0){\n            fs = i;\n            break;\n        }\n    \n    vector<int> all;\n    for(int i = fs; i < have; i++){\n        all.push_back(on[i]);\n    }\n    for(int i = 0; i < m; i++)\n        if(pos[i] == -1)\n            all.push_back(i);\n    \n    sort(all.begin(), all.end());\n    \n    for(int i = fs; i < have; i++)\n        if(on[i] != all[i - fs]){\n            puts(\"No\");\n            return 0;\n        }\n    puts(\"Yes\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  int q;\n  scanf(\"%d\",&q);\n  vi a(q);\n  rep(i,q) {\n    scanf(\"%d\",&a[i]);\n    --a[i];\n  }\n  reverse(rng(a));\n  vvi p(m);\n  rep(i,q) {\n    p[a[i]].pb(i);\n  }\n  vi used(m);\n  vi r(n);\n  int fr = 0;\n  bool ok = true; \n  rep(i,q) {\n    if (used[a[i]]) continue;\n    int k = 0;\n    rep(j,sz(p[a[i]])) {\n      if (j < i) continue;\n      if (r[k] > p[a[i]][j]) continue;\n      r[k] = p[a[i]][j]; ++k;\n      if (k >= n) break;\n    }\n    if (ok && k == n) {\n    } else {\n      if (fr == a[i]) {\n        ok = false;\n      } else {\n        puts(\"No\");\n        return 0;\n      }\n    }\n    used[a[i]] = 1;\n    while (fr < m && used[fr]) ++fr;\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0],n){\n\t\tif(v[i]!=i-pos[0]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tint hi=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\thi=max(hi,pos[a[i]]+1);\n\t\t\t//while(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(hi<pos[a[i]]){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t\t/*else if(num[pos[a[i]]+1]>0){\n\t\t\tnum[pos[a[i]]+1]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t}\n\t\telse if(num[n]>0){\n\t\t\tnum[n]+=0;\n\t\t}\n\t\telse{\n\t\t\tif(lo<pos[a[i]]){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\t//num[lo]--;num[pos[a[i]]+1]++;lo=1;\n\t\t}\n\t\t//rep(j,n+1) cout<<num[j]<<' ';cout<<endl;\n\t\t*/\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    /*\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n    int last = -1;\n    drep(i,v.size()){\n        if(v[i].first <= mex){\n            last = i;\n            break;\n        }\n    }\n    */\n\n\n    /*\n    drep(i,v.size()){\n        // if(i == last)break;\n        if(i == v.size() - 1 && v[i].first <= mex)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n    */\n\n    int use[m+1] = {};\n    int mex2 = 1;\n    rep(i,v.size()){\n        if(v[i].second == n){\n            use[v[i].first] = 1;\n            continue;\n        }else{\n            while(use[mex2] == 1)mex2++;\n            if(v[i].first == mex2){\n                use[mex2] = 1;\n            }else{\n                flag = 0;\n                break;\n            }\n        }\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, Q;\nint A[101010];\nint cnt[101010];\nset<int> poss[101010];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\t--A[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\t++cnt[A[i]];\n\t\tposs[A[i]].insert(i);\n\t}\n\tset<int> rem;\n\tfor (int i = 0; i < M; ++i) rem.insert(i);\n\tvector<int> req;\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tif (rem.count(A[i]) == 0) continue;\n\t\tif (0 && rem.size() > 0 && *(rem.begin()) == A[i]) {\n\t\t\t// you can ignore it\n\t\t} else {\n\t\t\treq.push_back(A[i]);\n\t\t}\n\t\trem.erase(A[i]);\n\t}\n\tvector<bool> ok(req.size(), true);\n\tfor (int i = 0; i < req.size() - 1; ++i) if (req[i] > req[i + 1]) ok[i] = false;\n\tfor (int i = req.size() - 2; i >= 0; --i) ok[i] = ok[i] && ok[i + 1];\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lp = Q;\n\t\tint fg = -1;\n\t\tfor (int _j = 0; _j < req.size(); _j++) {\n\t\t\tint j = req[_j];\n\t\t\tint nxtp = -1;\n\t\t\tauto pt = poss[j].upper_bound(lp);\n\t\t//\tprintf(\"%d \", lp);\n\t\t\tif (pt == poss[j].begin()) {\n\t\t\t\tif (ok[_j]) break;\n\t\t\t\telse {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnxtp = *(--pt);\n\t\t\t\tlp = nxtp;\n\t\t\t\tposs[j].erase(lp);\n\t\t\t}\n\t\t}\n\t//\tputs(\"\");\n\t}\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, Q;\nint A[101010];\nint cnt[101010];\nset<int> poss[101010];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\t--A[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\t++cnt[A[i]];\n\t\tposs[A[i]].insert(i);\n\t}\n\tset<int> rem;\n\tfor (int i = 0; i < M; ++i) rem.insert(i);\n\tvector<int> req;\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tif (rem.count(A[i]) == 0) continue;\n\t\tif (rem.size() > 0 && *(rem.begin()) == A[i]) {\n\t\t\t// you can ignore it\n\t\t} else {\n\t\t\treq.push_back(A[i]);\n\t\t}\n\t\trem.erase(A[i]);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lp = Q;\n\t\tfor (int j : req) {\n\t\t\tint nxtp = -1;\n\t\t\tauto pt = poss[j].upper_bound(lp);\n\t\t//\tprintf(\"%d \", lp);\n\t\t\tif (pt == poss[j].begin()) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnxtp = *(--pt);\n\t\t\tlp = nxtp;\n\t\t\tposs[j].erase(lp);\n\t\t}\n\t//\tputs(\"\");\n\t}\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    REPN(i,1,l){\n        if(dat[l]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n        }\n    }\n\n    bool ok = true;\n    for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool allappeared[100050];\nint a[100050];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    allappeared[0] = true;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared[a[i] - 1]) allappeared[a[i]] = true;\n    }\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    /*\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        cerr << val[i] << endl;\n    }\n    */\n    num[0] = N;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], num[nowindex-1]);\n        /*\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        */\n    }\n    for(int i = 1; i <= index; i++) {\n        if(num[i] != N) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    return 1;\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> a(q);\n  rep(i,q){\n    cin>>a[i]; --a[i];\n  }\n  reverse(all(a));\n  vector<int> fin; fin.reserve(m);\n  vector<int> inv(m,-1),cnt(m);\n  for(int x:a){\n    if(inv[x]<0){\n      inv[x]=fin.size();\n      fin.pb(x);\n    }\n    ++cnt[inv[x]];\n    if(inv[x] && cnt[inv[x]-1]<cnt[inv[x]]){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  rep(i,m) if(inv[i]<0){\n    inv[i]=fin.size();\n    fin.pb(i);\n  }\n  rep(i,m-1) if(cnt[i]<n && fin[i]>fin[i+1]){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <cassert>\nusing namespace std;\n#define fast_io ios_base::sync_with_stdio (false) ; cin.tie(0) ; cout.tie(0) ;\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define MOD (long long int)(1e9+7)\n#define INF (int)(1e9)\n#define LINF (long long int)(1e18)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  if(n <= 1e7){\n    ret *= kaijo(n); ret %= MOD;\n    ret *= gyaku_kaijo(r); ret %= MOD;\n    ret *= gyaku_kaijo(n-r); ret %= MOD;\n  }else{\n    rep(i,r){\n      ret *= n-i; ret %= MOD;\n      ret *= mpow(r-i, MOD-2); ret %= MOD;\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  fast_io\n  cout<<fixed<<setprecision(15);\n\n  int n,m;cin>>n>>m;\n  int q;cin>>q;\n  vector<int> A(q);\n  rep(i,q){\n    cin>>A[i];\n  }\n\n  vector<int> count(m,0);\n  map<int,int> mp, rev;\n  REP(i,q){\n    if(mp.count(A[i]) == 0){\n      int size = mp.size();\n      mp[A[i]] = size;\n      rev[size] = A[i];\n      count[size]++;\n    }else{\n      int idx = mp[A[i]];\n      count[idx]++;\n      if(idx >= 1){\n        chmin(count[idx], count[idx-1]);\n      }\n    }\n  }\n  int memo = -1;\n  rep(i,m){\n    if(count[i] < n){\n      memo = i;\n      break;\n    }\n  }\n\n  if(memo == -1){\n    cout<<\"Yes\"<<endl;\n    return 0;\n  }\n\n  int next = 1;\n  rep(i,m){\n    if(i < memo) continue;\n    while(mp.count(next) > 0 && count[mp[next]] >= n){\n      next++;\n    }\n    //cout<<next<<\" \" << rev[i] << endl;\n    if(rev.count(i) > 0 && rev[i] != next){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    next++;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <math.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <list>\n#include <ctype.h>\n#include <cassert>\n#include <stack>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <ctime>\n#include <functional>\n#include <ctime>\n#include <limits>\n#include <tuple>\n#include <complex>\n#include <numeric>\n\nusing namespace std;\n\n#define snd second\n#define fst first\n#define mp make_pair\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pb push_back\n#define left _left\n#define right _right\n\nconst ld pi = acos(-1.0l);\n\ntemplate<typename T>\nT abs(T x) {\n    return x > 0 ? x : -x;\n}\n\ntemplate<typename T>\nT sqr(T x) {\n    return x * x;\n}\n\ntemplate<typename T>\nbool chmin(T &x, T y) {\n    if (x > y) {\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmax(T &x, T y) {\n    if (x < y) {\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename U, typename V>\nostream &operator<<(ostream &s, const pair<U, V> &x) {\n    s << \"(\" << x.fst << \", \" << x.snd << \")\";\n    return s;\n}\n\ntemplate<typename U>\nostream &operator<<(ostream &s, const vector<U> &x) {\n    s << \"[\";\n    bool was = false;\n    for (auto it : x) {\n        if (was) {\n            s << \", \";\n        }\n        was = true;\n        s << it;\n    }\n    s << \"]\";\n    return s;\n}\n\ntemplate<typename U>\nostream &operator<<(ostream &s, const set<U> &x) {\n    s << \"{\";\n    bool was = false;\n    for (auto it : x) {\n        if (was) {\n            s << \", \";\n        }\n        was = true;\n        s << it;\n    }\n    s << \"}\";\n    return s;\n}\n\ntemplate<int sz>\nostream operator<<(ostream &s, const bitset<sz> &x) {\n    for (int i = 0; i < sz; i++) {\n        s << x[i];\n    }\n    return s;\n}\n\n\n//-----------------------------------------------------------------------------\n\nconst int maxn = 1e5 + 5;\nint cnt[maxn];\n\nint main() {\n    srand(time(NULL));\n\n    retry:\n#ifdef LOCAL\n    // gen();\n\n    freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n#else\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n#endif\n\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    reverse(a.begin(), a.end());\n    map<int,int> was;\n    int v = 1;\n\n    for (int &x : a) {\n        if (!was.count(x)) {\n            was[x] = v++;\n        }\n        x = was[x];\n    }\n    for (int i = 1; i <= m; i++) {\n        if (!was.count(i)) {\n            was[i] = v++;\n        }\n    }\n\n\n\n    int g = 0;\n    cnt[0] = n;\n    for (int x : a) {\n        if (cnt[x - 1]) {\n            cnt[x - 1]--;\n            cnt[x]++;\n            chmax(g, x);\n        } else {\n            if (g >= x) {\n\n            } else {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        int x = was[i];\n        if (cnt[x - 1]) {\n            cnt[x] += cnt[x - 1];\n            cnt[x - 1] = 0;\n            chmax(g, x);\n        } else {\n            if (g >= x) {\n\n            } else {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    if (cnt[v - 1] == n) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n    cout << \"No\" << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> A(Q);\n    for(int i=0; i<Q; i++){\n        cin >> A[i];\n        A[i]--;\n    }\n    reverse(A.begin(), A.end());\n    vector<int> order, rev(M, -1);\n    for(int a : A) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    int sz = order.size();\n    int pt = sz-1;\n    while(pt > 0 && order[pt-1] < order[pt]) pt--;\n    int lack = 0;\n    while(lack < M && rev[lack] >= 0) lack++;\n    if(lack > order[pt]) sz = pt;\n\n    for(int a=0; a<M; a++) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    vector<int> num(M+1);\n    bitset<100001> visited;\n    visited[0] = 1;\n    num[0] = N;\n    for(int a : A){\n        if(num[rev[a]]){\n            num[rev[a]]--;\n            num[rev[a]+1]++;\n            visited[rev[a]+1] = 1;\n        }else if(!visited[rev[a]]){\n            fail();\n        }\n    }\n    for(int i=0; i<sz; i++) if(num[i]){\n        fail();\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> pos(m);\n        REP(i, Q) {\n            used.insert(a[i]);\n            pos[a[i]] = i;\n        }\n        vector<P> temp;\n        REP(i, m) if (used.count(i) > 0) temp.pb({-pos[i], i});\n        sort( ALL(temp) );\n        vector<ll> res;\n        REP(i, temp.size()) {\n            res.pb(temp[i].second);\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    ll def = 0;\n    REP(i, seq.size()) {\n        if (seq[i] == 0) {\n            bool f = true;\n            FOR(j, i, seq.size()) {\n                if (seq[j] != j-i) f = false;\n            }\n            if (f) def = m-i;\n            break;\n        }\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n/*\n    vector< set<ll> > v(m);\n    REP(i, n) {\n        v[a[i]].insert(i);\n    }\n    set<ll> used;\n    RREP(pos, n) {\n        if (used.size() == n-1) break;\n        if (used.count(a[pos]) > 0) continue;\n        ll x = a[pos];\n\n    }\n    cout << \"Yes\" << endl;\n*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nvoid RE(){\n    RE();\n    RE();\n}\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                if(m<=5)RE();\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    int mn = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        if(chk[mn]) {\n            while(mn < M && chk[mn]) mn++;\n        }\n        if(arr[i] == mn) {\n            chk[arr[i]] = 1;\n            continue;\n        }\n        if(Pos[arr[i]].size() < N) {\n            printf(\"No\");\n            return 0;\n        }\n        int len = 1e9;\n        for(int j = (int)Pos[arr[i]].size() - 1; j >= (int)Pos[arr[i]].size() - N; j--) {\n            len = min(len, Pos[arr[i]][j] - (j == 0? -1 : Pos[arr[i]][j - 1]));\n        }\n        for(int j = 0; j < len; j++) {\n            bool ok = true;\n            for(int k = (int)Pos[arr[i]].size() - 1; k >= (int)Pos[arr[i]].size() - N + 1; k--) {\n                if(arr[Pos[arr[i]][k] - j] != arr[Pos[arr[i]][k - 1] - j]) {\n                    ok = false;\n                    break;\n                }\n                chk[ arr[ Pos[arr[i]][k] - j ] ] = 1;\n            }\n            if(!ok) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint a[100001];\nvector<pair<int, int>> num;\nset<int> hoge;\nvector<int> en;\n\nint main(int argc, char **argv) {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n  for (int i = 1; i < M; ++i) {\n    cin >> a[i];\n  }\n  for (int i = M; i >= 1; --i) {\n    if(hoge.find(a[i]) == hoge.end()){\n      hoge.insert(a[i]);\n      en.push_back(a[i]);\n    }\n  }\n  vector<int> foo(hoge.size());\n  for(auto &i : foo){\n    i = N;\n  }\n  for (int i = M; i >= 1; --i) {\n    int cnt = 0;\n    for(auto &j: foo){\n      if(j == a[i]) {\n        j--;\n        continue;\n      }\n      cnt += j;\n      if(cnt > M) {\n        cout << \"No\";\n        return 0;\n      }\n    }\n  }\n  cout << \"Yes\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tArray a(q);\n\tREP(i, q)cin >> a[i], a[i]--;\n\n\treverse(all(a));\n\tArray cnt(m, 0);\n\tArray pre(m, -1);\n\tll last = -1;\n\n\tArray used(m, 0);\n\tArray p;\n\n\tREP(i, q) {\n\t\tif (cnt[a[i]] == 0) {\n\t\t\tp.push_back(a[i]);\n\t\t\tused[a[i]] = 1;\n\t\t\tcnt[a[i]]++;\n\t\t\tpre[a[i]] = last;\n\t\t\tlast = a[i];\n\t\t}\n\t\telse if (pre[a[i]] == -1 || cnt[pre[a[i]]] > cnt[a[i]])cnt[a[i]]++;\n\t}\n\tREP(i, m)if (used[i] == 0)p.push_back(i);\n\tREP(i, m) {\n\t\tif (cnt[p[i]] != n) {\n\t\t\trep(j, i + 2, m) {\n\t\t\t\tif (p[j] < p[j - 1]) {\n\t\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// square1001氏.\n// https://atcoder.jp/contests/code-festival-2016-quala/submissions/1939048\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\nint N, M, Q, a[100009], c[100009], p[100009], inv[100009];\nint main(){\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    rep(i, Q) scanf(\"%d\", &a[i]), a[i]--;\n    rep(i, M) inv[i] = -1;\n    int cur = 0;\n    repr(i, Q - 1, 0){\n        if(inv[a[i]] == -1){\n            inv[a[i]] = cur;\n            c[cur] = 1;\n            p[cur++] = a[i];\n        }else{\n            if(c[inv[a[i]]] < (inv[a[i]] == 0 ? N : c[inv[a[i]] - 1])) c[inv[a[i]]]++;\n        }\n    }\n    rep(i, M) if(inv[i] == -1) p[cur++] = i;\n    bool ret = true;\n    rep(i, M) if(i >= 1 && c[i - 1] != N && p[i - 1] > p[i]) ret = false;\n    printf(ret ? \"Yes\\n\" : \"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nvoid RE(){\n    RE();\n    RE();\n}\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        RE();\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = (int)E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = n + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tbound[j - 1] = vec[A[i]][idx];\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n#include <fstream>\n\nusing namespace std;\n\n\n#define LL long long\n#define N 200100\n#define M 10000100\n#define MP make_pair\n#define Pi acos(-1.0)\n#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n#define ls (rt << 1)\n#define rs (ls | 1)\n#define md ((ll+rr)/2)\n#define lson ll, md, ls\n#define rson md+1, rr, rs\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define sqr(x) ((x)*(x))\n#define eps 1e-6\n#define MP make_pair\n#define uLL unsigned long long\nLL powmod(LL a,LL b) {LL res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n#define F(x) ((x)/3+((x)%3 == 1 ? 0 : tb))\n#define G(x) ((x)<tb ? (x)*3+1 : ((x) - tb)*3+2)\n#define lowbit(x) ((x)&(-x))\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nint gcd(int x,int y){\n    while(y){\n        int t = x % y;\n        x = y;\n        y = t;\n    }\n    return x;\n}\n\nint pos[N],a[N],on[N],at[N];\n\nint main(){\n    int n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i = 0; i < q; i++)\n        scanf(\"%d\",&a[i]),a[i]--;\n    \n    for(int i = 0; i < m; i++){\n        at[i] = 0;\n        pos[i] = -1;\n        on[i] = -1;\n    }\n    \n    int have = 0;\n    at[0] = n;\n    for(int i = q - 1; i >= 0; i--){\n        int v = a[i];\n        if(pos[v] == -1){\n            pos[v] = have;\n            on[have] = v;\n            at[have]--;\n            have++;\n            at[have]++;\n            continue;\n        }\n        if(at[pos[v]] > 0)\n            at[pos[v]]--,at[pos[v]+1]++;\n    }\n    \n    int fs = -1;\n    for(int i = 0; i < m; i++)\n        if(at[i] > 0){\n            fs = i;\n            break;\n        }\n    \n    vector<int> all;\n    for(int i = fs; i < have; i++){\n        all.push_back(on[i]);\n    }\n    for(int i = 0; i < m; i++)\n        if(pos[i] == -1)\n            all.push_back(i);\n    \n    sort(all.begin(), all.end());\n    \n    for(int i = fs; i < have; i++)\n        if(on[i] != all[i - fs]){\n            puts(\"No\");\n            return 0;\n        }\n    puts(\"Yes\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define eps (1e-6)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\n#define sq(x) ((x)*(x))\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define INF 1000000000000000000LL\n#define maxn 300005\n\nint a[maxn] , cnt[maxn] , pos[maxn] ;\n\nint main()\n{\n    int n , m ;\n    int q ;\n\n    scanf(\"%d %d\",&n,&m) ;\n    scanf(\"%d\",&q) ;\n\n    for(int i=1; i<=q ; i++) scanf(\"%d\",&a[i]) ;\n\n    vector <int> perm ;\n    set<int> st ;\n    for(int i=1 ; i<=m ; i++) st.insert(i) ;\n\n    for(int i=q ; i>=1 ; i--)\n    {\n        if( st.find(a[i]) != st.end() )\n        {\n            perm.pb(a[i]) ;\n            st.erase( st.find(a[i]) ) ;\n        }\n    }\n\n    for(int v: st) perm.pb(v) ;\n\n    while( perm.size() >= 2 )\n    {\n        int sz = perm.size() ;\n        if( perm[sz-2] < perm[sz-1] ) perm.pop_back() ;\n        else break ;\n    }\n\n    perm.pop_back() ;\n\n    for(int i=1 ; i<=m ; i++) pos[i] = -1 ;\n    for(int i=0 ; i<perm.size() ; i++) pos[ perm[i] ] = i ;\n\n    for(int i=q ; i>=1 ; i--)\n    {\n        if( pos[ a[i] ] == -1 ) continue ;\n\n        if( pos[ a[i] ] == 0 ) cnt[ pos[ a[i] ] ]++ ;\n        else{\n            cnt[ pos[ a[i] ] ]++ ;\n            cnt[ pos[ a[i] ] ] = min( cnt[ pos[a[i]] ] , cnt[ pos[a[i]] - 1 ] ) ;\n        }\n    }\n\n    int fl = 1 ;\n\n    for(int i=0 ; i<perm.size() ; i++)\n    {\n        if( cnt[i] < n ) fl = 0 ;\n    }\n\n    if(fl) printf(\"Yes\\n\") ;\n    else printf(\"No\\n\") ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  vector<int> result;\n  while(amc.size() > 0){\n    if (temp != 1){\n      minw = min(minw, (int)amc[temp].size()); \n    }\n    for (int i = 0; i < amc[temp].size(); i++){\n      used[amc[temp][i]] = 1;\n    }\n    amc.erase(temp);\n    while(used[tempindex] == 1){\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == i+1){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nint n,m,q,v;\nint a[N], used[N], ord[N], pos[N], sor[N], prog[N];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tFOR(i,q) scanf(\"%d\", &a[i]);\n\tFOR(i,q) a[i]--;\n\tREPD(i,q-1,0) if (!used[a[i]]) {\n\t\tord[v++] = a[i];\n\t\tused[a[i]]=1;\n\t}\n\tFOR(i,m) if (!used[i]) ord[v++] = i;\n\tsor[v-1]=sor[v]=1;\n\tREPD(i,v-2,0) sor[i] = sor[i+1] && (ord[i] < ord[i+1]);\n\tFOR(i,v) pos[ord[i]] = i;\n\tREPD(i,q-1,0) {\n\t\tint pp = upper_bound(prog, prog+n, a[i]) - prog - 1;\n\t\tif (pp >= 0) {\n\t\t\tprog[pp]++;\n\t\t}\n\t}\n\t//FOR(i,n) printf(\"%d %d\\n\", i, prog[i]);\n\tbool ok = true;\n\tFOR(i,n) if (!sor[prog[i]]) ok = false;\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\n\nvoid doit(set<int> rest){\n  int lastpos=q;\n  bool ng=false;\n  REP(i,m) if(rest.count(i)){\n    if(pos[i].empty()) lastpos=-1;\n    else if(pos[i][0]>lastpos) ng=true;\n    else lastpos=pos[i][0];\n  }\n  if(!ng){\n    puts(\"Yes\");\n  }else{\n    puts(\"No\");\n  }\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=q;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n\n  set<int> rest;\n  REP(i,m) rest.insert(i);\n\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        doit(rest);\n      }else{\n        finish[i]=pos[val][j];\n        ++j;\n      }\n    }\n    rest.erase(val);\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1] > f[a[i]]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q; cin >> N >> M >> Q;\n\n    vector<int> A(Q);\n    for (int i = 0; i < Q; ++i)\n        cin >> A[i];\n    vector<int> seen(M + 1, 0);\n    vector<int> coupled(M + 1, 0);\n    vector<int> next(M + 1, -1);\n    int last = -1;\n    int length = 0;\n    for (auto it = A.rbegin(); it != A.rend(); ++it) {\n        if (seen[*it]++ == 0) {\n            next[*it] = last;\n            last = *it;\n            ++length;\n        }\n        if (next[*it] == -1) {\n            coupled[*it]++;\n        } else {\n            coupled[*it] = min(coupled[*it] + 1, coupled[next[*it]]);\n        }\n    }\n\n    int now = last, i;\n    for (i = M; i > 0; --i) {\n        if (!seen[i])\n            continue;\n        if (now == i && now == length) {\n            now = next[now];\n            length--;\n        } else\n            break;\n    }\n    if (length == i && length > 0 && now != -1)\n        now = next[now];\n    if (now == -1 || coupled[now] >= N)\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q; cin >> N >> M >> Q;\n\n    vector<int> A(Q);\n    for (int i = 0; i < Q; ++i)\n        cin >> A[i];\n    vector<int> seen(M + 1, 0);\n    vector<int> coupled(M + 1, 0);\n    vector<int> next(M + 1, -1);\n    int last = -1;\n    int length = 0;\n    for (auto it = A.rbegin(); it != A.rend(); ++it) {\n        if (seen[*it]++ == 0) {\n            next[*it] = last;\n            last = *it;\n            ++length;\n        }\n        if (next[*it] == -1) {\n            coupled[*it]++;\n        } else {\n            coupled[*it] = min(coupled[*it] + 1, coupled[next[*it]]);\n        }\n    }\n\n    int now = last, i;\n    for (i = M; i > 0; --i) {\n        if (!seen[i])\n            continue;\n        if (now == i && now == length) {\n            now = next[now];\n            length--;\n        } else\n            break;\n    }\n    if (length > 0 && now != -1 && now <= length)\n        now = next[now];\n    if (now == -1 || coupled[now] >= N)\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nconst string NO = \"No\";\nconst string YES = \"Yes\";\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n    int q;\n    cin >> q;\n\n    vector<int> a(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n    }\n\n    reverse(a.begin(), a.end());\n\n    vector<int> b(n - 1);\n    for (int i = 0; i + 1 < n; ++i) {\n        b[i] = 0;\n    }\n\n    set<int> values;\n    for (int x = 1; x <= m; ++x) {\n        values.insert(x);\n    }\n\n    vector<int> minValues(m);\n    for (int i = 0; i < m; ++i) {\n        minValues[i] = 1;\n    }\n\n    map<int, int> mp;\n    int last = 1;\n\n    vector<int> revValues(m + 1);\n\n    for (int x : a) {\n        if (mp.find(x) == mp.end()) {\n            values.erase(values.find(x));\n            if (last < m) {\n                minValues[last] = (*values.begin());\n            }\n            revValues[last] = x;\n            mp[x] = last++;\n            continue;\n        }\n\n        int xx = mp[x] - 1;\n\n        int bl = 0;\n        int br = n - 2;\n        int ba = -1;\n        while (bl <= br) {\n            int bm = (bl + br) >> 1;\n\n            if (b[bm] == xx) {\n                ba = bm;\n                br = bm - 1;\n            } else if (b[bm] > xx) {\n                bl = bm + 1;\n            } else {\n                br = bm - 1;\n            }\n        }\n\n        if (ba == -1) {\n            continue;\n        } else {\n            ++b[ba];\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        while (b[i] != last - 1 && revValues[b[i] + 1] == minValues[b[i]]) {\n            ++b[i];\n        }\n        if (b[i] != last - 1) {\n            cout << NO << endl;\n            return 0;\n        }\n    }\n\n    cout << YES << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,nai=0;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tmultiset<int>las;//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las.ins(big);}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tvector<int>iti;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j>=numlis[no].size()){break;}\n\t\t\tauto it=las.lower_bound(numlis[no][j]);\n\t\t\tif(it==las.end()){break;}\n\t\t\titi.pub(*it);\n\t\t\tlas.erase(it);\n\t\t}\n\t\tif(j<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;j<n-nai;j++){\n\t\t\tauto it=las.lower_bound(-1);\n\t\t\titi.pub(-999);\n\t\t\tlas.erase(it);\n\t\t\tnai++;\n\t\t}\n\t\twhile(iti.size()!=0){las.ins(iti.back());iti.pob();}\n\t\t//cout<<endl<<\"de i=\"<<i;\n\t\t//for(auto it=las.begin();it!=las.end();it++){cout<<\" \"<<(*it);}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q + M);\n    for(int i = 0; i < M; i++){\n        a[M] = M - i - 1;\n    }\n    for(int i = M; i < Q + M; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q + M - 1; p >= 0; p--){\n        if (p >= M && que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N,M,Q;\n\tcin >> N >> M >> Q;\n\tvector<int> A(Q),seq;\n\tfor(int i =0; i < Q; i++) {\n\t\tcin >> A[i];\n\t\tA[i]--;\n\t}\n\tvector<bool> vis(M,0);\n\tfor(int i =Q-1; i >= 0; i--) if(!vis[A[i]]) {\n\t\tseq.push_back(A[i]);\n\t\tvis[A[i]] =1;\n\t}\n\tfor(int i =0; i < M; i++) if(!vis[i]) {\n\t\tseq.push_back(i);\n\t\tvis[i] =1;\n\t}\n\tvector<int> rev(M);\n\tfor(int i =0; i < M; i++) rev[seq[i]] =i;\n\n\tvector<int> cnt(M+1,0);\n\tcnt[0] =N;\n\tfor(int i =0; i < M; i++) vis[i] =0;\n\tfor(int i =Q-1; i >= 0; i--) {\n\t\tint id =rev[A[i]];\n\t\tif(cnt[id] == 0 && !vis[A[i]]) {\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(cnt[id] == 0) continue;\n\t\tvis[A[i]] =1;\n\t\tcnt[id]--;\n\t\tcnt[id+1]++;\n\t}\n\n\tint mid =M-1;\n\twhile(mid > 0 && seq[mid-1] < seq[mid]) mid--;\n\tfor(int i =0; i < mid; i++) if(cnt[i]) {\n\t\tcout << \"No\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"Yes\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,q){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n  REP(i,m) if(st.find(i)==st.end()) b.push_back(i);\n  int x = m-1;\n  while(x>0 && b[x-1] < b[x]) x--;\n\n  REP(i,q) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,q){\n    c[a[i]] = min(c[a[i]]+1,n);\n    if(a[i] && c[a[i]-1] < c[a[i]]) ng();\n  }\n\n  REP(i,x) if(c[i]<n) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(cnt[i] == n) continue;\n\t\tif(idx[i] != i + 1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, m, q, a[N], vec[N], cnt[N], pos[N];\nset<int> st;\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= m; i++) st.insert(i);\n\tint tmp = 0;\n\tfor (int i = q; i >= 1; i--) {\n\t\tif (st.count(a[i])) {\n\t\t\tvec[++tmp] = a[i];\n\t\t\tst.erase(a[i]);\n\t\t}\n\t}\n\twhile (st.size()) {\n\t\tvec[++tmp] = *st.begin();\n\t\tst.erase(st.begin());\n\t}\n\tfor (int i = 1; i <= m; i++) pos[vec[i]] = i;\n\tfor (int i = q; i >= 1; i--) {\n\t\tint p = pos[a[i]];\n\t\tcnt[p] = min(cnt[p] + 1, n);\n\t\tif (p > 1 && cnt[p - 1] < cnt[p]) {\n\t\t\tif (!cnt[p - 1]) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcnt[p] = cnt[p - 1];\n\t\t}\n\t}\n\tint st;\n\tfor (st = m; st > 1 && vec[st - 1] < vec[st]; st--);\n\tfor (int i = 1; i < st; i++) {\n\t\tif (cnt[i] < n) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nint top;\nbool okalone(int num,int I){\n\tif(num!=top) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn 1;\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t\tif(top==v){\n\t\t\twhile(top<M&&done[top]) top++;\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long target[200000];\nlong long filled[200000];\nlong long go[200000];\nint done[200000];\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m, query;\n\tcin >> n >> m >> query;\n\tvector<long long> inputs;\n\tREP(i, query) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\t//first we need to simulate it!\n\tint now_itr = 0;\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tif (done[inputs[i]] == 0) {\n\t\t\ttarget[inputs[i]] = now_itr;\n\t\t\tfilled[now_itr] = inputs[i];\n\t\t\tdone[inputs[i]] = 1;\n\t\t\tnow_itr++;\n\t\t}\n\t}\n\tnow_itr--;\n\twhile (now_itr > 0) {\n\t\tif (filled[now_itr - 1] > filled[now_itr]) break;\n\t\tnow_itr--;\n\t}\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tint hoge = target[inputs[i]];\n\t\tif (hoge >= now_itr) continue;\n\t\tint ok = 0;\n\t\tif (hoge == 0) {\n\t\t\tok = 1;\n\t\t}\n\t\telse if (go[hoge] == 0 || go[hoge] + 1 <= go[hoge - 1]) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tgo[hoge]++;\n\t\t\tif (hoge != 0 && go[hoge] > go[hoge - 1]) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < now_itr; ++i) {\n\t\tif (go[i] < n) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,nai=0;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tmultiset<int>las;//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las.ins(big);}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tvector<int>iti;\n\t\tint x=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j>=numlis[no].size()){break;}\n\t\t\tauto it=las.lower_bound(numlis[no][j]);\n\t\t\tif(it==las.end()){x++;continue;}\n\t\t\titi.pub(numlis[no][j]);\n\t\t\tlas.erase(it);\n\t\t}\n\t\tif(j-x<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;j-x<n-nai;j++){\n\t\t\tauto it=las.lower_bound(-1);\n\t\t\titi.pub(-999);\n\t\t\tlas.erase(it);\n\t\t\tnai++;\n\t\t}\n\t\twhile(iti.size()!=0){las.ins(iti.back());iti.pob();}\n\t\t//cout<<endl<<\"de i=\"<<i;\n\t\t//for(auto it=las.begin();it!=las.end();it++){cout<<\" \"<<(*it);}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  if(F){\n    for(int i=0;i<m&&F;i++){\n      if(P[i]!=-1&&C[P[i]]<n&&P[i]<N-1){\n\tint j=T[P[i]+1];\n\tif(j<i){\n\t  F=0;\n\t}\n\telse{\n\t  for(int x=i+1;x<j;x++){\n\t    if(P[x]==-1){\n\t      F=0;\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint used[114514];\nint inv[114514];\nsigned main(){\n\tint n,m,q;\n\tcin>>n>>m>>q;\n\tvector<int> a;\n\tfor(int i=0;i<q;i++){\n\t\tint x; cin>>x; a.pb(x);\n\t}\n\treverse( a.begin(), a.end() );\n\tvector<int> b;\n\tb = a;\n\tfor(int i=1;i<=m;i++){\n\t\tb.pb(i);\n\t}\n\tvector<int> c;\n\tfor(int i=0;i<b.size();i++){\n\t\tif( used[b[i]]==0 ){ c.pb(b[i]); used[b[i]] = 1;}\n\t}\n\tfor(int i=0;i<c.size();i++){ inv[ c[i] ] = i+1; }\n\tmultiset<int> ms;\n\tfor(int i=0;i<n;i++){\n\t\tms.insert(0);\n\t}\n\tint goal = m;\n\twhile( goal > 1 && c[goal-1] > c[goal-2] )goal--;\n\tgoal--;\n\tmultiset<int>::iterator it;\n\tfor(int i=0;i<q;i++){\n\t\tint cur = inv [ a[i] ];\n\t\tit = ms.find(cur-1);\n\t\tif( it != ms.end() ){\n\t\t\tms.erase( it );\n\t\t\tms.insert( cur );\n\t\t}\n\t\t//cout<<\"cur\"<<cur<<\" \"; for(auto itr = ms.begin(); itr != ms.end(); ++itr)cout<<*itr<<\" \"; cout<<endl;\n\t}\n\tint cnt = 0;\n\tit = ms.begin();\n\twhile( it != ms.end() ){\n\t\t//cout<<*it<<\" \";\n\t\tif( *it >= goal ) cnt++;\n\t\tit++;\n\t}\n\tif( cnt == n )cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,f[500010],m,a[500010],used;\nbool rem(){\n\tint t=0;\n\tFOR(i,1,q) if (a[i]>t){\n\t\tif (a[i]!=t+1) return 0;\n\t\t++t;\n\t}\n\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tif (rem()) return puts(\"Yes\"),0;\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,q) v[a[i]].pb(i);\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tu[a[now]]=1;\n\t\tused+=SZ(v[a[now]]);\n\t\tif (a[now]==1 && used==q) return puts(\"Yes\"),0;\n\t\tint t=0;\n\t\tFOR(i,1,n){\n\t\t\twhile (v[a[now]][t]<=f[i] && t<SZ(v[a[now]])) ++t;\n\t\t\tif (t>=SZ(v[a[now]])) return puts(\"No\"),0;\n\t\t\tf[i]=v[a[now]][t];\n\t\t\t++t;\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n//# pragma GCC target (\"sse4\")\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m,q;\n    static int s[1 << 20];\n    fi>>n>>m>>q;\n    for (int i = 1;i <= q;++i)\n        fi>>s[i];\n    vector < int > S;\n    static int was[1 << 20];\n    for (int i = 1;i <= m;++i)\n        was[i] = -1;\n    for (int i = q;i;--i)\n        if (was[s[i]] == -1)\n            S.push_back(s[i]),was[s[i]] = 1;\n    for (auto it : S)\n        p(it);\n    static int cnt[1 << 20];\n    cnt[0] = n;\n    int sz = S.size();\n    static int where[1 << 20];\n    for (int i = 0;i < sz;++i)\n        where[S[i]] = i + 1;\n    int until = sz - 1;\n    for (int i = sz - 1;i;--i)\n        if (S[i] > S[i-1])\n            --until;\n        else\n            break;\n    for (int i = q;i;--i)\n    {\n        const int index = where[s[i]] - 1;\n        if (cnt[index])\n            --cnt[index],++cnt[index + 1];\n    }\n    fo << (until && *max_element(cnt,cnt+until) ? \"No\" : \"Yes\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(x) (int((x).size()))\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\ntemplate<typename T> bool domax(T &a, T b) { return (b > a ? (a = b, true) : false); }\ntemplate<typename T> bool domin(T &a, T b) { return (b < a ? (a = b, true) : false); }\ntypedef long long ll;\n\nconst int maxn = 100*1000+5;\n\nint n, m, q, a[maxn], place[maxn], next[maxn];\nstd::vector<int> l[maxn];\nbool seen[maxn];\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &q);\n    for (int i = 0; i < q; i++) scanf(\"%d\", a+i);\n    for (int i = q-1; i >= 0; i--) {\n        int v = a[i];\n        if (!seen[v]) {\n            seen[v] = true;\n            place[v] = sz(l[0]);\n            l[next[v]++].pb(v);\n        } else if (next[v] < n) {\n            if (place[v] == sz(l[next[v]])) {\n                l[next[v]++].pb(v);\n            }\n        }\n    }\n    std::fill(seen, seen+m+1, false);\n    for (int &i : l[n-1]) seen[i] = true;\n    for (int j = 1; j <= m; j++) if (!seen[j]) l[n-1].pb(j);\n    for (int i = n-2; i >= 0; i--) {\n        for (int k = 0; k < sz(l[i]); k++) if (l[i][k] != l[n-1][k]) {\n            printf(\"No\\n\");\n            exit(0);\n        }\n    }\n    printf(\"Yes\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)));\n\nint N , M , Q;\nint a[100010];\nint x[100010];\nint c;\nint f , e;\nvector<int> V;\n\nint main(){\n\tscanf(\"%d%d%d\" , &N , &M , &Q);\n\tfor(int i = 0 ; i < Q ; ++i){\n\t\tscanf(\"%d\" , a + i);\n\t}\n\tc = 0;\n\tf = 0;\n\te = 0;\n\tfor(int i = Q - 1 ; i >= 0 ; --i){\n\t\t++x[a[i]];\n\t\tif(x[a[i]] == 1){\n\t\t\twhile(x[c + 1] > 0) ++c;\n\t\t\tV.push_back(a[i]);\n\t\t\t++e;\n\t\t\tif(c < a[i]){\n\t\t\t\tf = e;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i < f ; ++i){\n\t\tif(x[V[i]] < N){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nint main()\n{\n\tios_init();\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tint q;\n\t\tcin >> q;\n\t\tvector<int> a(q);\n\t\tREP(i,q) cin >> a[i], a[i]--;\n\t\tvector<int> v;\n\t\t// v.reserve(m);\n\t\tvector<bool> f(m,false);\n\t\tRREP(i,q){\n\t\t\tif(!f[a[i]]){\n\t\t\t\tf[a[i]] = true;\n\t\t\t\tv.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tREP(i,q){\n\t\t\tif(!f[i]){\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint p = SZ(v)-1;\n\t\tRREP(i,SZ(v)-1){\n\t\t\tif(v[i+1] > v[i]){\n\t\t\t\tp--;\n\t\t\t}else break;\n\t\t}\n\t\tvector<int> mp(m,-1000);\n\t\tREP(i,SZ(v)){\n\t\t\tmp[v[i]] = i;\n\t\t}\n\t\tvector<int> cntv(m,0);\n\t\tdpite(ALL(mp));\n\t\tRREP(i,q){\n\t\t\tif(mp[a[i]] == 0 or cntv[mp[a[i]]] < cntv[mp[a[i]]-1]){\n\t\t\t\tcntv[mp[a[i]]]++;\n\t\t\t}else{\n\n\t\t\t}\n\t\t}\n\t\tstring ans = \"Yes\";\n\t\tdpite(ALL(cntv));\n\t\tREP(i,p){\n\t\t\tif(cntv[i] < n){\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\n/* -------------------------------- Library -------------------------------- */\n\n/* ---------------------------------- Main ---------------------------------- */\n\nint main() {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n  vector<int> a(Q);\n  for (int &i: a) { cin >> i; --i; }\n  reverse(ALL(a));\n\n  vector<int> ans;\n  set<int> se;\n  REP(i,M) se.insert(i);\n  for (int i: a) {\n    auto it = se.find(i);\n    if (it != se.end()) {\n      ans.push_back(*it);\n      se.erase(it);\n    }\n  }\n  for (int i: se) ans.push_back(i);\n  int mi = 1e9;\n  while (!ans.empty() && ans.back() < mi) {\n    mi = ans.back(); ans.pop_back();\n  }\n  vector<int> it(M, -1);\n  REP(i,ans.size()) it[ans[i]] = i;\n  vector<int> res(ans.size(), 0);\n  for (int i: a) {\n    int id = it[i];\n    if (id == -1) continue;\n    // cout << id << \" \" << ans.size() << endl;\n    if (id == 0 || res[id-1] > res[id]) ++res[id];\n  }\n  bool flag = (res.size() == 0 || res.back() >= N);\n  cout << (flag ? \"Yes\" : \"No\") << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M * 2, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n//\tfor (PP p : seq) {\n//\t\tif (p.second == N) {\n//\t\t\tSet.erase(p.first);\n//\t\t} else {\n//\t\t\tif (*Set.begin() != p.first) {\n//\t\t\t\tok = false;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tSet.erase(p.first);\n//\t\t}\n//\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, m, q;\n        in >> n >> m >> q;\n        vector<int> v(q);\n        for (int i: range(q)) {\n            in >> v[i];\n            --v[i];\n        }\n\n        vector<vector<int>> changesTimes(m);\n\n        for (int i: range(q)) {\n            changesTimes[v[i]].push_back(i);\n        }\n\n        vector<int> last(n, 1000000000);\n\n\n        vector<int> used(m + 1);\n        int minUnused = 0;\n        for (int j: downrange(q)) {\n            int i = v[j];\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            while (used[minUnused])\n                ++minUnused;\n            if (i <= minUnused) {\n                continue;\n            }\n\n            set<int> cur(changesTimes[i].begin(), changesTimes[i].end());\n\n            for (int& vv: last) {\n                auto it = cur.lower_bound(vv);\n                if (it == cur.begin()) {\n                    out << \"No\\n\";\n                    return;\n                }\n                --it;\n                vv = *it;\n                cur.erase(it);\n            }\n        }\n\n        out << \"Yes\\n\";\n    }\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    int mn = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        if(arr[i] == mn) {\n            chk[arr[i]] = 1;\n            while(mn < M && chk[mn]) mn++;\n            continue;\n        }\n        if(Pos[arr[i]].size() < N) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\nconst int max0=100010;\n\nint main()\n{\nprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK \"1\"\n\nusing namespace std;\n\nint n, m, q;\nvector<int> need[N], ans[N];\n\nint used[N];\nint t[N];\nint was[N];\n\nvector<int> dop(vector<int> a) {\n\tfor (int i = 1; i <= m; i++) used[i] = 0;\n\tfor (int i = 0; i < a.size(); i++) used[a[i]] = 1;\n\tfor (int i = 1; i <= m; i++) if (!used[i]) a.pb(i);\n\treturn a;\n}\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK\".in\",\"r\",stdin);\t\n\t\tfreopen(TASK\".out\",\"w\",stdout);\n\t#endif\t\t\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> t[i];\n\t}\n\tfor (int i = 1; i < n; i++) need[0].pb(i);\n\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tint g = t[i];\n\n\t\tif (was[g] == 0) {\n\t\t\tans[0].pb(g);\n\t\t\twas[g] = 1;\n\n\t\t\tfor (int h : need[0]) need[g].pb(h);\n\t\t\tneed[0].clear();\n\n\t\t\tcontinue;\n\t\t}\n\t\tif (need[g].size() == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint t = need[g].back();\n\t\tneed[g].pop_back();\n\n\t\tans[t].pb(g);\n\n\t\tif (ans[t].size() < m) {\n\t\t\tif (ans[0].size() == ans[t].size()) need[0].pb(t); else need[ans[0][ans[t].size()]].pb(t);\n\t\t}\n\t}\n//\tfor (int i = 0; i < n; i++) {\n//\t\tfor (int j = 0; j < ans[i].size(); j++) cout << ans[i][j] << \" \";\n//\t\tcout << endl;\n//\t}\n\tint x = -1;\n\tfor (int i = 0; i < n; i++) if (x == -1 || ans[i].size() < ans[x].size()) x = i;\n\tif (dop(ans[0]) != dop(ans[x])) cout << \"No\\n\"; else cout << \"Yes\\n\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nset<int> s;\n\nstruct bit{\n\tint tree[100005];\n\tvoid add(int x, int v){\n\t\twhile(x <= m){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nint a[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tcol[a[i]].push_back(i);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\tfor(int i=q; i; i--){\n\t\tif(col[a[i]].empty() || col[a[i]].back() != i) continue;\n\t\tif(a[i] == 1){\n\t\t\tfor(int j=2; j<=m+1; j++){\n\t\t\t\tif(col[j].empty()){\n\t\t\t\t\tbool bad= 0;\n\t\t\t\t\tfor(int k=j+1; k<=m; k++){\n\t\t\t\t\t\tif(col[k].size()){\n\t\t\t\t\t\t\tbad = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad) return !puts(\"Yes\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = a[i];\n\t\tfor(int j=0; j<n; j++){\n\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\ttime[j] = col[x].back();\n\t\t\tcol[x].pop_back();\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long llint;\ntypedef pair <int, int> pi;\n\nconst int MAXN = 100005;\n\nint n, m, q;\nint a[MAXN], bio[MAXN], cnt[MAXN], nxt[MAXN];\nvector <int> v, r;\n\nint main () {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    for (int i = q-1; i >= 0; i--) {\n        if (!bio[a[i]]) v.push_back(a[i]);\n        bio[a[i]] = 1;\n    }\n    for (int i = 1; i <= m; i++) if (bio[i] == 0) v.push_back(i);\n    for (int i = 1; i < m; i++) nxt[v[i - 1]] = v[i];\n    cnt[v[0]] = n;\n    for (int i = q-1; i >= 0; i--) {\n        if (cnt[a[i]] == 0) continue;\n        cnt[a[i]]--;\n        cnt[nxt[a[i]]]++;\n    }\n    memset(bio, 0, sizeof bio);\n    for (int i = 0; i < m; i++) {\n        if (cnt[v[i]] != 0) break;\n        bio[v[i]] = 1;\n        r.push_back(v[i]);\n    }\n    for (int i = 1; i <= m; i++) if (bio[i] == 0) r.push_back(i);\n    bool ok = 1;\n    for (int i = 0; i < m; i++) ok &= v[i] == r[i];\n    if (ok) cout << \"Yes\"; else cout << \"No\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK \"1\"\n\nusing namespace std;\n\nint n, m, q;\nvector<int> need[N], ans[N];\n\nint used[N];\nint t[N];\nint was[N];\n\nvector<int> dop(vector<int> a) {\n\tfor (int i = 1; i <= m; i++) used[i] = 0;\n\tfor (int i = 0; i < a.size(); i++) used[a[i]] = 1;\n\tfor (int i = 1; i <= m; i++) if (!used[i]) a.pb(i);\n\treturn a;\n}\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK\".in\",\"r\",stdin);\t\n\t\tfreopen(TASK\".out\",\"w\",stdout);\n\t#endif\t\t\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> t[i];\n\t}\n\tfor (int i = 1; i < n; i++) need[0].pb(i);\n\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tint g = t[i];\n\n\t\tif (was[g] == 0) {\n\t\t\tans[0].pb(g);\n\t\t\twas[g] = 1;\n\n\t\t\tfor (int h : need[0]) need[g].pb(h);\n\t\t\tneed[0].clear();\n\n\t\t\tcontinue;\n\t\t}\n/*\t\tif (need[g].size() == 0) {\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}*/\n\n\t\tint t = need[g].back();\n\t\tneed[g].pop_back();\n\n\t\tans[t].pb(g);\n\n\t\tif (ans[t].size() < m) {\n\t\t\tif (ans[0].size() == ans[t].size()) need[0].pb(t); else need[ans[0][ans[t].size()]].pb(t);\n\t\t}\n\t}\n//\tfor (int i = 0; i < n; i++) {\n//\t\tfor (int j = 0; j < ans[i].size(); j++) cout << ans[i][j] << \" \";\n//\t\tcout << endl;\n//\t}\n\tint x = -1;\n\tfor (int i = 0; i < n; i++) if (x == -1 || ans[i].size() < ans[x].size()) x = i;\n\tif (dop(ans[0]) != dop(ans[x])) cout << \"No\\n\"; else cout << \"Yes\\n\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __UNION_FIND_H__0004__\n#define __UNION_FIND_H__0004__\n\nclass UnionFindTree {\n\tint whole_size_m;\n\tint* parent_p_m;\t// 根である場合は自分自身の添え字を入れる\n\tint* rank_p_m;\n\tint* size_p_m;\t\t// 集合のサイズ(根に大きさを書く)\n\n\tbool Is_valid_index(int index);\n\tint Root_of_rec(int index);\npublic:\n\tUnionFindTree(int whole_size);\n\t~UnionFindTree();\n\n\tint Root_of(int index);\n\tvoid Unite(int index_l, int index_r);\n\tbool Are_together(int index_l, int index_r);\n\tint Size_of_set(int index);\n};\n\n#include <cassert>\n#include <functional>\n#include <algorithm>\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n\nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n\n\tconst FuncType func_m;\n\n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n\n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n\ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n\n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n\ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n\ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n\n\tval_p_m = new T[1 << rank_m];\n\tfill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n\n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n\ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n\n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n\ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n\n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n\ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn max<T>(a, b);\n\t}\n};\n\ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn min<T>(a, b);\n\t}\n};\n\n#endif\n\n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n\n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n\nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n\n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vi a(q);\n  rep (i, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  //DEBUG_VEC(a);\n\n  vi pre_idx_value(m, inf);\n  vi pre_idx_same_value(q, -1);\n  rrep (i, q) {\n    if (pre_idx_value[a[i]] != inf) {\n      pre_idx_same_value[pre_idx_value[a[i]]] = i;\n    }\n    pre_idx_value[a[i]] = i;\n  }\n  \n  vector<bool> used_x(m);\n  vi pre_idx(n, inf);\n  int idx = q - 1;\n\n  int ok_idx = q;\n  int nex = 0;\n  while (true) {\n    bool flag = true;\n    for (int i = ok_idx - 1; i >= 0; i--) {\n      while (nex < m and used_x[nex]) nex++;\n      if (used_x[a[i]]) {\n        ok_idx = i;\n        continue;\n      }\n      if (a[i] == nex) {\n        nex = a[i] + 1;\n        ok_idx = i;\n      }\n      else if (a[i] < nex) {\n        ok_idx = i;\n        continue;\n      }\n      else {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(pre);\n    //DEBUG(idx);\n    while (idx >= 0) {\n      if (used_x[a[idx]]) idx--;\n      else break;\n    }\n    if (idx == -1) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(idx);\n\n    used_x[a[idx]] = true;\n    pre_idx[0] = idx;\n    int j = 1;\n    int i = pre_idx_same_value[idx];\n    while (i >= 0) {\n      if (i < pre_idx[j]) {\n        pre_idx[j] = i;\n        j++;\n      }\n      if (j == n) break;\n      i = pre_idx_same_value[i];\n    }\n    if (j < n) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\n\nbool vis[N];\nint n,m,q,a[N],cnt[N],p[N];\nvi order;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m >> q;\n    forn(i,q) cin >> a[i], a[i]--;\n    dforsn(i,0,q) if (!vis[a[i]]) {\n        order.pb(a[i]);\n        vis[a[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) order.pb(i);\n    //for (int x : order) cerr << x+1 << ' ';\n    forn(i,m) p[order[i]] = i;\n\n    bool ok = true;\n    cnt[0] = n;\n    dforsn(i,0,q) {\n        int pos = p[a[i]];\n        if (cnt[pos]) {\n            cnt[pos]--;\n            cnt[pos+1]++;\n        }\n        else if (cnt[pos+1]);\n        else ok = false;\n    }\n\n    int least;\n    forn(i,N) if (cnt[i]) {\n        least = i;\n        break;\n    }\n\n    vi norder;\n    memset(vis,0,sizeof vis);\n    forn(i,least) {\n        norder.pb(order[i]);\n        vis[order[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) norder.pb(i);\n    \n    ok &= norder == order;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n, m; cin >> n >> m;\n\tvector<int> at(m, -1), cnt(m + 1, 0), stk;\n\tcnt[0] = n;\n\tint q; cin >> q;\n\tvector<int> op(q);\n\tfor(int & v : op) cin >> v;\n\treverse(op.begin(), op.end());\n\tfor(int & v : op){\n\t\tv--;\n\t\tif(at[v] == -1){\n\t\t\tstk.push_back(v);\n\t\t\tat[v] = stk.size();\n\t\t\tcnt[at[v]] = 1;\n\t\t} else {\n\t\t\tif(cnt[at[v] - 1] > cnt[at[v]]){\n\t\t\t\tcnt[at[v]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint len = stk.size() + 1;\n\tvector<int> res;\n\tfor(int i = 0, j = 0; i < len; i = j){\n\t\twhile(j < len && cnt[j] == cnt[i]) j++;\n\t\tif(!res.empty() && j != len) continue;\n\t\tvector<int> holm;\n\t\tfor(int k = 1; k < j; k++) holm.push_back(stk[k - 1]);\n\t\tfor(int k = 0; k < m; k++) if(at[k] == -1 || at[k] >= j) holm.push_back(k);\n\t\tif(res.empty()) res = holm;\n\t\telse if(res != holm){\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nint top;\nbool okalone(int num,int I){\n\texit(1);\n\tif(num!=top) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t\tif(top==v){\n\t\t\twhile(top<M&&done[top]) top++;\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define er erase\n#define bg begin()\n#define ed end()\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define enter cout << \"\\n\"\n#define space cout << \" \"\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (n); ++i)\n#define fj(st,n) for (int j = (st); j <= (n); ++j)\n#define fk(st,n) for (int k = (st); k <= (n); ++k)\n#define fq(st,n) for (int q = (st); q <= (n); ++q)\n#define fw(st,n) for (int w = (st); w <= (n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (n); --i)\n#define ej(st,n) for (int j = (st); j >= (n); --j)\n#define ek(st,n) for (int k = (st); k >= (n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (n); --(i))\n#define ri(st,n) for (int i = (st); i < (n); ++i)\n#define rj(st,n) for (int j = (st); j < (n); ++j)\n#define rk(st,n) for (int k = (st); k < (n); ++k)\n#define rq(st,n) for (int q = (st); q < (n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = (int)1e9;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 1000000007;\nconst int maxn = (int) 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint n, m, T, a[maxn], khm, x, y, t[maxn], en[maxn];\nvector <int> vh, vc[maxn];\n\nint main()\n{\n//    fin(\"t.in\");\n    sync;\n    cin >> n >> m;\n    cin >> T;\n    fi(1, T) {\n        cin >> a[i];\n        vc[a[i]].pb(i);\n    }\n    fi(1, n) {\n        en[i] = T;\n    }\n    vh.clear();\n    khm = -1;\n    ei(T, 1) {\n        if (t[a[i]])\n            continue;\n        vh.pb(a[i]);\n        t[a[i]] = 1;\n        x = n;\n        ej((int)vc[a[i]].size() - 1, 0) {\n            if (en[x] < vc[a[i]][j]) {\n                continue;\n            }\n            en[x] = vc[a[i]][j] - 1;\n            --x;\n            if (x == 0)\n                break;\n        }\n        if (khm == -1) {\n            ej(x, 1) {\n                en[j] = 0;\n                khm = (int)vh.size() - 1;\n            }  \n        }\n    }\n    if (khm != -1) {\n        y = 0;\n//        cout << khm << endl;\n        ri(khm, vh.size()) {\n            ++y;\n            if (vh[i] != y) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, M, Q;\nconst int _ = 100096;\nint a[_], r[_], id[_], s[_];\nbool vis[_];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tint t = 1;\t\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tif(a[i] >= t-1) t = a[i];\n\t}\n\tif(t == 1) return puts(\"Yes\"), 0;\n\tint c = 0;\n\tfor(int i = Q; i >= 1; --i)\n\t\tif(!vis[a[i]]) {\n\t\t\tr[++c] = a[i];\n\t\t\tvis[a[i]]= true;\n\t\t}\n\tfor(int i =1; i <= M; ++i)\n\t\tif(!vis[i]) r[c++] = i;\n\tfor(int i = 1; i <= M; ++i)\n\t\tid[r[i]] = i;\n\tint init = M;\n\tfor(int i = M; i >= 1; --i)\n\t\tif(id[i] == i) {\n\t\t\tinit = i - 1;\n\t\t} else break;\n\ts[init] = N;\n\tint worst = init;\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tint k = id[a[i]];\n\t\tif(s[k + 1]) {\n\t\t\ts[k + 1]--;\n\t\t\t++s[k];\n\t\t\tif(k + 1 == worst && !s[k + 1])\n\t\t\t\t--worst;\n\t\t} else {\n\t\t\tif(k > worst) {\n\t\t\t\t--s[worst];\n\t\t\t\t++s[worst = k];\n\t\t\t} \n\t\t}\n\t}\n\tputs(worst > 1? \"No\": \"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n#include <ctime>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main() {\n  srand((unsigned)time(NULL));\n  if (rand() % 2 == 0) {\n    cout << \"Yes\" << endl;\n  }\n  else {\n    cout << \"No\" << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nint n,m,q;\nint t[MAX];\nvector<int> wyg;\nbool cz[MAX];\nbool odw[MAX];\nvoid tak(){\n  cout << \"Yes\\n\";\n  exit(0);\n}\nint dp[MAX],gd[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    cin >> t[i];\n    t[i]--;\n  }\n  for(int i = q-1;i >= 0;i--){\n    if(!cz[t[i]]){\n      cz[t[i]] = 1;\n      gd[t[i]] = SZ(wyg);\n      wyg.PB(t[i]);\n    }\n  }\n  if(cz[0]){\n   // bool ok = 1;\n    int pom = gd[0];\n    R(i,pom){\n      odw[wyg[i]] = 1;\n    }\n    int pow = 0;\n    while(1){\n      pom ++;\n      pow ++;\n      if(pom == SZ(wyg)){\n        wyg.resize(gd[0]);\n        break;\n      }\n      while(odw[pow])pow++;\n      if(wyg[pom] != pow)break;\n    }/*\n    R(i,SZ(wyg)){\n      if(wyg[i] != i)ok = 0;\n    }\n    if(ok)tak();*/\n  }\n  for(int i = q-1;i >= 0;i--){\n    int pom = gd[t[i]];\n    if(pom == 0)\n      dp[pom]++;\n    else\n      dp[pom] = min(dp[pom]+1, dp[pom-1]);\n  }\n  if(SZ(wyg) == 0 || dp[SZ(wyg)-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  int Q; cin >> Q;\n  VI xs(Q);\n  REP(i,Q){\n\tcin >> xs[i];\n\t--xs[i];\n  }\n\n  vector<bool> use(M);\n  VI as;\n  for(int i=Q-1;i>=0;--i)\n\tif(!use[xs[i]]){\n\t  use[xs[i]] = true;\n\t  as.PB(xs[i]);\n\t}\n  REP(i,M)\n\tif(!use[i])\n\t  as.PB(i);\n  //REP(i,M) cout<<as[i]<<\" \";cout<<endl;\n  VI len(M+1);\n  len[0] = N;\n  VI idx(M);\n  REP(i,M) idx[as[i]] = i;\n  for(int i=Q-1;i>=0;--i){\n\tint x = xs[i];\n\tif(len[idx[x]]){\n\t  len[idx[x]+1]++;\n\t  len[idx[x]]--;\n\t}\n  }\n  REP(i,M)\n\tlen[idx[i]+1] += len[idx[i]];\n  \n  cout << (len[M]==N?\"Yes\":\"No\") << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nint top;\nbool okalone(int num,int I){\n\tif(num!=top) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t\tif(top==v){\n\t\t\twhile(top<M&&done[top]) top++\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 303030;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(n, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(n, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tassert(false);\n\tREP(i, n) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nint main(){\n  int R, C, N;\n  cin >> R >> C;\n  cin >> N;\n  //long long int mat[R+10][C+10];\n  long long int *mat;\n  mat = (long long int*)malloc(sizeof(long long int) * R*C);\n  for(int i  = 0; i < R; i++){\n    //mat[i] = (long long int*)malloc(sizeof(long long int) * C);\n    for(int j = 0; j < C; j++){\n      mat[i*R+j] = -1;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    long long int r,c,a;\n    cin >> r >> c >> a;\n    mat[(r-1)*R+c-1] = a;\n  }\n  bool changed = true;\n  while(changed){\n    changed = false;\n    for(int i  = 0; i < R-1; i++){\n      for(int j = 0; j < C-1; j++){\n        int c = 0;\n        if(mat[i*R+j] == -1){\n          c++;\n        }\n        if(mat[(i+1)*R+j] == -1){\n          c++;\n        }\n        if(mat[i*R+j+1] == -1){\n          c++;\n        }\n        if(mat[(i+1)*R+j+1] == -1){\n          c++;\n        }\n        if(c >= 2){\n          continue;\n        }else if(c == 0){\n          if(mat[i*R+j]+mat[(i+1)*R+j+1] != mat[(i+1)*R+j]+mat[i*R+j+1]){\n            cout << \"No\" << endl;\n            return 0;\n          }\n        }else{//c == 1\n          long long int v = 0;\n          if(mat[i*R+j] == -1){\n            v = mat[i*R+j] = mat[(i+1)*R+j] + mat[i*R+j+1] - mat[(i+1)*R+j+1];\n          }else if(mat[(i+1)*R+j] == -1){\n            v = mat[(i+1)*R+j] = mat[i*R+j] + mat[(i+1)*R+j+1] - mat[i*R+j+1];\n          }else if(mat[i*R+j+1] == -1){\n            v = mat[i*R+j+1] = mat[i*R+j] + mat[(i+1)*R+j+1] - mat[(i+1)*R+j];\n          }else if(mat[(i+1)*R+j+1] == -1){\n            v = mat[(i+1)*R+j+1] = mat[(i+1)*R+j] + mat[i*R+j+1] - mat[i*R+j];\n          }\n          if(v < 0){\n            cout << \"No\" << endl;\n            return 0;\n          }\n          changed = true;\n        }\n      }\n    }\n  }\n  cout << \"Yes\" << endl;\n  free(mat);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, m, q;\n        in >> n >> m >> q;\n        vector<int> v(q);\n        for (int i: range(q)) {\n            in >> v[i];\n            --v[i];\n        }\n\n        vector<vector<int>> changesTimes(m);\n\n        for (int i: range(q)) {\n            changesTimes[v[i]].push_back(i);\n        }\n\n        vector<int> last(n, 1000000);\n\n\n        vector<int> used(m + 1);\n        int minUnused = 0;\n        for (int j: downrange(q)) {\n            if (used[v[j]]) {\n                continue;\n            }\n            int i = v[j];\n            if (i == minUnused) {\n                used[i] = true;\n                while (used[minUnused])\n                    ++minUnused;\n                continue;\n            }\n            used[i] = true;\n            while (used[minUnused])\n                ++minUnused;\n\n            if (changesTimes[i].size() < n) {\n                out << \"No\\n\";\n                return;\n            }\n            set<int> cur(changesTimes[i].begin(), changesTimes[i].end());\n\n            for (int& vv: last) {\n                auto it = cur.lower_bound(vv);\n                if (it == cur.begin()) {\n                    out << \"No\\n\";\n                    return;\n                }\n                --it;\n                vv = *it;\n                cur.erase(it);\n            }\n        }\n\n        out << \"Yes\\n\";\n    }\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\n\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t}\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0)return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\tLST[ct] = pos[x][j];\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n\tputs(chk()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(cnt[i] == n) continue;\n\t\tif(cnt[i] == 0) {\n\t\t\tif(dict.count(i + 1)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(idx[i] != i + 1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tint Q;cin>>Q;\n\tvi A(Q);cin>>A;\n\tvi v(N),I(M+1),B;\n\trf(i,Q){\n\t\tif(I[A[i]]){\n\t\t\tauto it=lower_bound(all(v),I[A[i]]);\n\t\t\tif(it!=v.begin()){\n\t\t\t\t--it;\n\t\t\t\tif(*it==I[A[i]]-1){\n\t\t\t\t\t++*it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tI[A[i]]=++v[N-1];\n\t\t\tB<<A[i];\n\t\t}\n\t}\n\tbool z=true;\n\tfoor(i,v[0],v[N-1]-2){\n\t\tz&=B[i]<B[i+1];\n\t}\n\tYn(z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    std::vector<int> A(M + Q);\n    for (int i = M; i < M + Q; i++) { std::cin >> A[i], A[i]--; }\n    for (int i = 0; i < M; i++) { A[i] = M - i - 1; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M + Q; i++) { L[A[i]].push_back(i); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = M + Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, Q + M);\n    for (const auto& o : op) {\n        for (int i = 0; i < N; i++) {\n            while (pos[i] < L[o].back()) {\n                if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                L[o].pop_back();\n            }\n            const int prev = pos[i];\n            pos[i] = L[o].back();\n            if (L[o].size() > 1) { L[o].pop_back(); }\n            if (prev < M) { break; }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid ext(vector<int> &result, int len, int m, vector<int> &v) {\n    vector<bool> used(m+1, false);\n    for (int i = 0; i < len; i++) {\n        int a = result[i];\n        assert(!used[a]);\n        v.push_back(a);\n        used[a] = true;\n    }\n    for (int i = 1; i <= m; i++) if (!used[i]) v.push_back(i);\n}\n\nint main() {\n    int n, m, q; cin >> n >> m >> q;\n    int a[q];\n    for (int i = 0; i < q; i++) cin >> a[i];\n    vector<int> cnt(m+1, 0), len(n, 0), idx(m+1), result;\n    for (int i = q-1; i >= 0; i--) {\n        if (0 < cnt[a[i]]) {\n            if (cnt[a[i]] < n && len[cnt[a[i]]] == idx[a[i]]) {\n                len[cnt[a[i]]]++;\n                cnt[a[i]]++;\n            }\n        } else {\n            cnt[a[i]]++;\n            len[0]++;\n            idx[a[i]] = result.size();\n            result.push_back(a[i]);\n        }\n        // cerr << \"result = \"; for (int x : result) cerr << x << \" \"; cerr << endl;\n        // cerr << \"length = \"; for (int x : len) cerr << x << ' '; cerr << endl;\n        // cerr << \"idx = \"; for (int x : idx) cerr << x << ' '; cerr << endl;\n        // cerr << \"cnt = \"; for (int x : cnt) cerr << x << ' '; cerr << endl;\n    }\n    vector<int> v1, v2;\n    ext(result, len[0], m, v1);\n    ext(result, len[n-1], m, v2);\n    for (int i = 0; i < m; i++) {\n        // cerr << v1[i] << \" \" << v2[i] << endl;\n        if (v1[i] != v2[i]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 0; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] < n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tif (now == -1) return 1;\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j >= n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N,M; cin >> N >> M;\n    int Q; cin >> Q;\n    vector<int> A(Q);\n    rep(i,Q) cin >> A[i];\n\n    map<int, int> dic;\n    dic.emplace(0,0);\n    vector<int> idx = {0};\n    vector<int> cnt = {N};\n    for (int i = Q-1, cur = 1; i >= 0; i--) {\n        if (dic.count(A[i])) {\n            int id = dic[A[i]];\n            if (cnt[id-1]==cnt[id]) continue;\n            cnt[id]++;\n        } else {\n            dic[A[i]] = cur;\n            idx.emplace_back(A[i]);\n            cur++;\n            cnt.emplace_back(1);\n        }\n    }\n\n    rep(i,SZ(idx)) {\n        if (cnt[i]!=N) {\n            int n = idx[i];\n            if (n != 1) {\n                cout << \"No\" << ln;\n                return 0;\n            }\n            for (int j = i+1; j < SZ(idx); j++) {\n                if (idx[j] != n+1) {\n                    cout << \"No\" << ln;\n                    return 0;\n                }\n                n++;\n            }\n            break;\n        }\n    }\n\n    cout << \"Yes\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\n\nbool was[maxn];\nint a[maxn];\nint pos[maxn];\nset<int> need[maxn];\nset<int> waiting;\nint ans[maxn], posans[maxn];\nint n, m, q;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n// \t\tscanf(\"%d\", &a[m + i]);\n// \t\ta[m + i]--;\n\t}\n// \tq += m;\n\tfor (int i = 0; i < m; i++) was[i] = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tneed[a[q - 1]].insert(i);\n\t\tpos[i] = 0;\n\t}\n\tans[0] = a[q - 1];\n\twas[a[q - 1]] = true;\n\tint anslen = 1;\n\tfor (int i = q - 1; i >= 0; i--)\n\t{\n\t\tif (need[a[i]].size() > 0)\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (was[a[i]]) continue;\n\t\tans[anslen] = a[i];\n\t\tanslen++;\n\t\tfor (auto t : waiting)\n\t\t{\n\t\t\tneed[a[i]].insert(t);\n\t\t}\n\t\twaiting.clear();\n\t\twas[a[i]] = true;\n\t\t{\n\t\t\tint wh = *need[a[i]].begin();\n\t\t\tneed[a[i]].erase(need[a[i]].begin());\n\t\t\tpos[wh]++;\n\t\t\tif (anslen > pos[wh]) need[ans[pos[wh]]].insert(wh);\n\t\t\telse waiting.insert(wh);\n\t\t}\n\t}\n// \tcout << anslen << endl;\n// \tfor (int i = 0; i < anslen; i++) cout << ans[i] << ' ';\n// \tcout << endl;\n// \tfor (int i = 0; i < n; i++) cout << pos[i] << ' ';\n// \tcout << endl;\n\tfor (int i = 0; i < m; i++) posans[i] = m;\n\tfor (int i = 0; i < anslen; i++) posans[ans[i]] = i;\n\tfor (int i = 0; i < n; i++) if (pos[i] < anslen)\n\t{\n// \t\tcout << i << ' ' << pos[i] << endl;\n\t\tint cur = 0;\n\t\twhile (pos[i] < anslen && cur < m)\n\t\t{\n// \t\t\tcout << cur << ' ' << posans[cur] << ' ' << pos[i] << endl;\n\t\t\tif (posans[cur] > pos[i])\n\t\t\t{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if (posans[cur] == pos[i])\n\t\t\t{\n\t\t\t\tpos[i]++;\n\t\t\t\tcur++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tif (pos[i] < anslen)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nconst int N=1e5+10;\nint n,m,q,num[N],cnt,sum[N],pos[N],a[N];\nbool vis[N];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\ntemplate<typename I>inline I mi(const I &a,const I &b){return a<b ? a : b;}\nint main()\n{\n\t//freopen(\"LRU Puzzle.in\",\"r\",stdin);\n\tread(n,m,q);\n\tfor(RG int i=1;i<=q;i++) read(a[i]);\n\tfor(RG int i=q;i;i--)\n\t if(!vis[a[i]])\n\t {\n\t\tnum[++cnt]=a[i];\n\t\tpos[a[i]]=cnt;\n\t\tvis[a[i]]=1;\n\t }\n\tfor(RG int i=1, cnt2=0;i<=m;i++) if(!vis[i]) num[cnt+(++cnt2)]=i;\n\tsum[0]=n;\n\tfor(RG int i=q;i;i--)\n\t{\n\t\tint tt=pos[a[i]];\n\t\tif(sum[tt-1])\n\t\t{\n\t\t\tsum[tt-1]--;\n\t\t\tsum[tt]++;\n\t\t}\n\t}\n\tint st=n;\n\tfor(RG int i=0;i<=cnt && st==n;i++) if(sum[i]) st=i;\n\tfor(RG int i=st+2;i<=mi(m,cnt+1);i++)\n\t if(num[i]<num[i-1])\n\t {\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t }\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tif(cur == n+1){\n\t\t\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"No\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\nconst ll LINF = (ll)1e18 + 5;\nconst int INF = (int)1e9 + 5;\n\ntemplate<class T>\nT sqr(T x) { return x * x; }\n\ntemplate<class T>\nT abs(T x) { return x < 0 ? -x : x; }\n\ntemplate<class T>\nll round(T x) { return x < 0 ? x - 0.5 : x + 0.5; }\n\ntemplate<class T>\nbool chmin(T & x, const T & y) {\n\tif (y < x) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate<class T>\nbool chmax(T & x, const T & y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\ntemplate<class P, class Q>\nostream & operator <<(ostream & os, const pair<P, Q> & p) {\n\treturn os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const vector<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename vector<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const set<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename set<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const multiset<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename multiset<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class P, class Q>\nostream & operator <<(ostream & os, const map<P, Q> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename map<P, Q>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\n#define all(x) (x).begin(), (x).end()\n\ntemplate<class T>\nT nextInt() {\n\tll x = 0;\n\tbool p = false;\n\tchar c;\n\tdo {\n\t\tc = getchar();\n\t} while (c <= 32);\n\tif (c == '-') {\n\t\tp = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\treturn (p ? -x : x);\n}\n\nset<int> tmp;\nbool myCmp(vector<int> a, vector<int> b) {\n\tif (a.size() > b.size()) swap(a, b);\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\tif (b[i] != a[i]) return false;\n\t}\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\ttmp.erase(a[i]);\n\t}\n\tbool ok = true;\n\tstatic vector<int> erased;\n\terased.resize(0);\n\tfor (int i = (int)a.size(); i < (int)b.size(); i++) {\n\t\tint cur = *tmp.begin(); tmp.erase(tmp.begin());\n\t\terased.push_back(cur);\n\t\tok = ok && (cur == b[i]);\n\t}\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\ttmp.insert(a[i]);\n\t}\n\tfor (int x : erased) {\n\t\ttmp.insert(x);\n\t}\n\treturn ok;\n}\n\nint main() {\n\tsrand(time(0));\n\n#ifdef LOCAL\n\t//gen();\n\tfreopen(\"input.txt\", \"r\", stdin);\n#else\n\t\n#endif\n\n\tint n, m, q;\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\n\tvector<int> a(q);\n\n\tfor (int & x : a) {\n\t\tscanf(\"%d\", &x);\n\t}\n\n\treverse(all(a));\n\n\tmap<int, set<int>> listOfHeight;\n\tvector<vector<int>> cols(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlistOfHeight[cols[i].size()].insert(i);\n\t}\n\n\tmap<int, set<int>> whoNeed;\n\tset<int> was;\n\n\tfor (int x : a) {\n\t\tauto & z = whoNeed[x];\n\t\tif (!z.empty()) {\n\t\t\tint idx = *z.begin(); z.erase(z.begin());\n\t\t\tlistOfHeight[cols[idx].size()].erase(idx);\n\t\t\tcols[idx].push_back(x);\n\t\t\tlistOfHeight[cols[idx].size()].insert(idx);\n\t\t\twas.insert(x);\n\t\t}\n\t\telse {\n\t\t\tif (was.count(x)) continue;\n\t\t\twas.insert(x);\n\t\t\twhile ((--listOfHeight.end())->second.empty()) {\n\t\t\t\tlistOfHeight.erase(--listOfHeight.end());\n\t\t\t}\n\t\t\tint h = (--listOfHeight.end())->first;\n\t\t\tauto & t = listOfHeight[h];\n\t\t\tint idx = *t.begin(); t.erase(t.begin());\n\t\t\tcols[idx].push_back(x);\n\t\t\tlistOfHeight[cols[idx].size()].insert(idx);\n\t\t\tfor (int q : t) {\n\t\t\t\twhoNeed[x].insert(q);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 1; i <= m; i++) {\n\t\ttmp.insert(i);\n\t}\n\n\tbool res = true;\n\tfor (int i = 0; i + 1 < (int)cols.size(); i++) {\n\t\tres = res && myCmp(cols[i], cols[i + 1]);\n\t}\n\n\tputs(res ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nvector<int> ord;\nint markn[N], a[N], cnt[N], pl[N];\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n        a[i]--;\n    }\n    cnt[0] = n;\n    for (int i = q - 1; i >= 0; --i) {\n        if (!markn[a[i]]++) {\n            ord.push_back(a[i]);\n        }\n    }\n    for (int i = 0; i < m; ++i)\n        if (!markn[i]++) {\n            ord.push_back(i);\n        }\n    for (int i = 0; i < m; ++i)\n        pl[ord[i]] = i;\n    for (int i = q - 1; i >= 0; --i) {\n        if (cnt[pl[a[i]]] == 0 && cnt[pl[a[i]] + 1] == 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n        if (cnt[pl[a[i]]] == 0) continue;\n        cnt[pl[a[i]]]--;\n        cnt[pl[a[i]] + 1]++;\n    }\n    int sr = 0;\n    for (int i = m - 2; i >= 0; --i) {\n        if (ord[i + 1] < ord[i]) {\n            sr = i + 1;\n            break;\n        }\n    }\n    for (int i = 0; i < sr; ++i) {\n        if (cnt[i] > 0) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tif (bound[1] < vec[A[i]][idx]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tbound[1] = vec[A[i]][idx];\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tbound[j - 1] = vec[A[i]][idx];\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tputs(Set[order.size() - 1].size() == n - 1 ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> st[100000];\nbool used[100000];\nint idx[100000];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    int a[100000];\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n        st[a[i]].insert(i);\n    }\n    vector<int> ans;\n    for(int i = Q-1; i >= 0; i--){\n        if(!used[a[i]]){\n            ans.push_back(a[i]);\n            used[a[i]] = true;\n        }\n    }\n    for(int i = 0; i < N; i++) idx[i] = -1;\n    for(int i = 0; i < M; i++){\n        if(!used[i]) ans.push_back(i);\n    }\n    // for(int i = 0; i < M; i++) cout << ans[i] << ' ';\n    int last = -1;\n    for(int i = 1; i < M; i++){\n        if(ans[i] < ans[i-1]) last = i-1;\n    }\n    // cout << last << endl;\n    for(int i = 0; i <= last; i++){\n        for(int j = 0; j < N; j++){\n            auto ptr = st[ans[i]].lower_bound(idx[j]);\n            if(ptr == st[ans[i]].end()){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            int m = *ptr;\n            idx[j] = m;\n            st[ans[i]].erase(m);\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define er erase\n#define bg begin()\n#define ed end()\n#define X first\n#define Y second\n#define fin(name) freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define files(name) fin(name\".in\"); fout(name\".out\")\n#define enter cout << \"\\n\"\n#define space cout << \" \"\n#define endl \"\\n\"\n#define fi(st,n) for (int i = (st); i <= (n); ++i)\n#define fj(st,n) for (int j = (st); j <= (n); ++j)\n#define fk(st,n) for (int k = (st); k <= (n); ++k)\n#define fq(st,n) for (int q = (st); q <= (n); ++q)\n#define fw(st,n) for (int w = (st); w <= (n); ++w)\n#define ff(i, st, n) for (int (i) = (st); (i) <= (n); ++(i))\n#define ei(st,n) for (int i = (st); i >= (n); --i)\n#define ej(st,n) for (int j = (st); j >= (n); --j)\n#define ek(st,n) for (int k = (st); k >= (n); --k)\n#define ef(i, st, n) for (int (i) = (st); (i) >= (n); --(i))\n#define ri(st,n) for (int i = (st); i < (n); ++i)\n#define rj(st,n) for (int j = (st); j < (n); ++j)\n#define rk(st,n) for (int k = (st); k < (n); ++k)\n#define rq(st,n) for (int q = (st); q < (n); ++q)\n#define rf(i, st, n) for (int (i) = (st); (i) < (n); ++(i))\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define y1 dsklmlvmd\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int inf = (int)1e9;\nconst dbl eps = (dbl) 1e-8;\nconst int mod = (int) 1000000007;\nconst int maxn = (int) 1e5 + 5;\n//const dbl M_PI = (dbl)2 * (dbl)acos(0);\n\n//cout<<fixed<<setprecision(10);\n//srand(time(0));\n\nint n, m, T, a[maxn], khm, x, y, t[maxn], en[maxn], zp;\nvector <int> vh, vc[maxn];\n\nint main()\n{\n//    fin(\"t.in\");\n    sync;\n    cin >> n >> m;\n    cin >> T;\n    fi(1, T) {\n        cin >> a[i];\n        vc[a[i]].pb(i);\n    }\n    fi(1, n) {\n        en[i] = T;\n    }\n    vh.clear();\n    khm = -1;\n    ei(T, 1) {\n        if (t[a[i]])\n            continue;\n        vh.pb(a[i]);\n        t[a[i]] = i;\n        x = n;\n        ej((int)vc[a[i]].size() - 1, 0) {\n            if (en[x] < vc[a[i]][j]) {\n                continue;\n            }\n            en[x] = vc[a[i]][j] - 1;\n            --x;\n            if (x == 0)\n                break;\n        }\n        if (khm == -1) {\n            ej(x, 1) {\n                en[j] = 0;\n                khm = (int)vh.size() - 1;\n                zp = i;\n            }  \n        }\n    }\n    if (khm != -1) {\n        y = 0;\n//        cout << khm << endl;\n        ri(khm, vh.size()) {\n            ++y;\n            while (t[y] > zp) {\n                ++y;\n            }\n            if (vh[i] != y) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ryan in ny / per jorner fills in: derivative code\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(n);i++)\n#define per(i,a,n) for (int i=(n)-1;i>=(a);i--)\ntypedef long long ll;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    vector<int> v(q);\n    rep(i, 0, q) cin >> v[i], v[i]--;\n    \n    vector<int> waiting(m + 1, 0);\n    waiting[0] = n;\n    vector<int> pos(m, -1);\n    int built = 0;\n    vector<int> order(m, -1);\n    \n    per(i, 0, q) {\n        if (pos[v[i]] != -1) {\n            if (waiting[pos[v[i]]]) {\n                waiting[pos[v[i]]]--;\n                waiting[pos[v[i]] + 1]++;\n            }\n        } else {\n            pos[v[i]] = built;\n            assert(waiting[built]);\n            waiting[built]--;\n            waiting[built + 1]++;\n            order[built] = v[i];\n            built++;\n        }\n    }\n    \n    /*for (auto x : order)cout << x << \" \"; cout << endl;\n    rep(i, 0, m) {\n        cout << order[i] << \": \" << waiting[i] << endl;\n    }*/\n    bool ok = true;\n    per(i, 0, m) {\n        if (order[i] == -1) continue;\n        if (i == m - 1 || order[i + 1] == -1 || order[i] < order[i + 1]) {\n        } else {\n            ok = false;\n        }\n        if (!ok && waiting[i]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > 30000000){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint vis[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    mem(vis, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n\n        vis[a[i]] = 1;\n        if (a[i] == mark) {\n            while (vis[mark] || M[mark] == 0) mark++;\n            ans[n] = i;\n            for (int j = i; j > 0; j = f[j]) flag[j] = 1;\n            continue;\n        }\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) return 0;\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 200 * 1000 + 10;\n\nint a[N];\nint cnt[N];\n\nvector<int> work(int m, vector<int> action) {\n    set<int> all;\n    for (int a : action)\n        all.insert(a);\n    //reverse(action.begin(), action.end());\n    vector<int> res = action;\n    for (int i = 0; i < m; i++)\n        if (all.find(i) == all.end())\n            res.push_back(i);\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector<int> pref;\n    map<int, int> pos;\n    int last = 0;\n    cnt[0] = n;\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n        a[i]--;\n    }\n    for (int i = q - 1; i >= 0; i--) {\n        if (pos.find(a[i]) == pos.end()) {\n            pos[a[i]] = pref.size();\n            cnt[last]--;\n            last++;\n            cnt[last]++;\n            pref.push_back(a[i]);\n        } else {\n            if (cnt[pos[a[i]]] > 0) {\n                cnt[pos[a[i]]]--;\n                cnt[pos[a[i]] + 1]++;\n            }\n        }\n    }    \n    int minP = last;\n    for (int i = 0; i <= last; i++)\n        if (cnt[i]) {\n            minP = i;\n            break;\n        }\n    vector<int> r1 = work(m, pref);\n    pref.resize(minP);\n    vector<int> r2 = work(m, pref);\n    cout << (r1 == r2 ? \"Yes\" : \"No\") << endl;        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tArray a(q);\n\tREP(i, q)cin >> a[i], a[i]--;\n\n\treverse(all(a));\n\tArray cnt(m, 0);\n\tArray pre(m, -1);\n\tll last = -1;\n\n\tREP(i, q) {\n\t\tif (cnt[a[i]] == 0) {\n\t\t\tpre[a[i]] = last;\n\t\t\tlast = a[i];\n\t\t}\n\t\telse {\n\t\t\tif (pre[a[i]] != -1 && cnt[a[i]] < n && cnt[pre[a[i]]] <= cnt[a[i]]) {\n\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcnt[a[i]]++;\n\t}\n\tArray used(m, 0);\n\tArray p;\n\twhile (last != -1)p.push_back(last), used[last]=1,last = pre[last];\n\treverse(all(p));\n\tREP(i, m)if (used[i] == 0)p.push_back(i);\n\tREP(i, m) {\n\t\tif (cnt[p[i]] != n) {\n\t\t\trep(j, i + 1, m) {\n\t\t\t\tif (p[j] < p[j - 1]) {\n\t\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MX = 100 * 1000 + 7;\n\nvector<int> wait[MX];\nint pos[MX];\nvector<int> pattern;\nbool was[MX];\nint a[MX];\nvector<int> full;\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 1; i <= q; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) full.push_back(i);\n    for (int i = q; i >= 1; i--) {\n        int x = a[i];\n        if (was[x]) {\n            if (!wait[x].empty()) {\n                int cpos = wait[x].back();\n                wait[x].pop_back();\n                pos[cpos]++;\n                if (pos[cpos] == (int)pattern.size()) {\n                    full.push_back(cpos);\n                } else {\n                    wait[pattern[pos[cpos]]].push_back(cpos);\n                }\n            }\n        } else {\n            was[x] = true;\n            pattern.push_back(x);\n            for (int cpos : full) {\n                wait[x].push_back(cpos);\n            }\n            full.clear();\n        }\n    }\n    int maxPos = (int)pattern.size() - 1;\n    while (maxPos > 0 && pattern[maxPos - 1] < pattern[maxPos]) maxPos--;\n    bool ok = true;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] < maxPos) ok = false;\n    }\n    if (ok) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (0 <= idx && idx < m) {} else {\n      exit(0);\n    }\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nSometimes I feel like I don't have a partner\nSometimes I feel like my only friend\nIt's the city I live in, the City of Angels\nLonely as I am, together we cry\n\nI drive on her streets 'cause she's my companion\nI walk through her hills cause she knows who I am\nShe sees my good deeds and she kisses me windy\nI never worry, now that is a lie\n\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah\n\nIt's hard to believe that there's nobody out there\nIt's hard believe that I'm all alone\nAt least I have her love the city, she loves me\nLonely as I am, together we cry\n\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, love me I say yeah, yeah\n\nUnder the bridge downtown is where I drew some blood\nUnder the bridge downtown I could not get enough\nUnder the bridge downtown forgot about my love\nUnder the bridge downtown I gave my life away\nYeah, yeah, yeah\n\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, oh, no, no\nI said yea yeah, Ill stay\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 500031;\n\nint n, m, Q;\nint ar[N];\nint last_entry[N];\n\nint whr[N], cnt[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> m >> Q;\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tcin >> ar[i];\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tlast_entry[i] = -i;\n\t}\n\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tlast_entry[ar[i]] = i;\n\t}\n\n\tvector<pair<int,int> > order;\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\torder.push_back(make_pair(last_entry[i], i));\n\t}\n\n\tsort(order.begin(), order.end());\n\treverse(order.begin(), order.end());\n\tfor (int i = 0; i < order.size(); i++)\n\t{\n\t/*\tif (i>0)\n\t\t\tcout << \" \";\n\t\tcout << order[i].second;\n\t*/\twhr[order[i].second] = i;\n\t}\n//\tcout << endl;\n\t\n\tfor (int i = Q; i; --i)\n\t{\n\t\tint val = ar[i];\n\t\tint ps = whr[val];\n\t\tif (ps > 0 && cnt[ps - 1] == 0)\n\t\t{\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcnt[ps]++;\n\t\tif (ps > 0 && cnt[ps] > cnt[ps - 1])\n\t\t\tcnt[ps]--;\n\t}\n\n\tint q = m - 1;\n\twhile (q > 0 && order[q].second > order[q - 1].second)\n\t\t--q;\n\n\tif (q == 0 || cnt[q-1] >= n)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nSometimes I feel like I don't have a partner\nSometimes I feel like my only friend\nIt's the city I live in, the City of Angels\nLonely as I am, together we cry\n\nI drive on her streets 'cause she's my companion\nI walk through her hills cause she knows who I am\nShe sees my good deeds and she kisses me windy\nI never worry, now that is a lie\n\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nI dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah\n\nIt's hard to believe that there's nobody out there\nIt's hard believe that I'm all alone\nAt least I have her love the city, she loves me\nLonely as I am, together we cry\n\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nAnd I dont ever wanna feel like I did that day\nTake me to the place I love, take me all the way\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, love me I say yeah, yeah\n\nUnder the bridge downtown is where I drew some blood\nUnder the bridge downtown I could not get enough\nUnder the bridge downtown forgot about my love\nUnder the bridge downtown I gave my life away\nYeah, yeah, yeah\n\nYeah, yeah, yeah, oh, no, no, no\nYeah, yeah, oh, no, no\nI said yea yeah, Ill stay\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 500031;\n\nint n, m, Q;\nint ar[N];\nint last_entry[N];\n\nint whr[N], cnt[N];\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> m >> Q;\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tcin >> ar[i];\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tlast_entry[i] = -i;\n\t}\n\n\tfor (int i = 1; i <= Q; i++)\n\t{\n\t\tlast_entry[ar[i]] = i;\n\t}\n\n\tvector<pair<int,int> > order;\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\torder.push_back(make_pair(last_entry[i], i));\n\t}\n\n\tsort(order.begin(), order.end());\n\treverse(order.begin(), order.end());\n\t/*for (int i = 0; i < order.size(); i++)\n\t{\n\t\tif (i>0)\n\t\t\tcout << \" \";\n\t\tcout << order[i].second;\n\t\twhr[order[i].second] = i;\n\t}\n\tcout << endl;\n\t*/\n\tfor (int i = Q; i; --i)\n\t{\n\t\tint val = ar[i];\n\t\tint ps = whr[val];\n\t\tif (ps > 0 && cnt[ps - 1] == 0)\n\t\t{\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcnt[ps]++;\n\t\tif (ps > 0 && cnt[ps] > cnt[ps - 1])\n\t\t\tcnt[ps]--;\n\t}\n\n\tint q = m - 1;\n\twhile (q > 0 && order[q].second > order[q - 1].second)\n\t\t--q;\n\n\tif (q == 0 || cnt[q-1] >= n)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    int st = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                if(arr[i] != mn) ok = false;\n                for(int k = j; k >= st; k--) pnt[k] = -1;\n                st = j + 1;\n                break;\n            }\n            pnt[j] = Pos[arr[i]][pos];\n        }\n        if(!ok) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, int> PLDI;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nconst LL MOD = 1e9+7;\nconst LL INF = (1e18);\nconst double EPS=1.0e-9;\nconst double PI=atan2(0,-1);\n\n\n\nint main()\n{\n    int n,m,q;\n    cin>>n>>m>>q;\n    vector<int> a(q);\n    REP(i,q)\n        cin>>a[i];\n    \n    bool used[100001];\n    vector<int> b;\n    CLR(used);\n    b.reserve(q);\n    for(int i=q-1;i>=0;i--)\n    {\n        if(!used[a[i]])\n            b.push_back(a[i]);\n    }\n    REP(i,m)\n    {\n        if(!used[i+1])\n            b.push_back(i+1);\n    }\n    vector<int> c(m+1);\n    REP(i,m)\n        c[b[i]]=i+1;\n    \n    bool flag=1;\n    vector<int> d(m+2);\n    d[0]=n;\n    for(int i=q-1;i>=0;i--)\n    {\n        d[c[a[i]]-1]--;\n        if(d[c[a[i]]-1]<0)\n        {\n            flag=0;\n            break;\n        }\n        d[c[a[i]]]++;\n    }\n    \n    CLR(used);\n    //used[0]=1;\n        int k=1;\n    REP(i,m+2)\n    {\n        if(d[i]==0)continue;\n        \n        for(int j=0;j<i;j++)\n            used[b[j]]=1;\n        \n        FOR(j,i,m)\n        {\n            if(used[k])\n            {\n                k++; j--;\n                continue;\n            }\n            if(k!=b[j])\n            {\n                flag=0;\n                break;\n            }\n            k++;\n        }\n        \n        break;\n    }\n    \n    if(flag)\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\nint n, m, q, a[100009], b[100009], c[100009], d[100009]; vector<int>Z; bool used[100009], OK = true;\nint main() {\n\tcin >> n >> m >> q; for (int i = 1; i <= q; i++)cin >> a[i], a[i]--;\n\tfor (int i = q; i >= 1; i--) { if (used[a[i]] == false) { used[a[i]] = true; Z.push_back(a[i]); } }\n\tif (Z[Z.size() - 1] == 0) { assert(false); }\n\tfor (int i = 0; i < Z.size(); i++) { if (Z[i] != i)OK = false; b[Z[i]] = i; }\n\tif (OK == true) { cout << \"Yes\" << endl; return 0; }\n\tif (n*Z.size() > q) { cout << \"No\" << endl; return 0; }\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = b[a[i]];\n\t\tif (c[num] == n || d[c[num]] < num)continue;\n\t\td[c[num]]++; c[num]++;\n\t}\n\tfor (int i = 0; i < n; i++) { if (d[i] != n)OK = true; }\n\tif (OK == true)cout << \"No\" << endl; else cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N, M, Q;\nvector<int> as;\nvector<int> vs[114514];\nvector<int> needs[114514];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int q;\n    cin >> q;\n    as.eb(q);\n  }\n\n  reps(i, 1, N) needs[0].eb(i);\n\n  rrep(i, Q) {\n    int t = as[i];\n    if (needs[t].empty()) {\n      vs[0].eb(t);\n      needs[t].swap(needs[0]);\n    } else {\n      int idx = needs[t].back(); needs[t].pop_back();\n      vs[idx].eb(t);\n      assert(vs[0].size() >= vs[idx].size());\n      if (vs[0].size() == vs[idx].size()) needs[0].eb(idx);\n      else needs[vs[0][vs[idx].size()]].eb(idx);\n    }\n  }\n\n  int m = vs[0].size();\n  int incr = 0;\n  set<int> st;\n  rep(i, M) st.insert(i+1);\n  rep(i, m) {\n    int v = vs[0][i];\n    if (st.count(v)) {\n      if (v != *st.begin()) incr = i+1;\n      st.erase(v);\n    }\n  }\n\n  reps(i, 1, N) {\n    if (incr > vs[i].size()) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int L=1e5+10;\nvector<int> pos[L];\nint lb[L];\nbool done[L];\nint main() {\n\tint N,M,Q;\n\tcin >> N >> M >> Q;\n\tvector<int> as;\n\tfor(int i=0;i<Q;i++){\n\t\tint a;\n\t\tcin >> a;\n\t\tpos[a].push_back(Q-1-i);\n\t\tas.push_back(a);\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\treverse(pos[i].begin(),pos[i].end());\n\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tlb[i]=i;\n\t}\n\treverse(as.begin(),as.end());\n\tdone[0]=true;\n\tint c=0;\n\n\tbool breaked=false;\n\tfor(int i=0;i<Q;i++){\n\t\tint a=as[i];\n\t\tif(done[a])continue;\n\t\tdone[a]=true;\n\t\tif(!breaked){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tauto it=lower_bound(pos[a].begin(),pos[a].end(),lb[j]);\n\t\t\t\tif(it==pos[a].end()){\n\t\t\t\t\tbreaked=true;\n\t\t\t\t\t//cerr << \"bbb \" << i << \", \" << j << \", \" << lb[j] << \": \" << a << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//cerr << lb[j] << \", \" << *it << endl;\n\t\t\t\tlb[j]=*it;\n\t\t\t\tlb[j+1]=max(lb[j+1],lb[j]+1);\n\t\t\t}\n\t\t}\n\t\tif(breaked){\n\t\t\twhile(c<a){\n\t\t\t\tif(!done[c]){\n\t\t\t\t\tcout << \"No\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Yes\" << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,...) for(auto&& i:__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\n\nsigned main(){\n    LL(n,m,q);\n    VEC(ll,a,q);\n    Rev(a);\n    vector<pll>b;\n    b.emplace_back(0,n);\n    unordered_map<ll,ll>index;\n    each(i,a){\n        if(!index.count(i)){\n            index[i]=b.size();\n            b.emplace_back(i,1);\n        }\n        else{\n            ll j=index[i];\n            if(b[j-1].second>b[j].second)b[j].second++;\n        }\n    }\n    rep(i,1,m+1)if(!index.count(i)){\n        index[i]=b.size();\n        b.emplace_back(i,0);\n    }\n    ll at=m;\n    rrep(i,1,m+1)if(b[index[i]].second<n){\n        if(index[i]!=at--)return No();\n    }\n    Yes();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N, M, Q;\nint a[MAXN];\nstack <int> occ[MAXN], pos[MAXN];\nset <int> S;\n\nvoid load() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; i++)\n\t\tscanf(\"%d\", a + i);\n}\n\nbool solve() {\n\tfor (int i = 0; i < Q; i++)\n\t\tocc[a[i]].push(i);\n\t\n\tfor (int i = 1; i <= M; i++)\n\t\tS.insert(i);\n\t\n\tfor (int i = 0; i < N; i++)\n\t\tpos[i].push(Q);\n\t\n\tbool ok = true;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (!S.count(a[i])) continue;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\twhile (!occ[a[i]].empty() && occ[a[i]].top() >= pos[j].top())\n\t\t\t\tocc[a[i]].pop();\n\t\t\tif (occ[a[i]].empty()) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos[j].push(occ[a[i]].top());\n\t\t\tocc[a[i]].pop();\n\t\t}\n\t\tif (!ok && a[i] != *S.begin()) \n\t\t\treturn false;\n\t\tS.erase(a[i]);\n\t}\n\t\n\treturn true;\n}\n\nint main() {\n\tload();\n\tputs(solve() ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define N 123456\n\nint n, m, q, a[N];\nint s[N], pos[N], arr[N], cnt[N], put;\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfo(i,0,q) scanf(\"%d\", a+i);\n\treverse(a, a+q);\n\n\tcnt[0] = n;\n\tfo(i,0,q) {\n\t\tint at = a[i];\n\t\tif (!s[at]) {\n\t\t\ts[at] = 1;\n\t\t\tpos[at] = ++put;\n\t\t\tarr[pos[at]] = at;\n\t\t\tcnt[pos[at]]++;\n\t\t\tcnt[pos[at]-1]--;\n\t\t} else {\n\t\t\tif (cnt[pos[at]-1]==0) continue;\n\t\t\tcnt[pos[at]-1]--;\n\t\t\tcnt[pos[at]]++;\n\t\t}\n\t}\n\tint ut = 1;\n\tfo(i,0,put-1) {\n\t\tif (arr[i+1] == ut) {\n\t\t\tcnt[i+1] += cnt[i];\n\t\t\tcnt[i] = 0;\n\t\t\tut++;\n\t\t}\n\t\tif (cnt[i]) puts(\"NO\"), exit(0);\n\t}\n\tputs(\"YES\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nvoid RE(){\n    RE();\n    RE();\n}\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                RE();\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=n-1;\n\tfor(;t>0;t--){\n\t\tif(v[t]<v[t-1]) break;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tint hi=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\thi=max(hi,pos[a[i]]+1);\n\t\t\t//while(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(hi<pos[a[i]]){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size()) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && pos[last] < firstFail) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\twhile (last < m) {\n\t\t\t\tif (was[last] && pos[last] < firstFail)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\n\nbool vis[N];\nint n,m,q,a[N],cnt[N],p[N];\nvi order;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m >> q;\n    forn(i,q) cin >> a[i], a[i]--;\n    dforsn(i,0,q) if (!vis[a[i]]) {\n        order.pb(a[i]);\n        vis[a[i]] = true;\n    }\n    m = si(order);\n    //forn(i,m) if (!vis[i]) order.pb(i);\n    forn(i,si(order)) p[order[i]] = i;\n\n    bool ok = true;\n    cnt[0] = n;\n    dforsn(i,0,q) {\n        int pos = p[a[i]];\n        if (cnt[pos]) {\n            cnt[pos]--;\n            cnt[pos+1]++;\n        }\n        else if (cnt[pos+1] || cnt[si(order)]);\n        else ok = false;\n    }\n\n    int least;\n    forn(i,N) if (cnt[i]) {\n        least = i;\n        break;\n    }\n\n    vi norder;\n    memset(vis,0,sizeof vis);\n    forn(i,least) {\n        norder.pb(order[i]);\n        vis[order[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) norder.pb(i);\n    \n    ok &= norder == order;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tint n=read(),m=read(),q=read();\n\tvi a(q);\n\tREP(i,q)\n\t\ta[i]=read()-1;\n\tvector<vi> pos(m);\n\tfor(int i=q-1;i>=0;i--){\n\t\tpos[a[i]].PB(i);\n\t}\n\tvi use(n,114514);\n\tpriority_queue<int,vi,greater<int>> expect;\n\tREP(i,m)\n\t\texpect.push(i);\n\tvector<bool> used(m,false);\n\tfor(int i=q-1;i>=0;i--){\n\t\tbool ok=true;\n\t\tint v=a[i];\n\t\tif(!pos[v].empty()){\n\t\t\tif((int)pos[v].size()<n){\n\t\t\t\tok=false;\n\t\t\t\tgoto END;\n\t\t\t}else{\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(use[j]<pos[v][j]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto END;\n\t\t\t\t\t}else\n\t\t\t\t\t\tuse[j]=pos[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos[v].clear();\n\t\t\tused[v]=true;\n\t\t}\n\t\tEND:;\n\t\tif(!ok){\n\t\t\tfor(int j=q-1;j>=0;j--){\n\t\t\t\tif(!used[a[j]]){\n\t\t\t\t\tused[a[j]]=true;\n\t\t\t\t\tif(expect.top()==a[j]){\n\t\t\t\t\t\texpect.pop();\n\t\t\t\t\t}else\n\t\t\t\t\t\tNo();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tYes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nvector<int> t,co;\nint dp[MAX];\nint cz[MAX];\nint il = 0;\nint kt[MAX];\nint n,m,q;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    int pom;\n    cin >> pom;\n    pom--;\n    t.PB(pom);\n  }\n  reverse(ALL(t));\n  for(int el:t){\n    if(!cz[el]){\n      cz[el] = 1;\n      kt[el] = il;\n      il++;\n      co.PB(el);\n    }\n    int pom = kt[el];\n    dp[pom]++;\n    if(pom != 0)\n      mini(dp[pom],dp[pom-1]);\n  }\n  int naj = 0;\n  while(cz[naj])naj++;\n  debug(naj);\n  if(naj > co.back()){\n    while(il != 1 && co[il-1] > co[il-2])\n      il--;\n    if(il == 1 && co[0] == 0)il = 0;\n  }\n  debug(il);\n  if(il == 0 || dp[il-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nbool okalone(int num,int I){\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                if(arr[i] != mn) ok = false;\n                break;\n            }\n            pnt[j] = pos--;\n        }\n        if(!ok) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\n\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t}\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0)return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n\tputs(chk()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tint n=read(),m=read(),q=read();\n\tvi a(q);\n\tREP(i,q)\n\t\ta[i]=read()-1;\n\tvector<vi> pos(m);\n\tfor(int i=q-1;i>=0;i--){\n\t\tpos[a[i]].PB(i);\n\t}\n\tvi use(n,114514);\n\tset<int> expect;\n\tREP(i,m)\n\t\texpect.insert(i);\n\tfor(int i=q-1;i>=0;i--){\n\t\tbool ok=true;\n\t\tint v=a[i];\n\t\tif(!pos[v].empty()){\n\t\t\tif((int)pos[v].size()<n){\n\t\t\t\tok=false;\n\t\t\t\tgoto END;\n\t\t\t}else{\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(use[j]<pos[v][j]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto END;\n\t\t\t\t\t}else\n\t\t\t\t\t\tuse[j]=pos[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos[v].clear();\n\t\t\texpect.erase(v);\n\t\t}\n\t\tEND:;\n\t\tif(!ok){\n\t\t\tint cov=n;\n\t\t\tfor(int j=q-1;j>=0;j--){\n\t\t\t\tif(!pos[a[j]].empty()){\n\t\t\t\t\tif(*expect.begin()==a[j]&&(int)pos[a[j]].size()<=cov){\n\t\t\t\t\t\texpect.erase(expect.begin());\n\t\t\t\t\t\tcov=pos[a[j]].size();\n\t\t\t\t\t}else\n\t\t\t\t\t\tNo();\n\t\t\t\t\tpos[a[j]].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tYes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n\nsigned main(){\n    int n, m;\n    cin >> m >> n;\n    int q;\n    cin >> q;\n    vector<int> a(q);\n    for(auto& x : a){\n        cin >> x;\n        --x;\n    }\n\n    auto rev = a;\n    reverse(rev.begin(), rev.end());\n    for(int i = 0; i < n; ++i)\n        rev.emplace_back(i);\n    unordered_set<int> s;\n    vector<int> final;\n    for(auto& x : rev)\n        if(s.find(x) == s.end()){\n            s.insert(x);\n            final.emplace_back(x);\n        }\n    rev.resize(rev.size() - n);\n\n    vector<int> inv(n);\n    for(int i = 0; i < n; ++i)\n        inv[final[i]] = i;\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = m;\n    for(auto& x : rev){\n        --dp[inv[x]];\n        ++dp[inv[x] + 1];\n    }\n\n    int c;\n    int ma = MOD;\n    for(c = n - 1; c >= 0; --c){\n        if(ma < final[c])\n            break;\n        ma = final[c];\n    }\n    c++;\n    /*\n    cout << c << endl;\n\n    for(int i = 0; i < n; ++i)\n        cout << final[i] + 1 << \" \\n\"[i == n - 1];\n\n    for(int i = 0; i <= n; ++i)\n        cout << dp[i] << \" \\n\"[i == n];\n        */\n\n    cout << (accumulate(next(dp.begin(), c), dp.end(), 0) == m ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    int n,m,q;cin>>n>>m>>q;\n    int a[q];\n    rep(i,0,q)cin>>a[i];\n    int num[m+1];\n    fill(num,num+m+1,-1);\n    int now[m+1];\n    fill(now,now+m+1,-1);\n    now[0]=0;\n    int len[n];\n    fill(len,len+n,0);\n    rrep(i,q-1,0){\n        //rep(ii,0,2)cout<<len[ii]<<\" \";\n        //cout<<endl;\n        if(num[a[i]]==-1){\n            num[a[i]]=len[0];\n            len[0]++;\n            \n        }\n        else{\n            int u=n,d=-1;\n            int y=num[a[i]];\n            while(u-d>1){\n                int mid=(u+d)/2;\n                if(len[mid]<=y)u=mid;\n                else d=mid;\n            }\n            //cout<<y<<endl;\n            if(u==n)continue;\n            if(len[u]==y){\n                len[u]++;\n            }\n            \n        }\n    }\n    //rep(i,0,2)cout<<len[i]<<endl;\n    int le=len[0];\n    int le2=len[n-1];\n    set<int> st;\n    int ka[m+1];\n    fill(ka,ka+m+1,-1);\n    rep(i,1,m+1){\n        if(num[i]>=0)ka[num[i]]=i;\n    }\n    //rep(i,0,3)cout<<ka[i]<<\" \";\n    //cout<<endl;\n    rep(i,1,m+1)st.insert(i);\n    rep(i,0,le2)st.erase(ka[i]);\n    rep(i,le2,le){\n        int u=ka[i];\n        int uu=*st.begin();\n        //cout<<u<<\" \"<<uu<<endl;\n        if(u!=uu){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        st.erase(st.begin());\n    }\n    cout<<\"Yes\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q);\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    if ((temp != 1) || (temp == counter)){\n      minw = min(minw, (int)amc[temp].size()); \n    }\n    for (int i = 0; i < amc[temp].size(); i++){\n      used[amc[temp][i]] = 1;\n    }\n    amc.erase(temp);\n    while(used[tempindex] == 1){\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == i+1){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, b) for(int i = 0; i < b; i++)\n#define repi(i, a, b) for(int i = a; i < b; i++)\n#define all(c) c.begin(),c.end()\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define MAX_V 1001\n#define MAX_E 401\n#define INF INT_MAX\n#define MOD 1000000007\n#define EPS 1e-7\ntypedef long long ll;\ninline int toInt(std::string s) { int v; std::istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline std::string toString(T x) { std::ostringstream sout; sout << x; return sout.str(); }\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\n#define X real()\n#define Y imag()\ntypedef pair<int, int> pii;\n\n\nstruct Data{\n\tint r, c;\n\tll a;\n};\n\n/*\nint main()\n{\n\tll ans = 0;\n\tint R, C;\n\tint N;\n\tcin >> R >> C >> N;\n\tvector<Data> m(N);\n\tmap<pii, ll> mp;\n\trep(i, N)\n\t{\n\t\tcin >> m[i].r >> m[i].c >> m[i].a;\n\t\tmp[make_pair(m[i].r, m[i].c)] = m[i].a;\n\t}\n\trep(i, N)\n\t{\n\t\trepi(j, -1, 2)\n\t\t{\n\t\t\tif (j == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trepi(k, -1, 2)\n\t\t\t{\n\t\t\t\tif (m[i].r == 0 || m[i].r == R + 1 || m[i].c == 0 || m[i].c == C + 1)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (k == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto itr = mp.find(make_pair(m[i].r + j, m[i].c + k));\n\t\t\t\tif (itr != mp.end())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}*/\n\nint main()\n{\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\nint nodelen;\n\nint bit[111111];\nint lowbit(int x){\n\treturn x&-x;\n}\nvoid add(int x){\n\twhile(x <= M){\n\t\tbit[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint query(int x){\n\tint r=0;\n\twhile(x){\n\t\tr+=bit[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn r;\n}\n\nbool chk2(){\n\tif(node[head].next == -1)return true;\n\tint start = node[node[head].next].val;\n\tint end = node[tail].val;\n\treturn end - start + 1 == nodelen + query(end) - query(start+1);\n}\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tnodelen = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t\t\n\t\t\tnodelen++;\n\t\t}\n\n\tmemset(bit,0,sizeof(bit));\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0 && chk2())return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\tLST[ct] = pos[x][j];\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\tif(tail == p)\n\t\t\ttail = prev_pnt;\n\t\tnodelen--;\n\t\tadd(x);\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n\tputs(chk()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tvector<ll> not_comp;\n\tREP(i, m) if(!dict.count(i) || dict[i] != n) not_comp.pb(i);\n\tsort(ALL(not_comp));\n\tll tmp = 0;\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(idx[i] != not_comp[tmp]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = m; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= m ){\n\tassert( ss[ v[i] ].find( i-m ) != ss[ v[i] ].end() );\n\tss[ v[i] ].erase( ss[ v[i] ].find( i-m ) );\n      }\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( t * n  > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      cur = *ite;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    reverse(ALL(b));\n    while(SZ(b)&&b.back()==1)\n        b.pop_back();\n    reverse(ALL(b));\n    q=SZ(b);\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=m;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, M, Q;\nint A[100011];\nint cnt[100011];\nint rnk[100011];\nint len[100011];\nVI ord;\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &M, &Q);\n    REP (i, Q) scanf(\"%d\", A+i), A[i]--;;\n\n    for (int i=Q; i--;) {\n\tint v = A[i];\n\tif (cnt[v] == 0) {\n\t    rnk[v] = ord.size();\n\t    ord.push_back(v);\n\t    len[0]++;\n\t} else if (cnt[v] < N && len[cnt[v]] == rnk[v]) {\n\t    len[cnt[v]]++;\n\t}\n\tcnt[v]++; \n    }\n\n    REP (i, M) if (cnt[i] == 0) ord.push_back(i);\n    bool yes = true;\n    for (int i=len[N-1]; i<M-1; i++) if (ord[i] > ord[i+1]) yes = false;\n    puts(yes? \"Yes\": \"No\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size()) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\nint nebitan[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0 && Poz[br].size(); ) {\n    if (Poz[br].back() < V[ind]) {\n      R.push_back(Poz[br].back());\n      ind--;\n    }\n    Poz[br].pop_back();\n  }\n\n  if (ind >= 0)\n    Nope();\n\n  reverse(R.begin(), R.end());\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  vector <int> Por;\n  for (int i=q-1; i>=0; i--) {\n    if (bio[p[i]]++)\n      continue;\n\n    Por.push_back(p[i]);\n  }\n\n  for (int i=(int) Por.size()-1; i>=0; i--) {\n    if (i != (int) Por.size() - 1 && Por[i] > Por[i+1])\n      break;\n\n    int da = 1;\n    int poc = (i == (int) Por.size() - 1) ? 1 : Por[i+1];\n    for (int j=poc; j<Por[i]; j++)\n      if (!bio[j])\n        da = 0;\n\n    if (!da)\n      break;\n\n    nebitan[Por[i]] = 1;\n  }\n\n  memset(bio, 0, sizeof bio);\n\n  for (int i=q-1; i>=0; i--) {\n    if (bio[p[i]]++)\n      continue;\n\n    if (nebitan[p[i]])\n      continue;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\n\nint main(){\n\tint N, M, Q;\n\tbool ans=false;\n\n\tcin >> N >> M >> Q;\n\tvector<int> s;\n\tvector<int> a(Q);\n\trep(i,Q){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\treverse( all(a) );\n\n\tmap<int,int> mp;\n\tint max_num=0;\n\tint cnt[100005]={};\n\trep(i,Q){\n\t\tif( !mp.count(a[i]) ){\n\t\t\tmp[ a[i] ] = s.size();\n\t\t\ts.push_back(a[i]);\n\t\t}\n\t\tint num = mp[ a[i] ];\n\t\tif( num == 0 || cnt[num-1] > cnt[num] ){\n\t\t\tcnt[num]++;\n\t\t}\n\t}\n\n\tmap<int,int> m;\n\tmax_num = 0;\n\trep(i, s.size()){\n\t\tm[ s[i] ] = i;\n\t\tif( cnt[i] >= N || s[i] == max_num ){\n\t\t\tans = true;\n\t\t}else{\n\t\t\tans = false;\n\t\t\tbreak;\n\t\t}\n\t\twhile( m.count(max_num) ) max_num++;\n\t}\n\n\tcout << (ans?\"Yes\":\"No\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    auto A = readVec<int>(Q);\n    for (auto& a : A) { a--; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M; i++) { L[i].push_back(M - i - 1); }\n    for (int i = 0; i < Q; i++) { L[A[i]].push_back(i + M); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, Q + M);\n    for (const auto& o : op) {\n        if (pos[0] < L[o].back()) { return std::cout << \"No\" << std::endl, 0; }\n        for (int i = 0; i < N; i++) {\n            while (pos[i] < L[o].back()) {\n                if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                L[o].pop_back();\n            }\n            pos[i] = L[o].back();\n            if (L[o].size() > 1) { L[o].pop_back(); }\n            //            if (pos[i] < M) { break; }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i,x,n) for (int i = x;i < n;++i)\n\nvector<int> v[100000], V;\nint l[100001], x[100000];\n\nvoid NO() {\n\tprintf(\"No\\n\");\n\texit(0);\n}\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tf(i, 0, q)scanf(\"%d\", x + i);\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint d = l[x[i]];\n\t\tif (d == n)continue;\n\t\tif (!d)V.push_back(x[i]);\n\t\tv[l[x[i]]].push_back(x[i]);\n\t\t++l[x[i]];\n\t}\n\tint i = V.size();\n\tint j = 1;\n\twhile (l[j])++j;\n\tfor (--j; j > 0 && i; --j)if (V[i - 1] == j)--i;\n\tf(j, 0, n)f(k, 0, i) {\n\t\tint t = v[j].size();\n\t\tif (k >= t && k < i)NO();\n\t\telse if (k < t && v[j][k] != V[k])NO();\n\t}\n\tprintf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    int st = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= st; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                st = j + 1;\n                ok = false;\n                break;\n            }\n            pnt[j] = pos--;\n        }\n        if(!ok) {\n            if(arr[i] != mn) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1;cin>>n>>m>>q;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tif(ban[i]==0){continue;}//skipped\n\t\tint no=ban[i];\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t\tban[numlis[no][j]]=0;\n\t\t}\n\t\tif(numlis[no].size()<n){if(zyu!=no){cout<<\"No\"<<endl;return 0;}else{zyu++;}}\n\t\tfor(j=numlis[no].size();j<n;j++){las[j]=i-q;}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i,x,n) for (int i = x;i < n;++i)\n\nvector<int> v[100000], V;\nint l[100001], x[100000];\n\nvoid NO() {\n\tprintf(\"No\\n\");\n\texit(0);\n}\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tf(i, 0, q)scanf(\"%d\", x + i);\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint d = l[x[i]];\n\t\tif (d == n)continue;\n\t\tif (!d)V.push_back(x[i]);\n\t\tv[l[x[i]]].push_back(x[i]);\n\t\t++l[x[i]];\n\t}\n\tint i = V.size();\n\tint j = 1;\n\twhile (l[j])++j;\n\tfor (--j; j > 0 && i; --j)if (V[i - 1] == j)--i;\n\tf(j, 0, n)f(k, 0, V.size()) {\n\t\tif (k >= v[j].size()) {\n\t\t\tif (k < i)NO();\n\t\t\tbreak;\n\t\t}\n\t\tif (v[j][k] != V[k])NO();\n\t}\n\tprintf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool allappeared[100050];\nint a[100050];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    allappeared[0] = true;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared[a[i] - 1]) allappeared[a[i]] = true;\n    }\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    /*\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        cerr << val[i] << endl;\n    }\n    */\n    num[0] = N;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], num[nowindex-1]);\n        /*\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        */\n    }\n    for(int i = 1; i <= index; i++) {\n        if(num[i] != N) {\n            cout << \"No\" << endl;\n            return 1;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nvoid mainmain(){\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvint as(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tscanf(\"%d\", &as[i]);\n\t\t--as[i];\n\t}\n\n\tvint vis(m);\n\tvector<int> seq;\n\tfor(int i = q; i--; ){\n\t\tif(!vis[as[i]]){\n\t\t\tvis[as[i]] = 1;\n\t\t\tseq.push_back(as[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){ seq.push_back(i); }\n\t}\n\tvint rtbl(m);\n\tfor(int i = 0; i < m; ++i){\n\t\trtbl[seq[i]] = i;\n\t}\n\n\tvint idx(m + 1);\n\tidx[0] = n;\n\tfor(int i = q; i--; ){\n\t\tint x = rtbl[as[i]];\n\t\tif(idx[x] > 0){\n\t\t\t--idx[x];\n\t\t\t++idx[x];\n\t\t}\n\t}\n\n\tint minidx;\n\tfor(minidx = 0; !idx[minidx]; ++minidx);\n\tvis.assign(m, 0);\n\tvint seq2;\n\tfor(int i = 0; i < minidx; ++i){\n\t\tseq2.push_back(seq[i]);\n\t\tvis[seq[i]] = 1;\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){\n\t\t\tseq2.push_back(i);\n\t\t}\n\t}\n\n\tputs(seq == seq2 ? \"Yes\" : \"No\");\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\nint nodelen;\n\nint bit[111111];\nint lowbit(int x){\n\treturn x&-x;\n}\nvoid add(int x){\n\twhile(x <= M){\n\t\tbit[x]++;\n\t\tx+=lowbit(x);\n\t}\n}\nint query(int x){\n\tint r=0;\n\twhile(x){\n\t\tr+=bit[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn r;\n}\n\nbool chk2(){\n\tif(node[head].next == -1)return true;\n\tint start = node[node[head].next].val;\n\tint end = node[tail].val;\n\treturn end - start + 1 == nodelen + query(end) - query(start-1);\n}\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tnodelen = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t\t\n\t\t\tnodelen++;\n\t\t}\n\n\tmemset(bit,0,sizeof(bit));\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0 && chk2())return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\tLST[ct] = pos[x][j];\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\tif(tail == p)\n\t\t\ttail = prev_pnt;\n\t\tnodelen--;\n\t\tadd(x);\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n\tputs(chk()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tbool force = false ;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tbool no = false ;\t\t\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tno = true;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tno = true;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t\tif (no) {\n\t\t\tforce = true;\n\t\t}\n\t\tif (force) {\n\t\t\tif (id == A[i]) {\n\t\t\t\twhile (vis[id]) ++id;\n\t\t\t\tcontinue ;\n\t\t\t} else {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tif(!vis[1]) return !puts(\"No\");\t\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t}\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m, -1);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0 && Poz[br].size(); ) {\n    if (Poz[br].back() < V[ind]) {\n      R.push_back(Poz[br].back());\n      ind--;\n    }\n    Poz[br].pop_back();\n  }\n\n  if (ind >= 0)\n    Nope();\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  int tmin = 1;\n  for (int i=q-1; i>=0; i--) {\n    for (; bio[tmin]; tmin++);\n\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] == tmin)\n      continue;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = n - 1;\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && Set[pos[last]].size() == 0) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos)\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tint n=read(),m=read(),q=read();\n\tvi a(q);\n\tREP(i,q)\n\t\ta[i]=read()-1;\n\tvector<vi> pos(m);\n\tfor(int i=q-1;i>=0;i--){\n\t\tpos[a[i]].PB(i);\n\t}\n\tvi use(n,114514);\n\tset<int> expect;\n\tREP(i,m)\n\t\texpect.insert(i);\n\tvector<bool> used(m,false);\n\tfor(int i=q-1;i>=0;i--){\n\t\tbool ok=true;\n\t\tint v=a[i];\n\t\tif(!pos[v].empty()){\n\t\t\tif((int)pos[v].size()<n){\n\t\t\t\tok=false;\n\t\t\t\tgoto END;\n\t\t\t}else{\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(use[j]<pos[v][j]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto END;\n\t\t\t\t\t}else\n\t\t\t\t\t\tuse[j]=pos[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos[v].clear();\n\t\t\tused[v]=true;\n\t\t\texpect.erase(v);\n\t\t}\n\t\tEND:;\n\t\tif(!ok){\n\t\t\tfor(int j=q-1;j>=0;j--){\n\t\t\t\tif(!used[a[j]]){\n\t\t\t\t\tused[a[j]]=true;\n\t\t\t\t\tif(*expect.begin()==a[j]){\n\t\t\t\t\t\texpect.erase(expect.begin());\n\t\t\t\t\t}else\n\t\t\t\t\t\tNo();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tYes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(i != 0 && cnt[i - 1] != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(false);\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) ok = false;\n            pnt[j] = pos;\n            if(pos >= 0) pos--;\n        }\n        if(!ok) {\n            if(arr[i] != mn) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m,q;\n    static int s[1 << 20];\n    fi>>n>>m>>q;\n    for (int i = 1;i <= q;++i)\n        fi>>s[i];\n    vector < int > S;\n    static int was[1 << 20];\n    for (int i = 1;i <= m;++i)\n        was[i] = -1;\n    for (int i = q;i;--i)\n        if (was[s[i]] == -1)\n            S.push_back(s[i]),was[s[i]] = 1;\n    static int cnt[1 << 20];\n    for (int i = 1;i <= m;++i)\n        if (was[i] == -1)\n            S.push_back(i);\n    static int where[1 << 20];\n    for (int i = 0;i < m;++i)\n        where[S[i]] = i + 1;\n    cnt[0] = n;\n    for (int i = q;i;--i)\n    {\n        const int index = where[s[i]] - 1;\n        if (cnt[index])\n            --cnt[index],++cnt[index + 1];\n    }\n    int Last = 0;\n    for (int i = m - 1;i;--i)\n        if (S[i] < S[i - 1])\n            {Last = i;break;}\n    int ok = 1;\n    for (int i = 0;i < Last;++i)\n        ok &= !cnt[i];\n    fo << (ok ? \"Yes\" : \"No\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N,M,Q,a[100000],tree[1<<18];\nbool b[100001];\nset<pair<int,int>>st;\nvector<int>v;\n\nvoid add(int x,int t){\n\tx+=(1<<17);\n\twhile(x){\n\t\ttree[x]+=t;\n\t\tx/=2;\n\t}\n}\n\nint calc(int p,int q,int l,int r,int k){\n\tif(r<p||q<l)return 0;\n\tif(p<=l&&r<=q)return tree[k];\n\telse{\n\t\treturn (calc(p,q,l,(l+r)/2,k*2)+calc(p,q,(l+r)/2+1,r,k*2+1));\n\t}\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tfor(int i=0;i<Q;++i){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=Q-1;i>=0;--i){\n\t\tif(b[a[i]])continue;\n\t\tv.push_back(a[i]);\n\t\tb[a[i]]=true;\n\t}\n\tfor(int i:v){\n\t\tadd(i,1);\n\t}\n\twhile(!v.empty()){\n\t\tif(calc(0,v.back(),0,(1<<17)-1,1)==v.back()){\n\t\t\tadd(v.back(),-1);\n\t\t\tv.pop_back();\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<Q;++i){\n\t\tst.insert({i,a[i]});\n\t}\n\tfor(int i=0;i<N;++i){\n\t\tint t=0;\n\t\tauto it=st.end();\n\t\twhile(it!=st.begin()&&t!=v.size()){\n\t\t\t--it;\n\t\t\tif(it->second==v[t]){\n\t\t\t\t++t;\n\t\t\t\tauto it2=it;\n\t\t\t\t--it;\n\t\t\t\tst.erase(it2);\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t\tif(t!=v.size()){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            for(int j=1; j<=tail; j++)\n            {\n                if(qu[j]==a[i])\n                    goto haha;\n            }\n            tail++;\n            qu[tail]=a[i];\n            haha:;\n        }\n    }\n    //cout<<head<<  \"  \"<<tail<<endl;\n    if(head==tail)\n    {\n        if(ha[head]>=3)\n        {\n            cout<<\"Yes\"<<endl;\n            return 0;\n        }\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\"<<endl;\n            return 0;\n        }\n    }\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n\n    cout<<\"No\"<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nint n, m;\nint q;\n\nint a[100010];\nll t;\n\nvi v, x;\n\nset<int> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%d %d\" , &n , &m );\n  scanf( \"%d\" , &q );\n  REP( i , q ) scanf( \"%d\" , &a[i] );\n  \n  for( int i = n; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( int i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= n ) ss[ v[i] ].erase( ss[ v[i] ].find( i-n ) );\n    }\n  }\n  \n  for( int i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( t * n > q ) return no();\n\n  REP( i , n-1 ){\n    int cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 505050;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(m, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(rmq.get(pos) == n) continue;\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    drep(i,v.size()){\n        if(i == v.size() - 1 && v[i].first == 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nint top;\nbool okalone(int num,int I){\n\tif(num!=top) return 0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\tif(N==1) return 1;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n//\t\tshow(I);\n//\t\tshow(v);\n\n//\t\tif(okalone(v,I)) return 1;\n\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t\tif(top==v){\n\t\t\twhile(top<M&&done[top]) top++;\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,doc=7;cin>>n>>m>>q;doc=n;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){cout<<\"No\"<<endl;return 0;}\n\t\t\tlas[j]=numlis[no][j];\n\t\t}\n\t\tif(numlis[no].size()<n){\n\t\t\twhile(mita[zyu]){zyu++;}\n\t\t\tif(zyu!=no){cout<<\"No\"<<endl;return 0;}\n\t\t}\n\t\tmita[no]=true;\n\t\tfor(j=numlis[no].size();j<doc;j++){las[j]=-999;}\n\t\tmineq(doc,numlis[no].size());\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint n,m,q;\nint state[100010];\n\nint last[100010];\n\nint number[100010];\n\nint a[100010];\n\nint main(void){\n\tcin >> n >> m >> q;\n\trep(i,q) cin >> a[i],a[i]--;\n\t\n\trep(i,m) last[i]=-i-1;\n\trep(i,q) last[a[i]]=i;\n\n\tusing type=tuple<int,int>;\n\tvector<type> ary;\n\trep(i,m) ary.push_back(type(last[i],i));\n\t\n\tsort(_all(ary));\n\t\n\tint offset=1;\n\twhile(offset<m and get<1>(ary[offset-1]) > get<1>(ary[offset])) offset++;\n\n\tfill(number,number+m,-1);\n\tconst int len=m-offset;\n\trep(i,len) number[get<1>(ary[i+offset])]=i;\n\n\n\n\tstate[0]=n;\n\n\trep(i,q){\n\t\tint idx=number[a[i]];\n\t\tif(idx==-1) continue;\n\t\tif(state[idx]>0){\n\t\t\tstate[idx]--;\n\t\t\tstate[idx+1]++;\n\t\t}\n\t}\n\n\tif(state[len]==n)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int M = 100100;\n\nint n, m, q;\nint a[M];\nbool used[M];\nint cnt[M];\nint ord[M];\nvector<int> seq;\n\nvoid read() {\n  cin >> n >> m >> q;\n  for (int i = 0; i < q; ++i) {\n    cin >> a[i];\n    --a[i];\n  }\n  reverse(a, a + q);\n}\n\nvoid nx(int i) {\n  assert(i < m);\n  if (cnt[i] > 0) {\n    --cnt[i];\n    ++cnt[i + 1];\n  }\n}\n\nvoid add(int x) {\n  if (!used[x]) {\n    int f = seq.size();\n\n    used[x] = true;\n    ord[x] = f;\n\n    nx(f);\n    seq.push_back(x);\n  } else {\n    int k = ord[x];\n    nx(k);\n  }\n}\n\nvoid kill() {\n  cnt[0] = n;\n\n  for (int i = 0; i < q; ++i)\n    add(a[i]);\n\n  for (int i = 0; i < m; ++i)\n    if (!used[i])\n      seq.push_back(i);\n\n  int sh = 0;\n  while (!cnt[sh])\n    ++sh;\n  \n  auto alt = seq;\n  sort(alt.begin() + sh, alt.end());\n\n  if (alt == seq) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n\nint main() {\n  cout.precision(20);\n  cout << fixed;\n  ios_base::sync_with_stdio(false);\n  read();\n  kill();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> void chmax(T& a,const T& b){if(a < b) a = b;}\ntemplate<typename T> void chmin(T& a,const T& b){if(b < a) a = b;}\ntypedef long long ll;\n\nint N,M,Q;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M >> Q;\n\tvector<int> A(Q);\n\tFOR(i,0,Q){\n\t\tcin >> A [i];\n\t}\n\n\tset<int> st;\n\tvector<int> B,pos(M + 1,-1);\n\tfor(int i = Q - 1;i >= 0;i--){\n\t\tif(st.count(A [i]) == 0){\n\t\t\tpos [A [i]] = B.size();\n\t\t\tB.push_back(A [i]);\n\t\t\tst.insert(A [i]);\n\t\t}\n\t}\n\n\tvector<int> cnt(B.size() + 1);\n\tcnt [0] = N;\n\tfor(int i = Q - 1;i >= 0;i--){\n\t\tint p = pos [A [i]];\n\t\tif(cnt [p]){\n\t\t\tcnt [p]--;\n\t\t\tcnt [p + 1]++;\n\t\t}\n\t}\n\t\n\tst.clear();\n\tvector<int> C;\n\tfor(int i = 0;i < B.size() && cnt [i] == 0;i++){\n\t\tC.push_back(B [i]);\n\t\tst.insert(B [i]);\n\t}\n\n\tfor(int i = 1;i <= M && C.size() < B.size();i++){\n\t\tif(st.count(i) == 0){\n\t\t\tC.push_back(i);\n\t\t}\n\t}\n\n\tcout << (B == C ? \"Yes\" : \"No\") << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint p[110000];\nint sh[110000];\npair<int,int> lat[110000];\nint goal[110000];\nint num[110000];\nint rev[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",p+i);\n\t\tp[i]--;\n\t}\n\tfor(int i=0;i<b;i++)sh[i]=-1;\n\t\n\tfor(int i=c-1;i>=0;i--){\n\t\tif(sh[p[i]]==-1){\n\t\t\tsh[p[i]]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<b;i++)lat[i]=make_pair(-sh[i],i);\n\tstd::sort(lat,lat+b);\n\tfor(int i=0;i<b;i++)goal[i]=lat[i].second;\n\tfor(int i=0;i<b;i++)rev[goal[i]]=i;\n\tbool ok=true;\n//\tfor(int i=0;i<b;i++)printf(\"%d\\n\",p[i]);\n\tfor(int i=c-1;i>=0;i--){\n\t\tif(rev[p[i]]==0||num[rev[p[i]]]<num[rev[p[i]]-1]){\n\t\t\tnum[rev[p[i]]]++;\n\t\t}\n\t}\n\tint fp=99999999;\n\tfor(int i=0;i<b;i++){\n\t\tif(num[i]<a){\n\t\t\tfp=i;break;\n\t\t}\n\t}\n\tfor(int i=fp;i<b-1;i++){\n\t\tif(goal[i]>goal[i+1])ok=false;\n\t}\n\tif(ok)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    cut[qv[0]] = true;\n    std::set<ll> free;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n            for (ll idx : free) nxts[e].insert(idx);\n            free.clear();\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n            else free.insert(idx);\n        }\n    }\n\n    bool ok = true;\n    for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MX = 100 * 1000 + 7;\n\nvector<int> wait[MX];\nint pos[MX];\nvector<int> pattern;\nbool was[MX];\nint a[MX];\nvector<int> full;\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 1; i <= q; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) full.push_back(i);\n    for (int i = q; i >= 1; i--) {\n        int x = a[i];\n        if (was[x]) {\n            if (!wait[x].empty()) {\n                int cpos = wait[x].back();\n                wait[x].pop_back();\n                pos[cpos]++;\n                if (pos[cpos] == (int)pattern.size()) {\n                    full.push_back(cpos);\n                } else {\n                    wait[pattern[pos[cpos]]].push_back(cpos);\n                }\n            }\n        } else {\n            was[x] = true;\n            pattern.push_back(x);\n            for (int cpos : full) {\n                wait[x].push_back(cpos);\n            }\n            full.clear();\n        }\n    }\n    int maxPos = (int)pattern.size() - 1;\n    while (maxPos > 0 && pattern[maxPos] == 1) maxPos--;\n    bool ok = true;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] <= maxPos) ok = false;\n    }\n    if (ok) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, M, Q;\nconst int _ = 100096;\nint a[_], r[_], id[_], s[_];\nbool vis[_];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tint t = 1;\t\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tif(a[i] >= t-1) t = a[i];\n\t}\n\tif(t == 1) return puts(\"Yes\"), 0;\n\tint c = 0;\n\tfor(int i = Q; i >= 1; --i)\n\t\tif(!vis[a[i]]) {\n\t\t\tr[++c] = a[i];\n\t\t\tvis[a[i]]= true;\n\t\t}\n\tfor(int i =1; i <= M; ++i)\n\t\tif(!vis[i]) r[c++] = i;\n\tfor(int i = 1; i <= M; ++i)\n\t\tid[r[i]] = i;\n\tint init = M;\n\tfor(int i = M; i >= 1; --i)\n\t\tif(id[i] == i) {\n\t\t\tinit = i - 1;\n\t\t} else break;\n\tif((long long)(init - 1) * N > Q)\n\t\treturn puts(\"No\"), 0;\n\ts[init] = N;\n\tint worst = init;\n\tfor(int i = 1; i <= Q; ++i) {\n\t\tint k = id[a[i]];\n\t\tif(s[k + 1]) {\n\t\t\ts[k + 1]--;\n\t\t\t++s[k];\n\t\t\tif(k + 1 == worst && !s[k + 1])\n\t\t\t\t--worst;\n\t\t} else {\n\t\t\tif(k > worst) {\n\t\t\t\t--s[worst];\n\t\t\t\t++s[worst = k];\n\t\t\t} \n\t\t}\n\t}\n\tputs(worst > 1? \"No\": \"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = m; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= m ){\n\tassert( ss[ v[i] ].find( i-m ) != ss[ v[i] ].end() );\n\tss[ v[i] ].erase( ss[ v[i] ].find( i-m ) );\n      }\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  //if( t * n > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nint main()\n{\n\tint n, m;\n\tint q;\n\tvector<int> a;\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\ta.resize(q);\n\tfor(int i = 0; i < q; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\n\tvector<int> sample;\n\tvector<bool> exist(m);\n\n\tfor(int i = q - 1; i >= 0; --i) {\n\t\tint x = a[i];\n\t\tif(exist[x]) continue;\n\t\texist[x] = true;\n\t\tsample.push_back(x);\n\t}\n\tfor(int x = 1; x <= m; ++x) {\n\t\tif(exist[x]) continue;\n\t\tsample.push_back(x);\n\t}\n\n\tvector<int> pos(m + 1, -1);\n\n\tfor(int i = 0; i < m; ++i)\n\t\tpos[sample[i]] = i;\n\n\tvector<int> count(m + 1);\n\tcount[0] = n;\n\n\tfor(int i = q - 1; i >= 0; --i) {\n\n\t\tint x = a[i];\n\t\tint p = pos[x];\n\n\t\tif(count[p] > 0) {\n\t\t\tcount[p] -= 1;\n\t\t\tcount[p + 1] += 1;\n\t\t}\n\t}\n\n\tint border = m;\n\n\tfor(int p = m - 1; p >= 1; --p) {\n\t\tif(sample[p - 1] > sample[p]) break;\n\t\tborder = p;\n\t}\n\tif(border == 1) border -= 1;\n\n\tbool ok = true;\n\n\tfor(int i = 0; i < border - 1; ++i) {\n\t\tif(count[i] > 0)\n\t\t\tok = false;\n\t}\n\n\t/*for(int i = 0; i <= m; ++i) {\n\t\tprintf(\"count[%d] = %d\\n\", i, count[i]);\n\t}\n\tfor(int i = 0; i < m; ++i) {\n\t\tprintf(\"sample[%d] = %d\\n\", i, sample[i]);\n\t}\n\tprintf(\"border: %d\\n\", border);*/\n\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint a[SIZE];\nint d[SIZE],u[SIZE],dn,now[SIZE];\nVI p[SIZE];\nint main(){\n    DRIII(N,M,Q);\n    REP(i,Q)RI(a[Q-1-i]);\n    int one=-1;\n    REP(i,Q){\n        p[a[i]].PB(i);\n        if(!u[a[i]]){\n            u[a[i]]=1;\n            if(a[i]==1)one=dn;\n            d[dn++]=a[i];\n        }\n    }\n    if(one!=-1){\n        bool suc=1;\n        REPP(i,one,dn){\n            if(d[i]-1!=i-one)suc=0;\n        }\n        if(suc)dn=one;\n    }\n    MS1(now);\n    REP(i,dn){\n        int it=0;\n        REP(j,N){\n            while(it<SZ(p[d[i]])&&p[d[i]][it]<=now[j])it++;\n            if(it>=SZ(p[d[i]])){\n                puts(\"No\");\n                return 0;\n            }\n            now[j]=p[d[i]][it++];\n        }\n    }\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = n - 1;\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos)\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nint n,m,q,v;\nint a[N], used[N], ord[N], pos[N], sor[N], prog[N];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tFOR(i,q) scanf(\"%d\", &a[i]);\n\tFOR(i,q) a[i]--;\n\tREPD(i,q-1,0) if (!used[a[i]]) {\n\t\tord[v++] = a[i];\n\t\tused[a[i]]=1;\n\t}\n\tFOR(i,m) if (!used[i]) ord[v++] = i;\n\tsor[v-1]=sor[v]=1;\n\tREPD(i,v-2,0) sor[i] = sor[i+1] && (ord[i] < ord[i+1]);\n\tFOR(i,v) pos[ord[i]] = i;\n\tREPD(i,q-1,0) {\n\t\tint pp = upper_bound(prog, prog+n, pos[a[i]]) - prog - 1;\n\t\tif (pp >= 0 && prog[pp] == pos[a[i]]) {\n\t\t\tprog[pp]++;\n\t\t}\n\t}\n\t//FOR(i,n) printf(\"%d %d\\n\", i, prog[i]);\n\tbool ok = true;\n\tFOR(i,n) if (!sor[prog[i]]) ok = false;\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != cur[k]-1) ans = false;\n\t\t\tif (cur[k] < 0) { cur[k] = j; break; }\n\t\t\telse cur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, m; cin>>n>>m;\n    int q; cin>>q;\n    int a[100010];\n    for(int i=0; i<q; i++){\n        cin>>a[i];\n    }\n    int ind[100010];\n    fill(ind, ind+m+1, -1);\n    int cnt[100010]={};\n    vector<int> v;\n    for(int i=q-1; i>=0; i--){\n        if(ind[a[i]]==-1){\n            ind[a[i]]=cnt[0];\n            v.push_back(a[i]);\n            cnt[0]++;\n        }else{\n            int l=0, r=n;\n            while(r-l>1){\n                int mid=(l+r)/2;\n                if(cnt[mid]<=ind[a[i]]) r=mid;\n                else l=mid;\n            }\n            if(r<n && cnt[r]==ind[a[i]]) cnt[r]++;\n        }\n    }\n    for(int i=1; i<=m; i++) if(ind[i]==-1) v.push_back(i);\n    int mn=0;\n    for(int i=m-1; i>=1; i--){\n        if(v[i]<v[i-1]){\n            mn=i; break;\n        }\n    }\n    for(int i=0; i<n; i++){\n        if(cnt[i]<mn){\n            cout<<\"No\"<<endl; return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,q;\n    cin >> n >> m >> q;\n    vector<int> a(q);\n    rep(i,0,q){\n        cin >> a[i];\n        --a[i];\n    }\n    reverse(a.begin(),a.end());\n\n    vector<int> v;\n    {\n        vector<bool> f(m);\n        rep(i,0,q){\n            if(f[a[i]]) continue;\n            f[a[i]]=true;\n            v.push_back(a[i]);\n        }\n        rep(i,0,m) if(not f[i]) v.push_back(i);\n    }\n\n    vector<int> pos(m);\n    rep(i,0,m) pos[v[i]]=i;\n\n    vector<int> freq(m+1);\n    freq[0]=n;\n    rep(i,0,q){\n        int p=pos[a[i]];\n        if(not freq[p]) continue;\n        --freq[p];\n        ++freq[p+1];\n    }\n    rep(i,0,m+1){\n        if(not freq[i]) continue;\n        vector<int> w;\n        vector<bool> f(m);\n        rep(j,0,q){\n            if(w.size()==i) break;\n            if(f[a[j]]) continue;\n            f[a[j]]=true;\n            w.push_back(a[j]);\n        }\n        rep(j,0,m) if(not f[j]) w.push_back(j);\n        if(v==w) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n        return;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nVI a;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    if (prog[inv_t[op[i]]] == 0 && !pass[inv_t[op[i]]]) {\n      return false;\n    }\n    if (prog[inv_t[op[i]]] == 0) {\n      continue;\n    }\n    prog[inv_t[op[i]]]--;\n    prog[inv_t[op[i]] + 1]++;\n    pass[inv_t[op[i]]] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  a = VI(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int ind[M];\n  for(i=0;i<M;++i){ind[i] = -1;}\n  int laststock = 0;\n  int lastcount[M];\n  int before[M];\n  int bef = -1;\n  for(i=Q-1; i>=0; --i){\n    if(ind[a[i]-1] == -1){\n      ind[a[i]-1] = laststock;\n      laststock++;\n      lastcount[laststock] = 1;\n    }else{\n      if(ind[a[i]-1] == 0 || lastcount[ind[a[i]-1]] < lastcount[ind[a[i]-1]]){\n        lastcount[ind[a[i]-1]]++;\n      }\n    }\n  }\n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  int maxind = -1;\n  for(i=0; i<M; ++i){\n    if(ind[i] < 0){break;}\n    if(ind[i] > maxind){\n      maxind = ind[i];\n      lastcount[ind[i]] = N;\n    }\n  }\n  \n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  \n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 200200;\nint a[maxn];\nbool used[maxn];\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m, q;\n    cin >> n >> m >> q;\n    forn (i, q) {\n        cin >> a[i];\n        --a[i];\n    }\n    vector<int> p;\n    for (int i = q - 1; i >= 0; --i) {\n        if (used[a[i]])\n            continue;\n        int val = a[i];\n        used[val] = true;\n        p.push_back(val);\n    }\n    forn (i, m)\n        if (!used[i])\n            p.push_back(i);\n    assert(sz(p) == m);\n    int pr = 0;\n    //forn (i, m)\n        //cerr << p[i] << ' ';\n    //cerr << '\\n';\n    forn (i, m - 1)\n        if (p[i] > p[i + 1])\n            pr = i + 1;\n    vector<int> rp(m);\n    forn (i, m)\n        rp[p[i]] = i;\n    multiset<int> S;\n    forn (i, n)\n        S.insert(0);\n    for (int i = q - 1; i >= 0; --i) {\n        int x = rp[a[i]];\n        auto it = S.lower_bound(x);\n        if (it == S.end()) {\n            cout << \"No\\n\";\n            return 0;\n        }\n        int to = x;\n        if (to == x)\n            ++to;\n        S.erase(it);\n        S.insert(to);\n    }\n    if (*S.begin() < pr)\n        cout << \"No\\n\";\n    else\n        cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\n\nint main()\n{\n\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            for(int j=1; j<=tail; j++)\n            {\n                if(qu[j]==a[i])\n                    goto haha;\n            }\n            tail++;\n            qu[tail]=a[i];\n            haha:;\n        }\n    }\n    //cout<<head<<  \"  \"<<tail<<endl;\n    if(head==tail)\n    {\n        if(ha[head]>=3)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n    }\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<int> as(q);\n    for (auto &a: as) {\n        cin >> a;\n        a--;\n    }\n\n    map<int, vector<int>> poss;\n\n    for (int i = 0; i < q; i++) {\n        poss[as[i]].push_back(i);\n    }\n\n    vector<int> height(n, q);\n\n    set<int> rest;\n    for (int i = 0; i < m; i++) {\n        rest.insert(i);\n    }\n\n    for (int i = q - 1; i >= 0; i--) {\n        int cur = as[i];\n        if (!rest.count(cur))\n            continue;\n\n        auto it = poss[cur].rbegin();\n        auto end = poss[cur].rend();\n        int partial = -1;\n\n        for (int j = 0; j < height.size(); j++) {\n            while (it != end && *it >= height[j])\n                it++;\n\n            if (it == end) {\n                partial = j;\n                break;\n            }\n\n            height[j] = *it++;\n        }\n\n        if (partial != -1) {\n            if (cur != *rest.begin()) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n\n            while (partial < height.size()) {\n                if (height[partial] < 0)\n                    break;\n                height[partial++] = -1;\n            }\n        }\n\n        // for (int j = 0; j < height.size(); j++)\n        //     cout << i << \", \" << j << \": \" << height[j] << endl;\n        // cout << endl;\n\n        rest.erase(cur);\n    }\n\n    cout << \"Yes\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long p[303030];\nconst long long mod = 1e9 + 7;\nlong long base;\n\nstruct node {\n\tnode *l = nullptr;\n\tnode *r = nullptr;\n\tnode *p = nullptr;\n\tint size = 1;\n\n\tlong long val;\n\tlong long hash;\n\n\tnode(long long val) : val(val), hash(val) {}\n};\n\nunsigned long long xor_shift() {\n\tstatic unsigned long long x = time(NULL);\n\tx ^= x << 13; x ^= x >> 7; x ^= x << 17;\n\treturn x;\n}\n\nint size(node *x) {\n\treturn x ? x->size : 0;\n}\n\nlong long hash_v(node *x) {\n\treturn x ? x->hash : 0;\n}\n\nnode *update(node *x) {\n\tx->size = 1 + size(x->l) + size(x->r);\n\tx->hash = (hash_v(x->l) * base + x->val) % mod;\n\tx->hash = (x->hash * p[size(x->r)] + hash_v(x->r)) % mod;\n\treturn x;\n}\n\nnode *merge(node *x, node *y) {\n\tif (!x) return y;\n\tif (!y) return x;\n\tif (xor_shift() % (size(x) + size(y)) < size(x)) {\n\t\tx->r = merge(x->r, y);\n\t\tif (x->r) x->r->p = x;\n\t\treturn update(x);\n\t} else {\n\t\ty->l = merge(x, y->l);\n\t\tif (y->l) y->l->p = y;\n\t\treturn update(y);\n\t}\n}\n\npair<node *, node *> split(node *x, bool erase_x = false) {\n\tif (!x) return make_pair(nullptr, nullptr);\n\tnode *l = x->l;\n\tnode *r = x->r;\n\tx->l = nullptr;\n\tx->r = nullptr;\n\tx = update(x);\n\n\twhile (x->p) {\n\t\tbool dir = x->p->l == x;\n\t\tx = x->p;\n\t\tif (dir) {\n\t\t\tx->l = r;\n\t\t\tif (r) r->p = x;\n\t\t\tr = update(x);\n\t\t} else {\n\t\t\tx->r = l;\n\t\t\tif (l) l->p = x;\n\t\t\tl = update(x);\n\t\t}\n\t}\n\tif (l) l->p = nullptr;\n\tif (r) r->p = nullptr;\n\treturn make_pair(l, r);\n}\n\npair<node *, node *> split(node *x, int k) {\n\tif (x == nullptr) return make_pair(nullptr, nullptr);\n\tif (k <= size(x->l)) {\n\t\tauto p = split(x->l, k);\n\t\tx->l = p.second;\n\t\tif (p.first != nullptr) p.first->p = nullptr;\n\t\tif (p.second != nullptr) p.second->p = x;\n\t\treturn make_pair(p.first, update(x));\n\t} else {\n\t\tauto p = split(x->r, k - size(x->l) - 1);\n\t\tx->r = p.first;\n\t\tif (p.first != nullptr) p.first->p = x;\n\t\tif (p.second != nullptr) p.second->p = nullptr;\n\t\treturn make_pair(update(x), p.second);\n\t}\n}\n\nint main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tsrand(time(NULL));\n\tbase = rand() + 100;\n\n\tp[0] = 1;\n\tfor (int i = 1; i < 303030; i++) {\n\t\tp[i] = p[i - 1] * base % mod;\n\t}\n\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\treverse(a.begin(), a.end());\n\n\tvector<int> val(m);\n\tvector<int> hor(n), ver(m);\n\tvector<int> pos(m, -1);\n\n\tint k = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tif (pos[a[i]] == -1) {\n\t\t\tval[k] = a[i];\n\t\t\tpos[a[i]] = k;\n\t\t\tk++;\n\t\t\thor[0]++;\n\t\t\tver[a[i]]++;\n\t\t} else {\n\t\t\tif (hor[ver[a[i]]] == pos[a[i]]) {\n\t\t\t\thor[ver[a[i]]]++;\n\t\t\t\tver[a[i]]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<node *> tr(m);\n\tfor (int i = 0; i < m; i++) {\n\t\ttr[i] = new node(i + 100);\n\t}\n\n\tnode *t = nullptr;\n\tfor (int i = 0; i < m; i++) {\n\t\tt = merge(t, tr[i]);\n\t}\n\n\tvector<long long> hh(n);\n\n\tk = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (k < hor[i]) {\n\t\t\tauto qr = split(tr[val[k]]);\n\t\t\tauto pq = split(qr.first, k);\n\n\t\t\ttr[val[k]]->p = nullptr;\n\t\t\ttr[val[k]]->l = nullptr;\n\t\t\ttr[val[k]]->r = nullptr;\n\t\t\tupdate(tr[val[k]]);\n\n\t\t\tt = merge(pq.first, tr[val[k]]);\n\t\t\tt = merge(t, pq.second);\n\t\t\tt = merge(t, qr.second);\n\t\t\tk++;\n\t\t}\n\n\t\thh[i] = hash_v(t);\n\t}\n\n\tbool ok = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (hh[i] != hh[0]) ok = false;\n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nconst int N=1e5+10;\nint n,m,q,num[N],cnt,sum[N],pos[N],a[N];\nbool vis[N];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"LRU Puzzle.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,m,q);\n\tfor(int i=1;i<=q;i++) read(a[i]);\n\tfor(int i=q;i;i--)\n\t{\n\t\tif(!vis[a[i]])\n\t\t{\n\t\t\tnum[++cnt]=a[i];\n\t\t\tpos[a[i]]=cnt;\n\t\t\tvis[a[i]]=1;\n\t\t}\n\t}\n\tfor(int i=1, cnt2=0;i<=m;i++) if(!vis[i]) num[cnt+(++cnt2)]=i;\n\tsum[0]=n;\n\tfor(int i=q;i;i--)\n\t{\n\t\tint tt=pos[a[i]];\n\t\tif(sum[tt-1])\n\t\t{\n\t\t\tsum[tt-1]--;\n\t\t\tsum[tt]++;\n\t\t}\n\t}\n\tint st=n;\n\tfor(int i=0;i<=cnt;i++) \n\t{\n\t\tif(sum[i])\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=st+2;i<=cnt;i++)\n\t{\n\t\tif(num[i]<num[i-1])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint z[N];\nint a[N];\nint pos[N];\nint at[N];\n\nint main() {\n  int n, m, q;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", z + i);\n    z[i]--;\n  }\n  for (int i = 0; i < m; i++) {\n    a[i] = -1;\n    pos[i] = -1;\n    at[i] = 0;\n  }\n  int known = 0;\n  at[0] = n;\n  at[m] = 0;\n  for (int it = q - 1; it >= 0; it--) {\n    int i = z[it];\n    if (pos[i] == -1) {\n      a[known] = i;\n      pos[i] = known;\n      at[known]--;\n      known++;\n      at[known]++;\n      continue;\n    }\n    if (at[pos[i]] > 0) {\n      at[pos[i]]--;\n      at[pos[i] + 1]++;\n    }\n  }\n  int first = -1;\n  for (int i = 0; i <= m; i++) {\n    if (at[i] > 0) {\n      first = i;\n      break;\n    }\n  }\n  vector <int> all;\n  for (int i = first; i < known; i++) {\n    all.push_back(a[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    if (pos[i] == -1) {\n      all.push_back(i);\n    }\n  }\n  sort(all.begin(), all.end());\n  for (int i = first; i < known; i++) {\n    if (all[i - first] != a[i]) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nlli cn[100005];\n\n\nint n,m,qn;\nint dat[100005];\nint gone[100005]={};\n\nset<int> ds;\n\nvector<int> td;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,qn)scanf(\"%d\",&dat[i]);\n\t\n\tint bp=1;\n\tirep(i,qn){\n\t\tint no=dat[i];\n\t\tif(!gone[no]){\n\t\t\ttd.push_back(no);\n\t\t\tgone[no]=bp;\n\t\t\tbp++;\n\t\t}\n\t}\n\t\n\treg(i,1,m){\n\t\tif(!gone[i])td.push_back(i);\n\t}\n\t\n\t/*\n\trep(i,m){\n\t\tprintf(\"td .. %d\\n\",td[i]);\n\t}*/\n\t\n\tcn[0]=n;\n\tds.insert(0);\n\t\n\tirep(i,qn){\n\t\tint no=dat[i],\n\t\t\tp=gone[no];\n\t\tset<int>::iterator ite;\n\t\tite = ds.lower_bound(p-1);\n\t\tif(ite!=ds.end()){\n\t\t\tcn[*ite]--;\n\t\t\tif(cn[*ite]==0)ds.erase(ite);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(cn[p]==0)ds.insert(p);\n\t\tcn[p]++;\n\t}\n\t\n\t/*\n\trep(i,m+1){\n\t\tprintf(\"cn[%d] %d\\n\",i,cn[i]);\n\t}\n\t*/\n\t\n\tint okp=-1;\n\tint nma=100005;\n\tirep(i,m){\n\t\tif(nma<td[i]){\n\t\t\tokp=i;\n\t\t\tbreak;\n\t\t}\n\t\tnma=td[i];\n\t}\n\t//printf(\"%d %d\\n\",nma,okp);\n\t\n\treg(i,0,okp){\n\t\tif(cn[i]>0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    if(id==(*s.begin())&&i>0){\n                        que.pop();\n                        break;\n                    }\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n    }\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    VI a(q);\n    REP(i,q) a[i] = in() - 1;\n    VI p;\n    set<int> st;\n    REP(i,m) st.insert(i);\n    FORR(i,q-1,0){\n        if (st.count(a[i])){\n            p.push_back(a[i]);\n            st.erase(a[i]);\n        }\n    }\n    for (int x : st) p.push_back(x);\n    VI idx(m);\n    REP(i,m) idx[p[i]] = i;\n\n    // REP(i,m) cout << p[i] << \" \";\n    // cout << endl;\n\n    int x = m - 1;\n    while (x > 0 && p[x - 1] < p[x]) x--;\n\n    VI cnt(m);\n    FORR(i,q-1,0){\n        int j = idx[a[i]];\n        cnt[j] = min(n, cnt[j] + 1);\n        if (j) chmin(cnt[j], cnt[j - 1]);\n    }\n    REP(i,x){\n        if (cnt[i] != n){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n, m; cin >> n >> m;\n    int Q; cin >> Q;\n    vector<int> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<int> seq = [&]() {\n        set<int> used;\n        vector<int> pos(m);\n        REP(i, Q) {\n            used.insert(a[i]);\n            pos[a[i]] = i;\n        }\n        vector<P> temp;\n        REP(i, m) if (used.count(i) > 0) temp.pb({-pos[i], i});\n        sort( ALL(temp) );\n        vector<int> res;\n        REP(i, temp.size()) {\n            res.pb(temp[i].second);\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    vector<int> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<int> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        int pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    int def = 0;\n    REP(i, seq.size()) {\n        if (seq[i] == 0) {\n            bool f = true;\n            FOR(j, i, seq.size()) {\n                if (seq[j] != j-i) f = false;\n            }\n            if (f) def = m-i;\n            break;\n        }\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n/*\n    vector< set<int> > v(m);\n    REP(i, n) {\n        v[a[i]].insert(i);\n    }\n    set<int> used;\n    RREP(pos, n) {\n        if (used.size() == n-1) break;\n        if (used.count(a[pos]) > 0) continue;\n        int x = a[pos];\n\n    }\n    cout << \"Yes\" << endl;\n*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, m, q;\n    cin >> n >> m >> q;\n    vi qs(q);\n    forn(i, q) cin >> qs[i];\n    reverse(all(qs));\n    vi vis(m), pos(m);\n    vi pref;\n    for (int x: qs) {\n        --x;\n        if (!vis[x]) pos[x] = pref.size(), pref.pb(x);\n        ++vis[x];\n        uin(vis[x], n);\n        if (pos[x]) uin(vis[x], vis[pref[pos[x] - 1]]);\n    }\n    forn(i, m) if (!vis[i]) pref.pb(i);\n    vi got;\n    forn(i, pref.size()) if (vis[pref[i]] == n) got.pb(pref[i]);\n    forn(i, m) if (vis[i] < n) got.pb(i);\n    cout << (got == pref ? \"Yes\" : \"No\") << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1])&&d[i]!=0){\n\t\t\te[i]=d[i];\n\t\t}else{\n\t\t\te[i]=e[i-1];\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(x) (int((x).size()))\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\ntemplate<typename T> bool domax(T &a, T b) { return (b > a ? (a = b, true) : false); }\ntemplate<typename T> bool domin(T &a, T b) { return (b < a ? (a = b, true) : false); }\ntypedef long long ll;\n\nconst int maxn = 100*1000+5;\n\nint n, m, q, a[maxn], place[maxn], next[maxn];\nstd::vector<int> l[maxn];\nbool seen[maxn];\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &q);\n    for (int i = 0; i < q; i++) scanf(\"%d\", a+i);\n    for (int i = q-1; i >= 0; i--) {\n        int v = a[i];\n        if (!seen[v]) {\n            seen[v] = true;\n            place[v] = sz(l[0]);\n            l[next[v]++].pb(v);\n        } else if (next[v] < n) {\n            l[next[v]++].pb(v);\n        }\n    }\n    std::fill(seen, seen+m+1, false);\n    for (int &i : l[n-1]) seen[i] = true;\n    for (int j = 1; j <= m; j++) if (!seen[j]) l[n-1].pb(j);\n    for (int i = n-2; i >= 0; i--) {\n        for (int k = 0; k < sz(l[i]); k++) if (l[i][k] != l[n-1][k]) {\n            printf(\"No\\n\");\n            exit(0);\n        }\n    }\n    printf(\"Yes\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=100000;\nint N,M,Q,a[MN];\nbool done[MN];\t\t//value done?\nint its[MN];\t\t//where iterate?\nset<int> v2ps[MN];\nbool ok0(int I){\n\tint num=0;\n\tfor(int it=I;it<Q&&num<M;it++){\n\t\tint v=a[it];\n\t\tif(done[v]) continue;\n\t\tif(v>num) return 0;\n\t\tif(a[it]==num){\n\t\t\tnum++;\n\t\t\twhile(num<M&&done[num]) num++;\n\t\t}\n\t}\n\treturn (num==M);\n}\nbool solve(){\n\tcin>>N>>M>>Q;\n\trep(i,Q) cin>>a[Q-1-i],a[Q-1-i]--;\n\trep(i,Q) v2ps[a[i]].insert(i);\n\twhile(true){\n\t\tint I=its[0];\n\t\tfor(;I<Q;I++){\n\t\t\tif(!done[a[I]]) break;\n\t\t}\n\t\tif(I==Q){\n\t\t\treturn 1;\n\t\t}\n\t\tint v=a[I];\n\t\tif(v==0){\n\t\t\tif(ok0(I)) return 1;\n\t\t}\n\t\tset<int>& st=v2ps[v];\n\t\trep(i,N){\n\t\t\tauto it=st.lower_bound(its[i]);\n\t\t\tif(it==st.end()) return 0;\n\t\t\tits[i]=*it;\n\t\t\tst.erase(it);\n\t\t}\n\t\tdone[v]=1;\n\t}\n\tassert(false);\n}\n\nint main(){\n\tif(solve()) puts(\"Yes\");\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, int> PLDI;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nconst LL MOD = 1e9+7;\nconst LL INF = (1e18);\nconst double EPS=1.0e-9;\nconst double PI=atan2(0,-1);\n\n\n\nint main()\n{\n    int n,m,q;\n    cin>>n>>m>>q;\n    vector<int> a(q);\n    REP(i,q)\n        cin>>a[i];\n    \n    bool used[100001];\n    vector<int> b;\n    CLR(used);\n    b.reserve(q);\n    for(int i=q-1;i>=0;i--)\n    {\n        if(!used[a[i]])\n        {\n            b.push_back(a[i]);\n            used[a[i]]=1;\n        }\n    }\n    REP(i,m)\n    {\n        if(!used[i+1])\n            b.push_back(i+1);\n    }\n    vector<int> c(m+1);\n    REP(i,m)\n        c[b[i]]=i+1;\n    \n    bool flag=1;\n    vector<int> d(m+2);\n    d[0]=n;\n    for(int i=q-1;i>=0;i--)\n    {\n        d[c[a[i]]-1]--;\n        if(d[c[a[i]]-1]<0)\n        {\n            d[c[a[i]]-1]=0;\n            continue;\n            //flag=0;\n            //break;\n        }\n        d[c[a[i]]]++;\n    }\n    \n    CLR(used);\n    //used[0]=1;\n        int k=1;\n    REP(i,m+2)\n    {\n        if(d[i]==0)continue;\n        \n        for(int j=0;j<i;j++)\n            used[b[j]]=1;\n        \n        FOR(j,i,m)\n        {\n            if(used[k])\n            {\n                k++; j--;\n                continue;\n            }\n            if(k!=b[j])\n            {\n                flag=0;\n                break;\n            }\n            k++;\n        }\n        \n        break;\n    }\n    \n    if(flag)\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++)ord[P[i].num] = i;\n    for(i=m;i>=2;i--){\n        if(P[i].num < P[i-1].num)break;\n    }\n    pp = i;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    for(i=1;i<pp;i++){\n        if(R[i] < n){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, m, q;\n\t\tin >> n >> m >> q;\n\t\tvector<int> v(q);\n\t\tfor (int i: range(q)) {\n\t\t\tin >> v[i];\n\t\t\t--v[i];\n\t\t}\n\n\t\tvector<vector<int>> changesTimes(m);\n\n\t\tfor (int i: range(q)) {\n\t\t\tchangesTimes[v[i]].push_back(i);\n\t\t}\n\n\t\tmap<int, int> halves;\n\t\tvector<vector<int>> intr;\n\t\tint minUnused = 1000000;\n\t\tfor (int i: range(m)) {\n\t\t\tsort(changesTimes[i]);\n\t\t\tif (changesTimes[i].size() >= n) {\n\t\t\t\tintr.emplace_back(changesTimes[i].end() - n, changesTimes[i].end());\n\t\t\t} else if (changesTimes[i].size() > 0) {\n\t\t\t\thalves[i] = changesTimes[i].back();\n\t\t\t} else {\n\t\t\t\tminUnused = min(minUnused, i);\n\t\t\t}\n\t\t}\n\n\n\t\tint lastPos = 1000000;\n\t\tfor (auto p: halves) {\n\t\t\tif (p.first > minUnused) {\n\t\t\t\tout << \"No\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (p.second > lastPos) {\n\t\t\t\tout << \"No\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastPos = p.second;\n\t\t}\n\n\n\n\t\tif (intr.size() > 1) {\n\t\t\tsort(intr);\n\t\t\tfor (int i: range(n)) {\n\t\t\t\tfor (int j: range(1, (int)intr.size())) {\n\t\t\t\t\tif (intr[j][i] < intr[j - 1][i]) {\n\t\t\t\t\t\tout << \"No\\n\";\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout << \"Yes\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nint N, M, Q;\nint main(void) {\n    vector<int> a, fm;\n    set<int> st;\n    int n;\n\n    cin >> N >> M >> Q;\n    REP(i, Q) {\n        cin >> n;\n        a.push_back(n);\n    }\n    REP(i, M) {\n        st.insert(i+1);\n    }\n    for(int i=a.size()-1; i>=0; --i) {\n        if(st.find(a[i]) != st.end()) {\n            fm.push_back(a[i]);\n            st.erase(a[i]);\n        }\n    }\n    for(auto x: st) {\n        fm.push_back(x);\n    }\n    vector<vector<int>> b(N);\n    vector<int> freq(M, 0);\n    freq[0] = N;\n    for(int i=a.size()-1; i>=0; --i) {\n        auto it = find(fm.begin(), fm.end(), a[i]);\n        int k = distance(fm.begin(), it);\n        if(freq[k] == 0) {\n            cout << \"No\" << endl;\n            return 0;\n        } else {\n            freq[k]--; freq[k+1]++;\n            REP(j, N) {\n                if(b[j].size()==k) {\n                    b[j].push_back(a[i]);\n                    break;\n                }\n            }\n        }\n    }\n    st.clear();\n    REP(i, M) {\n        st.insert(i+1);\n    }\n    int j;\n    REP(i, freq.size()) {\n        if(freq[i] > 0) {\n            for(j=0; j<b.size(); ++j) {\n                if(b[j].size() == i) break;\n            }\n            break;\n        }\n    }\n    for(auto x: b[j]) {\n        st.erase(x);\n    }\n    for(auto x: st) {\n        b[j].push_back(x);\n    }\n    REP(i, b[j].size()) {\n        if(b[j][i] != fm[i]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = M;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N,M; cin >> N >> M;\n    int Q; cin >> Q;\n    vector<int> A(Q);\n    rep(i,Q) cin >> A[i], --A[i];\n\n    vector<bool> seen(M);\n    vector<int> arr;\n    for (int i = Q-1; i >= 0; i--) {\n        if (seen[A[i]]) continue;\n        seen[A[i]] = 1;\n        arr.emplace_back(A[i]);\n    }\n    rep(i,M) {\n        if (!seen[i]) arr.emplace_back(i);\n    }\n    int MAX = M;\n    for (int i = SZ(arr)-1; i >= 0; i--) {\n        if (MAX <= arr[i]) break;\n        MAX = arr[i];\n        arr.pop_back();\n    }\n    map<int, int> dic;\n    for (int i = 0, cur = 0; i < SZ(arr); i++) {\n        dic[arr[i]] = cur++;\n    }\n    vector<int> cnt(SZ(arr));\n    for (int i = Q-1; i >= 0; i--) {\n        if (!dic.count(A[i])) continue;\n        int id = dic[A[i]];\n        if (id and cnt[id]==cnt[id-1]) continue;\n        cnt[id]++; \n    }\n    cout << (cnt.empty() or *min_element(all(cnt)) >= N ? \"Yes\" : \"No\") << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ELRU {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m, q; cin >> n >> m >> q;\n      vector<int> a(q);\n      rep(i, q) {\n        cin >> a[i];\n      }\n      reverse(all(a));\n      // value, pos\n      map<int, int> used;\n      vector<int> cnt;\n      vector<int> rev;\n      rep(i, q) {\n        if (used.find(a[i]) == used.end()) {\n          used[a[i]] = cnt.size();\n          cnt.push_back(1);\n          rev.push_back(a[i]);\n        } else {\n          int pos = used[a[i]];\n          if (pos == 0 || cnt[pos-1] > cnt[pos]) {\n            cnt[pos]++;\n          }\n        }\n      }\n\n      bool flag = true;\n      bool foundone = false;\n      for(int i=0; i<cnt.size(); i++) {\n        if (rev[i] == 1) foundone = true;\n        if (!foundone) {\n          if (cnt[i] < n) {\n            flag = false;\n            break;\n          }\n        } else {\n          if (rev[i] == 1 || rev[i-1]+1 == rev[i]) continue;\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        cout << \"Yes\" << endl;\n        return;\n      }\n\n      flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (cnt[i] >= n) continue;\n        if (rev[i] == 1 && i == cnt.size()-1) continue;\n        flag = false;\n        break;\n      }\n      cout << (flag ? \"Yes\" : \"No\") << endl;\n    }\n};\n\nsigned main() {\n  ELRU solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\n\nbool vis[N];\nint n,m,q,a[N],cnt[N],p[N];\nvi order;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m >> q;\n    forn(i,q) cin >> a[i], a[i]--;\n    dforsn(i,0,q) if (!vis[a[i]]) {\n        order.pb(a[i]);\n        vis[a[i]] = true;\n    }\n    //m = si(order);\n    //forn(i,m) if (!vis[i]) order.pb(i);\n    forn(i,si(order)) p[order[i]] = i;\n\n    bool ok = true;\n    cnt[0] = n;\n    dforsn(i,0,q) {\n        int pos = p[a[i]];\n        if (cnt[pos]) {\n            cnt[pos]--;\n            cnt[pos+1]++;\n        }\n        else if (cnt[pos+1] || cnt[m]);\n        else ok = false;\n    }\n\n    int least;\n    forn(i,N) if (cnt[i]) {\n        least = i;\n        break;\n    }\n\n    vi norder;\n    memset(vis,0,sizeof vis);\n    forn(i,least) {\n        norder.pb(order[i]);\n        vis[order[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) norder.pb(i);\n    \n    ok &= norder == order;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid No() {\n    cout << \"No\\n\";\n    exit(0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n, m, q;\n    cin >> n >> m >> q;\n    vector<int> qs(q, 0);\n    for (int i = 0; i < q; ++i) {\n        cin >> qs[i];\n        qs[i]--;\n    }\n\n    reverse(qs.begin(), qs.end());\n    vector<int> used(m, 0), seq;\n    for (int i = 0; i < q; ++i)\n        if (!used[qs[i]]) {\n            seq.push_back(qs[i]);\n            used[qs[i]] = 1;\n        }\n\n    for (int i = 0; i < m; ++i)\n        if (!used[i])\n            seq.push_back(i);\n    vector<int> myNum(m, -1);\n    for (int i = 0; i < m; ++i) {\n        myNum[seq[i]] = i;\n    //    cerr << seq[i] << ' ';\n    }\n    //cerr << \"\\n\";\n\n    int ind = m-1;\n    while (ind > 0 && seq[ind] > seq[ind-1])\n        --ind;\n    vector<int> kol(m+1, 0);\n    kol[0] = m;\n    bool weCan = false;\n    for (int i = 0; i < q; ++i) {\n        int v = seq[i];\n        int pos = myNum[v] + 1;\n        if (pos > ind) {\n            if (!weCan && kol[pos-1] == kol[pos])\n                No();\n            weCan = true;\n            kol[pos] += 1;\n        }\n        else {\n            kol[pos] = min(kol[pos-1], kol[pos] + 1);\n        }\n    }\n\n    //cerr << ind << ' ' << kol[ind] << \"\\n\";\n    if (kol[ind] < n)\n        No();\n    cout << \"Yes\\n\"; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m;\nint q;\nint a[125252];\nbool used[125252];\nint t[125252];\nint t_i;\nint rev[125252];\nint cnt[125252];\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&q);\n  REP(i,q)scanf(\"%d\",a+i),--a[i];\n  // calc target sequence\n  t_i = 0;\n  FORR(i,0,q){\n    int c = a[i];\n    if(used[c])continue;\n    used[c] = true;\n    t[t_i++] = c;\n  }\n  REP(i,m){\n    if(!used[i])t[t_i++] = i;\n  }\n  REP(i,m){\n    rev[t[i]] = i;\n  }\n  // split\n  cnt[0] = n;\n  FORR(i,0,q){\n    int c = a[i];\n    int id = rev[c];\n    if(cnt[id]>0){\n      cnt[id]--;\n      cnt[id+1]++;\n    }\n  }\n  REP(i,m){\n    if(cnt[i]>0){\n      bool flag = true;\n      FOR(j,i,m-1){\n        if(t[j]>t[j+1]){\n          flag = false;\n          break;\n        }\n      }\n      puts(flag?\"Yes\":\"No\");\n      break;\n    }\n    if(i==m-1){\n      puts(\"Yes\");\n      break;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  if(a.back()==1){\n    Int k=1,flg=1;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]<=k) continue;\n      if(a[i]>k+1){\n\tflg=0;\n\tbreak;\n      }\n      k++;\n    }\n    if(flg){\n      cout<<\"Yes\"<<endl;\n      return 0;\n    }\n  }\n  assert(n>=300);\n  vector<Int> used(m+1,0);\n  vector<Int> dp(q,n);\n  int lst=-1;\n  for(Int b=q-1;b>=0;b--){\n    if(used[a[b]]) continue;\n    if(dp[0]<n){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    used[a[b]]=1;\n    lst=a[b];\n    //cout<<a[b]<<endl;\n    vector<Int> nx(q);\n    Int k=0;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]==a[b]) k++;\n      if(k>dp[i]) k=dp[i];\n      nx[i]=k;\n    }\n    swap(dp,nx);\n  }\n  if(lst!=1&&dp[0]<n){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tif(d[1]) e[1]=d[1];\n\n\tfor(int i=2; i<=M; i++){\n\n\t\tif(d[i]==0||e[i-1]==INF) e[i]=INF;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]>=e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=e[i-1];\n\t\t}\n\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]==0) f[i]=1;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vi a(q);\n  rep (i, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  //DEBUG_VEC(a);\n  \n  vi used(q, -1);\n  int used_cnt = 0;\n  vector<bool> used_x(m);\n  vi pre_idx(n, inf);\n  int idx = q - 1;\n  while (true) {\n    int nex = 0;\n    rrep (i, q) {\n      while (nex < m and used_x[nex]) nex++;\n      if (used_x[a[i]]) continue;\n      if (a[i] == nex) {\n        nex = a[i] + 1;\n      }\n      else if (a[i] < nex) continue;\n      else {\n        nex = inf;\n        break;\n      }\n    }\n    if (nex != inf) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(pre);\n    //DEBUG(idx);\n    while (idx >= 0) {\n      if (used_x[a[idx]]) idx--;\n      else break;\n    }\n    if (idx == -1) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(idx);\n\n    used_x[a[idx]] = true;\n    pre_idx[0] = idx;\n    int j = 1;\n    for (int i = idx - 1; i >= 0; i--) {\n      if (a[i] == a[idx] and i < pre_idx[j]) {\n        pre_idx[j] = i;\n        j++;\n      }\n      if (j == n) break;\n    }\n    if (j < n) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 1e9+7;\nconst int MAXN = 1e5+5;\n\nint n, m, q;\nint a[MAXN], take[MAXN];\nvector<int> pl[MAXN];\n\nmap<int, int> s;\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> a[i]; a[i]--;\n\t\tpl[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t\ts[i] = 1;\n\n\tfor (int i = 0; i < n; ++i)\n\t\ttake[i] = q;\n\tfor (int i = q-1; i >= 0; --i) {\n\t\tif (s.empty())\n\t\t\tbreak;\n\t\tif (s.count(a[i]) == 0)\n\t\t\tcontinue;\n\t\tint fir = (*s.begin()).first;\n\t\ts.erase(a[i]);\n\t\tint ct = n-1;\n\t\tif (fir == a[i]) {\n\t\t\tfor (int j = pl[a[i]].size()-1; j >= 0; --j) {\n\t\t\t\tif (ct == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pl[a[i]][j] <= take[ct]) {\n\t\t\t\t\tct--; take[ct] = pl[a[i]][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = ct; j >= 0; --j)\n\t\t\t\ttake[ct] = -1;\n\t\t} else {\n\t\t\tfor (int j = pl[a[i]].size()-1; j >= 0; --j) {\n\t\t\t\tif (ct == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pl[a[i]][j] <= take[ct]) {\n\t\t\t\t\tct--; take[ct] = pl[a[i]][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ct >= 0) {\n\t\t\t\tcout << \"No\\n\"; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 2e6 + 5;\nint was[N];\n//int last[N];\nint inv[N];\nint a[N];\nint got[N];\nvoid Exit(string s) {\n  cout<<s<<endl;\n  exit(0);\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m, q;\n  cin>>n>>m>>q;\n  RE (i, q) {\n    cin>>a[i];\n   // occ[a[i]].PB(i);\n  }\n  \n  VI ord{0};\n  \n  \n  FORD (i, q, 1) {\n    if (was[a[i]]) { continue; }\n    ord.PB(a[i]);\n    was[a[i]] = 1;\n  }\n  RE (i, m) {\n    if (!was[i]) {\n      ord.PB(i);\n    }\n  }\n  RE (i, m) {\n    inv[ord[i]] = i;\n  }\n  got[0] = n;\n  FORD (i, q, 1) {\n    if (got[ord[inv[a[i]] - 1]] > got[a[i]]) {\n      got[a[i]]++;\n    }\n  }\n  bool lacked = false;\n  RE (i, m) {\n    if (lacked) {\n      if (ord[i] < ord[i - 1]) {\n        Exit(\"No\");\n      }\n    }\n    if (got[a[i]] < n) {\n      lacked = true;\n    }\n  }\n  Exit(\"Yes\");\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N,M; cin >> N >> M;\n    int Q; cin >> Q;\n    vector<int> A(Q);\n    rep(i,Q) cin >> A[i];\n\n    map<int, int> dic;\n    dic.emplace(0,0);\n    vector<int> idx = {0};\n    vector<int> cnt = {N};\n    for (int i = Q-1, cur = 1; i >= 0; i--) {\n        if (dic.count(A[i])) {\n            int id = dic[A[i]];\n            if (cnt[id-1]==cnt[id]) continue;\n            cnt[id]++;\n        } else {\n            dic[A[i]] = cur++;\n            idx.emplace_back(A[i]);\n            cnt.emplace_back(1);\n        }\n    }\n\n    rep(i,SZ(idx)) {\n        if (cnt[i]!=N) {\n            if (!dic.count(1)) {\n                cout << \"No\" << ln;\n                return 0;\n            }\n            int n = dic[1];\n            if (i < n) {\n                cout << \"No\" << ln;\n                return 0;\n            }\n            int id = 1;\n            for (int j = n; j < SZ(idx); j++) {\n                if (idx[j]!=id) {\n                    cout << \"No\" << ln;\n                    return 0;\n                }\n                id++;\n            }\n            break;\n        }\n    }\n\n    cout << \"Yes\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define sz(a) (int)(a).size()\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n\nstruct node\n{\n    map<int, int> m;\n};\n\nvector<node> t;\nvector<int> a;\n\nvoid build(int v, int tl, int tr)\n{\n    if (tl == tr) {\n        t[v].m[a[tl]] = tl;\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    build(v * 2, tl, tm);\n    build(v * 2 + 1, tm + 1, tr);\n    t[v].m = t[v * 2].m;\n    for (auto it : t[v * 2 + 1].m) {\n        t[v].m[it.first] = it.second;\n    }\n}\n\nint get(int v, int tl, int tr, int l, int r, int val)\n{\n    if (l > r) {\n        return -1;\n    }\n    if (tl == l && tr == r) {\n        if (t[v].m.count(val)) {\n            return t[v].m[val];\n        } else {\n            return -1;\n        }\n    }\n    int tm = (tl + tr) >> 1;\n    int ans = -1;\n    if (r > tm) {\n        ans = max(ans, get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, val));\n    }\n    if (ans != -1) {\n        return ans;\n    }\n    if (l <= tm) {\n        ans = max(ans, get(v * 2, tl, tm, l, min(r, tm), val));\n    }\n    return ans;\n}\n\nvoid kill(int v, int tl, int tr, int pos)\n{\n    if (tl == tr) {\n        t[v].m.clear();\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    if (pos <= tm) {\n        kill(v * 2, tl, tm, pos);\n    } else {\n        kill(v * 2 + 1, tm + 1, tr, pos);\n    }\n    t[v].m.erase(a[pos]);\n    if (t[v * 2 + 1].m.count(a[pos])) {\n        t[v].m[a[pos]] = t[v * 2 + 1].m[a[pos]];\n    } else if (t[v * 2].m.count(a[pos])) {\n        t[v].m[a[pos]] = t[v * 2].m[a[pos]];\n    }\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    int q;\n    scanf(\"%d\", &q);\n    vector<int> ptr(n, q - 1);\n\n    a.resize(q);\n    vector<vector<int> > positions(m + 1);\n    for (int i = 0; i < q; ++i) {\n        scanf(\"%d\", &a[i]);\n        positions[a[i]].pb(i);\n    }\n\n    t.resize(4 * q);\n    build(1, 0, q - 1);\n\n    set<int> dead;\n    int curr = 1;\n    for (int i = q - 1; i >= 0; --i) {\n        if (dead.count(a[i])) {\n            continue;\n        }\n        for (int j = 0; j < n; ++j) {\n            if (ptr[j] == -1) {\n                break;\n            }\n            if (j) {\n                ptr[j] = min(ptr[j], ptr[j - 1] - 1);\n            }\n            int x = get(1, 0, q - 1, 0, ptr[j], a[i]);\n            if (x == -1) {\n                ptr[j] = -1;\n                for (int s = j + 1; s < n; ++s) {\n                    ptr[s] = -1;\n                }\n                break;\n            } else {\n                ptr[j] = x;\n            }\n            //cout << \"!\" << j << \" \" << ptr[j] << \"\\n\";\n        }\n        if (ptr.back() == -1) {\n            if (a[i] != curr) {\n                cout << \"No\\n\";\n                return 0;\n            }\n        }\n        dead.insert(a[i]);\n        while (dead.count(curr)) {\n            ++curr;\n        }\n        for (int x : positions[a[i]]) {\n            kill(1, 0, q - 1, x);\n        }\n    }\n    cout << \"Yes\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(m);\n  set<int> st;\n  REP(i,n){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n\n  REP(i,n) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,n){\n    c[i] = min(c[i]+1,m);\n    if(i && c[i-1] < c[i]) ng();\n  }\n\n  REP(i,c.size()) if(c[i]<m) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      j=0;\n      for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n      if(j!=k&&c[k]!=q) f=false; \n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n\n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5;\nint a[N],st[N],pos[N],cnt[N],vis[N];\nint n,m,q,top,p;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfp(i,1,q)scanf(\"%d\",&a[i]);\n\tfd(i,q,1)if(!vis[a[i]])st[++top]=a[i],vis[a[i]]=1;\n\tfp(i,1,m)if(!vis[i])st[++top]=i;\n\tfp(i,1,top)pos[a[i]]=i;\n\tp=top;\n\twhile(p>1&&st[p-1]<st[p])--p;\n\tif(p==1)return puts(\"Yes\"),0;\n\tcnt[0]=233333;\n\tfd(i,q,1)if(cnt[pos[a[i]]-1])--cnt[pos[a[i]]-1],++cnt[pos[a[i]]];\n\tR int res=0;\n\tfp(i,p-1,n)res+=cnt[i];\n\tputs(res>=n?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nvector<int> cnt[N];\n\nbool check(vector<vector<int>> vvs, int n) {\n    sort(vvs.rbegin(), vvs.rend());\n    for (auto &v: vvs) {\n        if (v.size() < n)\n            return false;\n    }\n\n    for (int i=0; i<n; i++) {\n        for (int j=1; j<vvs.size(); j++) {\n            if (vvs[j][i] > vvs[j-1][i])\n                return false;\n        }\n    }\n    return true;\n}\n\n\nbool check2(int k) {\n    for (int i=2; i<=k; i++)\n        if (cnt[i][0] > cnt[i-1][0])\n            return false;\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m, q;\n    cin>>n>>m>>q;\n\n    for (int i=1; i<=q; i++) {\n        int x;\n        cin>>x;\n        cnt[x].push_back(i);\n    }\n\n    vector<vector<int>> vvs;\n    int mx = 0;\n    for (int i=1; i<=m; i++) {\n        reverse(cnt[i].begin(), cnt[i].end());\n        if (i == 1) {\n            while (cnt[i].size() < n)   cnt[i].push_back(0);\n        }\n        if (cnt[i].size())  vvs.push_back(cnt[i]), mx = i;\n    }\n\n    if (check(vvs, n)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n    if (mx == vvs.size() && check2(mx)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n\n    cout<<\"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << (x) << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, m;\n\tcin >> n >> m;\n\tint q;\n\tcin >> q;\n\tvector<int> a(q);\n\trep(i, q) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\treverse(all(a));\n\tvector<int> pl(m, -1), cnt(m), val(m);\n\tint idx = 0;\n\trep(i, q) {\n\t\tif (pl[a[i]] == -1) {\n\t\t\tpl[a[i]] = idx;\n\t\t\tval[pl[a[i]]] = a[i];\n\t\t\tidx++;\n\t\t\tcnt[pl[a[i]]]++;\n\t\t}\n\t\telse {\n\t\t\tint p = pl[a[i]];\n\t\t\tif (p == 0 || cnt[p - 1] > cnt[p]) {\n\t\t\t\tif (cnt[p] < n) cnt[p]++;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> vec;\n\trep(i, m) if (cnt[i] != 0 && cnt[i] != n) vec.pb(val[i]);\n\trep(i, m) if (pl[i] == -1) vec.pb(i);\n\tbool flag = true;\n\tint sz = vec.size();\n\trep(i, sz - 1) if (vec[i] > vec[i + 1]) flag = false;\n\tcout << (flag ? \"Yes\" : \"No\") << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tvector<ll> cnt(m, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(cnt[pos] == n) continue;\n\t\t\tif(pos != 0 && cnt[pos - 1] <~ cnt[pos]) continue;\n\t\t\tcnt[pos]++;\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\tcnt[ite]++;\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(cnt[i] == 0 || cnt[i] == n) continue;\n\t\tif(i != 0 && cnt[i - 1] != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (0 <= idx && idx < m) {\n      exit(0);\n    }\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define epr(...) fprintf(stderr, __VA_ARGS__)\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\"; \n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define all(a) (a).begin(), (a).end()\n\n#define equal equalll\n#define less lesss\nconst int N = 1e6 + 10;\nconst long long INF = 1e9 + 19;\n\nint n, m;\nint q;\nint a[N];\n\nvoid read() {\n\tif (scanf(\"%d%d%d\", &n, &m, &q) != 3)\n\t\texit(0);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n}\n\n\nvoid solve() {\n\tvector < bool > use(m);\n\tvector < int > answer;\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tif (!use[a[i]]) {\n\t\t\tanswer.pb(a[i]);\n\t\t\tuse[a[i]] = 1;\n\t\t}\n\t}\n\tint r = answer.size();\n\tfor (int i = 0; i < m; i++)\n\t\tif (!use[i])\n\t\t\tanswer.pb(i);\n\n\t//for (auto x: answer)\n\t\t//cerr << x << \" \";\n\t//cerr << endl;\n\n\tint l = r;\n\t//db(r);\n\t//db(m);\n\tfor (; ;) {\n\t\tif (l == 0) break;\n\t\tif (l < m) {\n\t\t\tif (!(answer[l - 1] < answer[l]))\n\t\t\t\tbreak;\n\t\t}\n\t\tl--;\n\t}\n\t\t\t//l > 0 && ((l == m && answer[l - 1] == m - 1) || answer[l - 1] < answer[l]); l--);\n\t//db2(l, r);\n\tvector < int > b(n, -1);\n\tvector < int > rev(m);\n\tfor (int i = 0; i < m; i++)\n\t\trev[answer[i]] = i;\n\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tint x = a[i];\n\t\tint pos = rev[x] - 1;\n\t\t//db2(\"find: \", pos);\n\t\tint posB = upper_bound(b.begin(), b.end(), pos) - b.begin() - 1;\n\t\tif (posB != -1 && b[posB] == pos) {\n\t\t\tb[posB]++;\t\n\t\t}\n\t}\n\n\t//cerr << \"b: \";\n\t//for (int i = 0; i < n; i++)\n\t\t//cerr << b[i] << \" \";\n\t//cerr << endl;\n\n\tbool flag = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tflag &= l - 1 <= b[i];\n\n\t\n\tif (flag)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n\n\n}\n\nvoid stress() {\n\n}\n\nint main(){\n#ifdef MY_DEBUG\n    freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n#endif\n    if (1) {\n        int k = 1000;\n        for (int tt = 0; tt < k; tt++) {\n            read();\n            solve();\n        }\n    }\n    else {\n        stress();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nconst int N=1e5+10;\nint n,m,q,num[N],cnt,sum[N],pos[N],a[N];\nbool vis[N];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"LRU Puzzle.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,m,q);\n\tfor(int i=1;i<=q;i++) read(a[i]);\n\tfor(int i=q;i;i--)\n\t{\n\t\tif(!vis[a[i]])\n\t\t{\n\t\t\tnum[++cnt]=a[i];\n\t\t\tpos[a[i]]=cnt;\n\t\t\tvis[a[i]]=1;\n\t\t}\n\t}\n\tfor(int i=1, cnt2=0;i<=m;i++) if(!vis[i]) num[cnt+(++cnt2)]=i;\n\tsum[0]=n;\n\tfor(int i=q;i;i--)\n\t{\n\t\tint tt=pos[a[i]];\n\t\tif(sum[tt-1])\n\t\t{\n\t\t\tsum[tt-1]--;\n\t\t\tsum[tt]++;\n\t\t}\n\t}\n\tint st=n;\n\tfor(int i=0;i<=cnt;i++) \n\t{\n\t\tif(sum[i])\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=st+2;i<=cnt+1;i++)\n\t{\n\t\tif(num[i]<num[i-1])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = n + Q;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i-1]]){\n\t\t\tf[a[i-1]]--;\n\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    int mx=0,cr=0;\n    vi f(q);\n    for(int i=0;i<q;i++){\n        inmax(mx,b[i]);\n        inmax(cr,b[i]);\n        if(cr==b[i]+1)\n            cr--;\n        else if(cr>b[i]+1){\n            cr=mx;\n        }\n        if(cr==1){\n            mx=1;\n            f[i]=1;\n        }\n    }\n    if(mx==1){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, int> PLDI;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nconst LL MOD = 1e9+7;\nconst LL INF = (1e18);\nconst double EPS=1.0e-9;\nconst double PI=atan2(0,-1);\n\n\n\nint main()\n{\n    int n,m,q;\n    cin>>n>>m>>q;\n    vector<int> a(q);\n    REP(i,q)\n        cin>>a[i];\n    \n    bool used[100001];\n    vector<int> b;\n    CLR(used);\n    b.reserve(q);\n    for(int i=q-1;i>=0;i--)\n    {\n        if(!used[a[i]])\n            b.push_back(a[i]);\n    }\n    REP(i,m)\n    {\n        if(!used[i+1])\n            b.push_back(i+1);\n    }\n    vector<int> c(m+1);\n    REP(i,m)\n        c[b[i]]=i+1;\n    \n    bool flag=1;\n    vector<int> d(m+2);\n    d[0]=n;\n    for(int i=q-1;i>=0;i--)\n    {\n        d[c[a[i]]-1]--;\n        if(d[c[a[i]]-1]<0)\n        {\n            d[c[a[i]]-1]=0;\n            //flag=0;\n            //break;\n        }\n        d[c[a[i]]]++;\n    }\n    \n    CLR(used);\n    //used[0]=1;\n        int k=1;\n    REP(i,m+2)\n    {\n        if(d[i]==0)continue;\n        \n        for(int j=0;j<i;j++)\n            used[b[j]]=1;\n        \n        FOR(j,i,m)\n        {\n            if(used[k])\n            {\n                k++; j--;\n                continue;\n            }\n            if(k!=b[j])\n            {\n                flag=0;\n                break;\n            }\n            k++;\n        }\n        \n        break;\n    }\n    \n    if(flag)\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=1; i<=m; i++) b[i]=-1;\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  m=v.size();\n  if (b[1]!=-1) {\n    for (i=b[1]+1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) m=b[1];\n  }\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=min(n,(j>0)?min(f[j]+1,f[j-1]):(f[j]+1));\n  }\n  puts((m==0 || f[m-1]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, q;\n\nvector<int> order;\nint place[112123];\nint ops[112123];\nint seen[112123];\n\nint main()\n{\n\tfill(place, place + 112123, -1);\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tcin >> ops[i];\n\t}\n\tfor (int i = q-1; i >= 0; i--)\n\t{\n\t\tint x = ops[i];\n\t\tif (place[x] == -1)\n\t\t{\n\t\t\tplace[x] = order.size();\n\t\t\torder.push_back(x);\n\t\t}\n\t\tif (place[x] == 0 || seen[order[place[x]-1]] > seen[x])\n\t\t\tseen[x]++;\n\t}\n\tbool good = true;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x = i;\n\t\tif (place[x] == -1)\n\t\t{\n\t\t\tplace[x] = order.size();\n\t\t\torder.push_back(x);\n\t\t}\n\t\tif (place[x] == 0)\n\t\t\tseen[x] = n;\n\t\telse if (seen[order[place[x]-1]] > seen[x])\n\t\t\tseen[x] = seen[order[place[x]-1]];\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (seen[i] < n) good = false;\n\tif (good) cout << \"Yes\\n\";\n\telse cout << \"No\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 10;\n\nbool vis[N];\nint n,m,q,a[N],cnt[N],p[N];\nvi order;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m >> q;\n    forn(i,q) cin >> a[i], a[i]--;\n    dforsn(i,0,q) if (!vis[a[i]]) {\n        order.pb(a[i]);\n        vis[a[i]] = true;\n    }\n    //m = si(order);\n    forn(i,m) if (!vis[i]) order.pb(i);\n    forn(i,si(order)) p[order[i]] = i;\n\n    bool ok = true;\n    cnt[0] = n;\n    dforsn(i,0,q) {\n        int pos = p[a[i]];\n        if (cnt[pos]) {\n            cnt[pos]--;\n            cnt[pos+1]++;\n        }\n        else if (cnt[pos+1] || cnt[m]);\n        else ok = false;\n    }\n\n    int least;\n    forn(i,N) if (cnt[i]) {\n        least = i;\n        break;\n    }\n\n    vi norder;\n    memset(vis,0,sizeof vis);\n    forn(i,least) {\n        norder.pb(order[i]);\n        vis[order[i]] = true;\n    }\n    forn(i,m) if (!vis[i]) norder.pb(i);\n    \n    ok &= norder == order;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, m, q;\n\t\tin >> n >> m >> q;\n\t\tvector<int> v(q);\n\t\tfor (int i: range(q)) {\n\t\t\tin >> v[i];\n\t\t\t--v[i];\n\t\t}\n\n\t\tvector<vector<int>> changesTimes(m);\n\n\t\tfor (int i: range(q)) {\n\t\t\tchangesTimes[v[i]].push_back(i);\n\t\t}\n\n\t\tmap<int, int> halves;\n\t\tvector<vector<int>> intr;\n\t\tint minUnused = n;\n\t\tfor (int i: range(m)) {\n\t\t\tsort(changesTimes[i]);\n\t\t\tif (changesTimes[i].size() >= n) {\n\t\t\t\tintr.emplace_back(changesTimes[i].end() - n, changesTimes[i].end());\n\t\t\t} else if (changesTimes[i].size() > 0) {\n\t\t\t\thalves[i] = changesTimes[i].back();\n\t\t\t} else {\n\t\t\t\tminUnused = min(minUnused, i);\n\t\t\t}\n\t\t}\n\n\n\t\tint lastPos = 1000000;\n\t\tfor (auto p: halves) {\n\t\t\tif (p.first > minUnused) {\n\t\t\t\tout << \"No\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (p.second > lastPos) {\n\t\t\t\tout << \"No\\n\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastPos = p.second;\n\t\t}\n\n\n\n\t\tif (intr.size() > 0) {\n\t\t\tsort(intr);\n\t\t\tfor (int i: range(n)) {\n\t\t\t\tfor (int j: range(1, (int)intr.size())) {\n\t\t\t\t\tif (intr[i][j] < intr[i][j - 1]) {\n\t\t\t\t\t\tout << \"No\\n\";\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout << \"Yes\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    unordered_map<int, int> X;\n    vector<int> order;\n    vector<int> num;\n    stack<int> S;\n    unordered_set<int> us;\n    int a, b, c;\n    for (int q = 0;q < Q;q++) {\n    \tcin >> a;\n    \tS.push(a);\n    }\n    while (S.size() > 0) {\n    \ta = S.top();\n    \tS.pop();\n    \tif (X.find(a) == X.end()) {\n    \t\tb = X.size();\n    \t\tX[a] = b;\n    \t}\n    \tb = X[a];\n    \tif (b >= order.size()) {\n    \t\torder.push_back(a);\n    \t\tus.insert(a);\n    \t}\n    \tif (b >= num.size()) num.push_back(0);\n    \tif (b == 0 && num[0] < N) num[0]++;\n    \telse {\n    \t\tif (num[b - 1] > num[b]) num[b]++;\n    \t}\n    }\n    vector<int> rem;\n    for (int i = 0;i < order.size();i++) {\n    \tif (num[i] != N) rem.push_back(order[i]);\n    }\n    for (int i = 1;i <= M;i++) {\n    \tif (us.find(i) == us.end()) rem.push_back(i);\n    }\n    vector<int> g = rem;\n    sort(g.begin(), g.end());\n    if (g == rem) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  int lo = S.size();\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1){\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <ctime>\n\nusing namespace std;\n\nint main()\n{\n\tint i;\n\n\tsrand((unsigned int)time(NULL));\n\tif (rand() % 2 == 0) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tif(d[1]) e[1]=d[1];\n\n\tfor(int i=2; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]){\n\t\t\te[i]=e[i-1];\n\t\t}else{\n\t\t\te[i]=INF;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nint main()\n{\n\tios_init();\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tint q;\n\t\tcin >> q;\n\t\tvector<int> a(q);\n\t\tREP(i,q) cin >> a[i], a[i]--;\n\t\tvector<int> v;\n\t\tv.reserve(m);\n\t\tvector<bool> f(m,false);\n\t\tRREP(i,q){\n\t\t\tif(!f[a[i]]){\n\t\t\t\tf[a[i]] = true;\n\t\t\t\tv.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tREP(i,m){\n\t\t\tif(!f[i]){\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint p = SZ(v)-1;\n\t\tRREP(i,SZ(v)-1){\n\t\t\tif(v[i+1] > v[i]){\n\t\t\t\tp--;\n\t\t\t}else break;\n\t\t}\n\t\tvector<int> mp(m,-1000);\n\t\tREP(i,SZ(v)){\n\t\t\tmp[v[i]] = i;\n\t\t}\n\t\tvector<int> cntv(m,0);\n\t\tdpite(ALL(mp));\n\t\tRREP(i,q){\n\t\t\tint po = mp[a[i]];\n\t\t\tif(po == 0 or cntv[po] < cntv[po-1]){\n\t\t\t\tcntv[po]++;\n\t\t\t}else{\n\n\t\t\t}\n\t\t}\n\t\tstring ans = \"Yes\";\n\t\tdpite(ALL(cntv));\n\t\tREP(i,p){\n\t\t\tif(cntv[i] < n){\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    assert (0 <= idx && idx < m);\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int last[Q];\n  int laststock = 0;\n  int lastcount[Q];\n  for(i=Q-1; i>=0; --i){\n    bool stocked = false;\n    for(j=0; j<laststock; ++j){\n      if(last[j] == a[i]){\n        if(j == 0 || lastcount[j] < lastcount[j-1]){\n          lastcount[j]++;\n        }\n        stocked = true;\n      }\n    }\n    if(!stocked){\n      last[laststock] = a[i];\n      lastcount[laststock] = 1;\n      laststock++;\n    }\n  }\n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  int p = 0;\n  int maxp = -1;\n  for(i=1; i<M+1; ++i){\n    while(p<laststock && last[p] != i){\n      ++p;\n    }\n    if(p >= laststock){break;}\n    if(p > maxp){\n      maxp = p;\n      lastcount[p] = N;\n    }\n  }\n  \n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  \n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid No() {\n    cout << \"No\\n\";\n    exit(0);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n, m, q;\n    cin >> n >> m >> q;\n    vector<int> qs(q, 0);\n    for (int i = 0; i < q; ++i) {\n        cin >> qs[i];\n        qs[i]--;\n    }\n\n    reverse(qs.begin(), qs.end());\n    vector<int> used(m, 0), seq;\n    for (int i = 0; i < q; ++i)\n        if (!used[qs[i]]) {\n            seq.push_back(qs[i]);\n            used[qs[i]] = 1;\n        }\n\n    for (int i = 0; i < m; ++i)\n        if (!used[i])\n            seq.push_back(i);\n    vector<int> myNum(m, -1);\n    for (int i = 0; i < m; ++i) {\n        myNum[seq[i]] = i;\n    //    cerr << seq[i] << ' ';\n    }\n    //cerr << \"\\n\";\n\n    int ind = m-1;\n    while (ind > 0 && seq[ind] > seq[ind-1])\n        --ind;\n    vector<int> kol(m+1, 0);\n    kol[0] = n;\n    bool weCan = false;\n    for (int i = 0; i < q; ++i) {\n        int v = seq[i];\n        int pos = myNum[v] + 1;\n        if (pos > ind) {\n            if (!weCan && kol[pos-1] == kol[pos])\n                No();\n            weCan = true;\n            kol[pos] += 1;\n        }\n        else {\n            kol[pos] = min(kol[pos-1], kol[pos] + 1);\n        }\n    }\n\n    //cerr << ind << ' ' << kol[ind] << \"\\n\";\n    if (kol[ind] < n)\n        No();\n    cout << \"Yes\\n\"; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 100010\n#define INF 1000000007\n\nint R, C;\nint n;\nvector<PII> A[N];\nll cm[N];\n\nint f[N]; ll g[N];\n\nint fa(int x) {\n\tif (f[x] == x) return x;\n\tint y = fa(f[x]);\n\tg[x] += g[f[x]];\n\tf[x] = y;\n\treturn y;\n}\n\nint main () {\n\tcin >> R >> C >> n;\n\tfor (int i = 0; i < C; i ++) cm[i] = INF;\n\tfor (int i = 0; i < n; i ++) {\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tx--, y--;\n\t\tA[x].pb(mp(y, z));\n\t\tcm[y] = min(cm[y], (ll)z);\n\t}\n\tfor (int i = 0; i < C; i++) f[i] = i;\n\tfor (int i = 0; i < R; i ++) {\n\t\tfor (int j = 0; j < (int) A[i].size()-1; j ++) {\n\t\t\tint u = A[i][j].fi;\n\t\t\tint v = A[i][j+1].fi;\n\t\t\tint x = fa(u);\n\t\t\tint y = fa(v);\n\t\t\tint dif = A[i][j+1].se - A[i][j].se;\n\t\t\tif (x == y) {\n\t\t\t\tif (g[v] - g[u] != dif) {\n\t\t\t\t\tputs (\"No\"); return 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf[y] = x;\n\t\t\t\tg[y] = dif - g[v] + g[u];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < C; i ++) {\n\t\tint y = fa(i);\n\t\tcm[y] = min(cm[y], cm[i] - g[i]);\n\t}\n\tfor (int i = 0; i < C; i ++) {\n\t\tint y = fa(i);\n\t\tcm[i] = min(cm[i], cm[y] + g[i]);\n\t\tif (cm[i] < 0) {\n\t\t\tputs (\"No\"); return 0;\n\t\t}\n\t}\n\tputs (\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n        ord[P[i].num] = i;\n    }\n    chk = 1;\n    for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    int ck = 0;\n    for(i=1;i<=n;i++){\n        if(P[i].num == 1)ck = 1;\n        if(R[i] < n && (!chk || !ck)){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(int i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{\n    long long start_, end_, step_;\n   public:\n    struct range_iterator{\n      long long val, step_;\n      range_iterator(long long v, long long step) : val(v), step_(step) {}\n      long long operator * (){return val;}\n      void operator ++ (){val += step_;}\n      bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;}\n    };\n    range(long long len) : start_(0), end_(len), step_(1) {}\n    range(long long start, long long end) : start_(start), end_(end), step_(1) {}\n    range(long long start, long long end, long long step) : start_(start), end_(end), step_(step) {}\n    range_iterator begin(){ return range_iterator(start_, step_); }\n    range_iterator   end(){ return range_iterator(  end_, step_); }\n  };\n\n  string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){\n    stringstream ss; for(int i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str();\n  }\n\n  string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n\n}\n\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  cin >> a;\n  for(auto i : range(q) ){\n    a[i]--;\n  }\n\n  reverse(a.begin(), a.end());\n\n  vector<int> res;\n  vector<int> ord(m, -1);\n\n  vector<int> cnt(m+1, 0);\n  cnt[0] = n;\n  for(int i=0; i<q; i++){\n    if(ord[a[i]] == -1){\n      ord[a[i]] = res.size();\n      if(cnt[ord[a[i]]] == 0){\n        cout << \"No\" << endl;\n        return 0;\n      }\n      cnt[ord[a[i]]]--;\n      cnt[ord[a[i]]+1]++;\n      res.push_back(a[i]);\n    }else{\n      if(cnt[ord[a[i]]] > 0){\n        cnt[ord[a[i]]]--;\n        cnt[ord[a[i]]+1]++;\n      }\n    }\n  }\n\n  set<int> unused;\n  for(int i=0; i<m; i++){\n    unused.insert(i);\n  }\n\n  for(int i=0; i<=m; i++){\n    if(cnt[i] != 0){\n      for(int j=0; j<i; j++){\n        unused.erase(res[j]);\n      }\n\n      for(int j=i; j<res.size(); j++){\n        if(res[j] != *unused.begin()){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        unused.erase(unused.begin());\n      }\n      break;\n    }\n  }\n\n  cout << \"Yes\" << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\nint ma[100005];\n\nint main()\n{\n\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  if(a.back()==1){\n    Int k=1,flg=1;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]<=k) continue;\n      if(a[i]>k+1){\n\tflg=0;\n\tbreak;\n      }\n      k++;\n    }\n    if(flg){\n      cout<<\"Yes\"<<endl;\n      return 0;\n    }\n  }\n  if(n<=300){\n    assert(0);\n  }\n  vector<Int> used(m+1,0);\n  vector<Int> dp(q,n);\n  int lst=-1;\n  for(Int b=q-1;b>=0;b--){\n    if(used[a[b]]) continue;\n    if(dp[0]<n&&a[b]<lst){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    used[a[b]]=1;\n    lst=a[b];\n    //cout<<a[b]<<endl;\n    vector<Int> nx(q);\n    Int k=0;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]==a[b]) k++;\n      if(k>dp[i]) k=dp[i];\n      nx[i]=k;\n    }\n    swap(dp,nx);\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid ng(){\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,q;\n  cin >> n >> m >> q;\n\n  vector<int> a(q);\n  REP(i,q) cin >> a[i], a[i]--;\n  \n  reverse(a.begin(),a.end());\n  vec b, id(n);\n  set<int> st;\n  REP(i,n){\n    if(st.find(a[i])==st.end()){\n      b.push_back(a[i]);\n      st.insert(a[i]);\n      id[a[i]] = b.size()-1;\n    }\n  }\n\n  REP(i,n) a[i] = id[a[i]];\n\n  vec c(b.size(),0);\n  REP(i,n){\n    c[i] = max(c[i]+1,m);\n    if(i && c[i-1] < c[i]) ng();\n  }\n\n  REP(i,c.size()) if(c[i]<m) ng();\n\n  cout << \"Yes\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    VI a(q);\n    REP(i,q) a[i] = in() - 1;\n    VI p;\n    set<int> st;\n    REP(i,m) st.insert(i);\n    FORR(i,q-1,0){\n        if (st.count(a[i])){\n            p.push_back(a[i]);\n            st.erase(a[i]);\n        }\n    }\n    for (int x : st) p.push_back(x);\n    VI idx(m);\n    REP(i,m) idx[p[i]] = i;\n\n    // REP(i,m) cout << p[i] << \" \";\n    // cout << endl;\n\n    // VI cnt(m);\n    // FORR(i,q-1,0){\n    //     int j = idx[a[i]];\n    //     cnt[j] = min(n, cnt[j] + 1);\n    //     if (j > 0 && cnt[j] > cnt[j - 1]){\n    //         cout << \"No\" << endl;\n    //         return 0;\n    //     }\n    // }\n\n    // int j = m - 1;\n    // while (j > 0 && p[j - 1] < p[j]) j--;\n    // REP(i,j){\n    //     if (cnt[i] != n){\n    //         cout << \"No\" << endl;\n    //         return 0;\n    //     }\n    // }\n\n    cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n//\tfor (PP p : seq) {\n//\t\tif (p.second == N) {\n//\t\t\tSet.erase(p.first);\n//\t\t} else {\n//\t\t\tif (*Set.begin() != p.first) {\n//\t\t\t\tok = false;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tSet.erase(p.first);\n//\t\t}\n//\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0; ) {\n    int da = 0;\n    for (; !Poz[br].empty(); ) {\n      if (Poz[br].back() < V[ind]) {\n        R.push_back(Poz[br].back());\n        da = 1;\n        ind--;\n      }\n\n      Poz[br].pop_back();\n    }\n\n    if (!da)\n      Nope();\n  }\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  int tmin = 1;\n  for (int i=q-1; i>=0; i--) {\n    for (; bio[tmin]; tmin++);\n\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] == tmin)\n      continue;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 505050;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(m, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(m, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(rmq.get(pos) == n) continue;\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) continue;\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint main(){\n\tint n=read(),m=read(),q=read();\n\tvi a;\n\tREP(i,q)a.PB(read()-1);\n\tvector<bool> used(m,false);\n\tvi t;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(!used[a[i]]){\n\t\t\tused[a[i]]=true;\n\t\t\tt.PB(a[i]);\n\t\t}\n\t}\n\tREP(i,m)if(!used[i])\n\t\tt.PB(i);\n\tvi idx(m);\n\tREP(i,m)\n\t\tidx[t[i]]=i;\n\tvi frek(m+1,0);\n\tfrek[0]=n;\n\tfor(int i=q-1;i>=0;i--){\n\t\tint k=idx[a[i]];\n\t\tif(frek[k]>0){\n\t\t\tfrek[k]--;\n\t\t\tfrek[k+1]++;\n\t\t}\n\t}\n\tREP(i,m+1)if(frek[i]>0){\n\t\tint last=-1;\n\t\tFOR(j,i,m)\n\t\t\tif(last<t[j]){\n\t\t\t\tlast=t[j];\n\t\t\t}else\n\t\t\t\tNo();\n\t\tbreak;\n\t}\n\tYes();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tfor(long long i = mini; i < M; i++){\n\t\tif(ans[i] != i){\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n \n    vec a(Q);\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n \n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n \n    que[M] = N - 1;\n \n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n \n    for(int i = 0; i < M; i++){\n        if(!used[i]){\n            used[i] = true;\n            if(prev >= 0) next[prev] = i;\n            prev = i;\n            que[i] += que[M];\n            que[M] = 0;\n        }\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n \n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\") \n#pragma warning(disable:4996)\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-10\n#define LL_INF 0x3fffffffffffffff\n#define INF 0x3f3f3f3f\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n\nconst int maxn = 1e5 + 5;\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\n\nint n, m;\nint q;\nint val[maxn], app[maxn], idx[maxn], res[maxn];\n\nvoid solve()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 1; i <= q; i++)\n\t{\n\t\tscanf(\"%d\", &val[i]);\n\t}\n\tvector<int>pre;\n\tfor (int i = q; i >= 1; i--)\n\t{\n\t\tif (app[val[i]] == 0)\n\t\t{\n\t\t\tapp[val[i]] = 1;\n\t\t\tidx[val[i]] = pre.size();\n\t\t\tpre.push_back(val[i]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (!app[i])\n\t\t{\n\t\t\tidx[i] = pre.size();\n\t\t\tpre.push_back(i);\n\t\t}\n\t}\n\tint sz = pre.size();\n\twhile (sz >= 2)\n\t{\n\t\tif (pre[sz - 2] > pre[sz - 1])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsz--;\n\t\t\tpre.pop_back();\n\t\t}\n\t}\n\tpre.pop_back();\n\tres[0] = n;\n\tfor (int i = q; i >= 1; i--)\n\t{\n\t\tif (res[idx[val[i]]])\n\t\t{\n\t\t\tres[idx[val[i]]]--;\n\t\t\tres[idx[val[i]] + 1]++;\n\t\t}\n\t}\n\tsz = pre.size();\n\tfor (int i = 0; i < sz;i++)\n\t{\n\t\tif (res[i])\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn;\n\t\t}\n\t }\n\tputs(\"Yes\");\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n//# pragma GCC target (\"sse4\")\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m,q;\n    static int s[1 << 20];\n    fi>>n>>m>>q;\n    for (int i = 1;i <= q;++i)\n        fi>>s[i];\n    vector < int > S;\n    static int was[1 << 20];\n    for (int i = 1;i <= m;++i)\n        was[i] = -1;\n    for (int i = q;i;--i)\n        if (was[s[i]] == -1)\n            S.push_back(s[i]),was[s[i]] = 1;\n    static int cnt[1 << 20];\n    cnt[0] = n;\n    int ok = 1;\n    for (int i = 0;i < S.size();++i)\n        ok &= S[i] == i + 1;\n    if (ok) return puts(\"Yes\") * 0;\n    int sz = S.size();\n    static int where[1 << 20];\n    for (int i = 0;i < sz;++i)\n        where[S[i]] = i + 1;\n    int until = sz;\n    for (int i = sz - 1;i;--i)\n        if (S[i] < S[i-1])\n            --until;\n        else\n            break;\n    for (int i = q;i;--i)\n    {\n        const int index = where[s[i]] - 1;\n        if (cnt[index])\n            --cnt[index],++cnt[index + 1];\n    }\n    fo << (*max_element(cnt,cnt+until) ? \"No\" : \"Yes\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nconst int DEBUG = 0;\n\nconst int N = 100010;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  assert (0 <= tol && tol < m);\n  VI inv_t(m);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    int idx = inv_t[op[i]];\n    if (prog[idx] == 0 && !pass[idx]) {\n      return false;\n    }\n    if (prog[idx] == 0) {\n      continue;\n    }\n    prog[idx]--;\n    prog[idx + 1]++;\n    pass[idx] = 1;\n  }\n  if (DEBUG) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  VI a(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  vector<bool> used(m);\n  int cur = 0;\n  VI target(m);\n  REP(i, 0, q) {\n    if (used[a[i]]) {\n      continue;\n    }\n    used[a[i]] = 1;\n    target[cur] = a[i];\n    cur++;\n  }\n  REP(i, 0, m) {\n    if (!used[i]) {\n      target[cur++] = i;\n    }\n  }\n  assert (cur == m);\n  int oldcur = m - 1;\n  while (oldcur > 0) {\n    if (target[oldcur - 1] < target[oldcur]) {\n      oldcur--;\n    } else {\n      break;\n    }\n  }\n  if (DEBUG) {\n    cerr << \"target:\";\n    REP(i, 0, m) {\n      cerr << \" \" << target[i];\n    }\n    cerr << endl << \"tol = \" << oldcur << endl;\n  }\n  cout << (match(n, m, target, a, oldcur) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n \nconst int MAXN = 1E5 + 10;\n \nint n, m, Q;\nint a[MAXN];\nint b[MAXN], id[MAXN];\nbool vis[MAXN];\nint cnt[MAXN];\n \nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor (int i = 1; i <= Q; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int k = 0, j = Q; j > 0; --j)\n\t\tif (!vis[a[j]])\n\t\t\tb[++k] = a[j], vis[a[j]] = true;\n\tfor (int j = m, i = m; i > 0; --i)\n\t\tif (!vis[i])\n\t\t\tb[j--] = i;\n\tfor (int i = 1; i <= m; ++i)\n\t\tid[b[i]] = i;\n \n\tbool flag = true;\n\tcnt[0] = n;\n\tfor(int i=1;i<=m;++i) vis[i]=0;\n\tfor (int i = Q; i > 0; --i){\n\t\tint t = id[a[i]];\n\t\tif (cnt[t - 1] > 0){\n\t\t\t--cnt[t - 1];\n\t\t\t++cnt[t];\n\t\t\tvis[t] = true;\n\t\t}\n\t\telse if (!vis[t]){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n \n\tint l;\n\tfor (l = 0; cnt[l] == 0; ++l);\n\tfor (int i = l + 1; i < m; ++i)\n\t\tflag &= b[i] < b[i + 1];\n\tputs(flag ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint cnt[101010];\nint a[101010];\nint t[101010],tn;\nbool vis[101010];\nint main()\n{\n\tint n,m,q,mi=1;\n\tbool mk=false;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(vis,0,sizeof(vis));\n\ttn=0;\n\tfor(int i=q;i>=1;i--)\n\t{\n\t\tif(!cnt[a[i]])\n\t\t\tt[++tn]=a[i];\n\t\tcnt[a[i]]++;\n\t}\n\tfor(int i=1;i<=tn;i++)\n\t\tif(cnt[t[i]]<n)\n\t\t{\n\t\t\twhile(vis[mi])\n\t\t\t\tmi++;\n\t\t\tvis[t[i]]=true;\n\t\t\tif(mi!=t[i])\n\t\t\t{\n\t\t\t\tprintf(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint q;\nint a[100011];\nint b[100011];\nint lenb;\n\n\nbool has[100011];\n\nint calc[100011];\n\nint atob[100011];\n\n\nint main()\n{\n\tint i,j;\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tmemset(has,0,sizeof(has));\n\tmemset(atob,0,sizeof(atob));\n\tlenb=0;\n\tfor(i=q;i>=1;i--)\n\t{\n\t\tif(has[a[i]]==0)\n\t\t{\n\t\t\thas[a[i]]=1;\n\t\t\tlenb++;\n\t\t\tb[lenb]=a[i];\n\t\t\tatob[a[i]]=lenb;\n\t\t}\n\t}\n\t\n\tint temp=0x3f3f3f3f;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tif(has[i]==0)\n\t\t{\n\t\t\ttemp=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\twhile(lenb>0 && b[lenb]<temp)\n\t{\n\t\ttemp=b[lenb];\n\t\tlenb--;\n\t}\n\t\n\t\n\t\n\t\n\tmemset(calc,0,sizeof(calc));\n\tcalc[1]=n;\n\tint maxlen=1;\n\tfor(i=q;i>=1;i--)\n\t{\n\t\tint pos=atob[a[i]];\n\t\t\n\t\tif(pos>lenb)continue;\n\t\t\n\t\t\n\t\tif(calc[pos]>0)\n\t\t{\n\t\t\tcalc[pos]--;\n\t\t\tcalc[pos+1]++;\n\t\t\t\n\t\t\tmaxlen=max(maxlen,pos+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pos<=maxlen)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tcout<<i<<\"    \"<<lenb<<\"  i\"<<endl;\n\t\tfor(j=1;j<=10;j++)\n\t\t{\n\t\t\tcout<<calc[j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t\t*/\n\t\t\n\t}\n\tif(i>=1)\n\t{\n\t\tcout<<\"No\"<<endl;\n\t\treturn 0;\n\t}\n\t\n\t\n\tif(maxlen==lenb+1 && calc[lenb+1]==n)\n\t{\n\t\tcout<<\"Yes\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  if(F){\n    vector<int> V;\n    int K=0;\n    for(int i=0;i<m;i++){\n      if(P[i]==-1||C[P[i]]<n){\n\tV.push_back(i);\n      }\n      else{\n\tK++;\n      }\n    }\n    for(int i=K;i<N;i++){\n      if(T[i]!=V[i]){\n\tF=0;\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nconst int N=1e5+10;\nint n,m,q,num[N],cnt,sum[N],pos[N],a[N];\nbool vis[N];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"LRU Puzzle.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n,m,q);\n\tfor(int i=1;i<=q;i++) read(a[i]);\n\tfor(int i=q;i;i--)\n\t{\n\t\tif(!vis[a[i]])\n\t\t{\n\t\t\tnum[++cnt]=a[i];\n\t\t\tpos[a[i]]=cnt;\n\t\t\tvis[a[i]]=1;\n\t\t}\n\t}\n\tfor(int i=1, cnt2=0;i<=m;i++) if(!vis[i]) num[cnt+(++cnt2)]=i;\n\tsum[0]=n;\n\tfor(int i=q;i;i--)\n\t{\n\t\tint tt=pos[a[i]];\n\t\tif(sum[tt-1])\n\t\t{\n\t\t\tsum[tt-1]--;\n\t\t\tsum[tt]++;\n\t\t}\n\t}\n\tint st=n;\n\tfor(int i=0;i<=cnt;i++) \n\t{\n\t\tif(sum[i])\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=st+2;i<=m;i++)\n\t{\n\t\tif(num[i]<num[i-1])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n\n#undef __STRICT_ANSI__\n\n#include <cstdlib>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <cassert>\n\nusing namespace std;\n\n#undef assert\n#define assert(e)\n\n#include <cstdarg>\n\n#include <sys/time.h>\n\nclass XsRandom {\n\tunsigned long long a;\n\tunsigned long long b;\npublic:\n\tinline XsRandom() : a(0x8a5cd789635d2dffULL), b(0x121fd2155c472f96ULL) {\n\t}\n\tinline XsRandom(const XsRandom & o) : a(o.a), b(o.b) {\n\t}\n\tinline unsigned long long next64() {\n\t\tunsigned long long c = a ^ (a<<23);\n\t\ta = b;\n\t\tb = c ^ a ^ (c>>18) ^ (a>>5);\n\t\treturn b + a;\n\t}\n\tinline XsRandom(unsigned int seed) : a(0x8a5cd789635d2dffULL), b(0x121fd2155c472f96ULL) {\n\t\tseed = seed * 1234567891 + 521288629;\n\t\tunsigned long long a2 = a;\n\t\tunsigned long long b2 = b;\n\t\twhile(seed) {\n\t\t\tnext64();\n\t\t\tif(seed & 1) {\n\t\t\t\ta2 ^= a;\n\t\t\t\tb2 ^= b;\n\t\t\t}\n\t\t\tseed >>= 1;\n\t\t}\n\t\ta = a2;\n\t\tb = b2;\n\t}\n\tinline unsigned int next() {\n\t\treturn (unsigned int)next64();\n\t}\n\tinline int nextInt(int r) {\n\t\tassert(1<=r);\n\t\treturn ((unsigned long long)next() * r)>>32;\n\t}\n};\n\ntypedef XsRandom MyRandom;\n\nMyRandom g_myRand;\n\ndouble g_startTime;\ndouble g_suspendTime = 0;\nconst double g_timeupSecBase = 9.8;\ndouble g_timeupSec = g_timeupSecBase;\n\n#include <numeric>\n\nconst char * nextCLineOrWord(int mode) {\n\tstatic char buf[65536];\n\tstatic int bufLen = sizeof(buf);\n\tstatic int bufPos = sizeof(buf);\n\tstatic bool canReadFlag = true;\n\tstatic bool crFlag = false;\n\tstatic bool enterFlag = false;\n\tif(canReadFlag && (enterFlag ? bufLen<=bufPos : (int)sizeof(buf)<=bufPos+bufPos)) {\n\t\tif(0<bufLen-bufPos) {\n\t\t\tmemmove(buf, buf+bufPos, bufLen-bufPos);\n\t\t\tbufLen -= bufPos;\n\t\t}\n\t\telse {\n\t\t\tbufLen = 0;\n\t\t}\n\t\tchar * result = fgets(buf+bufLen, sizeof(buf)-bufLen, stdin);\n\t\tcanReadFlag = (result!=NULL);\n\t\tif(result!=NULL) {\n\t\t\tint n = strlen(result);\n\t\t\tenterFlag = (n!=(int)sizeof(buf)-1-bufLen || (1<=bufLen+n && buf[bufLen+n-1]=='\\n'));\n\t\t\tbufLen += n;\n\t\t}\n\t\tbufPos = 0;\n\t}\n\tif(mode==0) {\n\t\tint pos = bufPos;\n\t\twhile(true) {\n\t\t\tchar c = buf[pos];\n\t\t\tif(c==32) {\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==10) {\n\t\t\t\tif(crFlag) {\n\t\t\t\t\tcrFlag = false;\n\t\t\t\t\tif(bufPos==pos) {\n\t\t\t\t\t\tpos = ++bufPos;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==13) {\n\t\t\t\tcrFlag = true;\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pos;\n\t\t}\n\t\tconst char * ret = buf + bufPos;\n\t\tbufPos = pos;\n\t\twhile(true) {\n\t\t\tchar c = buf[bufPos];\n\t\t\tif(c==32 || c==10 || c==13) {\n\t\t\t\t++bufPos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\telse if(mode==1) {\n\t\tint pos = bufPos;\n\t\twhile(true) {\n\t\t\tchar c = buf[pos];\n\t\t\tif(c==10) {\n\t\t\t\tif(crFlag) {\n\t\t\t\t\tcrFlag = false;\n\t\t\t\t\tif(bufPos==pos) {\n\t\t\t\t\t\tpos = ++bufPos;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==13) {\n\t\t\t\tcrFlag = true;\n\t\t\t\tbuf[pos++] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pos;\n\t\t}\n\t\tconst char * ret = buf + bufPos;\n\t\tbufPos = pos;\n\t\treturn ret;\n\t}\n\telse if(mode==2) {\n\t\treturn bufLen<=bufPos ? NULL : buf+bufPos;\n\t}\n\tassert(false);\n\treturn NULL;\n}\n\nconst char * nextCWord() {\n\treturn nextCLineOrWord(0);\n}\n\nint nextInt() {\n\treturn atoi(nextCWord());\n}\n\nvector<int> nextIntVec(int n) {\n\tvector<int> ret;\n\tfor(int i=0; i<n; ++i) {\n\t\tret.push_back(nextInt());\n\t}\n\treturn ret;\n}\n\nvoid echoln() {\n\tfputc('\\n', stdout);\n}\nvoid echoln(const char * fmt, ...) {\n\tva_list arg;\n\tva_start(arg, fmt);\n\tvprintf(fmt, arg);\n\tva_end(arg);\n\tfputc('\\n', stdout);\n}\n\nint main() {\n\tint N = nextInt();\n\tint M = nextInt();\n\tint Q = nextInt();\n\tvector<int> a = nextIntVec(Q);\n\treverse(a.begin(), a.end());\n\tvector<int> b;\n\tvector<int> dic(M+1, -1);\n\t{\n\t\tset<int> s;\n\t\tfor(int i : a) {\n\t\t\tif(s.find(i)==s.end()) {\n\t\t\t\ts.insert(i);\n\t\t\t\tb.push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=M+1; ++i) {\n\t\t\tif(s.find(i)==s.end()) {\n\t\t\t\tb.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint sz = 0;\n\t\tfor(int i=1; i<b.size(); ++i) {\n\t\t\tif(b[i]<b[i-1]) {\n\t\t\t\tsz = i;\n\t\t\t}\n\t\t}\n\t\tb.resize(sz);\n\t\tfor(int i=0; i<b.size(); ++i) {\n\t\t\tdic[b[i]] = i;\n\t\t}\n\t}\n\tvector<int> q(b.size()+1);\n\tq[0] = N;\n\tfor(int i : a) {\n\t\tint j = dic[i];\n\t\tif(0<=j) {\n\t\t\tif(q[j]) {\n\t\t\t\t--q[j];\n\t\t\t\t++q[j+1];\n\t\t\t}\n\t\t}\n\t}\n\techoln(q[b.size()]==N ? \"Yes\" : \"No\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nconst int max0=100010;\nstruct branch{\n    int x,y,a;\n}data[max0],mapx[max0];\nint min0[max0];\nint top0,top1,delta;\nbool R=1;\nbool v[max0];\nint dpt[max0];\nint bg[max0];\nint bfs[max0],top2,btt;\nint r,c,n,i;\nbool cmp(branch a,branch b){\n    if(a.x<b.x)return 1;\n    if(a.x>b.x)return 0;\n    if(a.y<b.y)return 1;\n    if(a.y>b.y)return 0;\n    if(a.a!=b.a)R=0;\n    return 1;\n}\nint main(){\n    scanf(\"%d%d%d\",&r,&c,&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d%d%d\",&data[top0].x,&data[top0].y,&data[top0].a);\n        top0++;\n    }\n    for(i=1;i<=c;i++)min0[i]=-1;\n    sort(data,data+top0,cmp);\n    top1=1;\n    if(R){\n        for(i=0;i<n;i++)\n            if(min0[data[i].y]==-1||data[i].a<min0[data[i].y])\n                min0[data[i].y]=data[i].a;\n        for(i=1;i<n;i++)\n            if(R&&data[i].x==data[i-1].x)\n            {\n                mapx[top1].x=data[i-1].y;\n                mapx[top1].y=data[i].y;\n                delta=data[i].a-data[i-1].a;\n                mapx[top1].a=delta;\n                top1++;\n                mapx[top1].x=data[i].y;\n                mapx[top1].y=data[i-1].y;\n                mapx[top1].a=-delta;\n                top1++;\n                if(min0[data[i-1].y]+delta<0)R=0;\n                if(min0[data[i].y]-delta<0)R=0;\n            }\n    }\n    if(R){\n        sort(mapx+1,mapx+top1,cmp);\n        for(i=1;i<top1;i++)\n            if(bg[mapx[i].x]==0)bg[mapx[i].x]=i;\n        for(i=1;R&&i<=c;i++)\n            if(!v[i]){\n                v[i]=1;bfs[top2++]=i;\n                while(R&&btt<top2){\n                    for(int j=bg[bfs[btt]];j<top1&&mapx[j].x==bfs[btt];j++){\n                        if(v[mapx[j].y]){\n                            if(dpt[mapx[j].y]-dpt[mapx[j].x]!=mapx[j].a)R=0;\n                        }\n                        else{\n                            v[mapx[j].y]=1;\n                            bfs[top2++]=mapx[j].y;\n                            dpt[mapx[j].y]=dpt[mapx[j].x]+mapx[j].a;\n                        }\n                    }\n                    btt++;\n                }\n            }\n    }\n    if(R)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0; ) {\n    int da = 0;\n    for (; !Poz[br].empty(); ) {\n      if (ind >= 0 && Poz[br].back() < V[ind]) {\n        R.push_back(Poz[br].back());\n        da = 1;\n        ind--;\n      }\n\n      Poz[br].pop_back();\n    }\n\n    if (!da)\n      Nope();\n  }\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  int tmin = 1;\n  for (int i=q-1; i>=0; i--) {\n    for (; bio[tmin]; tmin++);\n\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] == tmin)\n      continue;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size()) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && pos[last] < firstFail) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\twhile (last < m) {\n\t\t\t\tif (was[last])\n\t\t\t\t\tkek = 0;\n\t\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N, M, Q;\nint a[100005];\nint used[100005];\nint pro[100005];\n\nint res[100005];\n\nint main(void)\n{\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++) cin >> a[i];\n\treverse(a, a+Q);\n\t\n\tfor(int i = 1; i <= M; i++) used[i] = -1;\n\tfor(int i = 0; i < N; i++) pro[i] = -1;\n\t\n\tint id = 0;\n\tfor(int i = 0; i < Q; i++){\n\t\tif(used[a[i]] == -1){\n\t\t\tused[a[i]] = id++;\n\t\t\tpro[N-1]++;\n\t\t}\n\t\telse{\n\t\t\tint p = lower_bound(pro, pro+N, used[a[i]]) - pro;\n\t\t\tif(p > 0 && pro[p-1] == used[a[i]]-1){\n\t\t\t\tpro[p-1]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= M; i++){\n\t\tif(used[i] == -1) used[i] = id++;\n\t}\n\tfor(int i = 1; i <= M; i++) res[used[i]] = i;\n\t\n\tvector<int> vec, ans;\n\tfor(int i = 0; i <= pro[0]; i++) vec.push_back(res[i]);\n\tfor(int i = 1; i <= M; i++) vec.push_back(i);\n\t\n\tfor(int i = 1; i <= M; i++) used[i] = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(used[vec[i]] == 0){\n\t\t\tused[vec[i]] = 1;\n\t\t\tans.push_back(vec[i]);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tif(res[i] != ans[i]){\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 160000;\nconst int K = 5000;\nint a[N], used[N], p[N], len[N], f[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n, m, q;\n    cin >> m >> n >> q;\n    for (int i = 1; i <= q; i++) cin >> a[i];\n    int k = 0;\n    for (int i = q; i >= 1; i--){\n        if (!used[a[i]]){\n            used[a[i]] = 1;\n            k++;\n            p[k] = a[i];\n        }\n    }\n    int l = 1;\n    for (int i = k + 1; i <= n; i++){\n        while(used[l] == 1) l++;\n        p[i] = l;\n        l++;\n    }\n    int suf = 0;\n    p[n + 1] = 1e9;\n    for (int i = n; i >= 1; i--){\n        if (p[i] < p[i + 1]) suf++; else break;\n    }\n    for (int i = 1; i <= n; i++) f[p[i]] = i;\n    len[0] = m;\n    for (int i = q; i >= 1; i--){\n        int x = f[a[i]];\n        if (len[x - 1] > 0){\n            len[x - 1]--;\n            len[x]++;\n        }\n    }\n    int c = 0;\n    for (int i = n - suf; i <= n; i++) c += len[i];\n    if (c != m){\n        cout << \"No\";\n    } else cout << \"Yes\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  for (int i = 0; i < m; ++i) {\n    se.insert(i);\n  }\n  for (auto e : a) {\n    if (not se.count(e)) {\n      continue;\n    }\n    if (e != *begin(se)) {\n      if (c[e] < n) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    }\n    se.erase(e);\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    for(int i=0;i<c;i++)cin>>b;\n    if(a%2==0)cout<<\"Yes\"<<endl;\nelse cout<<\"No\"<<endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++;\n  bool f=true;\n  if(n>q&&a[q-1]!=1) f=false;\n  \n  \n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, m, q;\n        in >> n >> m >> q;\n        vector<int> v(q);\n        for (int i: range(q)) {\n            in >> v[i];\n            --v[i];\n        }\n\n        vector<vector<int>> changesTimes(m);\n\n        for (int i: range(q)) {\n            changesTimes[v[i]].push_back(i);\n        }\n\n        vector<int> last(n, 1000000000);\n\n\n        vector<int> used(m + 1);\n        int minUnused = 0;\n        for (int j: downrange(q)) {\n            int i = v[j];\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            while (used[minUnused])\n                ++minUnused;\n\n            multiset<int> cur(changesTimes[i].begin(), changesTimes[i].end());\n\n            for (int& vv: last) {\n                auto it = cur.upper_bound(vv);\n                if (it == cur.begin()) {\n                    if (i <= minUnused) {\n                        vv = 0;\n                        continue;\n                    } else {\n                        out << \"No\\n\";\n                        return;\n                    }\n                }\n                --it;\n                vv = *it;\n                cur.erase(it);\n            }\n        }\n\n        out << \"Yes\\n\";\n    }\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007;\nstatic const long long MODL=1000000000000000003LL;\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//HEAD_OF_JKI'S_HEADER_\n\n\t//TYPEDEF\n\ttypedef long long lld;\n\ttypedef unsigned long long u64;\n\ttypedef pair<int, int> pii;\n\n\t//COMPARE\n\ttemplate<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n\ttemplate<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n\ttemplate<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n\ttemplate<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n\t//STL\n\ttemplate<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n\ttemplate<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n\ttemplate<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n\t//BIT\n\tinline int BINT(const int x){ return 1<<x; }\n\tinline lld BLLD(const int x){ return 1LL<<x; }\n\tinline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n\tinline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n\ttemplate<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n\ttemplate<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n\t//CONST VALUE\n\tconst double PI=acos(-1.0);\n\tconst double EPS=1e-5;\n\n\t//CALCULATE\n\ttemplate<class T> inline T SQR(const T x){ return x*x; }\n\ttemplate<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n\t\tif(!y)return 1;else if((y&1)==0){\n\t\t\treturn SQR(POW(x, y>>1));\n\t\t}else return POW(x, y^1)*x;\n\t}\n\n\t//NUMBERIC\n\ttemplate<class T> inline T GCD(const T x, const T y){\n\t\tif(x<0)return GCD(-x, y);\n\t\tif(y<0)return GCD(x, -y);\n\t\treturn (!y)?x:GCD(y, x%y);\n\t}\n\ttemplate<class T> inline T LCM(const T x, const T y){\n\t\tif(x<0)return LCM(-x, y);\n\t\tif(y<0)return LCM(x, -y);\n\t\treturn x*(y/GCD(x, y));\n\t}\n\ttemplate<class T> inline T EEA(const T a, const T b, T &x, T &y){\n\t\t/* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n\t\tif(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n\t\tif(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n\t\tif(!b){\n\t\t\tx=1; y=0; return a;\n\t\t}else{\n\t\t\tT d=EEA(b, a%b, x, y);\n\t\t\tT t=x; x=y; y=t-(a/b)*y;\n\t\t\treturn d;\n\t\t}\n\t}\n\ttemplate<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n\t\tvector<pair<T, int> > ret;\n\t\tif(x<0)x=-x;\n\t\tfor (T i=2;x>1;){\n\t\t\tif(x%i==0){\n\t\t\t\tint count=0;\n\t\t\t\tfor(;x%i==0;x/=i)count++;\n\t\t\t\tret.push_back(MP(i, count));\n\t\t\t}\n\t\t\ti++;if(i>x/i)i=x;\n\t\t}\n\t\treturn ret;\n\t}\n\ttemplate<class T> inline int ISPRIME(const T x){\n\t\tif(x<=1)return 0;\n\t\tfor(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n\t\treturn 1;\n\t}\n\ttemplate<class T> inline T EULARFUNCTION(T x){\n\t\tvector<pair<T, int> > f=FACTORIZE(x);\n\t\tfor(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n\t\t\tx=x/it->first*(it->first-1);\n\t\t}\n\t\treturn x;\n\t}\n\ttemplate<class T> inline T INVERSEE(const T a, const T b=MOD){\n\t\tT x, y;\n\t\tEEA(a, b, x, y);\n\t\treturn x?x:1;\n\t}\n\n\t//REMINDER-LIZATION\n\ttemplate<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n\ttemplate<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n\ttemplate<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n\ttemplate<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n\ttemplate<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n\ttemplate<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n\ttemplate<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n\t\tif(y==0)return 1%m;else if((y&1)==0){\n\t\t\tT1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n\t\t}else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n\t}\n\tinline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n\t\tif(x<y)swap(x, y);\n\t\tlld z=0LL;\n\t\twhile(y>0){\n\t\t\tif(y&1){\n\t\t\t\tMOD_ADD(&z, x, m);\n\t\t\t}\n\t\t\tMOD_ADD(&x, x, m);\n\t\t\ty>>=1;\n\t\t}\n\t\treturn z;\n\t}\n\tinline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n\t\tif(y==0LL)return 1LL%m;else if((y&1)==0LL){\n\t\t\tlld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n\t\t}else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n\t}\n\n\t//MATRIX\n\ttemplate<class T> class MATX{\n\t\tprivate:\n\t\t\tunsigned long hig, wid;\n\t\t\tT *data;\n\n\t\t\tvoid __init(){\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tmemset(this->data, 0, sizeof(T)*this->hig*this->wid);\n\t\t\t}\n\n\t\tpublic:\n\t\t\tMATX(){ \n\t\t\t\tthis->hig=this->wid=1;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _len){\n\t\t\t\tthis->hig=this->wid=_len;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const unsigned long _hig, const unsigned long _wid){\n\t\t\t\tthis->hig=_hig;\n\t\t\t\tthis->wid=_wid;\n\t\t\t\t__init();\n\t\t\t}\n\t\t\tMATX(const MATX &rhs){\n\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t}\n\t\t\t~MATX(){\n\t\t\t\tfree(this->data);\n\t\t\t}\n\n\t\t\tT & operator()(const unsigned long x, const unsigned long y){\n\t\t\t\tif(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tMATX & operator=(const MATX &rhs){\n\t\t\t\tif(this->hig!=rhs.hig || this->wid!=rhs.wid){\n\t\t\t\t\tfree(this->data);\n\t\t\t\t\tthis->hig=rhs.hig;\n\t\t\t\t\tthis->wid=rhs.wid;\n\t\t\t\t\tthis->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n\t\t\t\t}\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=rhs.at(x, y);\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX operator+(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]+=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator-(const MATX &opn) const{\n\t\t\t\tMATX ret(*this);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tret.data[x*ret.wid+y]-=opn.at(x, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst MATX operator*(const MATX &opn) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.hig);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tconst MATX mul(const MATX &opn) const{ return *this*opn; }\n\t\t\ttemplate<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n\t\t\t\tMATX ret(this->hig, opn.wid);\n\t\t\t\tconst unsigned long len=MIN(this->wid, opn.wid);\n\t\t\t\tfor(unsigned long x=0; x<ret.hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<ret.wid; y++)\n\t\t\t\t\t\tfor(unsigned long z=0; z<len; z++)\n\t\t\t\t\t\t\tMOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tMATX & operator +=(const MATX &rhs){\n\t\t\t\t*this=*this+rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator -=(const MATX &rhs){\n\t\t\t\t*this=*this-rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tMATX & operator *=(const MATX &rhs){\n\t\t\t\t*this=*this*rhs;\n\t\t\t\treturn *this;\n\t\t\t}\n\n\t\t\tconst MATX pow(const unsigned long p) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret*=buff;\n\t\t\t\t\tbuff*=buff;\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\ttemplate<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n\t\t\t\tMATX buff(*this), ret(this->hig, this->wid);\n\t\t\t\tret.set_one();\n\t\t\t\tif(p>0)for(unsigned long i=1;;i<<=1){\n\t\t\t\t\tif(p&i)ret=ret.mul(buff, m);\n\t\t\t\t\tbuff=buff.mul(buff, m);\n\t\t\t\t\tif(i>(p>>1))break;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\n\t\t\tconst T at(const unsigned long x, const unsigned long y) const{\n\t\t\t\tif(x>=this->hig || y>=this->wid)return 0;\n\t\t\t\treturn this->data[x*wid+y];\n\t\t\t}\n\n\t\t\tvoid show() const{\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++){\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tcout<<this->at(x, y)<<\" \";\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set_one(){\n\t\t\t\tfor(unsigned long x=0; x<this->hig; x++)\n\t\t\t\t\tfor(unsigned long y=0; y<this->wid; y++)\n\t\t\t\t\t\tthis->data[x*this->wid+y]=(x==y)?1:0;\n\t\t\t}\n\n\t};\n\n\t//Complex\n\ttemplate<class T> class complex_t{\n\t\tpublic:\n\t\tT r, i;//real part & imaginary part; x+yi\n\t\tcomplex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n\t\tcomplex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n\t\tcomplex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n\t\tcomplex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n\t};\n\n\ttemplate<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n\t\tfor(int i=1, j=len>>1; i<len-1; i++){\n\t\t\tif(i<j)swap(f[i], f[j]);\n\t\t\tint k=len>>1;\n\t\t\twhile(j>=k){\n\t\t\t\tj-=k;\n\t\t\t\tk>>=1;\n\t\t\t}\n\t\t\tif(j<k)j+=k;\n\t\t}\n\t\tfor(int h=2; h<=len; h<<=1){\n\t\t\tcomplex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n\t\t\tfor(int i=0; i<len; i+=h){\n\t\t\t\tcomplex_t<T> wm(1.0, 0.0);\n\t\t\t\tfor(int j=i; j<i+(h>>1); j++){\n\t\t\t\t\tcomplex_t<T> u = f[j];\n\t\t\t\t\tcomplex_t<T> t = wm*f[j+(h>>1)];\n\t\t\t\t\tf[j] = u+t;\n\t\t\t\t\tf[j+(h>>1)] = u-t;\n\t\t\t\t\twm = wm*wn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!is_dft){\n\t\t\tfor(int i=0; i<len; i++)\n\t\t\t\tf[i].r/=len*1.0;\n\t\t}\n\t}\n\n\t//MILLERRABIN\n\tclass MILLERRABIN{\n\t\tprivate:\n\t\tstatic const int prime_table[12];\n\t\tint witness(lld a, lld d, lld s, lld n){\n\t\t\tlld r=MODL_POW(a, d, n);\n\t\t\tif(r==1 || r==n-1)return 0;\n\t\t\tfor(int i=0; i<s-1; i++){\n\t\t\t\tr = MODL_MUL(r, r, n);\n\t\t\t\tif(r==1)return 1;\n\t\t\t\tif(r==n-1)return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tpublic:\n\t\tint test(const lld n){\n\t\t\tif(n<=2LL) return 0;\n\t\t\tlld p=n-1LL, s=0LL;\n\t\t\twhile(!(p&1)){ p>>=1;s++; }\n\t\t\tfor(int i=0; i<12 && this->prime_table[i]<n; i++){\n\t\t\t\tif(witness(this->prime_table[i], p, s, n))return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t};\n\tconst int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n\t//Computational Geometry\n\n\ttemplate<class T> inline int fsign(const T x){\n\t\tif(x>-eps && x<eps)return 0;\n\t\treturn (x<0.0)?-1:1;\n\t}\n\n\ttemplate<class T> class point_t{\n\t\tpublic:\n\t\tT x, y;\n\t\tpoint_t (){\n\t\t\tthis->x=0.0;\n\t\t\tthis->y=0.0;\n\t\t}\n\t\tpoint_t (const T _x, const T _y){\n\t\t\tthis->x=_x;\n\t\t\tthis->y=_y;\n\t\t}\n\t\tpoint_t operator - (const point_t &rhs) const{\n\t\t\treturn point_t(this->x-rhs.x, this->y-rhs.y);\n\t\t}\n\t\tT operator ^ (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.y - this->y*rhs.x;\n\t\t}\n\t\tT operator * (const point_t &rhs) const{\n\t\t\treturn this->x*rhs.x + this->y*rhs.y;\n\t\t}\n\t\tbool operator < (const point_t &rhs) const{\n\t\t\tif(fsign(this->y-rhs.y)!=0)\n\t\t\t\treturn fsign(this->y-rhs.y)<0;\n\t\t\treturn fsign(this->x-rhs.x)<0;\n\t\t}\n\t\tT cross(const point_t &p, const point_t &q) const{\n\t\t\treturn (p-*this)^(q-*this);\n\t\t}\n\t\tvoid rotate(const double radian){\n\t\t\tT x0=x, y0=y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr;\n\t\t\ty=x0*sinr+y0*cosr;\n\t\t}\n\t\tvoid rotate(const point_t &p, const double radian){\n\t\t\tT x0=x-p.x, y0=y-p.y;\n\t\t\tT sinr=sin(radian);\n\t\t\tT cosr=cos(radian);\n\t\t\tx=x0*cosr-y0*sinr+p.x;\n\t\t\ty=x0*sinr+y0*cosr+p.y;\n\t\t}\n\t\tT dist2(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn (lhs-rhs)*(lhs-rhs);\n\t\t}\n\t\tT dist2(const point_t &rhs) const{\n\t\t\treturn (*this-rhs)*(*this-rhs);\n\t\t}\n\t\tT dist(const point_t &lhs, const point_t &rhs) const{\n\t\t\treturn sqrt((lhs-rhs)*(lhs-rhs));\n\t\t}\n\t\tT dist(const point_t &rhs) const{\n\t\t\treturn sqrt((*this-rhs)*(*this-rhs));\n\t\t}\n\t};\n\n\ttemplate<class T> class segment_t{\n\t\tpublic:\n\t\tpoint_t<T> p, q;\n\t\tsegment_t (){\n\t\t\tthis->p.x=this->p.y=0.0;\n\t\t\tthis->q.x=this->q.y=0.0;\n\t\t}\n\t\ttemplate<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n\t\t\tthis->p.x=_p.x;\n\t\t\tthis->p.y=_p.y;\n\t\t\tthis->q.x=_q.x;\n\t\t\tthis->q.y=_q.y;\n\t\t}\n\t\tsegment_t (const T px, const T py, const T qx, const T qy){\n\t\t\tthis->p.x=px;\n\t\t\tthis->p.y=py;\n\t\t\tthis->q.x=qx;\n\t\t\tthis->q.y=qy;\n\t\t}\n\t\tT length() const{\n\t\t\treturn this->p.dist(this->q);\n\t\t}\n\t\tT length2() const{\n\t\t\treturn this->p.dist2(this->q);\n\t\t}\n\t\tint contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n\t\t\tif(ignore_endpoint){\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n\t\t\t}else{\n\t\t\t\treturn fsign((this->p-pnt)^(this->q-pnt))==0\n\t\t\t\t\t&& fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n\t\t\t\t\t&& fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n\t\t\t}\n\t\t}\n\t\tint intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n\t\t\tif(!ignore_endpoint){\n\t\t\t\tif(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n\t\t\t\t&& fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n\t\t}\n\t\tint intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n\t\t\treturn this->intersection(*this, rhs, ignore_endpoint);\n\t\t}\n\t};\n\n\ttemplate<class T> static int compare_pas(const void *x, const void *y, void *z){\n\t\tconst point_t<T> *p1 = (point_t<T>*)x;\n\t\tconst point_t<T> *p2 = (point_t<T>*)y;\n\t\tconst point_t<T> *p0 = (point_t<T>*)z;\n\t\tint sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n\t\tif(sgn!=0)return -sgn;\n\t\treturn fsign(p0->dist2(*p1)-p0->dist2(*p2));\n\t}\n\ttemplate<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n\t\tint p=0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif(pnts[p]<pnts[i])p=i;\n\t\t}\n\t\tswap(pnts[0], pnts[p]);\n\t\tqsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n\t}\n\n\ttemplate<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n\t\tpolar_angle_sort(pnts, n);\n\t\tm=0;\n\t\tif(n<3)return;\n\t\tidx[m++]=0;\n\t\tidx[m++]=1;\n\t\tfor(int i=2; i<n; i++){\n\t\t\twhile(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n\t\t\tidx[m++]=i;\n\t\t}\n\t}\n\n\n//TAIL_OF_JKI'S_HEADER\n\n#define N 110000\n\nint n, m, len;\nint a[N], pos[N];\nint vst[N], msk;\n\nvector<int> arr;\nqueue<int> huk[N];\n\nint main() {\n    memset(vst, 0xff, sizeof(vst));msk=-1;\n    while(scanf(\"%d%d\", &n, &len)!=EOF){msk++;\n        scanf(\"%d\", &m);\n        for(int i=0; i<m; i++){\n            scanf(\"%d\", &a[i]);\n            a[i]--;\n        }\n        arr.clear();\n        for(int i=m-1; ~i; i--){\n            if(vst[a[i]]!=msk){\n                vst[a[i]]=msk;\n                arr.push_back(a[i]);\n            }\n        }\n        for(int i=0; i<len; i++){\n            if(vst[i]!=msk){\n                vst[i]=msk;\n                arr.push_back(i);\n            }\n        }\n        //printf(\"arr: \");\n        for(int i=0; i<len; i++){\n            //printf(\" %d\", arr[i]);\n            pos[arr[i]]=i;\n            while(!huk[i].empty()){\n                huk[i].pop();\n            }\n        }\n        //printf(\"\\n\");\n        for(int i=0; i<n; i++){\n            huk[0].push(i);\n        }\n        for(int i=m-1; ~i; i--){\n            int cnd=pos[a[i]];\n            if(!huk[cnd].empty()){\n                int idx=huk[cnd].front();\n                huk[cnd].pop();\n                if(cnd+1<len)\n                    huk[cnd+1].push(idx);\n            }\n        }\n        int req=len-1;\n        for(int i=len-2; i>=0 && arr[i]<arr[i+1]; i--){\n            req--;\n        }\n        //printf(\"req=%d\\n\", req);\n        int flag=1;\n        for(int i=0; i<req; i++){\n            if(!huk[i].empty()){\n                flag=0;\n                break;\n            }\n        }\n        if(flag){\n            printf(\"Yes\\n\");\n        }else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ELRU {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m, q; cin >> n >> m >> q;\n      vector<int> a(q);\n      rep(i, q) {\n        cin >> a[i];\n      }\n      reverse(all(a));\n      // value, pos\n      map<int, int> used;\n      vector<int> cnt;\n      vector<int> rev;\n      rep(i, q) {\n        if (used.find(a[i]) == used.end()) {\n          used[a[i]] = cnt.size();\n          debug(i, a[i], used[a[i]]);\n          cnt.push_back(1);\n          rev.push_back(a[i]);\n        } else {\n          int pos = used[a[i]];\n          debug(i, pos);\n          if (pos == 0 || cnt[pos-1] > cnt[pos]) {\n            cnt[pos]++;\n          }\n        }\n      }\n\n      for(int i=0; i<cnt.size(); i++) {\n        debug(i, cnt[i], rev[i]);\n      }\n\n      bool flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (i+1 != rev[i]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        cout << \"Yes\" << endl;\n        return;\n      }\n\n      flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (cnt[i] >= n) continue;\n        if (rev[i] == 1 && i == cnt.size()-1) continue;\n        flag = false;\n        break;\n      }\n      cout << (flag ? \"Yes\" : \"No\") << endl;\n    }\n};\n\nsigned main() {\n  ELRU solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (j > cur[k]) ans = false;\n\t\t\tcur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    auto A = readVec<int>(Q);\n    for (auto& a : A) { a--; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M; i++) { L[i].push_back(M - i - 1); }\n    for (int i = 0; i < Q; i++) { L[A[i]].push_back(i + M); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, N + M);\n    for (const auto& o : op) {\n        if (pos[0] < L[o].back()) { return std::cout << \"No\" << std::endl, 0; }\n        for (int i = 0; i < N; i++) {\n            if (pos[i] < M) {\n                while (pos[i] < L[o].back()) {\n                    if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                    L[o].pop_back();\n                }\n                pos[i] = L[o].back();\n                if (L[o].size() > 1) { L[o].pop_back(); }\n                break;\n            } else {\n                while (pos[i] < L[o].back()) {\n                    if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                    L[o].pop_back();\n                }\n                pos[i] = L[o].back();\n                if (L[o].size() > 1) { L[o].pop_back(); }\n            }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint n,m,A[110000],K,pd[110000],num[110000],fir,lim;\nvector<int>x[110000];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&K);\n\tfor (int i=1;i<=K;i++) scanf(\"%d\",&A[i]),x[A[i]].push_back(i);\n\tfir=1; lim=0;\n\tmemset(num,0x3f,sizeof num);\n\tfor (int now=K;now;now--){\n\t\tif (pd[A[now]]) continue;\n\t\tint rem=n;\n\t\tfor (int i=x[A[now]].size();i;i--){\n\t\t\tint k=x[A[now]][i-1];\n\t\t\tif (rem<=lim) num[rem]=0;\n\t\t//\tcout<<rem<<\" \"<<num[rem]<<\" \"<<k<<\" \"<<A[now]<<endl;\n\t\t\tif (k>num[rem]){\n\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t}\n\t\t\tnum[rem]=k; rem--;\n\t\t}\n\t\twhile (pd[fir]) fir++;\n\t\tif (fir==A[now]) lim=max(lim,rem);\n\t\telse if (rem){\n\t\t\tprintf(\"No\\n\"); return 0;\n\t\t}\n\t\tpd[A[now]]=1;\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> a(q);\n  rep(i,q){\n    cin>>a[i]; --a[i];\n  }\n  reverse(all(a));\n  vector<int> fin; fin.reserve(m);\n  vector<int> inv(m,-1),cnt(m);\n  for(int x:a){\n    if(inv[x]<0){\n      inv[x]=fin.size();\n      fin.pb(x);\n    }\n    ++cnt[inv[x]];\n    if(inv[x] && cnt[inv[x]-1]<cnt[inv[x]]){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  rep(i,int(fin.size())-1) if(cnt[i]<n && fin[i]>fin[i+1]){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M,Q;\nint A[101010];\nint did[101010];\nint ind[101010];\nvector<int> V;\nint num[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) cin>>A[i];\n\tfor(i=Q-1;i>=0;i--) {\n\t\tdid[A[i]]++;\n\t\tif(did[A[i]]==1) {\n\t\t\tind[A[i]]=V.size();\n\t\t\tV.push_back(A[i]);\n\t\t}\n\t}\n\tFOR(i,M) if(did[i+1]==0) {\n\t\tind[i+1]=V.size();\n\t\tV.push_back(i+1);\n\t}\n\t\n\twhile(V.size()>=2 && V[V.size()-2]<V[V.size()-1]) V.pop_back();\n\tV.pop_back();\n\t\n\tnum[0]=N;\n\tfor(i=Q-1;i>=0;i--) {\n\t\tif(num[ind[A[i]]]) {\n\t\t\tnum[ind[A[i]]]--;\n\t\t\tnum[ind[A[i]]+1]++;\n\t\t}\n\t}\n\t\n\tFOR(i,V.size()) if(num[i]) return _P(\"No\\n\");\n\t_P(\"Yes\\n\");\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tint Q;cin>>Q;\n\tvi A(Q);cin>>A;\n\tvi v(N),I(M+1),B;\n\trf(i,Q){\n\t\tif(I[A[i]]){\n\t\t\tauto it=lower_bound(all(v),I[A[i]]);\n\t\t\tif(it!=v.begin()){\n\t\t\t\t--it;\n\t\t\t\tif(*it==I[A[i]]-1){\n\t\t\t\t\t++*it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tI[A[i]]=++v[N-1];\n\t\t\tB<<A[i];\n\t\t}\n\t}\n\tfoor(i,1,M){\n\t\tif(!I[i])B<<i;\n\t}\n\tbool z=true;\n\tfoor(i,v[0],M-2){\n\t\tz&=B[i]<B[i+1];\n\t}\n\tYn(z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nint main() {\n\tint N,M, Q;\n\tcin >> N >> M >> Q;\n\t\n\tmap<int, int> order;\n\tvector<int> input;\n\tset<int> used;\n\tvector<int> pos(M+1, 0);\n\t\n\tpos[0] = N;\n\t\n\tvector<int> nums;\n\tfor(int i=0; i<Q; i++) {\n\t\tint p;\n\t\tcin >> p;\n\t\tinput.push_back(p);\n\t}\n\treverse(input.begin(), input.end());\n\tfor(int i=0; i<input.size(); i++) {\n\t\tint p = input[i];\n\t\tint cnt = used.size();\n\t\tused.insert(p);\n\t\tif((int)used.size() != cnt) {\n\t\t\torder[p] = cnt+1;\n\t\t\tnums.push_back(p);\n\t\t}\n\t\tint cur = order[p];\n\t\tif(pos[cur-1] > 0) {\n\t\t\tpos[cur-1]--;\n\t\t\tpos[cur]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0; i<3; i++) {\n\t\tcout <<\" \" << i << \" \" << pos[i] << endl;\n\t}\n\tfor(int i=0; i<nums.size(); i++)\n\t\tcout << nums[i] << endl;\n\t*/\n\tint last = nums.size()-1;\n\tbool ok = true;\n\tfor(int val = nums.back(); val>=1; val--) {\n\t\t\n\t\tif(order[val] == 0) ok = false;\n\t\tif(last>0 && val == nums[last-1]) {\n\t\t\tlast--;\n\t\t}\n\t}\n\tif(!ok) {\n\t\tlast = nums.size();\n\t}\n\t\n\tbool judge = true;\n\tfor(int i=0; i<last; i++)\n\t\tif(pos[i] > 0)\n\t\t\tjudge = false;\n\tif(judge) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order(m, -1);\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tit_bound = prev(it_bound);\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tauto it_order = find(order.begin(), order.end(), -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\t*it_order = i;\n\t\t\tit_order++;\n\n\t\t\tif (it_order == order.end()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < m - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\nconst ll LINF = (ll)1e18 + 5;\nconst int INF = (int)1e9 + 5;\n\ntemplate<class T>\nT sqr(T x) { return x * x; }\n\ntemplate<class T>\nT abs(T x) { return x < 0 ? -x : x; }\n\ntemplate<class T>\nll round(T x) { return x < 0 ? x - 0.5 : x + 0.5; }\n\ntemplate<class T>\nbool chmin(T & x, const T & y) {\n\tif (y < x) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate<class T>\nbool chmax(T & x, const T & y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\ntemplate<class P, class Q>\nostream & operator <<(ostream & os, const pair<P, Q> & p) {\n\treturn os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const vector<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename vector<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const set<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename set<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class T>\nostream & operator <<(ostream & os, const multiset<T> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename multiset<T>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\ntemplate<class P, class Q>\nostream & operator <<(ostream & os, const map<P, Q> & v) {\n\tbool was = false;\n\tos << \"{\";\n\tfor (typename map<P, Q>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tif (was) {\n\t\t\tos << \", \";\n\t\t}\n\t\telse {\n\t\t\twas = true;\n\t\t}\n\t\tos << *it;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n\n#define all(x) (x).begin(), (x).end()\n\ntemplate<class T>\nT nextInt() {\n\tll x = 0;\n\tbool p = false;\n\tchar c;\n\tdo {\n\t\tc = getchar();\n\t} while (c <= 32);\n\tif (c == '-') {\n\t\tp = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\treturn (p ? -x : x);\n}\n\nset<int> tmp;\nbool myCmp(vector<int> a, vector<int> b) {\n\tif (a.size() > b.size()) swap(a, b);\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\tif (b[i] != a[i]) return false;\n\t}\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\ttmp.erase(a[i]);\n\t}\n\tbool ok = true;\n\tstatic vector<int> erased;\n\terased.resize(0);\n\tfor (int i = (int)a.size(); i < (int)b.size(); i++) {\n\t\tint cur = *tmp.begin(); tmp.erase(tmp.begin());\n\t\terased.push_back(cur);\n\t\tok = ok && (cur == b[i]);\n\t}\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\ttmp.insert(a[i]);\n\t}\n\tfor (int x : erased) {\n\t\ttmp.insert(x);\n\t}\n\treturn ok;\n}\n\nint main() {\n\tsrand(time(0));\n\n#ifdef LOCAL\n\t//gen();\n\tfreopen(\"input.txt\", \"r\", stdin);\n#else\n\t\n#endif\n\n\tint n, m, q;\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &q);\n\n\tvector<int> a(q);\n\n\tfor (int & x : a) {\n\t\tscanf(\"%d\", &x);\n\t}\n\n\treverse(all(a));\n\n\tmap<int, set<int>> listOfHeight;\n\tvector<vector<int>> cols(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlistOfHeight[cols[i].size()].insert(i);\n\t}\n\n\tmap<int, set<int>> whoNeed;\n\tset<int> was;\n\n\tfor (int x : a) {\n\t\tauto & z = whoNeed[x];\n\t\tif (!z.empty()) {\n\t\t\tint idx = *z.begin(); z.erase(z.begin());\n\t\t\tlistOfHeight[cols[idx].size()].erase(idx);\n\t\t\tcols[idx].push_back(x);\n\t\t\tlistOfHeight[cols[idx].size()].insert(idx);\n\t\t\twas.insert(x);\n\t\t\twhile ((--listOfHeight.end())->second.empty()) {\n\t\t\t\tlistOfHeight.erase(--listOfHeight.end());\n\t\t\t}\n\t\t\tint h = (--listOfHeight.end())->first;\n\t\t\tauto & t = listOfHeight[h];\n\t\t\tint hiIdx = *t.begin();\n\t\t\tif ((int)cols[idx].size() < h) {\n\t\t\t\twhoNeed[cols[hiIdx][cols[idx].size()]].insert(idx);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (was.count(x)) continue;\n\t\t\twas.insert(x);\n\t\t\twhile ((--listOfHeight.end())->second.empty()) {\n\t\t\t\tlistOfHeight.erase(--listOfHeight.end());\n\t\t\t}\n\t\t\tint h = (--listOfHeight.end())->first;\n\t\t\tauto & t = listOfHeight[h];\n\t\t\tint idx = *t.begin(); t.erase(t.begin());\n\t\t\tcols[idx].push_back(x);\n\t\t\tlistOfHeight[cols[idx].size()].insert(idx);\n\t\t\tfor (int q : t) {\n\t\t\t\twhoNeed[x].insert(q);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 1; i <= m; i++) {\n\t\ttmp.insert(i);\n\t}\n\n\tbool res = true;\n\tfor (int i = 0; i + 1 < (int)cols.size(); i++) {\n\t\tres = res && myCmp(cols[i], cols[i + 1]);\n\t}\n\n\tputs(res ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n//\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n//\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n//\tfor (PP p : seq) {\n//\t\tif (p.second == N) {\n//\t\t\tSet.erase(p.first);\n//\t\t} else {\n//\t\t\tif (*Set.begin() != p.first) {\n//\t\t\t\tok = false;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tSet.erase(p.first);\n//\t\t}\n//\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n\nusing namespace std;\n\nint A[SIZE];\nbool use[SIZE];\nvector <int> query[SIZE];\nint dp[SIZE];\n\nint main()\n{\n\tint n,m,q;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tA[i]--;\n\t\tquery[A[i]].push_back(i);\n\t}\n\tvector <int> ord;\n\tfor(int i=q-1;i>=0;i--)\n\t{\n\t\tif(!use[A[i]])\n\t\t{\n\t\t\tord.push_back(A[i]);\n\t\t\tuse[A[i]]=true;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) if(!use[i]) ord.push_back(i);\n\twhile(ord.size()>=2)\n\t{\n\t\tint sz=ord.size();\n\t\tif(ord[sz-2]>ord[sz-1]) break;\n\t\tord.pop_back();\n\t}ord.pop_back();\n\t//for(int i=0;i<ord.size();i++) printf(\"%d \",ord[i]);puts(\"\");\n\tfor(int i=0;i<m;i++) dp[i]=q;\n\tfor(int i=0;i<ord.size();i++)\n\t{\n\t\tint v=ord[i];\n\t\tif(query[v].size()<m)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tint nxt=query[j][query[v].size()-j-1];\n\t\t\tif(dp[j]<nxt)\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[j]=nxt;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N,M,Q,a[100000],tree[1<<18];\nbool b[100001];\nset<pair<int,int>>st;\nvector<int>v;\n\nvoid add(int x,int t){\n\tx+=(1<<17);\n\twhile(x){\n\t\ttree[x]+=t;\n\t\tx/=2;\n\t}\n}\n\nint calc(int p,int q,int l,int r,int k){\n\tif(r<p||q<l)return 0;\n\tif(p<=l&&r<=q)return tree[k];\n\telse{\n\t\treturn (calc(p,q,l,(l+r)/2,k*2)+calc(p,q,(l+r)/2+1,r,k*2+1));\n\t}\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tfor(int i=0;i<Q;++i){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=Q-1;i>=0;--i){\n\t\tif(b[a[i]])continue;\n\t\tv.push_back(a[i]);\n\t\tb[a[i]]=true;\n\t}\n\tfor(int i:v){\n\t\tadd(i,1);\n\t}\n\twhile(!v.empty()){\n\t\tif(calc(0,v.back(),0,(1<<17)-1,1)==v.back()){\n\t\t\tadd(v.back(),-1);\n\t\t\tv.pop_back();\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(v.empty()){\n\t\tcout<<\"Yes\"<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<Q;++i){\n\t\tst.insert({i,a[i]});\n\t}\n\tfor(int i=0;i<N;++i){\n\t\tint t=0;\n\t\tauto it=st.end();\n\t\twhile(it!=st.begin()&&t!=v.size()){\n\t\t\t--it;\n\t\t\tif(it->second==v[t]){\n\t\t\t\t++t;\n\t\t\t\tauto it2=it;\n\t\t\t\t--it;\n\t\t\t\tst.erase(it2);\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\t\tif(t!=v.size()){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> pos(m);\n        REP(i, Q) {\n            used.insert(a[i]);\n            pos[a[i]] = i;\n        }\n        vector<P> temp;\n        REP(i, m) if (used.count(i) > 0) temp.pb({-pos[i], i});\n        sort( ALL(temp) );\n        vector<ll> res;\n        REP(i, temp.size()) {\n            res.pb(temp[i].second);\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; RPE(i, m) s.insert(seq[i]); assert(s.size() == m); }\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    cout << seq << endl;\n    cout << cnt << endl;\n    cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << ' ' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define DEBUG(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  vector<int> v;\n  for (int e : a) {\n    if (se.count(e)) {\n      continue;\n    }\n    se.insert(e);\n    v.push_back(e);\n  }\n  DEBUG(v);\n  while (v.size() >= 2 and v[v.size() - 2] < v.back()) {\n    v.pop_back();\n  }\n  v.pop_back();\n  DEBUG(v);\n  if (all_of(begin(v), end(v), [&](int e) { return c[e] >= n; })) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n\n    int last = -1;\n    drep(i,v.size()){\n        if(v[i].first <= mex){\n            last = i;\n            break;\n        }\n    }\n\n    drep(i,v.size()){\n        if(i == last)break;\n        if(i == v.size() - 1 && v[i].first <= mex)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, m, q, a[100009], b[100009], c[100009], d[100009]; vector<int>Z; bool used[100009], OK = true;\nint main() {\n\tcin >> n >> m >> q; for (int i = 1; i <= q; i++)cin >> a[i], a[i]--;\n\tfor (int i = q; i >= 1; i--) { if (used[a[i]] == false) { used[a[i]] = true; Z.push_back(a[i]); } }\n\tfor (int i = 0; i < Z.size(); i++) { if (Z[i] != i)OK = false; b[Z[i]] = i; }\n\tif (OK == true) { cout << \"Yes\" << endl; return 0; }\n\tif (n*Z.size() > q) { cout << \"No\" << endl; return 0; }\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = b[a[i]];\n\t\tif (c[num] == n || d[c[num]] < num)continue;\n\t\td[c[num]]++; c[num]++;\n\t}\n\tfor (int i = 0; i < n; i++) { if (d[i] != n)OK = true; }\n\tif (OK == true)cout << \"No\" << endl; else cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , m , Q , a[N] , v[N] , _;\nint vis[N] , cnt[N] , pos[N];\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&Q);\n  rep(i,0,Q) scanf(\"%d\",a + i);\n  reverse(a,a+Q);\n  rep(i,0,Q) {\n    if(!vis[a[i]])\n      vis[a[i]]=1,v[++_]=a[i];\n  }\n  rep(i,1,m+1) if(!vis[i])\n    v[++_]=i;\n  rep(i,1,m+1) pos[v[i]]=i;\n  cnt[0]=n;\n  int Max=0;\n  rep(i,0,Q) {\n    int t=pos[a[i]];\n    if(cnt[t-1]) {\n      cnt[t-1]--;\n      cnt[t]++;\n      Max = max(Max , t);\n    } else if(Max < t) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  int Min=0;\n  rep(i,0,m+1) if(cnt[i]) {\n    Min=i;\n    break;\n  }\n  int inc=true;\n  rep(i,Min+2,m+1) inc&=v[i]>v[i-1];\n  puts(inc ? \"Yes\" : \"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n  int Q;\n  cin >> Q;\n\n  int len = 0;\n  vector<int> order(m, -1);\n  vector<int> natural(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n\n  vector<int> ac(Q);\n  for (int iter=0; iter<Q; iter++) {\n    cin >> ac[Q-1-iter];\n    ac[Q-1-iter] --;\n  }\n\n  for (int iter=0; iter<Q; iter++) {\n    int a = ac[iter];\n//    printf(\"%d %d\\n\", a, order[a]);\n\n    if (order[a] == -1) {\n      order[a] = len;\n      natural[len] = a;\n      freq[len] --;\n      len ++;\n      freq[len] ++;\n      continue;\n    }\n    if (freq[order[a]] == 0) continue;\n    freq[order[a]] --;\n    freq[order[a]+1] ++;\n  }\n\n  for (int i=0; i<m; i++)\n    if (order[i] == -1) {\n      natural[len++] = i;\n    }\n  int first = 0;\n  for (int i=0; i<=m; i++)\n    if (freq[i]) {\n      first = i;\n      break;\n    }\n  for (int i=first; i+1<m; i++)\n    if (natural[i] > natural[i+1]) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n\n  cout << \"Yes\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      j=0;\n      for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n      if(j!=k&&c[k]!=q) f=false; \n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;else if(a[i]>j) f=false;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    for(i=2;i<=m;i++) if(c[i]!=0&&c[i]<n) f=false;\n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, m; cin>>n>>m;\n    int q; cin>>q;\n    int a[100010];\n    for(int i=0; i<q; i++){\n        cin>>a[i];\n    }\n    int ind[100010];\n    fill(ind, ind+m+1, -1);\n    int c=0;\n    vector<int> v[100010];\n    for(int i=q-1; i>=0; i--){\n        if(ind[a[i]]==-1){\n            ind[a[i]]=c;\n            v[0].push_back(a[i]);\n            c++;\n        }else{\n            int l=0, r=n;\n            while(r-l>1){\n                int mid=(l+r)/2;\n                if(v[mid].size()<=ind[a[i]]) r=mid;\n                else l=mid;\n            }\n            if(r<n && v[r].size()==ind[a[i]]){\n                v[r].push_back(a[i]);\n            }\n        }\n    }\n    for(int i=1; i<=m; i++) if(ind[i]==-1) v[0].push_back(i);\n    int mn=0;\n    for(int i=m-1; i>=1; i--){\n        if(v[0][i]<v[0][i-1]){\n            mn=i; break;\n        }\n    }\n    for(int i=0; i<n; i++){\n        if(v[i].size()<mn){\n            cout<<\"No\"<<endl; return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\n\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            for(int j=1; j<=tail; j++)\n            {\n                if(qu[j]==a[i])\n                    goto haha;\n            }\n            tail++;\n            qu[tail]=a[i];\n            ha[tail]++;\n            haha:;\n        }\n    }\n    //cout<<head<<  \"  \"<<tail<<endl;\n\n        if(ha[tail]>=n)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n\n     if(head==tail)\n      {\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n      }\n\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nvector<int> cnt[N];\n\nbool check(vector<vector<int>> vvs, int n) {\n    sort(vvs.rbegin(), vvs.rend());\n    for (auto &v: vvs)\n        if (v.size() < n)\n            return false;\n\n    for (int i=0; i<n; i++) {\n        for (int j=1; j<vvs.size(); j++) {\n            if (vvs[j][i] > vvs[j][i-1])\n                return false;\n        }\n    }\n    return true;\n}\n\n\nbool check2(int k) {\n    for (int i=2; i<=k; i++)\n        if (cnt[i][0] > cnt[i-1][0])\n            return false;\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m, q;\n    cin>>n>>m>>q;\n\n    for (int i=1; i<=q; i++) {\n        int x;\n        cin>>x;\n        cnt[x].push_back(i);\n    }\n\n    vector<vector<int>> vvs;\n    int mx = 0;\n    for (int i=1; i<=m; i++) {\n        reverse(cnt[i].begin(), cnt[i].end());\n        if (i == 1) {\n            while (cnt[i].size() < n)   cnt[i].push_back(0);\n        }\n        if (cnt[i].size())  vvs.push_back(cnt[i]), mx = i;\n    }\n\n    if (check(vvs, n)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n    if (check2(mx)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n\n    cout<<\"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1){\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n      }\n    }else{\n      assert(false);\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n#include <fstream>\n\nusing namespace std;\n\n\n#define LL long long\n#define N 200100\n#define M 10000100\n#define MP make_pair\n#define Pi acos(-1.0)\n#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n#define ls (rt << 1)\n#define rs (ls | 1)\n#define md ((ll+rr)/2)\n#define lson ll, md, ls\n#define rson md+1, rr, rs\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define sqr(x) ((x)*(x))\n#define eps 1e-6\n#define MP make_pair\n#define uLL unsigned long long\nLL powmod(LL a,LL b) {LL res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n#define F(x) ((x)/3+((x)%3 == 1 ? 0 : tb))\n#define G(x) ((x)<tb ? (x)*3+1 : ((x) - tb)*3+2)\n#define lowbit(x) ((x)&(-x))\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nint gcd(int x,int y){\n    while(y){\n        int t = x % y;\n        x = y;\n        y = t;\n    }\n    return x;\n}\n\nint pos[N],a[N],on[N],at[N];\n\nint main(){\n    int n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i = 0; i < q; i++)\n        scanf(\"%d\",&a[i]),a[i]--;\n    \n    for(int i = 0; i < m; i++){\n        at[i] = 0;\n        pos[i] = -1;\n        on[i] = -1;\n    }\n    \n    int have = 0;\n    at[0] = n;\n    at[m] = 0;\n    for(int i = q - 1; i >= 0; i--){\n        int v = a[i];\n        if(pos[v] == -1){\n            pos[v] = have;\n            on[have] = v;\n            at[have]--;\n            have++;\n            at[have]++;\n            continue;\n        }\n        if(at[pos[v]] > 0)\n            at[pos[v]]--,at[pos[v]+1]++;\n    }\n    \n    int fs = -1;\n    for(int i = 0; i < m; i++)\n        if(at[i] > 0){\n            fs = i;\n            break;\n        }\n    \n    vector<int> all;\n    for(int i = fs; i < have; i++){\n        all.push_back(on[i]);\n    }\n    for(int i = 0; i < m; i++)\n        if(pos[i] == -1)\n            all.push_back(i);\n    \n    sort(all.begin(), all.end());\n    \n    for(int i = fs; i < have; i++)\n        if(on[i] != all[i - fs]){\n            puts(\"No\");\n            return 0;\n        }\n    puts(\"Yes\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define VPII vector<pair<int,int> >\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<58;\nconst double eps = 1e-13;\n\nint d[100009];\nint cameout[100009];\nint cc[100009];\nvector<int> sq;\n\nint main(){\n\tDRIII(n,m,q);//number of arrays,length\n\tREP(i,q){\n\t\tRI(d[i]);d[i]--;\n\t}\n\tMS1(cameout);\n\tint ci=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(cameout[d[i]]!=-1)continue;\n\t\tcameout[d[i]]=ci++;\n\t\tsq.PB(d[i]);\n\t}\n\tint minleft=100009;\n\tREP(i,m){\n\t\tif(cameout[i]==-1)minleft=min(minleft,i);\n\t}\n\tfor(int i=ci-1;i>=0;i--){\n\t\tif(sq[i]<minleft){\n\t\t\tcameout[sq[i]]=-1;\n\t\t\tci--;\n\t\t\tminleft=sq[i];\n\t\t}\n\t\telse break;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(cameout[d[i]]==-1)continue;\n\t\tint ci=cameout[d[i]];\n\t\tcc[ci]++;\n\t\tif(ci!=0){\n\t\t\tcc[ci]=min(cc[ci],cc[ci-1]);\n\t\t}\n\t}\n\t//printf(\"%d\",ci);\n\tREP(i,ci){\n\t\tif(cc[i]<n){\n\t\t\tprintf(\"No\");return 0;\n\t\t}\n\t}printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(g[m]) return 1;\n\telse if(f[m]) return 1;\n\n\treturn 0;\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tif(d[1]) e[1]=d[1];\n\n\tfor(int i=2; i<=M; i++){\n\n\t\tif(d[i]==0||e[i-1]==INF) e[i]=INF;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]>=e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=e[i-1];\n\t\t}\n\t\t\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif((d[i]<e[i-1]&&d[i]!=0)&&e[i-1]!=INF) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    //REPN(i,1,l){\n        if(dat[l]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    //}\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 100100\nint n, m, q;\nint a[N];\n\nint b[N];\nint c[N], L;\nbool v[N];\n\nint u[N];\nint fi[N];\n\nint main () {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i ++) {\n\t\tcin >> a[i];\n\t\ta[i] --;\n\t}\n\t/*\n\tif (a[q-1] == 0) {\n\t\tint u = q-1;\n\t\tint nw = 0;\n\t\tbool F = true;\n\t\twhile (nw < m-1 && u >= 0) {\n\t\t\tif (a[u] != nw) {\n\t\t\t\tF = false; break;\n\t\t\t}\n\t\t\twhile (u >= 0 && a[u] <= nw) u--;\n\t\t\tnw ++;\n\t\t}\n\t\tif (F) {puts (\"Yes\"); return 0;}\n\t}\n\t*/\n\tmemset(v, 0, sizeof v);\n\tmemset(b, -1, sizeof b);\n\tfor (int i = q-1; i >= 0; i --) if (!v[a[i]]) {\n\t\tb[a[i]] = L;\n\t\tc[L++] = a[i];\n\t\tv[a[i]] = 1;\n\t}\n\tmemset(v, 0, sizeof v);\n\tint la = 0;\n\tint lw = 0;\n\tfor (int i = 0; i < L; i ++) {\n\t\tif (c[i] != lw) la = i+1;\n\t\tv[c[i]] = 1;\n\t\twhile (v[lw]) lw++;\n\t}\n\tif (la == 0) {\n\t\tputs (\"Yes\");\n\t\treturn 0;\n\t}\n\tmemset(fi, -1, sizeof fi);\n\tmemset(v, 0, sizeof v);\n\tfor (int i = q-1; i >= 0; i --) {\n\t\tif (b[a[i]] >= la) continue;\n\t\tif (b[a[i]] == 0 && u[0] == n) continue;\n\t\tif (b[a[i]] > 0 && u[b[a[i]]-1] == u[b[a[i]]]) continue;\n\t\tif (fi[b[a[i]]] == -1) fi[b[a[i]]] = i;\n\t\tv[i] = 1;\n\t\tu[b[a[i]]] ++;\n\t}\n\tif (u[la-1] != n) {\n\t\tputs (\"No\"); return 0;\n\t}\n\tbool F = true;\n\tfor (int i = q-1; i >= 0; i --) if (!v[i]) {\n\t\tif (b[a[i]] >= la) {\n\t\t\tif (fi[la-1] < i) {\n\t\t\t\tF = false; break;\n\t\t\t}\n\t\t} else \n\t\tif (b[a[i]] >= 0) {\n\t\t\tif (fi[b[a[i]]] < i) {\n\t\t\t\tF = false; break;\n\t\t\t}\n\t\t}\n\t}\n\tif (F) puts (\"Yes\"); else puts (\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<int> pnt;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    pnt = vector<int>(N, Q);\n    int mn = 0;\n    int st = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        while(mn < M && chk[mn]) mn++;\n        bool ok = true;\n        int pos = (int)Pos[arr[i]].size() - 1;\n        for(int j = N - 1; j >= 0; j--) {\n            while(pos >= 0 && Pos[arr[i]][pos] >= pnt[j]) pos--;\n            if(pos < 0) {\n                if(arr[i] != mn) ok = false;\n                for(int k = j; k >= st; k--) pnt[k] = -1;\n                st = j + 1;\n                break;\n            }\n            pnt[j] = Pos[arr[i]][pos--];\n        }\n        if(!ok) {\n            printf(\"No\");\n            return 0;\n        }\n        chk[arr[i]] = 1;\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  if (v[0]==1) {\n    for (i=1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) { puts(\"Yes\"); return 0; }\n  }\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=j?min(f[j]+1,f[j-1]):(f[j]+1);\n  }\n  j=int(v.size())-1;\n  if (v[j]==1) j--;\n  puts((f[j]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n\nsigned main(){\n    int n, m;\n    cin >> m >> n;\n    int q;\n    cin >> q;\n    vector<int> a(q);\n    for(auto& x : a){\n        cin >> x;\n        --x;\n    }\n\n    auto rev = a;\n    reverse(rev.begin(), rev.end());\n    for(int i = 0; i < n; ++i)\n        rev.emplace_back(i);\n    unordered_set<int> s;\n    vector<int> final;\n    for(auto& x : rev)\n        if(s.find(x) == s.end()){\n            s.insert(x);\n            final.emplace_back(x);\n        }\n    rev.resize(rev.size() - n);\n\n    vector<int> inv(n);\n    for(int i = 0; i < n; ++i)\n        inv[final[i]] = i;\n\n    vector<int> dp(n + 1, 0);\n    dp[0] = m;\n    for(auto& x : rev){\n        if(dp[inv[x]] == 0){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        --dp[inv[x]];\n        ++dp[inv[x] + 1];\n    }\n\n    int c;\n    int ma = MOD;\n    for(c = n - 1; c >= 0; --c){\n        if(ma < final[c])\n            break;\n        ma = final[c];\n    }\n    c++;\n    /*\n    cout << c << endl;\n\n    for(int i = 0; i < n; ++i)\n        cout << final[i] + 1 << \" \\n\"[i == n - 1];\n\n    for(int i = 0; i <= n; ++i)\n        cout << dp[i] << \" \\n\"[i == n];\n        */\n\n    cout << (accumulate(next(dp.begin(), c), dp.end(), 0) == m ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n\n    int last = -1;\n    drep(i,v.size()){\n        if(v[i].first <= mex){\n            last = i;\n            break;\n        }\n    }\n\n    /*\n    drep(i,v.size()){\n        // if(i == last)break;\n        if(i == v.size() - 1 && v[i].first <= mex)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n    */\n\n    int use[m+1] = {};\n    int mex2 = 1;\n    rep(i,v.size()){\n        if(v[i].second == n){\n            use[v[i].first] = 1;\n            continue;\n        }else{\n            while(use[mex2] == 1)mex2++;\n            if(v[i].first == mex2){\n                use[mex2] = 1;\n            }else{\n                flag = 0;\n                break;\n            }\n        }\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N,M,Q,a[100000],tree[1<<18],c[100001];\nbool b[100001];\nvector<int>v;\nmap<int,int>mp;\n\nvoid add(int x,int t){\n\tx+=(1<<17);\n\twhile(x){\n\t\ttree[x]+=t;\n\t\tx/=2;\n\t}\n}\n\nint calc(int p,int q,int l,int r,int k){\n\tif(r<p||q<l)return 0;\n\tif(p<=l&&r<=q)return tree[k];\n\telse{\n\t\treturn (calc(p,q,l,(l+r)/2,k*2)+calc(p,q,(l+r)/2+1,r,k*2+1));\n\t}\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tfor(int i=0;i<Q;++i){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=Q-1;i>=0;--i){\n\t\tif(b[a[i]])continue;\n\t\tv.push_back(a[i]);\n\t\tb[a[i]]=true;\n\t}\n\tfor(int i:v){\n\t\tadd(i,1);\n\t}\n\twhile(!v.empty()){\n\t\tif(calc(0,v.back(),0,(1<<17)-1,1)==v.back()){\n\t\t\tadd(v.back(),-1);\n\t\t\tv.pop_back();\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\tc[0]=N;\n\tfor(int i=0;i<v.size();++i){\n\t\tmp[v[i]]=i;\n\t}\n\tfor(int i=Q-1;i>=0;--i){\n\t\tif(mp.find(a[i])!=mp.end()){\n\t\t\tint t=mp[a[i]];\n\t\t\tif(c[t]){\n\t\t\t\t--c[t];\n\t\t\t\t++c[t+1];\n\t\t\t}\n\t\t}\n\t}\n\tif(c[v.size()]==N){\n\t\tcout<<\"Yes\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"No\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17;\n\nint bio[MAX];\nvector <int> Poz[MAX];\nint p[MAX];\n\nvoid Nope()\n{\n  printf(\"No\\n\");\n  exit(0);\n}\n\nvector <int> Kad(vector <int> V, int br)\n{\n  int ind = (int) V.size() - 1;\n  vector <int> R;\n\n  for (; ind >= 0 && Poz[br].size(); ) {\n    if (Poz[br].back() < V[ind]) {\n      R.push_back(Poz[br].back());\n      ind--;\n    }\n    Poz[br].pop_back();\n  }\n\n  if (ind >= 0)\n    Nope();\n\n  return R;\n}\n\nint n, m, q;\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &q);\n\n  for (int i=0; i<q; i++) {\n    scanf(\"%d\", &p[i]);\n    Poz[p[i]].push_back(i);\n  }\n\n  vector <int> T;\n  for (int i=0; i<n; i++)\n    T.push_back(MAX);\n\n  int tmin = 1;\n  for (int i=q-1; i>=0; i--) {\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] == tmin)\n      tmin++;\n    else if (p[i] < tmin) {\n      tmin = 0;\n      break;\n    }\n  }\n  tmin--;\n\n  memset(bio, 0, sizeof bio);\n\n  for (int i=q-1; i>=0; i--) {\n    if (bio[p[i]]++)\n      continue;\n\n    if (p[i] <= tmin)\n      break;\n\n    T = Kad(T, p[i]);\n  }\n\n  printf(\"Yes\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 0; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] < n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tif (now == -1) return 1;\n\tfor(int i = now, j = 0; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }else{\n          goto fail;\n        }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nint N,M,Q;\n\nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n\nconst int INF=1000000009;\n\nbool dcs(int m,int q){\n\n\tif(m==1) return 1;\n\n\tif(g[m]){\n\t\tif(dcs(m-1,q-c[m])) return 1;\n\t\telse return 0;\n\t}else{\n\t\tif(dcs(m-1,q-c[m])){\n\t\t\tif(f[m]) return 1;\n\t\t\telse return 0;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tcin>>N>>M>>Q;\n\n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n\n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i;\n\n\tfor(int i=0; i<100005; i++) e[i]=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]<e[i-1]){\n\t\t\te[i]=d[i];\n\t\t}else{\n\t\t\te[i]=e[i-1];\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]<e[i-1]) f[i]=1;\n\t}\n\n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nconst int M = 100005;\n\nint n, m, q;\n\nint a[M];\nbool used[M];\nint cnt[M], ord[M];\nvector<int> seq;\n\nvoid add(int x) {\n  if (!used[x]) {\n    int f = seq.size();\n    used[x] = true;\n    ord[x] = f;\n    if (cnt[i] > 0) {\n      cnt[i] -= 1;\n      cnt[i + 1] += 1;\n    }\n    seq.push_back(x);\n  } else {\n    int k = ord[x];\n    if (cnt[i] > 0) {\n      cnt[i] -= 1;\n      cnt[i + 1] += 1;\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m >> q;\n  for (int i = 0; i < q; i += 1) {\n    cin >> a[i];\n    a[i] -= 1;\n  }\n  reverse(a, a + q);\n  cnt[0] = n;\n  for (int i = 0; i < q; i += 1) add(a[i]);\n  for (int i = 0; i < m; i += 1) if (!used[i]) seq.push_back(i);\n  int sh = 0;\n  while (!cnt[sh]) sh += 1;\n  auto alt = seq;\n  sort(alt.begin() + sh, alt.end());\n  if (alt == seq) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n, m; cin >> n >> m;\n\tvector<int> at(m, -1), cnt(m + 1, 0), stk;\n\tcnt[0] = n;\n\tint q; cin >> q;\n\tvector<int> op(q);\n\tfor(int & v : op) cin >> v;\n\treverse(op.begin(), op.end());\n\tfor(int & v : op){\n\t\tv--;\n\t\tif(at[v] == -1){\n\t\t\tstk.push_back(v);\n\t\t\tat[v] = stk.size();\n\t\t\tcnt[at[v]] = 1;\n\t\t} else {\n\t\t\tif(cnt[at[v] - 1] > cnt[at[v]]){\n\t\t\t\tcnt[at[v]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint len = stk.size() + 1;\n\tvector<int> res;\n\tfor(int i = 0, j = 0; i < len; i = j){\n\t\twhile(j < len && cnt[j] == cnt[i]) j++;\n\t\tvector<int> holm;\n\t\tfor(int k = 1; k < j; k++) holm.push_back(stk[k - 1]);\n\t\tfor(int k = 0; k < m; k++) if(at[k] == -1 || at[k] >= j) holm.push_back(k);\n\t\tif(res.empty()) res = holm;\n\t\telse if(res != holm){\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 100010;\nVI a;\nbool done[N];\n\nbool match(int n, int m, const VI &target, const VI &op, int tol) {\n  VI inv_t(n);\n  REP(i, 0, m) {\n    inv_t[target[i]] = i;\n  }\n  VI prog(m + 1);\n  VI pass(m + 1);\n  prog[0] = n;\n  REP(i, 0, op.size()) {\n    if (prog[inv_t[op[i]]] == 0 && !pass[inv_t[op[i]]]) {\n      return false;\n    }\n    if (prog[inv_t[op[i]]] == 0) {\n      continue;\n    }\n    prog[inv_t[op[i]]]--;\n    prog[inv_t[op[i]] + 1]++;\n    pass[inv_t[op[i]]] = 1;\n  }\n  if (0) {\n    REP(i, 0, m + 1) {\n      cout << \"prog[\" << i << \"]=\" << prog[i] << endl;\n    }\n  }\n  REP(i, 0, tol) {\n    if (prog[i] > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint main(void){\n  int n, m, q;\n  cin >> n >> m >> q;\n  a = VI(q);\n  REP(i, 0, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  reverse(a.begin(), a.end());\n  int head = a[0];\n  VI target(m);\n  REP(i, 0, m) {\n    target[i] = i;\n  }\n  cout << (match(n, m, target, a, 0) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != cur[k]-1) ans = false;\n\t\t\tif (cur[k] < 0) break;\n\t\t\tcur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  int hi = S.size();\n  // reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FOR(i, q) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        // if(lo<ix[A[i]]) {\n        //   goto fail;\n        // }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint N, M, Q;\nvector <int> a;\n\nint main()\n{\n\tcin >> N >> M;\n\tcin >> Q;\n\tfor (int i=0; i<Q; i++){\n\t\tint input;\n\t\tcin >> input;\n\t\ta.push_back(input);\n\t}\n\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    // int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        // else ++skipped;\n    }\n    bool ans = true;\n    // if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n    //     ans = false;\n    // }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    REP(i, m) {\n        if (cnt[i] > 0) {\n            FOR(j, i, m-1) {\n                if (seq[j+1] < seq[j]) ans = false;\n            }\n            break;\n        }\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = q + 1;\n\tint id = 1;\n\tbool force = false ;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tint idx = vec[A[i]].size() - 1;\n\t\tbound[1] = vec[A[i]][idx];\n\t\tbool no = false ;\t\t\n\t\tFor(j,2,m) {\n\t\t\tif (--idx < 0) {\n\t\t\t\tno = true;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\twhile (bound[j] < vec[A[i]][idx]) {\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tno = true;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][idx];\n\t\t}\n\t\tif (no) {\n\t\t\tforce = true;\n\t\t}\n\t\tvis[A[i]] = true;\n\t\tif (force) {\n\t\t\tif (id == A[i]) {\n\t\t\t\twhile (vis[id]) ++id;\n\t\t\t\tcontinue ;\n\t\t\t} else {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\twhile (vis[id]) ++id;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint ans[200000];\nint now[200000];\nint aaa[200000];\nint main()\n{\n\tint num,len,query;\n\tscanf(\"%d%d%d\",&num,&len,&query);\n\tvector<int>v;\n\tfor(int i=0;i<query;i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\",&z);\n\t\tz--;\n\t\tv.push_back(z);\n\t}\n\treverse(v.begin(),v.end());\n\tset<int>se;\n\tvector<int>dd;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(se.find(v[i])==se.end())\n\t\t{\n\t\t\tans[v[i]]=se.size()+1;\n\t\t\tse.insert(v[i]);\n\t\t\tdd.push_back(v[i]);\n\t\t}\n\t\tint x=ans[v[i]];\n\t\tint beg=0,end=num;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(beg==end)break;\n\t\t\tint med=(beg+end)/2;\n\t\t\tif(now[med]<x)end=med;\n\t\t\telse beg=med+1;\n\t\t}\n\t\t//printf(\"  %d %d  %d\\n\",beg,v[i]+1,x);\n\t\tif(beg!=num&&now[beg]==x-1)\n\t\t{\n\t\t\tnow[beg]++;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++)if(ans[v[i]]==0)dd.push_back(i);\n\tvector<int>z;\n\tfor(int i=0;i<now[num-1];i++)\n\t{\n\t\tz.push_back(dd[i]);\n\t\taaa[dd[i]]=1;\n\t}\n\tfor(int i=0;i<len;i++)if(aaa[i]==0)z.push_back(i);\n\t//for(int i=0;i<len;i++)printf(\"%d %d\\n\",dd[i]+1,z[i]+1);\n\tif(dd==z)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int M=1e5+10;\nconst int Q=1e5+10;\n\nint n,m,q,a[Q];\nbool vis[M];\nmultiset<int> s[M];\n\nbool solve() {\n    VI v;\n    for ( int i=q; i>=1; i-- ) if ( !vis[a[i]] ) {\n        vis[a[i]]=1;\n        v.PB(a[i]);\n    }\n    REP1(i,1,m) if ( !vis[i] ) v.PB(i);\n    assert(SZ(v)==m);\n    int g=m-1;\n    while ( g>0 && v[g]>v[g-1] ) g--;\n    dump(g,v);\n    REP1(i,1,n) s[a[q]].insert(0);\n    for ( int i=q; i>=1; i-- ) {\n        int x=a[i];\n        if ( s[x].empty() ) continue;\n        int t=*s[x].begin();\n        s[x].erase(s[x].begin());\n        if ( t+1==m ) continue;\n        s[v[t+1]].insert(t+1);\n    }\n    REP1(i,1,m) for ( int j:s[i] ) if ( j<g ) return 0;\n    return 1;\n}\n\nint main() {\n    R(n,m,q);\n    REP1(i,1,q) R(a[i]);\n    bool ans=solve();\n    W(ans?\"Yes\":\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vec a(Q);\n    for(int i=0;i<Q;i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vector<int> final;\n    vector<int> que(M + 1, 0);\n    vector<int> next(M, -1);\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(used[a[p]]){\n\n            }else{\n                used[a[p]] = true;\n                if(final.size() > 0) next[final[final.size() - 1]] = a[p];\n                final.push_back(a[p]);\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                if(next[i] <= i){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5;\nint a[N],st[N],pos[N],cnt[N],vis[N];\nint n,m,q,top,p;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfp(i,1,q)scanf(\"%d\",&a[i]);\n\tfd(i,q,1)if(!vis[a[i]])st[++top]=a[i],vis[a[i]]=1;\n\tfp(i,1,m)if(!vis[i])st[++top]=i;\n\tfp(i,1,m)pos[st[i]]=i;\n\tp=m;\n\twhile(p>1&&st[p-1]<st[p])--p;\n\tif(p==1)return puts(\"Yes\"),0;\n\tcnt[0]=2333333;\n\tfd(i,q,1)if(cnt[pos[a[i]]-1])--cnt[pos[a[i]]-1],++cnt[pos[a[i]]];\n\tR int res=0;\n\tfp(i,p-1,m)res+=cnt[i];\n\tputs(res>=n?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    int lst=0,w=0;\n    for(auto u:st){\n        if(u.second>lst)\n            w++;\n        else\n            w=1;\n        lst=u.second;\n    }\n\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n            }\n        }\n    }\n\n\n    vi g[n];\n    for(int i=0;i<SZ(kek);i++){\n        for(int j=0;j<cnt[kek[i]];j++){\n            g[j].push_back(kek[i]);\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        int p=0;\n        bool fl=true;\n        for(auto u:st){\n            if(SZ(g[i])==p)\n                break;\n            if(g[i][p]!=u.second){\n                fl=false;\n                break;\n            }\n            p++;\n        }\n        if(!fl){\n            cout<<\"No\";\n            return;\n        }\n        if(w<m-p){\n            cout<<\"No\";\n            return;\n        }\n    }\n\n\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = -1;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK \"1\"\n\nusing namespace std;\n\nint n, m, q;\nvector<int> need[N], ans[N];\n\nint used[N];\nint t[N];\nint was[N];\n\nvector<int> dop(vector<int> a) {\n\tfor (int i = 1; i <= m; i++) used[i] = 0;\n\tfor (int i = 0; i < a.size(); i++) used[a[i]] = 1;\n\tfor (int i = 1; i <= m; i++) if (!used[i]) a.pb(i);\n\treturn a;\n}\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK\".in\",\"r\",stdin);\t\n\t\tfreopen(TASK\".out\",\"w\",stdout);\n\t#endif\t\t\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> t[i];\n\t}\n\tfor (int i = 1; i < n; i++) need[0].pb(i);\n\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tint g = t[i];\n\n\t\tif (was[g] == 0) {\n\t\t\tans[0].pb(g);\n\t\t\twas[g] = 1;\n\n\t\t\tfor (int h : need[0]) need[g].pb(h);\n\t\t\tneed[0].clear();\n\n\t\t\tcontinue;\n\t\t}\n\t\tif (need[g].size() == 0) {\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tint t = need[g].back();\n\t\tneed[g].pop_back();\n\n\t\tans[t].pb(g);\n\n\t\tif (ans[t].size() < m) {\n\t\t\tif (ans[0].size() == ans[t].size()) need[0].pb(t); else need[ans[0][ans[t].size()]].pb(t);\n\t\t}\n\t}\n//\tfor (int i = 0; i < n; i++) {\n//\t\tfor (int j = 0; j < ans[i].size(); j++) cout << ans[i][j] << \" \";\n//\t\tcout << endl;\n//\t}\n\tint x = -1;\n\tfor (int i = 0; i < n; i++) if (x == -1 || ans[i].size() < ans[x].size()) x = i;\n\tif (dop(ans[0]) != dop(ans[x])) cout << \"No\\n\"; else cout << \"Yes\\n\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int N, M, Q; scanf(\"%d%d%d\", &N, &M, &Q);\n  static pair<int,int> queries[100000];\n  for(int i = 0; i < Q; ++i) {\n    scanf(\"%d\", &queries[i].first); --queries[i].first;\n    queries[i].second = i;\n  }\n  sort(queries, queries+Q);\n  // printf(\"queries = \");\n  // for(int i = 0; i < Q; ++i) {\n  //   printf(\"(%d, %d), \", queries[i].first, queries[i].second);\n  // }\n  // printf(\"\\n\");\n  static int qidx[100001];\n  {\n    int i = 0;\n    for(int j = 0; j <= M; ++j) {\n      while(i < Q && queries[i].first < j) ++i;\n      qidx[j] = i;\n    }\n  }\n  // printf(\"qidx = \");\n  // for(int i = 0; i <= M; ++i) {\n  //   printf(\"%d, \", qidx[i]);\n  // }\n  // printf(\"\\n\");\n  static int lru_seq[100000];\n  for(int i = 0; i < M; ++i) {\n    lru_seq[i] = i;\n  }\n  sort(lru_seq, lru_seq+M, [&](int x, int y) -> bool {\n      int xx = (qidx[x] == qidx[x+1]) ? ~x : queries[qidx[x+1]-1].second;\n      int yy = (qidx[y] == qidx[y+1]) ? ~y : queries[qidx[y+1]-1].second;\n      return xx < yy;\n  });\n  // printf(\"lru_seq = \");\n  // for(int i = 0; i < M; ++i) {\n  //   printf(\"%d, \", lru_seq[i]);\n  // }\n  // printf(\"\\n\");\n  int max_ign = 0;\n  while(max_ign < M && lru_seq[max_ign] == lru_seq[0] - max_ign) ++max_ign;\n  // printf(\"max_ign = %d\\n\", max_ign);\n  for(int i = max_ign; i < M; ++i) {\n    if(qidx[lru_seq[i]+1] - qidx[lru_seq[i]] < N) {\n      printf(\"No\\n\");\n      return 0;\n    }\n  }\n  for(int i = max_ign; i+1 < M; ++i) {\n    int pos1 = qidx[lru_seq[i]+1]-N;\n    int pos2 = qidx[lru_seq[i+1]+1]-N;\n    for(int j = 0; j < N; ++j) {\n      if(queries[pos1+j].second > queries[pos2+j].second) {\n        printf(\"No\\n\");\n        return 0;\n      }\n    }\n  }\n  printf(\"Yes\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M, Q;\nvector<int> arr;\nvector<int> chk;\nvector<vector<int> > Pos;\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    arr.resize(Q);\n    Pos.resize(M);\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &arr[i]);\n        arr[i]--;\n        Pos[arr[i]].push_back(i);\n    }\n    chk = vector<int>(M, 0);\n    int mn = 0;\n    for(int i = Q - 1; i >= 0; i--) {\n        if(chk[arr[i]]) continue;\n        if(arr[i] == mn) {\n            chk[arr[i]] = 1;\n            while(mn < M && chk[mn]) mn++;\n            continue;\n        }\n        if(Pos[arr[i]].size() < N) {\n            printf(\"No\");\n            return 0;\n        }\n        int len = 1e9;\n        for(int j = (int)Pos[arr[i]].size() - 1; j >= (int)Pos[arr[i]].size() - N; j--) {\n            len = min(len, Pos[arr[i]][j] - (j == 0? -1 : Pos[arr[i]][j - 1]));\n        }\n        for(int j = 0; j < len; j++) {\n            bool ok = true;\n            for(int k = (int)Pos[arr[i]].size() - 1; k >= (int)Pos[arr[i]].size() - N + 1; k--) {\n                if(arr[Pos[arr[i]][k] - j] != arr[Pos[arr[i]][k - 1] - j]) {\n                    ok = false;\n                    break;\n                }\n                chk[ arr[ Pos[arr[i]][k] - j ] ] = 1;\n            }\n            if(!ok) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Yes\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    int n, m, nq;\n    cin >> n >> m >> nq;\n\n    vector<vector<int>> positions(m);\n    vector<int> q(nq);\n\n    for (int i = 0; i < nq; i++)\n    {\n        cin >> q[i];\n        q[i]--;\n        positions[q[i]].push_back(i);\n    }\n\n    vector<int> lastPos(n, m);\n\n    bool fail = false;\n    int maxNumber = 0;\n    bool maxedOut = false;\n\n    set<int> used;\n    for (int i = nq - 1; i >= 0; i--)\n    {\n        if (used.count(q[i])) continue;\n\n        used.insert(q[i]);\n\n        //if (used.size() == m) break;\n\n        if (maxedOut)\n        {\n            if (q[i] < maxNumber)\n            {\n                fail = true;\n                break;\n            }\n            continue;\n        }\n\n        vector<int> newLastPos;\n\n        int j = positions[q[i]].size() - 1;\n        for (int filled = 0; filled < n; filled++)\n        {\n            while (j >= 0 && positions[q[i]][j] > lastPos[filled])\n                j--;\n\n            if (j < 0)\n            {\n                maxedOut = true;\n                maxNumber = q[i];\n                break;\n            }\n\n            newLastPos.push_back(positions[q[i]][j]);\n            j--;\n        }\n\n        lastPos = newLastPos;\n    }\n\n    breakAll:;\n    printf(\"%s\\n\", fail ? \"No\" : \"Yes\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n//# pragma GCC target (\"sse4\")\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n,m,q;\n    static int s[1 << 20];\n    fi>>n>>m>>q;\n    for (int i = 1;i <= q;++i)\n        fi>>s[i];\n    vector < int > S;\n    int ok = 1;\n    for (int i = 0;i < S.size();++i)\n        ok &= S[i] == i + 1;\n    if (ok) return puts(\"Yes\") * 0;\n    static int was[1 << 20];\n    for (int i = 1;i <= m;++i)\n        was[i] = -1;\n    for (int i = q;i;--i)\n        if (was[s[i]] == -1)\n            S.push_back(s[i]),was[s[i]] = 1;\n    static int cnt[1 << 20];\n    cnt[0] = n;\n    int sz = S.size();\n    static int where[1 << 20];\n    for (int i = 0;i < sz;++i)\n        where[S[i]] = i + 1;\n    int until = sz;\n    for (int i = sz - 1;i;--i)\n        if (S[i] > S[i-1])\n            --until;\n        else\n            break;\n    for (int i = q;i;--i)\n    {\n        const int index = where[s[i]] - 1;\n        if (cnt[index])\n            --cnt[index],++cnt[index + 1];\n    }\n    fo << (*max_element(cnt,cnt+until) ? \"No\" : \"Yes\") << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=100005;\nint n,m,q,a[MAXN],pos[MAXN],beg=0,dest[MAXN];\nbool vis[MAXN];\nint cnt[MAXN];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=q;i>0;--i){\n\t\tif(!vis[a[i]]){\n\t\t\tpos[a[i]]=++beg;\n\t\t\tdest[beg]=a[i];\n\t\t\tvis[a[i]]=true;\n\t\t}\n\t}\n\tint t=0;\n\tfor(int i=1;i<=m;++i)\n\t\tif(!vis[i])dest[beg+(++t)]=i;\n\tcnt[0]=n;\n\tint mx=0;\n\tfor(int i=q;i>0;--i){\n\t\tint o=pos[a[i]];\n\t\tif(cnt[o-1]){\n\t\t\t--cnt[o-1];\n\t\t\t++cnt[o];\n\t\t\tmx=max(mx,o);\n\t\t}else if(mx<o-1){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\t\n\tint st=n;\n\tfor(int i=0;i<=beg;++i)\n\t\tif(cnt[i]){st=i;break;}\n\tfor(int i=st+2;i<=m;++i)\n\t\tif(dest[i]<dest[i-1]){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << ' ' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define DEBUG(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  vector<int> v;\n  for (int e : a) {\n    if (se.count(e)) {\n      continue;\n    }\n    se.insert(e);\n    v.push_back(e);\n  }\n  for (int i = 0; i < m; ++i) {\n    if (se.count(i)) {\n      continue;\n    }\n    se.insert(i);\n    v.push_back(i);\n  }\n  DEBUG(v);\n  while (v.size() >= 2 and v[v.size() - 2] < v.back()) {\n    v.pop_back();\n  }\n  v.pop_back();\n  DEBUG(v);\n  if (all_of(begin(v), end(v), [&](int e) { return c[e] >= n; })) {\n    cout << \"Yes\\n\";\n  } else {\n    cout << \"No\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size - 1) + 2), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\") \n#pragma warning(disable:4996)\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-10\n#define LL_INF 0x3fffffffffffffff\n#define INF 0x3f3f3f3f\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n\nconst int maxn = 5005;\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\n\nint N, M, Q;\nint A[101010];\nint did[101010];\nint ind[101010];\nvector<int> V;\nint num[101010];\n\nvoid solve() {\n\tint i, j, k, l, r, x, y; string s;\n\n\tcin >> N >> M >> Q;\n\trep(i, 0, Q)\n\t{\n\t\tcin >> A[i];\n\t}\n\tfor (i = Q - 1; i >= 0; i--)\n\t{\n\t\tdid[A[i]]++;\n\t\tif (did[A[i]] == 1)\n\t\t{\n\t\t\tind[A[i]] = V.size();\n\t\t\tV.push_back(A[i]);\n\t\t}\n\t}\n\trep(i, 0, M)\n\t{\n\t\tif (did[i + 1] == 0)\n\t\t{\n\t\t\tind[i + 1] = V.size();\n\t\t\tV.push_back(i + 1);\n\t\t}\n\t}\n\n\twhile (V.size() >= 2 && V[V.size() - 2]<V[V.size() - 1]) V.pop_back();\n\tV.pop_back();\n\n\tnum[0] = N;\n\tfor (i = Q - 1; i >= 0; i--) \n\t{\n\t\tif (num[ind[A[i]]])\n\t\t{\n\t\t\tnum[ind[A[i]]]--;\n\t\t\tnum[ind[A[i]] + 1]++;\n\t\t}\n\t}\n\n\trep(i, 0, V.size())\n\t{\n\t\tif (num[i])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != cur[k]-1) ans = false;\n\t\t\tcur[k] = j;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <memory.h>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <bitset>\n#include <deque>\n#include <ctime>\n#include <stack>\n#include <queue>\n#include <fstream>\n#include <sstream>\n#include <functional>\n/*#ifndef room111\n#include <sys/resource.h>\n#endif*/\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n//#define FILENAME \"\"\n#define mp make_pair\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nbool stress = false;\n\nint main() {\n#ifdef room111\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME\".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n#endif\n\tstart = clock();\n\tint t = 1;\n\tcout.sync_with_stdio(0);\n\tcin.tie(0);\n\tprecalc();\n\tcout.precision(10);\n\tcout << fixed;\n\t/*#ifndef room111\n\tconst rlim_t kStackSize = 128L * 1024L * 1024L;   // min stack size = 64 Mb\n\tstruct rlimit rl;\n\tint result;\n\n\tresult = getrlimit(RLIMIT_STACK, &rl);\n\tif (result == 0)\n\t{\n\tif (rl.rlim_cur < kStackSize)\n\t{\n\trl.rlim_cur = kStackSize;\n\tresult = setrlimit(RLIMIT_STACK, &rl);\n\tif (result != 0)\n\t{\n\tfprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n\t}\n\t}\n\t}\n\t#endif*/\n\n\t//cin >> t;\n\tint testNum = 1;\n\twhile (t--) {\n\t\t//cerr << testNum << endl;\n\t\t//cout << \"Case #\" << testNum++ << \": \";\n\t\tsolve(true);\n\t\t++testNumber;\n\t\t//++timer;\n\t}\n#ifdef room1111\n\twhile (true)\n\t\tsolve(false);\n#endif\n\n#ifdef room111\n\tcerr << \"\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n\treturn 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 300500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\n/*int curMod = 1000000009;\n\nint fact[100500], revfact[100500];\n\nint getC(int n, int k) {\nint res = fact[n] * revfact[n - k] % curMod * revfact[k] % curMod;\nreturn res;\n}*/\n\n/*const int C = 7000500;\n\nint least_prime[C];*/\n\nvoid precalc() {\n\n\t/*for (int i = 2; i < C; ++i) {\n\tif (!least_prime[i]) {\n\tleast_prime[i] = i;\n\tfor (li j = i * 1LL * i; j < C; j += i) {\n\tleast_prime[j] = i;\n\t}\n\t}\n\t}*/\n\n\t/*fact[0] = revfact[0] = 1;\n\tfor (int i = 1; i < 100500; ++i) {\n\tfact[i] = fact[i - 1] * i % curMod;\n\trevfact[i] = binpow(fact[i], curMod - 2, curMod);\n\t}*/\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\n//#define int li\n\n//const int mod = 1000000007;\n\n\nvoid solve(bool read) {\n\tint n, m, Q;\n\tcin >> n >> m >> Q;\n\tvector<int> a(Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\treverse(all(a));\n\n\tvector<int> fixed;\n\tvector<int> next_pos(n);\n\tint INF = 1e9;\n\tvector<int> num_fix(m, -1);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint cur = a[i];\n\t\tif (num_fix[cur] == -1) {\n\t\t\tnum_fix[cur] = fixed.size();\n\t\t\tfixed.push_back(cur);\n\t\t\t++next_pos[0];\n\t\t\tcontinue;\n\t\t}\n\t\tint cur_pos = num_fix[cur];\n\t\tint l = -1, r = n;\n\t\twhile (l + 1 < r) {\n\t\t\tint M = (l + r) / 2;\n\t\t\tif (next_pos[M] > cur_pos) {\n\t\t\t\tl = M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr = M;\n\t\t\t}\n\t\t}\n\t\tif (r < n && next_pos[r] == cur_pos) {\n\t\t\t++next_pos[r];\n\t\t}\n\t}\n\n\tvector<int> fs = fixed;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (num_fix[i] == -1) {\n\t\t\tfs.push_back(i);\n\t\t}\n\t}\n\tvector<int> last;\n\tvector<char> used_last(m, false);\n\tfor (int i = 0; i < next_pos[n - 1]; ++i) {\n\t\tlast.push_back(fixed[i]);\n\t\tused_last[fixed[i]] = true;\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (!used_last[i]) {\n\t\t\tlast.push_back(i);\n\t\t}\n\t}\n\n\tif (last == fs) {\n\t\tcout << \"Yes\\n\";\n\t}\n\telse {\n\t\tcout << \"No\\n\";\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    int N, M;\n    while(cin >> N >> M){\n        int Q; cin >> Q;\n        vector<int> order;\n        vector<int> used(M, 0);\n        vector<int> q(Q);\n        for(auto& t : q){ cin >> t; --t; }\n        reverse(q.begin(), q.end());\n        for(auto& t : q){\n            if(used[t]) continue;\n            used[t] = 1;\n            order.push_back(t);\n        }\n        for(int i=0;i<M;i++) if(!used[i]) order.push_back(i);\n        reverse(order.begin(), order.end());\n        vector<int> idx(M);\n        for(int i=0;i<M;i++) idx[order[i]] = i;\n        vector<int> stock(M, 0);\n        for(int i=0;i<M;i++){\n            if(i+1 == M || order[i] < order[i+1]){\n                stock[i] = N;\n                break;\n            }\n        }\n        reverse(q.begin(), q.end());\n        for(auto& t : q){\n            int p = idx[t];\n            if(p == 0) continue;\n            if(stock[p-1] > 0){\n                --stock[p-1];\n                ++stock[p];\n            }\n        }\n        cout << (stock.back() >= N ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e8;\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nint main()\n{\n\tios_init();\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tint q;\n\t\tcin >> q;\n\t\tvector<int> a(q);\n\t\tREP(i,q) cin >> a[i], a[i]--;\n\t\tvector<int> v;\n\t\tv.reserve(m);\n\t\tvector<bool> f(m,false);\n\t\tRREP(i,q){\n\t\t\tif(!f[a[i]]){\n\t\t\t\tf[a[i]] = true;\n\t\t\t\tv.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tREP(i,q){\n\t\t\tif(!f[i]){\n\t\t\t\tv.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint p = SZ(v)-1;\n\t\tRREP(i,SZ(v)-1){\n\t\t\tif(v[i+1] > v[i]){\n\t\t\t\tp--;\n\t\t\t}else break;\n\t\t}\n\t\tvector<int> mp(m,-10000);\n\t\tREP(i,SZ(v)){\n\t\t\tmp[v[i]] = i;\n\t\t}\n\t\tvector<int> cntv(m,0);\n\t\tRREP(i,q){\n\t\t\tif(mp[a[i]] == 0 or cntv[mp[a[i]]] < cntv[mp[a[i]]-1]){\n\t\t\t\tcntv[mp[a[i]]]++;\n\t\t\t}else{\n\n\t\t\t}\n\t\t}\n\t\tstring ans = \"Yes\";\n\t\tdpite(ALL(cntv));\n\t\tREP(i,p){\n\t\t\tif(cntv[i] < n){\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      //for(i=0;i<k;i++) if(c[i]==0) f=false;\n    }\n  }else{\n    \n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n\n    vec a(Q + M);\n    for(int i = 0; i < M; i++){\n        a[M] = M - i - 1;\n    }\n    for(int i = M; i < Q + M; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q + M - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(!used[a[p]]){\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                int t=v[id].back();v[id].pop_back();\n                if(t>last_used_id[i]){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n    }\n    //ut<<\"k\"<<endl;\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            //ut<<id<<\" \"<<lb<<endl;\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nint n, m, q, a[110000];\nint cur[110000], pre[110000];\nbool vst[110000], ans = true;\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tREP(i,m) cur[i] = -i;\n\tREP(i,q) {\n\t\tscanf(\"%d\", a+i);\n\t\tpre[i] = cur[a[i]];\n\t\tcur[a[i]] = i;\n\t}\n\tREP(i,m) cur[i] = q+1;\n\tint step(0);\n\tROF(i,q,1) if (!vst[a[i]]) {\n\t\tvst[a[i]] = true;\n\t\t++step;\n\t\tint k = 1, j = i;\n\t\twhile (k <= n) {\n\t\t\twhile (j > 0 && j > cur[k]) j = pre[j];\n\t\t\tif (cur[k] < 0 && j != cur[k]-1) ans = false;\n\t\t\tcur[k] = j;\n\t\t\tif (cur[k] < 0) break;\n\t\t\t++k; if (j > 0) j = pre[j];\n\t\t}\n\t}\n\tif (ans) printf(\"Yes\\n\"); else printf(\"No\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    int Q; cin >> Q;\n    vec a(Q); readi(a);\n\n    mat m(N, vec(0));\n    vec count(M, 0);\n    IREP(i, Q){\n        if(count[a[i]] < N){\n            m[count[a[i]]].push_back(a[i]);\n            count[a[i]]++;\n        }\n    }\n    vector<bool> used(M, false);\n    for(int i: m[N - 1]) used[i] = true;\n    REP(i, M) if(!used[i]) m[N - 1].push_back(i);\n\n    bool ans = true;\n    REP(i, N - 1){\n        REP(j, m[i].size()) if(m[i][j] != m[N - 1][j]) ans = false;\n    }\n\n    bool ans2 = true;\n    int t = -1;\n    IREP(i, Q){\n        if(a[i] > t + 1) ans2 = false;\n        t = max(t, a[i]);\n    }\n\n    if(ans || ans2) cout << \"Yes\";\n    else cout << \"No\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nvoid RE(){\n    RE();\n    RE();\n}\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    RE();\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      for(i=0;i<k;i++) if(c[i]==0) f=false;\n    }\n  }else{\n    \n  }\n  //cout << \"Yes\" << endl;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  if(a.back()==1){\n    Int k=1,flg=1;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]<=k) continue;\n      if(a[i]>k+1){\n\tflg=0;\n\tbreak;\n      }\n      k++;\n    }\n    if(flg){\n      cout<<\"Yes\"<<endl;\n      return 0;\n    }\n  }\n  \n  vector<Int> used(m+1,0);\n  vector<Int> dp(q,n);\n  int lst=-1;\n  for(Int b=q-1;b>=0;b--){\n    if(used[a[b]]) continue;\n    if(dp[0]<n){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    used[a[b]]=1;\n    lst=a[b];\n    //cout<<a[b]<<endl;\n    vector<Int> nx(q);\n    Int k=0;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]==a[b]) k++;\n      if(k>dp[i]) k=dp[i];\n      nx[i]=k;\n    }\n    swap(dp,nx);\n  }\n  if(lst!=1&&dp[0]<n){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,k,i,j,a[100100],b[100100],f[100100];\nbool was[100100];\nvector<int> v;\nint main() {\n  scanf(\"%d%d%d\",&n,&m,&k);\n  for (i=0; i<k; i++) scanf(\"%d\",&a[i]);\n  for (i=k-1; i>=0; i--) if (!was[a[i]]) {\n    was[a[i]]=true;\n    b[a[i]]=v.size();\n    v.push_back(a[i]);\n  }\n  if (v[0]==1) {\n    for (i=1; i<v.size(); i++) if (v[i]-v[i-1]!=1) break;\n    if (i>=v.size()) { puts(\"Yes\"); return 0; }\n  }\n  for (i=k-1; i>=0; i--) {\n    j=b[a[i]];\n    f[j]=min(n,(j>0)?min(f[j]+1,f[j-1]):(f[j]+1));\n  }\n  j=int(v.size())-1;\n  if (v[j]==1) j--;\n  puts((f[j]>=n)?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vi a(q);\n  rep (i, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  //DEBUG_VEC(a);\n  \n  vi used(q, -1);\n  int used_cnt = 0;\n  vector<bool> used_x(m);\n  vi pre_idx(n, inf);\n  int idx = q - 1;\n  while (true) {\n    int pre = -1;\n    rrep (i, q) {\n      while (pre >= 0 and pre < m and used_x[pre]) pre++;\n      if (used_x[a[i]]) continue;\n      if (a[i] == pre + 1) {\n        pre = a[i];\n      }\n      else if (a[i] <= pre) continue;\n      else {\n        pre = inf;\n        break;\n      }\n    }\n    if (pre != inf) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(pre);\n    //DEBUG(idx);\n    while (idx >= 0) {\n      if (used_x[a[idx]]) idx--;\n      else break;\n    }\n    if (idx == -1) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(idx);\n\n    used_x[a[idx]] = true;\n    pre_idx[0] = idx;\n    int j = 1;\n    for (int i = idx - 1; i >= 0; i--) {\n      if (a[i] == a[idx] and i < pre_idx[j]) {\n        pre_idx[j] = i;\n        j++;\n      }\n      if (j == n) break;\n    }\n    if (j < n) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint N, M, Q;\nvector <int> a;\nvector <int> ue;\nvector <int> koremade;\nvector <int> nex;\nvector <bool> ok;\n\nint tugi(int val){\n\tfor (int i=0; i<koremade.size(); i++){\n\t\tif (i==koremade.size()-1) return val;\n\t\telse{\n\t\t\tif (val == koremade[i]) return koremade[i+1];\n\t\t}\n\t}\n\tputs(\"error\");\n\treturn val;\n}\n\nint main()\n{\n\n\tcin >> N >> M;\n\tcin >> Q;\n\tfor (int i=0; i<Q; i++){\n\t\tint input;\n\t\tcin >> input;\n\t\ta.push_back(input);\n\t}\n\treverse(a.begin(), a.end());\n\tfor (int i; i<N; i++){\n\t\tfor (int j=M; j>0; j--){\n\t\t\ta.push_back(j);\n\t\t}\n\t}\n\t/*\n\tfor (int i; i<a.size(); i++){\n\t\tcout <<  a[i] << endl;\n\t}*/\n\n\n\tfor (int i; i<N-1; i++){\n\t\tnex.push_back(a[0]);\n\t}\n\n\tfor (int i; i<N-1; i++){\n\t\tok.push_back(0);\n\t}\n\n\tue.push_back(a[0]);\n\tfor (int i; i<N-1; i++){\n\t\tue.push_back(0);\n\t}\n\tkoremade.push_back(a[0]);\n\t\n\tfor (int i=1; i<a.size(); i++){\n\t\tbool flag = 0;\n\t\tfor (int i; i<N-1; i++){\n\t\t\tif (nex[i] == a[i]){\n\t\t\t\tnex[i] = tugi(a[i]);\n\t\t\t\tif (tugi(a[i])==a[i]) ok[i]=1;\n\t\t\t\tue[i] = a[i];\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tif (flag==1) continue;\n\n\t\tbool in=0;\n\t\tfor (int j=0; j<ue.size(); j++){\n\t\t\tif (ue[j]==a[i]){\n\t\t\t\tin = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (in == 1) continue;\n\n\t\tkoremade.push_back(a[i]);\n\t\tue[0] = a[i];\n\t\tfor (int i; i<N-1; i++){\n\t\t\tok[i]=0;\n\t\t}\n\t}\n\tint kekka=0;\n\tfor (int i; i<N-1; i++){\n\t\tif(ok[i] == 0){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tif (it_bound != fixed_index.begin()) {\n\t\t\tit_bound = prev(it_bound);\n\t\t}\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\torder.emplace_back(i);\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < order.size() - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=505,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    int Q;cin>>Q;\n    vector<int> A(Q);\n    for(int i=0;i<Q;i++) cin>>A[i];\n    \n    map<int,int> MA;\n    for(int i=1;i<=M;i++) MA[i]=0;\n    vector<int> last,when(M+1,INF);\n    \n    for(int i=Q-1;i>=0;i--){\n        \n        if(MA[A[i]]==0){\n            when[A[i]]=si(last);\n            last.push_back(A[i]);\n            MA[A[i]]++;\n        }else if(si(last)==1){\n            MA[A[i]]++;\n            if(MA[A[i]]>N) MA[A[i]]=N;\n        }else{\n            int a,b=MA[A[i]];\n            if(when[A[i]]==0){\n                MA[A[i]]++;\n                if(MA[A[i]]>N) MA[A[i]]=N;\n            }else{\n                a=MA[last[when[A[i]]-1]];\n                if(a>b) MA[A[i]]++;\n            }\n        }\n    }\n    \n    vector<int> X=last,Y;\n    for(int i=1;i<=M;i++){\n        if(when[i]==INF) X.push_back(i);\n    }\n    for(int i=0;i<si(last);i++){\n        if(MA[last[i]]==N) Y.push_back(last[i]);\n        else when[last[i]]=INF;\n    }\n    for(int i=1;i<=M;i++){\n        if(when[i]==INF) Y.push_back(i);\n    }\n    \n    if(X==Y) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin n,m,q;\nvector<set<in> > lofn;\nset<in> rmg;\nVI lat;\nVI mar;\nvoid imp(){\n  cout<<\"No\"<<endl;\n  exit(0);\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n>>m;\n  cin>>q;\n  mar.resize(q);\n  forn(i,q){\n    cin>>mar[i];\n    --mar[i];\n  }\n  lat.resize(n,q+2);\n  forn(i,m)\n    rmg.insert(i);\n  lofn.resize(m);\n  forn(i,q){\n    lofn[mar[i]].insert(i);\n  }\n  bool isb;\n  set<in>::iterator it;\n  for(in i=q-1;i>=0;--i){\n    if(rmg.find(mar[i])==rmg.end())\n      continue;\n    in u=mar[i];\n    isb=(*rmg.begin()==u);\n    forv(j,lat){\n      it=lofn[u].upper_bound(lat[j]);\n      if(it==lofn[u].begin()){\n\tif(!isb)\n\t  imp();\n\tif(lat[j]==-1)\n\t  break;\n\tlat[j]=-1;\n\tcontinue;\n      }\n      --it;\n      lat[j]=*it;\n      lofn[u].erase(it);\n    }\n    rmg.erase(u);\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  int q;\n  scanf(\"%d\",&q);\n  vi a(q);\n  rep(i,q) {\n    scanf(\"%d\",&a[i]);\n    --a[i];\n  }\n  reverse(rng(a));\n  vvi p(m);\n  rep(i,q) {\n    p[a[i]].pb(i);\n  }\n  vi used(m);\n  vi r(n);\n  int fr = 0;\n  int s = n;\n  rep(i,q) {\n    if (used[a[i]]) continue;\n    int k = 0;\n    rep(j,sz(p[a[i]])) {\n      if (j < i) continue;\n      if (r[k] > p[a[i]][j]) continue;\n      r[k] = p[a[i]][j]; ++k;\n      if (k >= n) break;\n    }\n    if (s == n && k == n) {\n    } else {\n      if (fr == a[i]) {\n        s = k;\n      } else {\n        puts(\"No\");\n        return 0;\n      }\n    }\n    used[a[i]] = 1;\n    while (fr < m && used[fr]) ++fr;\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\n\n#define maxn 100010\n\nint op[maxn], used[maxn], cnt[maxn], u[maxn];\n\nvoid lemon()\n{\n\tint n,m,q; scanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,1,q) scanf(\"%d\",&op[i]);\n\trep(i,1,q) cnt[op[i]]++;\n\tint s=0, place=-1;\n\trepd(i,q,1)\n\t{\n\t\tint ch=op[i];\n\t\tif (used[ch]) continue;\n\t\tif (cnt[ch]>=n)\n\t\t{\n\t\t\t//use it directly\n\t\t\tused[ch]=1;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//gg \n\t\t\t//supposed all used elements are u_1,\\cdots,u_s\n\t\t\tplace=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (place==-1) \n\t{\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\trep(i,1,m) if (!used[i]) { s++; u[s]=i; }\n\tint cpos=1;\n\trepd(i,place,1)\n\t{\n\t\tint ch=op[i];\n\t\tif (!used[ch] && ch!=u[cpos])\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (used[ch]) continue;\n\t\tused[ch]=1; cpos++;\n\t}\n\tif (cpos!=s+1) \n\t{\n\t\tprintf(\"No\\n\");\n\t\treturn;\n\t}\n\tprintf(\"Yes\\n\");\n}\n\nint main()\n{\n\tios::sync_with_stdio(true);\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"e.in\",\"r\",stdin);\n\t#endif\n\tlemon();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2){\n                if(i==1){\n                    if(E[x][E[x].size()-1] > tp){\n                        printf(\"No\\n\");\n                        return 0;\n                    }\n                    tp = E[x][E[x].size()-1];\n                }\n                else break;\n                continue;\n            }\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  reverse(a.begin(),a.end());\n  vector<Int> u(m+1,-1);\n  vector<Int> v;\n  vector<Int> cnt(m+1,0);\n  cnt[0]=n;\n  \n  for(Int i=0;i<q;i++){\n    if(u[a[i]]<0){\n      u[a[i]]=v.size();\n      v.emplace_back(a[i]);\n    }\n    if(cnt[u[a[i]]]){\n      cnt[u[a[i]]]--;\n      cnt[u[a[i]]+1]++;\n    }\n  }\n  \n  for(Int i=1;i<=m;i++)\n    if(u[i]<0) v.emplace_back(i);\n\n  for(Int i=0;i<m;i++){\n    if(!cnt[i]) continue;\n    Int flg=1;\n    for(Int j=i;j+1<m;j++)\n      flg&=v[j]<v[j+1];\n    if(!flg){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    break;\n  }\n  \n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::queue<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    cut[qv[0]] = true;\n    std::queue<ll> free;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].push(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n            while (free.size()) {\n                nxts[e].push(free.front());\n                free.pop();\n            }\n        } else {\n            ll idx = st.front();\n            st.pop();\n            cnts[idx]++;\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].push(idx);\n            else free.push(idx);\n        }\n    }\n    \n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n\n    {\n        bool ok = true;\n        for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n        if (ok) return true;\n    }\n    \n    {\n        std::set<ll> lack;\n        bool ok = true;\n        for (ll i = minv; i < aim.size(); i++) lack.insert(aim[i]); \n        for (ll i = 1; i <= m; i++) if (!cut[i]) lack.insert(i);\n        for (ll i = minv; i < aim.size(); i++) {\n            ll e = aim[i];\n            if (e != *lack.begin()) ok = false;\n            lack.erase(e);\n        }\n        if(ok) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n        cout<<f[i]<<\" \";\n    }\n    cout<<\"\\n\";\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)||(s==SZ(kek)-1&&kek.back()==1)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n,m;\nint q;\nint a[111111];\n\nint occ[111111];\n\nint lis[111111];int tot=0;\n\nint pos[111111];\n\nint su[111111];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(m);gn(n);\n\tgn(q);\n\trep(i,1,q+1)gn(a[i]);\n\n\tper(i,1,q+1)if(!occ[a[i]]){\n\t\tocc[a[i]]=1;\n\t\tlis[++tot]=a[i];\n\t}\n\trep(i,1,n+1)if(!occ[i])lis[++tot]=i;\n\n\trep(i,1,n+1)pos[lis[i]]=i;\n\twhile(tot>0 && (lis[tot]>lis[tot-1]))tot--;\n\n\ttot--;\n\n\n\tsu[0]=m;\n\n\tint cur=0;\n\tper(i,1,q+1){\n\t\tint d=pos[a[i]];\n\t\tif(su[d-1]){\n\t\t\tsu[d-1]--;\n\t\t\tsu[d]++;\n\t\t\tupmax(cur,d);\n\t\t}else if(d<=cur);\n\t\telse{\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trep(i,0,tot)if(su[i]){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"Yes\\n\");\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#include<vector>\nusing namespace std;\nstruct atom{\n\tint w,where;\n};\nint operator < (atom k1,atom k2){\n\treturn k1.w>k2.w||(k1.w==k2.w&&k1.where>k2.where);\n}\nset<atom>S;\nint n,m,A[110000],K,pd[110000],num[110000],fir,lim,len,s1[110000],s2[110000];\nvector<int>x[110000];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&K);\n\tfor (int i=1;i<=K;i++) scanf(\"%d\",&A[i]),x[A[i]].push_back(i);\n\tfor (int i=1;i<=K;i++) S.insert((atom){K+1,i});\n\tfir=1; lim=0;\n\tfor (int i=1;i<=n;i++) num[i]=K+1;\n\tfor (int now=K;now;now--){\n\t\tif (pd[A[now]]) continue;\n\t\tint rem=n; len=0; int pre=0;\n\t\twhile (pd[fir]) fir++;\n\t\tset<atom>::iterator k=S.begin();\n\t\tfor (int i=x[A[now]].size();i;i--){\n\t\t\tint k1=x[A[now]][i-1];\n\t\t\tif (k==S.end()){\n\t\t\t\tif (fir==K){\n\t\t\t\t\tif (len==0){\n\t\t\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t\t\t}\n\t\t\t\t\tint k2=x[A[now]][0];\n\t\t\t\t\ts2[len]=k2; rem=0; break;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint a=(*k).where,b=(*k).w;\n\t\t\tif (k1>num[rem]){\n\t\t\t\tif (fir==K){\n\t\t\t\t\tif (len==0){\n\t\t\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t\t\t}\n\t\t\t\t\tint k2=x[A[now]][0];\n\t\t\t\t\ts2[len]=k2; rem=0; break;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"No\\n\"); return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen++;\n\t\t\ts1[len]=a; s2[len]=k1;\n\t\t\trem--; k++;\n\t\t\tif (rem==0) break; \n\t\t}\n\t\tif (fir==A[now]){\n\t\t\tlim=max(lim,rem);\n\t\t\twhile (k!=S.end()){\n\t\t\t\tlen++; s1[len]=(*k).where; s2[len]=0; k++;\n\t\t\t}\n\t\t} else if (rem){\n\t\t\tprintf(\"No\\n\"); return 0;\n\t\t}\n\t\tfor (int i=1;i<=len;i++){\n\t\t\tS.erase((atom){s1[i],num[s1[i]]});\n\t\t\tnum[s1[i]]=s2[i];\n\t\t\tif (s2[i]) S.insert((atom){s1[i],num[s1[i]]});\n\t\t}\n\t\tpd[A[now]]=1;\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tcin >> K;\n\tvector<int>v(K);\n\tfor (auto &i : v)cin >> i;\n\tvector<int>box;\n\tvector<int>used(M + 1, 0);\n\tint num = 0;\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tif (used[i])continue;\n\t\tused[i] = 1;\n\t\tbox.push_back(i);\n\t}\n\t//reverse(box.begin(), box.end());\n\tnum = box.back();\n\tbool st = true;\n\t//for (auto i : box)cout << i << endl;\n\tfor (int i = 0; i < box.size(); i++) {\n\t\tif (box[i] != i + 1)st = false;\n\t}\n\tfor (int i = 0; i < N; i++)v.push_back(num);\n\treverse(v.begin(), v.end());\n\tif (st) {\n\t\tcout << \"Yes\\n\";\n\t\treturn 0;\n\t}\n\tvector<set<int>>place(M + 1);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tplace[v[i]].insert(-i);\n\t}\n\t//reverse(box.begin(), box.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tint p = -MOD;\n\t\tfor (auto j : box) {\n\t\t\t//cout << i << \" \" << j << \" \" << p << endl;\n\t\t\tauto it = place[j].lower_bound(p);\n\t\t\tif (it == place[j].end()) {\n\t\t\t\tcout << \"No\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = *it;\n\t\t\tplace[j].erase(it);\n\t\t}\n\t}\n\tcout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2016/09/24 20:56:18 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nusing namespace std;\n\nconst int maxn=100010;\n\nint seat[maxn],a[maxn],sum[maxn],num[maxn];\nbool finish[maxn];\n\nint main()\n{\n\tint n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for (int j=1;j<=q;++j)\n    {\n        scanf(\"%d\",&a[j]);\n    }\n    bool flag=1;\n    int last=0;\n    for (int j=q;j>0;--j)\n    {\n        if (a[j]>last)\n        {\n            if (a[j]==last+1) ++last;\n            else\n            {\n                flag=0;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    int cnt=0;\n    for (int j=n;j>0;--j)\n    {\n        int tis=a[j];\n        if (seat[tis]==0)\n        {\n            ++cnt;\n            seat[tis]=cnt;\n            sum[cnt]=1;\n            num[cnt]=tis;\n        }\n        else\n        {\n            if (finish[tis]) continue;\n            int st=seat[tis];\n            ++sum[st];\n            if (st>1&&sum[st]>sum[st-1]) --sum[st];\n            if (sum[st]==n)\n            {\n                finish[tis]=1;\n                continue;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    int nx=1;\n    while (nx<=m&&finish[nx]) ++nx;\n    for (int j=1;j<=cnt;++j)\n    {\n        if (sum[j]<n)\n        {\n            if (num[j]!=nx)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                ++nx;\n                while (nx<=m&&finish[nx]) ++nx;\n            }\n        }\n    }\n    if (flag) printf(\"No\\n\");\n    else printf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nvoid RE(){\n    RE();\n    RE();\n}\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(P[j].t > 0)break;\n            if(x==1)ck2=1;\n            if(chk && ck2)break;\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                if(chk){\n                    RE();\n                }\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, m; cin>>n>>m;\n  int q; cin>>q;\n  int a[100010];\n  for(int i=0; i<q; i++) cin>>a[i];\n  set<int> st[100010];\n  vector<int> v[100010];\n  for(int i=q-1; i>=0; i--){\n    for(int j=0; j<n; j++){\n      if(st[j].find(a[i])==st[j].end()){\n        st[j].insert(a[i]);\n        v[j].push_back(a[i]);\n        break;\n      }\n    }\n  }\n  for(int i=1; i<=m; i++){\n    if(st[0].find(i)==st[0].end()){\n      v[0].push_back(i);\n    }\n  }\n  int mn=0;\n  for(int i=m-1; i>=1; i--){\n    if(v[0][i]<v[0][i-1]){\n      mn=i; break;\n    }\n  }\n  for(int i=0; i<n; i++){\n    if(v[i].size()<mn){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long target[200000];\nlong long filled[200000];\nlong long go[200000];\nint done[200000];\nint main() {\n\tcout << \"Yes\" << endl;\n\treturn 0;\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m, query;\n\tcin >> n >> m >> query;\n\tvector<long long> inputs;\n\tREP(i, query) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\t//first we need to simulate it!\n\tint now_itr = 0;\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tif (done[inputs[i]] == 0) {\n\t\t\ttarget[inputs[i]] = now_itr;\n\t\t\tfilled[now_itr] = inputs[i];\n\t\t\tdone[inputs[i]] = 1;\n\t\t\tnow_itr++;\n\t\t}\n\t}\n\tnow_itr--;\n\twhile (now_itr > 0) {\n\t\tif (filled[now_itr - 1] > filled[now_itr]) break;\n\t\tnow_itr--;\n\t}\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tint hoge = target[inputs[i]];\n\t\tif (hoge >= now_itr) continue;\n\t\tif (go[hoge] == n) continue;\n\t\tint ok = 0;\n\t\tif (hoge == 0) {\n\t\t\tok = 1;\n\t\t}\n\t\telse if (go[hoge] == 0 || go[hoge] + 1 <= go[hoge - 1]) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tgo[hoge]++;\n\t\t\tif (hoge != 0 && go[hoge] > go[hoge - 1]) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < now_itr; ++i) {\n\t\tif (go[i] < n) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,q,a[N],vis[N],pos[N],cnt[N];\nVI v;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&q);\n\trep(i,0,q) scanf(\"%d\",a+i);\n\treverse(a,a+q);\n\trep(i,0,q) {\n\t\tif (!vis[a[i]]) {\n\t\t\tpos[a[i]]=SZ(v);\n\t\t\tv.pb(a[i]),vis[a[i]]=1;\n\t\t}\n\t}\n\tcnt[0]=n;\n\trep(i,0,q) {\n\t\tint w=pos[a[i]];\n\t\tif (cnt[w]>0) cnt[w]--,cnt[w+1]++;\n\t}\n\trep(i,1,m+1) if (!vis[i]) v.pb(i);\n\trep(i,0,SZ(v)) if (cnt[i]!=0) {\n\t\tbool val=1;\n\t\trep(j,i,m-1) if (v[j]>v[j+1]) val=0;\n\t\tputs(val?\"Yes\":\"No\");\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) {\n            if (a[i] == mark) mark++;\n            else return 0;\n        }\n        if (num == 0 && mark > 1) mark = 0;\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    //rin;\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tcin >> K;\n\tvector<int>v(K);\n\tfor (auto &i : v)cin >> i;\n\tvector<int>box;\n\tvector<int>used(M + 1, 0);\n\tint num = 0;\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tif (used[i])continue;\n\t\tused[i] = 1;\n\t\tbox.push_back(i);\n\t}\n\t//reverse(box.begin(), box.end());\n\tnum = box.back();\n\tbool st = true;\n\t//for (auto i : box)cout << i << endl;\n\tfor (int i = 0; i < box.size(); i++) {\n\t\tif (box[i] != i + 1)st = false;\n\t}\n\n\treverse(v.begin(), v.end());\n\tif (st) {\n\t\tcout << \"Yes\\n\";\n\t\treturn 0;\n\t}\n\tvector<set<int>>place(M + 1);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tplace[v[i]].insert(-i);\n\t}\n\tplace[box.back()].insert(box.size() - 1);\n\tfor (int i = (int)box.size() - 2; i >= 0; i--) {\n\t\tif (box[i] < box[i + 1]) {\n\t\t\tplace[box[i]].insert(i);\n\t\t}\n\t\telse break;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tint p = -MOD;\n\t\tfor (auto j : box) {\n\t\t\t//cout << i << \" \" << j << \" \" << p << endl;\n\t\t\tauto it = place[j].lower_bound(p);\n\t\t\tif (it == place[j].end()) {\n\t\t\t\tcout << \"No\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = *it;\n\t\t\tif (*it <= 0)place[j].erase(it);\n\t\t}\n\t}\n\tcout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  vi CNT(S.size()+1); CNT.back() = n;\n  if(S.empty()) goto ok;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1 && CNT[ix[A[i]]+1]) {\n      CNT[ix[A[i]]+1]-=1;\n      CNT[ix[A[i]]]+=1;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> pos(m);\n        REP(i, Q) {\n            used.insert(a[i]);\n            pos[a[i]] = i;\n        }\n        vector<P> temp;\n        REP(i, m) if (used.count(i) > 0) temp.pb({-pos[i], i});\n        sort( ALL(temp) );\n        vector<ll> res;\n        REP(i, temp.size()) {\n            res.pb(temp[i].second);\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    cout << seq << endl;\n    cout << cnt << endl;\n    cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      for(i=0;i<k;i++) if(c[i]==0) f=false;\n    }\n  }else{\n    \n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  vi CNT(S.size()+1); CNT.back() = n;\n  if(S.empty()) goto ok;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      int j = ix[A[i]]+1;\n      while(!CNT[j]) j -= 1;\n      CNT[j]-=1; CNT[ix[A[i]]]+=1;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n#include<map>\n\n#define rep(i,n,m) for(int i=n;i<(int)(m);i++)\n\nusing namespace std;\n\nint main() {\n\n\tcout<<\"Yes\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  for (map<int,vector<int> >::iterator iter = am.begin(); iter != am.end(); iter++){\n    if (iter->first != 1){\n      minw = min(minw, (int)iter->second.size());\n    }\n  }\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    //cerr << \"temp:\" << temp << endl;\n    //cerr << \"check1\" << ',' << amc.size() << endl;\n    for (int i = (int)amc[temp].size()-1; (i >= (int)amc[temp].size()-1-N) && (i >= 0); i--){\n      //cerr << \"check2\" << ',' << amc.size() << endl;\n      used[amc[temp][i]] = 1;\n    }\n    for (int i = 0; (i < minw) && (amc[temp].size() > 0); i++){\n      //cerr << \"check3\" << ',' << amc.size() << endl;\n      amc[temp].pop_back();\n    }\n    if (amc[temp].size() == 0){\n      //cerr << amc.size() << endl;\n      //cerr << \"check4\" << ',' << amc.size() << endl;\n      amc.erase(temp);\n      //cerr << amc.size() << endl;\n    }\n    for (map<int,vector<int> >::iterator iter = amc.begin(); iter != amc.end(); iter++){\n      //cerr << iter->first << endl;\n    }\n    if (tempindex == 0){\n      break;\n    }\n    while(used[tempindex] == 1){\n      //cerr << \"check5\" << endl;\n      if (tempindex == 0){\n        break;\n      }\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == (i+1)){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    unordered_map<int, int> X;\n    vector<int> order;\n    vector<int> num;\n    stack<int> S;\n    int a, b, c;\n    for (int q = 0;q < Q;q++) {\n    \tcin >> a;\n    \tS.push(a);\n    }\n    while (S.size() > 0) {\n    \ta = S.top();\n    \tS.pop();\n    \tif (X.find(a) == X.end()) {\n    \t\tb = X.size();\n    \t\tX[a] = b;\n    \t}\n    \tb = X[a];\n    \tif (b >= order.size()) order.push_back(a);\n    \tif (b >= num.size()) num.push_back(0);\n    \tif (b == 0 && num[0] < M) num[0]++;\n    \telse {\n    \t\tif (num[b - 1] > num[b]) num[b]++;\n    \t}\n    }\n    if (order[order.size() - 1] == 1) {\n    \tN--;\n    \tnum.pop_back();\n    }\n    if (N == 0) {\n    \tcout << \"YES\" << endl;\n    \treturn 0;\n    }\n    if (num.size() == N && num[N - 1] == M) {\n    \tcout << \"YES\" << endl;\n    \treturn 0;\n    }\n    bool ok = 1;\n    for (int i = 0;i < order.size();i++) {\n    \tif (order[i] != i + 1) ok = 0;\n    }\n    if (ok == 1) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    int mx=0;\n    vi f(q);\n    for(int i=0;i<q;i++){\n        inmax(mx,b[i]);\n        if(mx==b[i]+1)\n            mx--;\n        if(mx==1){\n            f[i]=1;\n        }\n    }\n    if(mx==1){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long target[200000];\nlong long filled[200000];\nlong long go[200000];\nint done[200000];\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m, query;\n\tcin >> n >> m >> query;\n\tvector<long long> inputs;\n\tREP(i, query) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\t//first we need to simulate it!\n\tint now_itr = 0;\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tif (done[inputs[i]] == 0) {\n\t\t\ttarget[inputs[i]] = now_itr;\n\t\t\tfilled[now_itr] = inputs[i];\n\t\t\tdone[inputs[i]] = 1;\n\t\t\tnow_itr++;\n\t\t}\n\t}\n\tnow_itr--;\n\twhile (now_itr > 0) {\n\t\tif (filled[now_itr - 1] > filled[now_itr]) break;\n\t\tnow_itr--;\n\t}\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tint hoge = target[inputs[i]];\n\t\tif (hoge >= now_itr) continue;\n\t\tif (go[hoge] == n) continue;\n\t\tint ok = 0;\n\t\tif (hoge == 0) {\n\t\t\tok = 1;\n\t\t}\n\t\telse if (go[hoge] == 0 || go[hoge] + 1 <= go[hoge - 1]) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tgo[hoge]++;\n\t\t\tif (hoge != 0 && go[hoge] > go[hoge - 1]) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < now_itr; ++i) {\n\t\tif (go[i] < n) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\n#include <stdlib.h>\n#include <functional>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <queue>\n#include <map>\nusing namespace std;\nint main(){\n\tint n,m,q;\n\tcin>>n>>m>>q;\n\tint a[q+1];\n\tfor(int i=1;i<=q;i++){\n\t\tcin>>a[i];\n\t}\n\tint flg=0;\n\tfor(int i=q;i>=1;i--){\n\t\tint ct=0;\n\t\tfor(int j=1;j<=q;j++){\n\t\t\tif(a[j]==i){\n\t\t\t\ta[j]=0;\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t\tif(ct%n!=0){\n\t\t\tfor(int j=1;j<=(ct%n);j++){\n\t\t\t\tint h=i-1;\n\t\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\t\tif(h>0){\n\t\t\t\t\t\tif(h==a[k]){\n\t\t\t\t\t\t\ta[k]=0;\n\t\t\t\t\t\t\th=h-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h>0){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flg==1){\n\t\tcout<<\"No\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"Yes\"<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tArray a(q);\n\tREP(i, q)cin >> a[i], a[i]--;\n\n\treverse(all(a));\n\tArray cnt(m, 0);\n\tArray pre(m, -1);\n\tll last = -1;\n\n\tREP(i, q) {\n\t\tif (cnt[a[i]] == 0) {\n\t\t\tpre[a[i]] = last;\n\t\t\tlast = a[i];\n\t\t}\n\t\telse {\n\t\t\tif (pre[a[i]] != -1 && cnt[pre[a[i]]] <= cnt[a[i]]) {\n\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t}\n\t\tcnt[a[i]]++;\n\t}\n\tArray used(m, 0);\n\tArray p;\n\twhile (last != -1)p.push_back(last), used[last]=1,last = pre[last];\n\treverse(all(p));\n\tREP(i, m)if (used[i] == 0)p.push_back(i);\n\tREP(i, m) {\n\t\tif (cnt[p[i]] != n) {\n\t\t\trep(j, i + 1, m) {\n\t\t\t\tif (p[j] < p[j - 1]) {\n\t\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = n;\n\tforn(i, n) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 2e6 + 5;\nint was[N];\n//int last[N];\nint inv[N];\nint a[N];\nint got[N];\nvoid Exit(string s) {\n  cout<<s<<endl;\n  exit(0);\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m, q;\n  cin>>n>>m>>q;\n  RE (i, q) {\n    cin>>a[i];\n   // occ[a[i]].PB(i);\n  }\n  \n  VI ord{0};\n  \n  \n  FORD (i, q, 1) {\n    if (was[a[i]]) { continue; }\n    ord.PB(a[i]);\n    was[a[i]] = 1;\n  }\n  RE (i, m) {\n    if (!was[i]) {\n      ord.PB(i);\n    }\n  }\n  RE (i, m) {\n    inv[ord[i]] = i;\n  }\n  got[0] = n;\n  FORD (i, q, 1) {\n    if (got[ord[inv[a[i]] - 1]] > got[a[i]]) {\n      got[a[i]]++;\n    }\n  }\n  bool lacked = false;\n  RE (i, m) {\n    if (lacked) {\n      if (ord[i] < ord[i - 1]) {\n        Exit(\"No\");\n      }\n    }\n    if (got[ord[i]] < n) {\n      lacked = true;\n    }\n  }\n  Exit(\"Yes\");\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2016/09/24 20:56:18 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nusing namespace std;\n\nconst int maxn=100010;\n\nint seat[maxn],a[maxn],sum[maxn],num[maxn];\nbool finish[maxn];\n\nint main()\n{\n\tint n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for (int j=1;j<=q;++j)\n    {\n        scanf(\"%d\",&a[j]);\n    }\n    bool flag=1;\n    int last=0;\n    for (int j=q;j>0;--j)\n    {\n        if (a[j]>last)\n        {\n            if (a[j]==last+1) ++last;\n            else\n            {\n                flag=0;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    int cnt=0;\n    for (int j=n;j>0;--j)\n    {\n        int tis=a[j];\n        if (seat[tis]==0)\n        {\n            ++cnt;\n            seat[tis]=cnt;\n            sum[cnt]=1;\n            num[cnt]=tis;\n        }\n        else\n        {\n            if (finish[tis]) continue;\n            int st=seat[tis];\n            ++sum[st];\n            if (sum[st]==n)\n            {\n                finish[tis]=1;\n                continue;\n            }\n            if (st>1&&sum[st]>sum[st-1])\n            {\n                flag=1;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    int nx=1;\n    while (nx<=m&&finish[nx]) ++nx;\n    for (int j=1;j<=cnt;++j)\n    {\n        if (sum[j]<n)\n        {\n            if (num[j]!=nx)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                ++nx;\n                while (nx<=m&&finish[nx]) ++nx;\n            }\n        }\n    }\n    if (flag) printf(\"No\\n\");\n    else printf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,ap[500010],f[500010],m,a[500010],used,A[500010],B[500010],AS,BS;\nbool rem(){\n\tint t=0;\n\tFOR(i,1,m) if (!u[i]){\n\t\tif (ap[i]<t) return 0;\n\t\tt=ap[i];\n\t}\n/*\tAS=BS=0;\n\tFOR(i,1,q) if (!u[a[i]] && i==v[a[i]][0]) A[++AS]=a[i];\n\tFOR(i,1,m) if (!u[i]) B[++BS]=i;\n\tFOR(i,1,AS) if (A[i]!=B[i]) return 0;\n*/\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,m) ap[i]=q+1;\n\tFOR(i,1,q){\n\t\tv[a[i]].pb(i);\n\t\tif (ap[a[i]]==q+1) ap[a[i]]=i;\n\t}\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tif (rem()) return puts(\"Yes\"),0;\n\t\tu[a[now]]=1;\n\t\tint t=0;\n\t\tFOR(i,1,n){\n\t\t\twhile (t<SZ(v[a[now]]) && v[a[now]][t]<=f[i]) ++t;\n\t\t\tif (t>=SZ(v[a[now]])){\n\t\t\t\tint tt=1;\n\t\t\t\treturn puts(\"No\"),0;\n\t\t\t}\n\t\t\tf[i]=v[a[now]][t];\n\t\t\t++t;\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable : 4996)\nint N, M, Q, a[100009], c[100009], p[100009], inv[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < M; i++) inv[i] = -1;\n\tint cur = 0;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (inv[a[i]] == -1) {\n\t\t\tinv[a[i]] = cur;\n\t\t\tc[cur] = 1;\n\t\t\tp[cur++] = a[i];\n\t\t}\n\t\telse {\n\t\t\tif (c[inv[a[i]]] < (inv[a[i]] == 0 ? N : c[inv[a[i]] - 1])) {\n\t\t\t\tc[inv[a[i]]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (inv[i] == -1) p[cur++] = i;\n\t}\n\tbool ret = true;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (i >= 1 && c[i - 1] != N && p[i - 1] > p[i]) {\n\t\t\tret = false;\n\t\t}\n\t}\n\tprintf(ret ? \"Yes\\n\" : \"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nbool solve(int n, int m, std::vector<int> a) {\n  std::vector<int> order(m + 1, -1), seq;\n  std::vector<int> len(n, 0), cnt(m + 1, 0);\n  int idx = 0;\n  for (auto &v: a) {\n    if (order[v] == -1) order[v] = ++idx, seq.push_back(v);\n    if (cnt[v] == n) continue;\n    if (len[cnt[v]] == order[v] - 1) ++len[cnt[v]], ++cnt[v];\n  }\n  int mx = len.back();\n  cnt.assign(m + 1, 0);\n  for (int i = 0; i < mx; ++i) cnt[seq[i]]++;\n  std::vector<int> u;\n  for (int i = 1; i <= m; ++i) if (cnt[i] == 0) {\n    u.push_back(i);\n  }\n  for (int i = mx; i < idx; ++i) {\n    if (u[i - mx] != seq[i]) return false;\n  }\n  return true;\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  std::vector<int> a(q);\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  std::reverse(a.begin(), a.end());\n  if (solve(n, m, a)) puts(\"Yes\");\n  else puts(\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\nint n, m, q;\nint a[100000];\n\nint cnt[100001];\nint pos[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<int> ord;\n\tcin >> n >> m >> q;\n\trep(i, q) cin >> a[i], a[i]--;\n\tset<int> s;\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tif (s.count(a[i]))continue;\n\t\tord.push_back(a[i]);\n\t\ts.insert(a[i]);\n\t}\n\trep(i, m) {\n\t\tif (s.count(i) == 0)ord.push_back(i);\n\t}\n\tint mi = 0;\n\tcnt[0] = n;\n\treverse(all(ord));\n\trep(i, m)pos[ord[i]] = i;\n\tbool f = true;\n\tfor (int i = 0; i < ord.front()+1;i++) {\n\t\tif (ord[i] != ord.front() - i)f = false;\n\t}\n\tif (f) {\n\t\tcnt[0] = 0;\n\t\tcnt[mi = ord.front() + 1] = n;\n\t}\n\n\trep(i, m) {\n\t\tif (ord[i] != m - 1 - i)break;\n\t\tord[i] = 0;\n\t\tord[i + 1] = n;\n\t\tmi = i + 1;\n\t}\n\n\trep(i, q) {\n\t\tint p = pos[a[i]];\n\t\tif (cnt[p] > 0) {\n\t\t\tcnt[p]--;\n\t\t\tcnt[p + 1]++;\n\t\t\tif (mi == p && cnt[p] == 0)mi++;\n\t\t}\n\t\telse {\n\t\t\tif (p > 0 && cnt[p - 1] == a[i]) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt[mi]--;\n\t\t\t\tcnt[mi = 0]++;\n\t\t\t\tif (ord[0] == a[i]) {\n\t\t\t\t\tcnt[mi++]--;\n\t\t\t\t\tcnt[mi]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (cnt[m] == n ? \"Yes\" : \"No\") << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  { S.pb(n+n); int j = S.size()-1;\n    while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n    S.resize(j);\n  }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  int hi = S.size();\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FOR(i, q) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) if(!E[A[i]]) { E[A[i]] = 1; S.pb(A[i]); }\n  bool remEnd=endV<=S.size(); int endV = S.back();\n  if(endV <= S.size()) FOR(i, endV+1) if(S[S.size()-1-i] != endV-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  if(S.empty()) goto ok;\n  assert(false);\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define li long long\n#define itn int\n\nusing namespace std;\n\ninline int nxt(){\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nvoid panic() {\n\tputs(\"No\");\n\texit(0);\n}\n\n#define next lksjflkgkjsfg\n#define prev jkhljsgf\n\nint main(){\n\n\tint n = nxt(), m = nxt();\n\tvector<vector<int>> indices(m);\n\tint q = nxt();\n\tvector<int> a(q);\n\tfor (itn i = 0; i < q; i++) {\n\t\tint x = nxt() - 1;\n\t\ta[i] = x;\n\t\tindices[x].push_back(i);\n\t}\n\tvector<int> lst(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tlst[i] = -i - 1;\n\t}\n\n\tfor (itn i = 0; i < m; i++) {\n\t\tif (!indices[i].empty()) {\n\t\t\tlst[i] = indices[i].back();\n\t\t}\n\t}\n\tvector<itn> next(m, -1), prev(m, -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i < m - 1) {\n\t\t\tnext[i] = i + 1;\n\t\t}\n\t\tprev[i] = i - 1;\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tif (lst[i] < lst[i + 1]) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvector<char> used(m);\n\tint index = q - 1;\n\tvector<int> bound(n, q);\n\twhile (index >= 0 && cnt) {\n\n\t\tint c = a[index];\n\t\tused[c] = 1;\n\t\tint nx = next[c];\n\t\tint pr = prev[c];\n\t\tif (nx > -1) {\n\t\t\tif (lst[c] < lst[nx]) {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tprev[nx] = pr;\n\t\t}\n\t\tif (pr > -1) {\n\t\t\tif (lst[pr] < lst[c]) {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tnext[pr] = nx;\n\t\t}\n\t\tif (nx > -1 && pr > -1) {\n\t\t\tif (lst[pr] < lst[nx]) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tint i = n - 1;\n\t\tfor (int j = (int)indices[c].size() - 1; j >= 0; j--) {\n\t\t\tif (i == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (indices[c][j] < bound[i]) {\n\t\t\t\tbound[i--] = indices[c][j];\n\t\t\t}\n\t\t}\n\t\tif (i >= 0) {\n\t\t\tpanic();\n\t\t}\n\n\t\twhile (index >= 0 && used[a[index]]) {\n\t\t\tindex--;\n\t\t}\n\t}\n\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    drep(i,v.size()){\n        if(i == v.size() - 1 && v[i].first == 1)continue;\n        if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  for (int i = 0; i < m; ++i) {\n    se.insert(i);\n  }\n  bool used = false;\n  for (auto e : a) {\n    if (not se.count(e)) {\n      continue;\n    }\n    if (used) {\n      if (e != *begin(se)) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    } else if (c[e] < n) {\n      if (e != *begin(se)) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n      used = true;\n    }\n    se.erase(e);\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n,m,q;\nvi a;\n\nint main(){\n\tcin>>m>>n>>q;\n\ta=vi(q);\n\tfor(int i=0;i<q;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\treverse(a.begin(),a.end());\n\tvi b(n,-1),c(n+1),b_(n);\n\tint id=0,M=0,B=1;\n\tc[0]=m;\n\tfor(int i=0;i<q;i++) if(b[a[i]]==-1){\n\t\tb[a[i]]=id;\n\t\tb_[id++]=a[i];\n\t}\n\tfor(int i=0;i<n;i++) if(b[i]==-1){\n\t\tb[i]=id;\n\t\tb_[id++]=i;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint I=b[a[i]];\n\t\tif(M<I) B=0;\n\t\tif(c[I]){\n\t\t\tc[I]--;\n\t\t\tc[I+1]++;\n\t\t\tM=max(M,I+1);\n\t\t}\n\t}\n\tint s=c[n]+c[n-1];\n\tfor(int i=n-2;i>=0&&b_[i]<b_[i+1];i--) s+=c[i];\n\tcout<<(s==m&&B?\"Yes\":\"No\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0]+1,n){\n\t\tif(v[i]<v[i+1]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tint hi=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\thi=max(hi,pos[a[i]]+1);\n\t\t\t//while(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(hi<pos[a[i]]){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t\t/*else if(num[pos[a[i]]+1]>0){\n\t\t\tnum[pos[a[i]]+1]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t}\n\t\telse if(num[n]>0){\n\t\t\tnum[n]+=0;\n\t\t}\n\t\telse{\n\t\t\tif(lo<pos[a[i]]){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\t//num[lo]--;num[pos[a[i]]+1]++;lo=1;\n\t\t}\n\t\t//rep(j,n+1) cout<<num[j]<<' ';cout<<endl;\n\t\t*/\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n\nint n, m, q, A[1111111], bound[1111111], vis[1111111];\nvector<int> vec[1111111];\nint main() {\n\tcin >> m >> n >> q;\n\tFor(i,1,q) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tvec[A[i]].push_back(i);\n\t}\n\tFor(i,1,m) bound[i] = n + 1;\n\tint id = 1;\n\tCor(i,q,1) {\n\t\tif (vis[A[i]]) continue ;\n\t\tvis[A[i]] = true;\n\t\tif (id == A[i]) {\n\t\t\twhile (vis[id]) ++id;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (vec[A[i]].size() < m) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tFor(j,1,m) {\n\t\t\tif (bound[j] < vec[A[i]][vec[A[i]].size() - j]) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbound[j] = vec[A[i]][vec[A[i]].size() - j];\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ProblemE.cpp\n\n#include <iostream>\n\nstatic std::istream & ip = std::cin;\nstatic std::ostream & op = std::cout;\n\n#if OJ_MYPC\n#include <ojio.h>\n#endif\n\n#ifndef OPENOJIO\n#define OPENOJIO\n#endif\n\n#if 1 || DEFINE\n/***************************************************************/\ntypedef unsigned long long u64;\ntypedef long long s64;\n\ntypedef unsigned uint;\n\n#define ABS(x) ((x) > 0 ? (x) : -(x))\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\n#define MIN3(x, y, z) MIN(x, MIN(y, z))\n#define MAX3(x, y, z) MAX(x, MAX(y, z))\n\n#define FillZero(arr) memset(arr, 0, sizeof(arr));\n\n/***************************************************************/\n#endif //1 || DEFINE\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <iomanip>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\n//001\n//op << setfill('0') << setw(3) << setiosflags(ios::right) << 1;\n\n//op << fixed << setprecision(20);\n\nusing namespace std;\n\n//ProblemE.cpp\n\n#define MAXN 100010\n#define MAXM 100010\n#define MAXQ 100010\n\nint main(int argc, char* argv[])\n{\n\tOPENOJIO;\n\n\tint n, m, q;\n\tstatic int a[MAXQ];\n\n\tip >> n >> m >> q;\n\tfor (int i = 1; i <= q; ++i) ip >> a[i];\n\n\tstatic bool used[MAXM];\n\tfor (int i = 1; i <= m; ++i) used[i] = false;\n\n\tint last[MAXM];\n\tint ilast = 1;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tif (used[a[i]])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = a[i];\n\t\tused[a[i]] = true;\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (used[i])\n\t\t\tcontinue;\n\n\t\tlast[ilast++] = i;\n\t}\n\n\tint mii[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tmii[last[i]] = i;\n\n\tstatic int cl[MAXM];\n\tfor (int i = 1; i <= m; ++i)\n\t\tcl[i] = 0;\n\tcl[0] = n;\n\n\tfor (int i = q; i >= 1; --i) {\n\t\tint index = mii[a[i]];\n\n\t\tif (cl[index - 1] > 0) {\n\t\t\t--cl[index - 1];\n\t\t\t++cl[index];\n\t\t}\n\t}\n\n\tbool rst = true;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (cl[i] == 0) continue;\n\t\tfor (int j = i + 1; j < m; ++j) {\n\t\t\tif (last[j] > last[j + 1]) {\n\t\t\t\trst = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tbool rst = cl[m] == n;\n\top << (rst ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n/***************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nconst int N = 100500;\nint wait[N];\n\nint P[N];\nint Q[N];\nint A[N];\n\nbool was[N];\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &A[i]);\n        --A[i];\n    }\n    int pt = 0;\n    for (int i = q - 1; i >= 0; i--) {\n        if (!was[A[i]])\n            was[A[i]] = true, P[pt] = A[i], Q[A[i]] = pt, pt++;\n    }\n    set<int> unused;\n    for (int i = 0; i <= m; i++)\n        unused.insert(i);\n    for (int i = 0; i < pt; i++)\n        unused.erase(P[i]);\n    while (pt > 0 && P[pt - 1] < *unused.begin()) {\n        --pt;\n        unused.insert(P[pt]);\n    }\n\n    wait[0] = n;\n    for (int i = q - 1; i >= 0; i--) {\n        int a = A[i];\n        assert(was[a]);\n        if (Q[a] >= pt)\n            continue;\n        if (wait[Q[a]])\n            wait[Q[a]]--, wait[Q[a] + 1]++;\n    }\n    if (wait[pt] != n) {\n        puts(\"No\");\n    } else {\n        puts(\"Yes\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] != n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tif (now == -1) return 1;\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tif(cur == m+1){\n\t\t\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"No\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n  int N, M;\n  scanf(\"%d%d\", &N, &M);\n  int Q;\n  scanf(\"%d\", &Q);\n  map<int,vector<int> > am;\n  vector<int> av;\n  for (int i = 0; i < Q; i++){\n    int temp;\n    scanf(\"%d\", &temp);\n    av.push_back(temp);\n    if (am.find(temp) == am.end()){\n      am[temp] = vector<int>();\n    }\n    am[temp].push_back(i);\n  }  \n  map<int,vector<int> > amc(am);\n  int temp = av[av.size()-1];\n  int tempindex = av.size()-1;\n  vector<int> used(Q, 0);\n  int minw = N;\n  vector<int> result;\n  int counter = 1;\n  while(amc.size() > 0){\n    if ((temp != 1) || (temp != counter)){\n      minw = min(minw, (int)amc[temp].size()); \n    }\n    for (int i = 0; i < amc[temp].size(); i++){\n      used[amc[temp][i]] = 1;\n    }\n    amc.erase(temp);\n    while(used[tempindex] == 1){\n      tempindex--;\n    }\n    result.push_back(temp);    \n    temp = av[tempindex];\n    counter++;\n  }\n  if (minw == N){\n    cout << \"Yes\" << endl;\n  }else{\n    for (int i = 0; i < result.size(); i++){\n      if (result[i] == (i+1)){\n        continue;\n      }else{\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\nconst int max0=100010;\nint n,m,a,i;\n\tint countx[max0],data[max0],ans[max0],top;\n\tint dic[max0];\n\tbool had[max0],wrong;\nint main()\n{\n\n\tscanf(\"%d%d%d\",&n,&m,&a);\n\tfor(i=0;i<a;i++)\n\t\tscanf(\"%d\",&data[i]);\n\tfor(i=a-1;i>=0;i--)\n\t\tif(had[data[i]]==0){\n                had[data[i]]=1,ans[top++]=data[i];\n\t\t}\n    for(i=1;i<=m;i++)\n        if(had[i]==0){\n                had[i]=1,ans[top++]=i;\n\t\t}\n    //printf(\"!%d %d %d\\n\",top,ans[1],p1);\n\twhile(top>1&&ans[top-1]>ans[top-2])top--;\n\tif(ans[top-1]==1)top--;\n    //printf(\"!%d\\n\",top);\n\tfor(i=top-1;i>=1;i--)dic[ans[i]]=ans[i-1];\n\tfor(i=a-1;i>=0;i--){\n\t\tcountx[data[i]]++;\n\t\tif(dic[data[i]]!=0)\n\t\t\tif(countx[data[i]]>countx[dic[data[i]]])\n\t\t\t\tcountx[data[i]]=countx[dic[data[i]]];\n\t}\n\tif(top!=0&&countx[ans[top-1]]<n)printf(\"No\\n\");\n\telse \tprintf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m);\n  vector<int> pos(m);\n  vector<int> freq(m + 1);\n  \n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i] !=0){\n        first = -1;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n  for(int i = first; i < known; i++){\n    if(all[i - first] != a[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tint N,M,Q,a;\n\tvector<int> num;\n\tint ans;\n\n\tcin >> N >> M >> Q;\n\t\n\tfor (int i=0; i < M; i++) {\n\t\tnum.push_back(0);\n\t}\n\n\tfor (int i=0; i < Q; i++) {\n\t\tcin >> a;\n\t\tnum[a - 1]++;\n\t}\n\tnum.erase(num.begin());\n\tans = num[0] % M;\n\tfor (int i = 0; i < N-1; i++) {\n\t\tif (ans != num[i] % M) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Yes\" << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int N, M, Q; scanf(\"%d%d%d\", &N, &M, &Q);\n  static pair<int,int> queries[100000];\n  for(int i = 0; i < Q; ++i) {\n    scanf(\"%d\", &queries[i].first); --queries[i].first;\n    queries[i].second = i;\n  }\n  sort(queries, queries+Q);\n  // printf(\"queries = \");\n  // for(int i = 0; i < Q; ++i) {\n  //   printf(\"(%d, %d), \", queries[i].first, queries[i].second);\n  // }\n  // printf(\"\\n\");\n  static int qidx[100001];\n  {\n    int i = 0;\n    for(int j = 0; j <= M; ++j) {\n      while(i < Q && queries[i].first < j) ++i;\n      qidx[j] = i;\n    }\n  }\n  // printf(\"qidx = \");\n  // for(int i = 0; i <= M; ++i) {\n  //   printf(\"%d, \", qidx[i]);\n  // }\n  // printf(\"\\n\");\n  static int lru_seq[100000];\n  for(int i = 0; i < M; ++i) {\n    lru_seq[i] = i;\n  }\n  sort(lru_seq, lru_seq+M, [&](int x, int y) -> bool {\n      int xx = (qidx[x] == qidx[x+1]) ? ~x : queries[qidx[x+1]-1].second;\n      int yy = (qidx[y] == qidx[y+1]) ? ~y : queries[qidx[y+1]-1].second;\n      return xx < yy;\n  });\n  // printf(\"lru_seq = \");\n  // for(int i = 0; i < M; ++i) {\n  //   printf(\"%d, \", lru_seq[i]);\n  // }\n  // printf(\"\\n\");\n  int max_ign = 1;\n  while(max_ign < M && lru_seq[max_ign] <= lru_seq[max_ign-1]) ++max_ign;\n  // printf(\"max_ign = %d\\n\", max_ign);\n  static int max_times[100000];\n  fill(max_times, max_times+N, Q);\n  for(int i = M-1; i >= max_ign; --i) {\n    int j = qidx[lru_seq[i]+1]-1;\n    int min_j = qidx[lru_seq[i]];\n    for(int k = 0; k < N; ++k) {\n      while(j >= min_j && queries[j].second > max_times[k]) --j;\n      if(j < min_j) {\n        printf(\"No\\n\");\n        return 0;\n      }\n      max_times[k] = queries[j].second;\n      // printf(\"i=%d: max_times[%d] = %d\\n\", i, k, max_times[k]);\n      --j;\n    }\n  }\n  printf(\"Yes\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vi a(q);\n  rep (i, q) {\n    cin >> a[i];\n    a[i]--;\n  }\n  //DEBUG_VEC(a);\n  \n  vi used(q, -1);\n  int used_cnt = 0;\n  vector<bool> used_x(m);\n  vi pre_idx(n, inf);\n  int idx = q - 1;\n  while (true) {\n    int pre = -1;\n    rrep (i, q) {\n      if (used_x[a[i]]) continue;\n      if (a[i] == pre + 1) {\n        pre = a[i];\n      }\n      else if (a[i] <= pre) continue;\n      else {\n        pre = inf;\n        break;\n      }\n    }\n    if (pre != inf) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(pre);\n    //DEBUG(idx);\n    while (idx >= 0) {\n      if (used_x[a[idx]]) idx--;\n      else break;\n    }\n    if (idx == -1) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n    //DEBUG(idx);\n\n    used_x[a[idx]] = true;\n    pre_idx[0] = idx;\n    int j = 1;\n    for (int i = idx - 1; i >= 0; i--) {\n      if (a[i] == a[idx] and i < pre_idx[j]) {\n        pre_idx[j] = i;\n        j++;\n      }\n      if (j == n) break;\n    }\n    if (j < n) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n \ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n \nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n \n\tconst FuncType func_m;\n \n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n \n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n \ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n \n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n \ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n \ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n \n\tval_p_m = new T[1 << rank_m];\n\tstd::fill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n \n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n \n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n \ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n \n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n \ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n \ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n \n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n \nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n \ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n \n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n \n//#include \"Union_Find.h\"\n \nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n \nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n \n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n \n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 200200;\nint a[maxn];\nbool used[maxn];\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"e.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m, q;\n    cin >> n >> m >> q;\n    forn (i, q) {\n        cin >> a[i];\n        --a[i];\n    }\n    vector<int> p;\n    for (int i = q - 1; i >= 0; --i) {\n        if (used[a[i]])\n            continue;\n        int val = a[i];\n        used[val] = true;\n        p.push_back(val);\n    }\n    forn (i, m)\n        if (!used[i])\n            p.push_back(i);\n    assert(sz(p) == m);\n    int pr = 0;\n    //forn (i, m)\n        //cerr << p[i] << ' ';\n    //cerr << '\\n';\n    forn (i, m - 1)\n        if (p[i] > p[i + 1])\n            pr = i + 1;\n    vector<int> rp(m);\n    forn (i, m)\n        rp[p[i]] = i;\n    multiset<int> S;\n    forn (i, n)\n        S.insert(0);\n    for (int i = q - 1; i >= 0; --i) {\n        int x = rp[a[i]];\n        auto it = S.lower_bound(x);\n        int to = *it + 1;\n        S.erase(it);\n        S.insert(to);\n    }\n    if (*S.begin() < pr)\n        cout << \"No\\n\";\n    else\n        cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nbool check(const vec<ll> &qv) {\n    ll cur = 1;\n    for (ll e : qv) {\n        if (e <= cur) continue;\n        if (cur + 1 < e) return false;\n        cur++;\n    }\n    return true;\n}\n\nbool solve() {\n    ll n, m, q;\n    std::cin >> n >> m >> q;\n    vec<ll> cnts(n);\n    vec<ll> aim;\n    std::map<ll, std::set<ll>> nxts;\n    vec<ll> qv(q);\n    for (ll &e : qv) std::cin >> e;\n    std::reverse(ALL(qv));\n    if (qv[0] == 1 && check(qv)) return true;\n    vec<bool> cut(m + 1);\n    aim.push_back(qv[0]);\n    cnts[0]++;\n    cut[qv[0]] = true;\n    for (ll i = 1; i < n; i++) nxts[qv[0]].insert(i);\n    for (ll i = 1; i < q; i++) {\n        ll e = qv[i];\n        auto &st = nxts[e];\n        if (st.empty()) {\n            if (cut[e]) continue;\n            aim.push_back(e);\n            cut[e] = true;\n            cnts[0]++;\n        } else {\n            ll idx = *st.begin();\n            cnts[idx]++;\n            st.erase(idx);\n            if (cnts[idx] < cnts[0]) nxts[aim[cnts[idx]]].insert(idx);\n        }\n    }\n\n    bool ok = true;\n    for (ll i = 0; i < aim.size(); i++) if (i + 1 != aim[i]) ok = false;\n    if (ok) return true;\n    ll minv = *std::min_element(ALL(cnts));\n    ll diff = cnts[0] - minv;\n    if (diff == 0) return true;\n    ok = true;\n    for (ll i = minv; i < aim.size(); i++) if (aim[i] != 1) ok = false;\n    return ok;\n}\n\nint main() {\n    std::cout << (solve() ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#define range(i,a,b) for(int i = (a); i <= (b); i++)\n#define rep(i,b) for(int i = 1; i <= (b); i++)\n#define rrep(i,b) for(int i = (b); i >= 1; i--)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+11,INF=~0u>>2;\nbool vis[N],flag=1;\nint n,m,q,a[N],b[N],id[N],cnt[N],len;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();m=read();q=read();\n\trep(i,q) a[i]=read();\n\trrep(i,q) if(!vis[a[i]]) b[++len]=a[i],vis[a[i]]=1;\n\trep(i,m) if(!vis[a[i]]) b[++len]=i;\n\trep(i,m) id[b[i]]=i;\n\tcnt[0]=n;\n\trep(i,m) vis[i]=0;\n\trrep(i,q){\n\t\tint t=id[a[i]];\n\t\tif(cnt[t-1]>0) cnt[t-1]--,cnt[t]++,vis[t]=1;\n\t\telse if(!vis[t]){\n\t\t\tflag=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen=0;\n\twhile(cnt[len]==0) len++;\n\trange(i,len+1,m-1) flag&=b[i]<b[i+1];\n\tputs(flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*N M\nQ\na1 a2 … aQ*/\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>   \nusing namespace std;\n\nint main() {\n\tint N,M,Q;\n\tcin >> N >> M;\n\tcin >> Q;\n\tint a[M];\n\tint sum =0;\n\tfor(int i=0;i<M;i++) {\n\t\tcin >> a[i];\n\t\tsum+=a[i];\n\t}\n\tstring s;\n\tcin >> s;\n\tcin >> K;\n\n\n\tif(sum%2==0) {\n\t\tcout << \"YES\" << endl;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n\telse {\n\t\tcout << \"NO\" << endl;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n \n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\n \n// head\n\nll n, m;\nll q;\n\nll a[100010];\nll t;\n\nvl v, x;\n\nset<ll> ss[100010];\n\nbool used[100010];\n\nint no(){\n  puts( \"No\" );\n  return 0;\n}\n\nint main(){\n\n  scanf( \"%lld %lld\" , &n , &m );\n  scanf( \"%lld\" , &q );\n  REP( i , q ) scanf( \"%lld\" , &a[i] );\n  \n  for( ll i = m; i >= 1; i-- ) v.pb( i );\n  REP( i , q ) v.pb( a[i] );\n\n  REP( i , q ) ss[ a[i] ].insert( i );\n\n  for( ll i = SZ(v)-1; i >= 0; i-- ){\n    if( !used[v[i]] ){\n      used[ v[i] ] = true;\n      x.pb( v[i] );\n      if( i >= m ) ss[ v[i] ].erase( ss[ v[i] ].find( i-m ) );\n    }\n  }\n  \n  for( ll i = SZ(x)-2; i >= 0; i-- ){\n    if( x[i] > x[i+1] ){\n      t = i+1;\n      break;\n    }\n  }\n  \n  if( t * n > q ) return no();\n\n  REP( i , n-1 ){\n    ll cur = q;\n    REP( j , t ){\n      auto ite = ss[ x[j] ].lower_bound( cur );\n      if( ite == ss[ x[j] ].begin() ) return no();\n      ite--;\n      ss[ x[j] ].erase( ite );\n    }\n  }\n\n  puts( \"Yes\" );\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool allappeared[100050];\nint a[100050];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    allappeared[0] = true;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared[a[i] - 1]) allappeared[a[i]] = true;\n    }\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    /*\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        cerr << val[i] << endl;\n    }\n    */\n    num[0] = 1e9;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], N);\n        chmin(num[nowindex], num[nowindex-1]);\n        /*\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        */\n    }\n    for(int i = 1; i <= index; i++) {\n        if(num[i] != N) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main() {\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv;\n\n// import dcomp.scanner;\n// import dcomp.container.deque;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m, q;\n    int[] a;\n    sc.read(n, m, q, a);\n\n    bool solve() {\n        int[] co, idx = new int[m]; idx[] = -1;\n\n        int l = 0;\n        foreach_reverse (d; a) {\n            d--;\n            int u = idx[d];\n            if (u == -1) {\n                u = idx[d] = co.length.to!int;\n                co ~= 0;\n            }\n            if (u && co[u-1] == co[u]) {\n                return false;\n            }\n            co[u]++;\n            if (co[u] == n) {\n                l++;\n                idx[d] = -1;\n            }\n        }\n        foreach (i; 0..m) {\n            if (idx[i] == -1) continue;\n            if (idx[i]-l != i) return false;\n        }\n        return true;\n    }\n\n    if (solve()) {\n        writeln(\"Yes\");\n    } else {\n        writeln(\"No\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(4L, 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const { assert(p, \"this deque is not init\"); }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint v[100010], ap[100010], nr[100010], a[100010];\n\nint main ()\n{\n   // freopen (\"file.in\", \"r\", stdin);\n\n    int n, m, q;\n    scanf (\"%d %d %d\", &n, &m, &q);\n\n    nr[0] = n;\n    for (int i = 1; i <= q; ++i)\n        scanf (\"%d\", &v[q - i + 1]);\n\n    int k = 0;\n    for (int i = 1; i <= q; ++i)\n        if (!ap[v[i]]) ap[a[++k] = v[i]] = k;\n\n    for (int i = 1; i <= m; ++i)\n        if (!ap[i]) ap[a[++k] = i] = k;\n\n    for (int i = 1; i <= q; ++i)\n    {\n        int fr = ap[v[i]];\n        if (nr[fr - 1] > 0) --nr[fr - 1], ++nr[fr];\n    }\n\n    for (int i = 0; i < m; ++i)\n        if (nr[i] > 0)\n        {\n            for (++++i; i <= m; ++i)\n                if (a[i] < a[i - 1])\n                {\n                    printf (\"No\\n\");\n                    return 0;\n                }\n\n            break;\n        }\n\n    printf (\"Yes\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ELRU {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m, q; cin >> n >> m >> q;\n      vector<int> a(q);\n      rep(i, q) {\n        cin >> a[i];\n      }\n      reverse(all(a));\n      // value, pos\n      map<int, int> used;\n      vector<int> cnt;\n      vector<int> rev;\n      rep(i, q) {\n        if (used.find(a[i]) == used.end()) {\n          used[a[i]] = cnt.size();\n          cnt.push_back(1);\n          rev.push_back(a[i]);\n        } else {\n          int pos = used[a[i]];\n          if (pos == 0 || cnt[pos-1] > cnt[pos]) {\n            cnt[pos]++;\n          }\n        }\n      }\n\n      bool flag = true;\n      bool foundone = false;\n      set<int> st;\n      for(int i=1; i<=m; i++) {\n        st.insert(i);\n      }\n      for(int i=0; i<cnt.size(); i++) {\n        if (rev[i] == 1) foundone = true;\n        if (!foundone) {\n          if (cnt[i] < n) {\n            flag = false;\n            break;\n          }\n          st.erase(rev[i]);\n        } else {\n          if (rev[i] == *st.begin()) {\n            st.erase(st.begin());\n            continue;\n          }\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        cout << \"Yes\" << endl;\n        return;\n      }\n\n      flag = true;\n      for(int i=0; i<cnt.size(); i++) {\n        if (cnt[i] >= n) continue;\n        flag = false;\n        break;\n      }\n      cout << (flag ? \"Yes\" : \"No\") << endl;\n    }\n};\n\nsigned main() {\n  ELRU solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n    assert(seq.size() == m);\n    { set<ll> s; REP(i, m) s.insert(seq[i]); assert(s.size() == m); }\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n    }\n    // cout << seq << endl;\n    // cout << cnt << endl;\n    // cout << def << endl;\n    bool ans = true;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  int q;\n  scanf(\"%d\",&q);\n  vi a(q);\n  rep(i,q) {\n    scanf(\"%d\",&a[i]);\n    --a[i];\n  }\n  reverse(rng(a));\n  vvi p(m);\n  rep(i,q) {\n    p[a[i]].pb(i);\n  }\n  vi used(m);\n  vi r(n);\n  int fr = 0;\n  bool ok = true; \n  rep(i,q) {\n    if (used[a[i]]) continue;\n    int k = 0;\n    rep(j,sz(p[a[i]])) {\n      assert(j >= i);\n      if (r[k] > p[a[i]][j]) continue;\n      r[k] = p[a[i]][j]; ++k;\n      if (k >= n) break;\n    }\n    if (ok && k == n) {\n    } else {\n      if (fr == a[i]) {\n        ok = false;\n      } else {\n        puts(\"No\");\n        return 0;\n      }\n    }\n    used[a[i]] = 1;\n    while (fr < m && used[fr]) ++fr;\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nmap <int, vector <int> > mp;\n\nint a[100010];\nint ans[100010];\nint pptr[100010];\nbool u[100010];\nint ptr[1000010];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i < n; ++i) {\n        mp[0].push_back(i);\n    }\n    int q;\n    cin >> q;\n    for (int i = q; i >= 1; --i) {\n        cin >> a[i];\n    }\n    int cnt = 1;\n    for (int i = 1; i <= q; ++i) {\n        if (!u[a[i]]) {\n            ans[cnt] = a[i];\n            pptr[a[i]] = cnt;\n            ++cnt;\n            u[a[i]] = 1;\n        } else {\n            if (mp.find(pptr[a[i]] - 1) == mp.end() || mp[pptr[a[i]] - 1].empty()) {\n                continue;\n            } else {\n                mp[pptr[a[i]]].push_back(mp[pptr[a[i]] - 1].back());\n                mp[pptr[a[i]] - 1].pop_back();\n                if (mp[pptr[a[i]] - 1].empty()) {\n                    mp.erase(pptr[a[i]] - 1);\n                }\n            }\n        }\n    }\n    vector <int> help;\n    int mn = mp.begin()->first;\n    for (int i = 1; i <= mn; ++i) {\n        help.push_back(ans[i]);\n    }\n    sort(help.begin(), help.end());\n    int qqwe = 0;\n    int qsr = 1;\n    ++mn;\n    for (; mn < cnt; ++mn) {\n        while (qqwe < help.size() && qsr == help[qqwe]) {\n            ++qsr;\n            ++qqwe;\n        }\n        if (ans[mn] != qsr) {\n            cout << \"No\\n\";\n            return 0;\n        }\n        ++qsr;\n    }\n    cout << \"Yes\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, Q, w[101000], pv[101000], CC, ord[101000], R[101000];\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=m;i>=2;i--){\n        if(P[i].num < P[i-1].num)break;\n    }\n    pp = i;\n    R[0] = n;\n    for(i=Q;i>=1;i--){\n        int t = ord[w[i]];\n        if(R[t] < R[t-1])R[t]++;\n    }\n    for(i=1;i<pp;i++){\n        if(R[i] < n){\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  for (int i = 0; i < m; ++i) {\n    se.insert(i);\n  }\n  for (auto e : a) {\n    if (se.empty() or e != *begin(se)) {\n      if (c[e] < n) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    }\n    se.erase(e);\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing FuncType = std::function<T(const T&, const T&)>;\n\nprivate:\n\tT* val_p_m;\n\tconst T init_val_m;\n\tconst int size_m;\n\tconst int rank_m;\n\n\tconst FuncType func_m;\n\n\tT Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right);\n\tbool Is_valid_index(int index);\npublic:\n\tSegmentTree(int size, const T& init_val, const FuncType& func);\n\n\tvoid Update(int pos, const T& val);\n\tT Query(int range_left, int range_right);\n};\n\ntemplate<typename T>\nT SegmentTree<T>::Query_rec(int range_left, int range_right, int node_index, int node_range_left, int node_range_right) {\n\tif (node_range_right <= range_left || range_right <= node_range_left) return init_val_m;\n\tif (range_left <= node_range_left && node_range_right <= range_right) return val_p_m[node_index];\n\n\tint node_range_mid = (node_range_left + node_range_right) / 2;\n\tconst T val_left = Query_rec(range_left, range_right, node_index * 2, node_range_left, node_range_mid);\n\tconst T val_right = Query_rec(range_left, range_right, node_index * 2 + 1, node_range_mid, node_range_right);\n\treturn func_m(val_left, val_right);\n}\n\ntemplate<typename T>\ninline bool SegmentTree<T>::Is_valid_index(int index) {\n\treturn index >= 0 && index < size_m;\n}\n\ntemplate<typename T>\nSegmentTree<T>::SegmentTree(int size, const T& init_val, const FuncType& func)\n\t: init_val_m(init_val), size_m(size), rank_m((int)std::log2(size) + 1), func_m(func) {\n\n\tval_p_m = new T[1 << rank_m];\n\tfill(val_p_m + (1 << (rank_m - 1)), val_p_m + (1 << rank_m), init_val_m);\n\n\tfor (int i = (1 << (rank_m - 1)) - 1; i >= 1; --i) {\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n\ntemplate<typename T>\nvoid SegmentTree<T>::Update(int pos, const T& val) {\n\tassert(Is_valid_index(pos));\n\n\tint i = pos + (1 << (rank_m - 1));\n\tval_p_m[i] = val;\n\twhile (i > 1) {\n\t\ti /= 2;\n\t\tval_p_m[i] = func_m(val_p_m[i * 2], val_p_m[i * 2 + 1]);\n\t}\n}\n\ntemplate<typename T>\nT SegmentTree<T>::Query(int range_left, int range_right) {\n\tassert(Is_valid_index(range_left));\n\tassert(Is_valid_index(range_right - 1));\n\n\treturn Query_rec(range_left, range_right, 1, 0, 1 << (rank_m - 1));\n}\n\ntemplate<typename T>\nclass Max {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::max<T>(a, b);\n\t}\n};\n\ntemplate<typename T>\nclass Min {\npublic:\n\tconst T& operator()(const T& a, const T& b) const {\n\t\treturn std::min<T>(a, b);\n\t}\n};\n\n//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n// all_of\n\n#if 1\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\n//#include \"Union_Find.h\"\n\nint N, M, Q;\nint A[100000];\nvector<PP> seq;\nint idxs[100000];\nset<int> Set;\n\nint main() {\n\tcin >> N >> M >> Q;\n\tREP(i, 0, Q) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tFill(idxs, -1);\n\n\tSegmentTree<int> S(M, INF, Min<int>());\n\tREPM(i, Q, 0) {\n\t\tint idx = idxs[A[i]];\n\t\tif (idx == -1) {\n\t\t\tseq.push_back(PP(A[i], 1));\n\t\t\tidxs[A[i]] = seq.size() - 1;\n\t\t\tS.Update(idxs[A[i]], 1);\n\t\t} else {\n\t\t\tint mn = idx == 0 ? INF : S.Query(0, idx);\n\t\t\tif (seq[idx].second != mn && seq[idx].second != N) {\n\t\t\t\t++seq[idx].second;\n\t\t\t\tS.Update(idx, seq[idx].second);\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 0, M) {\n\t\tSet.insert(i);\n\t}\n\tbool ok = true;\n\tfor (PP p : seq) {\n\t\tif (p.second == N) {\n\t\t\tSet.erase(p.first);\n\t\t} else {\n\t\t\tif (*Set.begin() != p.first) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet.erase(p.first);\n\t\t}\n\t}\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n#include <vector>\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass D {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        int n, m, q;\n        in >> n >> m >> q;\n        vector<int> v(q);\n        for (int i: range(q)) {\n            in >> v[i];\n            --v[i];\n        }\n\n        vector<vector<int>> changesTimes(m);\n\n        for (int i: range(q)) {\n            changesTimes[v[i]].push_back(i);\n        }\n\n        vector<vector<int>> intr;\n\n\n        vector<int> used(m + 1);\n        int minUnused = 0;\n        for (int j: downrange(q)) {\n            if (used[v[j]]) {\n                continue;\n            }\n            int i = v[j];\n            if (i == minUnused) {\n                used[i] = true;\n                while (used[minUnused])\n                    ++minUnused;\n                continue;\n            }\n            used[i] = true;\n            while (used[minUnused])\n                ++minUnused;\n\n            if (changesTimes[i].size() < n) {\n                out << \"No\\n\";\n                return;\n            }\n            intr.emplace_back(changesTimes[i].end() - n, changesTimes[i].end());\n        }\n\n        if (intr.size() > 1) {\n            sort(intr);\n            for (int i: range(n)) {\n                for (int j: range(1, (int) intr.size())) {\n                    if (intr[j][i] < intr[j - 1][i]) {\n                        out << \"No\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n\n        out << \"Yes\\n\";\n    }\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nvoid mainmain(){\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvint as(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tscanf(\"%d\", &as[i]);\n\t\t--as[i];\n\t}\n\n\tvint vis(m);\n\tvector<int> seq;\n\tfor(int i = q; i--; ){\n\t\tif(!vis[as[i]]){\n\t\t\tvis[as[i]] = 1;\n\t\t\tseq.push_back(as[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){ seq.push_back(i); }\n\t}\n\tvint rtbl(m);\n\tfor(int i = 0; i < m; ++i){\n\t\trtbl[seq[i]] = i;\n\t}\n\n\tvint cnt(m + 1);\n\tcnt[0] = n;\n\tfor(int i = q; i--; ){\n\t\tint x = rtbl[as[i]];\n\t\tif(cnt[x] > 0){\n\t\t\t--cnt[x];\n\t\t\t++cnt[x + 1];\n\t\t}\n\t}\n\n\tint minidx;\n\tfor(minidx = 0; !cnt[minidx]; ++minidx);\n\tvis.assign(m, 0);\n\tvint seq2;\n\tfor(int i = 0; i < minidx; ++i){\n\t\tseq2.push_back(seq[i]);\n\t\tvis[seq[i]] = 1;\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){\n\t\t\tseq2.push_back(i);\n\t\t}\n\t}\n\n\tputs(seq == seq2 ? \"Yes\" : \"No\");\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =1002;\nconst int MOD =1000000007;\n\n  \n  \nsigned main(){\nint n,m,q;\ncin>>n>>m>>q;\nint a[q];\nfor(int i=0;i<q;i++)cin>>a[i];\nint x[m],y[m]={};\nfill(x,x+m,MOD);\nfor(int i=0;i<q;i++){\n  if(x[a[q-1-i]-1]==MOD)x[a[q-1-i]-1]=i;\n  y[a[q-1-i]-1]++;\n}\npair<int,int>p[m];\nfor(int i=0;i<m;i++)p[i]={x[i],i};\nsort(p,p+m);\nint k=0;\nwhile(k<m&&y[p[k].second]>=n)k++;\nfor(int i=k;i<m-1;i++)if(p[i].second>=p[i+1].second){\n  cout<<\"No\"<<endl;\n  return 0;\n}\ncout<<\"Yes\"<<endl;\nreturn 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int ind[M];\n  for(i=0;i<M;++i){ind[i] = -1;}\n  int laststock = 0;\n  int lastcount[M];\n  int before[M];\n  int bef = -1;\n  for(i=Q-1; i>=0; --i){\n    if(ind[a[i]-1] == -1){\n      ind[a[i]-1] = laststock;\n      laststock++;\n      lastcount[laststock] = 1;\n    }else{\n      if(ind[a[i]-1] == 0 || lastcount[ind[a[i]-1]] < lastcount[ind[a[i]-1]]){\n        lastcount[ind[a[i]-1]]++;\n      }\n    }\n  }\n  int maxind = -1;\n  int maxcover = N;\n  for(i=0; i<M; ++i){\n    if(ind[i] < 0){break;}\n    bool f1 = false;\n    bool f2 = false;\n    if(ind[i] > maxind){\n      maxind = ind[i];\n      f1 = true;\n    }\n    if(lastcount[ind[i]] <= maxcover){\n      maxcover = lastcount[ind[i]];\n      f2 = true;\n    }\n    if(f1 && f2){\n      lastcount[ind[i]] = N;\n    }\n  }\n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5;\nint a[N],st[N],pos[N],cnt[N],vis[N];\nint n,m,q,top,p;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfp(i,1,q)scanf(\"%d\",&a[i]);\n\tfd(i,q,1)if(!vis[a[i]])st[++top]=a[i],vis[a[i]]=1;\n\tfp(i,1,m)if(!vis[i])st[++top]=i;\n\tfp(i,1,top)pos[a[i]]=i;\n\tp=top;\n\twhile(p>1&&st[p-1]<st[p])--p;\n\tif(p==1)return puts(\"Yes\"),0;\n\tcnt[0]=233333;\n\tfd(i,q,1)if(cnt[pos[a[i]]-1])--cnt[pos[a[i]]-1],++cnt[pos[a[i]]];\n\tR int res=0;\n\tfp(i,p-1,m)res+=cnt[i];\n\tputs(res>=n?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m, -1);\n  vector<int> pos(m, -1);\n  vector<int> freq(m + 1,0);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] = -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i]  > 0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != b[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = n;\n\tforn(i, n) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && firstFail > pos[last]) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nset<int> st[100000];\nbool used[100000];\nint idx[100000];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    int a[100000];\n    for(int i = 0; i < Q; i++){\n        cin >> a[i];\n        a[i]--;\n        st[a[i]].insert(i);\n    }\n    vector<int> ans;\n    for(int i = Q-1; i >= 0; i--){\n        if(!used[a[i]]){\n            ans.push_back(a[i]);\n            used[a[i]] = true;\n        }\n    }\n    for(int i = 0; i < N; i++) idx[i] = Q;\n    for(int i = 0; i < M; i++){\n        if(!used[i]) ans.push_back(i);\n    }\n    //for(int i = 0; i < M; i++) cout << ans[i] << ' ';\n    int last = -1;\n    for(int i = 1; i < M; i++){\n        if(ans[i] < ans[i-1]) last = i-1;\n    }\n    // cout << last << endl;\n    for(int i = 0; i <= last; i++){\n        //cout << i << endl;\n        for(int j = 0; j < N; j++){\n            //cout << j << endl;\n            auto ptr = st[ans[i]].lower_bound(idx[j]);\n            if(ptr == st[ans[i]].begin()){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            ptr--;\n            int m = *ptr;\n            idx[j] = m;\n            st[ans[i]].erase(m);\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, Q;\nint A[101010];\nint cnt[101010];\nset<int> poss[101010];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\t--A[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\t++cnt[A[i]];\n\t\tposs[A[i]].insert(i);\n\t}\n\tset<int> rem;\n\tfor (int i = 0; i < M; ++i) rem.insert(i);\n\tvector<int> req;\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tif (rem.count(A[i]) == 0) continue;\n\t\tif (rem.size() > 0 && *(rem.begin()) == A[i]) {\n\t\t\t// you can ignore it\n\t\t} else {\n\t\t\treq.push_back(A[i]);\n\t\t}\n\t\trem.erase(A[i]);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lp = M;\n\t\tfor (int j : req) {\n\t\t\tint nxtp = -1;\n\t\t\tauto pt = poss[j].upper_bound(lp);\n\t\t\tif (pt == poss[j].begin()) {\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnxtp = *(--pt);\n\t\t\tposs[j].erase(nxtp);\n\t\t}\n\t}\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, deque<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N, M, Q;\ndeque<int> a;\n\nbool solve() {\n    vector<int> b(M);\n    for (int i = 0; i < M; ++i) b[i] = i;\n    map<int,int> id;\n    int iter = 0;\n    for (int i = 0; i < a.size(); ++i) {\n        if (id.count(a[i])) continue;\n        id[a[i]] = iter++;\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (id.count(b[i])) continue;\n        id[b[i]] = iter++;\n    }\n    for (int i = 0; i < a.size(); ++i) a[i] = id[a[i]];\n    for (int i = 0; i < b.size(); ++i) b[i] = id[b[i]];\n\n    vector<int> con(id.size(), 0);\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i] == 0) con[a[i]]++;\n        else if (con[a[i]] + 1 <= con[a[i]-1]) con[a[i]]++;\n    }\n    for (int i = 0; i < b.size(); ++i) {\n        if (b[i] == 0) chmax(con[b[i]], N);\n        else chmax(con[b[i]], con[b[i]-1]);\n    }\n    bool ok = true;\n    for (int i = 0; i < con.size(); ++i) {\n        if (con[i] < N) ok = false;\n    }\n\n    //COUT(a); COUT(id); COUT(a); COUT(con);\n    \n    return ok;\n}\n\nint main() {\n    while (cin >> N >> M >> Q) {\n        a.resize(Q);\n        for (int i = 0; i < Q; ++i) cin >> a[i], --a[i];\n        reverse(a.begin(), a.end());\n        if (a.empty() || solve()) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n \nconst int INF=1000000009;\n \nbool dcs(int m,int q){\n \n\tif(m==1) return 1;\n \n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(d[m]==0) return 1;\n \telse{\n \t\tif(g[m]) return 1;\n\t\telse{\n\t  \tif(f[m]) return 1;\n\t\t}\n \t}\n \n\treturn 0;\n \n}\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n \n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n \n\tsort(b,b+Q); M=b[Q-1];\n \n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n \n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n \n\tfor(int i=0; i<100005; i++) e[i]=INF;\n \n\tif(d[1]) e[1]=d[1];\n \n\tfor(int i=2; i<=M; i++){\n \n\t\tif(d[i]==0||e[i-1]==INF) e[i]=INF;\n\t\telse if(d[i]<e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=d[i];\n\t\t}else if(d[i]>=e[i-1]&&e[i-1]!=INF){\n\t\t\te[i]=e[i-1];\n\t\t}\n \n\t}\n \n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n \n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n \n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      for(i=0;i<k;i++) if(c[i]==0) f=false;\n    }\n  }else if(n==q){\n    j=0;\n    for(i=q-1;i>=0;i--) if(a[i]=j+1) j++;\n    if(j!=k&&c[k]!=q) f=false;\n  }else{\n\n  }\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n    }\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint ans[200000];\nint now[200000];\nint aaa[200000];\nint main()\n{\n\tint num,len,query;\n\tscanf(\"%d%d%d\",&num,&len,&query);\n\tvector<int>v;\n\tfor(int i=0;i<query;i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\",&z);\n\t\tz--;\n\t\tv.push_back(z);\n\t}\n\treverse(v.begin(),v.end());\n\tset<int>se;\n\tvector<int>dd;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(se.find(v[i])==se.end())\n\t\t{\n\t\t\tans[v[i]]=se.size()+1;\n\t\t\tse.insert(v[i]);\n\t\t\tdd.push_back(v[i]);\n\t\t}\n\t\tint x=ans[v[i]];\n\t\tint beg=0,end=num;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(beg==end)break;\n\t\t\tint med=(beg+end)/2;\n\t\t\tif(now[med]<x)end=med;\n\t\t\telse beg=med+1;\n\t\t}\n\t\t//printf(\"  %d %d  %d\\n\",beg,v[i]+1,x);\n\t\tif(beg!=num&&now[beg]==x-1)\n\t\t{\n\t\t\tnow[beg]++;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++)if(ans[v[i]]==0)dd.push_back(i);\n\tvector<int>z;\n\tfor(int i=0;i<now[num-1];i++)\n\t{\n\t\tz.push_back(dd[i]);\n\t\taaa[dd[i]]=1;\n\t}\n\tfor(int i=0;i<len;i++)if(aaa[i]==0)z.push_back(i);\n\tfor(int i=0;i<len;i++)printf(\"%d %d\\n\",dd[i]+1,z[i]+1);\n\tif(dd==z)printf(\"Yes\\n\");\n\t//else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n    cout << \"No\" << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> A(Q);\n    for(int i=0; i<Q; i++){\n        cin >> A[i];\n        A[i]--;\n    }\n    reverse(A.begin(), A.end());\n    vector<int> order, rev(M, -1);\n    for(int a : A) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n    int b = order.back(), sz = order.size();\n    if(sz > b){\n        bool ok = true;\n        for(int i=0; i<=b; i++) if(order[i-b+sz-1] != i) ok = false;\n        if(ok) sz -= b+1;\n    }\n    for(int a=0; a<M; a++) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    vector<int> num(M+1);\n    bitset<100001> visited;\n    visited[0] = 1;\n    num[0] = N;\n    for(int a : A){\n        if(num[rev[a]]){\n            num[rev[a]]--;\n            num[rev[a]+1]++;\n            visited[rev[a]+1] = 1;\n        }else if(!visited[rev[a]]){\n            fail();\n        }\n    }\n    for(int i=0; i<sz; i++) if(num[i]) fail();\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define char ll\n//#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n#ifdef HK_CUP\n    freopen(\"finput.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n#ifndef HK_CUP\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n#endif\n    return 0;\n}\n\nconst int N = 1e5 + 10;\nint cnt[N];\nint ord[N];\nint timer = 0;\n\nvoid smain() {\n    fill(ord, ord + N, -1);\n\n    int n, m;\n    cin >> n >> m;\n    int q;\n    cin >> q;\n    vi a(q);\n    fori (i, q) {\n        cin >> a[i];\n        a[i]--;\n    }\n    reverse(ALL(a));\n    vi p;\n    for (auto x : a) {\n        if (ord[x] == -1) {\n            ord[x] = timer++;\n            p.push_back(x);\n        }\n        int l = -1, r = N - 1;\n        while (r - l > 1) {\n            int m = r + l >> 1;\n            if (cnt[m] > ord[x]) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        ++l;\n        if (l < n && cnt[l] == ord[x]) {\n            cnt[l]++;\n        }\n    }\n    set<int> not_in;\n    fori (i, m) {\n        not_in.insert(i);\n    }\n    for (auto x : p) {\n        not_in.erase(x);\n    }\n    for (auto x : not_in) {\n        p.push_back(x);\n    }\n    while (p.size() > 1 && p.back() > p[SZ(p) - 2]) {\n        p.pop_back();\n    }\n    p.pop_back();\n//    watch(p);\n    fori (i, n) {\n//        cerr << \"cnt[\" << i << \"] = \" << cnt[i] << endl;\n        if (cnt[i] < p.size()) {\n            cout << \"No\\n\";\n            return;\n        }\n    }\n    cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>(), Q = read<int>();\n    auto A = readVec<int>(Q);\n    for (auto& a : A) { a--; }\n    std::vector<std::vector<int>> L(M);\n    for (int i = 0; i < M; i++) { L[i].push_back(M - i - 1); }\n    for (int i = 0; i < Q; i++) { L[A[i]].push_back(i + M); }\n    std::vector<int> op;\n    std::vector<bool> used(M, false);\n    for (int i = Q - 1; i >= 0; i--) {\n        if (used[A[i]]) { continue; }\n        op.push_back(A[i]), used[A[i]] = true;\n    }\n    std::vector<int> pos(N, N + M);\n    for (const auto& o : op) {\n        if (pos[0] < L[o].back()) { return std::cout << \"No\" << std::endl, 0; }\n        for (int i = 0; i < N; i++) {\n            while (pos[i] < L[o].back()) {\n                if (L[o].size() == 1) { return std::cout << \"No\" << std::endl, 0; }\n                L[o].pop_back();\n            }\n            pos[i] = L[o].back();\n            if (L[o].size() > 1) { L[o].pop_back(); }\n        }\n    }\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tArray a(q);\n\tREP(i, q)cin >> a[i], a[i]--;\n\n\treverse(all(a));\n\tArray cnt(m, 0);\n\tArray pre(m, -1);\n\tll last = -1;\n\n\tArray used(m, 0);\n\tArray p;\n\n\tREP(i, q) {\n\t\tif (cnt[a[i]] == 0) {\n\t\t\tp.push_back(a[i]);\n\t\t\tused[a[i]] = 1;\n\t\t\tcnt[a[i]]++;\n\t\t\tpre[a[i]] = last;\n\t\t\tlast = a[i];\n\t\t}\n\t\telse if (pre[a[i]] == -1 || cnt[pre[a[i]]] > cnt[a[i]])cnt[a[i]]++;\n\t}\n\tREP(i, m)if (used[i] == 0)p.push_back(i);\n\tREP(i, m) {\n\t\tif (cnt[p[i]] != n) {\n\t\t\trep(j, i + 1, m) {\n\t\t\t\tif (p[j] < p[j - 1]) {\n\t\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nvoid mainmain(){\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tvint as(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tscanf(\"%d\", &as[i]);\n\t\t--as[i];\n\t}\n\n\tvint vis(m);\n\tvector<int> seq;\n\tfor(int i = q; i--; ){\n\t\tif(!vis[as[i]]){\n\t\t\tvis[as[i]] = 1;\n\t\t\tseq.push_back(as[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){ seq.push_back(i); }\n\t}\n\tvint rtbl(m);\n\tfor(int i = 0; i < m; ++i){\n\t\trtbl[seq[i]] = i;\n\t}\n\n\tvint nxt(n);\n\tfor(int i = q; i--; ){\n\t\tint x = rtbl[as[i]];\n\t\tint k = lower_bound(ALL(nxt), x, greater<int>()) - nxt.begin();\n\t\tif(k < n && nxt[k] == x){\n\t\t\t++nxt[k];\n\t\t}\n\t}\n\n\tint minimum = *min_element(ALL(nxt));\n\tvis.assign(m, 0);\n\tvint seq2;\n\tfor(int i = 0; i < minimum; ++i){\n\t\tseq2.push_back(seq[i]);\n\t\tvis[seq[i]] = 1;\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(!vis[i]){\n\t\t\tseq2.push_back(i);\n\t\t}\n\t}\n\n\tputs(seq == seq2 ? \"Yes\" : \"No\");\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) if(!E[A[i]]) { E[A[i]] = 1; S.pb(A[i]); }\n  int endV = S.back();\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV+1) if(S[S.size()-1-i] != endV-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n  if(S.empty()) goto ok;\n  assert(false);\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint ans[200000];\nint now[200000];\nint aaa[200000];\nint main()\n{\n\tint num,len,query;\n\tscanf(\"%d%d%d\",&num,&len,&query);\n\tvector<int>v;\n\tfor(int i=0;i<query;i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\",&z);\n\t\tz--;\n\t\tv.push_back(z);\n\t}\n\treverse(v.begin(),v.end());\n\tset<int>se;\n\tvector<int>dd;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(se.find(v[i])==se.end())\n\t\t{\n\t\t\tans[v[i]]=se.size()+1;\n\t\t\tse.insert(v[i]);\n\t\t\tdd.push_back(v[i]);\n\t\t}\n\t\tint x=ans[v[i]];\n\t\tint beg=0,end=num;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(beg==end)break;\n\t\t\tint med=(beg+end)/2;\n\t\t\tif(now[med]<x)end=med;\n\t\t\telse beg=med+1;\n\t\t}\n\t\t//printf(\"  %d %d  %d\\n\",beg,v[i]+1,x);\n\t\tif(beg!=num&&now[beg]==x-1)\n\t\t{\n\t\t\tnow[beg]++;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++)if(ans[i]==0)dd.push_back(i);\n\tvector<int>z;\n\tfor(int i=0;i<now[num-1];i++)\n\t{\n\t\tz.push_back(dd[i]);\n\t\taaa[dd[i]]=1;\n\t}\n\tfor(int i=0;i<len;i++)if(aaa[i]==0)z.push_back(i);\n\t//for(int i=0;i<len;i++)printf(\"%d %d\\n\",dd[i]+1,z[i]+1);\n\tif(dd==z)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint m;\nint q;\n\nint a[MAX];\n\nset<int> s;\ndeque<int> v;\nbool can[MAX];\n\nmultiset<int> mp;\nint id[MAX];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\treverse(a, a + q);\n\tfor (int i = 0; i < q; i++){\n\t\tif (s.count(a[i])==0){\n\t\t\tv.push_back(a[i]);\n\t\t\ts.insert(a[i]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tif (s.count(i) == 0){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tint maxx = INT_MAX;\n\tcan[v.size()] = true;\n\tfor (int i = v.size() - 1; i >= 0; i--){\n\t\tif (maxx > v[i]){\n\t\t\tmaxx = v[i];\n\t\t\tcan[i] = true;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\ts.clear();\n\tfor (int i = 0; i < v.size(); i++){\n\t\tid[v[i]] = i;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmp.insert(0);\n\t}\n\tint L = -1;\n\tfor (int i = 0; i < q; i++){\n\t\tint ID = id[a[i]];\n\t\tif (mp.count(ID)){\n\t\t\tauto k = mp.find(ID);\n\t\t\tmp.erase(k);\n\t\t\tmp.insert(ID + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ID <= L){\n\t\t\tcontinue;\n\t\t}\n\t\tL = max(L, ID);\n\t}\n\tfor (auto it = mp.begin(); it != mp.end(); it++){\n\t\tif (can[(*it)] == false){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n        //cout<<f[i]<<\" \";\n    }\n    //cout<<\"\\n\";\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)||(s==SZ(kek)-1&&kek.back()==1)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=m;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long target[200000];\nlong long filled[200000];\nlong long go[200000];\nint done[200000];\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m, query;\n\tcin >> n >> m >> query;\n\tvector<long long> inputs;\n\tREP(i, query) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\t//first we need to simulate it!\n\tint now_itr = 0;\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tif (done[inputs[i]] == 0) {\n\t\t\ttarget[inputs[i]] = now_itr;\n\t\t\tfilled[now_itr] = inputs[i];\n\t\t\tdone[inputs[i]] = 1;\n\t\t\tnow_itr++;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (done[i] == 0) {\n\t\t\ttarget[i] = now_itr;\n\t\t\tfilled[now_itr] = i;\n\t\t\tdone[i] = 1;\n\t\t\tnow_itr++;\n\t\t}\n\t}\n\tnow_itr--;\n\twhile (now_itr > 0) {\n\t\tif (filled[now_itr - 1] > filled[now_itr]) break;\n\t\tnow_itr--;\n\t}\n\tfor (int i = inputs.size() - 1; i >= 0; --i) {\n\t\tint hoge = target[inputs[i]];\n\t\tif (hoge >= now_itr) continue;\n\t\tif (go[hoge] == n) continue;\n\t\tint ok = 0;\n\t\tif (hoge == 0) {\n\t\t\tok = 1;\n\t\t}\n\t\telse if (go[hoge] == 0 || go[hoge] + 1 <= go[hoge - 1]) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tgo[hoge]++;\n\t\t\tif (hoge != 0 && go[hoge] > go[hoge - 1]) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < now_itr; ++i) {\n\t\tif (go[i] < n) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,q,i,j,k=0;cin>>n>>m>>q;\n  int a[q],c[m+1];\n  memset(c,0,sizeof(c));\n  for(i=0;i<q;i++) cin>>a[i],c[a[i]]++,k=max(k,a[i]);\n  bool f=true;\n  if(n>q){\n    if(a[q-1]!=1) f=false;\n    else{\n      for(i=0;i<k;i++) if(c[i]==0) f=false;\n    }\n  }else{\n    \n  }\n  cout << \"Yes\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tit_bound = prev(it_bound);\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\torder.emplace_back(i);\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < order.size() - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    int f=[&](){\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    if(id==(*s.begin())&&i>0){\n                        que.pop();\n                        return 1;\n                    }\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n        \n    }\n    return 1;\n    }();\n    if(f==0)return 0;\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\n\nvoid out(vi v) {\n  for (auto x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nint main() {\n  int n, m, q;\n  cin >> n >> m >> q;\n  vi a(q);\n  for (int i = 0; i < q; ++i) {\n    cin >> a[i];\n    --a[i];\n  }\n  vi was(m), ord;\n  for (int i = a.size() - 1; i >= 0; --i) {\n    if (!was[a[i]]) ord.push_back(a[i]);\n    ++was[a[i]];\n  }\n  for (int i = 0; i < m; ++i) {\n    if (!was[i]) ord.push_back(i);\n    ++was[i];\n  }\n//  out(ord);\n  bool ok = ord.size() == m;\n  for (int i = 0; i < ord.size(); ++i) if (ord[i] != i) ok = 0;\n  if (ok) {\n    printf(\"Yes\\n\");\n    return 0;\n  }\n  vi c(ord.size()), pos(m);\n  for (int i = 0; i < ord.size(); ++i) pos[ord[i]] = i;\n  for (int i = a.size() - 1; i >= 0; --i) {\n    int x = pos[a[i]];\n    if (x == 0) {\n      ++c[0];\n    } else {\n      c[x] = min(c[x] + 1, c[x-1]);\n    }\n  }\n//  out(c);\n  for (int i = 0; i < m; ++i) {\n    int x = pos[i];\n    if (x == 0) {\n      c[0] = n;\n    } else {\n      c[x] = max(c[x], c[x-1]);\n    }\n  }\n//  out(c);\n  for (int i = 0; i < c.size(); ++i) if (c[i] < n) {\n    printf(\"No\\n\");\n    return 0;\n  }\n  printf(\"Yes\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  int hi = S.size();\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FOR(i, q) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    int Q; cin >> Q;\n    vec a(Q); readi(a);\n\n    vec order(M, -1), count(M, 0), v(0);\n    int n = 0;\n    IREP(i, Q){\n        if(order[a[i]] == -1){\n            order[a[i]] = n;\n            count[n]++;\n            n++;\n            v.push_back(a[i]);\n        }else if(order[a[i]] == 0){\n            count[0]++;\n        }else if(count[order[a[i]]] < count[order[a[i]] - 1]){\n            count[order[a[i]]]++;\n        }\n    }\n\n    vector<bool> used(M, false);\n    REP(i, M){\n        if(count[i] >= N) used[v[i]] = true;\n        else break;\n    }\n    bool f = true;\n    int mval = -1;\n    IREP(i, Q){\n        if(!used[a[i]]){\n            if(a[i] < mval && mval != -1) f = false;\n            used[a[i]] = true;\n            mval = a[i];\n        }\n    }\n    IREP(i, M) if(i < mval && !used[i]) f = false;\n    if(f) cout << \"Yes\";\n    else cout << \"No\"; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint smlst, N, M, Q, nr, b[100009], a[100009], pos[100009], need[100009];\nbool ap[100009];\n\nvoid Ans (bool x)\n{\n    if (x) printf (\"Yes\\n\");\n    else printf (\"No\\n\");\n    exit (0);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &Q);\nfor (int i=1; i<=Q; i++)\n    scanf (\"%d\", &a[i]);\nb[++nr] = a[Q --], pos[b[1]] = 1;\nneed[1] = N - 1;\nwhile (Q)\n{\n    int val = a[Q --];\n    if (pos[val] != 0)\n    {\n        int p = pos[val];\n        if (need[p]) need[p] --, need[p + 1] ++;\n        else Ans (0);\n        continue;\n    }\n    b[++nr] = val, pos[val] = nr;\n}\nsmlst = -1;\nfor (int i=1; i<=nr; i++)\n    if (need[i] > 0)\n    {\n        smlst = i - 1;\n        break;\n    }\nif (smlst == -1) Ans (1);\nfor (int i=1; i<=smlst; i++)\n    ap[b[i]] = 1;\nint j = smlst + 1;\nfor (int i=1; i<=M; i++)\n    if (ap[i] == 0)\n    {\n        if (j > nr) break;\n        if (i != b[j ++]) Ans (0);\n    }\nAns (1);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<utility>\n#include<random>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint a[1 << 17];\nbool used[1 << 17];\nvector<int> v;\nint c[1 << 17];\nint inv[1 << 17];\nint main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\trep(i, q) {\n\t\tcin >> a[i];\n\t}\n\tper(i, q) {\n\t\tif (used[a[i]])continue;\n\t\tused[a[i]] = true;\n\t\tv.push_back(a[i]);\n\t}\n\trep1(i, m) {\n\t\tif (used[i])continue;\n\t\tv.push_back(i);\n\t}\n\tint ri = 0;\n\trep(i, m - 1) {\n\t\tif (v[i] > v[i + 1]) {\n\t\t\tri = i + 1;\n\t\t}\n\t}\n\trep(i, m) {\n\t\tinv[v[i]] = i;\n\t}\n\tbool f = true;\n\tper(i, q) {\n\t\tint id = inv[a[i]];\n\t\tif (id >= ri)continue;\n\t\tif (id > 0) {\n\t\t\tif (c[id - 1] > c[id]) {\n\t\t\t\tc[id]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c[id] == n)continue;\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\telse c[id]++;\n\t}\n\trep(i, ri) {\n\t\tif (c[i] < n)f = false;\n\t}\n\tif (f)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 0; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] < n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tif (now == -1) return 1;\n\tfor(int i = now, j = 0; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 1e9+7;\nconst int MAXN = 1e5+5;\n\nint n, m, q;\nint a[MAXN], take[MAXN];\nvector<int> pl[MAXN];\n\nmap<int, int> s;\n\nint main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> a[i]; a[i]--;\n\t\tpl[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t\ts[i] = 1;\n\n\tfor (int i = 0; i < n; ++i)\n\t\ttake[i] = q;\n\tfor (int i = q-1; i >= 0; --i) {\n\t\tif (s.empty())\n\t\t\tbreak;\n\t\tif (s.count(a[i]) == 0)\n\t\t\tcontinue;\n\t\tint fir = (*s.begin()).first;\n\t\ts.erase(a[i]);\n\t\tint ct = n-1;\n\t\tif (fir == a[i]) {\n\t\t\tfor (int j = pl[a[i]].size()-1; j >= 0; --j) {\n\t\t\t\tif (ct == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pl[a[i]][j] <= take[ct]) {\n\t\t\t\t\ttake[ct] = pl[a[i]][j]; ct--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = ct; j >= 0; --j)\n\t\t\t\ttake[ct] = -1;\n\t\t} else {\n\t\t\tfor (int j = pl[a[i]].size()-1; j >= 0; --j) {\n\t\t\t\tif (ct == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pl[a[i]][j] <= take[ct]) {\n\t\t\t\t\ttake[ct] = pl[a[i]][j]; ct--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ct >= 0) {\n\t\t\t\tcout << \"No\\n\"; return 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    int lst=0,w=0;\n    for(auto u:st){\n        if(u.second>lst)\n            w++;\n        else\n            w=1;\n        lst=u.second;\n    }\n\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n    }\n\n\n    vi g[n];\n    for(int i=0;i<SZ(kek);i++){\n        for(int j=0;j<cnt[kek[i]];j++){\n            g[j].push_back(kek[i]);\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        int p=0;\n        bool fl=true;\n        for(auto u:st){\n            if(SZ(g[i])==p)\n                break;\n            if(g[i][p]!=u.second){\n                fl=false;\n                break;\n            }\n            p++;\n        }\n        if(fl==false){\n            cout<<\"No\";\n            return;\n        }\n        if(w<n-p){\n            cout<<\"No\";\n            return;\n        }\n\n    }\n\n\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint qs[maxn];\n\nint n, m, q;\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &q) < 3) {\n    return 0;\n  }\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%d\", qs + i);\n    --qs[i];\n  }\n  return 1;\n}\n\nint lev[maxn];\n\nint used[maxn];\nint a[maxn];\nint back[maxn];\n\nvoid solve() {\n  for (int i = 0; i < m; ++i) {\n    used[i] = 0;\n  }\n  int k = 0;\n  for (int iter = q - 1; iter >= 0; --iter) {\n    int x = qs[iter];\n    if (!used[x]) {\n      used[x] = 1;\n      a[k++] = x;\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    if (!used[i]) {\n      a[k++] = i;\n    }\n  }\n  int stop = m;\n  for (int last = inf; stop && a[stop] < last; --stop) {\n    last = a[stop];\n  }\n\n  for (int i = 0; i <= stop; ++i) {\n    lev[i] = 0;\n  }\n  lev[0] = n;\n\n  for (int i = 0; i < n; ++i) {\n    back[a[i]] = i;\n  }\n\n  for (int iter = q - 1; iter >= 0; --iter) {\n    int x = qs[iter];\n    int pos = back[x];\n    if (pos < stop && lev[pos]) {\n      --lev[pos];\n      ++lev[pos + 1];\n    }\n  }\n  if (lev[stop] == n) {\n    printf(\"Yes\\n\");\n  } else {\n    printf(\"No\\n\");\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\nusing namespace std;\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\n\nbool solve(int n, int m, int q, const vector<int> & a) {\n    // make the final sequence\n    vector<int> used(m);\n    vector<int> b;\n    REP_R (i, q) {\n        if (not used[a[i]]) {\n            used[a[i]] = true;\n            b.push_back(a[i]);\n        }\n    }\n    REP (i, m) {\n        if (not used[i]) {\n            b.push_back(i);\n        }\n    }\n\n    // remove the tail\n    int r = m - 1;\n    while (r - 1 >= 0 and b[r - 1] < b[r]) {\n        -- r;\n    }\n    if (r == 0) return true;\n\n    // count queries\n    vector<int> next(m, m);\n    REP (i, r) {\n        next[b[i]] = (i + 1 < r ? b[i + 1] : m);\n    }\n    vector<int> cnt(m + 1);\n    cnt[b[0]] = n;\n    REP_R (i, q) {\n        if (cnt[a[i]]) {\n            -- cnt[a[i]];\n            ++ cnt[next[a[i]]];\n        }\n    }\n    return cnt[m] == n;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    int q; cin >> q;\n    vector<int> a(q);\n    REP (i, q) {\n        cin >> a[i];\n        -- a[i];\n    }\n    cout << (solve(n, m, q, a) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint b[100005],c[100005],d[100005],e[100005],f[100005]; bool g[100005];\n\nvector<int> a,v;\n \nconst int INF=1000000009;\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta.push_back(x);\n\t\tb[i]=x;\n\t\tc[x]++;\n\t}\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tint j=1;\n\t\n\tfor(int i=Q-1; i>=0; i--){\n\t\tif(!g[a[i]]){\n\t\t\td[j]=a[i]; g[a[i]]=1; j++;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(g[i]==0){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=j; i<=M; i++){\n\t\td[i]=v[0]; v.erase(v.begin());\n\t}\n\n\tint esize=M; bool no=1;\n\n\tfor(int i=M-1; i>=1; i--){\n\t\tif(d[i]>d[i+1]){\n\t\t\tesize=i; no=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(no){\n\t\tcout<<\"Yes\"<<endl; return 0;\n\t}\n\n\tint k=1;\n\n\tfor(int i=esize; i>=1; i--){\n\t\te[k]=d[i]; k++;\n\t}\n\n\tint count=0,time=0; bool find=0;\n\n while(1){\n\n\tk=1; find=0;\n\n\tfor(int i=0; i<a.size(); i++){\n\n\t if(a[i]==e[k]) k++;\n\t \n\t if(k==esize+1){\n\t\tcount++; k=1; find=1;\n\t }\n\n\t}\n\n\tif(!find) break;\n\tif(count>=N) break;\n\n\tk=1;\n\n\tfor(int i=0; i<a.size(); i++){\n\t\tif(a[i]==e[k]){\n\t\t\ta.erase(a.begin()+i); k++;\n\t\t}\n\t\tif(k==esize+1){\n\t\t\tif(time==count) break;\n\t\t\ttime++; k=1;\n\t\t}\n\t}\n\n }\n\n\tif(count>=N) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tcout << \"Yes\" << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long llint;\ntypedef pair <int, int> pi;\n\nconst int MAXN = 100005;\n\nint n, m, q;\nint a[MAXN], bio[MAXN], cnt[MAXN], nxt[MAXN];\nvector <int> v, r;\n\nint main () {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m >> q;\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    for (int i = q-1; i >= 0; i--) {\n        if (!bio[a[i]]) v.push_back(a[i]);\n        bio[a[i]] = 1;\n    }\n    for (int i = 1; i <= m; i++) if (bio[i] == 0) v.push_back(i);\n    for (int i = 1; i < m; i++) nxt[v[i - 1]] = v[i];\n    cnt[v[0]] = n;\n    for (int i = q-1; i >= 0; i--) {\n        if (cnt[a[i]] == 0) {\n            cout << \"No\";\n            return 0;\n        }\n        cnt[a[i]]--;\n        cnt[nxt[a[i]]]++;\n    }\n    memset(bio, 0, sizeof bio);\n    for (int i = 0; i < m; i++) {\n        if (cnt[v[i]] != 0) break;\n        bio[v[i]] = 1;\n        r.push_back(v[i]);\n    }\n    for (int i = 1; i <= m; i++) if (bio[i] == 0) r.push_back(i);\n    bool ok = 1;\n    for (int i = 0; i < m; i++) ok &= v[i] == r[i];\n    if (ok) cout << \"Yes\"; else cout << \"No\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = 1001001 + i;\n    rep(i,q)f_[a[i]] = -i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    /*\n    cout << v.size() << endl;\n    rep(i,v.size())cout << v[i].first << ' ' << v[i].second << endl;\n    */\n    int flag = 1;\n\n    int mex = 1;\n    int cnt[m+1] = {};\n    rep(i,v.size()){\n        cnt[v[i].first] = v[i].second;\n    }\n    srep(i,1,m+1){\n        if(cnt[i] >= n)mex++;\n        else break;\n    }\n\n    drep(i,v.size()){\n        // if(i == v.size() - 1 && v[i].first <= mex)continue;\n        // if(v.size() == m && i == v.size() - 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int a[q];\n    rep(i,q)cin >> a[i];\n\n    // 全部1つの配列でやる\n    int f_[m+1] = {};\n    srep(i,1,m+1)f_[i] = -1001001 + i;\n    rep(i,q)f_[a[i]] = i;\n    vector<P> v_;\n    srep(i,1,m+1)v_.push_back(P(f_[i], i));\n    sort(v_.begin(), v_.end());\n    int flag_ = 1;\n    rep(i,m)if(v_[i].second != i+1)flag_ = 0;\n    if(flag_){\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n\n    // 後ろから貪欲\n    vector<P> v;\n    map<int,int> mp;\n    drep(i,q){\n        int aa = a[i];\n        if(mp.find(aa) == mp.end()){\n            v.push_back(P(aa, 1));\n            mp[aa] = v.size() - 1;\n        }else{\n            int ite = mp[aa];\n            if(ite == 0){\n                v[ite].second++;\n                if(v[ite].second > n)v[ite].second = n;\n            }else{\n                v[ite].second++;\n                if(v[ite].second > v[ite-1].second)v[ite].second = v[ite-1].second;\n            }\n        }\n    }\n\n    int flag = 1;\n\n    drep(i,v.size()){\n        if(i == v.size() - 1 && v[i].first == 1)continue;\n        if(v[i].second != n)flag = 0;\n    }\n\n    if(flag)yn;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvoid ext(vector<int> &result, int len, int m, vector<int> &v) {\n    vector<bool> used(m+1, false);\n    for (int i = 0; i < len; i++) {\n        int a = result[i];\n        assert(!used[a]);\n        v.push_back(a);\n        used[a] = true;\n    }\n    for (int i = 1; i <= m; i++) if (!used[i]) v.push_back(i);\n}\n\nint main() {\n    int n, m, q; cin >> n >> m >> q;\n    int a[q];\n    for (int i = 0; i < q; i++) cin >> a[i];\n    vector<int> cnt(m+1, 0), len(n, 0), idx(m+1), result;\n    for (int i = q-1; i >= 0; i--) {\n        if (0 < cnt[a[i]]) {\n            if (cnt[a[i]] < n && len[cnt[a[i]]] == idx[a[i]]) {\n                len[cnt[a[i]]]++;\n                cnt[a[i]]++;\n            }\n        } else {\n            cnt[a[i]]++;\n            len[0]++;\n            idx[a[i]] = result.size();\n            result.push_back(a[i]);\n        }\n        // cerr << \"result = \"; for (int x : result) cerr << x << \" \"; cerr << endl;\n        // cerr << \"length = \"; for (int x : len) cerr << x << ' '; cerr << endl;\n        // cerr << \"idx = \"; for (int x : idx) cerr << x << ' '; cerr << endl;\n        // cerr << \"cnt = \"; for (int x : cnt) cerr << x << ' '; cerr << endl;\n    }\n    vector<int> v1, v2;\n    ext(result, len[0], m, v1);\n    ext(result, len[n-1], m, v2);\n    for (int i = 0; i < n; i++) {\n        // cerr << v1[i] << \" \" << v2[i] << endl;\n        if (v1[i] != v2[i]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    }\n    cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    int mx=0;\n    vi f(q);\n    for(int i=0;i<q;i++){\n        inmax(mx,b[i]);\n        if(mx==b[i]+1)\n            mx--;\n        if(mx==1){\n            f[i]=1;\n        }\n    }\n    if(mx==1){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n                if(s==SZ(kek)){\n                    if(i==0||f[q-i]==1){\n                        cout<<\"Yes\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<random>\n#include<unordered_set>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst int big=1e9+10;\nconst long double pai=3.141592653589793238462643383279;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(b==0){return a;}return gcd(b,a%b);}//a>b\nllint lcm(llint a,llint b){return (a/gcd(max(a,b),min(a,b)))*b;}\nint main(void){\n\tint n,m,q,i,j,zyu=1,doc=7;cin>>n>>m>>q;doc=n;\n\tvector<int>ban(q);//入力 番号\n\tvector<deque<int>>numlis(m+1);//どこに番号があるのだろう?\n\tvector<int>las(n);//最後に番号入れたのいつ？\n\tvector<bool>mita(m+1);\n\tfor(i=0;i<n;i++){las[i]=big;}\n\tfor(i=0;i<q;i++){\n\t\tint in;cin>>in;\n\t\tban[i]=in;\n\t\tnumlis[in].puf(i);\n\t}\n\tfor(i=q-1;i>=0;i--){\n\t\tint no=ban[i];\n\t\tif(mita[no]){continue;}//skipped\n\t\tbool mincan=false;\n\t\twhile(mita[zyu]){zyu++;}\n\t\tmita[no]=true;\n\t\tmincan=(zyu==no);\n\t\tfor(j=0;j<min(n,(int)numlis[no].size());j++){\n\t\t\tif(las[j]<numlis[no][j]){\n\t\t\t\tif(!mincan){cout<<\"No\"<<endl;return 0;}\n\t\t\t\tbreak;\n\t\t\t}else{las[j]=numlis[no][j];}\n\t\t}\n\t\tif(numlis[no].size()<n&&(!mincan)){cout<<\"No\"<<endl;return 0;}\n\t\tfor(;j<n;j++){if(las[j]==-999){break;}las[j]=-999;}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MX = 100 * 1000 + 7;\n\nvector<int> wait[MX];\nint pos[MX];\nvector<int> pattern;\nbool was[MX];\nint a[MX];\nvector<int> full;\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 1; i <= q; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) full.push_back(i);\n    for (int i = q; i >= 1; i--) {\n        int x = a[i];\n        if (was[x]) {\n            if (!wait[x].empty()) {\n                int cpos = wait[x].back();\n                wait[x].pop_back();\n                pos[cpos]++;\n                if (pos[cpos] == (int)pattern.size()) {\n                    full.push_back(cpos);\n                } else {\n                    wait[pattern[pos[cpos]]].push_back(cpos);\n                }\n            }\n        } else {\n            was[x] = true;\n            pattern.push_back(x);\n            for (int cpos : full) {\n                wait[x].push_back(cpos);\n            }\n            full.clear();\n        }\n    }\n    int maxPos = (int)pattern.size() - 1;\n    for (int i = 0; i < (int)pattern.size(); i++) {\n        if (pattern[i] == 1) {\n            bool ok = true;\n            for (int j = i; j < (int)pattern.size(); j++) {\n                if (pattern[j] != j - i + 1) ok = false;\n            }\n            if (ok) maxPos = i;\n        }\n    }\n    bool ok = true;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] < maxPos) ok = false;\n    }\n    if (ok) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m,q;\n  cin >> n >> m >> q;\n  int a[q];\n  rep(i,q) cin >> a[i];\n  map<int,int> ma;\n  vector<int> v;\n  bool u[m+1];\n  mem(u);\n  rrep(i,q) {\n    if(!ma.count(a[i])) {\n      v.pb(a[i]);\n      u[a[i]]=1;\n    }\n    ma[a[i]]++;\n  }\n  REP(i,1,m+1) {\n    if(!u[i]) v.pb(i);\n  }\n  v.pb(m+1);\n  bool f=1;\n  rep(i,v.size()-1) {\n    if(ma[v[i]]<n) f=0;\n    if(f) continue;\n    if(v[i]>v[i+1]) {\n      pr(\"No\");\n      return;\n    }\n  }\n  pr(\"Yes\");\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define OUT(a) cout<<(a)<<endl;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q,a[100010],rank[100010]={},cnt=1,l,dat[100010]={100010};\n    vector<int> res;\n    cin >> n >> m >> q;\n    REP(i,q){\n        cin >> a[i];\n    }\n    for(int i= q-1; i>=0;--i){\n        if(rank[a[i]]==0){\n            rank[a[i]]=cnt;\n            ++cnt;\n            res.push_back(a[i]);\n        }\n    }\n    REPN(i,1,m){\n        if(rank[i]==0){\n            rank[i]=cnt;\n            ++cnt;\n            res.push_back(i);\n        }\n    }\n\n    for(int i=m-1;i>0;--i){\n        if(res[i]<res[i-1]){\n            l=i;\n            break;\n        }\n    }\n\n    for(int i= q-1; i>=0;--i){\n        if(dat[rank[a[i]]]<dat[rank[a[i]]-1]){\n        ++dat[rank[a[i]]];\n        }\n    }\n    if(l==0)return 0;\n    REPN(i,1,l){\n        if(dat[l]<n){\n            cout << \"No\" <<endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" <<endl;\n    /*\n    OUT(l)\n    REP(i,m){\n        OUT(res[i])\n    }\n    REP(i,m+1){\n        OUT(dat[i])\n    }\n    //*/\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,q,a[N],vis[N],pos[N],cnt[N];\nVI v;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&q);\n\trep(i,0,q) scanf(\"%d\",a+i);\n\treverse(a,a+q);\n\trep(i,0,q) {\n\t\tif (!vis[a[i]]) {\n\t\t\tpos[a[i]]=SZ(v);\n\t\t\tv.pb(a[i]),vis[a[i]]=1;\n\t\t}\n\t}\n\tcnt[0]=n;\n\trep(i,0,q) {\n\t\tint w=pos[a[i]];\n\t\tif (cnt[w]>0) cnt[w]--,cnt[w+1]++;\n\t}\n\trep(i,1,m+1) if (!vis[i]) v.pb(i);\n\trep(i,0,SZ(v)) if (cnt[i]!=0) {\n\t\tbool val=1;\n\t\trep(j,i,m-1) if (v[j]>v[j+1]) val=0;\n\t\tassert(val);\n\t\tputs(val?\"Yes\":\"No\");\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[101000];\nint n, m, Q, w[101000], pv[101000], CC;\nstruct point{\n    int t, num;\n    bool operator<(const point &p)const{\n        return t<p.t;\n    }\n}P[101000];\nint main(){\n    int i, chk = 0, j, pp = -1;\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for(i=1;i<=m;i++)P[i].num=i,P[i].t=i;\n    for(i=1;i<=Q;i++){\n        scanf(\"%d\",&w[i]);\n        E[w[i]].push_back(i);\n        P[w[i]].t=-i;\n    }\n    sort(P+1,P+m+1);\n    for(i=1;i<=m;i++){\n        if(P[i].num == 1)pp = i;\n    }\n    if(pp!=-1){\n        chk = 1;\n        for(i=pp;i<m;i++)if(P[i].num > P[i+1].num)chk = 0;\n    }\n    if(!chk){\n        for(i=1;i<=m;i++)if(P[i].t<0)CC++;\n    }\n    else{\n        CC = pp-1;\n    }\n    if(1ll*CC*n > Q){\n        printf(\"No\\n\");\n        return 0;\n    }\n    for(i=1;i<=m;i++){\n        pv[i] = E[i].size() - 1;\n    }\n    for(i=1;i<=n;i++){\n        int tp = 1e9;\n        int ck2 = 0;\n        for(j=1;j<=m;j++){\n            int x = P[j].num;\n            if(x==1)ck2=1;\n            if(chk && ck2){\n                if(i==1){\n                    if(E[x][E[x].size()-1] > tp){\n                        printf(\"No\\n\");\n                        return 0;\n                    }\n                    tp = E[x][E[x].size()-1];\n                }\n                continue;\n            }\n            if(P[j].t > 0)break;\n            while(pv[x] >= 0 && E[x][pv[x]] > tp)pv[x]--;\n            if(pv[x] == -1){\n                printf(\"No\\n\");\n                return 0;\n            }\n            tp = E[x][pv[x]];\n            pv[x]--;\n        }\n    }\n    printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool allappeared[100050];\nint a[100050];\nbool canignore[100050];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    allappeared[0] = true;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(allappeared[a[i] - 1]) allappeared[a[i]] = true;\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared[a[i] - 1]) canignore[a[i]] = true;\n    }\n    /*\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    */\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        cerr << val[i] << \" \" << canignore[val[i]] << endl;\n    }\n    num[0] = N;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], num[nowindex-1]);\n        /*\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        */\n    }\n    for(int i = 1; i <= index; i++) {\n        if(!canignore[val[i]] && num[i] != N) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint a[100005],b[100005],c[100005],d[100005],e[100005]; bool f[100005],g[100005];\n \nconst int INF=1000000009;\n \nbool dcs(int m,int q){\n \n\tif(m==1) return 1;\n \n\tif(!dcs(m-1,q-c[m])) return 0;\n\n\tif(d[m]==0) return 1;\n \telse{\n \t\tif(g[m]) return 1;\n\t\telse{\n\t  \tif(f[m]) return 1;\n\t\t}\n \t}\n \n\treturn 0;\n \n}\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++) scanf(\"%d\",&a[i]);\n \n\tfor(int i=0; i<Q; i++) b[i]=a[i];\n \n\tsort(b,b+Q); M=b[Q-1];\n \n\tfor(int i=0; i<Q; i++) c[a[i]]++;\n\t\n\tfor(int i=0; i<100005; i++) if(c[i]>=N) g[i]=1;\n \n\tfor(int i=Q-1; i>=0; i--) if(!d[a[i]]) d[a[i]]=i+1;\n \n\tfor(int i=0; i<100005; i++) e[i]=INF;\n \n\tint Min=INF;\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]==0){\n\t\t\te[i]=INF; break;\n\t\t}else{\n\t\t\tif(d[i]<Min){\n\t\t\t\te[i]=d[i]; Min=d[i];\n\t\t\t}\n\t\t}\n\t}\n \n\tfor(int i=1; i<=M; i++){\n\t\tif(d[i]<e[i-1]&&e[i-1]!=INF) f[i]=1;\n\t}\n \n\tif(dcs(M,Q)) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n \n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> n_fixed(m+1, 0);\n\tn_fixed[0] = n;\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = order.size();\n\t\t\torder.emplace_back(a[i]);\n\n\t\t\tn_fixed[order.size()]++;\n\t\t\tn_fixed[order.size()-1]--;\n// show(n_fixed, \"n_fixed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tif (n_fixed[pos] > 0) {\n\t\t\tn_fixed[pos]--;\n\t\t\tn_fixed[pos+1]++;\n\t\t}\n// show(n_fixed, \"n_fixed\");\n\t}\n\n\t// show(order, \"order\");\n\t// show(n_fixed, \"n_fixed\");\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\torder.emplace_back(i);\n\t\t}\n\t}\n// show(order, \"order\");\n\n\tauto it = find_if(n_fixed.begin(), n_fixed.end(),\n\t                  [](const int &a) {return a > 0;});\n\tint min_fix = it - n_fixed.begin();\n// printf(\"min_fix %d\\n\", min_fix);\n\n\tbool ok = true;\n\tfor (int i = min_fix; i < order.size() - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,f[500010],m,a[500010],used;\nbool rem(){\n\tint t=0;\n\tFOR(i,1,q) if (a[i]>t){\n\t\tif (a[i]!=t+1) return 0;\n\t\t++t;\n\t}\n\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tif (rem()) return puts(\"Yes\"),0;\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,q) v[a[i]].pb(i);\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tu[a[now]]=1;\n\t\tused+=SZ(v[a[now]]);\n\t\tif (a[now]==1 && used==q) return puts(\"Yes\"),0;\n\t\tif (SZ(v[a[now]])<n) return puts(\"No\"),0;\n\t\tFOR(i,0,n-1){\n\t\t\tif (v[a[now]][i]<=f[i]) return puts(\"No\"),0;\n\t\t\tf[i]=v[a[now]][i];\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define FNAME \"\"\n\n#include <bits/stdc++.h>\n\n#define hash padjf9srpi\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (n); i++)\n#define fornr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forab(i, a, b) for (int i = (a); i < (b); i++)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n \n#ifdef _WIN32\n    #define I64 \"%I64d\"\n#else\n    #define I64 \"%lld\"\n#endif\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;                                                                                                                                                                                      \ntypedef vector <int> vi;\n\ntemplate <class T> T sqr(const T &a) {return a * a;}\n\nconst int MAXN = 2e5 + 100;\n\nset <int> Set[MAXN];\nint n, m, q, a[MAXN], was[MAXN], pos[MAXN];\nvi order;\n\nint main()\n{\n#ifdef LOCAL\n    freopen(FNAME\".in\", \"r\", stdin);\n    freopen(FNAME\".out\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tforab(i, 1, n)\n\t\tSet[0].insert(i);\n\tforn(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfornr(i, q) {\n\t\tif (!was[a[i]]) {\n\t\t\twas[a[i]] = 1;\n\t\t\tpos[a[i]] = (int) order.size();\n\t\t\torder.pb(a[i]);\n\t\t} else {\n\t\t\tint p = pos[a[i]];\n\t\t\tif (Set[p].size()) {\n\t\t\t\tSet[p + 1].insert(*Set[p].begin());\n\t\t\t\tSet[p].erase(Set[p].begin());\n\t\t\t}\n\t\t}\n\t}\n\tint okPos = order.size();\n\tint firstFail = (int) order.size();\n\tforn(i, (int) order.size()) \n\t\tif (Set[i].size()) {\n\t\t\tfirstFail = i;\n\t\t\tbreak;\n\t\t}\n\tforn(i, (int) order.size()) {\n\n\t\tif (order[i] == 1) {\n\t\t\tint kek = 1;\n\t        int last = 1;\n\t\t\tif (firstFail < i)\n\t\t\t\tcontinue;\n\t\t\tforab(j, i, (int) order.size()) {\n//\t\t\t    printf(\"j=%d order=%d last=%d was=%d\\n\", j, order[j], last, was[last]);\n\t\t\t\twhile (order[j] > last && was[last] && pos[last] < firstFail) last++;\n//\t\t\t    printf(\"j=%d order=%d last=%d\\n\", j, order[j], last);\n\t\t\t\tif (order[j] != last)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\twhile (last < m) {\n\t\t\t\tif (was[last] && pos[last] >= firstFail)\n\t\t\t\t\tkek = 0;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tif (kek)\n\t\t\t\tokPos = i;\n\t\t\tbreak;\n\t\t}\n\t}             /*\n\tfor (int i: order)\n\t\tprintf(\"%d \", i);\n\tprintf(\"\\n%d\\n\", okPos);*/\n\tint ok = 1;\n\tforn(i, okPos) {\n//\t\tprintf(\"%d\\n\", (int) Set[i].size());\n\t\tif (Set[i].size())\n\t\t\tok = 0;\n    }\n\tputs(ok ? \"Yes\" : \"No\");\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    int n,m,q;cin>>n>>m>>q;\n    int a[q];\n    rep(i,0,q)cin>>a[i];\n    int num[m+1];\n    fill(num,num+m+1,-1);\n    int now[m+1];\n    fill(now,now+m+1,-1);\n    now[0]=0;\n    int len[n];\n    fill(len,len+n,0);\n    rrep(i,q-1,0){\n        //rep(ii,0,2)cout<<len[ii]<<\" \";\n        //cout<<endl;\n        if(num[a[i]]==-1){\n            num[a[i]]=len[0];\n            len[0]++;\n            \n        }\n        else{\n            int u=n,d=-1;\n            int y=num[a[i]];\n            while(u-d>1){\n                int mid=(u+d)/2;\n                if(len[mid]<=y)u=mid;\n                else d=mid;\n            }\n            //cout<<y<<endl;\n            if(len[u]!=y){\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n            len[u]++;\n        }\n    }\n    //rep(i,0,2)cout<<len[i]<<endl;\n    int le=len[0];\n    int le2=len[n-1];\n    set<int> st;\n    int ka[m+1];\n    fill(ka,ka+m+1,-1);\n    rep(i,1,m+1){\n        if(num[i]>=0)ka[num[i]]=i;\n    }\n    //rep(i,0,3)cout<<ka[i]<<\" \";\n    //cout<<endl;\n    rep(i,1,m+1)st.insert(i);\n    rep(i,0,le2)st.erase(ka[i]);\n    rep(i,le2,le){\n        int u=ka[i];\n        int uu=*st.begin();\n        //cout<<u<<\" \"<<uu<<endl;\n        if(u!=uu){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        st.erase(st.begin());\n    }\n    cout<<\"Yes\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    int f=[&](){\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    if(id==(*s.begin())&&i>0){\n                        que.pop();\n                        return 1;\n                    }\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n    }\n    }();\n    if(f==0)return 0;\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n\n\nint main(){\n    ll m,n,q;cin>>m>>n>>q;//注意！\n    \n    ll a[q];\n    rep(i,0,q-1){\n        cin>>a[i];a[i]--;\n    }\n    reverse(a,a+q);\n    ll ans[n+1];fill(ans,ans+n+1,-1);\n    ll anspos=0;\n    ll ansc[n+1];memset(ansc,0,sizeof(ansc));\n    ll rev[n];fill(rev,rev+n,-1);\n    rep(i,0,q-1){\n        ll x=a[i];\n        if(rev[x]==-1){\n            rev[x]=anspos;\n            ll y=rev[x];\n            ans[y]=x;\n            ansc[y]++;\n            anspos++;\n        }else{\n            ll y=rev[x];\n            if(y>0&&ansc[y-1]>ansc[y])ansc[y]++;\n        }\n    }\n    vector<ll>v;\n    ll pos=0;\n    while(pos<=n-1&&ansc[pos]>=m){\n        pos++;\n    }\n    while(pos<=n-1&&ans[pos]!=-1){\n        v.pb(ans[pos]);\n        pos++;\n    }\n    //for(auto x:v)cout<<x<<\" \";cout<<endl;\n    rep(i,0,n-1){\n        if(rev[i]==-1)v.pb(i);\n    }\n    ll s=v.size();\n    //for(auto x:v)cout<<x<<\" \";cout<<endl;\n    //cout<<\" ans:\";rep(i,0,n)cout<<ans[i]<<\" \";cout<<endl;\n    //cout<<\"ansc:\";rep(i,0,n)cout<<ansc[i]<<\" \";cout<<endl;\n    //cout<<\" rev:\";rep(i,0,n-1)cout<<rev[i]<<\" \";cout<<endl;\n    rep(i,0,s-2){\n        if(v[i]>=v[i+1]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5+7;\nvector<int> cnt[N];\n\nbool check(vector<vector<int>> vvs, int n) {\n    sort(vvs.rbegin(), vvs.rend());\n    for (auto &v: vvs)\n        if (v.size() < n)\n            return false;\n\n    for (int i=0; i<n; i++) {\n        for (int j=1; j<vvs.size(); j++) {\n            if (vvs[j][i] > vvs[j][i-1])\n                return false;\n        }\n    }\n    return true;\n}\n\n\nbool check2(int k) {\n    for (int i=2; i<=k; i++)\n        if (cnt[i][0] > cnt[i-1][0])\n            return false;\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m, q;\n    cin>>n>>m>>q;\n\n    for (int i=1; i<=q; i++) {\n        int x;\n        cin>>x;\n        cnt[x].push_back(i);\n    }\n\n    vector<vector<int>> vvs;\n    int mx = 0;\n    for (int i=1; i<=m; i++) {\n        reverse(cnt[i].begin(), cnt[i].end());\n        if (i == 1) {\n            while (cnt[i].size() < n)   cnt[i].push_back(0);\n        }\n        if (cnt[i].size())  vvs.push_back(cnt[i]), mx = i;\n    }\n\n    if (check(vvs, n)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n    if (mx == vvs.size() && check2(mx)) {\n        cout<<\"Yes\\n\";\n        return 0;\n    }\n\n    cout<<\"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2016/09/24 20:56:18 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nusing namespace std;\n\nconst int maxn=100010;\n\nint seat[maxn],a[maxn],sum[maxn],num[maxn];\nbool finish[maxn];\n\nint main()\n{\n\tint n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for (int j=1;j<=q;++j)\n    {\n        scanf(\"%d\",&a[j]);\n    }\n    bool flag=1;\n    int last=0;\n    for (int j=q;j>0;--j)\n    {\n        if (a[j]>last)\n        {\n            if (a[j]==last+1) ++last;\n            else\n            {\n                flag=0;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    int cnt=0;\n    for (int j=q;j>0;--j)\n    {\n        int tis=a[j];\n        if (seat[tis]==0)\n        {\n            ++cnt;\n            seat[tis]=cnt;\n            sum[cnt]=1;\n            num[cnt]=tis;\n        }\n        else\n        {\n            if (finish[tis]) continue;\n            int st=seat[tis];\n            ++sum[st];\n            if (sum[st]==n)\n            {\n                finish[tis]=1;\n                continue;\n            }\n            if (st>1&&sum[st]>sum[st-1])\n            {\n                flag=1;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    int nx=1;\n    while (nx<=m&&finish[nx]) ++nx;\n    for (int j=1;j<=cnt;++j)\n    {\n        if (sum[j]<n)\n        {\n            if (num[j]!=nx)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                ++nx;\n                while (nx<=m&&finish[nx]) ++nx;\n            }\n        }\n    }\n    if (flag) printf(\"No\\n\");\n    else printf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint cnt[101010];\nint a[101010];\nint t[101010],tn;\nbool vis[101010];\nint main()\n{\n\tint n,m,q,mi=1;\n\tbool mk=false;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(vis,0,sizeof(vis));\n\ttn=0;\n\tfor(int i=q;i>=1;i--)\n\t{\n\t\tif(!cnt[a[i]])\n\t\t\tt[++tn]=a[i];\n\t\tcnt[a[i]]++;\n\t}\n\tfor(int i=1;i<=tn;i++)\n\t{\n\t\tif(cnt[t[i]]<n)\n\t\t{\n\t\t\twhile(vis[mi])\n\t\t\t\tmi++;\n\t\t\tif(mi!=t[i])\n\t\t\t{\n\t\t\t\tprintf(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tvis[t[i]]=true;\n\t}\n\tprintf(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\nconst int Qmax = 100001;\nconst int Mmax = 100001;\nint N,M,Q;\nint A[Qmax];\n\nint main(){\n  cin >> N >> M >> Q;\n  for(int i=0; i<Q; i++) cin >> A[i];\n\n  if(A[Q-1] == 1){\n    int t=1;\n    for(int i=Q-1; i>=0; i--){\n      if(A[i] == t || A[i] == t+1) t = A[i];\n      else break;\n    }\n    if(t == M) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n  }\n\n  set<int> used;\n  vector<pair<int, int> > x;\n  int order[Mmax];\n  int ok = 1;\n  for(int i=0; i<=M; i++) order[i] = -1;\n  for(int i=Q-1; i>=0; i--){\n    if(used.find(A[i]) == used.end()) {\n      order[A[i]] = x.size();\n      x.push_back(make_pair(A[i],1));\n      used.insert(A[i]);\n    }\n    else {\n      x[order[A[i]]].second += 1;\n      if(x[order[A[i]]-1].second < x[order[A[i]]].second &&\n         x[order[A[i]]-1].second < N) {\n        ok=0;\n        break;\n      }\n    }\n  }\n  for(int i=0; i<x.size(); i++){\n    if(i < x.size()-1){\n      if(x[i].second < N) ok=0;\n    }\n    else {\n      if(x[i].second < N &&\n         x[i].first != 1) ok=0;\n    }\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<int> as(q);\n    for (auto &a: as) {\n        cin >> a;\n        a--;\n    }\n\n    map<int, vector<int>> poss;\n\n    for (int i = 0; i < q; i++) {\n        poss[as[i]].push_back(i);\n    }\n\n    vector<int> height(n, q);\n\n    set<int> rest;\n    for (int i = 0; i < m; i++) {\n        rest.insert(i);\n    }\n\n    for (int i = q - 1; i >= 0; i--) {\n        int cur = as[i];\n        if (!rest.count(cur))\n            continue;\n\n        auto it = poss[cur].rbegin();\n        auto end = poss[cur].rend();\n        int partial = -1;\n\n        for (int j = 0; j < height.size(); j++) {\n            while (it != end && *it >= height[j])\n                it++;\n\n            if (it == end) {\n                partial = j;\n                break;\n            }\n\n            height[j] = *it++;\n        }\n\n        if (partial != -1) {\n            if (cur != *rest.begin()) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n\n            while (partial < height.size())\n                height[partial++] = -1;\n        }\n\n        // for (int j = 0; j < height.size(); j++)\n        //     cout << i << \", \" << j << \": \" << height[j] << endl;\n        // cout << endl;\n\n        rest.erase(cur);\n    }\n\n    cout << \"Yes\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    int Q; cin >> Q;\n    vec a(Q); readi(a);\n\n    mat m(N, vec(0));\n    vec count(M, 0);\n    IREP(i, Q){\n        if(count[a[i]] < N){\n            m[count[a[i]]].push_back(a[i]);\n            count[a[i]]++;\n        }\n    }\n    vector<bool> used(M, false);\n    for(int i: m[N - 1]) used[i] = true;\n    REP(i, M) if(!used[i]) m[N - 1].push_back(i);\n\n    bool ans = true;\n    REP(i, N - 1){\n        REP(j, m[i].size()) if(m[i][j] != m[N - 1][j]) ans = false;\n    }\n    if(ans) cout << \"Yes\";\n    else cout << \"No\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\nint Q;\nint a[MAXN], f[MAXN], g[MAXN], num[MAXN];\n\nvoid read(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d\", &Q);\n\tfor(int i = 1; i <= Q; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n}\n\nint check(){\n\tf[0] = 2 * (n + Q);\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tfor(int i = Q; i; i--)\n\t\tif (f[a[i]-1]){\n\t\t//\tf[a[i]-1]--;\n\t\t\tif (f[a[i]-1] > f[a[i]])\n\t\t\t\tf[a[i]]++;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint solve(){\n\tif (check()) return 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tf[i] = 0;\n\tint cnt = 0;\n\tfor(int i = Q; i; i--){\n\t\tint x = a[i];\n\t\tif (f[x] == 0){\n\t\t\tg[x] = ++cnt;\n\t\t\tnum[cnt] = x;\n\t\t\tf[x]++;\n\t\t}\n\t\telse{\n\t\t\tif (f[num[g[x]-1]] > f[x])\n\t\t\t\tf[x]++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<f[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<g[i]<<' '; cout<<endl;\n\tfor(int i = 1; i <= 3; i++)\n\t\tcout<<num[i]<<' '; cout<<endl;\n\tcout<<cnt<<endl;*/\n\tint now = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tg[i] = 0;\n\tfor(int i = 1; i <= cnt; i++)\n\t\tif (f[num[i]] < n){\n\t\t\tnow = i;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tg[num[i]] = 1;\n\t\t}\n\tif (now == -1) return 1;\n\tfor(int i = now, j = 1; i <= cnt && j <= n; i++, j++){\n\t\twhile(g[j] && j <= n) j++;\n\t\tif (j > n) break;\n\t\tif (num[i] != j)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid printans(int flag){\n\tputs(flag ? \"Yes\" : \"No\");\n}\n\t\n\nint main(){\n\tint T = 1;\n//\tcin>>T;\n\twhile(T--){\n\t\tread();\n\t\tprintans(solve());\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\nconst int Qmax = 100001;\nconst int Mmax = 100001;\nint N,M,Q;\nint A[Qmax];\n\nint main(){\n  cin >> N >> M >> Q;\n  for(int i=0; i<Q; i++) cin >> A[i];\n\n  if(A[Q-1] == 1){\n    int t=1;\n    for(int i=Q-1; i>=0; i--){\n      if(A[i] == t || A[i] == t+1) t = A[i];\n      else break;\n    }\n    if(t == M) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n  }\n\n  set<int> used;\n  vector<pair<int, int> > x;\n  int order[Mmax];\n  int ok = 1;\n  for(int i=0; i<=M; i++) order[i] = -1;\n  for(int i=Q-1; i>=0; i--){\n    if(used.find(A[i]) == used.end()) {\n      order[A[i]] = x.size();\n      x.push_back(make_pair(A[i],1));\n      used.insert(A[i]);\n    }\n    else {\n      x[order[A[i]]].second += 1;\n      if(x[order[A[i]]-1].second < x[order[A[i]]].second &&\n         x[order[A[i]]-1].second < N) {\n        ok=0;\n        break;\n      }\n    }\n  }\n  for(int i=0; i<x.size(); i++){\n    if(i < x.size()-1){\n      if(x[i].second < N) ok=0;\n    }\n    else {\n      if(x[i].second < N &&\n         x[i].first != 1) ok=0;\n    }\n  }\n\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvector<int> vec;\nint freq[100001];\nvi a;\nvi inv;\nbool visited[100001];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m, q;\n\tcin >> n >> m >> q; vec.resize(q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tcin >> vec[i]; vec[i]--;\n\t}\n\tfreq[0] = n;\n\treverse(vec.begin(), vec.end());\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tif(!visited[vec[i]])\n\t\t{\n\t\t\tvisited[vec[i]] = 1;\n\t\t\ta.pb(vec[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(!visited[i]) a.pb(i);\n\t}\n\t//cerr << a.size() << ' ' << n << '\\n';\n\tinv.resize(m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tinv[a[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint f = inv[vec[i]];\n\t\tif(freq[f])\n\t\t{\n\t\t\tfreq[f]--; freq[f+1]++;\n\t\t}\n\t}\n\tint idx = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tif(freq[i])\n\t\t{\n\t\t\tidx = i; break;\n\t\t}\n\t}\n\tfor(int i = idx; i < m - 1; i++)\n\t{\n\t\tif(a[i] >= a[i+1]) {cout << \"No\"; return 0;}\n\t}\n\tcout << \"Yes\"; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  { S.pb(n+n); int j = S.size()-1;\n    while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n    S.resize(j);\n  }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  int lo = S.size();\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1) {\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n        if(CNT[lo]==0) lo -=1;\n      }else{\n        if(lo<ix[A[i]]) {\n          CNT[lo]-=1;\n          CNT[ix[A[i]]]+=1;\n          lo=ix[A[i]];\n        }\n      }\n    }\n  }\n  if(lo!=0) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q), c(m);\n  for (auto&& e : a) {\n    cin >> e;\n    --e;\n    ++c[e];\n  }\n  reverse(begin(a), end(a));\n  set<int> se;\n  vector<int> v;\n  for (int e : a) {\n    if (se.count(e)) {\n      continue;\n    }\n    se.insert(e);\n    v.push_back(e);\n  }\n  for (int i = 0; i < m; ++i) {\n    if (se.count(i)) {\n      continue;\n    }\n    se.insert(i);\n    v.push_back(i);\n  }\n  while (v.size() >= 2 and v[v.size() - 2] < v.back()) {\n    v.pop_back();\n  }\n  v.pop_back();\n  if (any_of(begin(v), end(v), [&](int e) { return c[e] < n; })) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n  int k = v.size();\n  map<int, int> mp;\n  for (int i = 0; i < k; ++i) {\n    mp[v[i]] = i;\n  }\n  vector<int> t(k);\n  for (int e : a) {\n    if (not mp.count(e)) {\n      continue;\n    }\n    int i = mp[e];\n    ++t[i];\n    if (i and t[i - 1] < t[i]) {\n      cout << \"No\\n\";\n      exit(0);\n    }\n  }\n  cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***********************************************\nAuthor        :axp\nCreated Time  :2016/9/24 21:10:20\nTASK\t\t  :E.cpp\nLANG          :C++\n************************************************ */\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\nconst int inf = 1<<30;\nconst int md = 1e9+7;\nint n,m;\nint T;\nconst int N = 1e5+10;\nint num[N];\nint ar[N];\nint in[N];\nint mp[N];\nint save[N];\nint tot;\nint q;\nint cnt;\n\nbool solve()\n{\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(mp[ar[i]]>=n)continue;\n\t\tif(save[i]!=ar[i])return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;i++)scanf(\"%d\",&in[i]);\n\tfor(int i=q;i>=1;i--)\n\t{\n\t\tint x=in[i];\n\t\tif(!mp[x])mp[x]=++tot,ar[tot]=x;\n\t\tnum[x]++;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(mp[i]>=n)continue;\n\t\tsave[++cnt]=i;\n\t}\n\tbool ans=solve();\n\tputs(ans?\"Yes\":\"No\");\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,m,q,a[N],vis[N],pos[N],cnt[N];\nVI v;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tassert(m<=3);\n\tscanf(\"%d\",&q);\n\trep(i,0,q) scanf(\"%d\",a+i);\n\treverse(a,a+q);\n\trep(i,0,q) {\n\t\tif (!vis[a[i]]) {\n\t\t\tpos[a[i]]=SZ(v);\n\t\t\tv.pb(a[i]),vis[a[i]]=1;\n\t\t}\n\t}\n\tcnt[0]=n;\n\trep(i,0,q) {\n\t\tint w=pos[a[i]];\n\t\tif (cnt[w]>0) cnt[w]--,cnt[w+1]++;\n\t}\n\trep(i,1,m+1) if (!vis[i]) v.pb(i);\n\trep(i,0,SZ(v)) if (cnt[i]!=0) {\n\t\tbool val=1;\n\t\trep(j,i,m-1) if (v[j]>v[j+1]) val=0;\n\t\tputs(val?\"Yes\":\"No\");\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tcin >> n >> m >> q;\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order(m, -1);\n\tint n_order = 0;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tif (!num_used[a[i]]) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = n_order;\n\t\t\torder[n_order] = a[i];\n\t\t\tn_order++;\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = num_pos[a[i]];\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tit_bound = prev(it_bound);\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tauto it_order = find(order.begin(), order.end(), -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\t*it_order = i;\n\t\t\tit_order++;\n\n\t\t\tif (it_order == order.end()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < m - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nvector<ll> vec;\n\nint main()\n{\n\tfastInp;\n\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvec.resize(q);\n\tfor (int i = 0; i < n; i++) cin >> vec[i];\n\t\n\tvector<ll> c;\n\tmap<ll, ll> cnt;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcnt[i]--;\n\t\tcnt[i]++;\n\t}\n\tfor (auto cur : vec) {\n\t\tcnt[cur]++;\n\t\tc.push_back(cur);\n\t}\n\n\tsort(c.begin(), c.end());\n\n\tll zs = 0;\n\tvector<ll> bd, gd;\n\tfor (auto cur : cnt) {\n\t\tif (cur.second == 0) {\n\t\t\tzs++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cur.second < m) {\n\t\t\tbd.push_back(cur.second);\n\t\t}\n\t\telse if (cur.second >= m) {\n\t\t\tgd.push_back(cur.second - m);\n\t\t}\n\t}\n\n\tbool fl = true;\n\n\tif (bd.size() == 0) {\n\t\tcout << \"Yes\";\n\t\treturn 0;\n\t}\n\n\tsort(bd.begin(), bd.end());\n\tsort(gd.begin(), gd.end());\n\n\tll dif = 0;\n\tfor (int i = 1; i < bd.size(); i++) {\n\t\tif (bd[i] != bd[i - 1]) dif++;\n\t}\n\n\tif ((dif + zs) >= 3) {\n\t\tcout << \"No\";\n\t\treturn 0;\n\t}\n\n\tif (1) {\n\t\tif (zs >= 1) {\n\t\t\tif (gd.size() == 0 && bd[0] == bd.back()) {\n\n\t\t\t}\n\t\t\telse if (gd[0] < bd[0]) fl = false;\n\t\t}\n\t\telse if (zs == 0) {\n\t\t\tif (gd.size() == 0) {\n\t\t\t\tif (bd.back() != bd[0]) fl = false;\n\t\t\t}\n\t\t\telse if (gd.size() == 1) {\n\t\t\t\tif (gd[0] < bd[0]) {\n\t\t\t\t\tfl = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool fl2 = false;\n\t\t\t\tgd.push_back(INF);\n\t\t\t\tfor (int j = 1; j < gd.size(); j++) {\n\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\tif (gd[j + 1] >= bd[0] && gd[0] + gd[j] >= bd[0]) fl2 = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (gd[1] >= bd[0] && gd[0] + gd[j] >= bd[0]) fl2 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgd.pop_back();\n\t\t\t\tif (!fl2) fl = false;\n\t\t\t}\n\t\t}\n\t\telse if (zs >= 2 && bd.size() >= 1) {\n\t\t\tfl = false;\n\t\t}\n\t\telse if (zs >= 1 && bd.size() >= 1) {\n\t\t\tif (bd[0] > gd[0]) fl = false;\n\t\t}\n\t}\n\n\tif (fl) {\n\t\tcout << \"Yes\";\n\t}\n\telse {\n\t\tcout << \"No\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n  int n,m,q;\n  scanf(\"%d%d%d\",&n,&m,&q);\n  static int a[100010];\n  for(int i=0;i<q;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n  bool F=1;\n  static int P[100010],C[100010],T[100010];\n  for(int i=0;i<m;i++){\n    P[i]=-1;\n  }\n  int N=0;\n  for(int i=q-1;i>=0;i--){\n    int k=a[i];\n    if(P[k]==-1){\n      P[k]=N;\n      C[N]=1;\n      T[N]=k;\n      N++;\n    }\n    else if(C[P[k]]<n){\n      C[P[k]]++;\n      if(P[k]>0&&C[P[k]-1]<C[P[k]]){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  if(F){\n    for(int i=0;i<m;i++){\n      if(P[i]!=-1&&C[P[i]]<n&&P[i]!=N-1&&T[P[i]+1]<i){\n\tF=0;\n\tbreak;\n      }\n    }\n  }\n  puts(F?\"Yes\":\"No\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    int n, m, nq;\n    cin >> n >> m >> nq;\n\n    vector<vector<int>> positions(m);\n    vector<int> q(nq);\n\n    for (int i = 0; i < nq; i++)\n    {\n        cin >> q[i];\n        q[i]--;\n        positions[q[i]].push_back(i);\n    }\n\n    vector<int> lastPos(n, m);\n\n    bool fail = false;\n    int maxNumber = 0;\n    bool maxedOut = false;\n\n    set<int> unused;\n    for (int i = 0; i < m; i++) unused.insert(i);\n    for (int x: q) unused.erase(x);\n\n    vector<int> inFront;\n    for (int x: unused)\n        inFront.push_back(x);\n    reverse(inFront.begin(), inFront.end());\n\n    copy(q.begin(), q.end(), back_inserter(inFront));\n    q = inFront;\n    nq = q.size();\n\n    set<int> used;\n    for (int i = nq - 1; i >= 0; i--)\n    {\n        if (used.count(q[i])) continue;\n\n        used.insert(q[i]);\n\n        //if (used.size() == m) break;\n\n        if (maxedOut)\n        {\n            if (q[i] < maxNumber)\n            {\n                fail = true;\n                break;\n            }\n            maxNumber = q[i];\n            continue;\n        }\n\n        vector<int> newLastPos;\n\n        int j = positions[q[i]].size() - 1;\n        for (int filled = 0; filled < n; filled++)\n        {\n            while (j >= 0 && positions[q[i]][j] > lastPos[filled])\n                j--;\n\n            if (j < 0)\n            {\n                maxedOut = true;\n                maxNumber = q[i];\n                break;\n            }\n\n            newLastPos.push_back(positions[q[i]][j]);\n            j--;\n        }\n\n        lastPos = newLastPos;\n    }\n\n    printf(\"%s\\n\", fail ? \"No\" : \"Yes\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, m, q;\nint a[100005];\nint b[200005];\nint last[200005];\nbool used[200005];\nint cnt;\n\nvoid corr(int *a, int &cnt) {\n    memset(last, -1, sizeof last);\n    forn(i, cnt) used[i] = true;\n    forn(i, cnt) {\n        if (last[a[i]] != -1) {\n            used[last[a[i]]] = false;\n        }\n        last[a[i]] = i;\n    }\n    int ncnt = 0;\n    forn(i, cnt) if (used[i]) {\n        a[ncnt++] = a[i];\n    }\n    cnt = ncnt;\n    reverse(a, a + cnt);\n    forn(i, n) if (last[i] == -1) {\n        a[cnt++] = i;\n    }\n}\n\nint pos[100000] = {};\nset<int> where[100000];\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    scanf(\"%d%d%d\", &n, &m, &q);\n    forn(i, q) scanf(\"%d\", a + i), --a[i];\n    forn(i, m) b[i] = m - 1 - i;\n    cnt = m;\n    forn(i, q) b[cnt++] = a[i];\n    corr(b, cnt);\n    while (cnt > 1 && b[cnt - 1] > b[cnt - 2]) {\n        --cnt;\n    }\n    --cnt;\n    if (cnt == 0) {\n        cout << \"Yes\" << endl;\n        return 0;\n    }\n    reverse(a, a + q);\n    forn(i, n) {\n        pos[i] = 0;\n        where[b[0]].insert(i);\n    }\n    forn(i, q) {\n        int val = a[i];\n        if (!where[val].empty()) {\n            int ind = *where[val].begin();\n            where[val].erase(where[val].begin());\n            ++pos[ind];\n            if (pos[ind] < cnt) {\n                where[b[pos[ind]]].insert(ind);\n            }\n        }\n    }\n    forn(i, n) if (pos[i] != cnt) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\n\nint t[100005];\nmap<int,int> m1;\nvector<int> v1,v2;//after,count\n\nint main(){\n\tint n,m,q;\n\tint i,j,k;\n\tint a,b,c;\n\tcin>>n>>m>>q;\n\tfor(i=0;i<q;i++){\n\t\tcin>>t[i];\n\t}\n\tv2.push_back(n);\n\tfor(i=q-1;i>=0;i--){\n\t\tif(m1.find(t[i])==m1.end()){\n\t\t\tm1[t[i]]=v2.size();\n\t\t\tv1.push_back(t[i]);\n\t\t\tv2.push_back(0);\n\t\t}\n\t\tb=m1[t[i]];\n\t\tif(v2[b-1]>0)v2[b]++,v2[b-1]--;\n\t}\n\tfor(i=1;i<=n+1;i++){\n\t\tif(m1.find(i)!=m1.end())continue;\n\t\tm1[i]=v1.size();\n\t\tv1.push_back(i);\n\t\tbreak;\n\t}\n\tint s=v2.back();\n\tfor(i=v1.size()-1;i>=0;i--){\n\t\tif(v1[i-1]>v1[i])break;\n\t\ts+=v2[i-1];\n\t}\n\tif(s==n)cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nint N,M,Q,MIN;\nint a[111111];\nint LST[111111];\nvector<int> pos[111111];\nbool valid[111111];\n\nstruct Node{\n\tint prev,next;\n\tint val;\n} node[111111];\nint head,tail,Z;\nint pnt[111111],cnt_bad;\n\nbool chk(){\n\tcnt_bad = 0;\n\tfor(int i=1; i<=M; i++)\n\t\tvalid[i] = true;\n\n\thead = tail = ++Z;\n\tnode[Z].prev = -1;\n\tnode[Z].next = -1;\n\tnode[Z].val = 0;\n\n\tfor(int i=1; i<=M; i++)\n\t\tif(!pos[i].empty()){\n\t\t\tif(tail != head){\n\t\t\t\tif(pos[node[tail].val].back() < pos[i].back())\n\t\t\t\t\tcnt_bad++;\n\t\t\t}\n\t\t\t++Z;\n\t\t\tnode[Z].prev = tail;\n\t\t\tnode[Z].next = -1;\n\t\t\tnode[Z].val = i;\n\t\t\tpnt[i] = Z;\n\n\t\t\tnode[tail].next = Z;\n\t\t\ttail = Z;\n\t\t}\n\n\tMIN = 1;\n\tfor(int i=Q; i>=1; i--){\n\t\tif(!valid[a[i]])continue;\n\t\tint x = a[i];\n\t\tif(x == MIN){\n\t\t\tif(cnt_bad == 0)return true;\n\t\t}\n\t\tint sz = (int)pos[x].size(), ct = 1;\n\t\tfor(int j=sz-1; j>=0; j--){\n\t\t\tif(pos[x][j] < LST[ct]){\n\t\t\t\tLST[ct] = pos[x][j];\n\t\t\t\t++ct;\n\t\t\t\tif(ct > N)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ct <= N)\n\t\t\treturn false;\n\t\tvalid[x] = false;\n\n\t\tint p = pnt[x];\n\t\tint prev_pnt = node[p].prev;\n\t\tint next_pnt = node[p].next;\n\n\t\tif(prev_pnt != head && pos[node[prev_pnt].val].back() < pos[x].back())cnt_bad--;\n\t\tif(next_pnt != -1 && pos[x].back() < pos[node[next_pnt].val].back())cnt_bad--;\n\t\tif(prev_pnt != head && next_pnt != -1 && pos[node[prev_pnt].val].back() < pos[node[next_pnt].val].back())cnt_bad++;\n\n\t\tnode[prev_pnt].next = next_pnt;\n\t\tif(next_pnt!=-1)node[next_pnt].prev = prev_pnt;\n\n\t\twhile(MIN <= M && !valid[MIN])MIN++;\n\t}\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&Q);\n\tfor(int i=1; i<=Q; i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=N; i++)\n\t\tLST[i] = 123456789;\n//\tputs(chk()?\"Yes\":\"No\");\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\nint n, m, q;\nint a[100000];\n\nint cnt[100001];\nint pos[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tvector<int> ord;\n\tcin >> n >> m >> q;\n\trep(i, q) cin >> a[i], a[i]--;\n\tset<int> s;\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tif (s.count(a[i]))continue;\n\t\tord.push_back(a[i]);\n\t\ts.insert(a[i]);\n\t}\n\trep(i, m) {\n\t\tif (s.count(i) == 0)ord.push_back(i);\n\t}\n\tint mi = 0;\n\tcnt[0] = n;\n\treverse(all(ord));\n\trep(i, m)pos[ord[i]] = i;\n\tbool f = true;\n\tfor (int i = 0; i < ord.front()+1;i++) {\n\t\tif (ord[i] != ord.front() - i)f = false;\n\t}\n\tif (f) {\n\t\tcnt[0] = 0;\n\t\tcnt[mi = ord.front() + 1] = n;\n\t}\n\n\trep(i, m) {\n\t\tif (ord[i] != m - 1 - i)break;\n\t\tord[i] = 0;\n\t\tord[i + 1] = n;\n\t\tmi = i + 1;\n\t}\n\n\trep(i, q) {\n\t\tint p = pos[a[i]];\n\t\tif (cnt[p] > 0) {\n\t\t\tcnt[p]--;\n\t\t\tcnt[p + 1]++;\n\t\t\tif (mi == p && cnt[p] == 0)mi++;\n\t\t}\n\t\telse {\n\t\t\tif (p == 0 || cnt[p - 1] == a[i]) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt[mi]--;\n\t\t\t\tcnt[mi = 0]++;\n\t\t\t\tif (ord[0] == a[i]) {\n\t\t\t\t\tcnt[mi++]--;\n\t\t\t\t\tcnt[mi]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (cnt[m] == n ? \"Yes\" : \"No\") << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor : samjia2000\nSource : code festival 2016 qual A E.LRU Puzzle\n*/\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 100005;\n\nint n,m,q;\nint a[N];\nbool bz[N];\nint w[N],lst[N];\nint Rig[N];\nint a1[N],a2[N],k1,k2;\nint be[N];\nint num[N];\n\nint main(){\n\tn=get();m=get();\n\tq=get();\n\tfo(i,1,q)a[i]=get();\n\tfo(i,1,q){\n\t\tlst[i]=w[a[i]];\n\t\tw[a[i]]=i;\n\t}\n\tfo(i,1,n)Rig[i]=q+1;\n\tfd(i,q,1)\n\tif (!bz[a[i]]){\n\t\tint x=1,w=i;\n\t\tfor(;x<=n&&w;w=lst[w]){\n\t\t\tif(w<Rig[x]){\n\t\t\t\tRig[x]=w;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (x>n)bz[a[i]]=1;\n\t\telse{\n\t\t\tfo(x,1,m)if (!bz[x])a1[++k1]=x;\n\t\t\tfd(x,i,1)if (!bz[a[x]])bz[a2[++k2]=a[x]]=1;\n\t\t\tbool pd=1;\n\t\t\tfo(x,1,k2)pd&=(a1[x]==a2[x]);\n\t\t\tif (!pd)return printf(\"No\\n\"),0;\n\t\t\treturn printf(\"Yes\\n\"),0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M, Q;\nint A[100000];\nbool used[100000];\nint perm[100000], rev[100000];\nint C[100001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) cin >> A[i], A[i]--;\n\n  C[0] = N;\n  int top = 0;\n  for (int i=Q-1; i>=0; i--) {\n    int a = A[i];\n    if (used[a]) {\n      if (C[rev[a]] > 0) C[rev[a]+1]++, C[rev[a]]--;\n    }\n    else {\n      used[a] = true;\n      perm[top] = a;\n      rev[a] = top;\n      C[top]--, C[top+1]++;\n      top++;\n    }\n  }\n  vector<int> result;\n  rep(i, M) used[i] = false;\n  rep(i, M) {\n    if (C[i]) break;\n    result.pb(perm[i]);\n    used[perm[i]] = true;\n  }\n  rep(i, M) if (!used[i]) result.pb(i);\n  //cout<<\"result: [\";for (int x:result)cout<<x<<\",\";cout<<\"]\\n\";\n  bool bad = false;\n  rep(i, M) {\n    if (result[i] != perm[i]) bad = true;\n\n    if (C[i+1] > 0 && bad) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100000;\n\nint a[N], len[N], cnt[N], rnk[N];\n\nint main()\n{\n  int n, m, q;\n  while (scanf(\"%d%d%d\", &n, &m, &q) == 3) {\n    for (int i = 0; i < q; ++ i) {\n      scanf(\"%d\", a + i);\n      a[i] --;\n    }\n    memset(len, 0, sizeof(*len) * n);\n    memset(cnt, 0, sizeof(*cnt) * m);\n    memset(rnk, -1, sizeof(*rnk) * m);\n    std::vector<int> seq;\n    for (int i = q - 1; i >= 0; -- i) {\n      if (rnk[a[i]] == -1) {\n        rnk[a[i]] = seq.size();\n        seq.push_back(a[i]);\n      }\n      if (cnt[a[i]] < n) {\n        len[cnt[a[i]]] ++;\n        cnt[a[i]] ++;\n      }\n    }\n    int o = 0;\n    while (o < m && ~rnk[o]) {\n      o ++;\n    }\n    int min_len = seq.size();\n    while (min_len > 0 && seq[min_len - 1] < o) {\n      o = seq[-- min_len];\n    }\n    bool ok = true;\n    for (int i = 0; i < n; ++ i) {\n      ok &= len[i] >= min_len;\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  int q;\n  cin >> q;\n  vector<int> a(q);\n  for(int i = 0; i < q; i++){\n    cin >> a[i];\n    a[i]--;\n  }\n\n  vector<int> b(m, -1);\n  vector<int> pos(m, -1);\n  vector<int> freq(m + 1,0);\n  freq[0] = n;\n  freq[m] = 0;\n  int known = 0;\n  for(int it = q - 1; it >= 0; it--){\n    int i = a[it];\n    if(pos[i] == -1){\n      b[known] = i;\n      pos[i] = known;\n      freq[known]--;\n      known++;\n      freq[known]++;\n      continue;\n    }\n    if(freq[pos[i]] > 0){\n      freq[pos[i]]--;\n      freq[pos[i] + 1]++;\n    }\n  }\n  \n  int first = -1;\n  for(int i = 0; i <= m; i++){\n    if(freq[i]  > 0){\n        first = i;\n        break;\n    }\n  }\n  \n  vector<int> all;\n  for(int i = first; i < known; i++){\n     all.push_back(b[i]);\n  }\n  for(int i = 0; i < m; i++){\n    if(pos[i] == -1){\n      all.push_back(i);\n    }\n  }\n  \n sort(all.begin(), all.end());\n  for(int i = first; i < known; i++){\n    if(all[i - first] != b[i]){\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n,m,q;\nint a[100005];\nint re;\nint qu[100005],ha[100005],head=0,tail=0;\n\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>q;\n    for(int i=1; i<=q; i++)\n    {\n        cin>>a[i];\n    }\n    head=tail=1;\n    qu[1]=a[q];\n    ha[1]=1;\n    for(int i=q-1; i>=1; i--)\n    {\n        if(a[i]==qu[head])\n        {\n            ha[head]++;\n            if(ha[head]==n)\n            {\n                head++;\n            }\n        }\n        else\n        {\n            for(int j=1; j<=tail; j++)\n            {\n                if(qu[j]==a[i])\n                    goto haha;\n            }\n            tail++;\n            qu[tail]=a[i];\n            haha:;\n        }\n    }\n    cout<<head<<  \"  \"<<tail<<endl;\n    if(head==tail)\n    {\n        if(ha[head]>=n)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n        if(qu[head]==1)\n        {\n            cout<<\"Yes\";\n            return 0;\n        }\n    }\n    int ji=0;\n    for(int j=1; j<=tail; j++)\n    {\n        if(qu[j]==j) ji++;\n    }\n    if(ji==tail)\n    {\n        cout<<\"Yes\";\n        return 0;\n    }\n\n    cout<<\"No\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=m;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    if(pos[val].size()<n){\n      if(val==1){\n        last=true;\n      }\n    }\n\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(val==0){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e18;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    vi b(q);\n\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n    reverse(ALL(b));\n    int k=1;\n    for(int i=0;i<q;i++){\n        if(b[i]==k){\n            k++;\n        }else if(b[i]!=k-1){\n            break;\n        }\n    }\n    if(k==m+1){\n        cout<<\"Yes\";\n        return;\n    }\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]!=cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n            }\n        }\n    }\n\n\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n    for(int i=1;i<=m;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint smlst, N, M, Q, nr, b[100009], a[100009], pos[100009], need[100009];\nbool ap[100009];\n\nvoid Ans (bool x)\n{\n    if (x) printf (\"Yes\\n\");\n    else printf (\"No\\n\");\n    exit (0);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &M, &Q);\nfor (int i=1; i<=Q; i++)\n    scanf (\"%d\", &a[i]);\nb[++nr] = a[Q --], pos[b[1]] = 1;\nneed[1] = N - 1;\nwhile (Q)\n{\n    int val = a[Q --];\n    if (pos[val] != 0)\n    {\n        int p = pos[val];\n        if (need[p]) need[p] --, need[p + 1] ++;\n        continue;\n    }\n    b[++nr] = val, pos[val] = nr;\n}\nsmlst = -1;\nfor (int i=1; i<=nr; i++)\n    if (need[i] > 0)\n    {\n        smlst = i - 1;\n        break;\n    }\nif (smlst == -1) Ans (1);\nfor (int i=1; i<=smlst; i++)\n    ap[b[i]] = 1;\nint j = smlst + 1;\nfor (int i=1; i<=M; i++)\n    if (ap[i] == 0)\n    {\n        if (j > nr) break;\n        if (i != b[j ++]) Ans (0);\n    }\nAns (1);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n, m; cin >> n >> m;\n    ll Q; cin >> Q;\n    vector<ll> a(Q); cin >> a; REP(i, Q) a[i]--;\n    vector<ll> seq = [&]() {\n        set<ll> used;\n        vector<ll> res;\n        RREP(i, Q) {\n            if (used.count(a[i]) == 0) {\n                res.pb(a[i]);\n                used.insert(a[i]);\n            }\n        }\n        REP(i, m) if ( used.count(i) == 0 ) res.pb(i);\n        return res;\n    }();\n\n    vector<ll> rseq(m); REP(i, m) rseq[seq[i]] = i;\n    vector<ll> cnt(m+1, 0); cnt[0] = n;\n    // int skipped = 0;\n    RREP(i, Q) {\n        ll pos = rseq[a[i]];\n        if (cnt[pos] > 0) --cnt[pos], ++cnt[pos+1];\n        // else ++skipped;\n    }\n    ll def = 1;\n    RREP(i, m-1) {\n        if (seq[i+1] > seq[i]) ++def;\n        else break;\n    }\n    bool ans = true;\n    // if (skipped > 0 && cnt[m] == 0 && cnt[m-1] == 0) {\n    //     ans = false;\n    // }\n    cout << seq << endl;\n    cout << cnt << endl;\n    cout << def << endl;\n    REP(i, m) {\n        if (cnt[i] > 0 && i+def < m) ans = false;\n    }\n    if (ans) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nconst int MAX = 100000;\n\nint n,m;\nint q;\nint a[MAX];\nbool used[MAX];\nint t[MAX];\nint t_i;\nint rev[MAX];\nint cnt[MAX+1];\n\nint main(){\n  scanf(\"%d%d%d\",&n,&m,&q);\n  REP(i,q)scanf(\"%d\",a+i),--a[i];\n  // calc target sequence\n  FORR(i,0,q){\n    int c = a[i];\n    if(!used[c]){\n      used[c] = true;\n      t[t_i++] = c;\n    }\n  }\n  REP(i,m){\n    if(!used[i])t[t_i++] = i;\n    rev[t[i]] = i;\n  }\n  // split\n  cnt[0] = n;\n  FORR(i,0,q){\n    int c = a[i];\n    int id = rev[c];\n    if(cnt[id]>0){\n      cnt[id]--;\n      cnt[id+1]++;\n    }\n  }\n  REP(i,m){\n    if(cnt[i]>0){\n      bool flag = true;\n      FOR(j,i,m-1){\n        flag = flag && t[j]<t[j+1];\n      }\n      puts(flag?\"Yes\":\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2016/09/24 20:56:18 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nusing namespace std;\n\nconst int maxn=100010;\n\nint seat[maxn],a[maxn],sum[maxn],num[maxn];\nbool finish[maxn];\n\nint main()\n{\n\tint n,m,q;\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for (int j=1;j<=q;++j)\n    {\n        scanf(\"%d\",&a[j]);\n    }\n    bool flag=1;\n    int last=0;\n    for (int j=q;j>0;--j)\n    {\n        if (a[j]>last)\n        {\n            if (a[j]==last+1) ++last;\n            else\n            {\n                flag=0;\n                break;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"Yes\\n\");\n        return 0;\n    }\n    int cnt=0;\n    for (int j=q;j>0;--j)\n    {\n        int tis=a[j];\n        if (seat[tis]==0)\n        {\n            ++cnt;\n            seat[tis]=cnt;\n            sum[cnt]=1;\n            num[cnt]=tis;\n        }\n        else\n        {\n            if (finish[tis]) continue;\n            int st=seat[tis];\n            ++sum[st];\n            if (st>1&&sum[st]>sum[st-1]) --sum[st];\n            if (sum[st]==n)\n            {\n                finish[tis]=1;\n                continue;\n            }\n        }\n    }\n    if (flag)\n    {\n        printf(\"No\\n\");\n        return 0;\n    }\n    int nx=1;\n    while (nx<=m&&finish[nx]) ++nx;\n    for (int j=1;j<=cnt;++j)\n    {\n        if (sum[j]<n)\n        {\n            if (num[j]!=nx)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                ++nx;\n                while (nx<=m&&finish[nx]) ++nx;\n            }\n        }\n    }\n    if (flag) printf(\"No\\n\");\n    else printf(\"Yes\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N, M, Q;\nint a[100010], b[100010];\nbool us[100010];\nint pos[100010];\nint nums[100010];\nbool inc[100010];\n\nint main() {\n\tcin >> N >> M >> Q;\n\n\trep(i, Q) cin >> a[i];\n\tint now = 0;\n\tfor (int i = Q-1; i >= 0; --i) {\n\t\tif (!us[a[i]]) {\n\t\t\tus[a[i]] = 1;\n\t\t\tb[now++] = a[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= M; ++i) {\n\t\tif (us[i]) {\n\t\t\tb[now++] = i;\n\t\t}\n\t}\n\n\trep(i, M) {\n\t\tpos[b[i]] = i;\n\t}\n\n\tinc[M] = 1; b[M] = 2e5;\n\n\tfor (int i = M-1; i >= 0; --i) {\n\t\tinc[i] = inc[i+1] && (b[i] < b[i+1]);\n\t}\n\n\tnums[0] = N;\n\n\tfor (int i = Q-1; i >= 0; --i) {\n\t\tint p = pos[a[i]];\n\n\t\tif (nums[p] > 0) {\n\t\t\t--nums[p];\n\t\t\t++nums[p+1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (nums[i] > 0 && !inc[i]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXLEN=100000;\nconst int MAXOP=100000;\n\nint n,len,nop;\nint op[MAXOP];\n\nint pos[MAXLEN],npos;\nint cnt[MAXLEN+1];\nint res[MAXLEN];\n\nbool solve() {\n\tREP(i,len) pos[i]=-1; npos=0;\n\tREPE(i,len) cnt[i]=0; cnt[0]=n;\n\tfor(int i=nop-1;i>=0;--i) {\n\t\tint cur=op[i];\n\t\tif(pos[cur]==-1) {\n\t\t\tint p=npos; pos[cur]=npos++;\n\t\t\tassert(cnt[p]>0); --cnt[p],++cnt[p+1];\n\t\t} else {\n\t\t\tint p=pos[cur];\n\t\t\tif(cnt[p]>0) --cnt[p],++cnt[p+1];\n\t\t}\n\t}\n\tREP(i,len) if(pos[i]==-1) pos[i]=npos++;\n\tREP(i,len) res[pos[i]]=i;\n\tint need=len-1; while(need>0&&res[need-1]<res[need]) --need;\n\t//printf(\"res:\"); REP(i,len) printf(\" %d\",res[i]+1); puts(\"\");\n\t//printf(\"cnt:\"); REPE(i,len) printf(\" %d\",cnt[i]); printf(\" (need=%d)\\n\",need);\n\tREP(i,need) if(cnt[i]>0) return false;\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\",&n,&len,&nop); REP(i,nop) scanf(\"%d\",&op[i]),--op[i];\n\tprintf(\"%s\\n\",solve()?\"Yes\":\"No\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=q;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(val==0){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n        ++j;\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n \nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vec a(Q);\n    for(int i=0;i<Q;i++){\n        cin >> a[i];\n        a[i]--;\n    }\n\n    vector<bool> used(M, false);\n    vec que(M + 1, 0);\n    vec next(M, -1);\n    int prev = -1;\n\n    que[M] = N - 1;\n\n    for(int p = Q - 1; p >= 0; p--){\n        if (que[a[p]] > 0){\n            que[a[p]]--;\n            if(next[a[p]] != -1){\n                assert(0 <= next[a[p]] && next[a[p]] < M);\n                que[next[a[p]]]++;\n            }else{\n                que[M]++;\n            }\n        }else{\n            if(used[a[p]]){\n\n            }else{\n                used[a[p]] = true;\n                if(prev >= 0) next[prev] = a[p];\n                prev = a[p];\n                que[a[p]] += que[M];\n                que[M] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(que[i] > 0){\n            if(next[i] != -1){\n                assert(0 <= next[i] && next[i] < M);\n                que[next[i]] += que[i];\n            }else{\n                que[M] += que[i];\n            }\n        }\n    }\n\n    if(que[M] == N - 1){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\treturn 0;\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\t//cout << \"i=\" << i << \" idx = \" << idx << endl;\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cassert>\n\nconst int N = 1e5 + 7;\n\nint n, m, q;\nint a[N];\nint visit[N], b[N];\nstd::vector<int> queue[N];\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tqueue[0].push_back(i);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tvisit[i] = -1;\n\t}\n\tint cur = 0;\n\tfor (int i = q; i >= 1; i--) {\n\t\tint num = a[i];\n\t\tif (visit[num] != -1) {\n\t\t\tint pos = visit[num];\n\t\t\tif (queue[pos - 1].size()) {\n\t\t\t\tint back = queue[pos - 1].back();\n\t\t\t\tqueue[pos - 1].pop_back();\n\t\t\t\tqueue[pos].push_back(back);\n\t\t\t}\n\t\t} else {\n\t\t\tvisit[num] = ++cur;\n\t\t\tassert(queue[cur - 1].size());\n\t\t\tint back = queue[cur - 1].back();\n\t\t\tqueue[cur - 1].pop_back();\n\t\t\tb[cur] = num;\n\t\t\tqueue[cur].push_back(back);\n\t\t}\n\t}\n\tfor (int i = cur + 1, ptr = 1; i <= m; i++) {\n\t\twhile (visit[ptr] != -1) {\n\t\t\tptr++;\n\t\t}\n\t\tb[i] = ptr;\n\t\tvisit[ptr] = i;\n\t}\n\t/*\n\tprintf(\"b = \\n\");\n\tfor (int i = 1; i <= m; i++) {\n\t\tprintf(\"%d \", b[i]);\n\t}\n\tputs(\"\");\n\t*/\n\tint least = cur;\n\tfor (int i = 0; i <= cur; i++) {\n\t\tif (queue[i].size()) {\n\t\t\tleast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//printf(\"%d\\n\", least);\n\tfor (int i = least + 1; i < m; i++) {\n\t\tif (b[i] > b[i + 1]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, Q;\nint A[101010];\nint cnt[101010];\nset<int> poss[101010];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\t--A[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\t++cnt[A[i]];\n\t\tposs[A[i]].insert(i);\n\t}\n\tset<int> rem;\n\tfor (int i = 0; i < M; ++i) rem.insert(i);\n\tvector<int> req;\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tif (rem.count(A[i]) == 0) continue;\n\t\tif (0 && rem.size() > 0 && *(rem.begin()) == A[i]) {\n\t\t\t// you can ignore it\n\t\t} else {\n\t\t\treq.push_back(A[i]);\n\t\t}\n\t\trem.erase(A[i]);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lp = Q;\n\t\tint fg = -1;\n\t\tfor (int j : req) {\n\t\t\tint nxtp = -1;\n\t\t\tauto pt = poss[j].upper_bound(lp);\n\t\t//\tprintf(\"%d \", lp);\n\t\t\tif (pt == poss[j].begin()) {\n\t\t\t\tif (fg > j) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tfg = j;\n\t\t\t\tlp = -1;\n\t\t\t} else {\n\t\t\t\tnxtp = *(--pt);\n\t\t\t\tlp = nxtp;\n\t\t\t\tposs[j].erase(lp);\n\t\t\t}\n\t\t}\n\t//\tputs(\"\");\n\t}\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    li n, m;\n    cin >> n >> m;\n    li q;\n    cin >> q;\n    vector<li> qs(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> qs[i];\n        qs[i]--;\n    }\n\n    reverse(qs.begin(), qs.end());\n    bool ok = true;\n\n    map<li, li> positions;\n    map<li, li> length_count;\n    length_count[0] = n;\n    for (int i = 0; i < q; ++i) {\n        bool first_time = positions.count(qs[i]) == 0;\n        if (first_time) {\n            const li next_index = positions.size();\n            positions[qs[i]] = next_index;\n        }\n\n        const li next_index = positions[qs[i]];\n        if (length_count[next_index] > 0) {\n            length_count[next_index]--;\n            length_count[next_index + 1]++;\n        } else if (first_time) {\n            ok = false;\n            break;\n        }\n    }\n\n    if (ok) {\n        li shortest = m;\n        for (int i = 0; i < m; ++i) {\n            if (length_count[i] > 0) {\n                shortest = min(shortest, (li)i);\n            }\n        }\n        vector<li> order(positions.size());\n        for (auto &position  : positions) {\n            order[position.second] = position.first;\n        }\n        set<li> unseen;\n        for (int i = 0; i < m; ++i) {\n            unseen.insert(i);\n        }\n        for (int i = 0; i < positions.size(); ++i) {\n            if (i < shortest) {\n                unseen.erase(order[i]);\n            } else {\n                ok &= unseen.lower_bound(order[i]) == unseen.begin();\n                unseen.erase(order[i]);\n            }\n        }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nvec v[100010];\nbool u[500010];\nint now,q,n,f[500010],m,a[500010],used;\nbool rem(){\n\tint t=0;\n\tFOR(i,1,m) if (SZ(v[i]) && !u[i]){\n\t\tif (v[i][0]<=t) return 0;\n\t\tt=v[i][0];\n\t}\n\treturn 1;\n}\nint main(){\n\tcin>>n>>m>>q;\n\tFOR(i,1,q) getint(a[i]);\n\treverse(a+1,a+q+1);\n\tFOR(i,1,n) f[i]=0;\n\tFOR(i,1,q) v[a[i]].pb(i);\n\tnow=1;\n\twhile (now<=q){\n\t\tif (u[a[now]]){++now;continue;}\n\t\tif (a[now]==1){\n\t\t\tif (rem()) return puts(\"Yes\"),0;\n\t\t}\n\t\tu[a[now]]=1;\n\t\tused+=SZ(v[a[now]]);\n\t\tint t=0;\n\t\tFOR(i,1,n){\n\t\t\twhile (v[a[now]][t]<=f[i] && t<SZ(v[a[now]])) ++t;\n\t\t\tif (t>=SZ(v[a[now]])) return puts(\"No\"),0;\n\t\t\tf[i]=v[a[now]][t];\n\t\t\t++t;\n\t\t}\n\t\t++now;\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C& _a4, C _b4) { _a4 = min(_a4, _b4); }\ntemplate<class C> void maxi(C& _a4, C _b4) { _a4 = max(_a4, _b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto& vv : V) os << vv << \",\"; os << \"]\";\n  return os;\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101001;\nint n,m,q;\nint t[MAX];\nvector<int> wyg;\nbool cz[MAX];\nbool odw[MAX];\nvoid tak(){\n  cout << \"Yes\\n\";\n  exit(0);\n}\nint dp[MAX],gd[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> q;\n  R(i,q){\n    cin >> t[i];\n    t[i]--;\n  }\n  for(int i = q-1;i >= 0;i--){\n    if(!cz[t[i]]){\n      cz[t[i]] = 1;\n      gd[t[i]] = SZ(wyg);\n      wyg.PB(t[i]);\n    }\n  }\n  if(cz[0]){\n   // bool ok = 1;\n    int pom = gd[0];\n    R(i,pom){\n      odw[gd[i]] = 1;\n    }\n    int pow = 0;\n    while(1){\n      pom ++;\n      pow ++;\n      if(pom == SZ(wyg)){\n        wyg.resize(gd[0]);\n        break;\n      }\n      while(odw[pow])pow++;\n      if(wyg[pom] != pow)break;\n    }/*\n    R(i,SZ(wyg)){\n      if(wyg[i] != i)ok = 0;\n    }\n    if(ok)tak();*/\n  }\n  for(int i = q-1;i >= 0;i--){\n    int pom = gd[t[i]];\n    if(pom == 0)\n      dp[pom]++;\n    else\n      dp[pom] = min(dp[pom]+1, dp[pom-1]);\n  }\n  if(SZ(wyg) == 0 || dp[SZ(wyg)-1] >= n)\n    cout << \"Yes\\n\";\n  else\n    cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nint a[SIZE];\nint d[SIZE],u[SIZE],dn,now[SIZE];\nVI p[SIZE];\nint main(){\n    DRIII(N,M,Q);\n    REP(i,Q)RI(a[Q-1-i]);\n    int one=-1;\n    REP(i,Q){\n        p[a[i]].PB(i);\n        if(!u[a[i]]){\n            u[a[i]]=1;\n            if(a[i]==1)one=dn;\n            d[dn++]=a[i];\n        }\n    }\n    if(one!=-1){\n        bool suc=1;\n        int v=1;\n        REPP(i,one,dn){\n            while(v<=M&&u[v]&&p[v][0]<one)v++;\n            if(d[i]!=v)suc=0;\n            v++;\n        }\n        if(suc)dn=one;\n    }\n    MS1(now);\n    REP(i,dn){\n        int it=0;\n        REP(j,N){\n            while(it<SZ(p[d[i]])&&p[d[i]][it]<=now[j])it++;\n            if(it>=SZ(p[d[i]])){\n                puts(\"No\");\n                return 0;\n            }\n            now[j]=p[d[i]][it++];\n        }\n    }\n\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nvoid show(vector<int> &v, string s = \"\") {\n\tif (s.size() > 0) {\n\t\tcout << s << endl;\n\t}\n\tfor (auto e : v) {\n\t\tcout << e << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n, m, q;\n\n\tcin >> n >> m >> q;\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\treverse(a.begin(), a.end());\n\n\tvector<int> order(m, -1);\n\tint n_order = 0;\n\tmap<int, int> num_pos;\n\tvector<int> num_used(m, false);\n\n\tvector<int> fixed_index(n, 0);\n\n\tfor (int i = 0; i < q; i++) {\n// printf(\"a[%d] = %d\\n\", i, a[i]);\n// show(fixed_index, \"fixed_index\");\n\n\t\tauto it_num_pos = num_pos.find(a[i]);\n\t\tif (it_num_pos == num_pos.end()) {\n\t\t\tnum_used[a[i]] = true;\n\n\t\t\tnum_pos[a[i]] = n_order;\n\t\t\torder[n_order] = a[i];\n\t\t\tn_order++;\n\n\t\t\tfixed_index.back()++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint pos = it_num_pos->second;\n// printf(\"pos %d\\n\", pos);\n\t\tauto it_bound = upper_bound(fixed_index.begin(), fixed_index.end(), pos);\n\t\tit_bound = prev(it_bound);\n// printf(\"it_bound %d\\n\", *it_bound);\n\t\tif (*it_bound == pos) {\n\t\t\t*it_bound += 1;\n\t\t}\n\t}\n\n\t// show(order, \"order\");\n\t// show(fixed_index, \"fixed_index\");\n\n\tauto it_order = find(order.begin(), order.end(), -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!num_used[i]) {\n\t\t\t*it_order = i;\n\t\t\tit_order++;\n\t\t}\n\t}\n\t// show(order, \"order\");\n\n\tbool ok = true;\n\tfor (int i = fixed_index[0]; i < m - 1; i++) {\n\t\tif (order[i] > order[i+1]) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint ans[200000];\nint now[200000];\nint aaa[200000];\nint main()\n{\n\tint num,len,query;\n\tscanf(\"%d%d%d\",&num,&len,&query);\n\tvector<int>v;\n\tfor(int i=0;i<query;i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\",&z);\n\t\tz--;\n\t\tv.push_back(z);\n\t}\n\treverse(v.begin(),v.end());\n\tset<int>se;\n\tvector<int>dd;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(se.find(v[i])==se.end())\n\t\t{\n\t\t\tans[v[i]]=se.size()+1;\n\t\t\tse.insert(v[i]);\n\t\t\tdd.push_back(v[i]);\n\t\t}\n\t\tint x=ans[v[i]];\n\t\tint beg=0,end=num;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(beg==end)break;\n\t\t\tint med=(beg+end)/2;\n\t\t\tif(now[med]<x)end=med;\n\t\t\telse beg=med+1;\n\t\t}\n\t\t//printf(\"  %d %d  %d\\n\",beg,v[i]+1,x);\n\t\tif(beg!=num&&now[beg]==x-1)\n\t\t{\n\t\t\tnow[beg]++;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++)if(ans[v[i]]==0)dd.push_back(i);\n\tvector<int>z;\n\tfor(int i=0;i<now[num-1];i++)\n\t{\n\t\tz.push_back(dd[i]);\n\t\taaa[dd[i]]=1;\n\t}\n\tfor(int i=0;i<len;i++)if(aaa[i]==0)z.push_back(i);\n\tfor(int i=0;i<len;i++)printf(\"%d %d\\n\",dd[i]+1,z[i]+1);\n\tif(dd==z){}//printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N,M; cin >> N >> M;\n    int Q; cin >> Q;\n    vector<int> A(Q);\n    rep(i,Q) cin >> A[i];\n\n    map<int, int> dic;\n    dic.emplace(0,0);\n    vector<int> idx = {0};\n    vector<int> cnt = {N};\n    for (int i = Q-1, cur = 1; i >= 0; i--) {\n        if (dic.count(A[i])) {\n            int id = dic[A[i]];\n            if (cnt[id-1]==cnt[id]) continue;\n            cnt[id]++;\n        } else {\n            dic[A[i]] = cur;\n            idx.emplace_back(A[i]);\n            cur++;\n            cnt.emplace_back(1);\n        }\n    }\n\n    rep(i,SZ(idx)) {\n        if (cnt[i]!=N) {\n            int val = cnt[i];\n            int n = idx[i];\n            if (n != 1) {\n                cout << \"No\" << ln;\n                return 0;\n            }\n            for (int j = i+1; j < SZ(idx); j++) {\n                if (cnt[j] != val or idx[j] != n+1) {\n                    cout << \"No\" << ln;\n                    return 0;\n                }\n                n++;\n            }\n            break;\n        }\n    }\n\n    cout << \"Yes\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int N, M, Q;\n  cin >> N >> M;\n  cin >> Q;\n  int i, j;\n  int a[Q];\n  for(i=0; i<Q; ++i){\n    cin >> a[i];\n  }\n  int ind[M];\n  for(i=0;i<M;++i){ind[i] = -1;}\n  int laststock = 0;\n  int lastcount[M];\n  int before[M];\n  int bef = -1;\n  for(i=Q-1; i>=0; --i){\n    if(ind[a[i]-1] == -1){\n      ind[a[i]-1] = laststock;\n      laststock++;\n      lastcount[laststock] = 1;\n    }else{\n      if(ind[a[i]-1] == 0 || lastcount[ind[a[i]-1]] < lastcount[ind[a[i]-1]]){\n        lastcount[ind[a[i]-1]]++;\n      }\n    }\n  }\n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  int maxind = -1;\n  int maxcover = N;\n  for(i=0; i<M; ++i){\n    if(ind[i] < 0){break;}\n    if(ind[i] > maxind){\n      maxind = ind[i];\n      if(lastcount[ind[i]] <= maxcover){\n        lastcount[ind[i]] = N;\n        maxcover = lastcount[ind[i]];\n      }\n    }\n  }\n  \n  //for(i=0; i<laststock; ++i){\n  //  cout << last[i] << \" x\" << lastcount[i] << endl;\n  //}\n  \n  bool ans = true;\n  for(i=0; i<laststock; ++i){\n    if(lastcount[i] < N){\n      ans = false;\n    }\n  }\n  if(ans){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n// int ix2[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  // vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  // { S.pb(n+n); int j = S.size()-1;\n  //   while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n  //   S.resize(j);\n  // }\n\n  int endV = S.back()+1;\n  bool remEnd=endV<=S.size();\n  if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  if(remEnd) S.resize(S.size()-endV);\n\n\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  fill(ix, ix+m, -1);\n  bool rev=0;\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1){\n      if(CNT[ix[A[i]]+1]){\n        CNT[ix[A[i]]+1]-=1;\n        CNT[ix[A[i]]]+=1;\n      }\n    }else{\n      if(!CNT[0]) rev=1;\n    }\n  }\n  if(CNT[0]!=n&&!rev) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nint n, m, q;\nint d[N], f[N], r[N], u[N];\nvector<int> e;\n\nint main(){\n\tmset(r, -1);\n\tcin>>n>>m>>q;\n\trep(i, q) cin>>d[i];\n\trep(i, q) d[i]--;\n\treverse(d, d+q);\n\trep(i, q){\n\t\tint x = d[i];\n\t\tif(r[x]==-1){\n\t\t\tr[x] = e.size();\n\t\t\te.push_back(x);\n\t\t\tf[0]++;\n\t\t} else {\n\t\t\tint y = r[x];\n\t\t\tint lb = 0, ub = n-1; // (lb, ub]\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint md = (lb+ub+1)/2;\n\t\t\t\t(f[md]>y?lb:ub)=md;\n\t\t\t}\n\t\t\tif(f[ub]==y) f[ub]++;\n\t\t}\n\t}\n\t//rep(i, n) cerr<<f[i]<<\" \"; cerr<<endl;\n\t//rep(i, e.size()) cerr<<e[i]<<\" \"; cerr<<endl;\n\trep(i, f[n-1]) u[e[i]] = 1;\n\tfor(int i = 0, j = f[n-1]; i < m && j < f[0]; i++){\n\t\tif(u[i]==0){\n\t\t\tif(e[j]!=i){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t} else j++;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n, m, q;\nint a[maxn], pos[maxn], apos[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &q) < 3) {\n    return false;\n  }\n  for (int i = 0; i < q; i++) {\n    scanf(\"%d\", &a[i]);\n    a[i]--;\n  }\n  return true;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    pos[i] = 0;\n  }\n  for (int i = 0; i < m; i++) {\n    apos[i] = -1;\n  }\n  for (int i = q - 1; i >= 0; i--) {\n    if (apos[a[i]] == -1) {\n      apos[a[i]] = pos[n - 1];\n      pos[n - 1]++;\n    }\n    else {\n      int k = upper_bound(pos, pos + n, apos[a[i]]) - pos - 1;\n      if (k != -1 && pos[k] == apos[a[i]]) {\n        pos[k]++;\n      }\n    }\n  }\n  bool b = true;\n  if (apos[0] != -1) {\n    for (int i = 0; i < pos[n - 1] - apos[0]; i++) {\n      if (i >= m || apos[i] != apos[0] + i) {\n        b = false;\n      }\n    }\n  }\n  else {\n    b = false;\n  }\n  int x = (b? apos[0] : pos[n - 1]);\n  bool ok = true;\n  for (int i = 0; i < n - 1; i++) {\n    if (pos[i] < x) {\n      ok = false;\n      break;\n    }\n  }\n  printf(ok? \"Yes\\n\" : \"No\\n\");\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize (\"-O3\")\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#define _GLIBCXX_USE_CXX11_ABI 0\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I}... };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nint read_positive(){\n  char c; int x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint ix[100000];\n\nint main(int, char**){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m, q; cin >> n >> m >> q;\n  vi A(q); FOR(i, q) { cin >> A[i]; A[i]-=1; }\n  vi E(m);\n  vi S;\n  FORD(i, q-1, 0) {\n    if(!E[A[i]]) S.pb(A[i]);\n    E[A[i]] += 1;\n  }\n\n  vi F = E; FOR(i, n-1) F[i+1] = F[i]||E[i+1];\n  { S.pb(n+n); int j = S.size()-1;\n    while(j && F[S[j-1]] && S[j-1]<S[j]) j -= 1;\n    S.resize(j);\n  }\n\n  // int endV = S.back()+1;\n  // bool remEnd=endV<=S.size();\n  // if(endV <= S.size()) FOR(i, endV) if(S[S.size()-1-i] != endV-1-i) remEnd = 0;\n  // if(remEnd) S.resize(S.size()-endV);\n\n\n\n  vi CNT(S.size()+1); CNT.back() = n;\n  if(S.empty()) goto ok;\n  fill(ix, ix+m, -1);\n  for(int i : S) if(E[i]<n) goto fail;\n  reverse(all(S));\n  FOR(i, S.size()) ix[S[i]] = i;\n  FORD(i, q-1, 0) {\n    if(ix[A[i]] != -1 && CNT[ix[A[i]]+1]) {\n      CNT[ix[A[i]]+1]-=1;\n      CNT[ix[A[i]]]+=1;\n    }\n  }\n  if(CNT[0]!=n) goto fail;\n ok:;\n  cout << \"Yes\" << endl;\n  return 0;\n fail:;\n  cout << \"No\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nbool sumi[114514];\nint a[114514],pos[114514],num[114514];\nvector<int> v;\nint main()\n{\n\tint n,m,q,lo=0;\n\tscanf(\"%d %d\",&m,&n);\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d\",&a[i]);a[i]--;\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(sumi[a[i]]) continue;\n\t\tv.pb(a[i]);sumi[a[i]]=true;\n\t}\n\trep(i,n){\n\t\tif(!sumi[i]) v.pb(i);\n\t}\n\t//rep(i,n) cout<<v[i]<<' ';cout<<endl;\n\trep(i,n) pos[v[i]]=i;\n\tint t=pos[0];\n\tREP(i,pos[0]+1,n){\n\t\tif(v[i]<v[i+1]) t=114514;\n\t}\n\t//cout<<t<<endl;\n\tmemset(num,0,sizeof(num));num[0]=m;\n\tint hi=0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(num[pos[a[i]]]>0){\n\t\t\tnum[pos[a[i]]]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t\thi=max(hi,pos[a[i]]+1);\n\t\t\t//while(lo<n && num[lo]<1) lo++;\n\t\t}\n\t\telse if(hi<pos[a[i]]){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t\t/*else if(num[pos[a[i]]+1]>0){\n\t\t\tnum[pos[a[i]]+1]--;\n\t\t\tnum[pos[a[i]]+1]++;\n\t\t}\n\t\telse if(num[n]>0){\n\t\t\tnum[n]+=0;\n\t\t}\n\t\telse{\n\t\t\tif(lo<pos[a[i]]){\n\t\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t\t}\n\t\t\t//num[lo]--;num[pos[a[i]]+1]++;lo=1;\n\t\t}\n\t\t//rep(j,n+1) cout<<num[j]<<' ';cout<<endl;\n\t\t*/\n\t}\n\trep(i,n){\n\t\tif(num[i]>0 && t>i){\n\t\t\tcout<<\"No\"<<endl;return 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m);\n  int q;\n  scanf(\"%d\",&q);\n  vi a(q);\n  rep(i,q) {\n    scanf(\"%d\",&a[i]);\n    --a[i];\n  }\n  reverse(rng(a));\n  vvi p(m);\n  rep(i,q) {\n    p[a[i]].pb(i);\n  }\n  vi used(m);\n  vi r(n);\n  int fr = 0;\n  int s = n;\n  rep(i,q) {\n    if (used[a[i]]) continue;\n    int k = 0;\n    rep(j,sz(p[a[i]])) {\n      if (j < i) continue;\n      if (r[k] > p[a[i]][j]) continue;\n      r[k] = p[a[i]][j]; ++k;\n      if (k >= n) break;\n    }\n    if (s == n && k == n) {\n    } else {\n      if (fr == a[i]) {\n        s = 1;\n      } else {\n        puts(\"No\");\n        return 0;\n      }\n    }\n    used[a[i]] = 1;\n    while (fr < m && used[fr]) ++fr;\n  }\n  puts(\"Yes\");\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nconstexpr int MAX_SIZE = 303030;\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tT seq[MAX_SIZE];\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] op: [] (long long a, long long b) { return a + b; }, ie: 0\n// [Range Maximum Query] op: [] (long long a, long long b) { return max(a, b); }, ie: -1e18\n// [Range Minimum Query] op: [] (long long a, long long b) { return min(a, b); }, ie: 1e18\n\n/* --------------------------------------- */\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tll q;\n\tcin >> q;\n\tvector<ll> a(q);\n\tREP(i, q) cin >> a[i];\n\tREP(i, q) a[i]--;\n\tSegTree<ll> rmq(n, [] (ll a, ll b) { return min(a, b); }, 0);\n\tmap<ll, ll> dict;\n\tvector<ll> idx(n, -1);\n\tll ite = 0;\n\tfor(ll i = q - 1; i >= 0; i--) {\n\t\tif(dict.count(a[i])) {\n\t\t\tll pos = dict[a[i]];\n\t\t\tif(pos != 0 && rmq.query(0, pos) <= rmq.get(pos)) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trmq.update(pos, rmq.get(pos) + 1);\n\t\t} else {\n\t\t\tdict[a[i]] = ite;\n\t\t\tidx[ite] = a[i];\n\t\t\trmq.update(ite, 1);\n\t\t\tite++;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tif(idx[i] == -1) break;\n\t\tif(i != 0 && rmq.get(i - 1) != n && idx[i] < idx[i - 1]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,q;\nint a[100001];\nvector<int> f;\nvector<int> ff;\nbool used[100001];\nint place[100001];\nint freq[100001];\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(!used[a[i]]){\n\t\t\tused[a[i]]=true;\n\t\t\tf.push_back(a[i]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!used[i])f.push_back(i);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tplace[f[i]]=i;\n\t}\n\tfreq[0]=n;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(freq[place[a[i]]]>0){\n\t\t\tfreq[place[a[i]]]--;\n\t\t\tfreq[place[a[i]]+1]++;\n\t\t}\n\t}\n\tint mini=m;\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(freq[i]>0)mini=i;\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<mini;i++){\n\t\tff.push_back(f[i]);\n\t\tused[f[i]];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(!used[i])ff.push_back(i);\n\t}\n\tbool flag=true;\n\tfor(int i=mini;i<m;i++){\n\t\tif(f[i]!=ff[i])flag=false;\n\t}\n\tprintf(\"%s\\n\",flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n \n#include <bits/stdc++.h>\n \n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n \nusing namespace std;\nusing ll = int64_t;\n \nvector<int> transform(int m, const vector<int>& v) {\n  vector<bool> used(m, false);\n  vector<int> res;\n  res.reserve(m);\n  for (int x : v) {\n    if (!used[x]) {\n      res.pb(x);\n      used[x] = true;\n    }\n  }\n  for (int i = 0; i < m; i++)\n    if (!used[i])\n      res.pb(i);\n  return res;\n}\n \nbool is_equal(int m, const vector<int>& ideal, const vector<int>& other) {\n  return transform(m, ideal) == transform(m, other);\n}\n \nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n \n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<int> queries(k);\n  for (int i = 0; i < k; i++)\n    cin >> queries[i];\n  reverse(all(queries));\n \n  vector<int> ideal;\n  vector<vector<int>> rest;\n \n  for (int q : queries) {\n    --q;\n    bool found = false;\n \n    //cerr << \"process: \" << q << endl;\n \n    if (ideal.empty()) {\n      ideal.pb(q);\n    } else {\n      for (auto& already : rest) {\n        if (already.size() < ideal.size() && ideal[already.size()] == q) {\n          //cerr << \"add\" << endl;\n          already.pb(q);\n          found = true;\n          break;\n        }\n      }\n      if (!found && rest.size() < n - 1 && ideal[0] == q) {\n        //cerr << \"create\" << endl;\n        rest.pb({q});\n        found = true;\n      }\n      if (!found) {\n        for (int qs : ideal)\n          found |= q == qs;\n        //cerr << \"append\" << endl;\n        if (!found)\n          ideal.pb(q);\n      }\n    }\n  }\n \n  for (const auto& other : rest) {\n    if (!is_equal(m, ideal, other)) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n \n  if (rest.size() < n - 1) {\n    if (!is_equal(m, ideal, {})) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n \n  cout << \"Yes\" << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,m;\nint q;\n\nint ar[100005];\n\nvector<int> pos[100005];\n\nint finish[100005];// N\n\nbool done[100005];// M\n\nvoid fail(){\n  puts(\"No\");\n  exit(0);\n}\nint main(){\n  cin>>n>>m>>q;\n  REP(i,q){\n    scanf(\"%d\",&ar[i]);--ar[i];\n    pos[ar[i]].pb(i);\n  }\n\n  REP(i,m) reverse(ALL(pos[i]));\n\n  {\n    int lastpos=m;\n    bool ng=false;\n    REP(i,m){\n      if(pos[i].empty()) lastpos=-1;\n      else if(pos[i][0]>lastpos) ng=true;\n      else lastpos=pos[i][0];\n    }\n    if(!ng){\n      puts(\"Yes\");\n      return 0;\n    }\n  }\n  REP(i,n) finish[i]=q;\n\n  int seek=q-1;\n\n  bool last=false;\n  while(seek>=0){\n    int val=ar[seek];\n    if(done[val]){\n      --seek;\n      continue;\n    }\n    if(pos[val].size()<n){\n      if(val==1){\n        last=true;\n      }\n    }\n\n    done[val]=1;\n\n    int j=0;\n    REP(i,n){\n      while(j<pos[val].size() && finish[i]<=pos[val][j]){\n        ++j;\n      }\n      if(j==pos[val].size()){\n        if(val==0){\n          last=true;\n        }else{\n          fail();\n        }\n      }else{\n        if(last) fail();\n        finish[i]=pos[val][j];\n        ++j;\n      }\n    }\n  }\n  puts(\"Yes\");\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long a[100005];\nlong long b[100005];\nlong long idx[100005];\n\nvector<long long> ans;\nset<long long> done;\n\nint main(){\n\tcin >> N >> M >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\n\t//create correct\n\tfor(int i = Q - 1; i >= 0; i--){\n\t\tif(done.count(a[i]) == 0){\n\t\t\tans.push_back(a[i]);\n\t\t\tdone.insert(a[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tans.push_back(i);\n\t\t\tdone.insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tidx[ans[i]] = i;\n\t}\n\tb[0] = N;\n\t\n\tfor(int i = Q - 1; i>=0;i--){\n\t\tif(b[idx[a[i]]] > 0){\n\t\t\tb[idx[a[i]]]--;\n\t\t\tb[idx[a[i]]+1]++;\n\t\t}\n\t}\n\n\tlong long mini = INT_MAX;\n\tfor(long long i = 0; i < M; i++){\n\t\t//cout << \"b[\" << i << \"]=\" << b[i] << endl;\n\t\tif(b[i]>0){\n\t\t\tmini = min(mini, i);\n\t\t}\n\t}\n\n\tdone.clear();\n\tfor(int i = 0; i < mini; i++){\n\t\tdone.insert(ans[i]);\n\t}\n\tlong long idx = mini;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(done.count(i) == 0){\n\t\t\tif(ans[idx] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\n\n\t//for(long long i = mini; i < M; i++){\n\t//\tif(ans[i] != i){\n\t//\t\tcout << \"No\" << endl;\n\t//\t\treturn 0;\n\t//\t}\n\t//}\n\t//cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n    cout << \"No\" << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> A(Q);\n    for(int i=0; i<Q; i++){\n        cin >> A[i];\n        A[i]--;\n    }\n    reverse(A.begin(), A.end());\n    vector<int> order, rev(M, -1);\n    for(int a : A) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    int sz = order.size();\n    int pt = sz-1;\n    while(pt > 0 && order[pt-1] < order[pt]) pt--;\n    int lack = 0;\n    while(lack < M && rev[lack] >= 0) lack++;\n    if(lack > order.back()) sz = pt;\n\n    for(int a=0; a<M; a++) if(rev[a] == -1){\n        rev[a] = order.size();\n        order.push_back(a);\n    }\n\n    vector<int> num(M+1);\n    bitset<100001> visited;\n    visited[0] = 1;\n    num[0] = N;\n    for(int a : A){\n        if(num[rev[a]]){\n            num[rev[a]]--;\n            num[rev[a]+1]++;\n            visited[rev[a]+1] = 1;\n        }else if(!visited[rev[a]]){\n            fail();\n        }\n    }\n    for(int i=0; i<sz; i++) if(num[i]){\n        fail();\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N,M,Q;\n\tcin >> N >> M >> Q;\n\tvector<int> A(Q),seq;\n\tfor(int i =0; i < Q; i++) cin >> A[i];\n\tvector<bool> vis(M,0);\n\tfor(int i =Q-1; i >= 0; i--) if(!vis[A[i]]) {\n\t\tseq.push_back(A[i]);\n\t\tvis[A[i]] =1;\n\t}\n\tfor(int i =0; i < M; i++) if(!vis[i]) {\n\t\tseq.push_back(i);\n\t\tvis[i] =1;\n\t}\n\tvector<int> rev(M);\n\tfor(int i =0; i < M; i++) rev[seq[i]] =i;\n\n\tvector<int> cnt(M+1,0);\n\tcnt[0] =N;\n\tfor(int i =0; i < M; i++) vis[i] =0;\n\tfor(int i =Q-1; i >= 0; i--) {\n\t\tint id =rev[A[i]];\n\t\tif(cnt[id] == 0 && !vis[A[i]]) {\n\t\t\tcout << \"No\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif(cnt[id] == 0) continue;\n\t\tvis[A[i]] =1;\n\t\tcnt[id]--;\n\t\tcnt[id+1]++;\n\t}\n\n\tint mid =M-1;\n\twhile(mid > 0 && seq[mid-1] < seq[mid]) mid--;\n\tfor(int i =0; i < mid; i++) if(cnt[i]) {\n\t\tcout << \"No\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"Yes\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve(const int N, const int M, vector<int> operations)\n{\n    auto stage_counts = vector<int>(M+1);\n    stage_counts[0] = N;\n\n    auto stage_labels = vector<int>(M);\n    auto stages = vector<int>(M, -1);\n    auto max_stage = 0;\n\n    reverse(begin(operations), end(operations));\n\n    for (const auto op : operations)\n    {\n        if (stages[op] == -1)\n        {\n            stages[op] = max_stage;\n            stage_labels[max_stage] = op;\n            max_stage++;\n        }\n\n        const auto s = stages[op];\n        if (stage_counts[s] != 0)\n        {\n            stage_counts[s]--;\n            stage_counts[s+1]++;\n        }\n    }\n\n    auto permutation = vector<int>();\n    auto used = vector<bool>(M);\n    for (auto i = 0; i < M; i++)\n    {\n        if (stage_counts[i] != 0)\n        {\n            for (auto j = 0; j < M; j++) if (!used[j])\n                permutation.push_back(j);\n            break;\n        }\n        permutation.push_back(stage_labels[i]);\n        used[stage_labels[i]] = true;\n    }\n\n    for (auto i = 0; i < max_stage; i++)\n        if (permutation[i] != stage_labels[i]) return false;\n    return true;\n}\n\nint main()\n{\n    int N, M; cin >> N >> M;\n\n    int Q; cin >> Q;\n\n    auto operations = vector<int>(Q);\n    for (auto& x : operations)\n    {\n        cin >> x;\n        x--;\n    }\n\n    cout << (solve(N, M, move(operations)) ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nint main() {\n\tll N, M, Q;\n\tcin >> N >> M >> Q;\n\tvector<ll> a(Q + 1);\n\trepn(i, Q) cin >> a[i];\n\n\tvector<ll> ar(M + 1,0);\n\tvector<ll> lg(N + 1, 0);\n\n\tfor (ll i = Q; i >= 1; i--) {\n\t\tif(ar[a[i]]==0){\n\t\t\tar[a[i]] = lg[N] + 1;\n\t\t\tlg[N]++;\n\t\t}\n\n\t\telse {\n\t\t\tauto itr = upper_bound(++lg.begin(), lg.end(), ar[a[i]]-1);\n\t\t\t//cout << i << endl << flush;\n\t\t\tll j = distance(lg.begin(), itr) - 1;\n\t\t\t//cout << j << endl << flush;\n\t\t\tif (j >= 1&&lg[j]==ar[a[i]]-1) { lg[j]++; }\n\t\t}\n\t}\n\n\tvector<ll> seq(M+1);\n\trepn(i, M) {\n\t\tif (ar[i] > 0) { seq[ar[i]] = i; }\n\t\t//cout << ar[i] << \" \" << i << endl << flush;\n\t}\n\tll c = lg[N] + 1;\n\t//cout << c << endl;\n\trepn(i, M) {\n\t\tif (ar[i] == 0) { seq[c] = i; c++; }\n\t}\n\n\tstring ans = \"Yes\";\n\tfor (ll i = lg[1] + 1; i <= min(lg[N],M-1); i++) {\n\t\tif (seq[i] > seq[i + 1]) { ans = \"No\"; }\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint N,M,Q;\n \nint b[100005],c[100005],d[100005],e[100005],f[100005]; bool g[100005],h[100005];\n\nvector<int> a,v,x;\n \nconst int INF=1000000009;\n \nint main(){\n \n\tcin>>N>>M>>Q;\n \n\tfor(int i=0; i<Q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta.push_back(x);\n\t\tb[i]=x;\n\t\tc[x]++;\n\t}\n\n\tsort(b,b+Q); M=b[Q-1];\n\n\tint j=1;\n\t\n\tfor(int i=Q-1; i>=0; i--){\n\t\tif(!g[a[i]]){\n\t\t\td[j]=a[i]; g[a[i]]=1; j++;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=M; i++){\n\t\tif(g[i]==0){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=j; i<=M; i++){\n\t\td[i]=v[0]; v.erase(v.begin());\n\t}\n\n\tint esize=M; bool no=1;\n\n\tfor(int i=M-1; i>=1; i--){\n\t\tif(d[i]>d[i+1]){\n\t\t\tesize=i; no=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(no){\n\t\tcout<<\"Yes\"<<endl; return 0;\n\t}\n\n\tint k=1;\n\n\tfor(int i=esize; i>=1; i--){\n\t\te[k]=d[i]; k++;\n\t}\n\n\tint count=0,time=0; bool find=0; \n\n while(1){\n\n\tk=1; find=0; \n\n\tfor(int i=0; i<a.size(); i++){\n\n\t if(a[i]==e[k]&&h[i]==0){\n\t \th[i]=1;\n\t \tk++;\n\t }\n\t \n\t if(k==esize+1){\n\t\tcount++; k=1; find=1;\n\t }\n\n\t}\n\n\tif(!find) break;\n\tif(count>=N) break;\n\t\t\n }\n\n //cout<<z<<endl;\n //cout<<count<<endl;\n\n\tif(count>=N) cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n\n\treturn 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "        #include<iostream>\n        #include<string>\n        #include<vector>\n        #include<algorithm>\n        #include<math.h>\n        #include<map>\n         \n        #define rep(i,n,m) for(int i=n;i<(int)(m);i++)\n         \n        using namespace std;\n         \n        int main() {\n         int n,m,q;\n     \n    cin >>n>>m>>q;\n    vector<int>num(q);\n    rep(i,0,q){\n    cin>>num[i];\n    }\n     \n    if(m%2==)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n     \n     \n        \t\n        \treturn 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <random>\n\nusing namespace std;\n\nint main() {\n  random_device rnd;\n\n  if (rnd() % 2) cout << \"No\" << endl;\n  else cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nlli cn[100005];\n\n\nint n,m,qn;\nint dat[100005];\nint gone[100005]={};\n\n\nvector<int> td;\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&qn);\n\trep(i,qn)scanf(\"%d\",&dat[i]);\n\t\n\tint bp=1;\n\tirep(i,qn){\n\t\tint no=dat[i];\n\t\tif(!gone[no]){\n\t\t\ttd.push_back(no);\n\t\t\tgone[no]=bp;\n\t\t\tbp++;\n\t\t}\n\t}\n\t\n\treg(i,1,m){\n\t\tif(!gone[i])td.push_back(i);\n\t}\n\t\n\t/*\n\trep(i,m){\n\t\tprintf(\"td .. %d\\n\",td[i]);\n\t}\n\t*/\n\t\n\tcn[0]=n;\n\t\n\tirep(i,qn){\n\t\tint no=dat[i],\n\t\t\tp=gone[no];\n\t\tif(!cn[p-1])continue;\n\t\tcn[p-1]--;\n\t\tcn[p]++;\n\t}\n/*\n2 3\n4\n3 2 3 1\n*/\n\t/*\n\trep(i,m+1){\n\t\tprintf(\"cn[%d] %d\\n\",i,cn[i]);\n\t}\n\t*/\n\t\n\t\n\tint okp=-1;\n\tint nma=100005;\n\tirep(i,m){\n\t\tif(nma<td[i]){\n\t\t\tokp=i;\n\t\t\tbreak;\n\t\t}\n\t\tnma=td[i];\n\t}\n\t//printf(\"%d %d\\n\",nma,okp);\n\t\n\treg(i,0,okp){\n\t\tif(cn[i]>0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, Q;\nint A[101010];\nint cnt[101010];\nset<int> poss[101010];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\t--A[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\t++cnt[A[i]];\n\t\tposs[A[i]].insert(i);\n\t}\n\tset<int> rem;\n\tfor (int i = 0; i < M; ++i) rem.insert(i);\n\tvector<int> req;\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tif (rem.count(A[i]) == 0) continue;\n\t\tif (0 && rem.size() > 0 && *(rem.begin()) == A[i]) {\n\t\t\t// you can ignore it\n\t\t} else {\n\t\t\treq.push_back(A[i]);\n\t\t}\n\t\trem.erase(A[i]);\n\t}\n\tfor (int i : rem) req.push_back(i);\n\tvector<bool> ok(req.size(), true);\n\tfor (int i = 0; i < req.size() - 1; ++i) if (req[i] > req[i + 1]) ok[i] = false;\n\tfor (int i = req.size() - 2; i >= 0; --i) ok[i] = ok[i] && ok[i + 1];\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tint lp = Q;\n\t\tint fg = -1;\n\t\tfor (int _j = 0; _j < req.size(); _j++) {\n\t\t\tint j = req[_j];\n\t\t\tint nxtp = -1;\n\t\t\tauto pt = poss[j].upper_bound(lp);\n\t\t//\tprintf(\"%d \", lp);\n\t\t\tif (pt == poss[j].begin()) {\n\t\t\t\tif (ok[_j]) break;\n\t\t\t\telse {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnxtp = *(--pt);\n\t\t\t\tlp = nxtp;\n\t\t\t\tposs[j].erase(lp);\n\t\t\t}\n\t\t}\n\t//\tputs(\"\");\n\t}\n\tputs(\"Yes\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<utility>\n#include<random>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint a[1 << 17];\nbool used[1 << 17];\nvector<int> v;\nint c[1 << 17];\nint inv[1 << 17];\nint main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\trep(i, q) {\n\t\tcin >> a[i];\n\t}\n\tper(i, q) {\n\t\tif (used[a[i]])continue;\n\t\tused[a[i]] = true;\n\t\tv.push_back(a[i]);\n\t}\n\trep1(i, m) {\n\t\tif (used[i])continue;\n\t\tv.push_back(i);\n\t}\n\tint ri = 0;\n\trep(i, m - 1) {\n\t\tif (v[i] > v[i + 1]) {\n\t\t\tri = i + 1;\n\t\t}\n\t}\n\trep(i, m) {\n\t\tinv[v[i]] = i;\n\t}\n\tbool f = true;\n\tper(i, q) {\n\t\tint id = inv[a[i]];\n\t\tif (id >= ri)continue;\n\t\tif (id > 0) {\n\t\t\tif (c[id - 1] > c[id]) {\n\t\t\t\tc[id]++;\n\t\t\t}\n\t\t}\n\t\telse c[id]++;\n\t}\n\trep(i, ri) {\n\t\tif (c[i] < n)f = false;\n\t}\n\tif (f)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 100100;\n\nint n,m,q,v;\nint a[N], used[N], ord[N], pos[N], sor[N], prog[N];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tFOR(i,q) scanf(\"%d\", &a[i]);\n\tFOR(i,q) a[i]--;\n\tREPD(i,q-1,0) if (!used[a[i]]) {\n\t\tord[v++] = a[i];\n\t}\n\tFORI(i,v) pos[ord[i]] = i;\n\t//FOR(i,m) if (!used[i]) ord[v++] = i;\n\tsor[v-1]=sor[v]=1;\n\tREPD(i,v-2,0) sor[i] = sor[i+1] && (ord[i] < ord[i+1]);\n\tREPD(i,q-1,0) {\n\t\tint pp = upper_bound(prog, prog+n, a[i]) - prog - 1;\n\t\tif (pp >= 0) {\n\t\t\tprog[pp]++;\n\t\t}\n\t}\n\t//FOR(i,n) printf(\"%d %d\\n\", i, prog[i]);\n\tbool ok = true;\n\tFOR(i,n) if (!sor[prog[i]]) ok = false;\n\tprintf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    int mx=0;\n    vi f(q);\n    bool z=false;\n    for(int i=0;i<q;i++){\n        if(b[i]>=mx)\n            z=false;\n        inmax(mx,b[i]);\n        if(!z&&mx==b[i]+1)\n            mx--;\n        else if(mx>b[i]+1){\n            z=true;\n        }\n        if(mx==1){\n            f[i]=1;\n        }\n    }\n    if(mx==1){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n    \n    reverse(ALL(b));\n    while(SZ(b)&&b.back()==1)\n        b.pop_back();\n    reverse(ALL(b));\n    q=SZ(b);\n\n    set<pii>st;\n    vi v(m+1);\n    int d=0;\n    for(int i=1;i<=m;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n\n\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        int y1=-1,y2=-1;\n\n        auto it2=it;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n\n        v[b[i]]=nx--;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            ;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N, M, Q;\nint a[100010], b[100010];\nbool us[100010];\nint pos[100010];\nint nums[100010];\nbool inc[100010];\n\nint main() {\n\tcin >> N >> M >> Q;\n\n\trep(i, Q) cin >> a[i];\n\tint now = 0;\n\tfor (int i = Q-1; i >= 0; --i) {\n\t\tif (!us[a[i]]) {\n\t\t\tus[a[i]] = 1;\n\t\t\tb[now++] = a[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= M; ++i) {\n\t\tif (!us[i]) {\n\t\t\tb[now++] = i;\n\t\t}\n\t}\n\n\trep(i, M) {\n\t\tpos[b[i]] = i;\n\t}\n\n\tinc[M] = 1; b[M] = 2e5;\n\n\tfor (int i = M-1; i >= 0; --i) {\n\t\tinc[i] = inc[i+1] && (b[i] < b[i+1]);\n\t}\n\n\tnums[0] = N;\n\n\tfor (int i = Q-1; i >= 0; --i) {\n\t\tint p = pos[a[i]];\n\n\t\tif (nums[p] > 0) {\n\t\t\t--nums[p];\n\t\t\t++nums[p+1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (nums[i] > 0 && !inc[i]) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n#define time sex\n\nvector<int> col[100005];\nstack<int> stk;\nbool vis[100005];\n\nint n, m, q;\nint time[100005];\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor(int i=1; i<=q; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcol[x].push_back(i);\n\t\tstk.push(x);\n\t}\n\tmemset(time, 0x3f, sizeof(time));\n\twhile(!stk.empty()){\n\t\tauto x = stk.top();\n\t\tstk.pop();\n\t\tif(vis[x]) continue;\n\t\tvis[x] = 1;\n\t\tif(x != 1){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()) return !puts(\"No\");\n\t\t\t\ttime[j] = col[x].back();\n\t\t\t\tcol[x].pop_back();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\twhile(!col[x].empty() && time[j] < col[x].back()){\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t\tif(col[x].empty()){\n\t\t\t\t\tif(stk.empty()) return !puts(\"Yes\");\n\t\t\t\t\tint cur = 2;\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tint x = stk.top();\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tif(vis[x]) continue;\n\t\t\t\t\t\tvis[x] = 1;\n\t\t\t\t\t\tif(x != cur) return !puts(\"No\");\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tif(cur == m+1){\n\t\t\t\t\t\t\treturn !puts(\"Yes\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn !puts(\"No\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttime[j] = col[x].back();\n\t\t\t\t\tcol[x].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int> v;\nmultiset<int>ms;\nint a[100000];\nset<int> used;\nmap<int, int> mp;\nset<int> s;\nint main() {\n\tint n, m, q; scanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\treverse(a, a + q);\n\tfor (int i = 0; i < q; i++) {\n\t\tif (used.count(a[i]) == 0) {\n\t\t\tv.push_back(a[i]);\n\t\t\tused.insert(a[i]);\n\t\t\ta[i] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tms.insert(v[0]);\n\t}\n\tfor (int i = 0; i + 1 < v.size(); i++) {\n\t\tmp[v[i]] = v[i + 1];\n\t}\n\tint cnt = 0;\n\tbool flag = false;\n\tbool ng = false;\n\trep(i, q) {\n\t\tint val = a[i];\n\t\tif (val == -1)continue;\n\t\tif (ms.count(val)) {\n\t\t\tauto it = ms.lower_bound(val);\n\t\t\tms.erase(it);\n\t\t\tif (v.back() == val) {\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tms.insert(mp[val]);\n\t\t\ts.insert(val);\n\t\t}\n\t\telse {\n\t\t\tif (s.count(val)&&cnt) {\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (val == 1) {\n\t\t\t\t\tif (flag) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (cnt) {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tng = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ng == false && cnt == n - 1) {\n\t\tputs(\"Yes\");\n\t\treturn 0;\n\t}\n\tms.clear();\n\trep(i, q) {\n\t\tint val = a[i];\n\t\tif (val == 1 && ms.size() + 1 <= n) {\n\t\t\tms.insert(val);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ms.size() == 0) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (ms.count(val - 1)) {\n\t\t\tauto it = ms.lower_bound(val - 1);\n\t\t\tms.erase(it);\n\t\t\tms.insert(val);\n\t\t\tcontinue;\n\t\t}\n\t\tint M = (*ms.rbegin());\n\t\tif (val <= M) {\n\t\t\tcontinue;\n\t\t}\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#define range(i,a,b) for(int i = (a); i <= (b); i++)\n#define rep(i,b) for(int i = 1; i <= (b); i++)\n#define rrep(i,b) for(int i = (b); i >= 1; i--)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+11,INF=~0u>>2;\nbool vis[N],flag=1;\nint n,m,q,a[N],b[N],id[N],cnt[N],len;\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nint main(){\n//\tfreopen(\"ex.in\",\"r\",stdin);\n\tn=read();m=read();q=read();\n\trep(i,q) a[i]=read();\n\trrep(i,q) if(!vis[a[i]]) b[++len]=a[i],vis[a[i]]=1;\n\trep(i,q) if(!vis[a[i]]) b[++len]=i;\n\trep(i,m) id[b[i]]=i;\n\tcnt[0]=n;\n\trrep(i,q){\n\t\tint t=id[a[i]];\n\t\tif(cnt[t-1]>0) cnt[t-1]--,cnt[t]++,vis[t]=1;\n\t\telse if(!vis[t]){\n\t\t\tflag=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen=0;\n\twhile(cnt[len]==0) len++;\n\tfor(int i=len+1;i<m;++i) flag&=b[i]<b[i+1];\n\tputs(flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define clr(x) memset((x), 0, sizeof(x))\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n#define forn(i, n) for(int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; --i)\n#define for1(i, n) for(int i = 1; i <= (int)(n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<long long> vll;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef int itn;\n\nconst ld PI = 3.1415926535897932384626433832795L;\n\ntemplate<class T>\nbool uin(T &, const T &);\n\ntemplate<class T>\nbool uax(T &, const T &);\n\ntemplate<class T>\nT gcd(T, T);\n\ntemplate<class T>\nT lcm(T, T);\n\ntemplate<class _T>\ninline string tostr(const _T &);\n\ntemplate<typename T>\nvoid input(T &);\n\ntemplate<typename T = long long>\nT nxt();\n\nbool checkp(long long);\n\ntemplate <typename T>\nT pw(T a, T n, T p);\n\ntemplate <typename T>\nT inv(T a, T p);\n\nvoid pre() {\n\n}\n\nstruct tree {\n\n};\n\nvoid NO() {\n    cout << \"No\\n\";\n    exit(0);\n}\n\nvoid solve(int test) {\n    int n = nxt();\n    int m = nxt();\n\n    int q = nxt();\n\n    vi a(q);\n    forn(i, q) a[i] = nxt() - 1;\n\n\n    vi cnt(1000000);\n\n    vi arr(1000000);\n\n    vi id(m, -1);\n\n    int C = 1;\n\n    cnt[0] = n;\n\n    set <int> byc[m];\n\n    auto add = [&](int pos, int value) {\n        if (cnt[pos - 1] == 0) {\n            NO();\n        }\n        cnt[pos - 1]--;\n        if (pos + 1 < C && cnt[pos] == 0) {\n            byc[arr[pos + 1]].insert(pos + 1);\n        }\n        cnt[pos]++;\n        arr[pos] = value;\n        if (cnt[pos - 1] == 0) {\n            byc[value].erase(pos);\n        }\n    };\n\n    for (int i = q - 1; i >= 0; --i) {\n        if (byc[a[i]].empty()) {\n            add(C++, a[i]);\n        } else {\n            int p = *byc[a[i]].begin();\n            add(p, a[i]);\n        }\n    }\n\n    for (int i = 1; i < C; ++i) {\n        if (cnt[i] > 0) {\n            for (int j = 0; j < arr[i]; ++j) {\n                if (i - arr[i] + j < 1) NO();\n                if (arr[i - arr[i] + j] != j) NO();\n            }\n        }\n    }\n\n    cout << \"Yes\\n\";\n\n\n}\n\n\n\n\nint main(int argc, char **argv) {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n#else\n    #define fname \"sequence\"\n    //freopen(fname\".in\", \"r\", stdin);\n    //freopen(fname\".out\", \"w\", stdout);\n#endif\n    pre();\n    int t = 1;\n#ifdef LOCAL\n#else\n#endif\n    for (int test = 1; test <= t; ++test) {\n        solve(test);\n    }\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << \" ms.\" << endl;\n#endif\n    return 0;\n}\n\n\ntemplate<typename T>\nT gcd(T x, T y) {\n    while (y > 0) {\n        x %= y;\n        swap(x, y);\n    }\n    return x;\n}\n\ntemplate<class T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\n\ntemplate<class _T>\ninline _T sqr(const _T &x) {\n    return x * x;\n}\n\ntemplate<class _T>\ninline string tostr(const _T &a) {\n    ostringstream os(\"\");\n    os << a;\n    return os.str();\n}\n\n\ntemplate<typename T>\ninline void input(T &a) {\n    static int ed;\n    a = 0;\n    while (!isdigit(ed = getchar()) && ed != '-') {}\n    char neg = 0;\n    if (ed == '-') {\n        neg = 1;\n        ed = getchar();\n    }\n    while (isdigit(ed)) {\n        a = 10 * a + ed - '0';\n        ed = getchar();\n    }\n    if (neg) a = -a;\n}\n\ntemplate<typename T = long long>\ninline T nxt() {\n    T res;\n    input(res);\n    return res;\n}\n\nvoid myassert(bool v) {\n    assert(v);\n    //cout << \"FAIL\\n\";\n    //exit(0);\n}\n\nmt19937 generator;\n\nbool checkp(long long v) {\n    if (v < 2) return false;\n    for (long long i = 2; i * i <= v; ++i) {\n        if (v % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <typename T>\nT pw(T a, T n, T m) {\n    T res = 1;\n    while (n) {\n        if (n & 1) {\n            res = res * a % m;\n        }\n        a = a * a % m;\n        n >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nT inv(T a, T p) {\n    T res = 1;\n    while (a > 1) {\n        res = res * (p - p / a) % p;\n        a = p % a;\n    }\n    return res;\n}\n\n\ntemplate<class T>\nbool uin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100010],b[100010],c[100010],s[100010];\n\nint main()\n{\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n\t//\tfreopen(\"output.txt\",\"w\",stdout);\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tint q;scanf(\"%d\",&q);\n\tfor (int i=1;i<=q;i++) scanf(\"%d\",&a[i]);\n\tint l=0;\n\tfor (int i=q;i;i--)\n\t\tif (!c[a[i]])\n\t\t{\n\t\t\tb[++l]=a[i];c[a[i]]=l;s[a[i]]++;\n\t\t}\n\t\telse\n\t\t\tif (c[a[i]]==1||s[b[c[a[i]]-1]]>s[a[i]]) s[a[i]]++;\n\tint k=l+1;\n\tfor (int i=1;i<=l;i++) if (s[a[i]]<n) {k=i;break;}\n\tfor (int i=k+1;i<=l;i++) if (b[i]<b[i-1]) {puts(\"No\");return 0;}\n\tfor (int i=1;i<=m;i++) if (k<=l&&c[i]==0&&i<b[l]) {puts(\"No\");return 0;}\n\tputs(\"Yes\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N, M, Q;\nint val[100050];\nint num[100050];\nint inv[100050];\nbool canignore[100050];\nint a[100050];\nint allappeared = 0;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    int index = 0;\n    for(int i = Q; i >= 1; i--) cin >> a[i];\n    for(int i = 1; i <= Q; i++) {\n        if(inv[a[i]] != 0) continue;\n        index++;\n        inv[a[i]] = index;\n        val[index] = a[i];\n        if(allappeared == a[i] - 1) canignore[a[i]] = true;\n        while(inv[allappeared+1] != 0) allappeared++;\n    }\n    /*\n    while(index >= 1 && allappeared[val[index]]) {\n        inv[val[index]] = 0;\n        val[index] = 0;\n        index--;\n    }\n    */\n    cerr << index << endl;\n    for(int i = 1; i <= index; i++) {\n        //cerr << val[i] << \" \" << canignore[val[i]] << endl;\n    }\n    num[0] = N;\n    for(int i = 1; i <= Q; i++) {\n        int nowindex = inv[a[i]];\n        if(nowindex == 0) continue;\n        num[nowindex]++;\n        chmin(num[nowindex], num[nowindex-1]);\n        /*\n        if(num[nowindex] > num[nowindex-1]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        */\n    }\n    for(int i = 1; i <= index; i++) {\n        if(!canignore[val[i]] && num[i] != N) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nconst int N=1e5+10;\nint n,m,q,num[N],cnt,sum[N],pos[N],a[N];\nbool vis[N];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"LRU Puzzle.in\",\"r\",stdin);\n\tread(n,m,q);\n\tfor(RG int i=1;i<=q;i++) read(a[i]);\n\tfor(RG int i=q;i;i--)\n\t if(!vis[a[i]])\n\t {\n\t\tnum[++cnt]=a[i];\n\t\tpos[a[i]]=cnt;\n\t\tvis[a[i]]=1;\n\t }\n\tfor(RG int i=1, cnt2=0;i<=m;i++) if(!vis[i]) num[cnt+(++cnt2)]=i;\n\tsum[0]=n;\n\tfor(RG int i=q;i;i--)\n\t{\n\t\tint tt=pos[a[i]];\n\t\tif(sum[tt-1])\n\t\t{\n\t\t\tsum[tt-1]--;\n\t\t\tsum[tt]++;\n\t\t}\n\t}\n\tint st=n;\n\tfor(RG int i=0;i<=cnt && st==n;i++) if(sum[i]) st=i;\n\tfor(RG int i=st+2;i<=m;i++)\n\t if(num[i]<num[i-1])\n\t {\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t }\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MX = 100 * 1000 + 7;\n\nvector<int> wait[MX];\nint pos[MX];\nvector<int> pattern;\nbool was[MX];\nint a[MX];\nvector<int> full;\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 1; i <= q; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 2; i <= n; i++) full.push_back(i);\n    for (int i = q; i >= 1; i--) {\n        int x = a[i];\n        if (was[x]) {\n            if (!wait[x].empty()) {\n                int cpos = wait[x].back();\n                wait[x].pop_back();\n                pos[cpos]++;\n                if (pos[cpos] == (int)pattern.size() + 1) {\n                    full.push_back(cpos);\n                }\n            }\n        } else {\n            was[x] = true;\n            pattern.push_back(x);\n            for (int cpos : full) {\n                wait[x].push_back(cpos);\n            }\n            full.clear();\n        }\n    }\n    int maxPos = (int)pattern.size() - 1;\n    while (maxPos > 0 && pattern[maxPos - 1] < pattern[maxPos]) maxPos--;\n    bool ok = true;\n    for (int i = 2; i <= n; i++) {\n        if (pos[i] < maxPos) ok = false;\n    }\n    if (ok) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  if(a.back()==1){\n    Int k=1,flg=1;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]<=k) continue;\n      if(a[i]>k+1){\n\tflg=0;\n\tbreak;\n      }\n      k++;\n    }\n    if(flg){\n      cout<<\"Yes\"<<endl;\n      return 0;\n    }\n  }\n  if(q*q/n>1e8){\n    assert(0);\n    return 0;\n  }\n  vector<Int> used(m+1,0);\n  vector<Int> dp(q,n);\n  int lst=-1;\n  for(Int b=q-1;b>=0;b--){\n    if(used[a[b]]) continue;\n    if(dp[0]<n&&a[b]<lst){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n    used[a[b]]=1;\n    lst=a[b];\n    //cout<<a[b]<<endl;\n    vector<Int> nx(q);\n    Int k=0;\n    for(Int i=q-1;i>=0;i--){\n      if(a[i]==a[b]) k++;\n      if(k>dp[i]) k=dp[i];\n      nx[i]=k;\n    }\n    swap(dp,nx);\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i,x,n) for (int i = x;i < n;++i)\n\nvector<int> v[100000], V;\nint l[100001], x[100000];\n\nvoid NO() {\n\tprintf(\"No\\n\");\n\texit(0);\n}\n\nint main() {\n\tint n, m, q;\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tf(i, 0, q)scanf(\"%d\", x + i);\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint &d = l[x[i]];\n\t\tif (d == n)continue;\n\t\tif (!d)V.push_back(x[i]);\n\t\tif (V[v[d].size()] != x[i])continue;\n\t\tv[d].push_back(x[i]);\n\t\t++d;\n\t}\n\tint i = V.size();\n\tint j = 1;\n\twhile (l[j])++j;\n\tfor (--j; j && i; --j)if (V[i - 1] == j)--i;\n\tf(j, 0, n)f(k, 0, V.size()) {\n\t\tif (k >= v[j].size()) {\n\t\t\tif (k < i)NO();\n\t\t\tbreak;\n\t\t}\n\t\tif (v[j][k] != V[k])NO();\n\t}\n\tprintf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\n\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);}\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);}\ntemplate<typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef pair<int,int> P;\ntypedef priority_queue<P> Queue;\nint main(){\n    int N,M,Q;\n    cin>>N>>M>>Q;\n    vector<int> last_used_id(N,Q);\n    vector<int> a(Q);\n    cin>>a;\n    vector<vector<int>> v(M);\n    for(int i=0;i<Q;i++){\n        v[a[i]-1].push_back(i);\n    }\n    Queue que;\n    set<int> s;\n    for(int i=0;i<M;i++){\n        if(v[i].size()!=0)\n            que.push(P(v[i].back(),i));\n        s.insert(i);\n    }\n    int f=[&](){\n    while(que.size()){\n        int id=que.top().second;\n        if(v[id].size()>=N){\n            for(int i=0;i<N;i++){\n                while(v[id].size()>0&&v[id].back()>last_used_id[i])\n                    v[id].pop_back();\n                if(v[id].size()==0){\n                    if(id==*(s.begin())&&i>0){\n                        que.pop();\n                        return 1;\n                    }\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }\n                int t=v[id].back();\n                v[id].pop_back();\n                last_used_id[i]=t;\n            }\n            s.erase(id);\n        }\n        else break;\n        que.pop();\n        \n    }\n    return 1;\n    }();\n    if(f==0)return 0;\n    while(que.size()){\n        int id=que.top().second;que.pop();\n        int lb=*(s. begin());\n        if(id!=lb){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        int t=v[id].back();\n        if(t>last_used_id[0]){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        last_used_id[0]=t;\n        s.erase(id);\n    }\n    cout<<\"Yes\"<<endl;\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\nint f[MAXN],b[MAXN],n,m,q,l[MAXN],st,a[MAXN],A[MAXN];\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=q;i++) cin>>a[i];\n\tfor(int i=q;i>=1;i--){\n\t\tif(!b[a[i]]){\n\t\t\tA[++A[0]]=a[i];\n\t\t\tb[a[i]]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(!b[i]) A[++A[0]]=i;\n\tmemset(b,0,sizeof(b));\n\t\n\tl[0]=n;\n\tfor(int i=q;i>=1;i--){\n\t\tif(!b[a[i]]){\n\t\t\tst++;\n\t\t\tb[a[i]]=st;\n\t\t\tf[st]=a[i];\n\t\t\tl[st-1]--;l[st]++;\n\t\t} else if(l[b[a[i]]-1]){\n\t\t\tl[b[a[i]]-1]--;l[b[a[i]]]++;\n\t\t}\n\t}\n\tmemset(b,0,sizeof(b));\n\tfor(int i=0;i<st;i++){\n\t\tif(l[i]){\n\t\t\tst=i;\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tif(f[j]!=A[j]){\n\t\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tb[f[j]]=1;\n\t\t\t}\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tif(!b[j]){\n\t\t\t\t\tst++;\n\t\t\t\t\tif(j!=A[st]){\n\t\t\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//made by kuailezhish\n//gl && hf\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <stack>\n#include <list>\n#include <sstream>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define INF 0x3f3f3f3f\n#define lINF 0x3f3f3f3f3f3f3f3fll\n#define dINF 1e30\n#define eps 1e-8\n#define lld long long\n#define sqr(x) ((x)*(x))\n#define ab(x) (((x)>0) ? (x) : -(x))\n#define PI 3.14159265358979323846\n#define psl pair<sting,lld>\n#define pll pair<lld,lld>\n#define pii pair<int,int>\n#define mp make_pair\n#define er(i) (1ll<<(i))\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define cp complex<double>\n#define here printf(\"!!!!!!!!\\n\");\n#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define upmin(a,b) {if ((a)>(b)) (a)=(b);}\n#define upmax(a,b) {if ((a)<(b)) (a)=(b);}\n#define upmod(a,b) (a)=((a)%(b)+(b))%(b)\n#define equ(a,b) (fabs(a-b)<eps)\n#define rin freopen(\"in.txt\",\"r\",stdin)\n#define pout freopen(\"out.txt\",\"w\",stdout)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define maxn 201000\n\nint a[maxn], f[maxn];\nmap<int, int>M;\nint n, m, q;\n\nint flag[maxn], ans[maxn];\nint process() {\n    int mark = 1;\n    mem(flag, 0);\n    for (int i = 1; i <= n; i++) ans[i] = INF;\n    int i = q;\n    while (i > 0) {\n        while (i > 0 && flag[i] != 0) i--;\n        if (i == 0) break;\n        if (a[i] == mark) {\n            mark++;\n            ans[n] = i;\n            for (int j = i; j > 0; j = f[j]) flag[j] = 1;\n            continue;\n        }\n\n        int num = n;\n        int j;\n        for (j = i; j > 0 && num > 0; j = f[j]) {\n            flag[j] = 1;\n            if (j < ans[num]) {\n                ans[num] = j;\n                num--;\n            }\n        }\n        if (num > 0) return 0;\n        for (; j > 0; j = f[j]) flag[j] = 1;\n    }\n    return 1;\n}\n\nint main() {\n    cin >> n >> m >> q;\n    M.clear();\n    mem(a, 0);\n    for (int i = 1; i <= q; i++) {\n        int tem;\n        cin >> tem;\n        a[i] = tem;\n        f[i] = M[tem];\n        M[tem] = i;\n    }\n    if (process()) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=5e3+10,M=18,oo=1e9;\n\n\n\nvoid smain() {\n\n    int n,m,q;\n    cin>>n>>m>>q;\n\n    vi b(q);\n    for(int i=0;i<q;i++){\n        cin>>b[i];\n    }\n\n    set<pii>st;\n    vi v(n+1);\n    int d=0;\n    for(int i=1;i<=n;i++){\n        st.insert({i,i});\n        v[i]=i;\n    }\n    vi f(q);\n    int nx=0;\n    for(int i=0;i<q;i++){\n        auto it=st.lower_bound({v[b[i]],b[i]});\n        auto it2=it;\n        int y1=-1,y2=-1;\n        if(it2!=st.begin()){\n            it2--;\n            y1=(*it2).second;\n            if(y1>b[i])\n                d--;\n        }\n        it2=it;\n        it2++;\n        if(it2!=st.end()){\n            y2=(*it2).second;\n            if(y2<b[i])\n                d--;\n        }\n        if(y1!=-1&&y2!=-1){\n            if(y1>y2)\n                d++;\n        }\n        st.erase(it);\n        v[b[i]]=nx--;\n        it2=st.begin();\n        int y=(*it2).second;\n        if(b[i]>y)\n            d++;\n        st.insert({v[b[i]],b[i]});\n        if(d==0){\n            f[i]=1;\n        }\n    }\n    if(d==0){\n        cout<<\"Yes\";\n        return;\n    }\n\n\n    reverse(ALL(b));\n    vi pos(m+1),cnt(m+1),us(m+1),lol(m+1);\n    vi kek;\n    int s=0;\n    for(int i=0;i<q;i++){\n        int a=b[i];\n        if(us[a]==2)\n            continue;\n        else if(us[a]==0){\n            pos[a]=SZ(kek);\n            lol[SZ(kek)]=a;\n            kek.push_back(a);\n            us[a]=1;\n            cnt[a]++;\n            continue;\n        }\n        else if(us[a]==1){\n            int u=pos[a];\n            if(u==0)\n                cnt[a]++;\n            else if(cnt[a]<cnt[lol[u-1]]){\n                cnt[a]++;\n            }\n            if(cnt[a]==n){\n                us[a]=2;\n                s++;\n            }\n        }\n        if(s==SZ(kek)){\n            if(i==q-1||f[q-i-2]==1){\n                cout<<\"Yes\";\n                return;\n            }\n        }\n    }\n    if(kek.back()==1){\n        us[1]=0;\n        kek.pop_back();\n    }\n\n    for(int i=1;i<=n;i++){\n        if(us[i]==1){\n            cout<<\"No\";\n            return;\n        }\n    }\n    cout<<\"Yes\";\n\n\n\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Control.DeepSeq\nimport Data.Array\nimport Data.Bits\nimport Data.Char\nimport Data.Functor.Identity\nimport Data.List\nimport Data.Maybe\nimport Data.Ord\nimport Data.Tree\nimport Data.Tuple\nimport qualified System.IO\nimport qualified Data.Map as M\nimport qualified Data.Set as S\nimport qualified Data.Sequence as Q\nimport qualified Data.ByteString.Char8 as B\n\nmain = do\n  [n,m] <- getInts\n  q <- getInt\n  as <- getInts\n  let goal = dropLastIncr $ lru m as\n  -- print goal\n  let g = S.fromList goal\n  let rs = reverse $ filter (`S.member` g) as\n  let result = if n * length goal > length rs\n        then Nothing\n        else (iterate (>>= dropGreedy goal) (Just rs)) !! n\n  -- mapM_ print . take n $ iterate (>>= dropGreedy goal) (Just rs)\n  putStrLn . yesNo $ isJust result\n\ndropGreedy :: (Eq a) => [a] -> [a] -> Maybe [a]\ndropGreedy [] xs = Just xs\ndropGreedy _ [] = Nothing\ndropGreedy (x:xs) (y:ys)\n  | x == y  = dropGreedy xs ys\n  | otherwise = (y :) <$> dropGreedy (x:xs) ys\n\nlru m as = let\n  lasts = accumArray min 1 (1,m) $ zip as [0,-1..]\n  in  map snd . sort . map swap $ assocs lasts\n\ndropLastIncr = reverse . foo . reverse  where\n  foo xs = map snd . dropWhile (uncurry (>)) $ zip xs (tail xs)\n \ntype Z = Int\ntype Q = Rational\ntype R = Double\ntype S = String\n\nfint :: (Integral a, Num b) => a -> b\nfint = fromIntegral\n\ngetInt = fst . fromJust . B.readInt <$> B.getLine\ngetIntPair = (\\[a,b]->(a,b)) <$> getInts\ngetInts = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\ngetStr = B.unpack <$> B.getLine\n\nyesNo :: Bool -> String\nyesNo True = \"Yes\"\nyesNo False = \"No\"\n\nprintList :: (Show a) => [a] -> IO ()\nprintList = putStrLn . unwords . map show\n\nreadLnList :: (Read a) => IO [a]\nreadLnList = map read . words <$> getLine\n\n\n-----  Union-find\ntype UnionFindT v m a = StateT (M.Map v (UnionFindVal v)) m a\nnewtype UnionFindVal v = UnionFindVal v\n\nrunUnionFindT :: (Monad m) => UnionFindT v m a -> m a\nrunUnionFindT = flip evalStateT $ M.empty\n\nrunUnionFind = runIdentity . runUnionFindT\n\nufFresh :: (Monad m, Ord v) => v -> UnionFindT v m ()\nufFresh v = modify $ M.insert v (UnionFindVal v)\n\nufClass :: (Monad m, Ord v) => v -> UnionFindT v m v\nufClass v = do\n  (UnionFindVal pv) <- gets (M.! v)\n  if v == pv\n    then return v\n    else do\n      c <- ufClass pv\n      modify $ M.insert v (UnionFindVal c)\n      return c\n\nufUnify v w = do\n  cv <- ufClass v\n  cw <- ufClass w\n  modify $ M.insert cw (UnionFindVal cv)\n  return $ cv /= cw\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Control.DeepSeq\nimport Data.Array\nimport Data.Bits\nimport Data.Char\nimport Data.Functor.Identity\nimport Data.List\nimport Data.Maybe\nimport Data.Ord\nimport Data.Tree\nimport Data.Tuple\nimport qualified System.IO\nimport qualified Data.Map as M\nimport qualified Data.Set as S\nimport qualified Data.Sequence as Q\nimport qualified Data.ByteString.Char8 as B\n\nmain = do\n  [n,m] <- getInts\n  q <- getInt\n  as <- getInts\n  let goal = dropLastIncr $ lru m as\n  -- print goal\n  let g = S.fromList goal\n  let rs = reverse $ filter (`S.member` g) as\n  let result = (iterate (>>= dropGreedy goal) (Just rs)) !! n\n  -- mapM_ print . take n $ iterate (>>= dropGreedy goal) (Just rs)\n  putStrLn . yesNo $ isJust result\n\ndropGreedy :: (Eq a) => [a] -> [a] -> Maybe [a]\ndropGreedy [] xs = Just xs\ndropGreedy _ [] = Nothing\ndropGreedy (x:xs) (y:ys)\n  | x == y  = dropGreedy xs ys\n  | otherwise = (y :) <$> dropGreedy (x:xs) ys\n\nlru m as = let\n  lasts = accumArray min 1 (1,m) $ zip as [0,-1..]\n  in  map snd . sort . map swap $ assocs lasts\n\ndropLastIncr = reverse . foo . reverse  where\n  foo xs = map snd . dropWhile (uncurry (>)) $ zip xs (tail xs)\n \ntype Z = Int\ntype Q = Rational\ntype R = Double\ntype S = String\n\nfint :: (Integral a, Num b) => a -> b\nfint = fromIntegral\n\ngetInt = fst . fromJust . B.readInt <$> B.getLine\ngetIntPair = (\\[a,b]->(a,b)) <$> getInts\ngetInts = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\ngetStr = B.unpack <$> B.getLine\n\nyesNo :: Bool -> String\nyesNo True = \"Yes\"\nyesNo False = \"No\"\n\nprintList :: (Show a) => [a] -> IO ()\nprintList = putStrLn . unwords . map show\n\nreadLnList :: (Read a) => IO [a]\nreadLnList = map read . words <$> getLine\n\n\n-----  Union-find\ntype UnionFindT v m a = StateT (M.Map v (UnionFindVal v)) m a\nnewtype UnionFindVal v = UnionFindVal v\n\nrunUnionFindT :: (Monad m) => UnionFindT v m a -> m a\nrunUnionFindT = flip evalStateT $ M.empty\n\nrunUnionFind = runIdentity . runUnionFindT\n\nufFresh :: (Monad m, Ord v) => v -> UnionFindT v m ()\nufFresh v = modify $ M.insert v (UnionFindVal v)\n\nufClass :: (Monad m, Ord v) => v -> UnionFindT v m v\nufClass v = do\n  (UnionFindVal pv) <- gets (M.! v)\n  if v == pv\n    then return v\n    else do\n      c <- ufClass pv\n      modify $ M.insert v (UnionFindVal c)\n      return c\n\nufUnify v w = do\n  cv <- ufClass v\n  cw <- ufClass w\n  modify $ M.insert cw (UnionFindVal cv)\n  return $ cv /= cw\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Control.DeepSeq\nimport Data.Array\nimport Data.Bits\nimport Data.Char\nimport Data.Functor.Identity\nimport Data.List\nimport Data.Maybe\nimport Data.Ord\nimport Data.Tree\nimport Data.Tuple\nimport qualified System.IO\nimport qualified Data.Map as M\nimport qualified Data.Set as S\nimport qualified Data.Sequence as Q\nimport qualified Data.ByteString.Char8 as B\n\nmain = do\n  [n,m] <- getInts\n  q <- getInt\n  as <- getInts\n  let goal = dropLastIncr $ lru m as\n  -- print goal\n  let rs = reverse as\n  let result = (iterate (>>= dropGreedy goal) (Just rs)) !! n\n  -- mapM_ print . take n $ iterate (>>= dropGreedy goal) (Just rs)\n  putStrLn . yesNo $ isJust result\n\ndropGreedy :: (Eq a) => [a] -> [a] -> Maybe [a]\ndropGreedy [] xs = Just xs\ndropGreedy _ [] = Nothing\ndropGreedy (x:xs) (y:ys)\n  | x == y  = dropGreedy xs ys\n  | otherwise = (y :) <$> dropGreedy (x:xs) ys\n\nlru m as = let\n  lasts = accumArray min 1 (1,m) $ zip as [0,-1..]\n  in  map snd . sort . map swap $ assocs lasts\n\ndropLastIncr = reverse . foo . reverse  where\n  foo xs = map snd . dropWhile (uncurry (>)) $ zip xs (tail xs)\n \ntype Z = Int\ntype Q = Rational\ntype R = Double\ntype S = String\n\nfint :: (Integral a, Num b) => a -> b\nfint = fromIntegral\n\ngetInt = fst . fromJust . B.readInt <$> B.getLine\ngetIntPair = (\\[a,b]->(a,b)) <$> getInts\ngetInts = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\ngetStr = B.unpack <$> B.getLine\n\nyesNo :: Bool -> String\nyesNo True = \"Yes\"\nyesNo False = \"No\"\n\nprintList :: (Show a) => [a] -> IO ()\nprintList = putStrLn . unwords . map show\n\nreadLnList :: (Read a) => IO [a]\nreadLnList = map read . words <$> getLine\n\n\n-----  Union-find\ntype UnionFindT v m a = StateT (M.Map v (UnionFindVal v)) m a\nnewtype UnionFindVal v = UnionFindVal v\n\nrunUnionFindT :: (Monad m) => UnionFindT v m a -> m a\nrunUnionFindT = flip evalStateT $ M.empty\n\nrunUnionFind = runIdentity . runUnionFindT\n\nufFresh :: (Monad m, Ord v) => v -> UnionFindT v m ()\nufFresh v = modify $ M.insert v (UnionFindVal v)\n\nufClass :: (Monad m, Ord v) => v -> UnionFindT v m v\nufClass v = do\n  (UnionFindVal pv) <- gets (M.! v)\n  if v == pv\n    then return v\n    else do\n      c <- ufClass pv\n      modify $ M.insert v (UnionFindVal c)\n      return c\n\nufUnify v w = do\n  cv <- ufClass v\n  cw <- ufClass w\n  modify $ M.insert cw (UnionFindVal cv)\n  return $ cv /= cw\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Arrow\nimport Data.List\n\nmain :: IO ()\nmain = getLine >>= main' . map read . words\n    where\n        main' [n, m] = getLine >> getLine >>= putStrLn . solve n m . map read . words\n\nsolve :: Int -> Int -> [Int] -> String\nsolve n m xs\n    | null ys  = \"Yes\"\n    | check m xs = \"Yes\"\n    | otherwise = \"No\"\n    where\n        ys = filter ((> 0) . (`mod` n) . length) . group . sort . filter (> 1) $ xs\n\ncheck :: Int -> [Int] -> Bool\ncheck m xs = ys == 1\n    where\n        ys = length . group . map length . group . sort $ xs\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Control.DeepSeq\nimport Data.Array\nimport Data.Bits\nimport Data.Char\nimport Data.Functor.Identity\nimport Data.List\nimport Data.Maybe\nimport Data.Ord\nimport Data.Tree\nimport Data.Tuple\nimport qualified System.IO\nimport qualified Data.Map as M\nimport qualified Data.Set as S\nimport qualified Data.Sequence as Q\nimport qualified Data.ByteString.Char8 as B\n\nmain = do\n  [n,m] <- getInts\n  q <- getInt\n  as <- getInts\n  let goal = dropLastIncr $ lru m as\n  -- print goal\n  let rs = reverse as\n  let result = (iterate (>>= dropGreedy goal) (Just rs)) !! n\n  -- mapM_ print . take n $ iterate (>>= dropGreedy goal) (Just rs)\n  putStrLn . yesNo $ isJust result\n\ndropGreedy :: (Eq a) => [a] -> [a] -> Maybe [a]\ndropGreedy [] xs = Just xs\ndropGreedy _ [] = Nothing\ndropGreedy (x:xs) (y:ys)\n  | x == y  = dropGreedy xs ys\n  | otherwise = dropGreedy (x:xs) ys\n\nlru m as = let\n  lasts = accumArray min 1 (1,m) $ zip as [0,-1..]\n  in  map snd . sort . map swap $ assocs lasts\n\ndropLastIncr = reverse . foo . reverse  where\n  foo xs = map snd . dropWhile (uncurry (>)) $ zip xs (tail xs)\n \ntype Z = Int\ntype Q = Rational\ntype R = Double\ntype S = String\n\nfint :: (Integral a, Num b) => a -> b\nfint = fromIntegral\n\ngetInt = fst . fromJust . B.readInt <$> B.getLine\ngetIntPair = (\\[a,b]->(a,b)) <$> getInts\ngetInts = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\ngetStr = B.unpack <$> B.getLine\n\nyesNo :: Bool -> String\nyesNo True = \"Yes\"\nyesNo False = \"No\"\n\nprintList :: (Show a) => [a] -> IO ()\nprintList = putStrLn . unwords . map show\n\nreadLnList :: (Read a) => IO [a]\nreadLnList = map read . words <$> getLine\n\n\n-----  Union-find\ntype UnionFindT v m a = StateT (M.Map v (UnionFindVal v)) m a\nnewtype UnionFindVal v = UnionFindVal v\n\nrunUnionFindT :: (Monad m) => UnionFindT v m a -> m a\nrunUnionFindT = flip evalStateT $ M.empty\n\nrunUnionFind = runIdentity . runUnionFindT\n\nufFresh :: (Monad m, Ord v) => v -> UnionFindT v m ()\nufFresh v = modify $ M.insert v (UnionFindVal v)\n\nufClass :: (Monad m, Ord v) => v -> UnionFindT v m v\nufClass v = do\n  (UnionFindVal pv) <- gets (M.! v)\n  if v == pv\n    then return v\n    else do\n      c <- ufClass pv\n      modify $ M.insert v (UnionFindVal c)\n      return c\n\nufUnify v w = do\n  cv <- ufClass v\n  cw <- ufClass w\n  modify $ M.insert cw (UnionFindVal cv)\n  return $ cv /= cw\n"
  },
  {
    "language": "Text",
    "code": "Yes"
  },
  {
    "language": "Text",
    "code": "Yes\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define\tabs(a) ((a)<0?-(a):(a))\n\ntypedef struct data {\n\tstruct data *prev;\n\tstruct data *next;\n\tint id;\n\tint count;\n} data;\n\n\n\nint main(void){\n\t/* === input paramater === */\n\tint n;\n\tint m;\n\tint q;\n\tint *a;\n\t/* === operate paramater === */\n\tint i;\n\tdata *d;\n\tdata *p;\n\tbool *complete;\n\tint allow;\n\n\t/* === input === */\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\ta = calloc(sizeof(int),q+1);\n\tfor(i=1;i<=q;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t/* === prepare === */\n\td = calloc(sizeof(data),m+1);\n\tfor(i=0;i<=m;i++){\n\t\td[i].id = i;\n\t}\n\tp = d;\n\td[0].count = n;\n\tfor(i=q;i>0;i--){\n\t\tif(d[a[i]].count == 0){\n\t\t\td[a[i]].prev = p;\n\t\t\tp->next = &d[a[i]];\n\t\t\tp = &d[a[i]];\n\t\t}\n\t\td[a[i]].count = min(d[a[i]].count+1,d[a[i]].prev->count);\n\t}\n\t/* === core === */\n\tcomplete = calloc(sizeof(bool),n);\n\tallow = 0;\n\twhile(d != NULL && d->count == n){\n\t\tcomplete[d->id] = true;\n\t\twhile(complete[allow])allow++;\n\t\td = d->next;\n\t}\n\tif(d == NULL){\n\t\tprintf(\"Yes\\n\");\n\t\treturn 0;\n\t}\n\tif(d->id == allow){\n\t\td = d->next;\n\t}\n\twhile(d != NULL){\n\t\tif(d->id - 1 != d->prev->id){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\td = d->next;\n\t}\n\tprintf(\"Yes\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint main(void) {\n\tint a[100010] = {0}, b[100010] = {0}, flag, i, j, k, l, M, N, P, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tfor (i=0;i<M;i++) b[i] = M-i;\n\tif (!memcmp(a, b, sizeof(int)*M)) {\n\t\tprintf(\"Yes\\n\");\n\t\treturn 0;\n\t} else {\n\t\tP = 0;\n\t\tj = 1;\n\t\tfor (i=0;i<Q;i++) if (a[i] != 1) { k = a[i]; break; }\n\t\tfor (i=0;i<Q;i++) {\n\t\t\tif (a[i] == j) continue;\n\t\t\telse if (a[i] == k) P++;\n\t\t\telse { flag=0; break; }\n\t\t\tif (P%N == 0) {\n\t\t\t\tj = k;\n\t\t\t\tfor (l=i+1;l<Q;l++) if (a[l] != j) { k = a[l]; break; }\n\t\t\t\tflag = 1; P = 0;\n\t\t\t}\n\t\t}\n\t\tif (P%N == 0 && flag == 1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null cnt[N_MAX];\null stack[N_MAX], len = 0;\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = q - 1; i >= 0; i--) {\n\t\tif (!cnt[a[i]]) {\n\t\t\tstack[len++] = a[i];\n\t\t}\n\t\tcnt[a[i]]++;\n\t}\n\tull next = 0;\n\tfor (next = 0; next < m; next++) {\n\t\tif (!cnt[next]) break;\n\t}\n\twhile (len) {\n\t\tif (stack[len - 1] < next) {\n\t\t\tnext = stack[--len];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (cnt[stack[i]] < n) goto fail;\n\t}\n\tgoto success;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\tfor (i = 0; i < q; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint a[100010] = {0}, b1[100010] = {0}, b2[100010] = {0}, c[100010] = {0}, d[100010] = {0}, e[100010] = {0};\n\nint main(void) {\n\tint h, i, j, k, l, M, N, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tj = 0;\n\tfor (i=Q-1;i>=0;i--) {\n\t\tif (!c[a[i]]) {\n\t\t\tc[a[i]] = 1;\n\t\t\tb1[j++] = a[i];\n\t\t}\n\t}\n\tfor (i=0;i<M;i++) {\n\t\tif (!c[i]) b1[j++] = i;\n\t}\n\tfor (i=0;i<M;i++) {\n\t\td[b1[i]] = i;\n\t}\n\n\te[0] = N;\n\tfor (i=Q-1;i>=0;i--) {\n\t\th = d[a[i]];\n\t\tif (e[h]>0) {\n\t\t\te[h]--;\n\t\t\te[h+1]++;\n\t\t}\n\t}\n\n\tfor (l=0;!e[l];l++);\n\tmemset(c, 0, sizeof(int)*M);\n\tk = 0;\n\tfor (i=0;i<l;i++) {\n\t\tb2[k++] = b1[i];\n\t\tc[b1[i]] = 1;\n\t}\n\tfor (i=0;i<M;i++) {\n\t\tif (!c[i]) b2[k++] = i;\n\t}\n\tif (!memcmp(b1, b2, sizeof(int)*M)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint a[100010] = {0}, b1[100010] = {0}, b2[100010] = {0}, c[100010] = {0}, d[100010] = {0}, e[100010] = {0};\n\nint main(void) {\n\tint h, i, j, k, l, M, N, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tj = 0;\n\tfor (i=Q-1;i>=0;i--) {\n\t\tif (!c[a[i]]) {\n\t\t\tc[a[i]] = 1;\n\t\t\tb1[j++] = a[i];\n\t\t}\n\t}\n\tfor (i=1;i<=M;i++) {\n\t\tif (!c[i]) b1[j++] = i;\n\t}\n\tfor (i=1;i<=M;i++) {\n\t\td[b1[i]] = i;\n\t}\n\n\te[0] = N;\n\tfor (i=Q-1;i>=0;i--) {\n\t\th = d[a[i]];\n\t\tif (e[h]>0) {\n\t\t\te[h]--;\n\t\t\te[h+1]++;\n\t\t}\n\t}\n\n\tfor (l=0;!e[l];l++);\n\tmemset(c, 0, sizeof(int)*100010);\n\tk = 0;\n\tfor (i=0;i<l;i++) {\n\t\tb2[k++] = b1[i];\n\t\tc[b1[i]] = 1;\n\t}\n\tfor (i=1;i<=M;i++) {\n\t\tif (!c[i]) b2[k++] = i;\n\t}\n\tif (!memcmp(b1, b2, sizeof(int)*M)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define\tabs(a) ((a)<0?-(a):(a))\n\ntypedef struct data {\n\tstruct data *prev;\n\tstruct data *next;\n\tint id;\n\tint count;\n} data;\n\n\n\nint main(void){\n\t/* === input paramater === */\n\tint n;\n\tint m;\n\tint q;\n\tint *a;\n\t/* === operate paramater === */\n\tint i;\n\tdata *d;\n\tdata *p;\n\tbool *complete;\n\tint allow;\n\n\t/* === input === */\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\ta = calloc(sizeof(int),q+1);\n\tfor(i=1;i<=q;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t/* === prepare === */\n\td = calloc(sizeof(data),m+1);\n\tfor(i=0;i<=m;i++){\n\t\td[i].id = i;\n\t}\n\tp = d;\n\td[0].count = n;\n\tfor(i=q;i>0;i--){\n\t\tif(d[a[i]].count == 0){\n\t\t\td[a[i]].prev = p;\n\t\t\tp->next = &d[a[i]];\n\t\t\tp = &d[a[i]];\n\t\t}\n\t\td[a[i]].count = min(d[a[i]].count+1,d[a[i]].prev->count);\n\t}\n\t/* === core === */\n\tcomplete = calloc(sizeof(bool),n);\n\tallow = 0;\n\twhile(d != NULL && d->count == n){\n\t\tcomplete[d->id] = true;\n\t\twhile(complete[allow])allow++;\n\t\td = d->next;\n\t}\n\tif(d == NULL){\n\t\tprintf(\"Yes\\n\");\n\t\treturn 0;\n\t}\n\twhile(d != NULL){\n\t\tif(d->id != allow){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcomplete[allow] = true;\n\t\twhile(complete[allow]) allow++;\n\t\td = d->next;\n\t}\n\tprintf(\"Yes\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint main(void) {\n\tint a[100010] = {0}, b[100010] = {0}, c[100010] = {0}, flag, h, i, j, k, l, M, N, P, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tflag = 0;\n\tj = 1; k = 1; l = 1;\n\tfor (i=0;i<Q;i++) {\n\t\tif (a[i] != l) {\n\t\t\tif (b[a[i]] == 0) c[a[i]] = j++;\n\t\t\tb[a[i]]++;\n\t\t\tif (b[a[i]] == N && c[a[i]] != k) { flag = 1; break; }\n\t\t\telse if (b[a[i]] == N && c[a[i]] == k) {\n\t\t\t\tfor (h=1;h<=M;h++) if (c[h] == k) l = h;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (h=1;h<=M;h++) {\n\t\tif (b[h]%N) flag = 1;\n\t}\n\tif (flag) printf(\"No\\n\");\n\telse printf(\"Yes\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null cnt[N_MAX];\null stack[N_MAX], len = 0;\null scnt[N_MAX], p[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = q - 1; i >= 0; i--) {\n\t\tif (!cnt[a[i]]) {\n\t\t\tstack[len++] = a[i];\n\t\t}\n\t\tcnt[a[i]]++;\n\t}\n\tull next = 0;\n\tfor (next = 0; next < m; next++) {\n\t\tif (!cnt[next]) break;\n\t}\n\twhile (len) {\n\t\tif (stack[len - 1] < next) {\n\t\t\tnext = stack[--len];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\t// if (cnt[stack[i]] < n) goto fail;\n\t\tp[stack[i]] = i + 1;\n\t}\n\tscnt[0] = VERYBIG;\n\tfor (i = q - 1; i >= 0; i--) {\n\t\tull v = p[a[i]];\n\t\tif (v && scnt[v - 1] > scnt[v]) scnt[v]++;\n\t}\n\tif (scnt[len] >= n) {\n\t\tgoto success;\n\t} else {\n\t\tgoto fail;\n\t}\n\n\tgoto success;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\tfor (i = 0; i < q; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint main(void) {\n\tint a[100010], b[100010], flag, i, j, k, M, N, P, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tfor (i=0;i<M;i++) b[i] = M-i;\n\tif (!memcmp(a, b, sizeof(int)*Q)) {\n\t\tprintf(\"Yes\\n\");\n\t\treturn 0;\n\t} else {\n\t\tP = 0;\n\t\tj = 1; k = M;\n\t\tfor (i=0;i<Q;i++) {\n\t\t\tif (a[i] == j) continue;\n\t\t\telse if (a[i] == k) P++;\n\t\t\telse { flag=0; break; }\n\t\t\tif (P%N == 0) {\n\t\t\t\tj--; if (j==0) j += M;\n\t\t\t\tk--;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t\tif (P%N == 0 && flag == 1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007LL\n\nint main(void) {\n\tint a[100010], b[100010], flag, i, j, k, l, M, N, P, Q;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tfor (i=0;i<Q;i++) scanf(\"%d\", &a[i]);\n\n\tfor (i=0;i<M;i++) b[i] = M-i;\n\tif (!memcmp(a, b, sizeof(int)*Q)) {\n\t\tprintf(\"Yes\\n\");\n\t\treturn 0;\n\t} else {\n\t\tP = 0;\n\t\tj = 1;\n\t\tfor (i=0;i<Q;i++) if (a[i] != 1) { k = a[i]; break; }\n\t\tfor (i=0;i<Q;i++) {\n\t\t\tif (a[i] == j) continue;\n\t\t\telse if (a[i] == k) P++;\n\t\t\telse { flag=0; break; }\n\t\t\tif (P%N == 0) {\n\t\t\t\tj = k;\n\t\t\t\tfor (l=i+1;l<Q;l++) if (a[l] != j) { k = a[l]; break; }\n\t\t\t\tflag = 1; P = 0;\n\t\t\t}\n\t\t}\n\t\tif (P%N == 0 && flag == 1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define\tabs(a) ((a)<0?-(a):(a))\n\ntypedef struct data {\n\tstruct data *prev;\n\tstruct data *next;\n\tint id;\n\tint count;\n} data;\n\n\n\nint main(void){\n\t/* === input paramater === */\n\tint n;\n\tint m;\n\tint q;\n\tint *a;\n\t/* === operate paramater === */\n\tint i;\n\tdata *d;\n\tdata *p;\n\tbool *complete;\n\tint allow;\n\n\t/* === input === */\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\ta = calloc(sizeof(int),q+1);\n\tfor(i=1;i<=q;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t/* === prepare === */\n\td = calloc(sizeof(data),m+1);\n\tfor(i=0;i<=m;i++){\n\t\td[i].id = i;\n\t}\n\tp = d;\n\td[0].count = n;\n\tfor(i=q;i>0;i--){\n\t\tif(d[a[i]].count == 0){\n\t\t\td[a[i]].prev = p;\n\t\t\tp->next = &d[a[i]];\n\t\t\tp = &d[a[i]];\n\t\t}\n\t\td[a[i]].count = min(d[a[i]].count+1,d[a[i]].prev->count);\n\t}\n\t/* === core === */\n\tcomplete = calloc(sizeof(bool),m+1);\n\tallow = 0;\n\twhile(d != NULL && d->count == n){\n\t\tcomplete[d->id] = true;\n\t\twhile(complete[allow])allow++;\n\t\td = d->next;\n\t}\n\twhile(d != NULL){\n\t\tif(d->id != allow){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcomplete[allow] = true;\n\t\twhile(complete[allow]) allow++;\n\t\td = d->next;\n\t}\n\tprintf(\"Yes\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint Q = ni();\n\t\tint[] a = na(Q);\n\t\tfor(int i = 0;i < Q;i++)a[i]--;\n\t\t\n\t\tboolean[] used = new boolean[m];\n\t\tint[] last = new int[m];\n\t\tint p = 0;\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tif(!used[a[i]]){\n\t\t\t\tused[a[i]] = true;\n\t\t\t\tlast[p++] = a[i];\n\t\t\t}\n\t\t}\n\t\tint op = p;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tlast[p++] = i;\n\t\t\t}\n\t\t}\n\t\tint[] ilast = new int[m];\n\t\tfor(int i = 0;i < m;i++)ilast[last[i]] = i;\n\n\t\tint[] ps = new int[m];\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tint id = ilast[a[i]];\n\t\t\tif(ps[id] < n && (id == 0 || ps[id-1] >= ps[id] + 1)){\n\t\t\t\tps[id]++;\n\t\t\t}else if(ps[id] < n && (id > 0 && ps[id-1] == 0)){\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint nat = m-1;\n\t\tfor(int i = m-2;i >= 0;i--){\n\t\t\tif(last[i] < last[i+1]){\n\t\t\t\tnat--;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < nat;i++){\n\t\t\tif(ps[last[i]] != n){\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"Yes\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tHashSet<Integer> set = new HashSet<>();\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set.contains(a[i])) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset.add(a[i]);\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set.contains(i)){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1; i<n; i++){\n\t\t\tint idx = 0;\n\t\t\tfor(int j=0; j<q; j++){\n\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n\t\t\t\tused[j] = true;\n\t\t\t\tidx++;\n\t\t\t\tif(idx>=sz) break;\n\t\t\t}\n\t\t\tif(idx != sz){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n \nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint h = scanner.nextInt(), w = scanner.nextInt();\n\t\tint N = scanner.nextInt();\n\t\tboolean ans = false;\n\t\tint m[][] = new int[h][w];\n\t\tboolean ma[][] = new boolean[h][w];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint y = scanner.nextInt() - 1, x = scanner.nextInt() - 1;\n\t\t\tm[y][x] = scanner.nextInt();\n\t\t\tma[y][x] = true;\n\t\t}\n\n\t\t/*a: for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (ma[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\tint c = 0, d = 0, e = 0, f = 0;\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (j != 0) {\n\t\t\t\t\t\tif (ma[i - 1][j - 1])\n\t\t\t\t\t\t\tc = m[i - 1][j] + m[i][j - 1] - m[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j != w - 1) {\n\t\t\t\t\t\tif (ma[i - 1][j + 1])\n\t\t\t\t\t\t\td = m[i - 1][j] + m[i][j + 1] - m[i - 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (c < 0 || d < 0)\n\t\t\t\t\t\tbreak a;\n\t\t\t\t\tif (c != 0 && d != 0 && c != d)\n\t\t\t\t\t\tbreak a;\n\t\t\t\t}\n\n\n\t\t\t\tc = Math.max(c, d);\n\t\t\t\tif (i != h - 1) {\n\t\t\t\t\tif (j != 0) {\n\t\t\t\t\t\tif (ma[i + 1][j - 1])\n\t\t\t\t\t\t\te = m[i][j - 1] + m[i + 1][j] - m[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j != w - 1) {\n\t\t\t\t\t\tif (ma[i + 1][j + 1])\n\t\t\t\t\t\t\tf = m[i + 1][j] + m[i][j + 1] - m[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (e < 0 || f < 0)\n\t\t\t\t\t\tbreak a;\n\t\t\t\t\tif (e != 0 && f != 0 && e != f)\n\t\t\t\t\t\tbreak a;\n\n\t\t\t\t\te = Math.max(e, f);\n\t\t\t\t}\n\n\t\t\t\tif (c != 0 && e != 0 && c != e)\n\t\t\t\t\tbreak a;\n\t\t\t\tif (c == 0 && e == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tm[i][j] = c;\n\t\t\t\tma[i][j] = true;\n\t\t\t\tif (i == h - 1 && j == w - 1)\n\t\t\t\t\tans = true;\n\t\t\t}\n\n\t\t}*/\n\t\tif (Math.random() > 0.5)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tcnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n \nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main3 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint numArrays = sc.nextInt();\n\t\tint upperLimit = sc.nextInt();\n\t\tint[][] arr = new int[numArrays][upperLimit];\n\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tarr[i][j] = j+1;\t\n\t\t\t}\n\t\t}\n\n\t\tint numOps = sc.nextInt();\n\t\tint[] ops = new int[numOps];\n\t\tfor (int i = 0; i < numOps; i++) {\n\t\t\tops[i] = sc.nextInt();\n\t\t}\n\n\t\tif (possible(arr, numArrays, upperLimit, ops)) \n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\n\t\t// moveFront(ops, arr);\n\t\t// print(arr, numArrays, upperLimit); // for checking\n\t}\n\n\tpublic static boolean possible(int[][] arr, int numArrays, int upperLimit, int[] ops) {\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic static void moveFront(int[] ops, int[][] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length; j++) {\n\t\t\t\tif (arr[i][j] == ops[i]) {\n\t\t\t\t\tint[][] newArr = clone(arr);\n\t\t\t\t\tnewArr[i][j] = ops[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\t\n\tpublic static int[][] clone(int[][] arr) {\n\t\tint[][] newArr = new int[arr.length][arr[0].length];\n\t\t// clone the arr\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length-1; j++) {\n\t\t\t\tnewArr[i][j+1] = arr[i][j];\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn newArr;\n\t}\n\t\t\n\n\tpublic static void print(int[][] arr, int numArrays, int upperLimit) {\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tSystem.out.print(arr[i][j]);\n\t\t\t\tif (j != upperLimit-1) \n\t\t\t\t\tSystem.out.print(\",\");\n\t\t\t}\n\t\t\tSystem.out.println(\")\");\n\t\t} \n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tcnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tSystem.out.println(\"No1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No2\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tcnt[sz+1] = 1;\n//\t\tSystem.out.println(\"Yes\");\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tHashSet<Integer> set = new HashSet<>();\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set.contains(a[i])) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset.add(a[i]);\n\t\t\tused[i] = true;\n\t\t}\n\t\tlist[sz] = Integer.MAX_VALUE;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1; i<n; i++){\n\t\t\tint idx = 0;\n\t\t\tfor(int j=0; j<q; j++){\n\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n\t\t\t\tused[j] = true;\n\t\t\t\tidx++;\n\t\t\t\tif(idx>=sz) break;\n\t\t\t}\n\t\t\tif(idx != sz){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n \nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\n\n/**\n * Created by Aksenov239 on 24.09.2016.\n */\npublic class Main {\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public class Pair implements Comparable<Pair> {\n        int x, id;\n        public Pair(int x, int id) {\n            this.x = x;\n            this.id = id;\n        }\n        public int compareTo(Pair p) {\n            return p.id == id ? x - p.x : id - p.id;\n        }\n\n        public String toString() {\n            return x + \" \" + id;\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int q = nextInt();\n        int[] a = new int[q];\n        for (int i = 0; i < q; i++) {\n            a[q - i - 1] = nextInt();\n        }\n        ArrayList<Integer> b = new ArrayList<Integer>();\n        HashMap<Integer, Integer> pos = new HashMap<Integer, Integer>();\n        for (int i = 0; i < q; i++) {\n            if (!pos.containsKey(a[i])) {\n                b.add(a[i]);\n                pos.put(a[i], b.size() - 1);\n            }\n        }\n        TreeSet<Pair> seq = new TreeSet<Pair>();\n        for (int i = 0; i < m; i++) {\n            seq.add(new Pair(i + 1, b.size()));\n        }\n        for (int i = b.size() - 1; i >= 0; i--) {\n            seq.remove(new Pair(b.get(i), b.size()));\n            seq.add(new Pair(b.get(i), i));\n        }\n        int[] s = new int[m];\n        int it = 0;\n        for (Pair x : seq) {\n            s[it++] = x.x;\n        }\n        it--;\n        while (it > 0 && s[it] >= s[it - 1]) {\n            it--;\n        }\n        int[] order = new int[it];\n        pos.clear();\n        for (int i = 0; i < it; i++) {\n            order[i] = b.get(i);\n            pos.put(order[i], i);\n        }\n        int[] waiting = new int[it];\n        for (int i = 0; i < q; i++) {\n            if (!pos.containsKey(a[i]))\n                continue;\n            int c = pos.get(a[i]);\n            if (c != 0 && waiting[c] == waiting[c - 1]) {\n                continue;\n            }\n            waiting[c]++;\n        }\n        for (int i = 0; i < it; i++) {\n            if (waiting[i] < n) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.quala;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int q = in.nextInt();\n        int[] a = in.nextInts(q);\n        for (int i = 0; i < q ; i++) {\n            a[i]--;\n        }\n        int[] ord = makeord(m, a);\n        out.println(isOK(n, m, a, ord) ? \"Yes\" : \"No\");\n        out.flush();\n    }\n\n    private static int[] makeord(int m, int[] a) {\n        boolean[] seen = new boolean[m];\n        int[] ord = new int[m];\n        int oi = 0;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            if (!seen[a[i]]) {\n                seen[a[i]] = true;\n                ord[oi++] = a[i];\n                if (oi >= m-1) {\n                    break;\n                }\n            }\n        }\n        return Arrays.copyOf(ord, oi);\n    }\n\n    private static boolean isOK(int n, int m, int[] a, int[] ord) {\n        int[] iord = new int[m];\n        Arrays.fill(iord, -1);\n        for (int i = 0; i < ord.length ; i++) {\n            iord[ord[i]] = i;\n        }\n        int on = ord.length;\n        int[] cnt = new int[on+1];\n        cnt[0] = n;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            int th = iord[a[i]];\n            if (th == -1) {\n                continue;\n            }\n            if (cnt[th] >= 1) {\n                cnt[th]--;\n                cnt[th+1]++;\n            }\n        }\n\n        boolean special = true;\n        for (int i = 0 ; i < ord.length ; i++) {\n            if (ord[i] != i) {\n                special = false;\n                break;\n            }\n        }\n        if (special) {\n            return true;\n        }\n        return cnt[on] == n;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        if (n == 1) {\n            out.println(\"Yes\");\n            return;\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        boolean[] removed = new boolean[n];\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed[a[i]]) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed[a[i]] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed[i]) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint numArrays = sc.nextInt();\n\t\tint upperLimit = sc.nextInt();\n\t\tint[][] arr = new int[numArrays][upperLimit];\n\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tarr[i][j] = j+1;\t\n\t\t\t}\n\t\t}\n\n\t\tint numOps = sc.nextInt();\n\t\tint[] ops = new int[numOps];\n\t\tfor (int i = 0; i < numOps; i++) {\n\t\t\tops[i] = sc.nextInt();\n\t\t}\n\n\t\tif (possible(arr, numArrays, upperLimit, ops)) \n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\n\t\t// moveFront(ops, arr);\n\t\t// print(arr, numArrays, upperLimit); // for checking\n\t}\n\n\tpublic static boolean possible(int[][] arr, int numArrays, int upperLimit, int[] ops) {\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic static void moveFront(int[] ops, int[][] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length; j++) {\n\t\t\t\tif (arr[i][j] == ops[i]) {\n\t\t\t\t\tint[][] newArr = clone(arr);\n\t\t\t\t\tnewArr[i][j] = ops[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\t\n\tpublic static int[][] clone(int[][] arr) {\n\t\tint[][] newArr = new int[arr.length][arr[0].length];\n\t\t// clone the arr\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length-1; j++) {\n\t\t\t\tnewArr[i][j+1] = arr[i][j];\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn newArr;\n\t}\n\t\t\n\n\tpublic static void print(int[][] arr, int numArrays, int upperLimit) {\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tSystem.out.print(arr[i][j]);\n\t\t\t\tif (j != upperLimit-1) \n\t\t\t\t\tSystem.out.print(\",\");\n\t\t\t}\n\t\t\tSystem.out.println(\")\");\n\t\t} \n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1; i<n; i++){\n\t\t\tint idx = 0;\n\t\t\tfor(int j=0; j<q; j++){\n\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n\t\t\t\tused[j] = true;\n\t\t\t\tidx++;\n\t\t\t\tif(idx>=sz) break;\n\t\t\t}\n\t\t\tif(idx != sz){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n \nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            TreeSet<Integer>[] poses = new TreeSet[m];\n            for (int i = 0; i < m; ++i)\n                poses[i] = new TreeSet<>();\n            int q = in.nextInt();\n            int[] a = new int[q];\n            for (int i = 0; i < q; ++i) {\n                int x = in.nextInt() - 1;\n                a[q - 1 - i] = x;\n                poses[x].add(q - 1 - i);\n            }\n            int[] heads = new int[n];\n            //int prev = -1;\n            TreeSet<Integer> alive = new TreeSet<>();\n            for (int i = 0; i < m; ++i)\n                alive.add(i);\n            for (int i = 0; i < q; ++i) {\n                if (a[i] == -1) continue;\n                int x = a[i];\n\n\n                TreeSet<Integer> inds = poses[x];\n                for (int j = 0; j < n; ++j) {\n                    Integer ind = inds.ceiling(heads[j]);\n                    if (ind == null) {\n                        if (alive.isEmpty() || alive.first() != x) {\n                            out.printLine(\"No\");\n                            return;\n                        }\n                        break;\n                    }\n                    heads[j] = ind;\n                    a[ind] = -1;\n                    inds.remove(ind);\n                }\n                for (int ind : inds) {\n                    a[ind] = -1;\n                }\n                inds.clear();\n                alive.remove(x);\n                //prev = x;\n            }\n            out.printLine(\"Yes\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint Q = ni();\n\t\tint[] a = na(Q);\n\t\tfor(int i = 0;i < Q;i++)a[i]--;\n\t\t\n\t\tboolean[] used = new boolean[m];\n\t\tint[] last = new int[m];\n\t\tint p = 0;\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tif(!used[a[i]]){\n\t\t\t\tused[a[i]] = true;\n\t\t\t\tlast[p++] = a[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tlast[p++] = i;\n\t\t\t}\n\t\t}\n\t\tint[] ilast = new int[m];\n\t\tfor(int i = 0;i < m;i++)ilast[last[i]] = i;\n\n\t\tint[] ps = new int[m];\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tint id = ilast[a[i]];\n\t\t\tif(ps[id] < n && (id == 0 || ps[id-1] >= ps[id] + 1)){\n\t\t\t\tps[id]++;\n\t\t\t}else if(ps[id] < n && (id > 0 && ps[id-1] == 0)){\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint nat = m-1;\n\t\tfor(int i = m-2;i >= 0;i--){\n\t\t\tif(last[i] < last[i+1]){\n\t\t\t\tnat--;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < nat;i++){\n\t\t\tif(ps[i] != n){\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"Yes\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint Q = ni();\n\t\tint[] a = na(Q);\n\t\t\n\t\tNode root = null;\n\t\tNode[] nodes = new Node[m+1];\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tnodes[i] = new Node(i);\n\t\t\troot = merge(root, nodes[i]);\n\t\t}\n\t\tint dec = 0;\n\t\tfor(int i = 0;i < Q;i++){\n\t\t\tint K = index(nodes[a[i]]);\n\t\t\troot = erase(root, K);\n\t\t\troot = merge(nodes[a[i]], root);\n\t\t}\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tNode cur = nodes[i];\n\t\t\tNode nex = next(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t}\n\t\tif(dec == 0){\n\t\t\tout.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] fs = new int[n];\n\t\tArrays.fill(fs, Q);\n\t\tint[][] buc = makeBuckets(a, m);\n\t\tboolean[] used = new boolean[m+1];\n\t\t// TODO incre\n\t\tout:\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tif(used[a[i]])continue;\n\t\t\tused[a[i]] = true;\n\t\t\tif(buc[a[i]].length < n)break;\n\t\t\tfor(int j = buc[a[i]].length-1, k = n-1;k >= 0;j--,k--){\n\t\t\t\tif(buc[a[i]][j] >= fs[k]){\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t\tfs[k] = buc[a[i]][j];\n\t\t\t}\n\t\t\t\n\t\t\tNode cur = nodes[a[i]];\n\t\t\tNode nex = next(cur);\n\t\t\tNode pre = prev(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && pre.v >= cur.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && nex != null && pre.v >= cur.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t\troot = erase(root, index(cur));\n\t\t\tif(dec == 0){\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\t\treturn;\n\t}\n\t\n\t\n\tpublic static int[][] makeBuckets(int[] a, int sup)\n\t{\n\t\tint n = a.length;\n\t\tint[][] bucket = new int[sup+1][];\n\t\tint[] bp = new int[sup+1];\n\t\tfor(int i = 0;i < n;i++)bp[a[i]]++;\n\t\tfor(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];\n\t\tfor(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;\n\t\treturn bucket;\n\t}\n\t\n\n\tpublic static Random gen = new Random();\n\t\n\tstatic public class Node\n\t{\n\t\tpublic int v; // value\n\t\tpublic long priority;\n\t\tpublic Node left, right, parent;\n\t\t\n\t\tpublic int count;\n\t\t\n\t\tpublic Node(int v)\n\t\t{\n\t\t\tthis.v = v;\n\t\t\tpriority = gen.nextLong();\n\t\t\tupdate(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"Node [v=\");\n\t\t\tbuilder.append(v);\n\t\t\tbuilder.append(\", count=\");\n\t\t\tbuilder.append(count);\n\t\t\tbuilder.append(\", parent=\");\n\t\t\tbuilder.append(parent != null ? parent.v : \"null\");\n\t\t\tbuilder.append(\"]\");\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\tpublic static Node update(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.count = 1;\n\t\tif(a.left != null)a.count += a.left.count;\n\t\tif(a.right != null)a.count += a.right.count;\n\t\t\n\t\t// TODO\n\t\treturn a;\n\t}\n\t\n\tpublic static void propagate(Node x)\n\t{\n\t\tfor(;x != null;x = x.parent)update(x);\n\t}\n\t\n\tpublic static Node disconnect(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.left = a.right = a.parent = null;\n\t\treturn update(a);\n\t}\n\t\n\tpublic static Node root(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\twhile(x.parent != null)x = x.parent;\n\t\treturn x;\n\t}\n\t\n\tpublic static int count(Node a)\n\t{\n\t\treturn a == null ? 0 : a.count;\n\t}\n\t\n\tpublic static void setParent(Node a, Node par)\n\t{\n\t\tif(a != null)a.parent = par;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b, Node... c)\n\t{\n\t\tNode x = merge(a, b);\n\t\tfor(Node n : c)x = merge(x, n);\n\t\treturn x;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b)\n\t{\n\t\tif(b == null)return a;\n\t\tif(a == null)return b;\n\t\tif(a.priority > b.priority){\n\t\t\tsetParent(a.right, null);\n\t\t\tsetParent(b, null);\n\t\t\ta.right = merge(a.right, b);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tsetParent(a, null);\n\t\t\tsetParent(b.left, null);\n\t\t\tb.left = merge(a, b.left);\n\t\t\tsetParent(b.left, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\tpublic static Node[] split(Node x)\n\t{\n\t\tif(x == null)return new Node[]{null, null};\n\t\tif(x.left != null)x.left.parent = null;\n\t\tNode[] sp = new Node[]{x.left, x};\n\t\tx.left = null;\n\t\tupdate(x);\n\t\twhile(x.parent != null){\n\t\t\tNode p = x.parent;\n\t\t\tx.parent = null;\n\t\t\tif(x == p.left){\n\t\t\t\tp.left = sp[1];\n\t\t\t\tif(sp[1] != null)sp[1].parent = p;\n\t\t\t\tsp[1] = p;\n\t\t\t}else{\n\t\t\t\tp.right = sp[0];\n\t\t\t\tif(sp[0] != null)sp[0].parent = p;\n\t\t\t\tsp[0] = p;\n\t\t\t}\n\t\t\tupdate(p);\n\t\t\tx = p;\n\t\t}\n\t\treturn sp;\n\t}\n\t\n\tpublic static Node[] split(Node a, int... ks)\n\t{\n\t\tint n = ks.length;\n\t\tif(n == 0)return new Node[]{a};\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tif(ks[i] > ks[i+1])throw new IllegalArgumentException(Arrays.toString(ks));\n\t\t}\n\t\t\n\t\tNode[] ns = new Node[n+1];\n\t\tNode cur = a;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tNode[] sp = split(cur, ks[i]);\n\t\t\tcur = sp[0];\n\t\t\tns[i] = sp[0];\n\t\t\tns[i+1] = sp[1];\n\t\t}\n\t\treturn ns;\n\t}\n\t\n\t// [0,K),[K,N)\n\tpublic static Node[] split(Node a, int K)\n\t{\n\t\tif(a == null)return new Node[]{null, null};\n\t\tif(K <= count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tNode[] s = split(a.left, K);\n\t\t\ta.left = s[1];\n\t\t\tsetParent(a.left, a);\n\t\t\ts[1] = update(a);\n\t\t\treturn s;\n\t\t}else{\n\t\t\tsetParent(a.right, null);\n\t\t\tNode[] s = split(a.right, K-count(a.left)-1);\n\t\t\ta.right = s[0];\n\t\t\tsetParent(a.right, a);\n\t\t\ts[0] = update(a);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tpublic static Node insertb(Node root, Node x)\n\t{\n\t\tint ind = lowerBound(root, x.v);\n\t\treturn insert(root, ind, x);\n\t}\n\t\n\tpublic static Node insert(Node a, int K, Node b)\n\t{\n\t\tif(a == null)return b;\n\t\tif(b.priority < a.priority){\n\t\t\tif(K <= count(a.left)){\n\t\t\t\ta.left = insert(a.left, K, b);\n\t\t\t\tsetParent(a.left, a);\n\t\t\t}else{\n\t\t\t\ta.right = insert(a.right, K-count(a.left)-1, b);\n\t\t\t\tsetParent(a.right, a);\n\t\t\t}\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tNode[] ch = split(a, K);\n\t\t\tb.left = ch[0]; b.right = ch[1];\n\t\t\tsetParent(b.left, b);\n\t\t\tsetParent(b.right, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\t// delete K-th\n\tpublic static Node erase(Node a, int K)\n\t{\n\t\tif(a == null)return null;\n\t\tif(K < count(a.left)){\n\t\t\ta.left = erase(a.left, K);\n\t\t\tsetParent(a.left, a);\n\t\t\treturn update(a);\n\t\t}else if(K == count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tsetParent(a.right, null);\n\t\t\tNode aa = merge(a.left, a.right);\n\t\t\tdisconnect(a);\n\t\t\treturn aa;\n\t\t}else{\n\t\t\ta.right = erase(a.right, K-count(a.left)-1);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}\n\t}\n\t\n\tpublic static Node get(Node a, int K)\n\t{\n\t\twhile(a != null){\n\t\t\tif(K < count(a.left)){\n\t\t\t\ta = a.left;\n\t\t\t}else if(K == count(a.left)){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tK = K - count(a.left)-1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int index(Node a)\n\t{\n\t\tif(a == null)return -1;\n\t\tint ind = count(a.left);\n\t\twhile(a != null){\n\t\t\tNode par = a.parent;\n\t\t\tif(par != null && par.right == a){\n\t\t\t\tind += count(par.left) + 1;\n\t\t\t}\n\t\t\ta = par;\n\t\t}\n\t\treturn ind;\n\t}\n\t\n\tpublic static Node mergeTechnically(Node x, Node y)\n\t{\n\t\tif(count(x) > count(y)){\n\t\t\tNode d = x; x = y; y = d;\n\t\t}\n\t\t// |x|<=|y|\n\t\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\n\t\treturn y;\n\t}\n\t\n\tpublic static int lowerBound(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v >= q){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn lcount;\n\t}\n\t\n\tpublic static int search(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v == q){\n\t\t\t\tlcount += count(a.left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q < a.v){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a == null ? -(lcount+1) : lcount;\n\t}\n\t\n\tpublic static Node next(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.right != null){\n\t\t\tx = x.right;\n\t\t\twhile(x.left != null)x = x.left;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.left == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node prev(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.left != null){\n\t\t\tx = x.left;\n\t\t\twhile(x.right != null)x = x.right;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.right == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node[] nodes(Node a) { return nodes(a, new Node[a.count], 0, a.count); }\n\tpublic static Node[] nodes(Node a, Node[] ns, int L, int R)\n\t{\n\t\tif(a == null)return ns;\n\t\tnodes(a.left, ns, L, L+count(a.left));\n\t\tns[L+count(a.left)] = a;\n\t\tnodes(a.right, ns, R-count(a.right), R);\n\t\treturn ns;\n\t}\n\t\n\t// faster than nodes but inconsistent\n\tpublic static Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.count], new int[]{0}); }\n\tpublic static Node[] nodesdfs(Node a, Node[] ns, int[] pos)\n\t{\n\t\tif(a == null)return ns;\n\t\tns[pos[0]++] = a;\n\t\tnodesdfs(a.left, ns, pos);\n\t\tnodesdfs(a.right, ns, pos);\n\t\treturn ns;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.quala;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int q = in.nextInt();\n        int[] a = in.nextInts(q);\n        for (int i = 0; i < q ; i++) {\n            a[i]--;\n        }\n        int[] ord = makeord(m, a);\n        out.println(isOK(n, m, a, ord) ? \"Yes\" : \"No\");\n        out.flush();\n    }\n\n    private static int[] makeord(int m, int[] a) {\n        boolean[] seen = new boolean[m];\n        int[] ord = new int[m];\n        int oi = 0;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            if (!seen[a[i]]) {\n                seen[a[i]] = true;\n                ord[oi++] = a[i];\n            }\n        }\n        return Arrays.copyOf(ord, oi);\n    }\n\n    private static boolean isOK(int n, int m, int[] a, int[] ord) {\n        int[] iord = new int[m];\n        Arrays.fill(iord, -1);\n        for (int i = 0; i < ord.length; i++) {\n            iord[ord[i]] = i;\n        }\n        int on = ord.length;\n        int[] cnt = new int[on+1];\n        cnt[0] = n;\n        for (int i = a.length-1; i >= 0; i--) {\n            int th = iord[a[i]];\n            if (th == -1) {\n                continue;\n            }\n            if (cnt[th] >= 1) {\n                cnt[th]--;\n                cnt[th+1]++;\n            }\n        }\n\n        boolean special = true;\n        for (int i = 0; i < ord.length; i++) {\n            if (ord[i] != i) {\n                special = false;\n                break;\n            }\n        }\n        return special || (cnt[on] + ((on >= 2) ? cnt[on-1] : 0)) == n;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n \n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    int[] f(int[] a, int M, ArrayList<Integer> list) {\n      int Q = a.length;\n      TreeSet<Integer> set = new TreeSet<>();\n      for (int i = Q - 1; i >= 0; i--) {\n        if (set.contains(a[i])) continue;\n        list.add(a[i]);\n        set.add(a[i]);\n      }\n\n      for (int i = 0; i < M; i++) {\n        if (set.contains(i)) continue;\n        list.add(i);\n      }\n\n      int[] ret = new int[M];\n      for (int i = 0; i < M; i++) {\n        ret[list.get(i)] = i;\n      }\n      return ret;\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n      int Q = in.nextInt();\n      int[] a = new int[Q];\n      for (int i = 0; i < Q; i++) a[i] = in.nextInt() - 1;\n\n      ArrayList<Integer> list = new ArrayList<>();\n      int[] pos = f(a, M, list);\n      int[] freq = new int[M + 1];\n      freq[0] = N;\n      for (int i = Q - 1; i >= 0; i--) {\n        int p = pos[a[i]];\n        if (freq[p] == 0) {\n          out.println(\"No\");\n          return;\n        }\n        freq[p]--;\n        freq[p + 1]++;\n      }\n\n      int i;\n      for (i = 0; i <= M; i++) {\n        if (freq[i] > 0) {\n          break;\n        }\n      }\n      TreeSet<Integer> check = new TreeSet<>();\n      for (int j = 0; j <= freq[i]; j++) {\n        check.add(list.get(j));\n      }\n      int p = check.size();\n      for (int j = 0; j < M; j++) {\n        if (!check.contains(j)) {\n          if (list.get(p) != j) {\n            out.println(\"No\");\n            return;\n          } else {\n            p++;\n          }\n        }\n      }\n\n      out.println(\"Yes\");\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        if (n == 1) {\n            out.println(\"Yes\");\n            return;\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        boolean[] removed = new boolean[m];\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed[a[i]]) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed[a[i]] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed[i]) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint q = io.nextInt();\n\t\tint[] a = io.nextIntArray(q);\n\t\tboolean[] used = new boolean[m+1];\n\t\tArrayList<Integer> seq = new ArrayList<>();\n\t\tint ind = 0, count = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (count == 0 || seq.get(ind) != a[i]) {\n\t\t\t\tif (!used[a[i]]) {\n\t\t\t\t\tseq.add(a[i]);\n\t\t\t\t\tused[a[i]] = true;\n\t\t\t\t\tif (count == 0) count = 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t\tif (count == n) {\n\t\t\t\t\tind++;\n\t\t\t\t\tcount = seq.size() == ind ? 0 : 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\tseq.add(i);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> seq2 = new ArrayList<>();\n\t\tboolean[] used2 = new boolean[m+1];\n\t\tfor(int i=0;i<ind;i++) {\n\t\t\tint x = seq.get(i);\n\t\t\tseq2.add(x);\n\t\t\tused2[x] = true;\n\t\t}\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tif (!used2[i]) {\n\t\t\t\tseq2.add(i);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(seq.equals(seq2) ? \"Yes\" : \"No\");\n\t}\n\t\n\tstatic void gen() {\n\t\tint n = randInt(2,4);\n\t\tint m = randInt(2,5);\n\t\tint q = randInt(1,10);\n\t\tint[] a = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\ta[i] = randInt(1,m);\n\t\t}\n\t\tSystem.out.println(n + \" \" + m);\n\t\tSystem.out.println(q);\n\t\tSystem.out.println(Arrays.stream(a).boxed().map(String::valueOf).collect(Collectors.joining(\" \")));\n\t}\n\tstatic int randInt(int min,int max) {\n\t\treturn (int) (Math.random() * (max - min + 1)) + min;\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = in.nextInt() - 1;\n\t\t}\n\t\tint[] pos = new int[m];\n\t\tArrays.fill(pos, -1);\n\t\tint nowPos = 0;\n\t\tint[] cnt = new int[m];\n\t\tint[] vals = new int[m];\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint id = a[i];\n\t\t\tif (pos[id] == -1) {\n\t\t\t\tvals[nowPos] = id;\n\t\t\t\tpos[id] = nowPos;\n\t\t\t\tnowPos++;\n\t\t\t}\n\t\t\tcnt[pos[id]]++;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (cnt[i] < n) {\n\t\t\t\tboolean[] all = new boolean[m];\n\t\t\t\tArrays.fill(all, true);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (pos[j] != -1 && pos[j] < i) {\n\t\t\t\t\t\tall[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint it = 0;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int j = i; j < nowPos; j++) {\n\t\t\t\t\twhile (!all[it]) {\n\t\t\t\t\t\tit++;\n\t\t\t\t\t}\n\t\t\t\t\tif (it != vals[j]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tout.println(ok ? \"Yes\" : \"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"Yes\");\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew Main().runIO();\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tSet<Integer> set = new HashSet<>();\n\t\tset.add(1);\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap.put(i, 0);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint curr = map.get(a);\n\t\t\tif (curr == n - 1) {\n\t\t\t\tmap.put(a, 0);\n\t\t\t\tset.add(a);\n\t\t\t} else {\n\t\t\t\tmap.put(a, curr + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (map.get(i) > 0 && !set.contains(i)) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tif(cnt[ti]<n) cnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tcnt[sz+1] = 1;\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No2\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tcnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tSystem.out.println(\"No1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tcnt[sz+1] = 1;\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No2\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q + n];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        Set<Integer> removed = new HashSet<>();\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed.contains(a[i])) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed.add(a[i]);\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && l1.size() > l2.size() && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        boolean[] removed = new boolean[m];\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed[a[i]]) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed[a[i]] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed[i]) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n//            if (l2.size() > l1.size()) {\n//                out.println(\"No\");\n//                return;\n//            }\n            // l1.size() >= l2.size()\n            if (l1.size() == n && l2.size() == n && order.get(i) > order.get(i + 1)) {\n                for (int j = 0; j < l2.size(); j++) {\n                    if (l1.get(j) < l2.get(j)) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            } else {\n                if (order.get(i) > order.get(i + 1)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint M = cin.nextInt();\n\t\tint Q = cin.nextInt();\n\t\t\n\t\tint[] checker = new int[Q];\n\t\t\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint x = cin.nextInt();\n\t\t\tchecker[x-1] = (checker[x-1]+1)%N;\n\t\t}\n\t\t\n\t\tint standing = 0;\n\t\tboolean ans = true;\n\t\tfor (int i = 1; i < Q; i ++) {\n\t\t\tif (checker[i] > 0) {\n\t\t\t\tans = false;\n\t\t\t\tif (standing > 0) {\n\t\t\t\t\tstanding -= checker[i];\n\t\t\t\t} else {\n\t\t\t\t\tstanding += checker[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t} else {\n\t\t\tif (standing == 0) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println(ans);\n\t\t\n\t\t//if number across are same.\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tcnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tthrow new IOException();\n//\t\t\t\tSystem.out.println(\"No1\");\n//\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No2\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt(); // arrays\n\t\tint m = nextInt(); // numbers in each array\n\t\tint q = nextInt();\n\t\tint[] a = new int[q];\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\t\n\t\tTreeSet<Integer>[] sets = new TreeSet[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tsets[i] = new TreeSet<>();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tsets[a[i]].add(i);\n\t\t}\n\t\t\n\t\tboolean[] used = new boolean[m];\n\t\t\n\t\tint[] ptrs = new int[n];\n\t\tArrays.fill(ptrs, -1);\n\t\t\n\t\tint curPos = 0;\n\t\t\n\t\tint lastProper = -1;\n\t\t\n\t\touter: while (true) { // ?\n\t\t\twhile (curPos < q && used[a[curPos]]) {\n\t\t\t\tcurPos++;\n\t\t\t}\n\t\t\t\n\t\t\tif (curPos == q) { // huh?\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint num = a[curPos];\n\t\t\tused[num] = true;\n\t\t\t\n\t\t\tint prev = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tInteger newPtr = sets[num].higher(Math.max(prev, ptrs[i]));\n\t\t\t\tif (newPtr == null) {\n\t\t\t\t\tlastProper = num;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tsets[num].remove(newPtr);\n\t\t\t\tptrs[i] = newPtr;\n\t\t\t\tprev = newPtr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Integer> rest = new ArrayList<>();\n\t\trest.add(lastProper);\n\t\tfor (int i = curPos; i < q; i++) {\n\t\t\tif (!used[a[i]]) {\n\t\t\t\trest.add(a[i]);\n\t\t\t\tused[a[i]] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\trest.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < rest.size() - 1; i++) {\n\t\t\tif (rest.get(i) > rest.get(i + 1)) {\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"Yes\");\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.quala;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int q = in.nextInt();\n        int[] a = in.nextInts(q);\n        for (int i = 0; i < q ; i++) {\n            a[i]--;\n        }\n        int[] ord = makeord(m, a);\n        out.println(isOK(n, m, a, ord) ? \"Yes\" : \"No\");\n        out.flush();\n    }\n\n    private static int[] makeord(int m, int[] a) {\n        boolean[] seen = new boolean[m];\n        int[] ord = new int[m];\n        int oi = 0;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            if (!seen[a[i]]) {\n                seen[a[i]] = true;\n                ord[oi++] = a[i];\n            }\n        }\n        for (int i = 0; i < m ; i++) {\n            if (!seen[i]) {\n                ord[oi++] = i;\n            }\n        }\n        return ord;\n    }\n\n    private static boolean isOK(int n, int m, int[] a, int[] ord) {\n        int[] iord = new int[m];\n        Arrays.fill(iord, -1);\n        for (int i = 0; i < ord.length; i++) {\n            iord[ord[i]] = i;\n        }\n        int on = ord.length;\n        int[] cnt = new int[on+1];\n        cnt[0] = n;\n        for (int i = a.length-1; i >= 0; i--) {\n            int th = iord[a[i]];\n            if (cnt[th] >= 1) {\n                cnt[th]--;\n                cnt[th+1]++;\n            }\n        }\n\n        for (int i = 0; i <= on ; i++) {\n            if (cnt[i] >= 1) {\n                int[] ord2 = new int[m];\n                int oi = 0;\n                boolean[] seen = new boolean[m];\n                for (int j = 0; j < i ; j++) {\n                    ord2[oi++] = ord[j];\n                    seen[ord[j]] = true;\n                }\n                for (int j = 0; j < m ; j++) {\n                    if (!seen[j]) {\n                        ord2[oi++] = j;\n                    }\n                }\n                return Arrays.equals(ord, ord2);\n            }\n        }\n        throw new RuntimeException(\"nyan\");\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = in.nextInt() - 1;\n\t\t}\n\t\tint[] pos = new int[m];\n\t\tArrays.fill(pos, -1);\n\t\tint nowPos = 0;\n\t\tint[] vals = new int[m];\n\t\tint[] num = new int[m + 1];\n\t\tnum[0] = n;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint id = a[i];\n\t\t\tif (pos[id] == -1) {\n\t\t\t\tvals[nowPos] = id;\n\t\t\t\tpos[id] = nowPos;\n\t\t\t\tnowPos++;\n\t\t\t}\n\t\t\tif (num[pos[id]] > 0) {\n\t\t\t\tnum[pos[id]]--;\n\t\t\t\tnum[pos[id] + 1]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (num[i] !=0) {\n\t\t\t\tboolean[] all = new boolean[m];\n\t\t\t\tArrays.fill(all, true);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (pos[j] != -1 && pos[j] < i) {\n\t\t\t\t\t\tall[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint it = 0;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int j = i; j < nowPos; j++) {\n\t\t\t\t\twhile (!all[it]) {\n\t\t\t\t\t\tit++;\n\t\t\t\t\t}\n\t\t\t\t\tif (it != vals[j]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tout.println(ok ? \"Yes\" : \"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"Yes\");\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew Main().runIO();\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n/**\n * Created by Katushka on 11.03.2020.\n */\npublic class Main {\n\n    static int[] readArray(int size, InputReader in) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n    static long[] readLongArray(int size, InputReader in) {\n        long[] a = new long[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    static int binSearch(int[] list, int key) {\n        int l = -1;\n        int r = list.length;\n        while (l < r - 1) {\n            int m = (l + r) / 2;\n            if (list[m] > key) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return r;\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        final int n = in.nextInt();\n        final int m = in.nextInt();\n        final int q = in.nextInt();\n        final int[] a = readArray(q, in);\n        List<Integer> order = new ArrayList<>();\n        int[] used = new int[m + 1];\n        Arrays.fill(used, Integer.MAX_VALUE);\n\n        int[] sizes = new int[n];\n        for (int i = q - 1; i >= 0; i--) {\n            if (used[a[i]] == Integer.MAX_VALUE) {\n                sizes[0]++;\n                used[a[i]] = order.size();\n                order.add(a[i]);\n            } else {\n                int ind = used[a[i]];\n                int found = binSearch(sizes, ind);\n                if (sizes[found] == ind) {\n                    sizes[found]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 1; i < used.length; i++) {\n            if (used[i] == Integer.MAX_VALUE) {\n                min = i;\n                break;\n            }\n        }\n        int possibleDiff = 0;\n        for (int i = order.size() - 1; i >= 0; i--) {\n            int ai = order.get(i);\n            if (ai > min) {\n                break;\n            }\n            min = ai;\n            possibleDiff = order.size() - i;\n        }\n        if (sizes[0] - sizes[sizes.length - 1] > possibleDiff) {\n            out.println(\"No\");\n        } else {\n            out.println(\"Yes\");\n        }\n\n//      out.println(\"Time:\" + (System.currentTimeMillis() - startTime));\n        out.close();\n    }\n\n\n    private static String outputArray(Iterable<Integer> ans, Map<String, Integer> out) {\n        StringBuilder str = new StringBuilder();\n        for (int an : ans) {\n            str.append(an).append(' ');\n        }\n        String s = str.toString();\n        out.put(s, out.getOrDefault(s, 0) + 1);\n        return s;\n    }\n\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                createTokenizer();\n            }\n            return tokenizer.nextToken();\n        }\n\n        private void createTokenizer() {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String nextWord() {\n            return next();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public int[] nextInts() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                createTokenizer();\n            }\n            List<Integer> res = new ArrayList<>();\n            while (tokenizer.hasMoreElements()) {\n                res.add(Integer.parseInt(tokenizer.nextToken()));\n            }\n            int[] resArray = new int[res.size()];\n            for (int i = 0; i < res.size(); i++) {\n                resArray[i] = res.get(i);\n            }\n            return resArray;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int m = in.readInt();\n            int n = in.readInt();\n            int q = in.readInt();\n            int[] a = new int[q + 1];\n            for (int i = 1; i <= q; i++) {\n                a[i] = in.readInt();\n            }\n            Order[] order = new Order[n + 1];\n            for (int i = 1; i <= n; i++) {\n                order[i] = new Order();\n                order[i].val = i;\n                order[i].last = -i;\n            }\n            IntList[] list = new IntList[n + 1];\n            for (int i = 1; i <= n; i++) {\n                list[i] = new IntList();\n            }\n            for (int i = 1; i <= q; i++) {\n                list[a[i]].add(i);\n                order[a[i]].last = i;\n            }\n\n            Arrays.sort(order, 1, n + 1, (x, y) -> -Integer.compare(x.last, y.last));\n\n            int incUntil = n;\n            while (incUntil > 1 && order[incUntil - 1].val < order[incUntil].val) {\n                incUntil--;\n            }\n\n            for (int i = 1; i <= n; i++) {\n                SequenceUtils.reverse(list[i].getData(), 0, list[i].size());\n            }\n\n            IntList tmp = new IntList(n);\n            for (int i = 1; i < incUntil; i++) {\n                int x = order[i].val;\n                int y = order[i + 1].val;\n                if (list[x].size() < m) {\n                    no(out);\n                    return;\n                }\n\n                if (i + 1 == incUntil) {\n                    break;\n                }\n\n                tmp.clear();\n                for (int j = 0, k = 0; j < m && k < list[y].size(); j++) {\n                    int index = list[x].get(j);\n                    while (k < list[y].size() && list[y].get(k) > index) {\n                        k++;\n                    }\n                    if (k == list[y].size()) {\n                        no(out);\n                        return;\n                    }\n                    tmp.add(list[y].get(k));\n                    k++;\n                }\n\n                list[y].clear();\n                list[y].addAll(tmp);\n            }\n\n            yes(out);\n        }\n\n        public void no(FastOutput out) {\n            out.println(\"No\");\n        }\n\n        public void yes(FastOutput out) {\n            out.println(\"Yes\");\n        }\n\n    }\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        public void ensureSpace(int need) {\n            int req = size + need;\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntList)) {\n                return false;\n            }\n            IntList other = (IntList) obj;\n            return SequenceUtils.equal(data, other.data, 0, size - 1, 0, other.size - 1);\n        }\n\n    }\n    static class Order {\n        int val;\n        int last;\n\n    }\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void reverse(int[] data, int f, int t) {\n            int l = f, r = t - 1;\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static boolean equal(int[] a, int[] b, int al, int ar, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Checkbox;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean res = false;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint M = in.nextInt();\n\t\tint Q = in.nextInt();\n\t\tint[] a = new int[Q+1];\n\t\tfor (int i = 1; i < Q+1; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tArrayList<Integer>[] ns = new ArrayList[N+1];\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tns[i] = new ArrayList<Integer>();\n\t\t\tns[i].add(0);\n\t\t\tfor (int j = 1; j <= M; j++) {\n\t\t\t\tns[i].add(j);\n\t\t\t}\n\t\t}\n\n\t\tshuffle( ns, a, 1);\n\t\t\n\t\tif (res==true) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t} else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t\t\n\t}\n\n\tprivate static void shuffle( ArrayList<Integer>[] ns, int[] a, int i) {\n\t\t// TODO Auto-generated method stub\n\t\tif (i==a.length) {\n\t\t\tboolean check = isAligh(ns);\n\t\t\tif (check) {\n\t\t\t\tres = check;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int j = 1; j < ns.length; j++) {\n\t\t\tArrayList<Integer> tmp = new ArrayList<Integer>(ns[j].size());\n\t\t\tArrayList<Integer> tmp1 = new ArrayList<Integer>(ns[j].size());\n\t\t\tfor (Integer item: ns[j]) {\n\t\t\t\ttmp.add(item);\n\t\t\t\ttmp1.add(item);\n\t\t\t}\n\t\t\t\n\t\t\ttmp1.remove((Object)a[i]);\n\t\t\ttmp1.add(1,a[i]);\n\t\t\tns[j] = tmp1;\n\t\t\tshuffle( ns, a, i+1);\n\t\t\tns[j] = tmp;\t\t\n\t\t}\n\t}\n\n\tprivate static boolean isAligh(ArrayList<Integer>[] ns) {\n\t\t// TODO Auto-generated method stub\n\t\tboolean ans = true;\n\t\tfor (int i = 1; i < ns[1].size() ; i++) {\n\t\t\tif (ans==false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 1; j < ns.length-1; j++) {\n\t\t\t\tif (ns[j].get(i)==ns[j+1].get(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else {\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n \n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    int[] f(int[] a, int M, ArrayList<Integer> list) {\n      int Q = a.length;\n      TreeSet<Integer> set = new TreeSet<>();\n      for (int i = Q - 1; i >= 0; i--) {\n        if (set.contains(a[i])) continue;\n        list.add(a[i]);\n        set.add(a[i]);\n      }\n\n      for (int i = 0; i < M; i++) {\n        if (set.contains(i)) continue;\n        list.add(i);\n      }\n\n      int[] ret = new int[M];\n      for (int i = 0; i < M; i++) {\n        ret[list.get(i)] = i;\n      }\n      return ret;\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n      int Q = in.nextInt();\n      int[] a = new int[Q];\n      for (int i = 0; i < Q; i++) a[i] = in.nextInt() - 1;\n\n      ArrayList<Integer> list = new ArrayList<>();\n      int[] pos = f(a, M, list);\n      int[] freq = new int[M + 1];\n      freq[0] = N;\n      for (int i = Q - 1; i >= 0; i--) {\n        int p = pos[a[i]];\n        if (freq[p] == 0) continue;\n        freq[p]--;\n        freq[p + 1]++;\n      }\n\n      int i;\n      for (i = 0; i <= M; i++) {\n        if (freq[i] > 0) {\n          break;\n        }\n      }\n      TreeSet<Integer> check = new TreeSet<>();\n      for (int j = 0; j < i; j++) {\n        check.add(list.get(j));\n      }\n      int p = check.size();\n      for (int j = 0; j < M; j++) {\n        if (!check.contains(j)) {\n          if (list.get(p) != j) {\n            out.println(\"No\");\n            return;\n          } else {\n            p++;\n          }\n        }\n      }\n\n      out.println(\"Yes\");\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint Q = ni();\n\t\tint[] a = na(Q);\n\t\t\n\t\tNode root = null;\n\t\tNode[] nodes = new Node[m+1];\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tnodes[i] = new Node(i);\n\t\t\troot = merge(root, nodes[i]);\n\t\t}\n\t\tint dec = 0;\n\t\tfor(int i = 0;i < Q;i++){\n\t\t\tint K = index(nodes[a[i]]);\n\t\t\troot = erase(root, K);\n\t\t\troot = merge(nodes[a[i]], root);\n\t\t}\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tNode cur = nodes[i];\n\t\t\tNode nex = next(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t}\n\t\tif(dec == 0){\n\t\t\tout.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] fs = new int[n];\n\t\tArrays.fill(fs, Q);\n\t\tint[][] buc = makeBuckets(a, m);\n\t\tboolean[] used = new boolean[m+1];\n\t\tout:\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tif(used[a[i]])continue;\n\t\t\tused[a[i]] = true;\n\t\t\tif(buc[a[i]].length < n)break;\n\t\t\tint j = buc[a[i]].length-1;\n\t\t\tfor(int k = n-1;k >= 0;k--){\n\t\t\t\twhile(j >= 0 && buc[a[i]][j] >= fs[k]){\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif(j == -1)break out;\n\t\t\t\tfs[k] = buc[a[i]][j];\n\t\t\t}\n\t\t\t\n\t\t\tNode cur = nodes[a[i]];\n\t\t\tNode nex = next(cur);\n\t\t\tNode pre = prev(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && pre.v >= cur.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && nex != null && pre.v >= cur.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t\troot = erase(root, index(cur));\n\t\t\tif(dec == 0){\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\t\treturn;\n\t}\n\t\n\t\n\tpublic static int[][] makeBuckets(int[] a, int sup)\n\t{\n\t\tint n = a.length;\n\t\tint[][] bucket = new int[sup+1][];\n\t\tint[] bp = new int[sup+1];\n\t\tfor(int i = 0;i < n;i++)bp[a[i]]++;\n\t\tfor(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];\n\t\tfor(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;\n\t\treturn bucket;\n\t}\n\t\n\n\tpublic static Random gen = new Random();\n\t\n\tstatic public class Node\n\t{\n\t\tpublic int v; // value\n\t\tpublic long priority;\n\t\tpublic Node left, right, parent;\n\t\t\n\t\tpublic int count;\n\t\t\n\t\tpublic Node(int v)\n\t\t{\n\t\t\tthis.v = v;\n\t\t\tpriority = gen.nextLong();\n\t\t\tupdate(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"Node [v=\");\n\t\t\tbuilder.append(v);\n\t\t\tbuilder.append(\", count=\");\n\t\t\tbuilder.append(count);\n\t\t\tbuilder.append(\", parent=\");\n\t\t\tbuilder.append(parent != null ? parent.v : \"null\");\n\t\t\tbuilder.append(\"]\");\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\tpublic static Node update(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.count = 1;\n\t\tif(a.left != null)a.count += a.left.count;\n\t\tif(a.right != null)a.count += a.right.count;\n\t\t\n\t\t// TODO\n\t\treturn a;\n\t}\n\t\n\tpublic static void propagate(Node x)\n\t{\n\t\tfor(;x != null;x = x.parent)update(x);\n\t}\n\t\n\tpublic static Node disconnect(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.left = a.right = a.parent = null;\n\t\treturn update(a);\n\t}\n\t\n\tpublic static Node root(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\twhile(x.parent != null)x = x.parent;\n\t\treturn x;\n\t}\n\t\n\tpublic static int count(Node a)\n\t{\n\t\treturn a == null ? 0 : a.count;\n\t}\n\t\n\tpublic static void setParent(Node a, Node par)\n\t{\n\t\tif(a != null)a.parent = par;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b, Node... c)\n\t{\n\t\tNode x = merge(a, b);\n\t\tfor(Node n : c)x = merge(x, n);\n\t\treturn x;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b)\n\t{\n\t\tif(b == null)return a;\n\t\tif(a == null)return b;\n\t\tif(a.priority > b.priority){\n\t\t\tsetParent(a.right, null);\n\t\t\tsetParent(b, null);\n\t\t\ta.right = merge(a.right, b);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tsetParent(a, null);\n\t\t\tsetParent(b.left, null);\n\t\t\tb.left = merge(a, b.left);\n\t\t\tsetParent(b.left, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\tpublic static Node[] split(Node x)\n\t{\n\t\tif(x == null)return new Node[]{null, null};\n\t\tif(x.left != null)x.left.parent = null;\n\t\tNode[] sp = new Node[]{x.left, x};\n\t\tx.left = null;\n\t\tupdate(x);\n\t\twhile(x.parent != null){\n\t\t\tNode p = x.parent;\n\t\t\tx.parent = null;\n\t\t\tif(x == p.left){\n\t\t\t\tp.left = sp[1];\n\t\t\t\tif(sp[1] != null)sp[1].parent = p;\n\t\t\t\tsp[1] = p;\n\t\t\t}else{\n\t\t\t\tp.right = sp[0];\n\t\t\t\tif(sp[0] != null)sp[0].parent = p;\n\t\t\t\tsp[0] = p;\n\t\t\t}\n\t\t\tupdate(p);\n\t\t\tx = p;\n\t\t}\n\t\treturn sp;\n\t}\n\t\n\tpublic static Node[] split(Node a, int... ks)\n\t{\n\t\tint n = ks.length;\n\t\tif(n == 0)return new Node[]{a};\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tif(ks[i] > ks[i+1])throw new IllegalArgumentException(Arrays.toString(ks));\n\t\t}\n\t\t\n\t\tNode[] ns = new Node[n+1];\n\t\tNode cur = a;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tNode[] sp = split(cur, ks[i]);\n\t\t\tcur = sp[0];\n\t\t\tns[i] = sp[0];\n\t\t\tns[i+1] = sp[1];\n\t\t}\n\t\treturn ns;\n\t}\n\t\n\t// [0,K),[K,N)\n\tpublic static Node[] split(Node a, int K)\n\t{\n\t\tif(a == null)return new Node[]{null, null};\n\t\tif(K <= count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tNode[] s = split(a.left, K);\n\t\t\ta.left = s[1];\n\t\t\tsetParent(a.left, a);\n\t\t\ts[1] = update(a);\n\t\t\treturn s;\n\t\t}else{\n\t\t\tsetParent(a.right, null);\n\t\t\tNode[] s = split(a.right, K-count(a.left)-1);\n\t\t\ta.right = s[0];\n\t\t\tsetParent(a.right, a);\n\t\t\ts[0] = update(a);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tpublic static Node insertb(Node root, Node x)\n\t{\n\t\tint ind = lowerBound(root, x.v);\n\t\treturn insert(root, ind, x);\n\t}\n\t\n\tpublic static Node insert(Node a, int K, Node b)\n\t{\n\t\tif(a == null)return b;\n\t\tif(b.priority < a.priority){\n\t\t\tif(K <= count(a.left)){\n\t\t\t\ta.left = insert(a.left, K, b);\n\t\t\t\tsetParent(a.left, a);\n\t\t\t}else{\n\t\t\t\ta.right = insert(a.right, K-count(a.left)-1, b);\n\t\t\t\tsetParent(a.right, a);\n\t\t\t}\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tNode[] ch = split(a, K);\n\t\t\tb.left = ch[0]; b.right = ch[1];\n\t\t\tsetParent(b.left, b);\n\t\t\tsetParent(b.right, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\t// delete K-th\n\tpublic static Node erase(Node a, int K)\n\t{\n\t\tif(a == null)return null;\n\t\tif(K < count(a.left)){\n\t\t\ta.left = erase(a.left, K);\n\t\t\tsetParent(a.left, a);\n\t\t\treturn update(a);\n\t\t}else if(K == count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tsetParent(a.right, null);\n\t\t\tNode aa = merge(a.left, a.right);\n\t\t\tdisconnect(a);\n\t\t\treturn aa;\n\t\t}else{\n\t\t\ta.right = erase(a.right, K-count(a.left)-1);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}\n\t}\n\t\n\tpublic static Node get(Node a, int K)\n\t{\n\t\twhile(a != null){\n\t\t\tif(K < count(a.left)){\n\t\t\t\ta = a.left;\n\t\t\t}else if(K == count(a.left)){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tK = K - count(a.left)-1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int index(Node a)\n\t{\n\t\tif(a == null)return -1;\n\t\tint ind = count(a.left);\n\t\twhile(a != null){\n\t\t\tNode par = a.parent;\n\t\t\tif(par != null && par.right == a){\n\t\t\t\tind += count(par.left) + 1;\n\t\t\t}\n\t\t\ta = par;\n\t\t}\n\t\treturn ind;\n\t}\n\t\n\tpublic static Node mergeTechnically(Node x, Node y)\n\t{\n\t\tif(count(x) > count(y)){\n\t\t\tNode d = x; x = y; y = d;\n\t\t}\n\t\t// |x|<=|y|\n\t\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\n\t\treturn y;\n\t}\n\t\n\tpublic static int lowerBound(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v >= q){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn lcount;\n\t}\n\t\n\tpublic static int search(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v == q){\n\t\t\t\tlcount += count(a.left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q < a.v){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a == null ? -(lcount+1) : lcount;\n\t}\n\t\n\tpublic static Node next(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.right != null){\n\t\t\tx = x.right;\n\t\t\twhile(x.left != null)x = x.left;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.left == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node prev(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.left != null){\n\t\t\tx = x.left;\n\t\t\twhile(x.right != null)x = x.right;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.right == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node[] nodes(Node a) { return nodes(a, new Node[a.count], 0, a.count); }\n\tpublic static Node[] nodes(Node a, Node[] ns, int L, int R)\n\t{\n\t\tif(a == null)return ns;\n\t\tnodes(a.left, ns, L, L+count(a.left));\n\t\tns[L+count(a.left)] = a;\n\t\tnodes(a.right, ns, R-count(a.right), R);\n\t\treturn ns;\n\t}\n\t\n\t// faster than nodes but inconsistent\n\tpublic static Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.count], new int[]{0}); }\n\tpublic static Node[] nodesdfs(Node a, Node[] ns, int[] pos)\n\t{\n\t\tif(a == null)return ns;\n\t\tns[pos[0]++] = a;\n\t\tnodesdfs(a.left, ns, pos);\n\t\tnodesdfs(a.right, ns, pos);\n\t\treturn ns;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.quala;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int q = in.nextInt();\n        int[] a = in.nextInts(q);\n        for (int i = 0; i < q ; i++) {\n            a[i]--;\n        }\n        int[] ord = makeord(m, a);\n        out.println(isOK(n, m, a, ord) ? \"Yes\" : \"No\");\n        out.flush();\n    }\n\n    private static int[] makeord(int m, int[] a) {\n        boolean[] seen = new boolean[m];\n        int[] ord = new int[m];\n        int oi = 0;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            if (!seen[a[i]]) {\n                seen[a[i]] = true;\n                ord[oi++] = a[i];\n                if (oi >= m-1) {\n                    break;\n                }\n            }\n        }\n        return Arrays.copyOf(ord, oi);\n    }\n\n    private static boolean isOK(int n, int m, int[] a, int[] ord) {\n        int[] iord = new int[m];\n        Arrays.fill(iord, -1);\n        for (int i = 0; i < ord.length ; i++) {\n            iord[ord[i]] = i;\n        }\n        int on = ord.length;\n        int[] cnt = new int[on+1];\n        cnt[0] = n;\n        for (int i = a.length-1 ; i >= 0 ; i--) {\n            int th = iord[a[i]];\n            if (th == -1) {\n                continue;\n            }\n            if (cnt[th] >= 1) {\n                cnt[th]--;\n                cnt[th+1]++;\n            }\n        }\n\n        boolean special = true;\n        for (int i = 0 ; i < ord.length ; i++) {\n            if (ord[i] != i) {\n                special = false;\n                break;\n            }\n        }\n        if (special) {\n            return cnt[on] + cnt[0] == n;\n        }\n        return cnt[on] == n;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int m = in.readInt();\n            int n = in.readInt();\n            int q = in.readInt();\n            int[] seq = new int[q + 1];\n            int[] last = new int[q + 1];\n            int[] reg = new int[n + 1];\n            for (int i = 1; i <= q; i++) {\n                seq[i] = in.readInt();\n                last[i] = reg[seq[i]];\n                reg[seq[i]] = i;\n            }\n\n            List<Integer> perms = new ArrayList<>();\n            List<Integer> cnts = new ArrayList<>();\n            Constraint[] constraints = new Constraint[q + 1];\n            List<Constraint> wait = new ArrayList<>(q);\n            boolean[] used = new boolean[n + 1];\n            boolean flag = true;\n            int nextValue = 1;\n\n            for (int i = q; i >= 1; i--) {\n                int v = seq[i];\n                if (used[v]) {\n                    continue;\n                }\n                used[v] = true;\n                flag = flag && nextValue == v;\n                nextValue++;\n            }\n\n            Arrays.fill(used, false);\n            if (flag) {\n                out.println(\"Yes\");\n                return;\n            }\n\n            for (int i = q; i >= 1; i--) {\n                int v = seq[i];\n                if (used[v]) {\n                    continue;\n                }\n                for (int j = 0, until = wait.size(); j < until; j++) {\n                    Constraint c = wait.get(j);\n                    c.num = v;\n                    c.require = m - j;\n                    constraints[c.index] = c;\n                }\n\n                used[v] = true;\n                wait.clear();\n                for (int j = i; j >= 1; j = last[j]) {\n                    Constraint c = new Constraint();\n                    c.index = j;\n                    wait.add(c);\n                }\n                perms.add(v);\n                cnts.add(wait.size());\n            }\n\n            if (cnts.get(0) < m) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[] cnt = new int[n + 1];\n            if (perms.get(perms.size() - 1) == 1) {\n                cnt[1] = m;\n            }\n            for (int i = 1; i <= q; i++) {\n                cnt[seq[i]]++;\n                if (constraints[i] != null) {\n                    if (cnt[constraints[i].num] < constraints[i].require) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n\n            out.println(\"Yes\");\n            return;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Constraint {\n        int index;\n        int num;\n        int require;\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        boolean[] removed = new boolean[m];\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed[a[i]]) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed[a[i]] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed[i]) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n        boolean ok = true;\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n            if (l1.size() < n || l2.size() < n) {\n                ok = false;\n            }\n            if (ok && order.get(i) > order.get(i + 1)) {\n                for (int j = 0; j < l2.size(); j++) {\n                    if (l1.get(j) < l2.get(j)) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            } else {\n                if (order.get(i) > order.get(i + 1)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tHashSet<Integer> set = new HashSet<>();\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set.contains(a[i])) continue;\n\t\t\tset.add(a[i]);\n\t\t\tlist.add(a[i]);\n\t\t}\n\t\tout:{\n\t\t\tfor(int i=0; i<list.size(); i++){\n\t\t\t\tif(list.get(i) != i+1) break out;\n\t\t\t}\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\ta[q] = 1;\n\t}\n}\n \nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n/**\n * Created by Katushka on 11.03.2020.\n */\npublic class Main {\n\n    static int[] readArray(int size, InputReader in) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n    static long[] readLongArray(int size, InputReader in) {\n        long[] a = new long[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    static int binSearch(int[] list, int key) {\n        int l = -1;\n        int r = list.length;\n        while (l < r - 1) {\n            int m = (l + r) / 2;\n            if (list[m] > key) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return r;\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        final int n = in.nextInt();\n        final int m = in.nextInt();\n        final int q = in.nextInt();\n        final int[] a = readArray(q, in);\n        List<Integer> order = new ArrayList<>();\n        int[] used = new int[m + 1];\n        Arrays.fill(used, Integer.MAX_VALUE);\n\n        int[] sizes = new int[n];\n        for (int i = q - 1; i >= 0; i--) {\n            if (used[a[i]] == Integer.MAX_VALUE) {\n                sizes[0]++;\n                used[a[i]] = order.size();\n                order.add(a[i]);\n            } else {\n                int ind = used[a[i]];\n                int found = binSearch(sizes, ind);\n                if (found >= 0 && found < sizes.length && sizes[found] == ind) {\n                    sizes[found]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 1; i < used.length; i++) {\n            if (used[i] == Integer.MAX_VALUE) {\n                min = i;\n                break;\n            }\n        }\n        int possibleDiff = 0;\n        for (int i = order.size() - 1; i >= 0; i--) {\n            int ai = order.get(i);\n            if (ai > min) {\n                break;\n            }\n            min = ai;\n            possibleDiff = order.size() - i;\n        }\n        if (sizes[0] - sizes[sizes.length - 1] > possibleDiff) {\n            out.println(\"No\");\n        } else {\n            out.println(\"Yes\");\n        }\n\n//      out.println(\"Time:\" + (System.currentTimeMillis() - startTime));\n        out.close();\n    }\n\n\n    private static String outputArray(Iterable<Integer> ans, Map<String, Integer> out) {\n        StringBuilder str = new StringBuilder();\n        for (int an : ans) {\n            str.append(an).append(' ');\n        }\n        String s = str.toString();\n        out.put(s, out.getOrDefault(s, 0) + 1);\n        return s;\n    }\n\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                createTokenizer();\n            }\n            return tokenizer.nextToken();\n        }\n\n        private void createTokenizer() {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String nextWord() {\n            return next();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public int[] nextInts() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                createTokenizer();\n            }\n            List<Integer> res = new ArrayList<>();\n            while (tokenizer.hasMoreElements()) {\n                res.add(Integer.parseInt(tokenizer.nextToken()));\n            }\n            int[] resArray = new int[res.size()];\n            for (int i = 0; i < res.size(); i++) {\n                resArray[i] = res.get(i);\n            }\n            return resArray;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        if (n == 1) {\n            out.println(\"Yes\");\n            return;\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        boolean[] removed = new boolean[m];\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed[a[i]]) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed[a[i]] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed[i]) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int m = in.readInt();\n            int n = in.readInt();\n            int q = in.readInt();\n            int[] seq = new int[q + 1];\n            int[] last = new int[q + 1];\n            int[] reg = new int[n + 1];\n            for (int i = 1; i <= q; i++) {\n                seq[i] = in.readInt();\n                last[i] = reg[seq[i]];\n                reg[seq[i]] = i;\n            }\n\n            List<Integer> perms = new ArrayList<>();\n            List<Integer> cnts = new ArrayList<>();\n            Constraint[] constraints = new Constraint[q + 1];\n            List<Constraint> wait = new ArrayList<>(q);\n            boolean[] used = new boolean[n + 1];\n            boolean flag = true;\n            int nextValue = 1;\n\n            for (int i = q; i >= 1; i--) {\n                int v = seq[i];\n                if (used[v]) {\n                    continue;\n                }\n                flag = flag && nextValue == v;\n                nextValue++;\n            }\n\n            Arrays.fill(used, false);\n            if (flag) {\n                out.println(\"Yes\");\n                return;\n            }\n\n            for (int i = q; i >= 1; i--) {\n                int v = seq[i];\n                if (used[v]) {\n                    continue;\n                }\n                for (int j = 0, until = wait.size(); j < until; j++) {\n                    Constraint c = wait.get(j);\n                    c.num = v;\n                    c.require = m - j;\n                    constraints[c.index] = c;\n                }\n\n                used[v] = true;\n                wait.clear();\n                int cnt = 0;\n                for (int j = i; j >= 1; j = last[j]) {\n                    Constraint c = new Constraint();\n                    c.index = j;\n                    wait.add(c);\n                    cnt++;\n                }\n                perms.add(v);\n                cnts.add(cnt);\n            }\n\n            if (cnts.get(0) < m) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[] cnt = new int[n + 1];\n            if (perms.get(perms.size() - 1) == 1) {\n                cnt[1] = m;\n            }\n            for (int i = 1; i <= q; i++) {\n                cnt[seq[i]]++;\n                if (constraints[i] != null) {\n                    if (cnt[constraints[i].num] < constraints[i].require) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n\n            out.println(\"Yes\");\n            return;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Constraint {\n        int index;\n        int num;\n        int require;\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            TreeSet<Integer>[] poses = new TreeSet[m];\n            for (int i = 0; i < m; ++i)\n                poses[i] = new TreeSet<>();\n            int q = in.nextInt();\n            int[] a = new int[q];\n            for (int i = 0; i < q; ++i) {\n                int x = in.nextInt() - 1;\n                a[q - 1 - i] = x;\n                poses[x].add(q - 1 - i);\n            }\n            int[] heads = new int[n];\n            int stage = 0;\n            int prev = -1;\n            for (int i = 0; i < q; ++i) {\n                if (a[i] == -1) continue;\n                int x = a[i];\n\n                if (stage == 1) {\n                    if (prev != x - 1) {\n                        out.printLine(\"No\");\n                        return;\n                    }\n                }\n\n                TreeSet<Integer> inds = poses[x];\n                for (int j = 0; j < n; ++j) {\n                    Integer ind = inds.ceiling(heads[j]);\n                    if (ind == null) {\n                        if (stage == 0 && x != 0) {\n                            out.printLine(\"No\");\n                            return;\n                        }\n                        stage = 1;\n                        break;\n                    }\n                    heads[j] = ind;\n                    a[ind] = -1;\n                    inds.remove(ind);\n                }\n                for (int ind : inds) {\n                    a[ind] = -1;\n                }\n                inds.clear();\n                prev = x;\n            }\n            out.printLine(\"Yes\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        Set<Integer> removed = new HashSet<>();\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed.contains(a[i])) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed.add(a[i]);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed.contains(a[i])) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n/**\n * Created by Aksenov239 on 24.09.2016.\n */\npublic class Main {\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int q = nextInt();\n        int[] a = new int[q];\n        for (int i = 0; i < q; i++) {\n            a[q - i - 1] = nextInt();\n        }\n        ArrayList<Integer> b = new ArrayList<Integer>();\n        HashMap<Integer, Integer> pos = new HashMap<Integer, Integer>();\n        int[] waiting = new int[q];\n        for (int i = 0; i < q; i++) {\n            if (!pos.containsKey(a[i])) {\n                b.add(a[i]);\n                waiting[b.size() - 1] = 1;\n                pos.put(a[i], b.size() - 1);\n                continue;\n            }\n            int p = pos.get(a[i]);\n            if (waiting[p] == n) {\n                continue;\n            }\n            waiting[p]++;\n        }\n        int j = b.size() - 1;\n        int z = b.get(b.size() - 1);\n        while (j >= 0 && b.get(j) == z) {\n            j--;\n            z--;\n        }\n        for (int i = 0; i < (z == 0 ? j + 1 : b.size()); i++) {\n            if (waiting[i] != n) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.Vector;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author phantom11\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int N = in.nextInt(), M = in.nextInt(), Q = in.nextInt(), i, c = 0;\n            int a[] = new int[M], b[] = new int[M];\n            boolean used[] = new boolean[M];\n            Stack<Integer> stack = new Stack<Integer>();\n            for (i = 0; i < Q; i++) {\n                int k = in.nextInt() - 1;\n                a[k]++;\n                //b[i] = k;\n                stack.push(k);\n            }\n            boolean possible = true;\n            int p = 0;\n            int D[] = new int[M];\n            while (!stack.isEmpty()) {\n                int k = stack.pop();\n                if (!used[k]) {\n                    D[p++] = k;\n                    used[k] = true;\n                }\n            }\n            //DebugUtils.debug(D, a);\n            for (i = 0; i < p; i++) {\n                if (D[i] != i) {\n                    possible = false;\n                    break;\n                }\n            }\n            if (possible) {\n                out.printLine(\"Yes\");\n                return;\n            }\n            possible = true;\n\n\n            for (i = 1; i < M; i++) {\n                if (a[i] % N > 0) {\n                    // DebugUtils.debug(i, a[i]);\n                    possible = false;\n                }\n            }\n            if (possible) {\n                out.printLine(\"Yes\");\n            } else {\n                out.printLine(\"No\");\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tokenizer = null;\n\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(in.readLine());\n                }\n                return tokenizer.nextToken();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tint numArrays;\n\tint upperLimit;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint numArrays = sc.nextInt();\n\t\tint upperLimit = sc.nextInt();\n\t\tint[][] arr = new int[numArrays][upperLimit];\n\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tarr[i][j] = j+1;\t\n\t\t\t}\n\t\t}\n\n\t\tint numOps = sc.nextInt();\n\t\tint[] ops = new int[numOps];\n\t\tfor (int i = 0; i < numOps; i++) {\n\t\t\tops[i] = sc.nextInt();\n\t\t}\n\n\t\tif (possible(arr, numArrays, upperLimit, ops)) \n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\n\t\t// moveFront(ops, arr);\n\t\t// print(arr, numArrays, upperLimit); // for checking\n\t}\n\n\tpublic static boolean possible(int[][] arr, int numArrays, int upperLimit, int[] ops) {\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic static void moveFront(int[] ops, int[][] arr) {\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length; j++) {\n\t\t\t\tif (arr[i][j] == ops[i]) {\n\t\t\t\t\tint[][] newArr = clone(arr);\n\t\t\t\t\tnewArr[i][j] = ops[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\t\n\tpublic static int[][] clone(int[][] arr) {\n\t\tint[][] newArr = new int[arr.length][arr[0].length];\n\t\t// clone the arr\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j < arr[i].length-1; j++) {\n\t\t\t\tnewArr[i][j+1] = arr[i][j];\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn newArr;\n\t}\n\t\t\n\n\tpublic static void print(int[][] arr, int numArrays, int upperLimit) {\n\t\tfor (int i = 0; i < numArrays; i++) {\n\t\t\tSystem.out.print(\"(\");\n\t\t\tfor (int j = 0; j < upperLimit; j++) {\n\t\t\t\tSystem.out.print(arr[i][j]);\n\t\t\t\tif (j != upperLimit-1) \n\t\t\t\t\tSystem.out.print(\",\");\n\t\t\t}\n\t\t\tSystem.out.println(\")\");\n\t\t} \n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n \n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    int[] f(int[] a, int M, ArrayList<Integer> list) {\n      int Q = a.length;\n      TreeSet<Integer> set = new TreeSet<>();\n      for (int i = Q - 1; i >= 0; i--) {\n        if (set.contains(a[i])) continue;\n        list.add(a[i]);\n        set.add(a[i]);\n      }\n\n      for (int i = 0; i < M; i++) {\n        if (set.contains(i)) continue;\n        list.add(i);\n      }\n\n      int[] ret = new int[M];\n      for (int i = 0; i < M; i++) {\n        ret[list.get(i)] = i;\n      }\n      return ret;\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n      int Q = in.nextInt();\n      int[] a = new int[Q];\n      for (int i = 0; i < Q; i++) a[i] = in.nextInt() - 1;\n\n      ArrayList<Integer> list = new ArrayList<>();\n      int[] pos = f(a, M, list);\n      int[] freq = new int[M + 1];\n      freq[0] = N;\n      for (int i = Q - 1; i >= 0; i--) {\n        int p = pos[a[i]];\n        if (freq[p] == 0) {\n          out.println(\"No\");\n          return;\n        }\n        freq[p]--;\n        freq[p + 1]++;\n      }\n\n      int i;\n      for (i = 0; i <= M; i++) {\n        if (freq[i] > 0) {\n          break;\n        }\n      }\n      TreeSet<Integer> check = new TreeSet<>();\n      for (int j = 0; j < i; j++) {\n        check.add(list.get(j));\n      }\n      int p = check.size();\n      for (int j = 0; j < M; j++) {\n        if (!check.contains(j)) {\n          if (list.get(p) != j) {\n            out.println(\"No\");\n            return;\n          } else {\n            p++;\n          }\n        }\n      }\n\n      out.println(\"Yes\");\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q + n];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        Set<Integer> removed = new HashSet<>();\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed.contains(a[i])) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed.add(a[i]);\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n \n/**\n * Created by Aksenov239 on 24.09.2016.\n */\npublic class Main {\n    public static void main(String[] args) {\n        new Main().run();\n    }\n \n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n \n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n \n    public void solve() throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int q = nextInt();\n        int[] a = new int[q];\n        for (int i = 0; i < q; i++) {\n            a[q - i - 1] = nextInt();\n        }\n        ArrayList<Integer> b = new ArrayList<Integer>();\n        HashMap<Integer, Integer> pos = new HashMap<Integer, Integer>();\n        int[] waiting = new int[q];\n        for (int i = 0; i < q; i++) {\n            if (!pos.containsKey(a[i])) {\n                b.add(a[i]);\n                waiting[b.size() - 1] = 1;\n                pos.put(a[i], b.size() - 1);\n                continue;\n            }\n            int p = pos.get(a[i]);\n            if (waiting[p] == n) {\n                continue;\n            }\n            if (p != 0 && waiting[p] == waiting[p - 1]) continue;\n            waiting[p]++;\n        }\n        int j = b.size() - 1;\n        int z = b.get(b.size() - 1);\n        while (j >= 0 && b.get(j) == z) {\n            j--;\n            z--;\n        }\n        for (int i = 0; i < (z == 0 ? j + 1 : b.size()); i++) {\n            if (waiting[i] != n) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n    }\n \n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n \n            solve();\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public void solve() {\n        int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n        int[] a = new int[q];\n        Map<Integer, List<Integer>> occ = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            a[i] = in.nextInt() - 1;\n            if (!occ.containsKey(a[i])) {\n                occ.put(a[i], new ArrayList<>());\n            }\n            occ.get(a[i]).add(i);\n        }\n        for (int i : occ.keySet()) {\n            List<Integer> l = occ.get(i);\n            Collections.reverse(l);\n            if (l.size() > n) {\n                l = l.subList(0, n);\n            }\n            occ.put(i, l);\n        }\n        List<Integer> order = new ArrayList<>();\n        List<List<Integer>> toCompare = new ArrayList<>();\n\n        Set<Integer> removed = new HashSet<>();\n        for (int i = q - 1; i >= 0; i--) {\n            if (!removed.contains(a[i])) {\n                order.add(a[i]);\n                toCompare.add(occ.get(a[i]));\n                removed.add(a[i]);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (!removed.contains(i)) {\n                order.add(i);\n                toCompare.add(new ArrayList<>());\n            }\n        }\n\n        for (int i = 0; i < order.size() - 1; i++) {\n            List<Integer> l1 = toCompare.get(i), l2 = toCompare.get(i + 1);\n\n            if (l2.size() > l1.size()) {\n                out.println(\"No\");\n                return;\n            }\n            // l1.size() >= l2.size()\n\n            for (int j = 0; j < l2.size(); j++) {\n                if (l1.get(j) < l2.get(j)) {\n                    out.println(\"No\");\n                    return;\n                }\n            }\n\n            if (l1.size() != n && order.get(i) > order.get(i + 1)) {\n                out.println(\"No\");\n                return;\n            }\n        }\n        out.println(\"Yes\");\n\n    }\n\n    public void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    FastScanner in;\n    PrintWriter out;\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic void dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[] a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[] a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic List<Integer>[]createGraph(int n)\n    {List<Integer>[]g=new List[n];for(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor(int i=q-1; i>=0; i--){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] list = new int[q+1];\n\t\tint[] index = new int[q];\n\t\tint sz = 0;\n\t\tboolean[] set = new boolean[m+1];\n\t\tboolean[] used = new boolean[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tif(set[a[i]]) continue;\n\t\t\tlist[sz] = a[i];\n\t\t\tindex[sz++] = i;\n\t\t\tset[a[i]] = true;\n\t\t\tused[i] = true;\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(!set[i]){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist[sz] = min;\n\t\twhile(sz>0 && list[sz-1]<list[sz]) sz--;\n\t\tif(sz==0){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif((long)sz*n>q){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tint[] table = new int[m+1];\n\t\tArrays.fill(table, -1);\n\t\tint[] cnt = new int[sz];\n\t\tfor(int i=0; i<sz; i++){\n\t\t\ttable[list[i]] = i;\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int ti = table[a[i]];\n\t\t\tif(used[i] || ti == -1) continue;\n\t\t\tcnt[ti]++;\n\t\t\tif(ti < sz-1 && cnt[ti] > cnt[ti+1]){\n\t\t\t\tcnt[sz+1] = 1;\n\t\t\t\tSystem.out.println(\"No1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<sz; i++){\n\t\t\tif(cnt[i]<n){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfor(int i=1; i<n; i++){\n//\t\t\tint idx = 0;\n//\t\t\tfor(int j=0; j<q; j++){\n//\t\t\t\tif(used[j] || list[idx]!=a[j]) continue;\n//\t\t\t\tused[j] = true;\n//\t\t\t\tidx++;\n//\t\t\t\tif(idx>=sz) break;\n//\t\t\t}\n//\t\t\tif(idx != sz){\n//\t\t\t\tSystem.out.println(\"No2\");\n//\t\t\t\treturn;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n@SuppressWarnings(\"serial\")\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n \n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    int[] f(int[] a, int M) {\n      int Q = a.length;\n      TreeSet<Integer> set = new TreeSet<>();\n      ArrayList<Integer> list = new ArrayList<>();\n      for (int i = Q - 1; i >= 0; i--) {\n        if (set.contains(a[i])) continue;\n        list.add(a[i]);\n        set.add(a[i]);\n      }\n\n      for (int i = 0; i < M; i++) {\n        if (set.contains(i)) continue;\n        list.add(i);\n      }\n\n      int[] ret = new int[M];\n      for (int i = 0; i < M; i++) {\n        ret[list.get(i)] = i;\n      }\n      return ret;\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n      int Q = in.nextInt();\n      int[] a = new int[Q];\n      for (int i = 0; i < Q; i++) a[i] = in.nextInt() - 1;\n\n      int[] pos = f(a, M);\n      int K = M - 1;\n      for (int i = M - 1; i >= 1; i--) {\n        if (pos[i] > pos[i - 1]) K--;\n        else break;\n      }\n\n      int[] freq = new int[M + 1];\n      freq[0] = N;\n      for (int i = Q - 1; i >= 0; i--) {\n        int p = pos[a[i]];\n        if (freq[p] == 0) {\n          out.println(\"No\");\n          return;\n        }\n        freq[p]--;\n        freq[p + 1]++;\n      }\n\n      for (int i = 0; i < K; i++) {\n        if (freq[i] > 0) {\n          out.println(\"No\");\n          return;\n        }\n      }\n      out.println(\"Yes\");\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = in.nextInt() - 1;\n\t\t}\n\t\tint[] pos = new int[m];\n\t\tArrays.fill(pos, -1);\n\t\tint nowPos = 0;\n\t\tint[] cnt = new int[m];\n\t\tint[] vals = new int[m];\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint id = a[i];\n\t\t\tif (pos[id] == -1) {\n\t\t\t\tvals[nowPos] = id;\n\t\t\t\tpos[id] = nowPos;\n\t\t\t\tnowPos++;\n\t\t\t}\n\t\t\tcnt[pos[id]]++;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (cnt[i] != n) {\n\t\t\t\tboolean[] all = new boolean[m];\n\t\t\t\tArrays.fill(all, true);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (pos[j] != -1 && pos[j] < i) {\n\t\t\t\t\t\tall[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint it = 0;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int j = i; j < nowPos; j++) {\n\t\t\t\t\twhile (!all[it]) {\n\t\t\t\t\t\tit++;\n\t\t\t\t\t}\n\t\t\t\t\tif (it != vals[j]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tout.println(ok ? \"Yes\" : \"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"Yes\");\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew Main().runIO();\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt(); // arrays\n\t\tint m = nextInt(); // numbers in each array\n\t\tint q = nextInt();\n\t\tint[] a = new int[q];\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\t\n\t\tTreeSet<Integer>[] sets = new TreeSet[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tsets[i] = new TreeSet<>();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tsets[a[i]].add(i);\n\t\t}\n\t\t\n\t\tboolean[] used = new boolean[m];\n\t\t\n\t\tint[] ptrs = new int[n];\n\t\tArrays.fill(ptrs, -1);\n\t\t\n\t\tint curPos = 0;\n\t\t\n\t\tint lastProper = -1;\n\t\t\n\t\touter: while (true) { // ?\n\t\t\twhile (curPos < q && used[a[curPos]]) {\n\t\t\t\tcurPos++;\n\t\t\t}\n\t\t\t\n\t\t\tif (curPos == q) { // huh?\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint num = a[curPos];\n\t\t\tused[num] = true;\n\t\t\t\n\t\t\tint prev = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tInteger newPtr = sets[num].higher(Math.max(prev, ptrs[i]));\n\t\t\t\tif (newPtr == null) {\n\t\t\t\t\tlastProper = num;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tsets[num].remove(newPtr);\n\t\t\t\tptrs[i] = newPtr;\n\t\t\t\tprev = newPtr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Integer> rest = new ArrayList<>();\n\t\trest.add(lastProper);\n\t\tfor (int i = curPos; i < q; i++) {\n\t\t\tif (!used[a[i]]) {\n\t\t\t\trest.add(a[i]);\n\t\t\t\tused[a[i]] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < rest.size() - 1; i++) {\n\t\t\tif (rest.get(i) > rest.get(i + 1)) {\n\t\t\t\tout.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"Yes\");\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint Q = ni();\n\t\tint[] a = na(Q);\n\t\t\n\t\tNode root = null;\n\t\tNode[] nodes = new Node[m+1];\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tnodes[i] = new Node(i);\n\t\t\troot = merge(root, nodes[i]);\n\t\t}\n\t\tint dec = 0;\n\t\tfor(int i = 0;i < Q;i++){\n\t\t\tint K = index(nodes[a[i]]);\n\t\t\troot = erase(root, K);\n\t\t\troot = merge(nodes[a[i]], root);\n\t\t}\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tNode cur = nodes[i];\n\t\t\tNode nex = next(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t}\n\t\tif(dec == 0){\n\t\t\tout.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] fs = new int[n];\n\t\tArrays.fill(fs, Q);\n\t\tint[][] buc = makeBuckets(a, m);\n\t\tboolean[] used = new boolean[m+1];\n\t\tout:\n\t\tfor(int i = Q-1;i >= 0;i--){\n\t\t\tif(used[a[i]])continue;\n\t\t\tused[a[i]] = true;\n\t\t\tif(buc[a[i]].length < n)break;\n\t\t\tint j = buc[a[i]].length-1;\n\t\t\tfor(int k = n-1;k >= 0;k--){\n\t\t\t\twhile(j >= 0 && buc[a[i]][j] >= fs[k]){\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif(j == -1)break out;\n\t\t\t\tfs[k] = buc[a[i]][j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\t\n\t\t\tNode cur = nodes[a[i]];\n\t\t\tNode nex = next(cur);\n\t\t\tNode pre = prev(cur);\n\t\t\tif(nex != null && cur.v >= nex.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && pre.v >= cur.v){\n\t\t\t\tdec--;\n\t\t\t}\n\t\t\tif(pre != null && nex != null && pre.v >= cur.v){\n\t\t\t\tdec++;\n\t\t\t}\n\t\t\troot = erase(root, index(cur));\n\t\t\tif(dec == 0){\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\t\treturn;\n\t}\n\t\n\t\n\tpublic static int[][] makeBuckets(int[] a, int sup)\n\t{\n\t\tint n = a.length;\n\t\tint[][] bucket = new int[sup+1][];\n\t\tint[] bp = new int[sup+1];\n\t\tfor(int i = 0;i < n;i++)bp[a[i]]++;\n\t\tfor(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];\n\t\tfor(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;\n\t\treturn bucket;\n\t}\n\t\n\n\tpublic static Random gen = new Random();\n\t\n\tstatic public class Node\n\t{\n\t\tpublic int v; // value\n\t\tpublic long priority;\n\t\tpublic Node left, right, parent;\n\t\t\n\t\tpublic int count;\n\t\t\n\t\tpublic Node(int v)\n\t\t{\n\t\t\tthis.v = v;\n\t\t\tpriority = gen.nextLong();\n\t\t\tupdate(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"Node [v=\");\n\t\t\tbuilder.append(v);\n\t\t\tbuilder.append(\", count=\");\n\t\t\tbuilder.append(count);\n\t\t\tbuilder.append(\", parent=\");\n\t\t\tbuilder.append(parent != null ? parent.v : \"null\");\n\t\t\tbuilder.append(\"]\");\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\tpublic static Node update(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.count = 1;\n\t\tif(a.left != null)a.count += a.left.count;\n\t\tif(a.right != null)a.count += a.right.count;\n\t\t\n\t\t// TODO\n\t\treturn a;\n\t}\n\t\n\tpublic static void propagate(Node x)\n\t{\n\t\tfor(;x != null;x = x.parent)update(x);\n\t}\n\t\n\tpublic static Node disconnect(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.left = a.right = a.parent = null;\n\t\treturn update(a);\n\t}\n\t\n\tpublic static Node root(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\twhile(x.parent != null)x = x.parent;\n\t\treturn x;\n\t}\n\t\n\tpublic static int count(Node a)\n\t{\n\t\treturn a == null ? 0 : a.count;\n\t}\n\t\n\tpublic static void setParent(Node a, Node par)\n\t{\n\t\tif(a != null)a.parent = par;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b, Node... c)\n\t{\n\t\tNode x = merge(a, b);\n\t\tfor(Node n : c)x = merge(x, n);\n\t\treturn x;\n\t}\n\t\n\tpublic static Node merge(Node a, Node b)\n\t{\n\t\tif(b == null)return a;\n\t\tif(a == null)return b;\n\t\tif(a.priority > b.priority){\n\t\t\tsetParent(a.right, null);\n\t\t\tsetParent(b, null);\n\t\t\ta.right = merge(a.right, b);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tsetParent(a, null);\n\t\t\tsetParent(b.left, null);\n\t\t\tb.left = merge(a, b.left);\n\t\t\tsetParent(b.left, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\tpublic static Node[] split(Node x)\n\t{\n\t\tif(x == null)return new Node[]{null, null};\n\t\tif(x.left != null)x.left.parent = null;\n\t\tNode[] sp = new Node[]{x.left, x};\n\t\tx.left = null;\n\t\tupdate(x);\n\t\twhile(x.parent != null){\n\t\t\tNode p = x.parent;\n\t\t\tx.parent = null;\n\t\t\tif(x == p.left){\n\t\t\t\tp.left = sp[1];\n\t\t\t\tif(sp[1] != null)sp[1].parent = p;\n\t\t\t\tsp[1] = p;\n\t\t\t}else{\n\t\t\t\tp.right = sp[0];\n\t\t\t\tif(sp[0] != null)sp[0].parent = p;\n\t\t\t\tsp[0] = p;\n\t\t\t}\n\t\t\tupdate(p);\n\t\t\tx = p;\n\t\t}\n\t\treturn sp;\n\t}\n\t\n\tpublic static Node[] split(Node a, int... ks)\n\t{\n\t\tint n = ks.length;\n\t\tif(n == 0)return new Node[]{a};\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tif(ks[i] > ks[i+1])throw new IllegalArgumentException(Arrays.toString(ks));\n\t\t}\n\t\t\n\t\tNode[] ns = new Node[n+1];\n\t\tNode cur = a;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tNode[] sp = split(cur, ks[i]);\n\t\t\tcur = sp[0];\n\t\t\tns[i] = sp[0];\n\t\t\tns[i+1] = sp[1];\n\t\t}\n\t\treturn ns;\n\t}\n\t\n\t// [0,K),[K,N)\n\tpublic static Node[] split(Node a, int K)\n\t{\n\t\tif(a == null)return new Node[]{null, null};\n\t\tif(K <= count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tNode[] s = split(a.left, K);\n\t\t\ta.left = s[1];\n\t\t\tsetParent(a.left, a);\n\t\t\ts[1] = update(a);\n\t\t\treturn s;\n\t\t}else{\n\t\t\tsetParent(a.right, null);\n\t\t\tNode[] s = split(a.right, K-count(a.left)-1);\n\t\t\ta.right = s[0];\n\t\t\tsetParent(a.right, a);\n\t\t\ts[0] = update(a);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tpublic static Node insertb(Node root, Node x)\n\t{\n\t\tint ind = lowerBound(root, x.v);\n\t\treturn insert(root, ind, x);\n\t}\n\t\n\tpublic static Node insert(Node a, int K, Node b)\n\t{\n\t\tif(a == null)return b;\n\t\tif(b.priority < a.priority){\n\t\t\tif(K <= count(a.left)){\n\t\t\t\ta.left = insert(a.left, K, b);\n\t\t\t\tsetParent(a.left, a);\n\t\t\t}else{\n\t\t\t\ta.right = insert(a.right, K-count(a.left)-1, b);\n\t\t\t\tsetParent(a.right, a);\n\t\t\t}\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tNode[] ch = split(a, K);\n\t\t\tb.left = ch[0]; b.right = ch[1];\n\t\t\tsetParent(b.left, b);\n\t\t\tsetParent(b.right, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\t// delete K-th\n\tpublic static Node erase(Node a, int K)\n\t{\n\t\tif(a == null)return null;\n\t\tif(K < count(a.left)){\n\t\t\ta.left = erase(a.left, K);\n\t\t\tsetParent(a.left, a);\n\t\t\treturn update(a);\n\t\t}else if(K == count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tsetParent(a.right, null);\n\t\t\tNode aa = merge(a.left, a.right);\n\t\t\tdisconnect(a);\n\t\t\treturn aa;\n\t\t}else{\n\t\t\ta.right = erase(a.right, K-count(a.left)-1);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}\n\t}\n\t\n\tpublic static Node get(Node a, int K)\n\t{\n\t\twhile(a != null){\n\t\t\tif(K < count(a.left)){\n\t\t\t\ta = a.left;\n\t\t\t}else if(K == count(a.left)){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tK = K - count(a.left)-1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int index(Node a)\n\t{\n\t\tif(a == null)return -1;\n\t\tint ind = count(a.left);\n\t\twhile(a != null){\n\t\t\tNode par = a.parent;\n\t\t\tif(par != null && par.right == a){\n\t\t\t\tind += count(par.left) + 1;\n\t\t\t}\n\t\t\ta = par;\n\t\t}\n\t\treturn ind;\n\t}\n\t\n\tpublic static Node mergeTechnically(Node x, Node y)\n\t{\n\t\tif(count(x) > count(y)){\n\t\t\tNode d = x; x = y; y = d;\n\t\t}\n\t\t// |x|<=|y|\n\t\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\n\t\treturn y;\n\t}\n\t\n\tpublic static int lowerBound(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v >= q){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn lcount;\n\t}\n\t\n\tpublic static int search(Node a, int q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tif(a.v == q){\n\t\t\t\tlcount += count(a.left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q < a.v){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a == null ? -(lcount+1) : lcount;\n\t}\n\t\n\tpublic static Node next(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.right != null){\n\t\t\tx = x.right;\n\t\t\twhile(x.left != null)x = x.left;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.left == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node prev(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\tif(x.left != null){\n\t\t\tx = x.left;\n\t\t\twhile(x.right != null)x = x.right;\n\t\t\treturn x;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tNode p = x.parent;\n\t\t\t\tif(p == null)return null;\n\t\t\t\tif(p.right == x)return p;\n\t\t\t\tx = p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node[] nodes(Node a) { return nodes(a, new Node[a.count], 0, a.count); }\n\tpublic static Node[] nodes(Node a, Node[] ns, int L, int R)\n\t{\n\t\tif(a == null)return ns;\n\t\tnodes(a.left, ns, L, L+count(a.left));\n\t\tns[L+count(a.left)] = a;\n\t\tnodes(a.right, ns, R-count(a.right), R);\n\t\treturn ns;\n\t}\n\t\n\t// faster than nodes but inconsistent\n\tpublic static Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.count], new int[]{0}); }\n\tpublic static Node[] nodesdfs(Node a, Node[] ns, int[] pos)\n\t{\n\t\tif(a == null)return ns;\n\t\tns[pos[0]++] = a;\n\t\tnodesdfs(a.left, ns, pos);\n\t\tnodesdfs(a.right, ns, pos);\n\t\treturn ns;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\t\n\t\tint[] as = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tas[i] = sc.nextInt();\n\t\t}\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tSet<Integer> set = new HashSet<>();\n\t\tset.add(1);\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap.put(i, 0);\n\t\t}\n\n\t\tint j = 0;\n\t\twhile(j < q){\n\t\t\tint a = as[j];\n\t\t\tint curr = map.get(a);\n\t\t\tif (curr == n - 1) {\n\t\t\t\tmap.put(a, 0);\n\t\t\t\tset.add(a);\n\t\t\t} else {\n\t\t\t\tmap.put(a, curr + 1);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (map.get(i) > 0 && !set.contains(i)) {\n\t\t\t\tmap.clear();\n\t\t\t\tset.clear();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tset.add(1);\n\n\t\t\t\tfor (int z = 1; z <= m; z++) {\n\t\t\t\t\tmap.put(z, 0);\n\t\t\t\t}\n\n\t\t\t\tint z = 0;\n\t\t\t\twhile(z < q){\n\t\t\t\t\tif(is(as, z, m)){\n\t\t\t\t\t\tz += m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint a = as[z];\n\t\t\t\t\tint curr = map.get(a);\n\t\t\t\t\tif (curr == n - 1) {\n\t\t\t\t\t\tmap.put(a, 0);\n\t\t\t\t\t\tset.add(a);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap.put(a, curr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tz++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int q1 = 1; q1 <= m; q1++) {\n\t\t\t\t\tif (map.get(q1) > 0 && !set.contains(q1)) {\t\n\t\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n\tpublic static boolean is(int[] as, int j, int m){\n\t\tif (j + m > as.length)\n\t\t\treturn false;\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor (int i = j ; i < j+m; i++){\n\t\t\tif (set.contains(as[i])){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tset.add(as[i]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\t\n\t\tint[] as = new int[q];\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tSet<Integer> set = new HashSet<>();\n\t\tset.add(1);\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap.put(i, 0);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tas[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tint j = 0;\n\t\twhile(j < q){\n\t\t\tif(is(as, j, m)){\n\t\t\t\tj += m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a = as[j];\n\t\t\tint curr = map.get(a);\n\t\t\tif (curr == n - 1) {\n\t\t\t\tmap.put(a, 0);\n\t\t\t\tset.add(a);\n\t\t\t} else {\n\t\t\t\tmap.put(a, curr + 1);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (map.get(i) > 0 && !set.contains(i)) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n\tpublic static boolean is(int[] as, int j, int m){\n\t\tif (j + m > as.length)\n\t\t\treturn false;\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor (int i = j ; i < j+m; i++){\n\t\t\tif (set.contains(as[i])){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tset.add(as[i]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int m = in.readInt();\n            int n = in.readInt();\n            int q = in.readInt();\n            int[] a = new int[q + 1];\n            for (int i = 1; i <= q; i++) {\n                a[i] = in.readInt();\n            }\n            Order[] order = new Order[n + 1];\n            for (int i = 1; i <= n; i++) {\n                order[i] = new Order();\n                order[i].val = i;\n                order[i].last = -i;\n            }\n            IntList[] list = new IntList[n + 1];\n            for (int i = 1; i <= n; i++) {\n                list[i] = new IntList();\n            }\n            for (int i = 1; i <= q; i++) {\n                list[a[i]].add(i);\n                order[a[i]].last = i;\n            }\n\n            Arrays.sort(order, 1, n + 1, (x, y) -> -Integer.compare(x.last, y.last));\n\n            int incUntil = n;\n            while (incUntil > 1 && order[incUntil - 1].val < order[incUntil].val) {\n                incUntil--;\n            }\n\n            IntList tmp = new IntList(n);\n            for (int i = 1; i < incUntil; i++) {\n                int x = order[i].val;\n                int y = order[i + 1].val;\n                if (list[x].size() < m) {\n                    no(out);\n                    return;\n                }\n\n                if (i + 1 == incUntil) {\n                    break;\n                }\n\n                tmp.clear();\n                for (int j = 0, k = 0; j < m && k < list[y].size(); j++) {\n                    int index = list[x].get(j);\n                    while (k < list[y].size() && list[y].get(k) < index) {\n                        k++;\n                    }\n                    if (k == list[y].size()) {\n                        no(out);\n                        return;\n                    }\n                    tmp.add(list[y].get(k));\n                    k++;\n                }\n\n                list[y].clear();\n                list[y].addAll(tmp);\n            }\n\n            yes(out);\n        }\n\n        public void no(FastOutput out) {\n            out.println(\"No\");\n        }\n\n        public void yes(FastOutput out) {\n            out.println(\"Yes\");\n        }\n\n    }\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        public void ensureSpace(int need) {\n            int req = size + need;\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntList)) {\n                return false;\n            }\n            IntList other = (IntList) obj;\n            return SequenceUtils.equal(data, other.data, 0, size - 1, 0, other.size - 1);\n        }\n\n    }\n    static class Order {\n        int val;\n        int last;\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int[] b, int al, int ar, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    int n;\n    int m;\n    int q;\n    int[] a;\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        getinput();\n        bool[] check = new bool[m];\n        int[] counts = new int[m];\n        int[] place = new int[m];\n        int[] s = new int[m];\n        int count = m-2;\n        for(int i=0;i<m;i++){\n            check[i]=false;\n            counts[i] = 0;\n        }\n        {\n            int j = 0;\n            for(int i=q-1;i>=0;i--){\n                if(!check[a[i]]){\n                    check[a[i]] = true;\n                    place[a[i]] = j;\n                    s[j] = a[i];\n                    j++;\n                }\n            }\n            for(int i=0;i<m;i++){\n                if(!check[i]){\n                    place[i] = j;\n                    s[j] = i;\n                    j++;\n                }\n            }\n        }\n        for(int i =  q-1;i>=0;i--){\n            if(counts[place[a[i]]]<n){\n                if(place[a[i]] != 0 && counts[place[a[i]]-1] > counts[place[a[i]]]){\n                    counts[place[a[i]]]++;\n                }\n            }\n        }\n        while(count >= 0){\n            if(s[count]<s[count+1]){\n                count--;\n            }\n            else{\n                break;\n            }\n        }\n        if(count>=0 && counts[count]<n){\n            Console.WriteLine(\"No\");\n        }\n        else{\n            Console.WriteLine(\"Yes\");\n        }\n        // for(int i=0;i<=count;i++){\n        //     if(counts[i]<n){\n        //         Console.WriteLine(\"No\");\n        //         return;\n        //     }\n        // }\n        // Console.WriteLine(\"Yes\");\n    }\n    void getinput(){\n        string[] str = Console.ReadLine().Split(' ');\n        n = int.Parse(str[0]);\n        m = int.Parse(str[1]);\n        q = int.Parse(Console.ReadLine());\n        str = Console.ReadLine().Split(' ');\n        a = new int[q];\n        for(int i=0;i<q;i++){\n            a[i] = int.Parse(str[i])-1;\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var q = sc.Integer();\n            var a = sc.Integer(q);\n            var state = new List<int>() { -1 };\n            var cnt = new List<int>() { n };\n            var used = new Dictionary<int, int>();\n            for (int i = q - 1; i >= 0; i--)\n            {\n                var x = a[i];\n                if (used.ContainsKey(x))\n                {\n                    var y = used[x];\n                    if (cnt[y - 1] > 0)\n                    {\n                        cnt[y]++; cnt[y - 1]--;\n                    }\n                }\n                else\n                {\n                    var y = state.Count;\n                    used[x] = y;\n                    state.Add(x); cnt.Add(1); cnt[y - 1]--;\n                }\n            }\n            var ok = cnt.Last() == n;\n            if (!ok)\n            {\n                var num = 0;\n                num += cnt.Last(); cnt.RemoveAt(cnt.Count - 1);\n                num += cnt.Last();\n\n                var front = state.Last();\n                var k = 0;\n                for (int i = 1; i <= front; i++)\n                    if (used.ContainsKey(i)) k++;\n                ok |= num == n && k == front;\n            }\n            if (!ok)\n            {\n                var otaku = true;\n                for (int i = 1; i < state.Count; i++)\n                    if (state[i] != i) otaku = false;\n                ok |= otaku;\n\n            }\n            IO.Printer.Out.WriteLine((ok) ? \"Yes\" : \"No\");\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N, M, Q;\n\t\tint[] a;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N, out M);\n\t\t\tsc.Read(out Q);\n\t\t\ta = sc.ReadMany<int>();\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\t{\n\t\t\t\tvar b = new int[Q];\n\t\t\t\tfor (var i = 0; i < Q; i++) b[i] = a[Q - i - 1] - 1;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tvar ans = new List<int>();\n\t\t\t{\n\t\t\t\tvar s = new HashSet<int>();\n\t\t\t\tfor (var i = 0; i < Q; i++) if (!s.Contains(a[i])) { s.Add(a[i]); ans.Add(a[i]); }\n\t\t\t\tfor (var i = 0; i < M; i++) if (!s.Contains(i)) ans.Add(i);\n\t\t\t}\n\t\t\tvar rev = new Dictionary<int, int>();\n\t\t\tfor (var i = 0; i < M; i++) rev[ans[i]] = i;\n\t\t\tvar wait = new int[M + 1];\n\t\t\twait[0] = N;\n\t\t\tfor (var i = 0; i < Q; i++)\n\t\t\t{\n\t\t\t\tvar id = rev[a[i]];\n\t\t\t\tif (wait[id] != 0)\n\t\t\t\t{\n\t\t\t\t\twait[id] -= 1;\n\t\t\t\t\twait[id + 1] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0; i < M; i++)\n\t\t\t\tif (wait[i] != 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = i; j < M - 1; j++) if (ans[j] > ans[j + 1]) No();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tYes();\n\t\t}\n\t\tvoid No() { Console.WriteLine(\"No\"); Environment.Exit(0); }\n\t\tvoid Yes() { Console.WriteLine(\"Yes\"); Environment.Exit(0); }\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp == null ? Func.DefaultComparison<T>() : comp; }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp == null ? Func.DefaultComparison<T>() : comp;\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 0, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 0, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 0, IEnumerable<T> source = null) { this.comp = comp == null ? Func.DefaultComparison<T>() : comp; list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn (object)tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1l;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass E { static void Main() => new K(); }\nclass K\n{\n\tconst long InfL = 4011686018427387913L;\n\tint F => int.Parse(Console.ReadLine());\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tint[] G => Console.ReadLine().Split(sep).Select(_ => int.Parse(_)).ToArray();\n\tpublic K()\n\t{\n\t\tvar I = G;\n\t\tint N = I[0], M = I[1], Q = F;\n\t\tI = G;\n\t\tvar a = new int[Q];\n\t\tfor (var i = 0; i < Q; i++) a[i] = I[Q - i - 1] - 1;\n\t\tvar ans = new List<int>(M);\n\t\tvar s = new HashSet<int>();\n\t\tfor (var i = 0; i < Q; i++) if (!s.Contains(a[i])) { s.Add(a[i]); ans.Add(a[i]); }\n\t\tfor (var i = 0; i < M; i++) if (!s.Contains(i)) ans.Add(i);\n\t\tvar rev = new Dictionary<int, int>(M);\n\t\tfor (var i = 0; i < M; i++) rev[ans[i]] = i;\n\t\tvar wait = new int[M + 1];\n\t\twait[0] = N;\n\t\tfor (var i = 0; i < Q; i++)\n\t\t{\n\t\t\tvar id = rev[a[i]];\n\t\t\tif (wait[id] != 0) { wait[id] -= 1; wait[id + 1] += 1; }\n\t\t}\n\t\tfor (var i = 0; i < M; i++)\n\t\t\tif (wait[i] != 0)\n\t\t\t{\n\t\t\t\tfor (var j = i; j < M - 1; j++) if (ans[j] > ans[j + 1]) { Console.WriteLine(\"No\"); return; }\n\t\t\t\tbreak;\n\t\t\t}\n\t\tConsole.WriteLine(\"Yes\");\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    int n;\n    int m;\n    int q;\n    int[] a;\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        getinput();\n        bool[] check = new bool[m];\n        int[] counts = new int[m];\n        int[] place = new int[m];\n        int[] s = new int[m];\n        int count = m-2;\n        for(int i=0;i<m;i++){\n            check[i]=false;\n            counts[i] = 0;\n        }\n        {\n            int j = 0;\n            for(int i=q-1;i>=0;i--){\n                if(!check[a[i]]){\n                    check[a[i]] = true;\n                    place[a[i]] = j;\n                    s[j] = a[i];\n                    j++;\n                }\n            }\n            for(int i=0;i<m;i++){\n                if(!check[i]){\n                    place[i] = j;\n                    s[j] = i;\n                    j++;\n                }\n            }\n        }\n        for(int i =  q-1;i>=0;i--){\n            if(counts[place[a[i]]]<n){\n                if(place[a[i]] == 0 || counts[place[a[i]]-1] > counts[place[a[i]]]){\n                    counts[place[a[i]]]++;\n                }\n            }\n        }\n        while(count >= 0){\n            if(s[count]<s[count+1]){\n                count--;\n            }\n            else{\n                break;\n            }\n        }\n        if(count>=0 && counts[count]<n){\n            Console.WriteLine(\"No\");\n        }\n        else{\n            Console.WriteLine(\"Yes\");\n        }\n        // for(int i=0;i<=count;i++){\n        //     if(counts[i]<n){\n        //         Console.WriteLine(\"No\");\n        //         return;\n        //     }\n        // }\n        // Console.WriteLine(\"Yes\");\n    }\n    void getinput(){\n        string[] str = Console.ReadLine().Split(' ');\n        n = int.Parse(str[0]);\n        m = int.Parse(str[1]);\n        q = int.Parse(Console.ReadLine());\n        str = Console.ReadLine().Split(' ');\n        a = new int[q];\n        for(int i=0;i<q;i++){\n            a[i] = int.Parse(str[i])-1;\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m;\n        sc.Multi(out n, out m);\n        int q = sc.Int;\n        var a = sc.IntArr.Reverse();\n        var allcnts = new int[m + 1];\n        foreach (var item in a)\n        {\n            ++allcnts[item];\n        }\n        var cnts = new int[m + 1];\n        var nums = new int[m + 1];\n        var ind = new int[m + 1];\n        int c = 0;\n        cnts[0] = M;\n        int ok = 1;\n        foreach (var item in a)\n        {\n            if (cnts[item] == 0) {\n                ind[item] = ++c;\n                nums[c] = item;\n            }\n            ++cnts[item];\n            if (allcnts[item] < n) {\n                if (item != ok) {\n                    DBG(\"No\");\n                    return;\n                }\n                ++ok;\n            }\n            if (cnts[item] > cnts[nums[ind[item] - 1]]) {\n                DBG(\"No\");\n                return;\n            }\n        }\n        Prt(\"Yes\");\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    // static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++)\n        {\n            ret[i + 1] = ret[i] * (n - i) * inv(i + 1);\n        }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var q = sc.Integer();\n            var a = sc.Integer(q);\n            var state = new List<int>() { -1 };\n            var cnt = new List<int>() { n };\n            var used = new Dictionary<int, int>();\n            var A = new List<int>();\n            {\n                var s = new Stack<int>();\n                for (int i = m - 1; i >= 0; i--)\n                    s.Push(i + 1);\n                foreach (var x in a) s.Push(x);\n                var set = new HashSet<int>();\n                while (s.Count > 0)\n                {\n                    var p = s.Pop();\n                    if (set.Add(p)) A.Add(p);\n                }\n\n\n            }\n            for (int i = q - 1; i >= 0; i--)\n            {\n                var x = a[i];\n                if (used.ContainsKey(x))\n                {\n                    var y = used[x];\n                    if (cnt[y - 1] > 0)\n                    {\n                        cnt[y]++; cnt[y - 1]--;\n                    }\n                }\n                else\n                {\n                    var y = state.Count;\n                    used[x] = y;\n                    state.Add(x); cnt.Add(1); cnt[y - 1]--;\n                }\n            }\n            var ok = true;\n            var B = new List<int>();\n            {\n                var s = new Stack<int>();\n                for (int i = m - 1; i >= 0; i--)\n                    s.Push(i + 1);\n                var t = new List<int>();\n                for (int i = 0; i < state.Count; i++)\n                {\n                    if (i != 0)\n                        t.Add(state[i]);\n                    if (cnt[i] != 0 && cnt[i] != n) break;\n                }\n                t.Reverse();\n                foreach (var x in t) s.Push(x);\n                var set = new HashSet<int>();\n                while (s.Count > 0)\n                {\n                    var p = s.Pop();\n                    if (set.Add(p)) B.Add(p);\n                }\n\n            }\n            Debug.WriteLine(A.AsJoinedString());\n            Debug.WriteLine(B.AsJoinedString());\n            for (int i = 0; i < A.Count; i++)\n                if (A[i] != B[i]) ok = false;\n            IO.Printer.Out.WriteLine((ok) ? \"Yes\" : \"No\");\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var q = sc.Integer();\n            var a = sc.Integer(q);\n            var state = new List<int>() { -1 };\n            var cnt = new List<int>() { n };\n            var used = new Dictionary<int, int>();\n            for (int i = q - 1; i >= 0; i--)\n            {\n                var x = a[i];\n                if (used.ContainsKey(x))\n                {\n                    var y = used[x];\n                    if (cnt[y - 1] > 0)\n                    {\n                        cnt[y]++; cnt[y - 1]--;\n                    }\n                }\n                else\n                {\n                    var y = state.Count;\n                    used[x] = y;\n                    state.Add(x); cnt.Add(1); cnt[y - 1]--;\n                }\n            }\n            var ok = cnt.Last() == n;\n            if (!ok)\n            {\n                var num = 0;\n                num += cnt.Last(); cnt.RemoveAt(cnt.Count - 1);\n                num += cnt.Last();\n\n                var front = state.Last();\n                var k = 0;\n                for (int i = 1; i <= front; i++)\n                    if (used.ContainsKey(i)) k++;\n                ok |= num == n && k == front;\n            }\n            if (!ok)\n            {\n                var otaku = true;\n                for (int i = 1; i < state.Count; i++)\n                    if (state[i] != i) otaku = false;\n                ok |= otaku;\n\n            }\n            IO.Printer.Out.WriteLine((ok) ? \"Yes\" : \"No\");\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    int n;\n    int m;\n    int q;\n    int[] a;\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        getinput();\n        bool[] check = new bool[m];\n        int[] counts = new int[m];\n        int[] place = new int[m];\n        int[] s = new int[m];\n        int count = m-2;\n        for(int i=0;i<m;i++){\n            check[i]=false;\n            counts[i] = 0;\n        }\n        {\n            int j = 0;\n            for(int i=q-1;i>=0;i--){\n                if(!check[a[i]]){\n                    check[a[i]] = true;\n                    place[a[i]] = j;\n                    s[j] = a[i];\n                    j++;\n                }\n            }\n            for(int i=0;i<m;i++){\n                if(!check[i]){\n                    place[i] = j;\n                    s[j] = i;\n                    j++;\n                }\n            }\n        }\n        for(int i =  q-1;i>=0;i--){\n            if(counts[place[a[i]]]<n){\n                if(place[a[i]] == 0 || counts[place[a[i]]-1] > counts[place[a[i]]]){\n                    counts[place[a[i]]]++;\n                }\n            }\n        }\n        while(count >= 0){\n            if(s[count]<s[count+1]){\n                count--;\n            }\n            else{\n                break;\n            }\n        }\n        if(count>=0 && counts[count]<n){\n            Console.WriteLine(\"No\");\n        }\n        else{\n            Console.WriteLine(\"Yes\");\n        }\n    }\n    void getinput(){\n        string[] str = Console.ReadLine().Split(' ');\n        n = int.Parse(str[0]);\n        m = int.Parse(str[1]);\n        q = int.Parse(Console.ReadLine());\n        str = Console.ReadLine().Split(' ');\n        a = new int[q];\n        for(int i=0;i<q;i++){\n            a[i] = int.Parse(str[i])-1;\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Solve{\n    int n;\n    int m;\n    int q;\n    int[] a;\n    public Solve(){}\n    public static int Main(){\n        new Solve().Calc();\n        return 0;\n    }\n    void Calc(){\n        getinput();\n        bool[] check = new bool[m];\n        int[] counts = new int[m];\n        int[] place = new int[m];\n        int[] s = new int[m];\n        int count = m-2;\n        for(int i=0;i<m;i++){\n            check[i]=false;\n            counts[i] = 0;\n        }\n        {\n            int j = 0;\n            for(int i=q-1;i>=0;i--){\n                if(!check[a[i]]){\n                    check[a[i]] = true;\n                    place[a[i]] = j;\n                    s[j] = a[i];\n                    j++;\n                }\n            }\n            for(int i=0;i<m;i++){\n                if(!check[i]){\n                    place[i] = j;\n                    s[j] = i;\n                    j++;\n                }\n            }\n        }\n        for(int i =  q-1;i>=0;i--){\n            if(counts[place[a[i]]]<n){\n                counts[place[a[i]]]++;\n                if(place[a[i]] != 0 && counts[place[a[i]]-1] < counts[place[a[i]]]){\n                    Console.WriteLine(\"No\");\n                    return;\n                }\n            }\n        }\n        while(count >= 0){\n            if(s[count]<s[count+1]){\n                count--;\n            }\n            else{\n                break;\n            }\n        }\n        for(int i=0;i<=count;i++){\n            if(counts[i]<n){\n                Console.WriteLine(\"No\");\n                return;\n            }\n        }\n        Console.WriteLine(\"Yes\");\n    }\n    void getinput(){\n        string[] str = Console.ReadLine().Split(' ');\n        n = int.Parse(str[0]);\n        m = int.Parse(str[1]);\n        q = int.Parse(Console.ReadLine());\n        str = Console.ReadLine().Split(' ');\n        a = new int[q];\n        for(int i=0;i<q;i++){\n            a[i] = int.Parse(str[i])-1;\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var q = sc.Integer();\n            var a = sc.Integer(q);\n            var state = new List<int>() { -1 };\n            var cnt = new List<int>() { n };\n            var used = new Dictionary<int, int>();\n            var A = new List<int>();\n            {\n                var s = new Stack<int>();\n                for (int i = n - 1; i >= 0; i--)\n                    s.Push(i + 1);\n                foreach (var x in a.Reverse()) s.Push(x);\n                var set = new HashSet<int>();\n                while (s.Count > 0)\n                {\n                    var p = s.Pop();\n                    if (set.Add(p)) A.Add(p);\n                }\n\n\n            }\n            for (int i = q - 1; i >= 0; i--)\n            {\n                var x = a[i];\n                if (used.ContainsKey(x))\n                {\n                    var y = used[x];\n                    if (cnt[y - 1] > 0)\n                    {\n                        cnt[y]++; cnt[y - 1]--;\n                    }\n                }\n                else\n                {\n                    var y = state.Count;\n                    used[x] = y;\n                    state.Add(x); cnt.Add(1); cnt[y - 1]--;\n                }\n            }\n            var ok = true;\n            var B = new List<int>();\n            {\n                var s = new Stack<int>();\n                for (int i = n - 1; i >= 0; i--)\n                    s.Push(i + 1);\n                var t = new List<int>();\n                for (int i = 0; i < state.Count; i++)\n                {\n                    if (i != 0)\n                        t.Add(state[i]);\n                    if (cnt[i] != 0 && cnt[i] != n) break;\n                }\n                t.Reverse();\n                foreach (var x in t) s.Push(x);\n                var set = new HashSet<int>();\n                while (s.Count > 0)\n                {\n                    var p = s.Pop();\n                    if (set.Add(p)) B.Add(p);\n                }\n\n            }\n            Debug.WriteLine(A.AsJoinedString());\n            Debug.WriteLine(B.AsJoinedString());\n            for (int i = 0; i < A.Count; i++)\n                if (A[i] != B[i]) ok = false;\n            IO.Printer.Out.WriteLine((ok) ? \"Yes\" : \"No\");\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint X, Y, N;\n\t\tTuple<int, int, int>[] ps;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out X, out Y);\n\t\t\tsc.Read(out N);\n\t\t\t//ps = sc.ReadManyLines<int, int, int>(N);\n\t\t\tsc.ReadMany<int>();\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tif (rand.Next(0, 2) == 0) Yes();\n\t\t\telse No();\n\t\t\tvar ls = new Dictionary<int, long>[X];\n\t\t\tfor (var x = 0; x < X; x++) ls[x] = new Dictionary<int, long>();\n\t\t\tforeach (var p in ps) ls[p.Item1 - 1].Add(p.Item2 - 1, p.Item3);\n\t\t\tfor (var x = 0; x < X - 1; x++)\n\t\t\t{\n\t\t\t\tvar last = 0L;\n\t\t\t\tvar line = new Dictionary<int, long>();\n\t\t\t\tforeach (var t in ls[x])\n\t\t\t\t{\n\t\t\t\t\tif (!line.ContainsKey(t.Key)) line.Add(t.Key, 0);\n\t\t\t\t\tline[t.Key] -= t.Value;\n\t\t\t\t}\n\t\t\t\tforeach (var t in ls[x + 1])\n\t\t\t\t{\n\t\t\t\t\tif (!line.ContainsKey(t.Key)) line.Add(t.Key, 0);\n\t\t\t\t\tline[t.Key] += t.Value;\n\t\t\t\t}\n\t\t\t\tvar fix = new HashSet<int>(ls[x].Keys);\n\t\t\t\tfix.IntersectWith(ls[x + 1].Keys);\n\t\t\t\tforeach (var v in line.Values) last = Max(last, v);\n\t\t\t\tif (last < 0) No();\n\t\t\t\tforeach (var k in fix) if (last != line[k]) No();\n\t\t\t\tforeach (var k in line.Keys) if (line[k] < last && ls[x].ContainsKey(k) && !ls[x + 1].ContainsKey(k)) ls[x + 1].Add(k, ls[x][k] + last);\n\t\t\t}\n\t\t\tthrow new Exception();\n\t\t\tif (rand.Next(0, 2) == 0) Yes();\n\t\t\telse No();\n\t\t}\n\t\tvoid No() { Console.WriteLine(\"No\"); Environment.Exit(0); }\n\t\tvoid Yes() { Console.WriteLine(\"Yes\"); Environment.Exit(0); }\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp == null ? Func.DefaultComparison<T>() : comp; }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp == null ? Func.DefaultComparison<T>() : comp;\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 0, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 0, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 0, IEnumerable<T> source = null) { this.comp = comp == null ? Func.DefaultComparison<T>() : comp; list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn (object)tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1l;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint X, Y, N;\n\t\tTuple<int, int, int>[] ps;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out X, out Y);\n\t\t\tsc.Read(out N);\n\t\t\t//ps = sc.ReadManyLines<int, int, int>(N);\n\t\t\tsc.ReadMany<int>();\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tYes();\n\t\t\tif (rand.Next(0, 2) == 0) Yes();\n\t\t\telse No();\n\t\t\tvar ls = new Dictionary<int, long>[X];\n\t\t\tfor (var x = 0; x < X; x++) ls[x] = new Dictionary<int, long>();\n\t\t\tforeach (var p in ps) ls[p.Item1 - 1].Add(p.Item2 - 1, p.Item3);\n\t\t\tfor (var x = 0; x < X - 1; x++)\n\t\t\t{\n\t\t\t\tvar last = 0L;\n\t\t\t\tvar line = new Dictionary<int, long>();\n\t\t\t\tforeach (var t in ls[x])\n\t\t\t\t{\n\t\t\t\t\tif (!line.ContainsKey(t.Key)) line.Add(t.Key, 0);\n\t\t\t\t\tline[t.Key] -= t.Value;\n\t\t\t\t}\n\t\t\t\tforeach (var t in ls[x + 1])\n\t\t\t\t{\n\t\t\t\t\tif (!line.ContainsKey(t.Key)) line.Add(t.Key, 0);\n\t\t\t\t\tline[t.Key] += t.Value;\n\t\t\t\t}\n\t\t\t\tvar fix = new HashSet<int>(ls[x].Keys);\n\t\t\t\tfix.IntersectWith(ls[x + 1].Keys);\n\t\t\t\tforeach (var v in line.Values) last = Max(last, v);\n\t\t\t\tif (last < 0) No();\n\t\t\t\tforeach (var k in fix) if (last != line[k]) No();\n\t\t\t\tforeach (var k in line.Keys) if (line[k] < last && ls[x].ContainsKey(k) && !ls[x + 1].ContainsKey(k)) ls[x + 1].Add(k, ls[x][k] + last);\n\t\t\t}\n\t\t\tthrow new Exception();\n\t\t\tif (rand.Next(0, 2) == 0) Yes();\n\t\t\telse No();\n\t\t}\n\t\tvoid No() { Console.WriteLine(\"No\"); Environment.Exit(0); }\n\t\tvoid Yes() { Console.WriteLine(\"Yes\"); Environment.Exit(0); }\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp == null ? Func.DefaultComparison<T>() : comp; }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp == null ? Func.DefaultComparison<T>() : comp;\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 0, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 0, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 0, IEnumerable<T> source = null) { this.comp = comp == null ? Func.DefaultComparison<T>() : comp; list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn (object)tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1l;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m;\n        sc.Multi(out n, out m);\n        int q = sc.Int;\n        var a = sc.IntArr.Reverse();\n        var cnts = new int[m + 1];\n        var nums = new int[m + 1];\n        var ind = new int[m + 1];\n        int c = 0;\n        cnts[0] = M;\n        int ok = 1;\n        foreach (var item in a)\n        {\n            if (cnts[item] == 0) {\n                ind[item] = ++c;\n                nums[c] = item;\n            }\n            ++cnts[item];\n            if (cnts[item] > cnts[nums[ind[item] - 1]]) {\n                if (item != ok) {\n                    DBG(\"No\");\n                    return;\n                }\n                ++ok;\n            }\n        }\n        Prt(\"Yes\");\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    // static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++)\n        {\n            ret[i + 1] = ret[i] * (n - i) * inv(i + 1);\n        }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "console.log('argv', process.argv);"
  },
  {
    "language": "Ruby",
    "code": "if rand(2)==1\n  puts(\"Yes\")\nelse\n  puts(\"No\")\nend"
  },
  {
    "language": "Ruby",
    "code": "puts 'No'"
  },
  {
    "language": "Ruby",
    "code": "def evaluate\n  raw = gets.split(/\\s/)\n  n = raw.first.to_i\n  m = raw.last.to_i\n  q = gets.to_i\n  moves = gets.split(/\\s/).collect{|x| x.to_i }.select{|x| x > 1}\n  real_q = moves.size\n\n  return \"No\" if (m + n) % real_q == 1\n\n  \"Yes\"\nend\n\nputs evaluate"
  },
  {
    "language": "PHP",
    "code": "xaad"
  },
  {
    "language": "OCaml",
    "code": "module S =\n  Set.Make (struct\n      type t = int\n      let compare = compare\n    end)\n\nlet id x = x\n\nlet init n f =\n  let rec loop i l = if i < n then loop (i + 1) (f i :: l) else l in\n  List.rev (loop 0 [])\n\nlet rec is_sorted = function\n    [] -> true\n  | [_] -> true\n  | x :: y :: l -> if compare x y <= 0 then is_sorted (y :: l) else false\n\nlet n = Scanf.scanf \" %d\" id\nlet m = Scanf.scanf \" %d\" id\nlet q = Scanf.scanf \" %d\" id\nlet a =\n  init q (fun _ -> Scanf.scanf \" %d\" id)\n  |> List.rev\n\nlet () =\n  let cnt = Array.make (m + 1) 0 in\n  let nxt = Array.make (m + 1) None in\n  let root = ref (-1) in\n  let f (cur, ts) a =\n    if cnt.(a) > 0 then\n      let nxt = match nxt.(a) with\n          Some nxt -> nxt\n        | None -> raise (Failure \"\") in\n      let () = cnt.(a) <- cnt.(a) - 1;\n               cnt.(nxt) <- cnt.(nxt) + 1 in\n      (cur, ts)\n    else\n      match nxt.(a) with\n        Some _ -> (cur, ts) (* do nothing *)\n      | None -> match cur with\n                  None -> let () = root := a;\n                                   nxt.(a) <- Some 0;\n                                   cnt.(a) <- cnt.(0);\n                                   cnt.(0) <- 0 in\n                          (Some a, S.remove a ts)\n                | Some cur -> let () = nxt.(cur) <- Some a;\n                                       nxt.(a) <- Some 0;\n                                       cnt.(a) <- cnt.(0);\n                                       cnt.(0) <- 0 in\n                              (Some a, S.remove a ts) in\n  let () = cnt.(0) <- n - 1 in\n  let (_, ts) = List.fold_left f (None, S.of_list (init m (fun i -> i + 1))) a in\n  let hs =\n    let rec loop i f l =\n      match nxt.(i) with\n        None -> l\n      | Some nxt -> if cnt.(i) > 0 || f then\n                      loop nxt true (i :: l)\n                    else\n                      loop nxt f l in\n    List.rev (loop !root false []) in\n  let mx = List.fold_left max min_int hs in\n  let mn = try S.min_elt ts with Not_found -> max_int in\n  if is_sorted hs && mx <= mn then\n    print_endline \"Yes\"\n  else\n    print_endline \"No\""
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv;\n\n// import dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m, q;\n    int[] a;\n    sc.read(n, m, q, a);\n\n    bool solve() {\n        int[] co, idx = new int[m]; idx[] = -1;\n\n        int l = 0;\n        foreach_reverse (d; a) {\n            d--;\n            int u = idx[d];\n            if (u == -1) {\n                u = idx[d] = co.length.to!int;\n                co ~= 0;\n            }\n            if (u && co[u-1] == co[u]) {\n                return false;\n            }\n            co[u]++;\n            if (co[u] == n) {\n                l++;\n                idx[d] = -1;\n            }\n        }\n        int a = -1;\n        foreach (i; 0..m) {\n            if (idx[i] == -1) continue;\n\n            if (a != -1 && idx[i]-l-i != a) return false;\n            a = idx[i]-l-i;\n        }\n        return true;\n    }\n\n    if (solve()) {\n        writeln(\"Yes\");\n    } else {\n        writeln(\"No\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nvoid main(){\n    int N, M;\n    readlnTo(N, M);\n    auto Q = readInt();\n    auto a = readInts().map!(\"a-1\").array;\n    int[] aFin;\n    auto set = new RedBlackTree!int;\n    foreach(ai; chain(iota(M).retro, a).retro) {\n        if(ai in set) {\n            continue;\n        }\n        aFin ~= ai;\n        set.insert(ai);\n    }\n    auto before = new int[](M);\n    foreach(i; iota(M-1)) {\n        before[aFin[i+1]] = aFin[i];\n    }\n    before[aFin[0]] = M;\n    auto count = new int[](M+1);\n    count[M] = N;\n    foreach_reverse(ai; a) {\n        if(count[before[ai]] > 0) {\n            --count[before[ai]];\n            ++count[ai];\n            continue;\n        }\n        if(count[ai] > 0) {\n            continue;\n        }\n        writeln(\"No\");\n        return;\n    }\n    /*\n    writeln(count);\n    if(count[M] != 0) {\n        writeln(\"No\");\n        return;\n    }\n    */\n    auto next = new int[](M+1);\n    foreach(i; iota(M-1)) {\n        next[aFin[i]] = aFin[i+1];\n    }\n    next[aFin.back] = M;\n    next[M] = aFin[0];\n    bool test(int n) {\n        if(n == M) {\n            return true;\n        }\n        return next[n] > n && memoize!test(next[n]);\n    }\n    foreach(i; iota(M+1)) {\n        if(count[i] != 0) {\n            if(!test(next[i])) {\n                writeln(\"No\");\n                return;\n            }\n        }\n    }\n    writeln(\"Yes\");\n}\n\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.container.rbtree;\n\n// import dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m, q;\n    int[] a;\n    sc.read(n, m, q, a);\n\n    bool solve() {\n        int[] res;\n        bool[] used = new bool[m];\n        foreach_reverse (d; a) {\n            d--;\n            if (used[d]) continue;\n            used[d] = true;\n            res ~= d;\n        }\n        res ~= iota(m).filter!(i => !used[i]).array;\n        int[] rres = new int[m]; res.each!((i, d) => rres[d] = i.to!int);\n\n        auto tr = redBlackTree!(true)(repeat(0).take(n));\n\n        foreach_reverse (d; a) {\n            d--;\n            int id = rres[d];\n//            writeln(tr);\n            if (id in tr) {\n                tr.removeKey(id);\n                tr.insert(id+1);\n            } else if (tr.upperBound(id).empty) {\n                return false;\n            }\n        }\n//        writeln(tr);\n        int r = iota(m).filter!(i => (i==0 || res[i-1] > res[i])).array.back;\n        return tr.lowerBound(r).empty;\n    }\n\n    if (solve()) {\n        writeln(\"Yes\");\n    } else {\n        writeln(\"No\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv, std.range;\nimport std.container.rbtree;\n\n// import dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m, q;\n    int[] a;\n    sc.read(n, m, q, a);\n\n    bool solve() {\n        int[] res;\n        bool[] used = new bool[m];\n        foreach_reverse (d; a) {\n            d--;\n            if (used[d]) continue;\n            used[d] = true;\n            res ~= d;\n        }\n        res ~= iota(m).filter!(i => !used[i]).array;\n        int[] rres = new int[m]; res.each!((i, d) => rres[d] = i.to!int);\n\n        auto tr = redBlackTree!(true)(repeat(0).take(n).array);\n\n        foreach_reverse (d; a) {\n            d--;\n            int id = rres[d];\n//            writeln(tr);\n            if (id in tr) {\n                tr.removeKey(id);\n                tr.insert(id+1);\n            } else if (tr.upperBound(id).empty) {\n                return false;\n            }\n        }\n//        writeln(tr);\n        int r = iota(m).filter!(i => (i==0 || res[i-1] > res[i])).array.back;\n        return tr.lowerBound(r).empty;\n    }\n\n    if (solve()) {\n        writeln(\"Yes\");\n    } else {\n        writeln(\"No\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\n\nimport std.stdio, std.algorithm, std.conv;\n\n// import dcomp.scanner;\n// import dcomp.container.deque;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m, q;\n    int[] a;\n    sc.read(n, m, q, a);\n\n    bool solve() {\n        int[] co, idx = new int[m]; idx[] = -1;\n\n        int l = 0;\n        foreach_reverse (d; a) {\n            d--;\n            int u = idx[d];\n            if (u == -1) {\n                u = idx[d] = co.length.to!int;\n                co ~= 0;\n            }\n            if (u && co[u-1] == co[u]) {\n                return false;\n            }\n            co[u]++;\n            if (co[u] == n) {\n                l++;\n                idx[d] = -1;\n            }\n        }\n        foreach (i; 0..m) {\n            if (idx[i] == -1) continue;\n            if (idx[i]-l != i) return false;\n        }\n        return true;\n    }\n\n    if (solve()) {\n        writeln(\"Yes\");\n    } else {\n        writeln(\"No\");\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(4L, 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const { assert(p, \"this deque is not init\"); }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nvoid main(){\n    int N, M;\n    readlnTo(N, M);\n    auto Q = readInt();\n    auto a = readInts().map!(\"a-1\").array;\n    int[] aFin;\n    auto set = new RedBlackTree!int;\n    foreach(ai; chain(iota(M).retro, a).retro) {\n        if(ai in set) {\n            continue;\n        }\n        aFin ~= ai;\n        set.insert(ai);\n    }\n    auto before = new int[](M);\n    foreach(i; iota(M-1)) {\n        before[aFin[i+1]] = aFin[i];\n    }\n    before[aFin[0]] = M;\n    auto count = new int[](M+1);\n    count[M] = N;\n    foreach_reverse(ai; a) {\n        if(count[before[ai]] > 0) {\n            --count[before[ai]];\n            ++count[ai];\n            continue;\n        }\n        if(count[ai] > 0) {\n            continue;\n        }\n        writeln(\"No\");\n        return;\n    }\n    /*\n    writeln(count);\n    if(count[M] != 0) {\n        writeln(\"No\");\n        return;\n    }\n    */\n    auto next = new int[](M+1);\n    foreach(i; iota(M-1)) {\n        next[aFin[i]] = aFin[i+1];\n    }\n    next[M] = aFin[0];\n    next[aFin.back] = M+1;\n    bool test(int n) {\n        if(n == M+1) {\n            return true;\n        }\n        return next[n] > n && memoize!test(next[n]);\n    }\n    foreach(i; iota(M+1)) {\n        if(count[i] != 0) {\n            if(!test(next[i])) {\n                writeln(\"No\");\n                return;\n            }\n        }\n    }\n    writeln(\"Yes\");\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nimport sys\nfrom itertools import product\nreadline = sys.stdin.readline\n\ndef check1(A):\n    K = max(A)\n    table = [-1]*(K+1)\n    for i in range(Q):\n        table[A[i]] = i\n    \n    if -1 in table:\n        return False\n    if any(t1-t2 < 0 for t1, t2 in zip(table, table[1:])):\n        return False\n    return True\n\nINF = 10**9+7\ndef check2(A):\n    stack = []\n    used = set()\n    for a in A[::-1] + list(range(M)):\n        if a not in used:\n            used.add(a)\n            stack.append(a)\n    \n    C = dict()\n    for i in range(M):\n        C[stack[i]] = i\n    \n    table = [0]*M + [INF]\n    for a in A[::-1]:\n        if table[C[a]] < table[C[a]-1]:\n            table[C[a]] += 1\n    \n    used = set()\n    ch = []\n    for i in range(M):\n        if table[i] < N:\n            break\n        ch.append(stack[i])\n        used.add(stack[i])\n    for i in range(M):\n        if i not in used:\n            used.add(i)\n            ch.append(i)\n    \n    return stack == ch\n\nN, M = map(int, readline().split())\nQ = int(readline())\nA = list(map(lambda x: int(x)-1, readline().split()))\n\nans = 'Yes'\nif not check1(A):\n    if not check2(A):\n        ans = 'No'\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\ndef Judge(vector):\n\tlength = len(vector)-1\n\tfor i in range(length):\n\t\tif(vector[i] > vector[i+1]):\t\t\n\t\t\treturn 0\n\treturn 1\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\nfound = set()\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in found):\n\t\tpat.append(i)\n\t\tfound.add(i)\n\t\tpos[i] = counter\n\t\tfreq[counter] -= 1\n\t\tcounter += 1\n\t\tfreq[counter] += 1\n\telif (freq[pos[i]] > 0):\n\t\tfreq[pos[i]] -= 1\n\t\tfreq[pos[i]+1] += 1\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\nfor i in range(M+1):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\nprint(\"Yes\") if Judge(pat[start:]) else print(\"No\")"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\ndef Judge(vector):\n\tlength = len(vector)-1\n\tfor i in range(length):\n\t\tif(vector[i] > vector[i+1]):\t\t\n\t\t\treturn 0\n\treturn 1\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tcounter += 1\n\t\tif(counter == M):\n\t\t\tbreak\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\nfor i in A[::-1]:\n\ttemp = pos[i]\n\tif (freq[temp] > 0):\n\t\tfreq[temp] -= 1\n\t\tfreq[temp+1] += 1\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\nprint(\"Yes\") if Judge(pat[start:]) else print(\"No\")"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in r:\n\t\t\tr.append(n)\n\tfor i in range(m):\n\t\tif (i+1) not in r:\n\t\t\tr.append(i+1)\n\treturn r\n\ndef isSorted(a):\n\tfor i in range(1, len(a)):\n\t\tif a[i-1] > a[i]:\n\t\t\treturn False\n\treturn True\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\ntable = [-1] * (m+1)\nfor i in range(len(r)):\n\ttable[r[i]] = i\n\nfor aa in a[::-1]:\n\tindex = table[aa]\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = 0\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nif isSorted(r[to:]):\n\tprint('Yes')\nelse:\n\tprint('No')\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\n#-*- coding: utf-8 -*-\n# E-LRU Puzle\ndef reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n#Data input\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\n\n#Data structure initial\npos = [-1 for i in range(M)]\npat = []\nfreq = [0 for i in range(M+1)]\nfreq[0] = N\n\n#Pattern search & Match count\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\t--(freq[counter])\n\t\t++counter \n\t\t++(freq[counter])\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\t--freq[temp]\n\t\t\t++freq[temp+1]\n\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\n\n#Result judge\nfor i in freq:\n\tif (i != 0):\n\t\tstart = i\n\t\tbreak\n\ntemp = pat[start:]\ntemp.sort()\nif(temp == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "input()\ninput()\ninput()\n\nprint('Yes')"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\n#-*- coding: utf-8 -*-\n# E-LRU Puzle\ndef reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n#Data input\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\n\n#Data structure initial\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\n\n#Pattern search & Match count\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tfreq[counter] -= 1\n\t\tcounter += 1\n\t\tfreq[counter] += 1\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\tfreq[temp] -= 1\n\t\t\tfreq[temp+1] += 1\n\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\n\n#Result judge\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\n\np = pat[start:]\np.sort()\nif(p == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import random\n\nn, m = map(int, raw_input().split())\nq = int(raw_input())\na = map(int, raw_input().split())\nprint random.choice([\"Yes\", \"No\"])\n"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\ndef Judge(vector):\n\tlength = len(vector)-1\n\tfor i in range(length):\n\t\tif(vector[i] > vector[i+1]):\t\t\n\t\t\treturn 0\n\treturn 1\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\nfound = set()\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in found):\n\t\tpat.append(i)\n\t\tfound.add(i)\n\t\tpos[i] = counter\n\t\tcounter += 1\n\t\tif(counter == M):\n\t\t\tbreak\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\t\nfor i in A[::-1]:\n\ttemp = pos[i]\n\tif (freq[temp] > 0):\n\t\tfreq[temp] -= 1\n\t\tfreq[temp+1] += 1\nstart = M\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\nprint(\"Yes\") if Judge(pat[start:]) else print(\"No\")"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tfreq[counter] -= 1\n\t\tcounter += 1\n\t\tfreq[counter] += 1\n\t\tprint('freq is',freq)\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\tfreq[temp] -= 1\n\t\t\tfreq[temp+1] += 1\n\t\t\tprint('freq is',freq)\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\np = pat[start:]\np.sort()\nif(p == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/code-festival-2016-quala/tasks/codefestival_2016_qualA_e\n\n最後の配列の状態は何で決定されるか。\n同じaが同じ配列に複数回採用されたとき、効果があるのは最後に\n採用したaのみ。(それ以前は合っても無くても同じになる)\n\n最初、1が採用状態になっていると考えてよい。\n→おそらく気にすべきは配列aのみ(Nこの配列は考慮しなくてよい)\n\n1以外は、出現するなら少なくともN個出現しなければ不可能\n2,3だけで考えてみよう\n\nN==3のとき\n\n322233 →不可能(2が先頭が1つ生まれてしまう)\n232233 →可能\n\n→終了後の配列の数字は、最後に出現した順に前から並ぶ\n→よってaを見れば構成後の数列は分かる\n\n→後ろからaを見ていって、先に登場したやつより後に登場したほうが数が越えたらダメ\n→ただし、N個目以降は完全無視する\n→終了時に数がNに達していないのがあったらダメ(1を除く？)\n\nいや例3…\n→初期状態、の扱い方を考え直さなきゃな…\n\naの前に M…M(N個),M-1…M-1,…,1…1 があると考える\nすると、aを後ろから見ていった時に先に登場したやつより後に登場したほうが数が越えてはいけない、\nだけの条件になる！！\n\n\"\"\"\nimport sys\nN,M = map(int,input().split())\n\nQ = int(input())\n\nA = list(map(int,input().split()))\n\ndic = {}\nlis = []\nflag = True\n\na = [[M-i,N] for i in range(M)]\nfor i in range(Q):\n    a.append([A[i],1])\na.reverse()\n\nfor i in range(len(a)):\n\n    if a[i][0] not in dic:\n        ind = len(dic)\n        dic[a[i][0]] = ind\n        lis.append(a[i][1])\n    else:\n        ind = dic[a[i][0]]\n        lis[ind] = min(N,lis[ind] + a[i][1])\n    \n    if ind != 0 and lis[ind] > lis[ind-1]:\n        print (\"No\")\n        sys.exit()\n\nprint (\"Yes\")"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in r:\n\t\t\tr.append(n)\n\tfor i in range(m):\n\t\tif (i+1) not in r:\n\t\t\tr.append(i+1)\n\treturn r\n\ndef isSorted(a):\n\tfor i in range(1, len(a)):\n\t\tif a[i-1] > a[i]:\n\t\t\treturn False\n\treturn True\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\nfor aa in a[::-1]:\n\tindex = r.index(aa)\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = 0\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nif isSorted(r[to:]):\n\tprint('Yes')\nelse:\n\tprint('No')\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in r:\n\t\t\tr.append(n)\n\tfor i in range(m):\n\t\tif (i+1) not in r:\n\t\t\tr.append(i+1)\n\treturn r\n\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\nfor aa in a[::-1]:\n\tindex = r.index(aa)\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = 0\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nleft, right = r[:to], r[to:]\nleft = set(left)\n\nflag = True\nindex = 0\nfor i in range(1, len(r)+1):\n\tif i in left:\n\t\tcontinue\n\tif right[index] != i:\n\t\tflag = False\n\t\tbreak\n\tif right[index] == i:\n\t\tindex += 1\n\nif flag:\n\tprint('Yes')\nelse:\n\tprint('No')\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport itertools as it\n\n\n\nn, m = map(int, raw_input().split())\nnum = int(raw_input())\narr = np.empty(shape=(n,m),dtype=int)\nfor i in range(n):\n    arr[i] = np.arange(1, m+1)\n\n\nst = raw_input()\nq = st.split()\nq = [int(a) for a in q]\n\nlist =[]\nfor i in range (1, n+1):\n    for i in range(1, n + 1):\n        list.append(i)\n        list.append(i)\n        list.append(i)\n\nglobal copy\n\nkol=0\nmySet = []\nmySet = set(it.permutations(list, num))\n\nfor item in mySet:\n    copy = arr.copy()\n    for i in range(0, len(item)):\n        line = copy[item[i]-1]\n        for j in range(0, m):\n            if (line[j] == q[i]):\n                n = j\n        line = np.delete(line, n)\n        line = np.insert(line, 0, q[i])\n        for k in range(0, len(line)):\n            copy[item[i] - 1][k] = line[k]\n\n    if (copy == copy[0]).all():\n        kol+=1\n\n\nif kol>0:\n    print \"Yes\"\nelse:\n    print \"No\""
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\n#-*- coding: utf-8 -*-\n# E-LRU Puzle\n\nfrom collections import defaultdict\ndef ReadInput():\n\treturn [int(a) for a in input().split(' ')]\n\n(N, M) = ReadInput()\nQ = int(input())\nArray = ReadInput()\ndef ifEqual(x):\n\ttemp = None\n\tfor i in x:\n\t\tif (temp == None):\t\n\t\t\ttemp = x[i]\n\t\t\tcontinue\n\t\telif (x[i] != temp):\n\t\t\treturn 0\n\treturn temp\n\ndef check(Array, N, M, *args):\n\tCount = defaultdict(int)\n\tArray.reverse()\n\tfor i in Array:\n\t\tif (i == 1 or Count[i] < Count[i-1]):\n\t\t\tCount[i] += 1\n\tCount.pop(N)\n\tif(ifEqual(Count)):\n\t\treturn 1\n\t\n\tCount = defaultdict(int)\n\tfor i in Array:\n\t\tif (i == N or Count[i] < Count[i+1]):\n\t\t\tCount[i] += 1\n\tCount.pop(1)\n\tif(ifEqual(Count) >= M):\n\t\treturn 1\n\telse:\n\t\treturn 0\nif (check(Array, N, M)):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "printd = print\nprintd= lambda *args:0 #print\nN, M = [int(x) for x in input().split()]\nQ = int(input())\n\na = [int(x) - 1 for x in input().split()]\ntarget = []\n\nfor x in list(reversed(a)) + list(range(M)):\n    if x not in target:\n        target.append(x)\nprintd(target)\nassert len(target) == M\ntarget_length =M-1\nfor i in range(len(target) - 1, 0, -1):\n    if target[i] > target[i-1]:\n        target_length-=1\n    else:\n        break\n\nprintd(target_length)\ncan_trash = set()\n\n\nb = [0 for _ in range(N)]\n\nfor x in reversed(a):\n    _flag =False\n    printd('x:',x)\n    for i, value in enumerate(b):\n        printd(i, value, x, b)\n        if value < M and target[value] == x:\n            b[i] = value + 1\n            printd('value add ',b)\n            can_trash.add(x)\n            _flag = True\n            break\n    if _flag:\n        continue\n\n    if x == 0:\n        if any(val == len(target) for val in b):\n            can_trash.add(0)\n    if x in can_trash:\n        continue\n\n    else:\n        print('No')\n        exit()\n\nif all(x >= target_length for x in b):\n    print('Yes')\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef move(arr, item):\n    for i in range (0, len(arr)):\n        if arr[i] == item:\n            n=i\n    arr=np.delete(arr,n)\n    arr=np.insert(arr, 0, item)\n\n\nn, m = map(int, raw_input().split())\nnum = int(raw_input())\narr = np.empty(shape=(n,m),dtype=int)\nfor i in range(n):\n    arr[i] = np.arange(1, m+1)\n\n\nst = raw_input()\nq = st.split()\nq = [int(a) for a in q]\n\nk=0\nmySet = set((a, b, c, d, e, f) for a in range(1,n+1) for b in range(1,n+1) for c in range(1,n+1) for d in range(1,n+1) for e in range(1,n+1) for f in range(1,n+1))\nfor item in mySet:\n    copy = arr.copy()\n    for i in range(0, len(item)):\n        move(copy[item[i]-1], q[item[i]-1])\n\n    if (copy == copy[0]).all():\n        k+=1\n\n\nif k>0:\n    print \"Yes\"\nelse:\n    print \"No\""
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\ndef check1(A):\n    K = max(A)\n    table = [-1]*(K+1)\n    for i in range(Q):\n        table[A[i]] = i\n    \n    if -1 in table:\n        return False\n    if any(t1-t2 < 0 for t1, t2 in zip(table, table[1:])):\n        return False\n    return True\n\nINF = 10**9+7\ndef check2(A):\n    stack = []\n    used = set()\n    for a in A[::-1] + list(range(M)):\n        if a not in used:\n            used.add(a)\n            stack.append(a)\n    \n    C = dict()\n    for i in range(M):\n        C[stack[i]] = i\n    \n    table = [0]*M + [INF]\n    for a in A[::-1]:\n        if table[C[a]] < table[C[a]-1]:\n            table[C[a]] += 1\n    \n    zero = stack.index(0)\n    if all(t2 > t1 for t1, t2 in zip(stack[zero:], stack[zero+1:])):\n        for a in stack[zero:]:\n            table[C[a]] = N\n    \n\n    return  all(t >= N or t == 0 for t in table)\n\nN, M = map(int, readline().split())\nQ = int(readline())\nA = list(map(lambda x: int(x)-1, readline().split()))\n\nans = 'Yes'\nif not check1(A):\n    if not check2(A):\n        ans = 'No'\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, m = map(int, stdin.readline().split())\n    q = int(stdin.readline())\n    a = map(int, stdin.readline().split(), repeat(10, q))\n    a = [x - 1 for x in a]\n    l = [[] for i in xrange(q)]\n    la = []\n    for i in xrange(q - 1, -1, -1):\n        x = a[i]\n        if not l[x]:\n            la.append(x)\n        l[x].append(i)\n    ok = 1\n    b = [q] * n\n    f = [0] * m\n    xt = 0\n    for i, x in enumerate(la):\n        j = 0\n        for y in l[x]:\n            if j < n and y < b[j]:\n                b[j] = y\n                j += 1\n        if j < n:\n            ok = 0\n            b[j] = -1\n        if not ok:\n            while f[xt]:\n                  xt += 1\n            if x != xt:\n                print \"No\"\n                return\n            f[xt] = 1\n        else:\n            f[x] = 1\n    print \"Yes\"\nmain()"
  },
  {
    "language": "Python",
    "code": "printd=lambda *args:0 #print\nN,M = [int(x) for x in input().split()]\nQ=int(input())\n\n\na = [int(x)-1 for x in input().split()]\ntarget=[]\n\n\nfor x in reversed(a):\n    if x not in target:\n        target.append(x)\n\nif target[-1]==0:\n    target.pop()\nif all(target[i]==i for i in range(M)):\n    target=[]\nprintd(target)\ncan_trash= set()\n\nb = [0 for _ in range(N)]\n\nfor x in reversed(a):\n    for i,value in enumerate(b):\n        printd(i,value,x,b)\n        if value<len(target) and target[value]==x:\n            b[i] = value+1\n            printd(b)\n            can_trash.add(x)\n            break\n    if x==0:\n        if any(val==len(target) for val in b ):\n            can_trash.add(0)\n    if x in can_trash:\n        continue\n\n    else:\n        print('No')\n        exit()\n\nif all(x==len(target) for x in b):\n    print('Yes')\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import product\nreadline = sys.stdin.readline\n\ndef check1(A):\n    K = max(A)\n    table = [-1]*(K+1)\n    for i in range(Q):\n        table[A[i]] = i\n    \n    if -1 in table:\n        return False\n    if any(t1-t2 < 0 for t1, t2 in zip(table, table[1:])):\n        return False\n    return True\n\nINF = 10**9+7\ndef check2(A):\n    stack = []\n    used = set()\n    for a in A[::-1] + list(range(M)):\n        if a not in used:\n            used.add(a)\n            stack.append(a)\n    \n    C = dict()\n    for i in range(M):\n        C[stack[i]] = i\n    \n    table = [0]*N + [INF]\n    for a in A[::-1]:\n        if table[C[a]] < table[C[a]-1]:\n            table[C[a]] += 1\n    \n    zero = stack.index(0)\n    if all(t2 > t1 for t1, t2 in zip(stack[zero:], stack[zero+1:])):\n        for a in stack[zero:]:\n            table[C[a]] = N\n    \n\n    return  all(t >= N or t == 0 for t in table)\n\nN, M = map(int, readline().split())\nQ = int(readline())\nA = list(map(lambda x: int(x)-1, readline().split()))\n\nans = 'Yes'\nif not check1(A):\n    A = [0]*N + A\n    if not check2(A):\n        ans = 'No'\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\n#-*- coding: utf-8 -*-\n# E-LRU Puzle\ndef reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n#Data input\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\n\n#Data structure initial\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\n\n#Pattern search & Match count\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tfreq[counter] -= 1\n\t\tcounter += 1\n\t\tfreq[counter] += 1\n\t\tprint('freq is',freq)\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\tfreq[temp] -= 1\n\t\t\tfreq[temp+1] += 1\n\t\t\tprint('freq is',freq)\n\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\n\n#Result judge\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\n\np = pat[start:]\np.sort()\nif(p == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")"
  },
  {
    "language": "Python",
    "code": "# find what should answer be\nN, M = map(int, raw_input().split())\nQ = int(raw_input())\na_list = map(int, raw_input().split())\n\nsol = \"YES\"\n\n# back search\nfinal_order = []\nfor i in range(Q, 0, -1):\n    if a_list[i-1] not in final_order:\n        final_order.append(a_list.pop(i-1))\n\nfinal_list_1 = final_order\nfor i in range(1, M+1):\n    if i not in final_list_1:\n        final_list_1.append(i)\n\n# back search\nfor n in range(N-1):\n    final_order = []\n    for i in range(len(a_list), 0, -1):\n        if a_list[i-1] not in final_order:\n            final_order.append(a_list.pop(i-1))\n\n    final_list = final_order\n    for i in range(1, M+1):\n        if i not in final_list:\n            final_list.append(i)\n    if final_list_1 != final_list:\n        sol = \"NO\"\nprint sol"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1 for i in range(M)]\npat = []\nfreq = [0 for i in range(M+1)]\nfreq[0] = N\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\t--(freq[counter])\n\t\t++counter \n\t\t++(freq[counter])\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\t--freq[temp]\n\t\t\t++freq[temp+1]\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\nfor i in freq:\n\tif (i != 0):\n\t\tstart = i\n\t\tbreak\ntemp = pat[start:]\ntemp.sort()\nif(temp == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\ndef check1(A):\n    K = max(A)\n    table = [-1]*(K+1)\n    for i in range(Q):\n        table[A[i]] = i\n    \n    if -1 in table:\n        return False\n    if any(t1-t2 < 0 for t1, t2 in zip(table, table[1:])):\n        return False\n    return True\n\nINF = 10**9+7\ndef check2(A):\n    table = [0]*M + [INF]\n    idx = 0 \n    C = dict()\n    for i in range(len(A)-1, -1, -1):\n        a = A[i]\n        if a not in C:\n            C[a] = idx\n            idx += 1\n        \n        cidx = C[a]\n        if table[cidx] < table[cidx-1]:\n            table[cidx] += 1\n                \n    if all(table[i] >= N for i in range(idx)):\n        return True\n    return False\n\nN, M = map(int, readline().split())\nQ = int(readline())\nA = list(map(lambda x: int(x)-1, readline().split()))\n\nans = 'Yes'\nif not check1(A):\n    A = [0]*N + A\n    if not check2(A):\n        ans = 'No'\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tsa = set(a)\n\tseen = set()\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in seen:\n\t\t\tr.append(n)\n\t\t\tseen.add(n)\n\tfor i in range(m):\n\t\tif (i+1) not in sa:\n\t\t\tr.append(i+1)\n\treturn r\n\ndef isSorted(a):\n\tfor i in range(1, len(a)):\n\t\tif a[i-1] > a[i]:\n\t\t\treturn False\n\treturn True\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\ntable = [-1] * (m+1)\nfor i in range(len(r)):\n\ttable[r[i]] = i\n\nfor aa in a[::-1]:\n\tindex = table[aa]\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = m\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nif isSorted(r[to:]):\n\tprint('Yes')\nelse:\n\tprint('No')\n"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tfreq[counter] -= 1\n\t\tcounter += 1\n\t\tfreq[counter] += 1\n\telse:\n\t\ttemp = pos[i]\n\t\tif (freq[temp] > 0):\n\t\t\tfreq[temp] -= 1\n\t\t\tfreq[temp+1] += 1\nif(counter != M):\n\tfor i in range(M):\n\t\tif (i not in pat):\n\t\t\tpat.append(i)\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\np = pat[start:]\np.sort()\nif(p == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")"
  },
  {
    "language": "Python",
    "code": "# find what should answer be\nN, M = map(int, raw_input().split())\nQ = int(raw_input())\na_list = map(int, raw_input().split())\n\nsol = \"Yes\"\n\n# back search\nfinal_order = []\nfor i in range(Q, 0, -1):\n    if a_list[i-1] not in final_order:\n        final_order.append(a_list.pop(i-1))\n\nfinal_list_1 = final_order\nfor i in range(1, M+1):\n    if i not in final_list_1:\n        final_list_1.append(i)\n\n# back search\nfor n in range(N-1):\n    final_order = []\n    for i in range(len(a_list), 0, -1):\n        if a_list[i-1] not in final_order:\n            final_order.append(a_list.pop(i-1))\n\n    final_list = final_order\n    for i in range(1, M+1):\n        if i not in final_list:\n            final_list.append(i)\n    if final_list_1 != final_list:\n        sol = \"No\"\nprint sol"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/code-festival-2016-quala/tasks/codefestival_2016_qualA_e\n\n最後の配列の状態は何で決定されるか。\n同じaが同じ配列に複数回採用されたとき、効果があるのは最後に\n採用したaのみ。(それ以前は合っても無くても同じになる)\n\n最初、1が採用状態になっていると考えてよい。\n→おそらく気にすべきは配列aのみ(Nこの配列は考慮しなくてよい)\n\n1以外は、出現するなら少なくともN個出現しなければ不可能\n2,3だけで考えてみよう\n\nN==3のとき\n\n322233 →不可能(2が先頭が1つ生まれてしまう)\n232233 →可能\n\n→終了後の配列の数字は、最後に出現した順に前から並ぶ\n→よってaを見れば構成後の数列は分かる\n\n→後ろからaを見ていって、先に登場したやつより後に登場したほうが数が越えたらダメ\n→ただし、N個目以降は完全無視する\n→終了時に数がNに達していないのがあったらダメ(1を除く？)\n\nいや例3…\n→初期状態、の扱い方を考え直さなきゃな…\n\naの前に M…M(N個),M-1…M-1,…,1…1 があると考える\nすると、aを後ろから見ていった時に先に登場したやつより後に登場したほうが数が越えてはいけない、\nだけの条件になる！！\n\nあ、2233223 は…？\n最後の2つの2を1箇所に適応すれば可能じゃん！\nlis[a[i][0]]ってなんだ…？\n→それ以降に先頭をa[i][0]に更新できる最大数\n→よって、indに対して単調減少になっていなければいけない\n\nうん？前を超えないようにして、最終的にすべてN以上になればおｋ？\n\"\"\"\nimport sys\nN,M = map(int,input().split())\n\nQ = int(input())\n\nA = list(map(int,input().split()))\n\ndic = {}\nlis = []\nflag = True\n\na = [[M-i,N] for i in range(M)]\nfor i in range(Q):\n    a.append([A[i],1])\na.reverse()\n#print (a)\n\nfor i in range(len(a)):\n\n    if a[i][0] not in dic:\n        ind = len(dic)\n        dic[a[i][0]] = ind\n        if ind != 0:\n            lis.append(min(lis[ind-1] , a[i][1]))\n        else:\n            lis.append(a[i][1])\n    else:\n        ind = dic[a[i][0]]\n        if ind != 0:\n            lis[ind] = min(N, lis[ind] + a[i][1] , lis[ind-1])\n        else:\n            lis[ind] = min(N, lis[ind] + a[i][1])\n\nif lis[-1] == N:\n    print (\"Yes\")\nelse:\n    print (\"No\")"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tsa = set(a)\n\tseen = set()\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in seen:\n\t\t\tr.append(n)\n\t\t\tseen.add(n)\n\tfor i in range(m):\n\t\tif (i+1) not in sa:\n\t\t\tr.append(i+1)\n\treturn r\n\ndef isSorted(a):\n\tfor i in range(1, len(a)):\n\t\tif a[i-1] > a[i]:\n\t\t\treturn False\n\treturn True\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\ntable = [-1] * (m+1)\nfor i in range(len(r)):\n\ttable[r[i]] = i\n\nfor aa in a[::-1]:\n\tindex = table[aa]\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = 0\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nif isSorted(r[to:]):\n\tprint('Yes')\nelse:\n\tprint('No')\n"
  },
  {
    "language": "Python",
    "code": "\ndef read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split()))\n\ndef f(m, a):\n\tr = []\n\tfor n in a[::-1]:\n\t\tif n not in r:\n\t\t\tr.append(n)\n\tfor i in range(m):\n\t\tif (i+1) not in r:\n\t\t\tr.append(i+1)\n\treturn r\n\n\nn, m = reads()\nq = read()\na = reads()\n\nr = f(m, a)\ncount = [0] * (m+1)\ncount[0] = n\n\nfor aa in a[::-1]:\n\tindex = r.index(aa)\n\tif 0 < count[index]:\n\t\tcount[index] -= 1\n\t\tcount[index+1] += 1\n\nto = 0\nfor i in range(m):\n\tif 0 < count[i]:\n\t\tto = i\n\t\tbreak\n\nleft, right = r[:to], r[to:]\n\nflag = True\nindex = 0\nfor i in range(1, len(r)+1):\n\tif i in left:\n\t\tcontinue\n\tif right[index] != i:\n\t\tflag = False\n\t\tbreak\n\tif right[index] == i:\n\t\tindex += 1\n\nif flag:\n\tprint('Yes')\nelse:\n\tprint('No')\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef ReadInput():\n\treturn [int(a) for a in input().split(' ')]\n(N, M) = ReadInput()\nQ = int(input())\nArray = ReadInput()\ndef ifEqual(x):\n\ttemp = None\n\tfor i in x:\n\t\tif (temp == None):\t\n\t\t\ttemp = x[i]\n\t\t\tcontinue\n\t\telif (x[i] != temp):\n\t\t\tprint('ifEqual is 0')\n\t\t\treturn 0\n\treturn temp\ndef check(Array, N, M, *args):\n\tCount = defaultdict(int)\n\tArray.reverse()\n\tif (\"reverse\") not in args:\n\t\tfor i in Array:\n\t\t\tif (i == 1 or Count[i] < Count[i-1]):\n\t\t\t\tCount[i] += 1\n\t\t\telse:\t\n\t\t\t\treturn 0\n\t\tCount.pop(N)\n\t\tif(ifEqual(Count)):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\telse:\n\t\tfor i in Array:\n\t\t\tif (i == N or Count[i] < Count[i+1]):\n\t\t\t\tCount[i] += 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tCount.pop(1)\n\t\tif(ifEqual(Count) >= M):\n\t\t\treturn 1\n\t\telse\n\t\t\treturn 0\nif (check(Array, N, M) or check(Array, N, M, \"reverse\")):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, m = map(int, stdin.readline().split())\n    q = int(stdin.readline())\n    a = map(int, stdin.readline().split(), repeat(10, q))\n    a = [x - 1 for x in a]\n    l = [[] for i in xrange(m)]\n    la = []\n    for i in xrange(q - 1, -1, -1):\n        x = a[i]\n        if not l[x]:\n            la.append(x)\n        l[x].append(i)\n    ok = 1\n    b = [q] * n\n    f = [0] * m\n    xt = 0\n    for i, x in enumerate(la):\n        j = 0\n        for y in l[x]:\n            if j < n and y < b[j]:\n                b[j] = y\n                j += 1\n        if j < n:\n            ok = 0\n            b[j] = -1\n        if not ok:\n            while f[xt]:\n                  xt += 1\n            if x != xt:\n                print \"No\"\n                return\n            f[xt] = 1\n        else:\n            f[x] = 1\n    print \"Yes\"\nmain()"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\ndef Judge(vector):\n\tlength = len(vector)-1\n\tfor i in range(length):\n\t\tif(vector[i] > vector[i+1]):\t\t\n\t\t\treturn 0\n\treturn 1\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\nfound = set()\nfor i in A[::-1]:\n\tif (i not in found):\n\t\tpat.append(i)\n\t\tfound.add(i)\n\t\tpos[i] = counter\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\t\t\nfor i in A[::-1]:\n\ttemp = pos[i]\n\tif (freq[temp] > 0):\n\t\tfreq[temp] -= 1\n\t\tfreq[temp+1] += 1\nfor i in range(M+1):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\nprint(\"Yes\") if Judge(pat[start:]) else print(\"No\")"
  },
  {
    "language": "Python",
    "code": "n, m = map(int,raw_input().split(' '))\nq = int(raw_input())\na = map(lambda i: int(i) - 1, raw_input().split(' '))\na.reverse()\n\ns = set(range(m))\nans = []\n\nfor i in a:\n    if i in s:\n        s -= set([i])\n        ans.append(i)\n\nrest = list(s)\nrest.reverse()\n\nfor i in rest:\n    ans.append(i)\n\nmaximum = 10000000\n\nwhile ans and ans[-1] < maximum:\n    maximum = ans[-1]\n    ans.pop()\n\nindex = [-1] * m\n\nfor i, v in enumerate(ans):\n    index[v] = i\n\nnum = [0] * len(ans)\n\nfor i in a:\n    ind = index[i]\n    if ind == -1: continue\n    if ind == 0 or num[ind-1] > num[ind]:\n        num[ind] += 1\n\nprint \"Yes\" if len(num) == 0 or num[-1] >= n else \"No\"\n"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\ndef Judge(vector):\n\tlength = len(vector)-1\n\tfor i in range(length):\n\t\tif(vector[i] > vector[i+1]):\t\t\n\t\t\treturn 0\n\treturn 1\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\nfound = set()\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in found):\n\t\tpat.append(i)\n\t\tfound.add(i)\n\t\tpos[i] = counter\n\t\tcounter += 1\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\t\nfor i in A[::-1]:\n\ttemp = pos[i]\n\tif (freq[temp] > 0):\n\t\tfreq[temp] -= 1\n\t\tfreq[temp+1] += 1\nfor i in range(M+1):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\nprint(\"Yes\") if Judge(pat[start:]) else print(\"No\")"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\n#-*- coding: utf-8 -*-\n# E-LRU Puzle\n\nfrom collections import defaultdict\ndef ReadInput():\n\treturn [int(a) for a in input().split(' ')]\n\n(N, M) = ReadInput()\nQ = int(input())\nArray = ReadInput()\ndef ifEqual(x):\n\ttemp = None\n\tfor i in x:\n\t\tif (temp == None):\t\n\t\t\ttemp = x[i]\n\t\t\tcontinue\n\t\telif (x[i] != temp):\n\t\t\tprint('ifEqual is 0')\n\t\t\treturn 0\n\treturn temp\n\ndef check(Array, N, M, *args):\n\tCount = defaultdict(int)\n\tArray.reverse()\n\tif (\"reverse\") not in args:\n\t\tfor i in Array:\n\t\t\tif (i == 1 or Count[i] < Count[i-1]):\n\t\t\t\tCount[i] += 1\n\t\t\telse:\t\n\t\t\t\treturn 0\n\t\tCount.pop(N)\n\t\tif(ifEqual(Count)):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\telse:\n\t\tfor i in Array:\n\t\t\tif (i == N or Count[i] < Count[i+1]):\n\t\t\t\tCount[i] += 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tCount.pop(1)\n\t\tif(ifEqual(Count) >= M):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\nif (check(Array, N, M) or check(Array, N, M, \"reverse\")):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nN,M = map(int,input().split())\nQ = int(input())\nA = [int(x) for x in input().split()]\n\nused = [False] * (M+1)\narr = []\nfor x in A[::-1]:\n    if used[x]:\n        continue\n    used[x] = True\n    arr.append(x)\nfor x in range(1,M+1):\n    if used[x]:\n        continue\n    arr.append(x)\n\nx_to_i = {x:i for i,x in enumerate(arr,1)}\n\nmade = [N] + [0] * M\n\nfor x in A[::-1]:\n    i = x_to_i[x]\n    if made[i-1] > 0:\n        made[i-1] -= 1\n        made[i] += 1\n\nL = 0\nprev = M+100\nfor x in arr[::-1]:\n    if x >= prev:\n        break\n    prev = x\n    L += 1\n\nx = sum(made[::-1][:L+1])\nanswer = 'Yes' if x == N else 'No'\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nprintd = print\nprintd= lambda *args:0\nN, M = [int(x) for x in input().split()]\nQ = int(input())\n\na = [int(x) - 1 for x in input().split()]\ntarget = []\n\nfor x in list(reversed(a)) + list(range(M)):\n    if x not in target:\n        target.append(x)\nprintd(target)\nassert len(target) == M\ntarget_length = M - 1\nfor i in range(len(target) - 1, 0, -1):\n    if target[i] > target[i - 1]:\n        target_length -= 1\n    else:\n        break\n\nprintd('target_length:',target_length)\ncan_trash = set()\n\nbd = defaultdict(int)\nbd[0] = N\nfor x in reversed(a):\n    _flag = False\n    printd('x:', x)\n    _index = target.index(x)\n    printd(bd,_index,bd[_index])\n    if bd[_index]:\n        bd[_index] -= 1\n        bd[_index+1] += 1\n        can_trash.add(x)\n        printd('+1')\n        continue\n    if x == 0:\n        if any((not val) or (key>= len(target))  for key,val in bd.items()):\n            can_trash.add(0)\n    if x in can_trash:\n        continue\n    else:\n        printd('else',bd)\n        print('No')\n        exit()\n\nprintd(bd)\nif all((value==0) or key >= target_length for key,value in bd.items()):\n    print('Yes')\nelse:\n    print(\"No\")\n"
  },
  {
    "language": "Python",
    "code": "def reads(offset = 0):\n\treturn [int(i) - offset for i in input().split(' ')]\n(N, M) = reads()\nQ = int(input())\nA = reads(1)\npos = [-1] * M\npat = []\nfreq = [0] * (M+1)\nfreq[0] = N\ncounter = 0\nfor i in A[::-1]:\n\tif (i not in pat):\n\t\tpat.append(i)\n\t\tpos[i] = counter\n\t\tcounter += 1\n\t\tif(counter == M):\n\t\t\tbreak\nfor i in range(M):\n\tif (pos[i] == -1):\n\t\tpat.append(i)\t\nfor i in A[::-1]:\n\ttemp = pos[i]\n\tif (freq[temp] > 0):\n\t\tfreq[temp] -= 1\n\t\tfreq[temp+1] += 1\nfor i in range(M):\n\tif (freq[i] != 0):\n\t\tstart = i\n\t\tbreak\np = pat[start:]\np.sort()\nif(p == pat[start:]):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")"
  }
]