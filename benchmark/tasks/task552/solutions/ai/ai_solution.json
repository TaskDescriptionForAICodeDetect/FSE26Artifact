[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 10\n#define MAX_M 10\n\nint N, M;\nint lines[MAX_N][MAX_M];\nbool visited[MAX_N];\n\nbool trace_path(int start) {\n    int current = start;\n    for (int row = 0; row < M; row++) {\n        if (lines[row][current] == 1 && current < N - 1) {\n            current++;\n        } else if (lines[row][current - 1] == 1 && current > 0) {\n            current--;\n        }\n    }\n    return current == start;\n}\n\nbool is_good_amidakuji() {\n    for (int i = 0; i < N; i++) {\n        if (!trace_path(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N - 1; j++) {\n            scanf(\"%d\", &lines[i][j]);\n        }\n    }\n    \n    printf(\"%s\\n\", is_good_amidakuji() ? \"yes\" : \"no\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int n;\n    int m;\n    int* lines;\n} Amidakuji;\n\nint simulate(Amidakuji* a, int start) {\n    int pos = start;\n    for (int i = 0; i < a->m; ++i) {\n        int dir = a->lines[i];\n        if (dir == 0) {\n            if (pos > 0) {\n                pos--;\n            }\n        } else {\n            if (pos < a->n - 1) {\n                pos++;\n            }\n        }\n    }\n    return pos;\n}\n\nint is_good(Amidakuji* a) {\n    if (a->n == 0) return 1;\n    int first_end = simulate(a, 0);\n    for (int i = 1; i < a->n; ++i) {\n        if (simulate(a, i) != first_end) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    Amidakuji* lotteries = malloc(T * sizeof(Amidakuji));\n    \n    for (int i = 0; i < T; ++i) {\n        scanf(\"%d %d\", &lotteries[i].n, &lotteries[i].m);\n        lotteries[i].lines = malloc(lotteries[i].m * sizeof(int));\n        for (int j = 0; j < lotteries[i].m; ++j) {\n            scanf(\"%d\", &lotteries[i].lines[j]);\n        }\n    }\n    \n    int possible = 0;\n    for (int mask = 1; mask < (1 << T); ++mask) {\n        Amidakuji combined;\n        combined.n = 0;\n        combined.m = 0;\n        combined.lines = NULL;\n        \n        for (int i = 0; i < T; ++i) {\n            if (mask & (1 << i)) {\n                if (combined.n == 0) {\n                    combined.n = lotteries[i].n;\n                } else if (combined.n != lotteries[i].n) {\n                    // Incompatible number of vertical lines\n                    goto cleanup;\n                }\n                combined.m += lotteries[i].m;\n            }\n        }\n        \n        combined.lines = malloc(combined.m * sizeof(int));\n        int idx = 0;\n        for (int i = 0; i < T; ++i) {\n            if (mask & (1 << i)) {\n                for (int j = 0; j < lotteries[i].m; ++j) {\n                    combined.lines[idx++] = lotteries[i].lines[j];\n                }\n            }\n        }\n        \n        if (is_good(&combined)) {\n            possible = 1;\n            free(combined.lines);\n            break;\n        }\n        \n        cleanup:\n        free(combined.lines);\n    }\n    \n    printf(possible ? \"yes\\n\" : \"no\\n\");\n    \n    for (int i = 0; i < T; ++i) {\n        free(lotteries[i].lines);\n    }\n    free(lotteries);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool isGoodAmidakuji(const vector<vector<int>>& lotteries, int N) {\n    for (int start = 0; start < N; ++start) {\n        int current = start;\n        for (const auto& lottery : lotteries) {\n            for (int dir : lottery) {\n                if (dir == 0 && current > 0) {\n                    current--;\n                } else if (dir == 1 && current < N - 1) {\n                    current++;\n                }\n            }\n        }\n        if (current != start) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<vector<vector<int>>> lotteries(K);\n    \n    for (int i = 0; i < K; ++i) {\n        int M;\n        cin >> M;\n        vector<int> lottery(M);\n        for (int j = 0; j < M; ++j) {\n            cin >> lottery[j];\n        }\n        lotteries[i] = lottery;\n    }\n    \n    bool possible = false;\n    for (int mask = 1; mask < (1 << K); ++mask) {\n        vector<vector<int>> selected;\n        for (int i = 0; i < K; ++i) {\n            if (mask & (1 << i)) {\n                selected.push_back(lotteries[i]);\n            }\n        }\n        if (isGoodAmidakuji(selected, N)) {\n            possible = true;\n            break;\n        }\n    }\n    \n    cout << (possible ? \"yes\" : \"no\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Amidakuji {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] lotteries = new int[M][N - 1];\n        \n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N - 1; j++) {\n                lotteries[i][j] = scanner.nextInt();\n            }\n        }\n        \n        if (isGoodAmidakuji(N, M, lotteries)) {\n            System.out.println(\"yes\");\n        } else {\n            System.out.println(\"no\");\n        }\n    }\n    \n    private static boolean isGoodAmidakuji(int N, int M, int[][] lotteries) {\n        for (int mask = 1; mask < (1 << M); mask++) {\n            int[] permutation = new int[N];\n            for (int i = 0; i < N; i++) {\n                permutation[i] = i;\n            }\n            \n            for (int i = 0; i < M; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    for (int j = 0; j < N - 1; j++) {\n                        if (lotteries[i][j] == 1) {\n                            int temp = permutation[j];\n                            permutation[j] = permutation[j + 1];\n                            permutation[j + 1] = temp;\n                        }\n                    }\n                }\n            }\n            \n            boolean isGood = true;\n            for (int i = 0; i < N; i++) {\n                if (permutation[i] != i) {\n                    isGood = false;\n                    break;\n                }\n            }\n            \n            if (isGood) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:08:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        \n        int[][] lotteries = new int[N][M];\n        \n        for (int i = 0; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < M; j++) {\n                lotteries[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        System.out.println(canCreateGoodAmidakuji(N, M, lotteries) ? \"yes\" : \"no\");\n    }\n    \n    static boolean canCreateGoodAmidakuji(int N, int M, int[][] lotteries) {\n        for (int connected = 1; connected <= (1 << N); connected++) {\n            if (isGoodConfiguration(N, M, lotteries, connected)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static boolean isGoodConfiguration(int N, int M, int[][] lotteries, int connected) {\n        for (int start = 0; start < N; start++) {\n            int currentLine = start;\n            for (int lottery = 0; lottery < N; lottery++) {\n                if ((connected & (1 << lottery)) != 0) {\n                    currentLine = simulateLottery(N, M, lotteries[lottery], currentLine);\n                }\n            }\n            if (currentLine != start) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static int simulateLottery(int N, int M, int[] lottery, int startLine) {\n        int currentLine = startLine;\n        for (int j = 0; j < M; j++) {\n            if (currentLine > 0 && lottery[j] == 0) {\n                currentLine--;\n            } else if (currentLine < N - 1 && lottery[j] == 1) {\n                currentLine++;\n            }\n        }\n        return currentLine;\n    }\n}",
    "timestamp": "2025-08-05 22:08:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool checkAmidakuji(const vector<vector<int>>& lotteries) {\n    int N = lotteries.size();\n    \n    for (int start = 0; start < N; start++) {\n        int current = start;\n        for (const auto& lottery : lotteries) {\n            if (current < N - 1 && lottery[current] == 1) {\n                current++;\n            } else if (current > 0 && lottery[current - 1] == 1) {\n                current--;\n            }\n        }\n        if (current != start) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> lotteries(N);\n    \n    for (int i = 0; i < N; i++) {\n        int M;\n        cin >> M;\n        lotteries[i].resize(N - 1);\n        \n        for (int j = 0; j < N - 1; j++) {\n            cin >> lotteries[i][j];\n        }\n    }\n    \n    cout << (checkAmidakuji(lotteries) ? \"yes\" : \"no\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_form_good_amidakuji(lotteries):\n    for lottery in lotteries:\n        # current vertical positions\n        positions = list(range(len(lottery[0]) + 1))\n        \n        # simulate each horizontal line\n        for h_line in lottery:\n            new_positions = positions[:]\n            for i in range(len(h_line)):\n                if h_line[i] == 0:  # line extends left\n                    new_positions[i], new_positions[i+1] = new_positions[i+1], new_positions[i]\n                elif h_line[i] == 1:  # line extends right\n                    new_positions[i+1], new_positions[i] = new_positions[i], new_positions[i+1]\n            positions = new_positions\n\n        # check if the resulting positions are the same as initial\n        if positions != list(range(len(lottery[0]) + 1)):\n            return 'no'\n\n    return 'yes'\n\n# Example usage:\n# lotteries = [\n#   [[1, 0], [0, 1]],  # A good Amidakuji for 3 vertical lines\n#   [[0, 1], [1, 0]]   # Another good Amidakuji for 3 vertical lines\n# ]\n# print(can_form_good_amidakuji(lotteries))  # Output: 'yes'",
    "timestamp": "2025-08-13 09:01:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class AmidakujiLottery {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();  // Number of vertical lines\n        int m = scanner.nextInt();  // Number of horizontal lines in each Amidakuji\n        \n        boolean possible = false;\n        \n        for (int i = 0; i < n; i++) {\n            int[] horizontalLines = new int[m];\n            for (int j = 0; j < m; j++) {\n                horizontalLines[j] = scanner.nextInt();\n            }\n            \n            int position = 0;\n            for (int j = 0; j < m; j++) {\n                if (horizontalLines[j] == 0) {\n                    if (position > 0) position--; \n                } else { \n                    if (position < n - 1) position++;\n                }\n            }\n            \n            if (position == 0) {\n                possible = true;\n                break;\n            }\n        }\n        scanner.close();\n        \n        System.out.println(possible ? \"yes\" : \"no\");\n    }\n}",
    "timestamp": "2025-08-13 09:01:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint canCreateGoodAmidakuji(int n, int k, int* lines) {\n    int *state = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; ++i) {\n        state[i] = i;\n    }\n    for (int i = 0; i < k; ++i) {\n        int newState;\n        newState = (lines[i] == 0) ? state[i] : state[i + 1];\n        state[i + (lines[i] ? 0 : 1)] = state[i + (lines[i] ? 1 : 0)];\n        state[i + (lines[i] ? 1 : 0)] = newState;\n    }\n    int isGood = 1;\n    for (int i = 0; i < n; ++i) {\n        if (state[i] != i) {\n            isGood = 0;\n            break;\n        }\n    }\n    free(state);\n    return isGood;\n}\n\nint main() {\n    int n1, k1;\n    \n    // Example input/output\n    // scanf(\"%d %d\", &n1, &k1);\n    // int* lines1 = (int*)malloc(k1 * sizeof(int));\n    // for (int i = 0; i < k1; ++i) {\n    //     scanf(\"%d\", &lines1[i]);\n    // }\n    \n    int lines1[] = {1, 0, 1}; // Example edges, right, left, right e.g. (modify appropriately)\n    n1 = 4;             // Example vertical lines\n    k1 = sizeof(lines1)/sizeof(lines1[0]);\n    \n    int result = canCreateGoodAmidakuji(n1, k1, lines1);\n    printf(\"%s\\n\", result ? \"yes\" : \"no\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:01:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_good_amidakuji(N, lines):\n    def simulate_path(start):\n        current = start\n        for line in lines:\n            if 0 <= current < N - 1 and line[current] == 1:\n                current += 1\n            elif 0 < current and line[current - 1] == 1:\n                current -= 1\n        return current\n\n    for i in range(N):\n        if simulate_path(i) != i:\n            return False\n    return True\n\ndef solve():\n    N = int(input())\n    lines = []\n    for _ in range(N - 1):\n        lines.append(list(map(int, input().split())))\n    \n    print('yes' if is_good_amidakuji(N, lines) else 'no')\n\nsolve()",
    "timestamp": "2025-08-13 09:02:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    \n    for _ in range(T):\n        N = int(data[idx])\n        idx += 1\n        K = int(data[idx])\n        idx += 1\n        directions = data[idx:idx+K]\n        idx += K\n        \n        # Check if the Amidakuji is a permutation (i.e., each line maps to itself)\n        # We can simulate the process for each line and see if it ends at the same line\n        is_good = True\n        for start in range(N):\n            current = start\n            for dir in directions:\n                direction = int(dir)\n                if direction == 0:\n                    if current > 0:\n                        current -= 1\n                else:\n                    if current < N - 1:\n                        current += 1\n            if current != start:\n                is_good = False\n                break\n        if is_good:\n            print(\"yes\")\n        else:\n            print(\"no\")\n\nsolve()",
    "timestamp": "2025-08-13 09:02:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isGoodAmidakuji(const vector<vector<int>>& amidakuji, int n) {\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i) position[i] = i;\n\n    for (const auto& line : amidakuji) {\n        for (int i = 0; i < n - 1; ++i) {\n            if (line[i] == 1) {\n                swap(position[i], position[i + 1]);\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (position[i] != i) return false;\n    }\n    return true;\n}\n\nvoid addHorizontalLines(vector<vector<int>>& combined, const vector<vector<int>>& current) {\n    combined.insert(combined.end(), current.begin(), current.end());\n}\n\nint main() {\n    int t, n, m;\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        vector<vector<vector<int>>> lotteries;\n        for (int i = 0; i < n; ++i) {\n            cin >> m;\n            vector<vector<int>> amidakuji(m, vector<int>(n - 1));\n            for (int j = 0; j < m; ++j) {\n                for (int k = 0; k < n - 1; ++k) {\n                    cin >> amidakuji[j][k];\n                }\n            }\n            lotteries.push_back(amidakuji);\n        }\n\n        bool possible = false;\n        vector<vector<int>> combined;\n\n        for (int mask = 1; mask < (1 << n); ++mask) {\n            combined.clear();\n            for (int i = 0; i < n; ++i) {\n                if (mask & (1 << i)) {\n                    addHorizontalLines(combined, lotteries[i]);\n                }\n            }\n            if (isGoodAmidakuji(combined, n)) {\n                possible = true;\n                break;\n            }\n        }\n\n        cout << (possible ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:10"
  }
]