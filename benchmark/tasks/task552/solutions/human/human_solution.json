[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn._\nobject Main extends App {\n\n  val n = readInt()\n  val stripes = Array.tabulate(n){_ ⇒\n    readLine.trim.split(' ').tail.map(_.toInt).foldLeft(Stripe.default){case (acc, c) ⇒ acc.addBorder(c)}.toReplace\n  }.groupBy(_.loopLength())\n  if (stripes.contains(1) || stripes.get(2).exists(_.length > 3) || stripes.get(3).exists(_.length > 2)) {\n    println(\"yes\")\n  }else {\n    println(\n      if (stripes.toArray.flatMap(_._2).permutations.exists(a ⇒ a.tail.scan(a.head){case (acc, r) ⇒ acc + r}.exists(_.isId))) \"yes\" else \"no\"\n    )\n  }\n  object Stripe {\n    def default: Stripe = Stripe(0, 1, 2)\n  }\n  case class Stripe(left: Int, mid: Int, right: Int) {\n    def addBorder(position: Int): Stripe = position match {\n      case 0 ⇒ Stripe(mid, left ,right)\n      case 1 ⇒ Stripe(left, right, mid)\n      case _ ⇒ ???\n    }\n    def toReplace = Replace(Array(left, mid, right))\n  }\n  case class Replace(array: Array[Int]) {\n    def loopLength(): Int = {\n      val isVisit = Array.fill(array.length){false}\n      var max = 0\n      for (i ← array.indices if !isVisit(i)) {\n        var current = i\n        var count = 0\n        while(!isVisit(current)){\n          count += 1\n          isVisit(current) = true\n          current = array(current)\n        }\n        if (max < count) max = count\n      }\n      max\n    }\n    def +(that: Replace): Replace = Replace(that.array.map(array))\n    def isId: Boolean = array.indices.forall(i ⇒ array(i) == i)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]+1){\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1)))){\n            return true;\n        }\n        if(i == cnt[pos]){\n            break;\n        }\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Amida {\n\tint p1, p2, p3;\n};\nbool operator== (const Amida &a1, const Amida &a2) {\n\tif (a1.p1 == a2.p1 && a1.p2 == a2.p2 && a1.p3 == a2.p3) return true;\n\treturn false;\n}\n\nint n, w[109], dp[109][6][2]; vector<int>a[109]; Amida S[109];\n\nAmida solve(vector<int>v) {\n\tAmida F = Amida{ 1,2,3 };\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 0) swap(F.p1, F.p2);\n\t\tif (v[i] == 1) swap(F.p2, F.p3);\n\t}\n\treturn F;\n}\nAmida gousei(Amida P1, Amida P2) {\n\tint r[3] = { 0,0,0 }, q[3] = { P1.p1,P1.p2,P1.p3 };\n\tr[0] = q[P2.p1 - 1];\n\tr[1] = q[P2.p2 - 1];\n\tr[2] = q[P2.p3 - 1];\n\treturn Amida{ r[0],r[1],r[2] };\n}\nAmida toAmida(int p) {\n\tif (p == 0) return Amida{ 1,2,3 };\n\tif (p == 1) return Amida{ 1,3,2 };\n\tif (p == 2) return Amida{ 2,1,3 };\n\tif (p == 3) return Amida{ 2,3,1 };\n\tif (p == 4) return Amida{ 3,1,2 };\n\tif (p == 5) return Amida{ 3,2,1 };\n}\nint toNumber(Amida P) {\n\tif (P == Amida{ 1, 2, 3 }) return 0;\n\tif (P == Amida{ 1, 3, 2 }) return 1;\n\tif (P == Amida{ 2, 1, 3 }) return 2;\n\tif (P == Amida{ 2, 3, 1 }) return 3;\n\tif (P == Amida{ 3, 1, 2 }) return 4;\n\tif (P == Amida{ 3, 2, 1 }) return 5;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tfor (int j = 0; j < w[i]; j++) {\n\t\t\tint p; cin >> p;\n\t\t\ta[i].push_back(p);\n\t\t}\n\t\tS[i] = solve(a[i]);\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tif (dp[i][j][k] == 0) continue;\n\t\t\t\tdp[i + 1][j][k] = 1;\n\t\t\t\tAmida G = toAmida(j);\n\t\t\t\tAmida H = gousei(G, S[i]);\n\t\t\t\tint r = toNumber(H);\n\t\t\t\tdp[i + 1][r][1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[n][0][1] == 1) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<vector<int>> ord;\nint nxt[6][6];\n\nvoid init(){\n\t{\n\t\tvector<int> a = { 0,1,2 };\n\t\tdo{\n\t\t\tord.push_back(a);\n\t\t} while(next_permutation(a.begin(), a.end()));\n\t}\n\tfor(int i = 0; i < 6; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tvector<int> v1 = ord[i], v2 = ord[j];\n\t\t\tvector<int> res(3);\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tres[k] = v2[v1[k]];\n\t\t\t}\n\t\t\tnxt[i][j] = find(ord.begin(), ord.end(), res) - ord.begin();\n\t\t}\n\t}\n}\n\nbool dp[110][6][2];\nint id[100];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tinit();\n\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tint w;\n\t\tcin >> w;\n\t\tvector<int> v = { 0,1,2 };\n\t\twhile(w--){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(a == 0) swap(v[0], v[1]);\n\t\t\telse swap(v[1], v[2]);\n\t\t}\n\t\tid[i] = find(ord.begin(), ord.end(), v) - ord.begin();\n\t}\n\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(!dp[i][j][k]) continue;\n\t\t\t\tdp[i + 1][j][k] = 1;\n\t\t\t\tint to = nxt[j][id[i]];\n\t\t\t\tdp[i + 1][to][1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dp[N][0][1]) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(3,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi f(vi a, vi b) {\n  vi c(3);\n  rep(i, 3) {\n    c[b[i]] = a[i];\n  }\n  return c;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n;\n  cin >> n;\n  map<vi, int> mp;\n  vvi perms = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0}\n  };\n  rep(i, n) {\n    int w;\n    cin >> w;\n    vi perm(3);\n    iota(all(perm), 0);\n    rep(j, w) {\n      int a;\n      cin >> a;\n      if (a == 0) {\n        swap(perm[0], perm[1]);\n      }\n      else {\n        swap(perm[1], perm[2]);\n      }\n    }\n    mp[perm]++;\n  }\n\n  /*\n  for (auto p : mp) {\n    rep(i, 3) cerr << p.first[i] << \" \";\n    cerr << \": \" << p.second << endl;\n  }\n  */\n\n  if (mp[perms[0]] >= 1\n    || mp[perms[1]] >= 2\n    || mp[perms[2]] >= 2\n    || mp[perms[3]] >= 3\n    || mp[perms[4]] >= 3\n    || mp[perms[5]] >= 2)\n  {\n    cout << \"yes\" << endl;\n    return 0;\n  }\n\n  vvi list;\n  rep(i, 6) {\n    rep(j, mp[perms[i]]) {\n      list.push_back(perms[i]);\n    }\n  }\n\n  rep(state, 1 << list.size()) {\n    // cerr << \"state = \" << state << endl;\n    if (state == 0) continue;\n    vvi chosen;\n    rep(i, list.size()) {\n      if ((state >> i) & 1) {\n        chosen.push_back(list[i]);\n      }\n    }\n    sort(all(chosen));\n    do {\n      // printVV(chosen);\n      vi perm(3);\n      iota(all(perm), 0);\n      rep(i, chosen.size()) {\n        perm = f(perm, chosen[i]);\n      }\n      if (perm == perms[0]) {\n        cout << \"yes\" << endl;\n        return 0;\n      }\n    } while (next_permutation(all(chosen)));\n  }\n\n  cout << \"no\" << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n;\n    cin>>n;\n    map<vector<int>,int> mp;\n    rep(i,n){\n        int w;\n        cin>>w;\n        vector<int> a={0,1,2};\n        rep(j,w){\n            int x;\n            cin>>x;\n            if(x)swap(a[1],a[2]);\n            else swap(a[1],a[0]);\n        }\n        mp[a]++;\n    }\n    bool ok=false;\n    if(mp[{0,1,2}])ok=true;\n    if(mp[{0,2,1}]>=2)ok=true;\n    if(mp[{1,0,2}]>=2)ok=true;\n    if(mp[{2,1,0}]>=2)ok=true;\n    if(mp[{1,2,0}]>=3)ok=true;\n    if(mp[{2,0,1}]>=3)ok=true;\n    if(mp[{1,2,0}]>=1&&mp[{2,0,1}]>=1)ok=true;\n    if(mp[{0,2,1}]&&mp[{1,0,2}]&&mp[{1,2,0}])ok=true;\n    if(mp[{0,2,1}]&&mp[{1,0,2}]&&mp[{2,0,1}])ok=true;\n    if(mp[{2,1,0}]&&mp[{1,0,2}]&&mp[{1,2,0}])ok=true;\n    if(mp[{2,1,0}]&&mp[{1,0,2}]&&mp[{2,0,1}])ok=true;\n    if(mp[{0,2,1}]&&mp[{2,1,0}]&&mp[{1,2,0}])ok=true;\n    if(mp[{0,2,1}]&&mp[{2,1,0}]&&mp[{2,0,1}])ok=true;\n    if(ok)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid END(){\n  cout<<\"yes\"<<endl;\n  exit(0);\n}\nint main(){\n  int n,m,x;\n  cin>>n;\n  vector<vector<int> >v(n);\n  if(n>4)END();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<3;j++) v[i].push_back(j);\n    cin>>m;\n    while(m--){\n      cin>>x;\n      if(x)swap(v[i][1],v[i][2]);\n      else swap(v[i][0],v[i][1]);\n    }\n  }\n  sort(v.begin(),v.end());\n  do{\n    for(int i=0;i<n;i++){\n      int a[]={1,2,3},tmp[3];\n      for(int j=0;j<=i;j++){\n        for(int k=0;k<3;k++)tmp[k]=a[k];\n        for(int k=0;k<3;k++)a[k]=tmp[v[j][k]];\n      }\n      if(a[0]==1&&a[1]==2&&a[2]==3)END();\n    }\n  }while(next_permutation(v.begin(),v.end()));\n  cout<<\"no\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint N, A[6];\n//---------------------------------------------------------------------------------------------------\nvector<vector<int>> B = { {0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0} };\nint get(vector<int> v) {\n    rep(i, 0, 6) {\n        int ok = 1;\n        rep(j, 0, 3) if (v[j] != B[i][j]) ok = 0;\n        if (ok) return i;\n    }\n    assert(0);\n}\n//---------------------------------------------------------------------------------------------------\n#define yes \"yes\"\n#define no \"no\"\nstring solve() {\n    vector<int> v;\n    v.push_back(0);\n    rep(i, 0, 6) v.push_back(i);\n\n    do {\n        int s = 0, t = -1;\n        rep(i, 1, 7) if (v[i] == 0) t = i;\n        assert(1 <= t);\n\n        vector<int> cnt(6);\n        rep(i, s, t) {\n            int a = v[i];\n            int b = v[i + 1];\n\n            vector<int> w;\n            rep(u, 0, 3) rep(v, 0, 3) if (B[a][u] == B[b][v]) w.push_back(v);\n            cnt[get(w)]++;\n        }\n\n        int ok = 1;\n        rep(i, 0, 6) if (cnt[i] > A[i]) ok = 0;\n        if (ok) {\n            return yes;\n        }\n    } while (next_permutation(all(v)));\n\n    return no;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) {\n        int w; cin >> w;\n        vector<int> v = { 0, 1, 2 };\n        rep(j, 0, w) {\n            int a; cin >> a;\n            if (a == 0) swap(v[0], v[1]);\n            else swap(v[1], v[2]);\n        }\n\n        A[get(v)]++;\n    }\n\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n; cin >> n;\n  VVI vec;\n  REP(i, n) {\n    int w;\n    cin >> w;\n    VI v = {0, 1, 2};\n    REP(j, w) {\n      int a; cin >> a;\n      if(a == 0) swap(v[0], v[1]);\n      else swap(v[1], v[2]);\n    }\n    vec.PB(v);\n  }\n\n  if(n >= 6) {\n    cout << \"yes\" << endl;\n    return 0;\n  }\n\n  sort(ALL(vec));\n  FOR(i, 1, 1<<vec.size()) {\n    VVI v;\n    REP(j, vec.size()) {\n      if(i&1<<j) v.PB(vec[j]);\n    }\n    do {\n      VI amida = {0, 1, 2};\n      for(auto k: v) {\n        amida[0] = k[amida[0]];\n        amida[1] = k[amida[1]];\n        amida[2] = k[amida[2]];\n      }\n      if(amida == VI{0, 1, 2}) {\n        cout << \"yes\" << endl;\n        return 0;\n      }\n    } while(next_permutation(ALL(v)));\n  }\n  cout << \"no\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct S {\n\tint a,b,c;\n\tS() {}\n\tS(int a,int b,int c):a(a),b(b),c(c) {}\n\tbool operator<(const S s) const {\n\t\treturn a<s.a;\n\t}\n};\n\nint n;\nint to[50][3];\nset<S> st[2];\n\nvoid dfs(int idx,int a,int b,int c,int limit,bool used) {\n\tif(idx==limit) {\n\t\t//cout<<\"idx=\"<<idx<<\"(\"<<a<<','<<b<<','<<c<<')'<<endl;\n\t\tif(used) {\n\t\t\tif(limit==n) st[1].insert(S(a,b,c));\n\t\t\telse st[0].insert(S(a,b,c));\n\t\t}\n\t\treturn;\n\t}\n\tdfs(idx+1,a,b,c,limit,used);\n\tdfs(idx+1,to[idx][a],to[idx][b],to[idx][c],limit,true);\n}\n\nint f(S s,int i) {\n\tif(i==0) return s.a;\n\telse if(i==1) return s.b;\n\telse return s.c;\n}\n\nS conv(S s,S t) {\n\tS res;\n\tres.a=f(s,t.a),res.b=f(s,t.b),res.c=f(s,t.c);\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tREP(i,50) REP(j,3) to[i][j]=j;\n\n\tcin>>n;\n\tREP(i,n) {\n\t\tint w,a;cin>>w;\n\t\tREP(j,w) {\n\t\t\tcin>>a;\n\t\t\tif(a==0) swap(to[i][0],to[i][1]);\n\t\t\telse swap(to[i][1],to[i][2]);\n\t\t}\n\t}\n\tdfs(0,0,1,2,n/2,false);dfs(n/2,0,1,2,n,false);\n\tfor(auto s:st[0]) {\n\t\t//cout<<s.a<<' '<<s.b<<' '<<s.c<<endl;\n\t\tif(s.a==0&&s.b==1&&s.c==2) {\n\t\t\tcout<<\"yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout<<\"after st1\"<<endl;\n\tfor(auto t:st[1]) {\n\t\t//cout<<t.a<<' '<<t.b<<' '<<t.c<<endl;\n\t\tif(t.a==0&&t.b==1&&t.c==2) {\n\t\t\tcout<<\"yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout<<\"after st2\"<<endl;\n\tfor(auto s:st[0]) {\n\t\tfor(auto t:st[1]) {\n\t\t\tS tmp=conv(s,t);\n\t\t\tif(tmp.a==0&&tmp.b==1&&tmp.c==2) {\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"no\"<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(211); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prms[j], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(211, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if ((b >> e.id) & 1LL) continue;\n      if (e.dst == 12) cycle = true;\n      q.emplace(e.dst, b | (1LL << e.id));\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\nint main() {\n    int n;\n    \n    cin >> n;\n    \n    vector<vector<int>> v;\n    v.resize(n);\n    for(int i = 0; i < n; i++){\n        int w;\n        cin >> w;\n        \n        v[i].push_back(1);\n        v[i].push_back(2);\n        v[i].push_back(3);\n        for(int j = 0; j < w; j++){\n            int a;\n            cin >> a;\n            if(a == 0){\n                if(v[i][0] == 1){\n                    v[i][0] = 2;\n                }\n                else if(v[i][0] == 2){\n                    v[i][0] = 1;\n                }\n                if(v[i][1] == 1){\n                    v[i][1] = 2;\n                }\n                else if(v[i][1] == 2){\n                    v[i][1] = 1;\n                }\n                if(v[i][2] == 1){\n                    v[i][2] = 2;\n                }\n                else if(v[i][2] == 2){\n                    v[i][2] = 1;\n                }\n            }\n            else{\n                if(v[i][0] == 2){\n                    v[i][0] = 3;\n                }\n                else if(v[i][0] == 3){\n                    v[i][0] = 2;\n                }\n                if(v[i][1] == 2){\n                    v[i][1] = 3;\n                }\n                else if(v[i][1] == 3){\n                    v[i][1] = 2;\n                }\n                if(v[i][2] == 2){\n                    v[i][2] = 3;\n                }\n                else if(v[i][2] == 3){\n                    v[i][2] = 2;\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i = 0; i < n; i++){\n        cout << v[i][0] << ' '  << v[i][1] << ' ' << v[i][2] << endl;\n    }\n    */\n    \n    map<pair<pair<int, int>, int>, int> m;\n    for(int i = 0; i < n; i++){\n        if(v[i][0] == 1 && v[i][1] == 2 && v[i][2] == 3){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n        m[{{v[i][0], v[i][1]}, v[i][2]}]++;\n    }\n    for(auto x : m){\n        if(x.second >= 2){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n    }\n    \n    vector<pair<pair<int, int>, int>> w;\n    for(auto x : m){\n        w.push_back(x.first);\n    }\n    \n    do{\n        for(auto x : w){\n            vector<int> y = {1, 2, 3}, tmp = {0, 0, 0};\n            \n            tmp[x.first.first - 1] = y[0];\n            tmp[x.first.second - 1] = y[1];\n            tmp[x.second -  1] = y[2];\n            \n            if(tmp[0] == 1 && tmp[1] == 2 && tmp[2] == 3){\n                cout << \"yes\" << endl;\n                return 0;\n            }\n            else{\n                y[0] = tmp[0];\n                y[1] = tmp[1];\n                y[2] = tmp[2];\n            }\n        }\n    }while(next_permutation(w.begin(), w.end()));\n    \n    cout << \"no\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvector<int> getperm(){\n    int w;\n    cin>>w;\n    vector<int> ret = vector<int>{0,1,2};\n    \n    rep(i,w){\n        int p;\n        cin>>p;\n        if(p==0)swap(ret[0],ret[1]);\n        else    swap(ret[1],ret[2]);\n    }\n    \n    return ret;\n}\n\nvector<int> f(vector<int> origin, vector<int> comb){\n    vector<int> ret(3);\n    rep(i,3){\n        ret[i] = origin[comb[i]];\n    }\n    \n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> v;\n    map<vector<int>,int> mp;\n    rep(i,n){\n        vector<int> t = getperm();\n        if(mp[t]<2){\n            if(mp[t]==0 or t==vector<int>{2,0,1} or t==vector<int>{1,2,0}){\n                v.pb(t);\n            }}\n        mp[t]++;\n    }\n    \n    \n    assert(v.size()<=8);\n    \n    if(mp[vector<int>{2,0,1}]>=3 or\n       mp[vector<int>{1,2,0}]>=3 or\n       mp[vector<int>{2,1,0}]>=2 or\n       mp[vector<int>{1,0,2}]>=2 or\n       mp[vector<int>{0,1,2}]>=2 or\n       mp[vector<int>{0,2,1}]>=2){\n        cout<<\"yes\"<<endl;\n        return 0;\n    }\n    \n    sort(all(v));\n    \n    do{\n        vector<int> t = v[0];\n        if(t==vector<int>{0,1,2}){\n            cout<<\"yes\"<<endl;\n            return 0;\n        }\n        for(int i=1;i<v.size();i++){\n            t = f(t,v[i]);\n            if(t==vector<int>{0,1,2}){\n                cout<<\"yes\"<<endl;\n                return 0;\n            }\n        }\n    }while(next_permutation(all(v)));\n    \n    cout<<\"no\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tstd::vector<int> v(6, 0);\n\tREP(i, n) {\n\t\tVAR(int, w);\n\t\tstd::vector<int> x({1,2,3});\n\t\tREP(_, w) {\n\t\t\tVAR(int, a);\n\t\t\tif (a == 0) std::swap(x[0], x[1]);\n\t\t\tif (a == 1) std::swap(x[1], x[2]);\n\t\t}\n\t\tif (x[0] == 1 && x[1] == 2 && x[2] == 3) ++v[0];\n\t\tif (x[0] == 1 && x[1] == 3 && x[2] == 2) ++v[1]; // (23)\n\t\tif (x[0] == 2 && x[1] == 1 && x[2] == 3) ++v[2]; // (12)\n\t\tif (x[0] == 2 && x[1] == 3 && x[2] == 1) ++v[3]; // (12)(23)\n\t\tif (x[0] == 3 && x[1] == 1 && x[2] == 2) ++v[4]; // (23)(12)\n\t\tif (x[0] == 3 && x[1] == 2 && x[2] == 1) ++v[5]; // (23)(12)(23)\n\t}\n\tbool yes = false;\n\tif (v[0] >= 1) yes |= true;\n\tif (v[1] >= 2) yes |= true;\n\tif (v[2] >= 2) yes |= true;\n\tif (v[3] >= 3) yes |= true;\n\tif (v[4] >= 3) yes |= true;\n\tif (v[3] >= 1 && v[4] >= 1) yes |= true;\n\tif (v[5] >= 2) yes |= true;\n\tif (v[5] >= 1) {\n\t\tif (std::max(v[3], v[4]) >= 1 && std::max(v[1], v[2]) >= 1) yes |= true;\n\t}\n\tif (v[1] >= 1 && v[2] >= 1 && std::max(v[3], v[4]) >= 1) yes |= true;\n\tOUT(yes ? \"yes\" : \"no\")BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\n\nstring change(string boo){\n  string str = \"123\";\n  rep(i,0,boo.sz){\n    if(boo[i] == '1')swap(str[1],str[2]);\n    else swap(str[1],str[0]);\n  }\n  return str;\n}\n\nint main(){\n  t = \"no\";\n  vector<string> vec{\"123\",\"132\",\"321\",\"213\",\"231\",\"312\"};\n  int num[6] = {0,1,1,1,2,2};\n  cin >> n;\n  map<string,int> test;\n  rep(i,0,n){\n    string boolean;\n    cin >> m;\n    rep(j,0,m){\n      char c;\n      cin >> c;\n      boolean += c;\n    }\n    test[change(boolean)]++;\n  }\n  rep(i,0,vec.sz)if(test[vec[i]] > num[i])t = \"yes\";\n  if(test[vec[4]] > 0 && test[vec[5]] > 0)t = \"yes\";\n  if(test[vec[1]] > 0 && test[vec[2]] > 0 && test[vec[4]] > 0)t = \"yes\";\n  if(test[vec[1]] > 0 && test[vec[3]] > 0 && test[vec[4]] > 0)t = \"yes\";\n  if(test[vec[2]] > 0 && test[vec[3]] > 0 && test[vec[5]] > 0)t = \"yes\";\n  print(t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos)\n{\n    if(pos == 6){\n        return (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1)){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvector<int> getperm(){\n    int w;\n    cin>>w;\n    vector<int> ret = vector<int>{0,1,2};\n    \n    rep(i,w){\n        int p;\n        cin>>p;\n        if(p==0)swap(ret[0],ret[1]);\n        else    swap(ret[1],ret[2]);\n    }\n    \n    return ret;\n}\n\nvector<int> f(vector<int> origin, vector<int> comb){\n    vector<int> ret(3);\n    rep(i,3){\n        ret[i] = origin[comb[i]];\n    }\n    \n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> v;\n    map<vector<int>,int> mp;\n    rep(i,n){\n        vector<int> t = getperm();\n        if(mp[t]<2){\n            if(mp[t]==0 or t==vector<int>{2,0,1} or t==vector<int>{1,2,0}){\n                v.pb(t);\n            }}\n        mp[t]++;\n    }\n    \n    \n    assert(v.size()<=8);\n    \n    if(mp[vector<int>{2,0,1}]>=3 or\n       mp[vector<int>{1,2,0}]>=3 or\n       mp[vector<int>{2,1,0}]>=2 or\n       mp[vector<int>{1,0,2}]>=2 or\n       mp[vector<int>{0,1,2}]>=2 or\n       mp[vector<int>{0,2,1}]>=2){\n        cout<<\"yes\"<<endl;\n        return 0;\n    }\n    \n    sort(all(v));\n    \n    do{\n        vector<int> t = v[0];\n        if(t==vector<int>{0,1,2}){\n            cout<<\"yes\"<<endl;\n            return 0;\n        }\n        for(int i=1;i<v.size();i++){\n            t = f(t,v[i]);\n            if(t==vector<int>{0,1,2}){\n                cout<<\"yes\"<<endl;\n                return 0;\n            }\n        }\n    }while(next_permutation(all(v)));\n    \n    cout<<\"no\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\n\n//123:0(1個未満)\n//132:1(二個未満)\n//213:2(二個未満)\n//321:3(二個未満)\n//231:4\n//312:5\nstd::array<int, 3> get_type(int id)\n{\n\tswitch (id)\n\t{\n\tcase 0:\n\t\treturn {1,2,3};\n\tcase 1:\n\t\treturn { 1,3,2 };\n\tcase 2:\n\t\treturn { 2,1,3 };\n\tcase 3:\n\t\treturn { 3,2,1 };\n\tcase 4:\n\t\treturn { 2,3,1 };\n\tcase 5:\n\t\treturn { 3,1,2 };\n\tdefault:\n\t\tbreak;\n\t}\n}\nint get_id(std::array<int, 3> res)\n{\n\tif (res[0] == 1) {\n\t\tif (res[1] == 2) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (res[0] == 2) {\n\t\tif (res[1] == 1) {\n\t\t\treturn 2;\n\t\t}\n\t\telse {\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse  {\n\t\tif (res[1] == 1) {\n\t\t\treturn 5;\n\t\t}\n\t\telse {\n\t\t\treturn 3;\n\t\t}\n\t}\n}\n\nint amida_num[6];\n\nbool func(std::array<int, 3> v)\n{\n\tfor (int32_t i = 0; i < 6; i++)\n\t{\n\t\tif (amida_num[i] > 0)\n\t\t{\n\t\t\t--amida_num[i];\n\t\t\tauto sw = get_type(i);\n\n\t\t\tstd::array<int, 3> next;\n\t\t\tnext[0] = v[sw[0] - 1];\n\t\t\tnext[1] = v[sw[1] - 1];\n\t\t\tnext[2] = v[sw[2] - 1];\n\t\t\tif (get_id(next) == 0) { return true; }\n\t\t\tif (func(next)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t++amida_num[i];\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tint32_t w;\n\t\tin >> w;\n\t\tstd::array<int, 3> res{ 1,2,3 };\n\t\twhile(w--)\n\t\t{\n\t\t\tint t;\n\t\t\tin >> t;\n\t\t\tif (t == 1) {\n\t\t\t\tstd::swap(res[1], res[2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::swap(res[1], res[0]);\n\t\t\t}\n\t\t}\n\t\tamida_num[get_id(res)]++;\n\t}\n\tif (amida_num[0] >= 1) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[1] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[2] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[3] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[4] >= 3) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[5] >= 3) { out << \"yes\" << endl; return 0; }\n\n\tif (func({ 1,2,3 })) {\n\t\tout << \"yes\" << endl;\n\t}\n\telse {\n\t\tout << \"no\" << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <bitset>\nusing namespace std;\n\nint point(tuple<int, int, int> t) {\n    if        (t == make_tuple(0,1,2)) {\n        return 0;\n    } else if (t == make_tuple(0,2,1)) {\n        return 1;\n    } else if (t == make_tuple(1,0,2)) {\n        return 2;\n    } else if (t == make_tuple(1,2,0)) {\n        return 3;\n    } else if (t == make_tuple(2,0,1)) {\n        return 4;\n    } else if (t == make_tuple(2,1,0)) {\n        return 5;\n    }\n}\n\nbool dfs(const vector<vector<vector<int>>> &graph, bitset<50> used, int pos) {\n    // 0に戻れるか\n    for (int amida_id: graph[pos][0]) {\n        if (used[amida_id] != 1) return true;\n    }\n    \n    // 移動\n    bool f = false;\n    for (int i=0; i<6; i++) {\n        for (int amida_id: graph[pos][i]) {\n            if (used[amida_id] != 1) {\n                bitset<50> new_used = used;\n                new_used[amida_id] = 1;\n                f |= dfs(graph, new_used, i);\n            }\n        }\n    }\n    return f; \n}\n\nvoid solve(const vector<tuple<int, int, int>> &amida) {\n    // 置換に変換\n    /*\n    for (tuple<int, int, int> t: amida) \n        cout << \"{\" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << \"}\" << endl;\n    */\n\n    vector<vector<vector<int>>> graph(6);\n    for (auto &x: graph) x.resize(6);\n\n    int c = 0;\n    for (tuple<int,int,int> t: amida) {\n        for (int i=0; i<3; i++)\n            for (int j=0; j<3; j++)\n                for (int k=0; k<3; k++)\n                    if (i!=j && i!=k && j!=k) {\n                        vector<int> l = {i,j,k};\n                        graph[point(make_tuple(i,j,k))]\n                             [point(make_tuple(l[get<0>(t)-1], l[get<1>(t)-1], l[get<2>(t)-1]))]\n                            .push_back(c);\n                    }\n        c++;\n    }\n\n    /*\n    cout << \"0\" << endl;\n    for (int i=0; i<6; i++) {\n        cout << i << \": \";\n        for (auto x: graph[0][i]) {\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    if (dfs(graph, bitset<50>(0), 0)) {\n        cout << \"yes\" << endl;\n    } else {\n        cout << \"no\" << endl;\n    }\n}\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> in(n);\n\n    for (auto &x: in) {\n        int w; cin >> w; x.resize(w);\n        for (auto &y: x) cin >> y;\n    }\n\n    vector<tuple<int, int, int>> amida(n);\n    for (int i=0; i<n; i++) {\n        tuple<int, int, int> state = make_tuple(1, 2, 3);\n        reverse(in[i].begin(), in[i].end());\n        for (auto x: in[i]) {\n            if (x == 0) {\n                state = make_tuple(get<1>(state), get<0>(state), get<2>(state));\n            } else {\n                state = make_tuple(get<0>(state), get<2>(state), get<1>(state));\n            }\n        }\n        amida[i] = state;\n    }\n\n    solve(amida);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(3,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[i];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[i]], v[q[i] + 1]);\n    prm[i] = stoi(v);\n  }\n  exit(0);\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prm[i], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nmap<VI, int> mp;\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n) {\n    int w;\n    cin >> w;\n    VI vec = {0, 1, 2};\n    REP(j, w) {\n      int a; cin >> a;\n      if(a == 0) {\n        swap(vec[0], vec[1]);\n      } else{\n        swap(vec[1], vec[2]);\n      }\n    }\n    mp[vec]++;\n  }\n\n  if(n >= 6) {\n    cout << \"yes\" << endl;\n    return 0;\n  }\n\n  VVI vv;\n  for(auto i: mp) {\n    REP(j, i.second) {\n      vv.PB(i.first);\n    }\n  }\n\n  sort(ALL(vv));\n  FOR(i, 1, 1<<vv.size()) {\n    VVI v;\n    REP(j, vv.size()) {\n      if(i&1<<j) v.PB(vv[j]);\n    }\n    // sort(ALL(v));\n    // cout << v << endl;\n    do {\n      VI v2 = {0, 1, 2};\n      for(auto &i: v) {\n        v2[0] = i[v2[0]];\n        v2[1] = i[v2[1]];\n        v2[2] = i[v2[2]];\n      }\n      if(v2 == VI{0, 1, 2}) {\n        cout << \"yes\" << endl;\n        return 0;\n      }\n    } while(next_permutation(ALL(v)));\n  }\n\n  cout << \"no\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tstd::vector<int> v(6, 0);\n\tREP(i, n) {\n\t\tVAR(int, w);\n\t\tstd::vector<int> x({1,2,3});\n\t\tREP(_, w) {\n\t\t\tVAR(int, a);\n\t\t\tif (a == 0) std::swap(x[0], x[1]);\n\t\t\tif (a == 1) std::swap(x[1], x[2]);\n\t\t}\n\t\tif (x[0] == 1 && x[1] == 2 && x[2] == 3) ++v[0];\n\t\tif (x[0] == 1 && x[1] == 3 && x[2] == 2) ++v[1]; // (23)\n\t\tif (x[0] == 2 && x[1] == 1 && x[2] == 3) ++v[2]; // (12)\n\t\tif (x[0] == 2 && x[1] == 3 && x[2] == 1) ++v[3]; // (12)(23)\n\t\tif (x[0] == 3 && x[1] == 1 && x[2] == 2) ++v[4]; // (23)(12)\n\t\tif (x[0] == 3 && x[1] == 2 && x[2] == 1) ++v[5]; // (23)(12)(23)\n\t}\n\tbool yes = false;\n\tif (v[0] >= 1) yes |= true;\n\tif (v[1] >= 2) yes |= true;\n\tif (v[2] >= 2) yes |= true;\n\tif (v[3] >= 3) yes |= true;\n\tif (v[4] >= 3) yes |= true;\n\tif (v[3] >= 1 && v[4] >= 1) yes |= true;\n\tif (v[5] >= 2) yes |= true;\n\tif (v[5] >= 1) {\n\t\tif (v[3] >= 1 && v[1] >= 1) yes |= true;\n\t\tif (v[4] >= 1 && v[2] >= 1) yes |= true;\n\t}\n\tif (v[1] >= 1 && v[2] >= 1 && std::max(v[3], v[4]) >= 1) yes |= true;\n\tOUT(yes ? \"yes\" : \"no\")BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1)))){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvector<int> getperm(){\n    int w;\n    cin>>w;\n    vector<int> ret = vector<int>{0,1,2};\n    \n    rep(i,w){\n        int p;\n        cin>>p;\n        if(p==0)swap(ret[0],ret[1]);\n        else    swap(ret[1],ret[2]);\n    }\n    \n    return ret;\n}\n\nvector<int> f(vector<int> origin, vector<int> comb){\n    vector<int> ret(3);\n    rep(i,3){\n        ret[i] = origin[comb[i]];\n    }\n    \n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> v;\n    map<vector<int>,int> mp;\n    rep(i,n){\n        vector<int> t = getperm();\n        if(mp[t]>=2)continue;\n        if(mp[t]==0 or t==vector<int>{2,0,1} or t==vector<int>{1,2,0}){\n            v.pb(t);\n            mp[t]++;\n        }\n    }\n    \n    \n    assert(v.size()<=8);\n\n    sort(all(v));\n    \n    do{\n        vector<int> t = v[0];\n        if(t==vector<int>{0,1,2}){\n            cout<<\"yes\"<<endl;\n            return 0;\n        }\n        for(int i=1;i<v.size();i++){\n            t = f(t,v[i]);\n            if(t==vector<int>{0,1,2}){\n                cout<<\"yes\"<<endl;\n                return 0;\n            }\n        }\n    }while(next_permutation(all(v)));\n    \n    \n    cout<<\"no\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint main () {\n    int n;\n    cin >> n;\n    if (n > 5) {\n        cout << \"yes\" << endl;\n        return 0;\n    }\n    int rots[5][3];\n    for(int i = 0; i < n; i++) {\n        int m;\n        cin >> m;\n        for(int j = 0; j < 3; j++) rots[i][j] = j;\n        for(int j = 0; j < m; j++) {\n            int b;\n            cin >> b;\n            if (b == 0) {\n                swap(rots[i][0], rots[i][1]);\n            } else {\n                swap(rots[i][1], rots[i][2]);\n            }\n        }\n    }\n    int par[n];\n    for(int i = 0; i < n; i++) par[i] = i;\n    int ans[3] = {0, 1, 2};\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < 3; j++) ans[j] = ans[rots[par[i]][j]];\n        if (ans[0] == 0 && ans[1] == 1 && ans[2] == 2) {\n            cout << \"yes\" << endl;\n            return 0;\n        }\n    }\n    while(next_permutation(par, par + n)) {\n        for(int i = 0; i < 3; i++) ans[i] = i;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < 3; j++) ans[j] = ans[rots[par[i]][j]];\n            if (ans[0] == 0 && ans[1] == 1 && ans[2] == 2) {\n                cout << \"yes\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"no\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nstruct state{\n    int a,b,c;\n};\nbool operator<(const state&p,const state&q){\n    if(p.a==q.a){\n        if(p.b==q.b){\n            return p.c<q.c;\n        }\n        return p.b<q.b;\n    }\n    return p.a<q.a;\n}\nbool operator==(const state&p,const state&q){\n    return p.a==q.a&&p.b==q.b&&p.c==q.c;\n}\nstate f(state now,const vi& vec){\n    REP(i,vec.size()){\n        if(vec[i]==0){\n            swap(now.a,now.b);\n        }else{\n            swap(now.b,now.c);\n        }\n    }\n    return now;\n}\nint main(){\n    int n;\n    cin>>n;\n    vvi vec(n);\n    REP(i,n){\n        int s;\n        cin>>s;\n        vec[i].resize(s);\n        REP(j,s){\n            cin>>vec[i][j];\n        }\n    }\n    bool ans=false;\n    set<state> se;\n    se.insert({0,1,2});\n    REP(i,n){\n        set<state> next;\n        for(auto itr:se){\n            state t=itr;\n            state u=f(t,vec[i]);\n            if(u==state{0,1,2}){\n                ans=true;\n            }\n            next.insert(t);\n            next.insert(u);\n        }\n        se=next;\n    }\n    if(ans){\n        cout<<\"yes\"<<endl;\n    }else{\n        cout<<\"no\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]+1){\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1)))){\n            return true;\n        }\n        if(i == cnt[pos]){\n            break;\n        }\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nstruct state{\n    int a,b,c;\n};\nbool operator<(const state& p,const state&q){\n    if(p.a==q.a){\n        if(p.b==q.b){\n            return p.c<q.c;\n        }\n        return p.b<q.b;\n    }\n    return p.a<q.a;\n}\nstate f(state now,const vi& vec){\n    REP(i,vec.size()){\n        if(vec[i]==0){\n            swap(now.a,now.b);\n        }else{\n            swap(now.b,now.c);\n        }\n    }\n    return now;\n}\nint main(){\n    int n;\n    cin>>n;\n    vvi vec(n);\n    REP(i,n){\n        int s;\n        cin>>s;\n        vec[i].resize(s);\n        REP(j,s){\n            cin>>vec[i][j];\n        }\n    }\n    queue<state> que;\n    que.push(state{0,1,2});\n    set<state> se;\n    while(que.size()){\n        state st=que.front();que.pop();\n        if(se.count(st)){\n            continue;\n        }\n        REP(i,n){\n            state nex=f(st,vec[i]);\n            if(!se.count(nex)){\n                se.insert(nex);\n                que.push(nex);\n            }\n        }\n    }\n    if(se.count(state{0,1,2})){\n        cout<<\"yes\"<<endl;\n    }else{\n        cout<<\"no\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos)\n{\n    if(pos == 6){\n        return (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1)){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<map>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nint main(){\n  int n;\n  cin>>n;\n  map<vi,int> f;\n  vector<vi> pp;\n  rep(i,n){\n    int w;\n    cin>>w;\n    vi p(3);\n    rep(j,3)p[j]=j;\n    rep(j,w){\n      int a;\n      cin>>a;\n      swap(p[a],p[a+1]);\n    }\n    f[p]++;\n    pp.push_back(p);\n  }\n  if(n>=8){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n  sort(pp.begin(),pp.end());\n  do{\n    vi acc(3);\n    rep(i,3)acc[i]=i;\n    rep(i,pp.size()){\n      vi t(3);\n      rep(j,3){\n\tt[j]=acc[pp[i][j]];\n      }\n      bool eq=1;\n      rep(j,3)eq&=t[j]==j;\n      if(eq){\n\tcout<<\"yes\"<<endl;\n\treturn 0;\n      }\n    }\n  }while(next_permutation(pp.begin(),pp.end()));\n  cout<<\"no\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(3,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i, a, b) for(auto i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\tmap <string, int> cnt;\n\trep (i, n) {\n\t\tint w;\n\t\tcin >> w;\n\t\tstring num = \"123\";\n\t\trep (j, w) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a) swap(num[1], num[2]);\n\t\t\telse swap(num[0], num[1]);\n\t\t}\n\t\tcnt[num]++;\n\t}\n\tif (cnt[\"123\"] >= 1 || cnt[\"132\"] >= 2 || cnt[\"213\"] >= 2 || cnt[\"231\"] >= 3\n\t || cnt[\"312\"] >= 3 || cnt[\"321\"] >= 2 || (cnt[\"231\"] >= 1 && cnt[\"312\"] >= 1)) {\n\t\tcout << \"yes\" << endl;\n\t} else {\n\t\tcout << \"no\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//あみだくじは「置換」で表せる。これは6通りしかないので、実質N ≦ 6。よって全部試せる。\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint w, a;\nvector<vector<int>> ts;\n\nbool dfs(int used, vector<int> perm) {\n\tint i, j;\n\t\n\tif (used > 0 && perm[0] == 0 && perm[1] == 1 && perm[2] == 2) return true;\n\tfor (i = 0; i < ts.size(); i++) {\n\t\tif ((used >> i) & 1) continue;\n\t\t\n\t\tvector<int> nP;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tnP.push_back(ts[i][perm[j]]);\n\t\t}\n\t\tbool res = dfs(used + (1 << i), nP);\n\t\tif (res) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> w;\n\t\tint hoge[3] = {0, 1, 2};\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tcin >> a;\n\t\t\tswap(hoge[a], hoge[a + 1]);\n\t\t}\n\t\t\n\t\tvector<int> tikan;\n\t\tfor (j = 0; j < 3; j++) tikan.push_back(hoge[j]);\n\t\tts.push_back(tikan);\n\t}\n\tsort(ts.begin(), ts.end());\n\tts.erase(unique(ts.begin(), ts.end()), ts.end());\n\t\n\t//for (i = 0; i < ts.size(); i++) { for (j = 0; j < 3; j++) cout << ts[i][j] << \" \" ; cout << endl; }\n\tbool res = dfs(0, {0, 1, 2});\n\tif (res) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n;\nmap<tuple<int, int, int>, int> cnt;\n\nbool pre_check() {\n  if (cnt[make_tuple(0, 1, 2)] >= 1) return true;\n  else if (cnt[make_tuple(0, 2, 1)] >= 2) return true;\n  else if (cnt[make_tuple(1, 0, 2)] >= 2) return true;\n  else if (cnt[make_tuple(1, 2, 0)] >= 3) return true;\n  else if (cnt[make_tuple(2, 0, 1)] >= 3) return true;\n  else if (cnt[make_tuple(2, 1, 0)] >= 2) return true;\n  else if (cnt[make_tuple(1, 2, 0)] >= 1 && cnt[make_tuple(2, 0, 1)] >= 1) return true;\n  return false;\n}\n\nvector<int> amida_goal(int amida_num, vector<int> &amida_yoko) {\n    vector<int> goal(amida_num);\n    rep(i, amida_num) goal[i] = i;\n    int ysize = amida_yoko.size();\n    rep(i, ysize) {\n        int l = amida_yoko[i];\n        int r = l + 1;\n        swap(goal[l], goal[r]);\n\n    }\n    return goal;\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i, n) {\n      int w;\n      cin >> w;\n      vector<int> a(w);\n      rep(j, w) cin >> a[j];\n      vector<int> goal = amida_goal(3, a);\n      cnt[make_tuple(goal[0], goal[1], goal[2])]++;\n    }\n    if (pre_check()) {\n      cout << \"yes\" << endl;\n      return 0;\n    }\n    if (cnt[make_tuple(1, 2, 0)] == 0 && cnt[make_tuple(2, 0, 1)] == 0) {\n      cout << \"no\" << endl;\n    }\n    else {\n      if (cnt[make_tuple(0, 2, 1)] >= 1 && cnt[make_tuple(1, 0, 2)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else if (cnt[make_tuple(0, 2, 1)] >= 1 && cnt[make_tuple(2, 1, 0)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else if (cnt[make_tuple(1, 0, 2)] >= 1 && cnt[make_tuple(2, 1, 0)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else cout << \"no\" << endl;\n    }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(3,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==4)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(3,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\n\nstring change(string boo){\n  string str = \"123\";\n  rep(i,0,boo.sz){\n    if(boo[i] == '1')swap(str[1],str[2]);\n    else swap(str[1],str[0]);\n  }\n  return str;\n}\n\nstring exchange(string str,string key){\n  if(key == \"132\")swap(str[1],str[2]);\n  if(key == \"321\")swap(str[0],str[2]);\n  if(key == \"213\")swap(str[0],str[1]);\n  if(key == \"231\"){\n    swap(str[0],str[1]);\n    swap(str[1],str[2]);\n  }\n  if(key == \"312\"){\n    swap(str[0],str[1]);\n    swap(str[0],str[2]);\n  }\n  return str;\n}\n\nint main(){\n  t = \"no\";\n  int num[6] = {0,1,1,1,2,2};\n  cin >> n;\n  vector<string> vec{\"123\",\"132\",\"321\",\"213\",\"231\",\"312\"};\n  map<string,int> test;\n  rep(i,0,n){\n    string boolean;\n    cin >> m;\n    rep(j,0,m){\n      char c;\n      cin >> c;\n      boolean += c;\n    }\n    test[change(boolean)]++;\n  }\n  rep(i,0,vec.sz)if(test[vec[i]] > num[i])t = \"yes\";\n  if(t != \"yes\"){\n    vector<string> vec2;\n    rep(i,1,6){\n      rep(j,0,test[vec[i]])vec2.pb(vec[i]);\n    }\n    sort(all(vec));\n    do{\n      string res = vec2[0];\n      // cout << \"first_res:\" << res << endl;\n      rep(i,1,vec2.sz){\n        res = exchange(res,vec2[i]);\n        // cout << \"res:\" << res << endl;\n        if(res == \"123\")t = \"yes\";\n      }\n    }while(next_permutation(vec2.begin(),vec2.end()));\n  }\n  print(t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nvector<vector<int> > v(55);\n\nbool check(vector<int> vec){\n\tstring str = \"012\";\n\t//cout << \"!!\" << endl;\n\tREP(i,vec.size()){\n\t\tint now = vec[i];\n\t\tREP(j,v[now].size()){\n\t\t\tif(v[now][j] == 0){\n\t\t\t\tswap(str[0],str[1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tswap(str[1],str[2]);\n\t\t\t}\n\t\t}\n\t\t//cout << str << endl;\n\t\tif(str == \"012\")return true;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\tint n;cin >> n;\n\t\n\tREP(i,n){\n\t\tint w;cin >> w;\n\t\tREP(j,w){\n\t\t\tint tmp;cin >> tmp;\n\t\t\tv[i].PB(tmp);\n\t\t}\n\t}\n\t\n\tif(n > 7){\n\t\tcout << \"yes\" << endl;\n\t}\n\telse\n\t{\n\t\tvector<int> par(n);\n\t\tREP(i,n)par[i] = i;\n\t\tdo{\n\t\t\tif(check(par)){\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}while(next_permutation(ALL(par)));\n\t}\n\t\n\tcout << \"no\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint out_table[50][3];\nmap<int,bool> MAP;\nbool FLG;\n\n\nint makeCode(int code[3]){\n\treturn 100*code[0]+10*code[1]+code[2];\n}\n\n\nvoid recursive(int code[3],bool used[50]){\n\tif(FLG)return;\n\tint tmp_code;\n\n\tint next_code[3];\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tnext_code[out_table[i][k]] = code[k];\n\t\t\t}\n\n\t\t\ttmp_code = makeCode(next_code);\n\n\t\t\tif(tmp_code == 12){\n\t\t\t\tFLG = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tauto at = MAP.find(tmp_code);\n\t\t\tif(at != MAP.end())continue;\n\t\t\tMAP[tmp_code] = true;\n\n\t\t\tbool next_used[50];\n\t\t\tfor(int k = 0; k < N; k++)next_used[k] = used[k];\n\t\t\tnext_used[i] = true;\n\t\t\trecursive(next_code,next_used);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint yoko_num,work[3],tmp;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d\",&yoko_num);\n\n\t\tfor(int i = 0; i < 3; i++)work[i] = i;\n\n\t\tfor(int i = 0; i < yoko_num; i++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tif(tmp == 0){\n\t\t\t\tswap(work[0],work[1]);\n\t\t\t}else{\n\t\t\t\tswap(work[1],work[2]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tout_table[loop][work[i]] = i;\n\t\t}\n\t}\n\n\tFLG = false;\n\tint first_code[3] = {0,1,2};\n\tbool first_used[50];\n\tfor(int i = 0; i < N; i++)first_used[i] = false;\n\n\trecursive(first_code,first_used);\n\n\tif(FLG){\n\t\tprintf(\"yes\\n\");\n\t}else{\n\t\tprintf(\"no\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tnums[i]=min(2,nums[i]);\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day2/problems/F>\n問題文============================================================\n\n 縦線が３本のあみだくじがN個ある。\n どの線からスタートしてもスタートした線で終わるあみだくじを良いあみだくじとする。\n あみだくじを１つ以上選んで縦に自由な順序でつなぐことができる。\n 良いあみだくじを作ることができるのであれば\"yes\"、そうでなければ\"no\"を出力せよ。\n \n i番目のあみだくじには横線がwi本ある。\n ai,jはあみだくじiの上からj番目の横棒が中央の縦線から左右どちらに伸びているかを表し、\n ai,jが0ならば左に、1ならば右に伸びていることを表す。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    ll N; cin >> N;\n    set<pair<pll,ll>> s;\n    for(int i = 0; i < N;i++){\n        ll w; cin >> w;\n        ll l = 0, m = 1, r = 2;\n        for(int j = 0; j < w;j++){\n            ll a; cin >> a;\n            if(a == 0){\n                swap(l,m);\n            }else{\n                swap(r,m);\n            }\n        }\n        s.insert({{l,m},r});\n    }\n    vector<pair<pll,ll>> H(s.begin(),s.end());\n\n    vector<int> per(s.size());\n    iota(per.begin(),per.end(),0);\n    do{\n        ll h[3];\n        for(int i = 0; i < N;i++){\n            auto& e = H[per[i]];\n            if(i == 0){\n                h[0] = e.first.first; h[1] = e.first.second; h[2] = e.second;\n            }else{\n                h[0] = h[e.first.first]; h[1] = h[e.first.second]; h[2] = h[e.second];\n            }\n            if(h[0] == 0 && h[1] == 1 && h[2] == 2){\n                cout << \"yes\" << endl; return 0;\n            }\n        }\n//        cout << per << endl;\n    }while(next_permutation(per.begin(),per.end()));\n    cout << \"no\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\ntemplate<typename T>\nint index(const vector<T> &zip, T i) { return lower_bound(zip.begin(), zip.end(), i) - zip.begin(); }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\n\tusing T = tuple<int, int, int>;\n\tvector<int> w(N);\n\tvector<vector<int>> a(N);\n\tvector<vector<int>> d(N);\n\n\trep(i, 0, N) {\n\t\tcin >> w[i];\n\t\trep(j, 0, w[i]) {\n\t\t\tint t; cin >> t;\n\t\t\ta[i].emplace_back(t);\n\t\t}\n\t\tvector<int> v(3); iota(all(v), 0);\n\t\trep(j, 0, w[i]) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tswap(v[0], v[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(v[1], v[2]);\n\t\t\t}\n\t\t}\n\t\td[i].assign(3, 0);\n\t\trep(j, 0, 3) {\n\t\t\td[i][v[j]] = j;\n\t\t}\n\t}\n\tdump(d);\n\n\tvector<vector<int>> A{ {0,1,2 } }, B{ {0,1,2} };\n\trep(i, 0, N / 2) {\n\t\tint n = A.size();\n\t\trep(j, 0, n) {\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[d[i][k]] = A[j][k];\n\t\t\t}\n\t\t\tif (tmp == vector<int>{0, 1, 2}) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA.emplace_back(tmp);\n\t\t}\n\t}\n\trep(i, N / 2, N) {\n\t\tint n = B.size();\n\t\trep(j, 0, n) {\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[d[i][k]] = B[j][k];\n\t\t\t}\n\t\t\tif (tmp == vector<int>{0, 1, 2}) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tB.emplace_back(tmp);\n\t\t}\n\t}\n\tdump(A, B);\n\n\tA.erase(A.begin());\n\tB.erase(B.begin());\n\n\tA = compress(A);\n\tB = compress(B);\n\n\tdump(A, B);\n\tbool yes = false;\n\n\tif (find(all(A), vector<int>{0, 1, 2}) != A.end() ||\n\t\tfind(all(B), vector<int>{0, 1, 2}) != B.end()) {\n\t\tyes = true;\n\t}\n\n\tvector<vector<int>> C;\n\trep(i, 0, A.size()) {\n\t\trep(j, 0, B.size()) {\n\t\t\tvector<int> dist(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\tdist[B[j][k]] = k;\n\t\t\t}\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[dist[k]] = A[i][k];\n\t\t\t}\n\t\t\tC.emplace_back(tmp);\n\t\t}\n\t}\n\n\tif (find(all(C), vector<int>{0, 1, 2}) != C.end()) {\n\t\tyes = true;\n\t}\n\n\tif (yes)cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]+1){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1)))){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvector<int> getperm(){\n    int w;\n    cin>>w;\n    vector<int> ret = vector<int>{0,1,2};\n    \n    rep(i,w){\n        int p;\n        cin>>p;\n        if(p==0)swap(ret[0],ret[1]);\n        else    swap(ret[1],ret[2]);\n    }\n    \n    return ret;\n}\n\nvector<int> f(vector<int> origin, vector<int> comb){\n    vector<int> ret(3);\n    rep(i,3){\n        ret[i] = origin[comb[i]];\n    }\n    \n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> v(n,vector<int>(3));\n    rep(i,n){\n        v[i] = getperm();\n    }\n    \n    set<vector<int>> dp;\n    \n    dp.insert(v[0]);\n    for(int i=1;i<n;i++){\n        set<vector<int>> tdp = dp;\n        for(auto e:tdp){\n            dp.insert(f(e,v[i]));\n        }\n    }\n    if(dp.count(vector<int>{0,1,2}))cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//あみだくじは「置換」で表せる。これは6通りしかないので、実質N ≦ 6。よって全部試せる。\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint w, a;\nvector<vector<int>> ts;\n\nbool dfs(int used, vector<int> perm) {\n\tint i, j;\n\t\n\tif (used > 0 && perm[0] == 0 && perm[1] == 1 && perm[2] == 2) return true;\n\tfor (i = 0; i < ts.size(); i++) {\n\t\tif ((used >> i) & 1) continue;\n\t\t\n\t\tvector<int> nP;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tnP.push_back(ts[i][perm[j]]);\n\t\t}\n\t\tbool res = dfs(used + (1 << i), nP);\n\t\tif (res) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> w;\n\t\tint hoge[3] = {0, 1, 2};\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tcin >> a;\n\t\t\tswap(hoge[a], hoge[a + 1]);\n\t\t}\n\t\t\n\t\tvector<int> tikan;\n\t\ttikan.resize(3);\n\t\tfor (j = 0; j < 3; j++) tikan[hoge[j]] = j;\n\t\tts.push_back(tikan);\n\t}\n\tsort(ts.begin(), ts.end());\n\tts.erase(unique(ts.begin(), ts.end()), ts.end());\n\t\n\t//for (i = 0; i < ts.size(); i++) { for (j = 0; j < 3; j++) cout << ts[i][j] << \" \" ; cout << endl; }\n\tbool res = dfs(0, {0, 1, 2});\n\tif (res) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prms[j], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(300, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if ((b >> e.id) & 1LL) continue;\n      if (e.dst == 12) cycle = true;\n      q.emplace(e.dst, b | (1LL << e.id));\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//あみだくじは「置換」で表せる。これは6通りしかないので、実質N ≦ 6。よって全部試せる。\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint w, a;\nvector<vector<int>> ts;\n\nbool dfs(int used, vector<int> perm) {\n\tint i, j;\n\t\n\tif (used > 0 && perm[0] == 0 && perm[1] == 1 && perm[2] == 2) return true;\n\tfor (i = 0; i < ts.size(); i++) {\n\t\tif ((used >> i) & 1) continue;\n\t\t\n\t\tvector<int> nP;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tnP.push_back(ts[i][perm[j]]);\n\t\t}\n\t\tbool res = dfs(used + (1 << i), nP);\n\t\tif (res) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> w;\n\t\tint hoge[3] = {0, 1, 2};\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tcin >> a;\n\t\t\tswap(hoge[a], hoge[a + 1]);\n\t\t}\n\t\t\n\t\tvector<int> tikan;\n\t\tfor (j = 0; j < 3; j++) tikan.push_back(hoge[j]);\n\t\tts.push_back(tikan);\n\t}\n\tsort(ts.begin(), ts.end());\n\tts.erase(unique(ts.begin(), ts.end()), ts.end());\n\t\n\t//for (i = 0; i < ts.size(); i++) { for (j = 0; j < 3; j++) cout << ts[i][j] << \" \" ; cout << endl; }\n\tbool res = dfs(0, {0, 1, 2});\n\tif (res) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nbool operator<(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]==r[i])continue;\n\t\telse return false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N;cin>>N;\n\n\tmap<vector<int>,int>mp;\n\tmap<int,vector<int>>rev_mp;\n\tvector<int>v(3);\n\tiota(v.begin(),v.end(),0);\n\t{\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tmp[v]=i*2+j;\n\t\t\t\trev_mp[i*2+j]=v;\n\t\t\t\tswap(v[0],v[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>nums(6);\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int>perms(3);\n\t\tiota(perms.begin(),perms.end(),0);\n\n\t\tint w;cin>>w;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tint k;cin>>k;\n\t\t\tswap(perms[k],perms[k+1]);\n\t\t}\n\t\tnums[mp[perms]]++;\n\t}\n\n\tset<pair<int,vector<int>>>memo;\n\tmemo.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tqueue<pair<int,vector<int>>>que;\n\tque.emplace(mp[vector<int>{0, 1, 2}],nums);\n\n\tbool aok=false;\n\twhile (!que.empty()) {\n\t\tauto p(que.front());\n\t\tque.pop();\n\t\tint status_id=p.first;\n\t\tvector<int> rest=p.second;\n\n\t\tfor (int use_id = 0; use_id < 6; ++use_id) {\n\t\t\tif (rest[use_id]) {\n\t\t\t\trest[use_id]--;\n\n\t\t\t\tvector<int>now_status(rev_mp[status_id]);\n\t\t\t\tvector<int>next_status(now_status);\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tauto next_change(rev_mp[use_id]);\n\n\t\t\t\t\tnext_status[next_change[i]]= now_status[i];\n\n\t\t\t\t}\n\t\t\t\tint next_status_id = mp[next_status];\n\t\t\t\tif(next_status_id==0)aok=true;\n\t\t\t\tif (memo.find(make_pair(next_status_id, rest)) == memo.end()) {\n\t\t\t\t\tmemo.emplace(next_status_id, rest);\n\t\t\t\t\tque.emplace(next_status_id, rest);\n\t\t\t\t}\n\n\t\t\t\trest[use_id]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok=memo.find(make_pair(4,vector<int>(6,0)))!=memo.end();\n\tif(aok)cout<<\"yes\"<<endl;\n\telse cout<<\"no\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n/*\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first>vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<v2.first)return v1;\n\t\telse if(v1.first>v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n\n\n\nstruct Segmax{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first>vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first<vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmax(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp(-(1ll<<31),-1);\n\t\t}\n\t\t\n\t\tpa v1=segmax(a,b,k*2,l,(l+r)/2),v2=segmax(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first>v2.first)return v1;\n\t\telse if(v1.first<v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n*/\nbool bo(string s,string t){\n\tif(s.length()<t.length()) return false;\n\tif(s.length()==t.length())return s==t;\n\t\n\t\n\tint it1=0,it2=0;\n\t\n\tfor(int i=0;i<t.length();i++){\n\t\tif(it1==s.length()) return false;\n\t\t\n\t\twhile(s[it1]!=t[i]){\n\t\tit1++;\n\t\t\tif(it1==s.length()) return false;\n\t\t}\n\t//\tcout<<i<<\" \"<<it1<<endl;\n\t\tit1++;\n\t}\n\treturn true;\n\t\n}\n\nint h,w,q;\nstring yaru(string s,int r){\n\tif(r==1) return s;\n\t\n\tstring e=yaru(s,r-1);\n\tstring ans=e;\n\tfor(int i=0;i<s.length();i++){\n\t\tans+=s[i];\n\t\tans+=e;\n\t\tif(ans.length()>100020) return \"===#$%\";\n\t}\n\t//cout<<r<<\" \"<<ans<<endl;\n\treturn ans;\n}\n\nmap<string,int>ma;\nstring s[6]={\"123\",\"132\",\"213\",\"231\",\"312\",\"321\"};\n\nint ch(int i,int j){\nstring f=\"   \";\n\tfor(int k=0;k<3;k++)for(int l=0;l<3;l++)if(s[i][k]==s[j][l])f[k]='0'+l+1;\n\treturn ma[f];\n}\n\nsigned main(){\nma[\"123\"]=0;\n\tma[\"132\"]=1;\n\tma[\"213\"]=2;\n\tma[\"231\"]=3;\n\tma[\"312\"]=4;\n\tma[\"321\"]=5;\n\t\n\tint cnt[6]={0};\n\t\n\tint n;\n\tcin>>n;\n\t\n\tfor(int g=0;g<n;g++){\n\tint f;\n\t\tcin>>f;\n\t\tstring s=\"123\";\n\t\tfor(int i=0;i<f;i++){\n\t\t\tint sd;\n\t\tcin>>sd;\n\t\t\tif(sd==0)swap(s[0],s[1]);\n\t\t\telse swap(s[1],s[2]);\n\t\t}\n\tcnt[ma[s]]++;\n\t}\n\t\n\t\n\tif(cnt[0]>0){\n\tcout<<\"yes\"<<endl;\n\t\treturn 0;\n\t}\n\t\n\t\n\tvector<int> ve2,ve;\n\t\tfor(int i=1;i<=5;i++)ve2.pb(i);\n\t\n\t\tdo{\n\t\t\tfor(int i=1;i<=5;i++) {\n\t\t\t\tve.clear();\n\t\t\t\tve.pb(0);\n\t\t\t\tfor(int k=0;k<i;k++)ve.pb(ve2[k]);\n\t\t\t\tve.pb(0);\n\t\t\t\tint ar[6]={0};\n\t\t\t\tfor(int j=0;j<ve.size()-1;j++){\n\t\t\t\t\tar[ch(ve[j],ve[j+1])]++;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbool bo=true;\n\t\t\t\tfor(int j=0;j<=6;j++)if(ar[j]>cnt[j]) bo=false;\n\t\t\t\tif(bo){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}while(next_permutation(ve2.begin(),ve2.end()));\n\tcout<<\"no\"<<endl;\n\t\n\t\n\treturn 0;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i, a, b) for(auto i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\tmap <string, int> cnt;\n\trep (i, n) {\n\t\tint w;\n\t\tcin >> w;\n\t\tstring num = \"123\";\n\t\trep (j, w) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a) swap(num[1], num[2]);\n\t\t\telse swap(num[0], num[1]);\n\t\t}\n\t\tcnt[num]++;\n\t}\n\tif (cnt[\"123\"] >= 1 || cnt[\"132\"] >= 2 || cnt[\"213\"] >= 2 || cnt[\"231\"] >= 3\n\t || cnt[\"312\"] >= 3 || cnt[\"321\"] >= 2 || cnt[\"231\"] >= 1 && cnt[\"312\"] >= 1\n\t || (cnt[\"231\"] >= 1 || cnt[\"312\"] >= 2) && cnt[\"213\"] >= 1 && cnt[\"321\"] >= 1\n\t || (cnt[\"312\"] >= 1 || cnt[\"231\"] >= 2) && cnt[\"132\"] >= 1 && cnt[\"321\"] >= 1\n\t || cnt[\"231\"] >= 1 && cnt[\"132\"] >= 1 && cnt[\"213\"] >= 1\n\t || cnt[\"312\"] >= 1 && cnt[\"132\"] >= 1 && cnt[\"213\"] >= 1 ) {\n\t\tcout << \"yes\" << endl;\n\t} else {\n\t\tcout << \"no\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tvector<int>num(6);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> M;\n\t\tvector<int>box(3);\n\t\tfor (int k = 0; k < 3; k++) {\n\t\t\tbox[k] = k;\n\t\t}\n\t\tfor (int k = 0; k < M; k++) {\n\t\t\tcin >> K;\n\t\t\tif (K) {\n\t\t\t\tswap(box[1], box[2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(box[0], box[1]);\n\t\t\t}\n\t\t}\n\t\tif (box[0] == 0 && box[1] == 1) {\n\t\t\tnum[0]++;\n\t\t}\n\t\telse if (box[0] == 0 && box[1] == 2) {\n\t\t\tnum[1]++;\n\t\t}\n\t\telse if(box[0] == 1 && box[1] == 0) {\n\t\t\tnum[2]++;\n\t\t}\n\t\telse if (box[0] == 1 && box[1] == 2) {\n\t\t\tnum[3]++;\n\t\t}\n\t\telse if (box[0] == 2 && box[1] == 0) {\n\t\t\tnum[4]++;\n\t\t}\n\t\telse if (box[0] == 2 && box[1] == 1) {\n\t\t\tnum[5]++;\n\t\t}\n\t}\n\tif (num[0]) {\n\t\tcout << \"yes\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\tfor (int m = 0; m < 6; m++) {\n\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\tif (!i && !j && !k && !L && !m && !n) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvector<int>used(6);\n\t\t\t\t\t\t\tused[i]++;\n\t\t\t\t\t\t\tused[j]++;\n\t\t\t\t\t\t\tused[k]++;\n\t\t\t\t\t\t\tused[l]++;\n\t\t\t\t\t\t\tused[m]++;\n\t\t\t\t\t\t\tused[n]++;\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor (int loop = 1; loop < 6; loop++) {\n\t\t\t\t\t\t\t\tif (used[loop] > num[loop]) {\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvector<int>box(3);\n\t\t\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\t\t\tbox[k] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (box[0] == 0 && box[1] == 1) {\n\t\t\t\t\t\t\t\tcout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << m << \" \" << n << endl;\n\t\t\t\t\t\t\t\tcout << \"yes\\n\";\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"no\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[i];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[i]], v[q[i] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(211); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prm[i], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, long long>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v;\n    long long b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prms[j], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if ((b >> e.id) & 1LL) continue;\n      if (e.dst == 12) cycle = true;\n      q.emplace(e.dst, b | (1LL << e.id));\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nint cnt[6];\nint tikan[6][3] = {{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0}};\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\trep(i, n) {\n\t\tint w, a;\n\t\tint num[3] = {0, 1, 2};\n\t\tcin >> w;\n\t\trep(j, w) {\n\t\t\tcin >> a;\n\t\t\tswap(num[a], num[a + 1]);\n\t\t}\n\t\tint pos[3];\n\t\trep(j, 3) { pos[num[j]] = j; }\n\t\t\n\t\tint type;\n\t\tif (pos[0] == 0 && pos[1] == 1 && pos[2] == 2) type = 0;\n\t\tif (pos[0] == 0 && pos[1] == 2 && pos[2] == 1) type = 1;\n\t\tif (pos[0] == 1 && pos[1] == 0 && pos[2] == 2) type = 2;\n\t\tif (pos[0] == 1 && pos[1] == 2 && pos[2] == 0) type = 3;\n\t\tif (pos[0] == 2 && pos[1] == 0 && pos[2] == 1) type = 4;\n\t\tif (pos[0] == 2 && pos[1] == 1 && pos[2] == 0) type = 5;\n\t\tcnt[type]++;\n\t}\n\t\n\tif (cnt[0] >= 1) { cout << \"yes\" << endl; return 0; }\n\tif (cnt[1] >= 2 || cnt[5] >= 2 || cnt[2] >= 2) { cout << \"yes\" << endl; return 0; }\n\tif (cnt[3] >= 1 && cnt[4] >= 1) { cout << \"yes\" << endl; return 0; }\n\tif (cnt[3] >= 3 || cnt[4] >= 3) { cout << \"yes\" << endl; return 0; }\n\t\n\t//高々5個になったので全探索できる\n\tvector<int> types;\n\trep(i, 6) {\n\t\trep(j, cnt[i]) { types.push_back(i); }\n\t}\n\t\n\tvector<int> perm;\n\trep(i, types.size()) perm.push_back(i);\n\t\n\tdo {\n\t\tint pos[3] = {0, 1, 2};\n\t\trep(i, types.size()) {\n\t\t\tint type = types[perm[i]];\n\t\t\trep(j, 3) {\n\t\t\t\tpos[j] = tikan[type][pos[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pos[0] == 0 && pos[1] == 1 && pos[2] == 2) {\n\t\t\tcout << \"yes\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tcout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\ntemplate<typename T>\nint index(const vector<T> &zip, T i) { return lower_bound(zip.begin(), zip.end(), i) - zip.begin(); }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\n\tusing T = tuple<int, int, int>;\n\tvector<int> w(N);\n\tvector<vector<int>> a(N);\n\tvector<vector<int>> d(N);\n\n\trep(i, 0, N) {\n\t\tcin >> w[i];\n\t\trep(j, 0, w[i]) {\n\t\t\tint t; cin >> t;\n\t\t\ta[i].emplace_back(t);\n\t\t}\n\t\tvector<int> v(3); iota(all(v), 0);\n\t\trep(j, 0, w[i]) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tswap(v[0], v[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(v[1], v[2]);\n\t\t\t}\n\t\t}\n\t\td[i].assign(3, 0);\n\t\trep(j, 0, 3) {\n\t\t\td[i][v[j]] = j;\n\t\t}\n\t}\n\tdump(d);\n\n\tvector<vector<int>> A{ {0,1,2 } }, B{ {0,1,2} };\n\trep(i, 0, N / 2) {\n\t\tint n = A.size();\n\t\trep(j, 0, n) {\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[d[i][k]] = A[j][k];\n\t\t\t}\n\t\t\tA.emplace_back(tmp);\n\t\t}\n\t}\n\trep(i, N / 2, N) {\n\t\tint n = B.size();\n\t\trep(j, 0, n) {\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[d[i][k]] = B[j][k];\n\t\t\t}\n\t\t\tB.emplace_back(tmp);\n\t\t}\n\t}\n\tdump(A, B);\n\n\tA.erase(A.begin());\n\tB.erase(B.begin());\n\n\tA = compress(A);\n\tB = compress(B);\n\n\tdump(A, B);\n\tbool yes = false;\n\n\tif (find(all(A), vector<int>{0, 1, 2}) != A.end() ||\n\t\tfind(all(B), vector<int>{0, 1, 2}) != B.end()) {\n\t\tyes = true;\n\t}\n\n\tvector<vector<int>> C;\n\trep(i, 0, A.size()) {\n\t\trep(j, 0, B.size()) {\n\t\t\tvector<int> dist(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\tdist[B[j][k]] = k;\n\t\t\t}\n\t\t\tvector<int> tmp(3);\n\t\t\trep(k, 0, 3) {\n\t\t\t\ttmp[dist[k]] = A[i][k];\n\t\t\t}\n\t\t\tC.emplace_back(tmp);\n\t\t}\n\t}\n\n\tif (find(all(C), vector<int>{0, 1, 2}) != C.end()) {\n\t\tyes = true;\n\t}\n\n\tif (yes)cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//あみだくじは「置換」で表せる。これは6通りしかないので、実質N ≦ 6。よって全部試せる。\n//同じ「置換」を表すあみだくじを2つ以上使うケースは存在するか？　→ 存在するかもしれない…。    \n//嘘解法？：同じあみだくじを4つ以上使うケースがないものとして考える。　→　書いてみよう\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint n;\nint w, a;\nmap<vector<int>, int> mp;\nvector<vector<int>> ts;\n\nbool dfs(int used, vector<int> perm) {\n\tint i, j;\n\t\n\tif (used > 0 && perm[0] == 0 && perm[1] == 1 && perm[2] == 2) return true;\n\tfor (i = 0; i < ts.size(); i++) {\n\t\tif ((used >> i) & 1) continue;\n\t\t\n\t\tvector<int> nP;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tnP.push_back(ts[i][perm[j]]);\n\t\t}\n\t\tbool res = dfs(used + (1 << i), nP);\n\t\tif (res) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> w;\n\t\tint hoge[3] = {0, 1, 2};\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tcin >> a;\n\t\t\tswap(hoge[a], hoge[a + 1]);\n\t\t}\n\t\t\n\t\tvector<int> tikan;\n\t\ttikan.resize(3);\n\t\tfor (j = 0; j < 3; j++) tikan[hoge[j]] = j;\n\t\tif (mp.find(tikan) == mp.end()) mp[tikan] = 0;\n\t\tmp[tikan]++;\n\t}\n\t\n\tfor (map<vector<int>, int>::iterator it = mp.begin(); it != mp.end(); it++) {\n\t\tfor (i = 0; i < min((it->second), 3); i++) {\n\t\t\tts.push_back(it->first);\n\t\t}\n\t}\n\t\n\t//for (i = 0; i < ts.size(); i++) { for (j = 0; j < 3; j++) cout << ts[i][j] << \" \" ; cout << endl; }\n\tbool res = dfs(0, {0, 1, 2});\n\tif (res) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvector<int> getperm(){\n    int w;\n    cin>>w;\n    vector<int> ret = vector<int>{0,1,2};\n    \n    rep(i,w){\n        int p;\n        cin>>p;\n        if(p==0)swap(ret[0],ret[1]);\n        else    swap(ret[1],ret[2]);\n    }\n    \n    return ret;\n}\n\nvector<int> f(vector<int> origin, vector<int> comb){\n    vector<int> ret(3);\n    rep(i,3){\n        ret[i] = origin[comb[i]];\n    }\n    \n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> v;\n    map<vector<int>,int> mp;\n    rep(i,n){\n        vector<int> t = getperm();\n        if(mp[t]>2)continue;\n        if(mp[t]==0 or t==vector<int>{2,0,1} or t==vector<int>{1,2,0}){\n            v.pb(t);\n            mp[t]++;\n        }\n    }\n    \n    assert(v.size()<=8);\n\n    sort(all(v));\n    \n    do{\n        vector<int> t = v[0];\n        if(t==vector<int>{0,1,2}){\n            cout<<\"yes\"<<endl;\n            return 0;\n        }\n        for(int i=1;i<v.size();i++){\n            t = f(t,v[i]);\n            if(t==vector<int>{0,1,2}){\n                cout<<\"yes\"<<endl;\n                return 0;\n            }\n        }\n    }while(next_permutation(all(v)));\n    \n    \n    cout<<\"no\"<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, ami[6], a, w, p[3];\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = 0; i < N; ++i){\n        scanf(\"%lld\", &w);\n        *p = 0;\n        p[1] = 1;\n        p[2] = 2;\n        for(int j = 0; j < w; ++j){\n            scanf(\"%lld\", &a);\n            swap(p[1], p[a * 2]);\n        }\n        w = *p * 2 + (p[1] > p[2]);\n        //cout << w << endl;\n        ++ami[w];\n        switch(w){\n            case 0:\n                return 0 & puts(\"yes\");\n                break;\n            case 1:\n            case 2:\n            case 5:\n                if(ami[w] > 1)return 0 & puts(\"yes\");\n                break;\n            default:\n                if(ami[w] > 2)return 0 & puts(\"yes\");\n        }\n    }\n    if(ami[3] && ami[4])return 0 & puts(\"yes\");\n    if(ami[3] || ami[4]){\n        if(ami[1] + ami[2] + ami[3] > 1)return 0 & puts(\"yes\");\n    }\n    puts(\"no\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, ami[6], a, w, p[3];\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = 0; i < N; ++i){\n        scanf(\"%lld\", &w);\n        *p = 0;\n        p[1] = 1;\n        p[2] = 2;\n        for(int j = 0; j < w; ++j){\n            scanf(\"%lld\", &a);\n            swap(p[1], p[a * 2]);\n        }\n        w = *p * 2 + (p[1] > p[2]);\n        //cout << w << endl;\n        ++ami[w];\n        switch(w){\n            case 0:\n                return 0 & puts(\"yes\");\n                break;\n            case 1:\n            case 2:\n            case 5:\n                if(ami[w] > 1)return 0 & puts(\"yes\");\n                break;\n            default:\n                if(ami[w] > 2)return 0 & puts(\"yes\");\n        }\n    }\n    if(ami[3] && ami[4])return 0 & puts(\"yes\");\n    if(ami[3] || ami[4]){\n        if(ami[1] + ami[2] + ami[5] > 1)return 0 & puts(\"yes\");\n    }\n    puts(\"no\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint main () {\n    int n;\n    cin >> n;\n    if (n > 5) {\n        cout << \"yes\" << endl;\n        return 0;\n    }\n    int rots[5][3];\n    for(int i = 0; i < n; i++) {\n        int m;\n        cin >> m;\n        for(int j = 0; j < 3; j++) rots[i][j] = j;\n        for(int j = 0; j < m; j++) {\n            int b;\n            cin >> b;\n            if (b == 0) {\n                swap(rots[i][0], rots[i][1]);\n            } else {\n                swap(rots[i][1], rots[i][2]);\n            }\n        }\n    }\n    int par[n];\n    for(int i = 0; i < n; i++) par[i] = i;\n    int ans[3] = {0, 1, 2};\n    do {\n        for(int i = 0; i < 3; i++) ans[i] = i;\n        for(int i = 0; i < n; i++) {\n            int tmp[3];\n            for(int j = 0; j < 3; j++) tmp[j] = ans[j];\n            for(int j = 0; j < 3; j++) ans[j] = tmp[rots[par[i]][j]];\n            if (ans[0] == 0 && ans[1] == 1 && ans[2] == 2) {\n                cout << \"yes\" << endl;\n                return 0;\n            }\n        }\n    } while(next_permutation(par, par + n));\n    cout << \"no\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap< vector< int >, int > beet_aizu;\nset< vector< int > > used;\n\nbool uku(vector< int > beet, bool f) {\n  if(f && beet[0] == 0 && beet[1] == 1 && beet[2] == 2) {\n    return true;\n  }\n  for(auto &s : beet_aizu) {\n    if(s.second > 0) {\n      vector< int > tree_one(3);\n      tree_one[0] = beet[s.first[0]];\n      tree_one[1] = beet[s.first[1]];\n      tree_one[2] = beet[s.first[2]];\n      s.second--;\n      if(uku(tree_one, true)) return true;\n      s.second++;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int N;\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    int W;\n    cin >> W;\n    vector< int > vv{0, 1, 2};\n    for(int j = 0; j < W; j++) {\n      int x;\n      cin >> x;\n      if(x == 0) swap(vv[0], vv[1]);\n      else swap(vv[1], vv[2]);\n    }\n    beet_aizu[vv]++;\n  }\n  vector< int > oio{0, 1, 2};\n  if(uku(oio, false)) cout << \"yes\" << endl;\n  else cout << \"no\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\nusing namespace std;\n\nint main(){\n\tint n;\n\tint check[6];\n\trep(i,6)check[i]=0;\n\tcin>>n;\n\trep(i,n){\n\t\tint w,a;\n\t\tcin>>w;\n\t\tint one=1,two=2,three=3;\n\t\trep(j,w){\n\t\t\tcin>>a;\n\t\t\tif(a==0){\n\t\t\t\tint alt=one;\n\t\t\t\tone=two;\n\t\t\t\ttwo=alt;\n\t\t\t}else{\n\t\t\t\tint alt=two;\n\t\t\t\ttwo=three;\n\t\t\t\tthree=alt;\n\t\t\t}\n\t\t}\n\t\tif(one==1){\n\t\t\tif(two==2)check[0]++;\n\t\t\telse check[2]++;\n\t\t}else if(one==2){\n\t\t\tif(two==1)check[1]++;\n\t\t\telse check[4]++;\n\t\t}else{\n\t\t\tif(two==1)check[5]++;\n\t\t\telse check[3]++;\n\t\t}\n\t}\n\tbool ans=false;\n\tif(check[0])ans=true;\n\tif(check[1]>1 || check[2]>1 || check[3]>1)ans=true;\n\tif(check[4] && check[5])ans=true;\n\tif(check[4]>1 || check[5]>1)ans=true;\n\tif((check[4] || check[5]) && ((check[1]&&check[2])||(check[2]&&check[3])||(check[3]&&check[1])))ans=true;\n\tcout<<(ans?\"yes\":\"no\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prms[j], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n  exit(0);\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\n\n//123:0(1個未満)\n//132:1(二個未満)\n//213:2(二個未満)\n//321:3(二個未満)\n//231:4\n//312:5\nstd::array<int, 3> get_type(int id)\n{\n\tswitch (id)\n\t{\n\tcase 0:\n\t\treturn {1,2,3};\n\tcase 1:\n\t\treturn { 1,3,2 };\n\tcase 2:\n\t\treturn { 2,1,3 };\n\tcase 3:\n\t\treturn { 3,2,1 };\n\tcase 4:\n\t\treturn { 2,3,1 };\n\tcase 5:\n\t\treturn { 3,1,2 };\n\tdefault:\n\t\tbreak;\n\t}\n}\nint get_id(std::array<int, 3> res)\n{\n\tif (res[0] == 1) {\n\t\tif (res[1] == 2) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (res[0] == 2) {\n\t\tif (res[1] == 1) {\n\t\t\treturn 2;\n\t\t}\n\t\telse {\n\t\t\treturn 4;\n\t\t}\n\t}\n\telse  {\n\t\tif (res[1] == 1) {\n\t\t\treturn 5;\n\t\t}\n\t\telse {\n\t\t\treturn 3;\n\t\t}\n\t}\n}\n\nint amida_num[6];\n\nbool func(std::array<int, 3> v)\n{\n\tfor (int32_t i = 0; i < 6; i++)\n\t{\n\t\tif (amida_num[i] > 0)\n\t\t{\n\t\t\t--amida_num[i];\n\t\t\tauto sw = get_type(i);\n\n\t\t\tstd::array<int, 3> next;\n\t\t\tnext[0] = v[sw[0] - 1];\n\t\t\tnext[1] = v[sw[1] - 1];\n\t\t\tnext[2] = v[sw[2] - 1];\n\t\t\tif (func(next)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t++amida_num[i];\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tint32_t w;\n\t\tin >> w;\n\t\tstd::array<int, 3> res{ 1,2,3 };\n\t\twhile(w--)\n\t\t{\n\t\t\tint t;\n\t\t\tin >> t;\n\t\t\tif (t == 1) {\n\t\t\t\tstd::swap(res[1], res[2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::swap(res[1], res[0]);\n\t\t\t}\n\t\t}\n\t\tamida_num[get_id(res)]++;\n\t}\n\tif (amida_num[0] >= 1) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[1] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[2] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[3] >= 2) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[4] >= 3) { out << \"yes\" << endl; return 0; }\n\tif (amida_num[5] >= 3) { out << \"yes\" << endl; return 0; }\n\n\tif (func({ 1,2,3 })) {\n\t\tout << \"yes\" << endl;\n\t}\n\telse {\n\t\tout << \"no\" << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint main() {\n  int n;\n\n  cin >> n;\n\n  vector<vector<int>> v;\n  v.resize(n);\n  for(int i = 0; i < n; i++){\n    int w;\n    cin >> w;\n\n    v[i].push_back(1);\n    v[i].push_back(2);\n    v[i].push_back(3);\n    for(int j = 0; j < w; j++){\n      int a;\n      cin >> a;\n      if(a == 0){\n        if(v[i][0] == 1){\n          v[i][0] = 2;\n        }\n        else if(v[i][0] == 2){\n          v[i][0] = 1;\n        }\n        if(v[i][1] == 1){\n          v[i][1] = 2;\n        }\n        else if(v[i][1] == 2){\n          v[i][1] = 1;\n        }\n        if(v[i][2] == 1){\n          v[i][2] = 2;\n        }\n        else if(v[i][2] == 2){\n          v[i][2] = 1;\n        }\n      }\n      else{\n        if(v[i][0] == 2){\n          v[i][0] = 3;\n        }\n        else if(v[i][0] == 3){\n          v[i][0] = 2;\n        }\n        if(v[i][1] == 2){\n          v[i][1] = 3;\n        }\n        else if(v[i][1] == 3){\n          v[i][1] = 2;\n        }\n        if(v[i][2] == 2){\n          v[i][2] = 3;\n        }\n        else if(v[i][2] == 3){\n          v[i][2] = 2;\n        }\n      }\n    }\n  }\n\n  int cnt[3]={0,0,0};\n  rep(i,n){\n    if(v[i][0] == 1 && v[i][1] == 2 && v[i][2] == 3){\n      cout << \"yes\" << endl;\n      return 0;\n    }\n    if(v[i][0]==1&&v[i][1]!=2)cnt[0]++;\n    if(v[i][1]==2&&v[i][2]!=3)cnt[1]++;\n    if(v[i][2]==3&&v[i][0]!=1)cnt[2]++;\n  }\n  rep(j,3){\n    if(cnt[j]>=2){\n      cout<<\"yes\"<<endl;\n      return 0;\n    }\n  }\n\n  int cnt2[2]={0,0};\n  rep(i,n){\n    if(v[i][0] == 2 && v[i][1] == 3 && v[i][2] == 1){\n      cnt2[0]++;\n    }\n    if(v[i][0] == 3 && v[i][1] == 1 && v[i][2] == 2){\n      cnt2[1]++;\n    }\n  }\n  rep(j,2){\n    if(cnt[j]>=3){\n      cout<<\"yes\"<<endl;\n      return 0;\n    }\n  }\n\n  vector<int> idx;\n  rep(i,n)idx.push_back(i);\n\n  do{\n    vector<int> y = {1, 2, 3}, tmp = {0, 0, 0};\n    rep(i,n){\n      int j=idx[i];\n      tmp[v[j][0]-1] = y[0];\n      tmp[v[j][1]-1] = y[1];\n      tmp[v[j][2]-1] = y[2];\n      if(tmp[0] == 1 && tmp[1] == 2 && tmp[2] == 3){\n        cout << \"yes\" << endl;\n        return 0;\n      }\n      else{\n        y[0] = tmp[0];\n        y[1] = tmp[1];\n        y[2] = tmp[2];\n      }\n    }\n  }while(next_permutation(all(idx)));\n\n  cout<<\"no\"<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[i];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[i]], v[q[i] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prm[i], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//あみだくじは「置換」で表せる。これは6通りしかないので、実質N ≦ 6。よって全部試せる。\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint w, a;\nvector<vector<int>> ts;\n\nbool dfs(int used, vector<int> perm) {\n\tint i, j;\n\t\n\tif (used > 0 && perm[0] == 0 && perm[1] == 1 && perm[2] == 2) return true;\n\tfor (i = 0; i < ts.size(); i++) {\n\t\tif ((used >> i) & 1) continue;\n\t\t\n\t\tvector<int> nP;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tnP.push_back(ts[i][perm[j]]);\n\t\t}\n\t\tbool res = dfs(used + (1 << i), nP);\n\t\tif (res) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> w;\n\t\tint hoge[3] = {0, 1, 2};\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tcin >> a;\n\t\t\tswap(hoge[a], hoge[a + 1]);\n\t\t}\n\t\t\n\t\tvector<int> tikan;\n\t\ttikan.resize(3);\n\t\tfor (j = 0; j < 3; j++) tikan[hoge[j]] = j;\n\t\tts.push_back(tikan);\n\t}\n\tsort(ts.begin(), ts.end());\n\tts.erase(unique(ts.begin(), ts.end()), ts.end());\n\t\n\t//for (i = 0; i < ts.size(); i++) { for (j = 0; j < 3; j++) cout << ts[i][j] << \" \" ; cout << endl; }\n\tbool res = dfs(0, {0, 1, 2});\n\tif (res) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi f(vi a, vi b) {\n  vi c(3);\n  rep(i, 3) {\n    c[b[i]] = a[i];\n  }\n  return c;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n;\n  cin >> n;\n  map<vi, int> mp;\n  vvi perms = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0}\n  };\n  rep(i, n) {\n    int w;\n    cin >> w;\n    vi perm(3);\n    iota(all(perm), 0);\n    rep(j, w) {\n      int a;\n      cin >> a;\n      if (a == 0) {\n        swap(perm[0], perm[1]);\n      }\n      else {\n        swap(perm[1], perm[2]);\n      }\n    }\n    mp[perm]++;\n  }\n\n  if (mp[perms[0]] >= 1\n    || mp[perms[1]] >= 2\n    || mp[perms[2]] >= 2\n    || mp[perms[3]] >= 3\n    || mp[perms[4]] >= 3\n    || mp[perms[5]] >= 2)\n  {\n    cout << \"Yes\" << endl;\n    return 0;\n  }\n\n  vvi list;\n  rep(i, 6) {\n    rep(j, mp[perms[i]]) {\n      list.push_back(perms[i]);\n    }\n  }\n\n  rep(state, 1 << list.size()) {\n    // cerr << \"state = \" << state << endl;\n    if (state == 0) continue;\n    vvi chosen;\n    rep(i, list.size()) {\n      if ((state >> i) & 1) {\n        chosen.push_back(list[i]);\n      }\n    }\n    sort(all(chosen));\n    do {\n      // printVV(chosen);\n      vi perm(3);\n      iota(all(perm), 0);\n      rep(i, chosen.size()) {\n        perm = f(perm, chosen[i]);\n      }\n      if (perm == perms[0]) {\n        cout << \"Yes\" << endl;\n        return 0;\n      }\n    } while (next_permutation(all(chosen)));\n  }\n\n  cout << \"No\" << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing vi = vector<int>;\n\nvi in(){\n    int w;\n    cin >>w;\n\n    vi p(3);\n    iota(all(p),0);\n\n    rep(i,w){\n        int a;\n        cin >>a;\n        swap(p[a],p[a+1]);\n    }\n\n    return p;\n}\n\nbool solve(){\n    vi p(3);\n    iota(all(p),0);\n\n    vector<vi> v;\n    map<vi,int> m;\n    do{\n        m[p] = v.size();\n        v.pb(p);\n    }while(next_permutation(all(p)));\n\n    int n;\n    cin >>n;\n\n    int ct[6]={};\n    int loop[6]={1,2,2,3,3,2};\n    rep(i,n){\n        vi amida = in();\n        ++ct[m[amida]];\n    }\n\n    rep(i,6){\n        if(ct[i]>=loop[i]) return true;\n    }\n\n    vi x;\n    rep(i,6)rep(j,ct[i]) x.pb(i);\n    int X = x.size();\n\n    vi E(3);\n    iota(all(E),0);\n\n    do{\n        vi t(3);\n        iota(all(t),0);\n\n        rep(i,X){\n            vi nt(3);\n            vi f = v[x[i]];\n            rep(j,3) nt[j] = t[f[j]];\n            t = nt;\n            if(t==E) return true;\n        }\n    }while(next_permutation(all(x)));\n\n    return false;\n}\n\nint main(){\n    cout << (solve()?\"yes\":\"no\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct Amida {\n\tint p1, p2, p3;\n};\nbool operator== (const Amida &a1, const Amida &a2) {\n\tif (a1.p1 == a2.p1 && a1.p2 == a2.p2 && a1.p3 == a2.p3) return true;\n\treturn false;\n}\nbool operator<(const Amida &a1, const Amida &a2) {\n\tif (a1.p1 < a2.p1) return true; if (a1.p1 > a2.p1) return false;\n\tif (a1.p2 < a2.p2) return true; if (a1.p2 > a2.p2) return false;\n\tif (a1.p3 < a2.p3) return true; if (a1.p3 > a2.p3) return false;\n\treturn false;\n}\n\nint n, w[109]; vector<int>a[109]; Amida S[109];\nvector<Amida>I;\n\nAmida solve(vector<int>v) {\n\tAmida F = Amida{ 1,2,3 };\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 0) swap(F.p1, F.p2);\n\t\tif (v[i] == 1) swap(F.p2, F.p3);\n\t}\n\treturn F;\n}\nAmida gousei(Amida P1, Amida P2) {\n\tint r[3] = { 0,0,0 }, q[3] = { P1.p1,P1.p2,P1.p3 };\n\tr[0] = q[P2.p1 - 1];\n\tr[1] = q[P2.p2 - 1];\n\tr[2] = q[P2.p3 - 1];\n\treturn Amida{ r[0],r[1],r[2] };\n}\nAmida toAmida(int p) {\n\tif (p == 0) return Amida{ 1,2,3 };\n\tif (p == 1) return Amida{ 1,3,2 };\n\tif (p == 2) return Amida{ 2,1,3 };\n\tif (p == 3) return Amida{ 2,3,1 };\n\tif (p == 4) return Amida{ 3,1,2 };\n\tif (p == 5) return Amida{ 3,2,1 };\n}\nint toNumber(Amida P) {\n\tif (P == Amida{ 1, 2, 3 }) return 0;\n\tif (P == Amida{ 1, 3, 2 }) return 1;\n\tif (P == Amida{ 2, 1, 3 }) return 2;\n\tif (P == Amida{ 2, 3, 1 }) return 3;\n\tif (P == Amida{ 3, 1, 2 }) return 4;\n\tif (P == Amida{ 3, 2, 1 }) return 5;\n}\n\nbool solve(vector<Amida>Z) {\n\tAmida ZZ = Amida{ 1,2,3 };\n\n\tfor (int i = 0; i < Z.size(); i++) {\n\t\tZZ = gousei(ZZ, Z[i]);\n\t\tif (ZZ == Amida{ 1,2,3 }) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tfor (int j = 0; j < w[i]; j++) {\n\t\t\tint p; cin >> p;\n\t\t\ta[i].push_back(p);\n\t\t}\n\t\tS[i] = solve(a[i]);\n\t\tI.push_back(S[i]);\n\t}\n\tsort(I.begin(), I.end());\n\tI.erase(unique(I.begin(), I.end()), I.end());\n\n\tif (n != I.size()) {\n\t\tcout << \"yes\" << endl;\n\t}\n\telse {\n\t\tbool flag = false;\n\t\tdo {\n\t\t\tif (solve(I) == true) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (next_permutation(I.begin(), I.end()));\n\n\t\tif (flag == true) cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\nusing namespace std;\n\nint main(){\n\tint n;\n\tint check[6];\n\trep(i,6)check[i]=0;\n\tcin>>n;\n\trep(i,n){\n\t\tint w,a;\n\t\tcin>>w;\n\t\tint one=1,two=2,three=3;\n\t\trep(j,w){\n\t\t\tcin>>a;\n\t\t\tif(a==0){\n\t\t\t\tint alt=one;\n\t\t\t\tone=two;\n\t\t\t\ttwo=alt;\n\t\t\t}else{\n\t\t\t\tint alt=two;\n\t\t\t\ttwo=three;\n\t\t\t\tthree=alt;\n\t\t\t}\n\t\t}\n\t\tif(one==1){\n\t\t\tif(two==2)check[0]++;\n\t\t\telse check[2]++;\n\t\t}else if(one==2){\n\t\t\tif(two==1)check[1]++;\n\t\t\telse check[4]++;\n\t\t}else{\n\t\t\tif(two==1)check[5]++;\n\t\t\telse check[3]++;\n\t\t}\n\t}\n\tbool ans=false;\n\tif(check[0])ans=true;\n\tif(check[1]>1 || check[2]>1 || check[3]>1)ans=true;\n\tif(check[4] && check[5])ans=true;\n\tif(check[4]>2 || check[5]>2)ans=true;\n\tif((check[4] || check[5]) && ((check[1]&&check[2])||(check[2]&&check[3])||(check[3]&&check[1])))ans=true;\n\tcout<<(ans?\"yes\":\"no\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\ntypedef vector<int > V;\ntypedef vector<V> VV;\n\ntemplate <typename ITR>\nbool next_value(int base, ITR bg, ITR ed) {\n\tint c = 1;\n\tfor (; bg != ed && c == 1; ++bg) {\n\t\t(*bg) += c;\n\t\tif ((c = ((*bg) == base)))(*bg) = 0;\n\t}\n\treturn !c;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tmap<V, int> f;\n\tVV ei(6);\n\t{\n\t\tV latte = { 0,1,2 };\n\t\tint id = 0;\n\t\tdo {\n\t\t\tf[latte] = id;\n\t\t\tei[id] = latte;\n\t\t\tid++;\n\t\t} while (next_permutation(ALL(latte)));\n\t}\n\tV g(6);\n\tfor (int i : range(N)) {\n\t\tint w;\n\t\tcin >> w;\n\t\tV x = { 0,1,2 };\n\t\tfor (int j : range(w)) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a == 0) {\n\t\t\t\tswap(x[0], x[1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(x[1], x[2]);\n\t\t\t}\n\t\t}\n\t\tg[f[x]]++;\n\t}\n\tV o(6, 0);\n\tdo {\n\t\tV  malta = g;\n\t\tV beet = { 0,1,2 };\n\t\tfor (int i : range(6)) {\n\t\t\tif (malta[o[i]] == 0)break;\n\t\t\tmalta[o[i]]--;\n\t\t\tV nxt(3);\n\t\t\tfor (int j : range(3)) {\n\t\t\t\tnxt[ei[o[i]][j]] = beet[j];\n\t\t\t}\n\t\t\tswap(beet, nxt);\n\t\t\tif (beet == V{0, 1, 2}) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} while (next_value(6,ALL(o)));\n\tcout << \"no\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nstruct state{\n    int a,b,c;\n};\nbool operator<(const state& p,const state&q){\n    if(p.a==q.a){\n        if(p.b==q.b){\n            return p.c<q.c;\n        }\n        return p.b<q.b;\n    }\n    return p.a<q.a;\n}\nstate f(state now,const vi& vec){\n    REP(i,vec.size()){\n        if(vec[i]==0){\n            swap(now.a,now.b);\n        }else{\n            swap(now.b,now.c);\n        }\n    }\n    return now;\n}\nint main(){\n    int n;\n    cin>>n;\n    vvi vec(n);\n    REP(i,n){\n        int s;\n        cin>>s;\n        vec[i].resize(s);\n        REP(j,s){\n            cin>>vec[i][j];\n        }\n    }\n    queue<state> que;\n    que.push(state{0,1,2});\n    set<state> se;\n    while(que.size()){\n        state st=que.front();que.pop();\n        if(se.count(st)){\n            continue;\n        }\n        REP(i,n){\n            state nex=f(st,vec[i]);\n            if(!se.count(nex)){\n                se.insert(nex);\n                que.push(nex);\n            }\n        }\n    }\n    for(auto itr:se){\n    }\n    if(se.count(state{0,1,2})){\n        cout<<\"yes\"<<endl;\n    }else{\n        cout<<\"no\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prm[i], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nstruct state{\n    int a,b,c;\n};\nbool operator<(const state&p,const state&q){\n    if(p.a==q.a){\n        if(p.b==q.b){\n            return p.c<q.c;\n        }\n        return p.b<q.b;\n    }\n    return p.a<q.a;\n}\nbool operator==(const state&p,const state&q){\n    return p.a==q.a&&p.b==q.b&&p.c==q.c;\n}\nstate f(state now,const vi& vec){\n    REP(i,vec.size()){\n        if(vec[i]==0){\n            swap(now.a,now.b);\n        }else{\n            swap(now.b,now.c);\n        }\n    }\n    return now;\n}\nint main(){\n    int n;\n    cin>>n;\n    vvi vec(n);\n    REP(i,n){\n        int s;\n        cin>>s;\n        vec[i].resize(s);\n        REP(j,s){\n            cin>>vec[i][j];\n        }\n    }\n    bool ans=false;\n    set<state> se;\n    se.insert({0,1,2});\n    REP(i,n){\n        set<state> next;\n        for(auto itr:se){\n            state t=itr;\n            state u=f(t,vec[i]);\n            if(u==state{0,1,2}){\n                ans=true;\n            }\n            next.insert(t);\n            next.insert(u);\n        }\n        se=next;\n    }\n    if(ans){\n        cout<<\"yes\"<<endl;\n    }else{\n        cout<<\"no\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nvoid calc(VI &x, VI y){\n    REP(i,3) x[i] = y[x[i]];\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    VI good(3);\n    REP(i,3) good[i] = i;\n\n    VVI p(n, VI(3));\n    REP(i,n){\n        int w = in();\n        VI tmp(3);\n        REP(j,3) tmp[j] = j;\n\n        REP(j,w){\n            int x = in();\n            swap(tmp[x], tmp[x+1]);\n        }\n\n        if (tmp == good){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n\n        REP(j,3){\n            p[i][tmp[j]] = j;\n        }\n    }\n\n    REP(i,n) REP(j,i){\n        VI tmp(3);\n        REP(k,3) tmp[k] = k;\n\n        calc(tmp, p[i]);\n        calc(tmp, p[j]);\n\n        if (tmp == good){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n    }\n\n    // REP(i,n){\n    //     REP(j,3) cout << p[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n    REP(i,n) REP(j,n) REP(l,n){\n        if (i == j || j == l || l == i) continue;\n        VI tmp(3);\n        REP(k,3) tmp[k] = k;\n\n        calc(tmp, p[i]);\n        calc(tmp, p[j]);\n        calc(tmp, p[l]);\n\n\n        if (tmp == good){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"no\" << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvi f(vi a, vi b) {\n  vi c(3);\n  rep(i, 3) {\n    c[b[i]] = a[i];\n  }\n  return c;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n;\n  cin >> n;\n  map<vi, int> mp;\n  vvi perms = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0}\n  };\n  rep(i, n) {\n    int w;\n    cin >> w;\n    vi perm(3);\n    iota(all(perm), 0);\n    rep(j, w) {\n      int a;\n      cin >> a;\n      if (a == 0) {\n        swap(perm[0], perm[1]);\n      }\n      else {\n        swap(perm[1], perm[2]);\n      }\n      mp[perm]++;\n    }\n  }\n\n  if (mp[perms[0]] >= 1\n    || mp[perms[1]] >= 2\n    || mp[perms[2]] >= 2\n    || mp[perms[3]] >= 3\n    || mp[perms[4]] >= 3\n    || mp[perms[5]] >= 2)\n  {\n    cout << \"Yes\" << endl;\n    return 0;\n  }\n\n  vvi list;\n  rep(i, 6) {\n    rep(j, mp[perms[i]]) {\n      list.push_back(perms[i]);\n    }\n  }\n\n  rep(state, 1 << list.size()) {\n    // cerr << \"state = \" << state << endl;\n    if (state == 0) continue;\n    vvi chosen;\n    rep(i, list.size()) {\n      if ((state >> i) & 1) {\n        chosen.push_back(list[i]);\n      }\n    }\n    sort(all(chosen));\n    do {\n      // printVV(chosen);\n      vi perm(3);\n      iota(all(perm), 0);\n      rep(i, chosen.size()) {\n        perm = f(perm, chosen[i]);\n      }\n      if (perm == perms[0]) {\n        cout << \"Yes\" << endl;\n        return 0;\n      }\n    } while (next_permutation(all(chosen)));\n  }\n\n  cout << \"No\" << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\nusing namespace std;\n\nint main(){\n\tint n;\n\tint check[6];\n\trep(i,6)check[i]=0;\n\tcin>>n;\n\tset<pair<int,int> > st[n];\n\trep(i,n){\n\t\tint w,a;\n\t\tcin>>w;\n\t\tint one=1,two=2,three=3;\n\t\trep(j,w){\n\t\t\tcin>>a;\n\t\t\tif(a==0){\n\t\t\t\tint alt=one;\n\t\t\t\tone=two;\n\t\t\t\ttwo=alt;\n\t\t\t}else{\n\t\t\t\tint alt=two;\n\t\t\t\ttwo=three;\n\t\t\t\tthree=two;\n\t\t\t}\n\t\t}\n\t\tif(one==1){\n\t\t\tif(two==2)check[0]++;\n\t\t\telse check[2]++;\n\t\t}else if(one==2){\n\t\t\tif(two==1)check[1]++;\n\t\t\telse check[4]++;\n\t\t}else{\n\t\t\tif(two==1)check[5]++;\n\t\t\telse check[3]++;\n\t\t}\n\t}\n\tbool ans=false;\n\tif(check[0])ans=true;\n\tif(check[1]>1 || check[2]>1 || check[3]>1)ans=true;\n\tif(check[4] || check[5])ans=true;\n\tif((check[4] || check[5]) && ((check[1]&&check[2])||(check[2]&&check[3])||(check[3]&&check[1])))ans=true;\n\tcout<<(ans?\"yes\":\"no\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<map>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nint main(){\n  int n;\n  cin>>n;\n  map<vi,int> f;\n  vector<vi> pp;\n  rep(i,n){\n    int w;\n    cin>>w;\n    vi p(3);\n    rep(j,3)p[j]=j;\n    rep(j,w){\n      int a;\n      cin>>a;\n      swap(p[a],p[a+1]);\n    }\n    f[p]++;\n    pp.push_back(p);\n  }\n  if(n>=8){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n  sort(pp.begin(),pp.end());\n  do{\n    vi acc(3);\n    rep(i,3)acc[i]=i;\n    rep(i,pp.size()){\n      vi t(3);\n      rep(j,3){\n\tt[j]=acc[pp[i][j]];\n      }\n      bool eq=1;\n      rep(j,3)eq&=t[j]==j;\n      if(eq){\n\tcout<<\"yes\"<<endl;\n\treturn 0;\n      }\n      acc=t;\n    }\n  }while(next_permutation(pp.begin(),pp.end()));\n  cout<<\"no\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------\n#define FOR(i,j,n) for (int i=(j);i<(n);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REPN(i,n) for (int i=(n);i>=0;i--)\n#define I(n) scanf(\"%d\", &(n))\n#define LL(n) scanf(\"%lld\", &(n))\n#define pb(n) push_back((n))\n#define mp(i,j) make_pair((i),(j))\n#include <bits/stdc++.h>\nusing namespace std;\n\n//------------------------------typedef集\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vpi> vvpi;\ntypedef vector<vvi> vvvi;\ntypedef long long ll;\n\nint n,w,a,a1,a2,a3,amida[50],kind[6];\n\nint main(){\n    I(n);\n    REP(i,n){\n        a1 = 0;\n        a2 = 1;\n        a3 = 2;\n        I(w);\n        REP(j,w){\n            I(a);\n            if (a){\n                swap(a2,a3);\n            } else {\n                swap(a1,a2);\n            }\n        }\n        if (a1 == 0){\n            amida[i] = a2 == 1 ? 0 : 1;\n        } else if (a1 == 1){\n            amida[i] = a2 == 0 ? 2 : 3;\n        } else {\n            amida[i] = a2 == 0 ? 4 : 5;\n        }\n    }\n    REP(i,n) kind[ amida[i] ] ++;\n\n    if (kind[0] || kind[1] >= 2 || kind[2] >= 2 || kind[5] >= 2 ||\n        kind[3] >= 3 || kind[4] >= 3 || (kind[3] && kind[4]) ||\n        ( (kind[3] + kind[4]) && (kind[0] + kind[1] + kind[5]) >= 2 ) ) {\n            cout << \"yes\" << endl;\n        } else{\n            cout << \"no\" << endl;\n        }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nvector<vector<int> > v(55);\n\nbool check(vector<int> vec){\n\tstring str = \"012\";\n\t//cout << \"!!\" << endl;\n\tREP(i,vec.size()){\n\t\tint now = vec[i];\n\t\tREP(j,v[now].size()){\n\t\t\tif(v[now][j] == 0){\n\t\t\t\tswap(str[0],str[1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tswap(str[1],str[2]);\n\t\t\t}\n\t\t}\n\t\t//cout << str << endl;\n\t\tif(str == \"012\")return true;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\tint n;cin >> n;\n\t\n\tREP(i,n){\n\t\tint w;cin >> w;\n\t\tREP(j,w){\n\t\t\tint tmp;cin >> tmp;\n\t\t\tv[i].PB(tmp);\n\t\t}\n\t}\n\t\n\tif(n > 7){\n\t\tcout << \"yes\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tvector<int> par(n);\n\t\tREP(i,n)par[i] = i;\n\t\tdo{\n\t\t\tif(check(par)){\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}while(next_permutation(ALL(par)));\n\t}\n\t\n\tcout << \"no\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <vector>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n  int dst, id;\n  Edge(const int dst = 0, const int id = 0) : dst(dst), id(id) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstring itos(int i) {\n  ostringstream os;\n  os << setfill('0') << setw(3) << i;\n  return os.str();\n}\n\nint compose(int p, int q) { // 置換の合成\n  string s = itos(p), t = itos(q), r = \"   \";\n  for (int i = 0; i < 3; i++) r[i] = t[s[i] - '0'];\n  return stoi(r);\n}\n\nint prms[] = {12, 21, 102, 120, 201, 210};\n\nsigned main() {\n  int n;\n  cin >> n;\n  vector<int> prm(n);\n  for (int i = 0; i < n; i++) { // 各あみだくじを置換に変換\n    int w;\n    cin >> w;\n    vector<int> q(w);\n    for (int j = 0; j < w; j++) cin >> q[j];\n    string v = \"012\";\n    for (int j = w - 1; j >= 0; j--) swap(v[q[j]], v[q[j] + 1]);\n    prm[i] = stoi(v);\n  }\n\n  Graph g(300); // 頂点を置換, 辺を置換とするグラフ\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 6; j++) {\n      int u = prms[j], v = compose(prms[j], prm[i]);\n      g[u].emplace_back(v, i);\n    }\n  }\n\n  // ここから恒等置換から恒等置換への閉路を検出\n  vector<bool> used(n, false);\n  queue<pair<int, int>> q; // 頂点, 使用した置換(あみだくじ)をbitで持つ\n  q.emplace(12, 0);\n  bool cycle = false;\n  while (q.size()) {\n    int v, b;\n    tie(v, b) = q.front();\n    q.pop();\n    if (used[v]) continue;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (e.dst == 12) cycle = true;\n      if ((b >> e.id) & 1) continue;\n      q.emplace(e.dst, b | 1 << e.id);\n    }\n  }\n\n  cout << (cycle ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------\n#define FOR(i,j,n) for (int i=(j);i<(n);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REPN(i,n) for (int i=(n);i>=0;i--)\n#define I(n) scanf(\"%d\", &(n))\n#define LL(n) scanf(\"%lld\", &(n))\n#define pb(n) push_back((n))\n#define mp(i,j) make_pair((i),(j))\n#include <bits/stdc++.h>\nusing namespace std;\n\n//------------------------------typedef集\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vpi> vvpi;\ntypedef vector<vvi> vvvi;\ntypedef long long ll;\n\nint n,w,a,a1,a2,a3,amida[50],kind[6];\n\nint main(){\n    I(n);\n    REP(i,n){\n        a1 = 0;\n        a2 = 1;\n        a3 = 2;\n        I(w);\n        REP(j,w){\n            I(a);\n            if (a){\n                swap(a2,a3);\n            } else {\n                swap(a1,a2);\n            }\n        }\n        if (a1 == 0){\n            amida[i] = a2 == 1 ? 0 : 1;\n        } else if (a1 == 1){\n            amida[i] = a2 == 0 ? 2 : 3;\n        } else {\n            amida[i] = a2 == 0 ? 4 : 5;\n        }\n    }\n    REP(i,n) kind[ amida[i] ] ++;\n\n    if (kind[0] || kind[1] >= 2 || kind[2] >= 2 || kind[5] >= 2 ||\n        kind[3] >= 3 || kind[4] >= 3 || (kind[3] && kind[4]) ||\n        ( (kind[3] + kind[4]) && (kind[0] + kind[1] + kind[5]) ) ) {\n            cout << \"yes\" << endl;\n        } else{\n            cout << \"no\" << endl;\n        }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tstd::vector<int> v(6, 0);\n\tREP(i, n) {\n\t\tVAR(int, w);\n\t\tstd::vector<int> x({1,2,3});\n\t\tREP(_, w) {\n\t\t\tVAR(int, a);\n\t\t\tif (a == 0) std::swap(x[0], x[1]);\n\t\t\tif (a == 1) std::swap(x[1], x[2]);\n\t\t}\n\t\tif (x[0] == 1 && x[1] == 2 && x[2] == 3) ++v[0];\n\t\tif (x[0] == 1 && x[1] == 3 && x[2] == 2) ++v[1];\n\t\tif (x[0] == 2 && x[1] == 1 && x[2] == 3) ++v[2];\n\t\tif (x[0] == 2 && x[1] == 3 && x[2] == 1) ++v[3];\n\t\tif (x[0] == 3 && x[1] == 1 && x[2] == 2) ++v[4];\n\t\tif (x[0] == 3 && x[1] == 2 && x[2] == 1) ++v[5];\n\t}\n\tbool yes = false;\n\tif (v[0] >= 1) yes |= true;\n\tif (v[1] >= 2) yes |= true;\n\tif (v[2] >= 2) yes |= true;\n\tif (v[3] >= 3) yes |= true;\n\tif (v[4] >= 3) yes |= true;\n\tif (v[3] >= 1 && v[4] >= 1) yes |= true;\n\tif (v[5] >= 2) yes |= true;\n\tOUT(yes ? \"yes\" : \"no\")BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\nusing namespace std;\n\nint main(){\n\tint n;\n\tint check[6];\n\trep(i,6)check[i]=0;\n\tcin>>n;\n\tset<pair<int,int> > st[n];\n\trep(i,n){\n\t\tint w,a;\n\t\tcin>>w;\n\t\tint one=1,two=2,three=3;\n\t\trep(j,w){\n\t\t\tcin>>a;\n\t\t\tif(a==0){\n\t\t\t\tint alt=one;\n\t\t\t\tone=two;\n\t\t\t\ttwo=alt;\n\t\t\t}else{\n\t\t\t\tint alt=two;\n\t\t\t\ttwo=three;\n\t\t\t\tthree=two;\n\t\t\t}\n\t\t}\n\t\tif(one==1){\n\t\t\tif(two==2)check[0]++;\n\t\t\telse check[2]++;\n\t\t}else if(one==2){\n\t\t\tif(two==1)check[1]++;\n\t\t\telse check[4]++;\n\t\t}else{\n\t\t\tif(two==1)check[5]++;\n\t\t\telse check[3]++;\n\t\t}\n\t}\n\tbool ans=false;\n\tif(check[0])ans=true;\n\tif(check[1]>1 || check[2]>1 || check[3]>1)ans=true;\n\tif(check[4] && check[5])ans=true;\n\tif(check[4]>1 || check[5]>1)ans=true;\n\tif((check[4] || check[5]) && ((check[1]&&check[2])||(check[2]&&check[3])||(check[3]&&check[1])))ans=true;\n\tcout<<(ans?\"yes\":\"no\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n/*\nstruct Segmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first<vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first>vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmin(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp((1ll<<31)-1,-1);\n\t\t}\n\t\t\n\t\tpa v1=segmin(a,b,k*2,l,(l+r)/2),v2=segmin(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first<v2.first)return v1;\n\t\telse if(v1.first>v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n\n\n\nstruct Segmax{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=1;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first>vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse if(vec[2*i].first<vec[2*i+1].first)vec[i]=vec[2*i+1];\n\t\t\t\telse vec[i]=mp(vec[2*i].first,vec[2*i].second+vec[2*i+1].second);\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x ���ڂ� w���Z\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x���ڂ�w�ɕύX\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse if(vec[2*x].first<vec[2*x+1].first) vec[x]=vec[2*x+1];\n\t\t\telse vec[x]=mp(vec[2*x].first,vec[2*x].second+vec[2*x+1].second);\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmax(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp(-(1ll<<31),-1);\n\t\t}\n\t\t\n\t\tpa v1=segmax(a,b,k*2,l,(l+r)/2),v2=segmax(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first>v2.first)return v1;\n\t\telse if(v1.first<v2.first) return v2;\n\t\telse return mp(v1.first,v1.second+v2.second);\n\t}\n\t\n};\n*/\nbool bo(string s,string t){\n\tif(s.length()<t.length()) return false;\n\tif(s.length()==t.length())return s==t;\n\t\n\t\n\tint it1=0,it2=0;\n\t\n\tfor(int i=0;i<t.length();i++){\n\t\tif(it1==s.length()) return false;\n\t\t\n\t\twhile(s[it1]!=t[i]){\n\t\tit1++;\n\t\t\tif(it1==s.length()) return false;\n\t\t}\n\t//\tcout<<i<<\" \"<<it1<<endl;\n\t\tit1++;\n\t}\n\treturn true;\n\t\n}\n\nint h,w,q;\nstring yaru(string s,int r){\n\tif(r==1) return s;\n\t\n\tstring e=yaru(s,r-1);\n\tstring ans=e;\n\tfor(int i=0;i<s.length();i++){\n\t\tans+=s[i];\n\t\tans+=e;\n\t\tif(ans.length()>100020) return \"===#$%\";\n\t}\n\t//cout<<r<<\" \"<<ans<<endl;\n\treturn ans;\n}\n\nmap<string,int>ma;\nstring s[6]={\"123\",\"132\",\"213\",\"231\",\"312\",\"321\"};\n\nint ch(int i,int j){\nstring f=\"   \";\n\tfor(int k=0;k<3;k++)for(int l=0;l<3;l++)if(s[i][k]==s[j][l])f[k]='0'+l+1;\n\treturn ma[f];\n}\n\nsigned main(){\nma[\"123\"]=0;\n\tma[\"132\"]=1;\n\tma[\"213\"]=2;\n\tma[\"231\"]=3;\n\tma[\"312\"]=4;\n\tma[\"321\"]=5;\n\t\n\tint cnt[6]={0};\n\t\n\tint n;\n\tcin>>n;\n\t\n\tfor(int g=0;g<n;g++){\n\tint f;\n\t\tcin>>f;\n\t\tstring s=\"123\";\n\t\tfor(int i=0;i<f;i++){\n\t\t\tint sd;\n\t\tcin>>sd;\n\t\t\tif(sd==0)swap(s[0],s[1]);\n\t\t\telse swap(s[1],s[2]);\n\t\t}\n\tcnt[ma[s]]++;\n\t}\n\t\n\t\n\tif(cnt[0]>0){\n\tcout<<\"yes\"<<endl;\n\t\treturn 0;\n\t}\n\t\n\t\n\tvector<int> ve2,ve;\n\t\tfor(int i=1;i<=5;i++)ve2.pb(i);\n\t\n\t\tdo{\n\t\t\tfor(int i=1;i<=5;i++) {\n\t\t\t\tve.clear();\n\t\t\t\tve.pb(0);\n\t\t\t\tfor(int k=0;k<i;k++)ve.pb(ve2[k]);\n\t\t\t\tve.pb(0);\n\t\t\t\tint ar[6]={0};\n\t\t\t\tfor(int j=0;j<ve.size()-1;j++){\n\t\t\t\t\tar[ch(ve[j],ve[j+1])]++;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbool bo=true;\n\t\t\t\tfor(int j=0;j<6;j++)if(ar[j]>cnt[j]) bo=false;\n\t\t\t\tif(bo){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}while(next_permutation(ve2.begin(),ve2.end()));\n\tcout<<\"no\"<<endl;\n\t\n\t\n\treturn 0;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\nusing ll = long long;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int>W(N);\n\t//using T = tuple<int, int, int>;\n\tvector<vector<int>> V(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> W[i];\n\t\tvector<int> A(W[i]);\n\t\tfor (int j = 0; j < W[i]; j++)\n\t\t{\n\t\t\tcin >> A[j];\n\t\t}\n\t\tV[i].push_back(0);\n\t\tV[i].push_back(1);\n\t\tV[i].push_back(2);\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tif (A[k] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (V[i][j] == 1)V[i][j] = 0;\n\t\t\t\t\telse if (V[i][j] == 0)V[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (V[i][j] == 1)V[i][j] = 2;\n\t\t\t\t\telse if (V[i][j] == 2) V[i][j] = 1;\n\t\t\t\t}\n\t\t\t\t//cout << A[k] << \" \" << V[i][j]  << endl;\n\t\t\t}\n\t\t}\n\t\t//cout << V[i][0] << \" \" << V[i][1] << \" \" << V[i][2] << endl;\n\t}\n\n\tint n2 = N / 2;\n\tvector<int> tmp(3);\n\tvector<vector<int>> P(1 << n2);\n\tbool B[3][3][3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tB[i][j][k] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < 1 << n2; i++)\n\t{\n\t\tP[i].push_back(0);\n\t\tP[i].push_back(1);\n\t\tP[i].push_back(2);\n\t\tfor (int j = 0; j < n2; j++)\n\t\t{\n\t\t\tif (i >> j & 1) //jを使う\n\t\t\t{\n\t\t\t\ttmp[0] = P[i][0];\n\t\t\t\ttmp[1] = P[i][1];\n\t\t\t\ttmp[2] = P[i][2];\n\t\t\t\tP[i][0] = tmp[V[j][0]];\n\t\t\t\tP[i][1] = tmp[V[j][1]];\n\t\t\t\tP[i][2] = tmp[V[j][2]];\n\t\t\t}\n\t\t}\n\t\tif (P[i][0] == 0 && P[i][1] == 1 && P[i][2] == 2)\n\t\t{\n\t\t\tcout << \"yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tB[P[i][0]][P[i][1]][P[i][2]] = true;\n\t}\n\n\n\tfor (int i = 0; i < 1 << (N - n2); i++)\n\t{\n\t\tvector<int> Q(3);\n\t\tQ.push_back(0);\n\t\tQ.push_back(1);\n\t\tQ.push_back(2);\n\t\tfor (int j = 1; j < N - n2; j++)\n\t\t{\n\t\t\tif (i >> j & 1)\n\t\t\t{\n\t\t\t\tif (i >> j & 1) //j+n2を使う\n\t\t\t\t{\n\t\t\t\t\ttmp[0] = Q[0];\n\t\t\t\t\ttmp[1] = Q[1];\n\t\t\t\t\ttmp[2] = Q[2];\n\t\t\t\t\tQ[0] = tmp[V[j + n2][0]];\n\t\t\t\t\tQ[1] = tmp[V[j + n2][1]];\n\t\t\t\t\tQ[2] = tmp[V[j + n2][2]];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (Q[0] == 0 && Q[1] == 1 && Q[2] == 2)\n\t\t\t{\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//cout << Q[0] << \" \"  << Q[1] << \" \" << Q[2] << endl;\n\t\t\tint zero, one, two;\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tif (Q[k] == 0)\n\t\t\t\t{\n\t\t\t\t\tzero = k;\n\t\t\t\t}\n\t\t\t\tif (Q[k] == 1)\n\t\t\t\t{\n\t\t\t\t\tone = k;\n\t\t\t\t}\n\t\t\t\tif (Q[k] == 2)\n\t\t\t\t{\n\t\t\t\t\ttwo = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (B[zero][one][two])\n\t\t\t{\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"no\" << endl;\n\n\n\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\nint main() {\n    int n;\n    \n    cin >> n;\n    \n    vector<vector<int>> v;\n    v.resize(n);\n    for(int i = 0; i < n; i++){\n        int w;\n        cin >> w;\n        \n        v[i].push_back(1);\n        v[i].push_back(2);\n        v[i].push_back(3);\n        for(int j = 0; j < w; j++){\n            int a;\n            cin >> a;\n            if(a == 0){\n                if(v[i][0] == 1){\n                    v[i][0] = 2;\n                }\n                else if(v[i][0] == 2){\n                    v[i][0] = 1;\n                }\n                if(v[i][1] == 1){\n                    v[i][1] = 2;\n                }\n                else if(v[i][1] == 2){\n                    v[i][1] = 1;\n                }\n                if(v[i][2] == 1){\n                    v[i][2] = 2;\n                }\n                else if(v[i][2] == 2){\n                    v[i][2] = 1;\n                }\n            }\n            else{\n                if(v[i][0] == 2){\n                    v[i][0] = 3;\n                }\n                else if(v[i][0] == 3){\n                    v[i][0] = 2;\n                }\n                if(v[i][1] == 2){\n                    v[i][1] = 3;\n                }\n                else if(v[i][1] == 3){\n                    v[i][1] = 2;\n                }\n                if(v[i][2] == 2){\n                    v[i][2] = 3;\n                }\n                else if(v[i][2] == 3){\n                    v[i][2] = 2;\n                }\n            }\n        }\n    }\n    \n    /*\n    for(int i = 0; i < n; i++){\n        cout << v[i][0] << ' '  << v[i][1] << ' ' << v[i][2] << endl;\n    }\n    */\n    \n    map<pair<pair<int, int>, int>, int> m;\n    for(int i = 0; i < n; i++){\n        if(v[i][0] == 1 && v[i][1] == 2 && v[i][2] == 3){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n        m[{{v[i][0], v[i][1]}, v[i][2]}]++;\n    }\n    for(auto x : m){\n        if(x.second >= 2){\n            cout << \"yes\" << endl;\n            return 0;\n        }\n    }\n    \n    vector<pair<pair<int, int>, int>> w;\n    for(auto x : m){\n        w.push_back(x.first);\n    }\n    \n    do{\n        vector<int> y = {1, 2, 3}, tmp = {0, 0, 0};\n        for(auto x : w){\n            tmp[x.first.first - 1] = y[0];\n            tmp[x.first.second - 1] = y[1];\n            tmp[x.second -  1] = y[2];\n            \n            if(tmp[0] == 1 && tmp[1] == 2 && tmp[2] == 3){\n                cout << \"yes\" << endl;\n                return 0;\n            }\n            else{\n                y[0] = tmp[0];\n                y[1] = tmp[1];\n                y[2] = tmp[2];\n            }\n        }\n    }while(next_permutation(w.begin(), w.end()));\n    \n    cout << \"no\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<stack>\n \nusing namespace std;\n \n#define P(p) cout<<(p)<<endl\n#define rep(i,m,n) for(int i = (m); i < (int)(n); i++)\n#define rrep(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define vsort(v) sort(v.begin(), v.end());\n#define rvsort(v) sort(v.begin(), v.end(),greater<int>());\n#define YES cout<<\"YES\"<< endl\n#define NO cout<<\"NO\"<<endl\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl  \n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\n#define ret return\n#define C(i) cin>>i\n#define C2(i,j) cin>>i>>j\n#define C3(i,j,k) cin>>i>>j>>k\n#define C4(i,j,k,m) cin>>i>>j>>k>>m\n////////////////////////////////////////////////////////////\n\nstruct p{\n\tint f;\n\tint s;\n\tint t;\n};\n\nint dore( int p , vector<int> &a ){\n\trep(i,0,a.size()){\n\t\tif( a[i] == 0 ){\n\t\t\tif( p == 0 ) p = 1;\n\t\t\telse if( p == 1 ) p = 0;\n\t\t\telse continue;\n\t\t}\n\t\telse if( a[i] == 1 ){\n\t\t\tif( p == 1 ) p = 2;\n\t\t\telse if( p == 2 ) p = 1;\n\t\t\telse continue;\n\t\t}\n\t}\n\n\tret p;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> mp(6);\n\n\trep(i,0,n){\n\t\tint w;\n\t\tcin >> w;\n\t\tvector<int> a(w);\n\t\trep(j,0,w) cin >> a[j];\n\t\t\n\t\tint g0 = dore(0,a);\n\t\tint g1 = dore(1,a);\n\n\t\tif( g0 == 0 && g1 == 1 )\n\t\t\tmp[0]++;\n\t\telse if( g0 == 1 && g1 == 0)\n\t\t\tmp[1]++;\n\t\telse if( g0 == 0 && g1 == 2)\n\t\t\tmp[2]++;\n\t\telse if( g0 == 1 && g1 == 2)\n\t\t\tmp[3]++;\n\t\telse if( g0 == 2 && g1 == 0)\n\t\t\tmp[4]++;\n\t\telse if( g0 == 2 && g1 == 1)\n\t\t\tmp[5]++;\n\t}\n\n\tif( mp[0] > 0 || mp[1] > 1 || mp[2] > 1 || mp[3] > 2 || mp[4] > 2 || mp[5] > 1 ){\n\t\tyes;\n\t\tret 0;\n\t}\n\t\n\tvector<int> v;\n\trep(i,1,6){\n\t\trep(j,0,mp[i])\n\t\t\tv.push_back(i);\n\t}\n\t\n\tvsort(v);\n\tdo{\n\t\tvector<int> ami={0,1,2};\n\t\trep(i,0,v.size()){\n\t\t\tswitch(v[i]){\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(ami[0],ami[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tswap(ami[1],ami[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:{\n\t\t\t\t\tvector<int> tmp{ami[2],ami[0],ami[1]};\n\t\t\t\t\tami = tmp;\n\t\t\t\t\tbreak;}\n\t\t\t\tcase 4:{\n\t\t\t\t\tvector<int> tmp{ami[1],ami[2],ami[0]};\n\t\t\t\t\tami = tmp;\n\t\t\t\t\tbreak;}\n\t\t\t\tcase 5:\n\t\t\t\t\tswap(ami[0],ami[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ami[0] == 0 && ami[1] == 1 ){\n\t\t\tyes;\n\t\t\tret 0;\n\t\t}\n\t\t\n\t}while(next_permutation(v.begin(),v.end()));\n\t\n\tno;\n\tret 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct Amida {\n\tint p1, p2, p3;\n};\nbool operator== (const Amida &a1, const Amida &a2) {\n\tif (a1.p1 == a2.p1 && a1.p2 == a2.p2 && a1.p3 == a2.p3) return true;\n\treturn false;\n}\nbool operator<(const Amida &a1, const Amida &a2) {\n\tif (a1.p1 < a2.p1) return true; if (a1.p1 > a2.p1) return false;\n\tif (a1.p2 < a2.p2) return true; if (a1.p2 > a2.p2) return false;\n\tif (a1.p3 < a2.p3) return true; if (a1.p3 > a2.p3) return false;\n\treturn false;\n}\n\nint n, w[109], c[109]; vector<int>a[109]; Amida S[109];\nvector<Amida>I;\n\nAmida solve(vector<int>v) {\n\tAmida F = Amida{ 1,2,3 };\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 0) swap(F.p1, F.p2);\n\t\tif (v[i] == 1) swap(F.p2, F.p3);\n\t}\n\treturn F;\n}\nAmida gousei(Amida P1, Amida P2) {\n\tint r[3] = { 0,0,0 }, q[3] = { P1.p1,P1.p2,P1.p3 };\n\tr[0] = q[P2.p1 - 1];\n\tr[1] = q[P2.p2 - 1];\n\tr[2] = q[P2.p3 - 1];\n\treturn Amida{ r[0],r[1],r[2] };\n}\nAmida toAmida(int p) {\n\tif (p == 0) return Amida{ 1,2,3 };\n\tif (p == 1) return Amida{ 1,3,2 };\n\tif (p == 2) return Amida{ 2,1,3 };\n\tif (p == 3) return Amida{ 2,3,1 };\n\tif (p == 4) return Amida{ 3,1,2 };\n\tif (p == 5) return Amida{ 3,2,1 };\n}\nint toNumber(Amida P) {\n\tif (P == Amida{ 1, 2, 3 }) return 0;\n\tif (P == Amida{ 1, 3, 2 }) return 1;\n\tif (P == Amida{ 2, 1, 3 }) return 2;\n\tif (P == Amida{ 2, 3, 1 }) return 3;\n\tif (P == Amida{ 3, 1, 2 }) return 4;\n\tif (P == Amida{ 3, 2, 1 }) return 5;\n}\n\nbool solve(vector<Amida>Z) {\n\tAmida ZZ = Amida{ 1,2,3 };\n\n\tfor (int i = 0; i < Z.size(); i++) {\n\t\tZZ = gousei(ZZ, Z[i]);\n\t\tif (ZZ == Amida{ 1,2,3 }) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tfor (int j = 0; j < w[i]; j++) {\n\t\t\tint p; cin >> p;\n\t\t\ta[i].push_back(p);\n\t\t}\n\t\tS[i] = solve(a[i]);\n\t\tc[toNumber(S[i])]++;\n\t}\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int j = 0; j < min(2, c[i]); j++) I.push_back(toAmida(i));\n\t}\n\n\tif (n != I.size()) {\n\t\tcout << \"yes\" << endl;\n\t}\n\telse {\n\t\tbool flag = false;\n\t\tdo {\n\t\t\tif (solve(I) == true) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (next_permutation(I.begin(), I.end()));\n\n\t\tif (flag == true) cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n;\nmap<tuple<int, int, int>, int> cnt;\n\nbool pre_check() {\n  if (cnt[make_tuple(0, 1, 2)] >= 1) return true;\n  else if (cnt[make_tuple(0, 2, 1)] >= 2) return true;\n  else if (cnt[make_tuple(1, 0, 2)] >= 2) return true;\n  else if (cnt[make_tuple(1, 2, 0)] >= 3) return true;\n  else if (cnt[make_tuple(2, 0, 1)] >= 3) return true;\n  else if (cnt[make_tuple(2, 1, 0)] >= 2) return true;\n  else if (cnt[make_tuple(1, 2, 0)] >= 1 && cnt[make_tuple(2, 0, 1)] >= 1) return true;\n  return false;\n}\n\nvector<int> amida_goal(int amida_num, vector<int> &amida_yoko) {\n    vector<int> goal(amida_num);\n    rep(i, amida_num) goal[i] = i;\n    int ysize = amida_yoko.size();\n    rep(i, ysize) {\n        int l = amida_yoko[i];\n        int r = l + 1;\n        swap(goal[l], goal[r]);\n\n    }\n    return goal;\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i, n) {\n      int w;\n      cin >> w;\n      vector<int> a(w);\n      rep(j, w) cin >> a[j];\n      vector<int> goal = amida_goal(3, a);\n      cnt[make_tuple(goal[0], goal[1], goal[2])]++;\n    }\n    if (pre_check()) {\n      cout << \"yes\" << endl;\n      return 0;\n    }\n    if (cnt[make_tuple(1, 2, 0)] == 0 && cnt[make_tuple(2, 0, 1)] == 0) {\n      cout << \"no\" << endl;\n    }\n    else {\n      if (cnt[make_tuple(0, 2, 1)] >= 1 && cnt[make_tuple(1, 0, 2)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else if (cnt[make_tuple(0, 2, 1)] >= 1 && cnt[make_tuple(2, 1, 0)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else if (cnt[make_tuple(1, 0, 2)] >= 1 && cnt[make_tuple(2, 1, 0)] >= 1) {\n        cout << \"yes\" << endl;\n      }\n      else cout << \"no\" << endl;\n    }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <bitset>\n#include <limits.h>\n#define REP(i, n) for(LL i = 0;i < n;i++)\n#define REPR(i, n) for(LL i = n;i >= 0;i--)\n#define FOR(i, m, n) for(LL i = m;i < n;i++)\n#define FORR(i, m, n) for(LL i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define INF (LL)1e15\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> LP;\ntypedef pair<int, P> PP;\ntypedef pair<LL, LP> LPP;\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\n\n/*************** using variables ***************/\n/**********************************************/\n\nsigned main(){\n    map<vector<int>, int> mp;\n    int n;\n    cin >> n;\n    vector<int> amida = {0, 1, 2};\n    mp[{0, 1, 2}] = 0;\n    mp[{0, 2, 1}] = 0;\n    mp[{1, 0, 2}] = 0;\n    mp[{1, 2, 0}] = 0;\n    mp[{2, 1, 0}] = 0;\n    mp[{2, 0, 1}] = 0;\n    REP(i, n){\n        int w;\n        cin >> w;\n        vector<int> amida = {0, 1, 2};\n        REP(i, w){\n            int a;\n            cin >> a;\n            if(a == 0){\n                swap(amida[0], amida[1]);\n            }else if(a == 1){\n                swap(amida[1], amida[2]);\n            }\n        }\n        mp[amida]++;\n    }\n\n    bool flag = false;\n    if(mp[{0, 1, 2}] >= 1) flag = true;\n    else if(mp[{0, 2, 1}] >= 2 || mp[{1, 0, 2}] >= 2 || mp[{1, 2, 0}] >= 3 || mp[{2, 0, 1}] >= 3 || mp[{2, 1, 0}] >= 2) flag = true;\n\n    if(!flag){\n        if(mp[{1, 2, 0}] >= 1 && mp[{2, 0, 1}] >= 1) flag = true;\n        else if(mp[{1, 2, 0}] == 0 && mp[{2, 0, 1}] == 0){\n            cout << \"no\" << endl;\n            return 0;\n        }\n        else{\n            if(mp[{0, 2, 1}] + mp[{1, 0, 2}] + mp[{2, 1, 0}] >= 2){\n                flag = true;\n            }\n        }\n\n    } \n    if(flag) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    // デバッグ用\n    /*\n    cout << \"{0, 1, 2}: \" << mp[{0, 1, 2}] << endl;\n    cout << \"{0, 2, 1}: \" << mp[{0, 2, 1}] << endl;\n    cout << \"{1, 0, 2}: \" << mp[{1, 0, 2}] << endl;\n    cout << \"{1, 2, 0}: \" << mp[{1, 2, 0}] << endl;\n    cout << \"{2, 1, 0}: \" << mp[{2, 1, 0}] << endl;\n    cout << \"{2, 0, 1}: \" << mp[{2, 0, 1}] << endl;\n    */\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <bitset>\nusing namespace std;\n\nint point(tuple<int, int, int> t) {\n    if        (t == make_tuple(0,1,2)) {\n        return 0;\n    } else if (t == make_tuple(0,2,1)) {\n        return 1;\n    } else if (t == make_tuple(1,0,2)) {\n        return 2;\n    } else if (t == make_tuple(1,2,0)) {\n        return 3;\n    } else if (t == make_tuple(2,0,1)) {\n        return 4;\n    } else if (t == make_tuple(2,1,0)) {\n        return 5;\n    }\n}\n\nbool dfs(const vector<vector<vector<int>>> &graph, bitset<50> used, int pos) {\n    // 0に戻れるか\n    for (int amida_id: graph[pos][0]) {\n        if (used[amida_id] != 1) return true;\n    }\n    \n    // 移動\n    bool f = false;\n    for (int i=0; i<6; i++) {\n        for (int amida_id: graph[pos][i]) {\n            if (used[amida_id] != 1) {\n                bitset<50> new_used = used;\n                new_used[amida_id] = 1;\n                f |= dfs(graph, new_used, i);\n            }\n        }\n    }\n    return f; \n}\n\nvoid solve(const vector<tuple<int, int, int>> &amida) {\n    // 置換に変換\n    /*\n    for (tuple<int, int, int> t: amida) \n        cout << \"{\" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << \"}\" << endl;\n    */\n\n    vector<vector<vector<int>>> graph(6);\n    for (auto &x: graph) x.resize(6);\n\n    int c = 0;\n    for (tuple<int,int,int> t: amida) {\n        for (int i=0; i<3; i++)\n            for (int j=0; j<3; j++)\n                for (int k=0; k<3; k++)\n                    if (i!=j && i!=k && j!=k) {\n                        vector<int> l = {i,j,k};\n                        graph[point(make_tuple(i,j,k))]\n                             [point(make_tuple(l[get<0>(t)-1], l[get<1>(t)-1], l[get<2>(t)-1]))]\n                            .push_back(c);\n                    }\n        c++;\n    }\n\n    /*\n    cout << \"0\" << endl;\n    for (int i=0; i<6; i++) {\n        cout << i << \": \";\n        for (auto x: graph[0][i]) {\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    if (dfs(graph, bitset<50>(0), 0)) {\n        cout << \"yes\" << endl;\n    } else {\n        cout << \"no\" << endl;\n    }\n}\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> in(n);\n\n    for (auto &x: in) {\n        int w; cin >> w; x.resize(w);\n        for (auto &y: x) cin >> y;\n    }\n\n    vector<tuple<int, int, int>> amida(n);\n    for (int i=0; i<n; i++) {\n        tuple<int, int, int> state = {1, 2, 3};\n        reverse(in[i].begin(), in[i].end());\n        for (auto x: in[i]) {\n            if (x == 0) {\n                state = {get<1>(state), get<0>(state), get<2>(state)};\n            } else {\n                state = {get<0>(state), get<2>(state), get<1>(state)};\n            }\n        }\n        amida[i] = state;\n    }\n\n    solve(amida);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\nusing ll = long long;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int>W(N);\n\t//using T = tuple<int, int, int>;\n\tvector<vector<int>> V(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> W[i];\n\t\tvector<int> A(W[i]);\n\t\tfor (int j = 0; j < W[i]; j++)\n\t\t{\n\t\t\tcin >> A[j];\n\t\t}\n\t\tV[i].push_back(0);\n\t\tV[i].push_back(1);\n\t\tV[i].push_back(2);\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tif (A[k] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (V[i][j] == 1)V[i][j] = 0;\n\t\t\t\t\telse if (V[i][j] == 0)V[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (V[i][j] == 1)V[i][j] = 2;\n\t\t\t\t\telse if (V[i][j] == 2) V[i][j] = 1;\n\t\t\t\t}\n\t\t\t\t//cout << A[k] << \" \" << V[i][j]  << endl;\n\t\t\t}\n\t\t}\n\t\t//cout << V[i][0] << \" \" << V[i][1] << \" \" << V[i][2] << endl;\n\t}\n\n\tint n2 = N / 2;\n\tvector<int> tmp(3);\n\tvector<vector<int>> P(1 << n2);\n\tbool B[3][3][3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tB[i][j][k] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < 1 << n2; i++)\n\t{\n\t\tP[i].push_back(0);\n\t\tP[i].push_back(1);\n\t\tP[i].push_back(2);\n\t\tfor (int j = 0; j < n2; j++)\n\t\t{\n\t\t\tif (i >> j & 1) //jを使う\n\t\t\t{\n\t\t\t\ttmp[0] = P[i][0];\n\t\t\t\ttmp[1] = P[i][1];\n\t\t\t\ttmp[2] = P[i][2];\n\t\t\t\tP[i][0] = tmp[V[j][0]];\n\t\t\t\tP[i][1] = tmp[V[j][1]];\n\t\t\t\tP[i][2] = tmp[V[j][2]];\n\t\t\t}\n\t\t}\n\t\tif (P[i][0] == 0 && P[i][1] == 1 && P[i][2] == 2)\n\t\t{\n\t\t\tcout << \"yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tB[P[i][0]][P[i][1]][P[i][2]] = true;\n\t}\n\n\n\tfor (int i = 1; i < 1 << (N - n2); i++)\n\t{\n\t\tvector<int> Q;\n\t\tQ.push_back(0);\n\t\tQ.push_back(1);\n\t\tQ.push_back(2);\n\n\t\tfor (int j = 0; j < N - n2; j++)\n\t\t{\n\t\t\tif (i >> j & 1)\n\t\t\t{\n\t\t\t\ttmp[0] = Q[0];\n\t\t\t\ttmp[1] = Q[1];\n\t\t\t\ttmp[2] = Q[2];\n\t\t\t\t//cout << Q[0] << \" \" << Q[1] << \" \" << Q[2] << endl;\n\t\t\t\tQ[0] = tmp[V[j + n2][0]];\n\t\t\t\tQ[1] = tmp[V[j + n2][1]];\n\t\t\t\tQ[2] = tmp[V[j + n2][2]];\n\t\t\t\t//cout << Q[0] << \" \" << Q[1] << \" \" << Q[2] << endl;\n\t\t\t}\n\t\t}\n\n\t\tif (Q[0] == 0 && Q[1] == 1 && Q[2] == 2)\n\t\t{\n\t\t\tcout << \"yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t//cout << Q[0] << \" \" << Q[1] << \" \" << Q[2] << endl;\n\t\tint zero, one, two;\n\t\tfor (int k = 0; k < 3; k++)\n\t\t{\n\t\t\tif (Q[k] == 0)\n\t\t\t{\n\t\t\t\tzero = k;\n\t\t\t}\n\t\t\tif (Q[k] == 1)\n\t\t\t{\n\t\t\t\tone = k;\n\t\t\t}\n\t\t\tif (Q[k] == 2)\n\t\t\t{\n\t\t\t\ttwo = k;\n\t\t\t}\n\t\t}\n\t\tif (B[zero][one][two])\n\t\t{\n\t\t\tcout << \"yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcout << \"no\" << endl;\n\n\n\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\nint n;\n\nint numbers[3] = {0b001, 0b010, 0b100};\n\nvector<vector<int>> s;\nvector<vector<int>> t;\n\nset<int> st;\n\nint main() {\n  cin >> n;\n  vector<int> base = {0, 1, 2};\n  int sz = n / 2;\n  s.assign(sz, base);\n  t.assign(n - (sz) + 1, base);\n  rep(i, 0, sz - 1) {\n    int w;\n    cin >> w;\n    rep(j, 0, w - 1) {\n      int a;\n      cin >> a;\n      if (a == 0) {\n        swap(s[i][0], s[i][1]);\n      } else {\n        swap(s[i][1], s[i][2]);\n      }\n    }\n  }\n  rep(i, 0, n - (sz)-1) {\n    int w;\n    cin >> w;\n    rep(j, 0, w - 1) {\n      int a;\n      cin >> a;\n      if (a == 0) {\n        swap(t[i][0], t[i][1]);\n      } else {\n        swap(t[i][1], t[i][2]);\n      }\n    }\n  }\n  {\n    sz = s.size();\n    vector<int> dp((1 << sz), 0);\n    for (int i = 0; i < 3; i++) {\n      dp[0] |= (numbers[i] << (i * 3));\n    }\n    for (int i = 1; i < (1 << sz); i++) {\n      int j;\n      for (j = 0; j < sz; j++) {\n        if (i & (1 << j)) break;\n      }\n      int next = 0;\n      int before = i & ~(1 << j);\n      for (int from = 0; from < 3; from++) {\n        int to = s[j][from];\n        for (int k = 0; k < 3; k++) {\n          int bit = 0;\n          if (dp[before] & (1 << (from * 3 + k))) {\n            bit = 1;\n          }\n          next |= (bit << (to * 3 + k));\n        }\n      }\n      dp[i] = next;\n      st.insert(next);\n    }\n  }\n  {\n    sz = t.size();\n    vector<int> dp((1 << sz), 0);\n    for (int i = 0; i < 3; i++) {\n      dp[0] |= (numbers[i] << (i * 3));\n    }\n    for (int i = 1; i < (1 << sz); i++) {\n      int j;\n      for (j = 0; j < sz; j++) {\n        if (i & (1 << j)) break;\n      }\n      int next = 0;\n      int before = i & ~(1 << j);\n      for (int from = 0; from < 3; from++) {\n        int to = t[j][from];\n        for (int k = 0; k < 3; k++) {\n          int bit = 0;\n          if (dp[before] & (1 << (from * 3 + k))) {\n            bit = 1;\n          }\n          next |= (bit << (to * 3 + k));\n        }\n      }\n      dp[i] = next;\n      if ((i != (1 << (sz - 1)) && dp[0] == next) || st.count(next)) {\n        cout << \"yes\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"no\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1)))){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nmap<VI, int> mp;\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n) {\n    int w;\n    cin >> w;\n    VI vec = {0, 1, 2};\n    REP(j, w) {\n      int a; cin >> a;\n      if(a == 0) {\n        swap(vec[0], vec[1]);\n      } else{\n        swap(vec[1], vec[2]);\n      }\n    }\n    mp[vec]++;\n  }\n\n  if(n >= 6) {\n    cout << \"yes\" << endl;\n    return 0;\n  }\n\n  VVI vv;\n  for(auto i: mp) {\n    REP(j, i.second) {\n      vv.PB(i.first);\n    }\n  }\n\n  sort(ALL(vv));\n  FOR(i, 1, 1<<vv.size()) {\n    VVI v;\n    REP(j, vv.size()) {\n      if(i&1<<j) v.PB(vv[j]);\n    }\n    // sort(ALL(v));\n    // cout << v << endl;\n    do {\n      VI v2 = {0, 1, 2};\n      for(auto &i: v) {\n        v2[0] = i[v2[0]];\n        v2[1] = i[v2[1]];\n        v2[2] = i[v2[2]];\n      }\n      if(v2 == VI{0, 1, 2}) {\n        cout << \"yes\" << endl;\n        return 0;\n      }\n    } while(next_permutation(ALL(v)));\n  }\n\n  cout << \"no\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\n\nstring change(string boo){\n  string str = \"123\";\n  rep(i,0,boo.sz){\n    if(boo[i] == '1')swap(str[1],str[2]);\n    else swap(str[1],str[0]);\n  }\n  return str;\n}\n\nint main(){\n  t = \"no\";\n  vector<string> vec{\"123\",\"132\",\"321\",\"213\",\"231\",\"312\"};\n  int num[6] = {0,1,1,1,2,2};\n  cin >> n;\n  map<string,int> test;\n  rep(i,0,n){\n    string boolean;\n    cin >> m;\n    rep(j,0,m){\n      char c;\n      cin >> c;\n      boolean += c;\n    }\n    test[change(boolean)]++;\n  }\n  rep(i,0,vec.sz)if(test[vec[i]] > num[i])t = \"yes\";\n  if(test[vec[4]] > 0 && test[vec[5]] > 0)t = \"yes\";\n  if(test[vec[1]] > 0 && test[vec[2]] > 0 && test[vec[4]] > 0)t = \"yes\";\n  if(test[vec[1]] > 0 && test[vec[3]] > 0 && test[vec[4]] > 0)t = \"yes\";\n  if(test[vec[2]] > 0 && test[vec[3]] > 0 && test[vec[5]] > 0)t = \"yes\";\n  print(t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tvector<int>num(6);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> M;\n\t\tvector<int>box(3);\n\t\tfor (int k = 0; k < 3; k++) {\n\t\t\tbox[k] = k;\n\t\t}\n\t\tfor (int k = 0; k < M; k++) {\n\t\t\tcin >> K;\n\t\t\tif (K) {\n\t\t\t\tswap(box[1], box[2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(box[0], box[1]);\n\t\t\t}\n\t\t}\n\t\tif (box[0] == 0 && box[1] == 1) {\n\t\t\tnum[0]++;\n\t\t}\n\t\telse if (box[0] == 0 && box[1] == 2) {\n\t\t\tnum[1]++;\n\t\t}\n\t\telse if(box[0] == 1 && box[1] == 0) {\n\t\t\tnum[2]++;\n\t\t}\n\t\telse if (box[0] == 1 && box[1] == 2) {\n\t\t\tnum[3]++;\n\t\t}\n\t\telse if (box[0] == 2 && box[1] == 0) {\n\t\t\tnum[4]++;\n\t\t}\n\t\telse if (box[0] == 2 && box[1] == 1) {\n\t\t\tnum[5]++;\n\t\t}\n\t}\n\tif (num[0]) {\n\t\tcout << \"yes\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\tfor (int m = 0; m < 6; m++) {\n\t\t\t\t\t\tfor (int n = 0; n < 6; n++) {\n\t\t\t\t\t\t\tif (!i && !j && !k && !L && !m && !n) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvector<int>used(6);\n\t\t\t\t\t\t\tused[i]++;\n\t\t\t\t\t\t\tused[j]++;\n\t\t\t\t\t\t\tused[k]++;\n\t\t\t\t\t\t\tused[l]++;\n\t\t\t\t\t\t\tused[m]++;\n\t\t\t\t\t\t\tused[n]++;\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor (int loop = 1; loop < 6; loop++) {\n\t\t\t\t\t\t\t\tif (used[loop] > num[loop]) {\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvector<int>box(3);\n\t\t\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\t\t\tbox[k] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (k == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (l == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 1) {\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 2) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 3) {\n\t\t\t\t\t\t\t\tswap(box[1], box[0]);\n\t\t\t\t\t\t\t\tswap(box[1], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 4) {\n\t\t\t\t\t\t\t\tswap(box[0], box[1]);\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (n == 5) {\n\t\t\t\t\t\t\t\tswap(box[0], box[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (box[0] == 0 && box[1] == 1) {\n\t\t\t\t\t\t\t\tcout << \"yes\\n\";\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"no\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nvvi vec[6];\n\nbool dfs(vi nw,int* cnt,int pos,bool flag)\n{\n    if(pos == 6){\n        return flag && (nw == vi{0,1,2});\n    }\n    rep(i,cnt[pos]){\n        if(pos == 1){\n            swap(nw[1],nw[2]);\n        }else if(pos == 2){\n            swap(nw[0],nw[1]);\n        }else if(pos == 3){\n            swap(nw[0],nw[2]);\n        }else if(pos == 4){\n            swap(nw[0],nw[1]);\n            swap(nw[1],nw[2]);\n        }else{\n            swap(nw[0],nw[2]);\n            swap(nw[1],nw[2]);\n        }\n        if(dfs(nw,cnt,pos+1,(flag|(i >= 1))){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    mp[vi{0,1,2}] = 0,mp[vi{0,2,1}] = 1,mp[vi{1,0,2}] = 2;\n    mp[vi{2,1,0}] = 3,mp[vi{1,2,0}] = 4,mp[vi{2,0,1}] = 5;\n    int cnt[6] = {};\n    rep(i,n){\n        vi st = {0,1,2};\n        int a;\n        cin >> a;\n        rep(j,a){\n            int c;\n            cin >> c;\n            if(c){\n                swap(st[1],st[2]);\n            }else{\n                swap(st[0],st[1]);\n            }\n        }\n        cnt[mp[st]]++;\n    }\n    if(cnt[0] >= 1){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[1] >= 2 || cnt[2] >= 2 || cnt[3] >= 2){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(cnt[4] >= 3 || cnt[5] >= 3){\n        cout << \"yes\\n\";\n        return 0;\n    }\n    if(dfs(vi{0,1,2},cnt,0,false)){\n        cout << \"yes\\n\";\n    }else{\n        cout << \"no\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n\n  vector<int> ty(6,0);\n  for(int i=0;i<n;i++){\n    int w;\n    cin>>w;\n    int a=1;\n    int b=2;\n    int c=3;\n\n    for(int j=0;j<w;j++){\n      int t;\n      cin>>t;\n      if(t==0){\n        int tmp=a;\n        a=b;\n        b=tmp;\n      }else{\n        int tmp=b;\n        b=c;\n        c=tmp;\n      }\n    }\n    if(a==1&&b==2)ty[0]++;\n    if(a==2&&b==1)ty[1]++;\n    if(a==1&&b==3)ty[2]++;\n    if(a==3&&b==2)ty[3]++;\n    if(a==2&&b==3)ty[4]++;\n    if(a==3&&b==1)ty[5]++;\n  }\n\n  //for(int i=0;i<6;i++)cout<<ty[i]<<endl;\n\n\n  if(ty[0]!=0){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n\n  if(ty[1]>1||ty[2]>1||ty[3]>1){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n\n  if(ty[4]>2||ty[5]>2){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n\n  if(ty[4]==1&&ty[5]==1){\n    cout<<\"yes\"<<endl;\n    return 0;\n  }\n\n  vector<int> np;\n  for(int i=1;i<6;i++){\n    for(int j=0;j<ty[i];j++)np.push_back(i);\n  }\n  //for(int i=0;i<np.size();i++)cout<<np[i];\n\n  do{\n    int a=1;\n    int b=2;\n    int c=3;\n    int tmp;\n    for(int i=0;i<np.size();i++){\n      if(np[i]==1){\n        tmp=a;\n        a=b;\n        b=tmp;\n      }\n\n      if(np[i]==2){\n        tmp=b;\n        b=c;\n        c=tmp;\n      }\n\n      if(np[i]==3){\n        tmp=a;\n        a=c;\n        c=tmp;\n      }\n\n      if(np[i]==4){\n        tmp=a;\n        a=b;\n        b=c;\n        c=tmp;\n      }\n\n      if(np[i]==5){\n        tmp=a;\n        a=c;\n        c=b;\n        b=tmp;\n      }\n      if(a==1&&b==2){\n        //for(int i=0;i<np.size();i++)cout<<np[i];\n        cout<<\"yes\"<<endl;\n        return 0;\n      }\n    }\n  }while(next_permutation(np.begin(),np.end()));\n\n\n  cout<<\"no\"<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// {U}{INT,LONG,LLONG}_{MAX,MIN}\n#define INF         INT_MAX/3\n#define LLINF       LLONG_MAX/3\n#define MOD         (1000000007LL)\n#define MODA(a, b)  a=((a)+(b))%MOD\n#define MODP(a, b)  a=((a)*(b))%MOD\n#define inc(i, l, r)   for(int i=(l);i<(r);i++)\n#define dec(i, l, r)   for(int i=(r)-1;i>=(l);i--)\n#define pb          push_back\n#define se          second\n#define fi          first\n#define mset(a, b)  memset(a, b, sizeof(a))\n\nusing LL  = long long;\nusing G   = vector<vector<int>>;\n\nint di[] = {0, -1, 0, 1};\nint dj[] = {1, 0, -1, 0};\n// }}}\n\nint main() {\n    cin.tie(0);ios::sync_with_stdio(false);\n    int n;cin >> n;\n    vector<int> f(n);\n    map<string, int> mp;\n    mp[\"123\"] = 0; // id\n    mp[\"132\"] = 1; // swap\n    mp[\"213\"] = 2; // swap\n    mp[\"231\"] = 3; // <<\n    mp[\"312\"] = 4; // >>\n    mp[\"321\"] = 5; // swap\n\n    vector<int> cnt(6, 0);\n\n    inc(i, 0, n){\n        int w;cin >> w;\n        string s = \"123\";\n        inc(j, 0, w){\n            int a;cin >> a;\n            if(a == 0) swap(s[0], s[1]);\n            if(a == 1) swap(s[1], s[2]);\n        }\n        f[i] = mp[s];\n        cnt[f[i]]++;\n    }\n\n    string ans = \"no\";\n\n    if(cnt[0] >= 1) ans = \"yes\"; // id\n    if(cnt[1] >= 2) ans = \"yes\"; // swap\n    if(cnt[2] >= 2) ans = \"yes\"; // swap\n    if(cnt[5] >= 2) ans = \"yes\"; // swap\n    if(cnt[3] >= 3) ans = \"yes\"; // <<3\n    if(cnt[4] >= 3) ans = \"yes\"; // >>3\n    if(cnt[3] >= 1 && cnt[4] >= 1) ans = \"yes\"; // << >>\n    if(cnt[1]+cnt[2]+cnt[5] >= 2 && cnt[3]+cnt[4] >= 1) ans = \"yes\";\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint arr[6][3] = {\n    {0, 1, 2}, \n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0}\n};\n\nvector<int> w(6, 0);\nbool valid = false;\n\nvoid dfs(vector<int> v){\n    if(v[0] == 0 && v[1] == 1 && v[2] == 2){\n        valid = true;\n        return;\n    }\n    for(int i = 0; i < 6; i++){\n        if(w[i] == 0)   continue;\n        w[i]--;\n        vector<int> next(3);\n        for(int j = 0; j < 3; j++)  next[j] = v[arr[i][j]];\n        dfs(next);\n        w[i]++;\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    while(n-- > 0){\n        vector<int> v({0, 1, 2});\n        int q;  cin >> q;\n        while(q-- > 0){\n            int a;  cin >> a;\n            if(a == 0)  swap(v[0], v[1]);\n            if(a == 1)  swap(v[1], v[2]);\n        }\n        for(int i = 0; i < 6; i++){\n            bool valid = true;\n            for(int j = 0; j < 3; j++){\n                valid &= arr[i][j]==v[j];\n            }\n            if(valid)   w[i]++;\n        }\n    }\n    if(w[0] >= 1 || w[1] >= 2 || w[2] >= 2 || w[3] >= 3 || w[4] >= 3 || w[5] >= 2){\n        valid = true;\n    }else{\n        for(int i = 0; i < 6; i++){\n            if(w[i] == 0)   continue;\n            vector<int> next(3);\n            for(int j = 0; j < 3; j++)  next[j] = arr[i][j];\n            w[i]--;\n            dfs(next);\n            w[i]++;\n        }\n    }\n    cout << (valid ? \"yes\" : \"no\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct S {\n\tint a,b,c;\n\tS() {}\n\tS(int a,int b,int c):a(a),b(b),c(c) {}\n\tbool operator<(const S s) const {\n\t\treturn a<s.a;\n\t}\n};\n\nint n;\nint to[50][3];\nset<S> st[2];\n\nvoid dfs(int idx,int a,int b,int c,int limit,bool used) {\n\tif(idx==limit) {\n\t\t//cout<<\"idx=\"<<idx<<\"(\"<<a<<','<<b<<','<<c<<')'<<endl;\n\t\tif(used) {\n\t\t\tif(limit==n) st[1].insert(S(a,b,c));\n\t\t\telse st[0].insert(S(a,b,c));\n\t\t}\n\t\treturn;\n\t}\n\tdfs(idx+1,a,b,c,limit,used);\n\tdfs(idx+1,to[idx][a],to[idx][b],to[idx][c],limit,true);\n}\n\nint f(S s,int i) {\n\tif(i==0) return s.a;\n\telse if(i==1) return s.b;\n\telse return s.c;\n}\n\nS conv(S s,S t) {\n\tS res;\n\tres.a=f(s,t.a),res.b=f(s,t.b),res.c=f(s,t.c);\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tREP(i,50) REP(j,3) to[i][j]=j;\n\n\tcin>>n;\n\tREP(i,n) {\n\t\tint w,a;cin>>w;\n\t\tREP(j,w) {\n\t\t\tcin>>a;\n\t\t\tif(a==0) swap(to[i][0],to[i][1]);\n\t\t\telse swap(to[i][1],to[i][2]);\n\t\t}\n\t}\n\tdfs(0,0,1,2,n/2,false);dfs(n/2,0,1,2,n,false);\n\tfor(auto s:st[0]) {\n\t\t//cout<<s.a<<' '<<s.b<<' '<<s.c<<endl;\n\t\tif(s.a==0&&s.b==1&&s.c==2) {\n\t\t\tcout<<\"yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout<<\"after st1\"<<endl;\n\tfor(auto t:st[1]) {\n\t\t//cout<<t.a<<' '<<t.b<<' '<<t.c<<endl;\n\t\tif(t.a==0&&t.b==1&&t.c==2) {\n\t\t\tcout<<\"yes\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout<<\"after st2\"<<endl;\n\tfor(auto s:st[0]) {\n\t\tfor(auto t:st[1]) {\n\t\t\tS tmp=conv(s,t);\n\t\t\tif(tmp.a==0&&tmp.b==1&&tmp.c==2) {\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"no\"<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ei = tuple<int, int, int>;\n\nei pajie[] = {ei(0, 1, 2), ei(0, 2, 1), ei(1, 0, 2), ei(1, 2, 0), ei(2, 0, 1), ei(2, 1, 0), ei(0, 1, 2)};\n\nei latte(ei be, ei et) {\n  int a[3], b[3];\n  tie(a[0], a[1], a[2]) = be;\n  tie(b[0], b[1], b[2]) = et;\n  return ei(b[a[0]], b[a[1]], b[a[2]]);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<ei> v;\n  for (int i = 0; i < n; ++i) {\n    int a = 0, b = 1, c = 2;\n\n    int w;\n    cin >> w;\n\n    while (w--) {\n      int f;\n      cin >> f;\n\n      if (f)\n        swap(a, b);\n      else\n        swap(b, c);\n    }\n\n    v.push_back(ei(a, b, c));\n\n    // cerr << \"{\" << a << \", \" << b << \", \" << c << \"}\" << endl;\n  }\n\n  map<ei, int> unzip;\n  for (int i = 0; i < 6; ++i) {\n    unzip[pajie[i]] = i;\n  }\n\n  int dp[50][7] = {};\n  dp[0][6] = 1;\n\n  // cerr << unzip[v[0]] << endl;\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 7; ++j) {\n      if (dp[i][j]) {\n        dp[i + 1][j] = 1;\n        dp[i + 1][unzip[latte(pajie[j], v[i])]] = 1;\n      }\n    }\n  }\n\n  cout << (dp[n][0] ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\n\nstring change(string boo){\n  string str = \"123\";\n  rep(i,0,boo.sz){\n    if(boo[i] == '1')swap(str[1],str[2]);\n    else swap(str[1],str[0]);\n  }\n  return str;\n}\n\nstring exchange(string str,string key){\n  // ,,,,\n  if(key == \"132\")swap(str[1],str[2]);\n  if(key == \"321\")swap(str[0],str[2]);\n  if(key == \"213\")swap(str[0],str[1]);\n  if(key == \"231\"){\n    swap(str[0],str[1]);\n    swap(str[0],str[2]);\n  }\n  if(key == \"312\"){\n    swap(str[0],str[1]);\n    swap(str[1],str[2]);\n  }\n  return str;\n}\n\nint main(){\n  t = \"no\";\n  int num[6] = {0,1,1,1,2,2};\n  cin >> n;\n  vector<string> vec{\"123\",\"132\",\"321\",\"213\",\"231\",\"312\"};\n  map<string,int> test;\n  rep(i,0,n){\n    string boolean;\n    cin >> m;\n    rep(j,0,m){\n      char c;\n      cin >> c;\n      boolean += c;\n    }\n    test[change(boolean)]++;\n  }\n  rep(i,0,vec.sz)if(test[vec[i]] > num[i])t = \"yes\";\n  if(t != \"yes\"){\n    vector<string> vec2;\n    rep(i,1,6){\n      rep(j,0,test[vec[i]])vec2.pb(vec[i]);\n    }\n    sort(all(vec));\n    do{\n      string res = vec2[0];\n      // cout << \"first_res:\" << res << endl;\n      rep(i,1,vec2.sz){\n        res = exchange(res,vec2[i]);\n        // cout << \"res:\" << res << endl;\n        if(res == \"123\")t = \"yes\";\n      }\n    }while(next_permutation(vec2.begin(),vec2.end()));\n  }\n  print(t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, ami[6], a, w, p[3];\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = 0; i < N; ++i){\n        scanf(\"%lld\", &w);\n        *p = 0;\n        p[1] = 1;\n        p[2] = 2;\n        for(int j = 0; j < w; ++j){\n            scanf(\"%lld\", &a);\n            swap(p[1], p[a * 2]);\n        }\n        w = *p * 2 + (p[1] > p[2]);\n        ++ami[w];\n        switch(w){\n            case 0:\n                return 0 & puts(\"yes\");\n                break;\n            case 1:\n            case 2:\n            case 5:\n                if(ami[i] > 1)return 0 & puts(\"yes\");\n                break;\n            default:\n                if(ami[i] > 2)return 0 & puts(\"yes\");\n        }\n    }\n    if(ami[3] && ami[4])return 0 & puts(\"yes\");\n    if(ami[3] || ami[4]){\n        if(ami[1] + ami[2] + ami[3] > 1)return 0 & puts(\"yes\");\n    }\n    puts(\"no\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day2/problems/F>\n問題文============================================================\n\n 縦線が３本のあみだくじがN個ある。\n どの線からスタートしてもスタートした線で終わるあみだくじを良いあみだくじとする。\n あみだくじを１つ以上選んで縦に自由な順序でつなぐことができる。\n 良いあみだくじを作ることができるのであれば\"yes\"、そうでなければ\"no\"を出力せよ。\n \n i番目のあみだくじには横線がwi本ある。\n ai,jはあみだくじiの上からj番目の横棒が中央の縦線から左右どちらに伸びているかを表し、\n ai,jが0ならば左に、1ならば右に伸びていることを表す。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    ll N; cin >> N;\n    int check[6] = {0}; // 0: 123 / 1: 132 2: 321 3 : 213 / 4 : 312 5:231\n    for(int i = 0; i < N;i++){\n        ll w; cin >> w;\n        ll l = 1, m = 2, r = 3;\n        for(int j = 0; j < w;j++){\n            ll a; cin >> a;\n            if(a == 0){\n                swap(l,m);\n            }else{\n                swap(r,m);\n            }\n        }\n        string s = to_string(l) + to_string(m) + to_string(r);\n        int x = atoi(s.c_str());\n        if(x==123)check[0]++;\n        if(x==132)check[1]++;\n        if(x==321)check[2]++;\n        if(x==213)check[3]++;\n        if(x==312)check[4]++;\n        if(x==231)check[5]++;\n    }\n    \n    bool f = false;\n    if(check[0]) f = true;\n    if(check[1] > 1 || check[2] > 1 || check[3] > 1) f = true;\n    if(check[4] > 2 || check[5] > 2) f = true;\n    if(f){\n        cout << \"yes\" << endl;\n        return 0;\n    }\n    \n    // 0: 123 / 1: 132 2: 321 3 : 213 / 4 : 312 5:231\n    int n = check[1]+check[2]+check[3]+check[4]+check[5];\n    vector<pair<pii,int>> h(n);\n    int id = 0;\n    if(check[1]) h[id++]={{1,3},2};\n    if(check[2]) h[id++]={{3,2},1};\n    if(check[3]) h[id++]={{2,1},3};\n    \n    if(check[4]-- >0) h[id++]={{3,1},2};\n    if(check[4]-- >0) h[id++]={{3,1},2};\n    \n    if(check[5]-- >0) h[id++]={{2,3},1};\n    if(check[5]-- >0) h[id++]={{2,3},1};\n    \n    vector<int> per(n); iota(per.begin(),per.end(),0);\n    do{\n        int hh[4];\n        for(int i = 0; i < n;i++){\n            if(i==0){\n                hh[1]=h[per[i]].first.first; hh[2]=h[per[i]].first.second; hh[3]=h[per[i]].second;\n            }else{\n                int t1 = hh[h[per[i]].first.first], t2 = hh[h[per[i]].first.second], t3 = hh[h[per[i]].second];\n                hh[1]=t1; hh[2]=t2; hh[3]=t3;\n            }\n            \n            if(hh[1]==1&&hh[2]==2&&hh[3]==3){\n                cout << \"yes\"<<endl;\n                return 0;\n            }\n        }\n    }while(next_permutation(per.begin(),per.end()));\n    cout << \"no\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    VV<int> ls;\n    map<V<int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        int w;\n        cin >> w;\n        V<int> v(3);\n        iota(begin(v), end(v), 0);\n        for (int j = 0; j < w; j++) {\n            int a;\n            cin >> a;\n            swap(v[2*a], v[1]);\n        }\n        ls.push_back(v);\n        mp[v]++;\n        if (v == V<int>{0, 1, 2}) return true;\n        if (v == V<int>{1, 0, 2} && mp[v] >= 2) return true;\n        if (v == V<int>{0, 2, 1} && mp[v] >= 2) return true;\n        if (v == V<int>{2, 1, 0} && mp[v] >= 2) return true;\n        if (mp[v] >= 3) return true;\n    }\n    sort(begin(ls), end(ls));\n    do {\n        V<int> v(3), v2(3);\n        iota(begin(v), end(v), 0);\n        for (auto &w: ls) {\n            for (int i = 0; i < 3; i++) {\n                v2[w[i]] = v[i];\n            }\n            for (int i = 0; i < 3; i++) {\n                v[i] = v2[i];\n            }\n            if (v == V<int>{0, 1, 2}) return true;\n        }\n\n    } while (next_permutation(begin(ls), end(ls)));\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n\n    if (solve()) {\n        cout << \"yes\" << endl;\n    } else {\n        cout << \"no\" << endl;\n    }\n\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ei = tuple<int, int, int>;\n\nei pajie[] = {ei(0, 1, 2), ei(0, 2, 1), ei(1, 0, 2), ei(1, 2, 0), ei(2, 0, 1), ei(2, 1, 0)};\n\nei latte(ei be, ei et) {\n  int a[3], b[3];\n  tie(a[0], a[1], a[2]) = be;\n  tie(b[0], b[1], b[2]) = et;\n  return ei(b[a[0]], b[a[1]], b[a[2]]);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<ei> v;\n  for (int i = 0; i < n; ++i) {\n    int a = 0, b = 1, c = 2;\n\n    int w;\n    cin >> w;\n\n    while (w--) {\n      int f;\n      cin >> f;\n\n      if (f)\n        swap(a, b);\n      else\n        swap(b, c);\n    }\n\n    v.push_back(ei(a, b, c));\n\n    // cerr << \"{\" << a << \", \" << b << \", \" << c << \"}\" << endl;\n  }\n\n  map<ei, int> unzip;\n  for (int i = 0; i < 6; ++i) {\n    unzip[pajie[i]] = i;\n  }\n\n  int dp[50][6] = {};\n  dp[1][unzip[v[0]]] = 1;\n\n  // cerr << unzip[v[0]] << endl;\n\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < 6; ++j) {\n      if (dp[i][j]) {\n        dp[i + 1][j] = 1;\n        dp[i + 1][unzip[latte(pajie[j], v[i])]] = 1;\n      }\n    }\n  }\n\n  cout << (dp[n][0] ? \"yes\" : \"no\") << endl;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 3031 Ghost Legs\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nchar p[3][3][3];\n\nint main()\n{\n\tint N, w, i, ans;\n\tint a[3], t;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) {\n\t\ta[0] = 0, a[1] = 1, a[2] = 2;\n\t\tw = in();\n\t\twhile (w--) {\n\t\t\tif (in()) t = a[1], a[1] = a[2], a[2] = t;\n\t\t\telse      t = a[0], a[0] = a[1], a[1] = t;\n\t\t}\n//printf(\"--> %d %d %d\\n\", a[0], a[1], a[2]);\n\t\tp[a[0]][a[1]][a[2]]++;\n\t}\n\n\tans = p[0][1][2] ||\n\t\t  p[0][2][1] >= 2 || p[1][0][2] >= 2 || p[2][1][0] >= 2 ||\n\t\t  p[1][2][0] >= 3 || p[2][0][1] >= 3 || (p[1][2][0] && p[2][0][1]) ||\n\t\t  ((p[0][2][1] && p[1][0][2] || p[0][2][1] && p[2][1][0] ||\n\t\t\t     p[1][0][2] && p[2][1][0]) && (p[1][2][0] || p[2][0][1]));\n\n\tputs(ans? \"yes\": \"no\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint a[6];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tint d[3]={0,1,2};\n\t\twhile(k--){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x){int t=d[1];d[1]=d[2];d[2]=t;}\n\t\t\telse{int t=d[1];d[1]=d[0];d[0]=t;}\n\t\t}\n\t\ta[d[0]*2+(d[1]>d[2])]++;\n\t}\n\tif(a[0]>=1||a[1]>=2||a[2]>=2||a[5]>=2||a[3]>=3||a[4]>=3||(a[3]&&a[4])||(a[1]+a[2]+a[5]>=2&&(a[3]||a[4])))puts(\"yes\");\n\telse puts(\"no\");\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 3031 Ghost Legs\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nchar p[3][3][3];\n\nint main()\n{\n\tint N, w, i, ans;\n\tint a[3], t;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) {\n\t\ta[0] = 0, a[1] = 1, a[2] = 2;\n\t\tw = in();\n\t\twhile (w--) {\n\t\t\tif (in()) t = a[1], a[1] = a[2], a[2] = t;\n\t\t\telse      t = a[0], a[0] = a[1], a[1] = t;\n\t\t}\n//printf(\"--> %d %d %d\\n\", a[0], a[1], a[2]);\n\t\tp[a[0]][a[1]][a[2]]++;\n\t}\n\tans = p[0][1][2] ||\n\t\t  p[0][2][1] >= 2 || p[1][0][2] >= 2 || p[2][1][0] >= 2 ||\n\t\t  p[1][2][0] >= 3 || p[2][0][1] >= 3 || (p[1][2][0] && p[2][0][1]);\n\n\tputs(ans? \"yes\": \"no\");\n\treturn 0;\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int n; rd(n);\n\n  int id;\n  int s12, s23, s31;\n  int l, r;\n\n  while(n--){\n    auto args=readln.split.to!(int[]);\n    auto w=args[0], as=args[1..$];\n    int[] p=[1, 2, 3];\n    foreach(a; as){\n      if(a==0) swap(p[0], p[1]);\n      else swap(p[1], p[2]);\n    }\n    auto o1=p[0], o2=p[1], o3=p[2];\n    if(o1==1 && o2==2 && o3==3) id++;\n    if(o1==2 && o2==1 && o3==3) s12++;\n    if(o1==1 && o2==3 && o3==2) s23++;\n    if(o1==3 && o2==2 && o3==1) s31++;\n    if(o1==2 && o2==3 && o3==1) l++;\n    if(o1==3 && o2==1 && o3==2) r++;\n  }\n\n  if(id){\n    writeln(\"yes\");\n  }else if(s12>=2 || s23>=2 || s31>=2){\n    writeln(\"yes\");\n  }else if(l>=3 || r>=3){\n    writeln(\"yes\");\n  }else if(l>=1 && r>=1){\n    writeln(\"yes\");\n  }else{\n    writeln(\"no\");\n  }\n}\n\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int n; rd(n);\n\n  int id;\n  int s12, s23, s31;\n  int l, r;\n\n  while(n--){\n    auto args=readln.split.to!(int[]);\n    auto w=args[0], as=args[1..$];\n    int[] p=[1, 2, 3];\n    foreach(a; as){\n      if(a==0) swap(p[0], p[1]);\n      else swap(p[1], p[2]);\n    }\n    auto o1=p[0], o2=p[1], o3=p[2];\n    if(o1==1 && o2==2 && o3==3) id++;\n    if(o1==2 && o2==1 && o3==3) s12++;\n    if(o1==1 && o2==3 && o3==2) s23++;\n    if(o1==3 && o2==2 && o3==1) s31++;\n    if(o1==2 && o2==3 && o3==1) l++;\n    if(o1==3 && o2==1 && o3==2) r++;\n  }\n\n  if(id){\n    writeln(\"yes\");\n  }else if(s12>=2 || s23>=2 || s31>=2){\n    writeln(\"yes\");\n  }else if(l>=3 || r>=3){\n    writeln(\"yes\");\n  }else if(l>=1 && r>=1){\n    writeln(\"yes\");\n  }else if((l>=1 || r>=1) && s12>=1 && s23>=1){\n    writeln(\"yes\");\n  }else if((l>=1 || r>=1) && s23>=1 && s31>=1){\n    writeln(\"yes\");\n  }else if((l>=1 || r>=1) && s31>=1 && s12>=1){\n    writeln(\"yes\");\n  }else{\n    writeln(\"no\");\n  }\n}\n\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def amida():\n    line = list(map(int, input().split()))[1:]\n    res = [0, 1, 2]\n    for i in line:\n        if i:\n            res[1], res[2] = res[2], res[1]\n        else:\n            res[0], res[1] = res[1], res[0]\n    return res\n\n\ndef func(x, line, flag):\n    if line == [0, 1, 2] and flag:\n        return True\n    for i in range(27):\n        if x[i] == 0:\n            continue\n        swaps = tolist(i)\n        x[i] -= 1\n        res = func(x, [line[swaps[0]], line[swaps[1]], line[swaps[2]]], True)\n        x[i] += 1\n        if res:\n            return True\n    return False\n\n\nn = int(input())\nif n >= 7:\n    print(\"yes\")\n    exit()\namidas = [amida() for _ in range(n)]\ntoint = lambda x: x[0] * 9 + x[1] * 3 + x[2]\ntolist = lambda x: [x // 9, x % 9 // 3, x % 3]\naa = [0 for _ in range(27)]\nfor i in amidas:\n    aa[toint(i)] += 1\n\nflag = False\nfor i in range(27):\n    if aa[i] == 0:\n        continue\n    line = [0, 1, 2]\n    for j in range(aa[i]):\n        swaps = tolist(i)\n        line = [line[swaps[0]], line[swaps[1]], line[swaps[2]]]\n        if line == [0, 1, 2]:\n            flag = True\n            break\nif flag:\n    print(\"yes\")\n    exit()\nif func(aa, [0, 1, 2], False):\n    print(\"yes\")\n    exit()\nprint(\"no\")\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nSET = [0,0,0,0,0,0]\njudge = [[2,1,3],[1,3,2],[3,2,1],[2,3,1],[3,1,2],[1,2,3]]\nfor _ in range(0,N):\n    ID = [1, 2, 3]\n    amida = [int(x) for x in input().split()]\n    for j in range(1,len(amida)):\n        if amida[j] == 0:\n            ID[0],ID[1] = ID[1],ID[0]\n            #print(ID)\n        elif amida[j] == 1:\n            ID[1],ID[2] = ID[2],ID[1]\n            #print(ID)\n\n    for i in range(0,len(judge)):\n        if ID == judge[i]:\n            SET[i] += 1\n\n#print(SET)\n\nif ((SET[5] > 0) or (SET[0] > 1) or (SET[1] > 1) or (SET[2] > 1) or\n        ((SET[0] > 0) and (SET[1] > 0) and (SET[4] > 0)) or\n        ((SET[0] > 0) and (SET[2] > 0) and (SET[4] > 0)) or\n        ((SET[0] > 0) and (SET[2] > 0) and (SET[4] > 0)) or\n        ((SET[0] > 0) and (SET[1] > 0) and (SET[3] > 0)) or\n        ((SET[0] > 0) and (SET[2] > 0) and (SET[3] > 0)) or\n        ((SET[1] > 0) and (SET[2] > 0) and (SET[4] > 0)) or\n        ((SET[3] > 0) and (SET[4] > 0)) or\n        (SET[3] > 2) or (SET[4] > 2)):\n    print(\"yes\")\nelse:\n    print(\"no\")\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nC = [0]*6\nS = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]\nL = [1, 2, 2, 3, 3, 2]\nP = []\ninit = [0, 1, 2]\nfor i in range(N):\n    w, *A = map(int, input().split())\n    state = init[:]\n    for a in A:\n        if a:\n            state[1], state[2] = state[2], state[1]\n        else:\n            state[0], state[1] = state[1], state[0]\n    j = S.index(state)\n    C[j] += 1\n    if C[j] >= L[j]:\n        print('yes')\n        exit(0)\n    P.append(state)\n\n# case: \"L <= [0, 1, 1, 2, 2, 1]\"\nfrom itertools import permutations\nfor p in permutations(P):\n    s = init[:]\n    for q in p:\n        s[0], s[1], s[2] = s[q[0]], s[q[1]], s[q[2]]\n    if s == init:\n        print('yes')\n        exit(0)\n    print(s)\nprint('no')\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nC = [0]*6\nS = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]\nL = [1, 2, 2, 3, 3, 2]\nP = []\ninit = [0, 1, 2]\nfor i in range(N):\n    w, *A = map(int, input().split())\n    state = init[:]\n    for a in A:\n        if a:\n            state[1], state[2] = state[2], state[1]\n        else:\n            state[0], state[1] = state[1], state[0]\n    j = S.index(state)\n    C[j] += 1\n    if C[j] >= L[j]:\n        print('yes')\n        exit(0)\n    P.append(state)\n\n# case: \"L <= [0, 1, 1, 2, 2, 1]\"\nfrom itertools import permutations\nfor p in permutations(P):\n    s = init[:]\n    for q in p:\n        s[0], s[1], s[2] = s[q[0]], s[q[1]], s[q[2]]\n    if s == init:\n        print('yes')\n        exit(0)\nprint('no')\n\n"
  }
]