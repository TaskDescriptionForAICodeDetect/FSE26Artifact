[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    \n    int c[N], w[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &c[i], &w[i]);\n    }\n    \n    int colorCounts[101] = {0};\n    for (int i = 0; i < N; i++) {\n        colorCounts[c[i]]++;\n    }\n    \n    long long result = 1;\n    for (int color = 1; color <= 100; color++) {\n        if (colorCounts[color] > 1) {\n            int sameColorPairs = (colorCounts[color] * (colorCounts[color] - 1)) / 2;\n            result = (result * sameColorPairs) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MOD 1000000007\n#define MAXN 200000\n\ntypedef struct {\n    int color;\n    int weight;\n} Ball;\n\nBall balls[MAXN];\nint parent[MAXN];\nint size[MAXN];\nint color_min[MAXN];\nint color_max[MAXN];\nint color_exists[MAXN];\nint global_min = 1e9;\nint global_max = 0;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        if (size[u] < size[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        parent[v] = u;\n        size[u] += size[v];\n        if (color_min[u] > color_min[v]) color_min[u] = color_min[v];\n        if (color_max[u] < color_max[v]) color_max[u] = color_max[v];\n    }\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &balls[i].color, &balls[i].weight);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        parent[i] = i;\n        size[i] = 1;\n        color_min[i] = balls[i].color;\n        color_max[i] = balls[i].color;\n    }\n\n    // Operation 1: same color, total weight <= X\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (balls[i].color == balls[j].color && balls[i].weight + balls[j].weight <= X) {\n                union_sets(i, j);\n            }\n        }\n    }\n\n    // Operation 2: different color, total weight <= Y\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (balls[i].color != balls[j].color && balls[i].weight + balls[j].weight <= Y) {\n                union_sets(i, j);\n            }\n        }\n    }\n\n    // Collect all colors in each component\n    memset(color_exists, 0, sizeof(color_exists));\n    for (int i = 0; i < N; ++i) {\n        int root = find(i);\n        color_exists[balls[i].color] = 1;\n    }\n\n    // Count the number of unique color sets in components\n    int unique_colors = 0;\n    for (int i = 0; i < MAXN; ++i) {\n        if (color_exists[i]) unique_colors++;\n    }\n\n    // The answer is (number of unique color sets)! modulo MOD\n    long long result = 1;\n    for (int i = 1; i <= unique_colors; ++i) {\n        result = (result * i) % MOD;\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct UnionFind {\n    vector<int> parent, size;\n    UnionFind(int n) : parent(n), size(n, 1) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n        if (size[u] < size[v]) swap(u, v);\n        parent[v] = u;\n        size[u] += size[v];\n    }\n};\n\nint main() {\n    int N, X, Y;\n    cin >> N >> X >> Y;\n    vector<int> c(N), w(N);\n    for (int i = 0; i < N; ++i) cin >> c[i] >> w[i];\n\n    map<int, vector<int>> color_to_indices;\n    for (int i = 0; i < N; ++i) color_to_indices[c[i]].push_back(i);\n\n    UnionFind uf(N);\n\n    // Operation 1: same color\n    for (auto& [color, indices] : color_to_indices) {\n        if (indices.empty()) continue;\n        int min_idx = indices[0];\n        for (int idx : indices) {\n            if (w[idx] < w[min_idx]) min_idx = idx;\n        }\n        for (int idx : indices) {\n            if (w[idx] + w[min_idx] <= X) {\n                uf.unite(idx, min_idx);\n            }\n        }\n    }\n\n    // Operation 2: different colors\n    if (!color_to_indices.empty()) {\n        vector<pair<int, int>> all_min;\n        for (auto& [color, indices] : color_to_indices) {\n            if (indices.empty()) continue;\n            int min_idx = indices[0];\n            for (int idx : indices) {\n                if (w[idx] < w[min_idx]) min_idx = idx;\n            }\n            all_min.emplace_back(color, min_idx);\n        }\n        sort(all_min.begin(), all_min.end(), [&](const auto& a, const auto& b) {\n            return w[a.second] < w[b.second];\n        });\n\n        if (all_min.size() >= 2) {\n            int first_color = all_min[0].first;\n            int first_idx = all_min[0].second;\n            int second_idx = all_min[1].second;\n\n            for (auto& [color, indices] : color_to_indices) {\n                if (color == first_color) continue;\n                for (int idx : indices) {\n                    if (w[idx] + w[first_idx] <= Y) {\n                        uf.unite(idx, first_idx);\n                    }\n                }\n            }\n\n            for (int idx : color_to_indices[first_color]) {\n                if (w[idx] + w[second_idx] <= Y) {\n                    uf.unite(idx, second_idx);\n                }\n            }\n        }\n    }\n\n    map<int, map<int, int>> component_info;\n    for (int i = 0; i < N; ++i) {\n        int root = uf.find(i);\n        component_info[root][c[i]]++;\n    }\n\n    long long result = 1;\n    for (auto& [root, color_counts] : component_info) {\n        long long ways = 0;\n        for (auto& [color, cnt] : color_counts) {\n            ways += cnt;\n        }\n        result = (result * ways) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int N, X, Y;\n    static int[] c, w;\n    static List<List<Integer>> colorGroups;\n    static Map<Integer, Integer> colorToMinW;\n    static int globalMinW;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        X = Integer.parseInt(st.nextToken());\n        Y = Integer.parseInt(st.nextToken());\n        c = new int[N];\n        w = new int[N];\n        for (int i = 0; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            c[i] = Integer.parseInt(st.nextToken());\n            w[i] = Integer.parseInt(st.nextToken());\n        }\n\n        colorGroups = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            colorGroups.computeIfAbsent(c[i], k -> new ArrayList<>()).add(i);\n        }\n\n        colorToMinW = new HashMap<>();\n        globalMinW = Integer.MAX_VALUE;\n        for (Map.Entry<Integer, List<Integer>> entry : colorGroups.entrySet()) {\n            int minW = Integer.MAX_VALUE;\n            for (int idx : entry.getValue()) {\n                if (w[idx] < minW) {\n                    minW = w[idx];\n                }\n            }\n            colorToMinW.put(entry.getKey(), minW);\n            if (minW < globalMinW) {\n                globalMinW = minW;\n            }\n        }\n\n        List<Integer> movable = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int color = c[i];\n            if (w[i] + globalMinW <= Y || (colorToMinW.containsKey(color) && w[i] + colorToMinW.get(color) <= X)) {\n                movable.add(i);\n            }\n        }\n\n        Collections.sort(movable, Comparator.comparingInt(a -> c[a]));\n\n        int[] resultColors = new int[N];\n        int ptr = 0;\n        for (int color : colorGroups.keySet()) {\n            List<Integer> group = colorGroups.get(color);\n            List<Integer> currentGroup = new ArrayList<>();\n            for (int idx : group) {\n                if (w[idx] + globalMinW <= Y || w[idx] + colorToMinW.get(color) <= X) {\n                    currentGroup.add(idx);\n                }\n            }\n            Collections.sort(currentGroup, Comparator.comparingInt(a -> w[a]));\n            for (int idx : currentGroup) {\n                if (ptr < movable.size() && movable.get(ptr) == idx) {\n                    resultColors[movable.get(ptr)] = color;\n                    ptr++;\n                }\n            }\n        }\n\n        Map<Integer, Integer> colorCount = new HashMap<>();\n        for (int color : resultColors) {\n            colorCount.put(color, colorCount.getOrDefault(color, 0) + 1);\n        }\n\n        for (Map.Entry<Integer, List<Integer>> entry : colorGroups.entrySet()) {\n            int color = entry.getKey();\n            int cnt = entry.getValue().size();\n            colorCount.put(color, cnt);\n        }\n\n        long res = 1;\n        for (int cnt : colorCount.values()) {\n            res = res * factorial(cnt) % MOD;\n        }\n\n        System.out.println(res);\n    }\n\n    static long factorial(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) {\n            res = res * i % MOD;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:26:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n\n    public static int countColorSequences(int N, int X, int Y, int[] colors, int[] weights) {\n        int[] parent = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (colors[i] == colors[j] && weights[i] + weights[j] <= X) {\n                    union(parent, i, j);\n                }\n                if (colors[i] != colors[j] && weights[i] + weights[j] <= Y) {\n                    union(parent, i, j);\n                }\n            }\n        }\n\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            int root = find(parent, i);\n            groups.putIfAbsent(root, new HashSet<>());\n            groups.get(root).add(i);\n        }\n\n        long result = 1;\n        for (Set<Integer> group : groups.values()) {\n            Map<Integer, Integer> colorCount = new HashMap<>();\n            for (int idx : group) {\n                colorCount.put(colors[idx], colorCount.getOrDefault(colors[idx], 0) + 1);\n            }\n            long groupWays = 1;\n            for (int count : colorCount.values()) {\n                groupWays = (groupWays * factorial(count)) % MOD;\n            }\n            result = (result * groupWays) % MOD;\n        }\n\n        return (int) result;\n    }\n\n    private static int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    private static void union(int[] parent, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n\n    private static long factorial(int n) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result = (result * i) % MOD;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 23:26:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int countSequences(int N, vector<int>& colors, vector<int>& weights, int X, int Y) {\n        vector<int> parent(N);\n        for (int i = 0; i < N; i++) parent[i] = i;\n        \n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        \n        auto merge = [&](int x, int y) {\n            parent[find(x)] = find(y);\n        };\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (colors[i] == colors[j] && weights[i] + weights[j] <= X) {\n                    merge(i, j);\n                }\n                if (colors[i] != colors[j] && weights[i] + weights[j] <= Y) {\n                    merge(i, j);\n                }\n            }\n        }\n        \n        map<int, set<int>> groups;\n        for (int i = 0; i < N; i++) {\n            groups[find(i)].insert(colors[i]);\n        }\n        \n        int result = 1;\n        for (auto& group : groups) {\n            result = (result * (int)group.second.size()) % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 23:26:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef calculate_movements(N, colors, weights, X, Y):\n    # Grouping balls by color\n    from collections import defaultdict\n    color_to_indices = defaultdict(list)\n    for i in range(N):\n        color_to_indices[colors[i]].append(i)\n\n    # Checking possible swaps within the same color\n    for indices in color_to_indices.values():\n        indices.sort(key=lambda i: weights[i])\n    \n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def binomial(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        num = factorial(n)\n        denom = (factorial(k) * factorial(n - k)) % MOD\n        return (num * pow(denom, MOD - 2, MOD)) % MOD\n\n    def count_permutations(arr):\n        from collections import Counter\n        counter = Counter(arr)\n        denom = 1\n        for count in counter.values():\n            denom = (denom * factorial(count)) % MOD\n        num = factorial(len(arr))\n        return (num * pow(denom, MOD - 2, MOD)) % MOD\n\n    # Count different order permutations within same color groups\n    same_color_permutations = 1\n    for indices in color_to_indices.values():\n        same_color_permutations = (same_color_permutations * count_permutations(indices)) % MOD\n\n    # Count different order permutations globally considering different colors\n    all_color_permutations = count_permutations(colors)\n\n    return (same_color_permutations * all_color_permutations) % MOD\n\n# Example usage:\nN = 4\ncolors = [1, 2, 1, 2]\nweights = [3, 3, 3, 3]\nX = 6\nY = 6\nprint(calculate_movements(N, colors, weights, X, Y))  # This function will return the count of different sequences",
    "timestamp": "2025-08-13 15:07:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ColorfulBalls {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        long X = scanner.nextLong();\n        long Y = scanner.nextLong();\n\n        int[] colors = new int[N];\n        long[] weights = new long[N];\n        Map<Integer, List<Long>> colorWeightMap = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            colors[i] = scanner.nextInt();\n            weights[i] = scanner.nextLong();\n            colorWeightMap.computeIfAbsent(colors[i], k -> new ArrayList<>()).add(weights[i]);\n        }\n\n        Map<Integer, Integer> colorCount = new HashMap<>();\n        for (int color : colors) {\n            colorCount.put(color, colorCount.getOrDefault(color, 0) + 1);\n        }\n\n        long result = 1;\n        for (int count : colorCount.values()) {\n            result = (result * factorial(count)) % MOD;\n        }\n\n        long[] allWeights = Arrays.copyOf(weights, weights.length);\n        Arrays.sort(allWeights);\n\n        for (List<Long> weightList : colorWeightMap.values()) {\n            Collections.sort(weightList);\n            int m = weightList.size();\n            long totalPairs = ((long) m * (m - 1)) / 2;\n            long possiblePairs = countValidPairsUnderLimit(weightList, X);\n            result = (result * modPow(2, totalPairs - possiblePairs)) % MOD;\n        }\n\n        result = (result * modPow(2, countValidPairsUnderLimit(Arrays.asList(allWeights), Y))) % MOD;\n\n        System.out.println(result);\n    }\n\n    private static long countValidPairsUnderLimit(List<Long> weights, long limit) {\n        int n = weights.size();\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (weights.get(i) + weights.get(j) <= limit) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static long factorial(int n) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result = (result * i) % MOD;\n        }\n        return result;\n    }\n\n    private static long modPow(long base, long exp) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % MOD;\n            }\n            base = (base * base) % MOD;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 15:08:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int color;\n    int weight;\n} Ball;\n\nint compare(const void *a, const void *b) {\n    return ((Ball *)a)->color - ((Ball *)b)->color;\n}\n\nint factorial(int n) {\n    long long result = 1;\n    for(int i = 2; i <= n; i++)\n        result = (result * i) % MOD;\n    return (int)result;\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    \n    Ball balls[N];\n    for(int i = 0; i < N; i++)\n        scanf(\"%d %d\", &balls[i].color, &balls[i].weight);\n    \n    // Sort balls based on their color\n    qsort(balls, N, sizeof(Ball), compare);\n\n    // Calculate how many sequences can be formed using Operation 1\n    int fact_count = 1;\n    int same_color_count = 1;\n    for(int i = 1; i < N; i++) {\n        if(balls[i].color == balls[i - 1].color)\n            same_color_count++;\n        else {\n            fact_count = (fact_count * factorial(same_color_count)) % MOD;\n            same_color_count = 1;\n        }\n    }\n    fact_count = (fact_count * factorial(same_color_count)) % MOD;\n\n    // Calculate total sequences modulo MOD\n    int total_sequences = factorial(N);\n    int result = total_sequences / fact_count;\n    printf(\"%d\\n\", result % MOD);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:08:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <numeric>\n#include <algorithm>\n\nconst int MOD = 1000000007;\n\n// Helper function to compute factorials and inverse factorials modulo MOD\nstd::vector<long long> compute_factorials(int n) {\n    std::vector<long long> fact(n + 1, 1);\n    for (int i = 2; i <= n; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    return fact;\n}\n\nstd::vector<long long> compute_inverse_factorials(const std::vector<long long>& fact) {\n    std::vector<long long> inv_fact(fact.size());\n    inv_fact.back() = powmod(fact.back(), MOD - 2, MOD);\n    for (int i = fact.size() - 2; i >= 0; --i) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n    return inv_fact;\n}\n\nlong long powmod(long long a, long long b, long long m) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res = (res * a) % m;\n        }\n        a = (a * a) % m;\n        b /= 2;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    long long X, Y;\n    std::cin >> n >> X >> Y;\n    std::vector<int> c(n);\n    std::vector<long long> w(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> c[i] >> w[i];\n    }\n\n    std::map<int, int> color_count;\n    for (int col : c) {\n        color_count[col]++;\n    }\n\n    auto fact = compute_factorials(n);\n    auto inv_fact = compute_inverse_factorials(fact);\n\n    // Calculate number of distinct permutations of colors\n    long long total_permutations = fact[n];\n    for (const auto& [color, count] : color_count) {\n        total_permutations = (total_permutations * inv_fact[count]) % MOD;\n    }\n\n    std::cout << total_permutations << std::endl;\n}",
    "timestamp": "2025-08-13 15:08:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_color_sequences(N, colors, weights, X, Y):\n    MOD = 10**9 + 7\n    \n    # Create a graph to represent possible swaps\n    graph = [[] for _ in range(N)]\n    \n    # Add edges for same color swaps\n    for i in range(N):\n        for j in range(i+1, N):\n            if colors[i] == colors[j] and weights[i] + weights[j] <= X:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    # Add edges for different color swaps\n    for i in range(N):\n        for j in range(i+1, N):\n            if colors[i] != colors[j] and weights[i] + weights[j] <= Y:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    # Use BFS to find connected components\n    visited = [False] * N\n    color_groups = []\n    \n    def bfs(start):\n        component = []\n        queue = [start]\n        visited[start] = True\n        \n        while queue:\n            node = queue.pop(0)\n            component.append(node)\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        \n        return component\n    \n    # Group balls that can be swapped\n    for i in range(N):\n        if not visited[i]:\n            color_groups.append(bfs(i))\n    \n    # Calculate number of possible permutations\n    result = 1\n    for group in color_groups:\n        color_count = {}\n        for idx in group:\n            color_count[colors[idx]] = color_count.get(colors[idx], 0) + 1\n        \n        # Calculate permutations for each color group\n        group_perms = 1\n        for count in color_count.values():\n            group_perms = (group_perms * factorial(count)) % MOD\n        \n        result = (result * group_perms) % MOD\n    \n    return result\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result = (result * i) % (10**9 + 7)\n    return result",
    "timestamp": "2025-08-13 15:08:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    X = int(input[ptr])\n    ptr += 1\n    Y = int(input[ptr])\n    ptr += 1\n    \n    c = []\n    w = []\n    for _ in range(N):\n        ci = int(input[ptr])\n        wi = int(input[ptr+1])\n        c.append(ci)\n        w.append(wi)\n        ptr += 2\n    \n    color_to_balls = defaultdict(list)\n    for i in range(N):\n        color_to_balls[c[i]].append(w[i])\n    \n    # Find min for each color\n    min_per_color = {}\n    for color in color_to_balls:\n        min_per_color[color] = min(color_to_balls[color])\n    \n    global_min = min(min_per_color.values()) if min_per_color else 0\n    \n    # Find the second min (excluding the global_min color)\n    second_min = float('inf')\n    for color in min_per_color:\n        if min_per_color[color] != global_min:\n            if min_per_color[color] < second_min:\n                second_min = min_per_color[color]\n    \n    if second_min == float('inf'):\n        second_min = global_min\n    \n    # For each ball, determine if it can be swapped with any other ball\n    # A ball can be moved freely if:\n    # - it can be swapped with the global_min (if same color, sum <= X; else sum <= Y)\n    # - or it can be swapped with the second_min (if different color, sum <= Y)\n    \n    movable = [False] * N\n    global_min_color = None\n    for color in min_per_color:\n        if min_per_color[color] == global_min:\n            global_min_color = color\n            break\n    \n    for i in range(N):\n        wi = w[i]\n        ci = c[i]\n        # Check if can swap with global_min\n        if ci == global_min_color:\n            if wi + global_min <= X:\n                movable[i] = True\n        else:\n            if wi + global_min <= Y:\n                movable[i] = True\n        # Check if can swap with second_min\n        if global_min_color != ci:\n            if wi + second_min <= Y:\n                movable[i] = True\n    \n    # Also, the global_min itself is movable\n    for i in range(N):\n        if w[i] == global_min and c[i] == global_min_color:\n            movable[i] = True\n    \n    # Now, for each color, the balls that are movable can be in any order\n    # The non-movable balls must stay in their original relative order\n    \n    # Group by color, and for each color, split into movable and non-movable\n    color_groups = defaultdict(list)\n    for i in range(N):\n        color_groups[c[i]].append(i)\n    \n    res = 1\n    fact = [1] * (N + 1)\n    for i in range(1, N+1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (N + 1)\n    inv_fact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    for color in color_groups:\n        indices = color_groups[color]\n        m_count = 0\n        nm_indices = []\n        for idx in indices:\n            if movable[idx]:\n                m_count += 1\n            else:\n                nm_indices.append(idx)\n        # The non-movable must be in the same relative order\n        # So the number of ways is (m_count + len(nm_indices)) choose m_count\n        total = m_count + len(nm_indices)\n        ways = fact[total] * inv_fact[m_count] % MOD\n        ways = ways * inv_fact[total - m_count] % MOD\n        res = res * ways % MOD\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:08:47"
  }
]