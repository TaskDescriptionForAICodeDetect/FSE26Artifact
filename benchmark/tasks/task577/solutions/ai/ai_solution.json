[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint flood(char* diagram) {\n    int len = strlen(diagram);\n    int left[1000] = {0};\n    int right[1000] = {0};\n    int water[1000] = {0};\n    int max_height = 0;\n\n    // Find left wall heights\n    int current_height = 0;\n    for (int i = 0; i < len; i++) {\n        if (diagram[i] == '/')\n            current_height++;\n        else if (diagram[i] == '\\\\')\n            current_height--;\n        left[i] = current_height;\n        max_height = (current_height > max_height) ? current_height : max_height;\n    }\n\n    // Find right wall heights\n    current_height = 0;\n    for (int i = len - 1; i >= 0; i--) {\n        if (diagram[i] == '\\\\')\n            current_height++;\n        else if (diagram[i] == '/')\n            current_height--;\n        right[i] = current_height;\n    }\n\n    // Calculate water levels\n    for (int i = 0; i < len; i++) {\n        int min_height = (left[i] < right[i]) ? left[i] : right[i];\n        if (min_height > 0 && diagram[i] == '_')\n            water[i] = min_height;\n    }\n\n    // Count total water volume\n    int total_water = 0;\n    for (int i = 0; i < len; i++) {\n        total_water += water[i];\n    }\n\n    return total_water;\n}\n\nint main() {\n    char diagram[1000];\n    scanf(\"%s\", diagram);\n    printf(\"%d\\n\", flood(diagram));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int pos;\n    int depth;\n} Point;\n\nvoid simulate_flood(char* diagram) {\n    int len = strlen(diagram);\n    int max_depth = 0;\n    Point* stack = malloc(len * sizeof(Point));\n    int stack_top = -1;\n    int* areas = calloc(len, sizeof(int));\n    int total_area = 0;\n\n    for (int i = 0; i < len; i++) {\n        if (diagram[i] == '\\\\') {\n            stack_top++;\n            stack[stack_top].pos = i;\n            stack[stack_top].depth = stack_top;\n        } else if (diagram[i] == '/' && stack_top >= 0) {\n            Point p = stack[stack_top];\n            stack_top--;\n            int area = i - p.pos;\n            total_area += area;\n            areas[p.pos] = area;\n        }\n    }\n\n    printf(\"%d\\n\", total_area);\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (areas[i] > 0) {\n            count++;\n        }\n    }\n    printf(\"%d\", count);\n    for (int i = 0; i < len; i++) {\n        if (areas[i] > 0) {\n            printf(\" %d\", areas[i]);\n        }\n    }\n    printf(\"\\n\");\n\n    free(stack);\n    free(areas);\n}\n\nint main() {\n    char diagram[20001];\n    scanf(\"%20000s\", diagram);\n    simulate_flood(diagram);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid simulateFlood(const string &diagram) {\n    stack<int> slopes;\n    vector<int> areas(diagram.size(), 0);\n    int total = 0;\n\n    for (int i = 0; i < diagram.size(); ++i) {\n        if (diagram[i] == '\\\\') {\n            slopes.push(i);\n        } else if (diagram[i] == '/' && !slopes.empty()) {\n            int j = slopes.top();\n            slopes.pop();\n            int area = i - j;\n            total += area;\n            areas[j] = area;\n        }\n    }\n\n    cout << total << endl;\n    vector<int> result;\n    for (int i = 0; i < areas.size(); ++i) {\n        if (areas[i] > 0) {\n            result.push_back(areas[i]);\n        }\n    }\n    cout << result.size();\n    for (int a : result) {\n        cout << \" \" << a;\n    }\n    cout << endl;\n}\n\nint main() {\n    string diagram;\n    cin >> diagram;\n    simulateFlood(diagram);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class FloodSimulation {\n    public static List<Integer> simulateFlood(String diagram) {\n        List<Integer> areas = new ArrayList<>();\n        List<Integer> stack = new ArrayList<>();\n        int totalArea = 0;\n\n        for (int i = 0; i < diagram.length(); i++) {\n            char c = diagram.charAt(i);\n            if (c == '\\\\') {\n                stack.add(i);\n            } else if (c == '/' && !stack.isEmpty()) {\n                int j = stack.remove(stack.size() - 1);\n                int area = i - j;\n                totalArea += area;\n                areas.add(area);\n            }\n        }\n\n        return areas;\n    }\n}",
    "timestamp": "2025-08-05 22:12:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int[] floodFill(String diagram) {\n        int[] levels = new int[diagram.length()];\n        int currentHeight = 0;\n\n        for (int i = 0; i < diagram.length(); i++) {\n            char c = diagram.charAt(i);\n            \n            if (c == '/') {\n                currentHeight++;\n            } else if (c == '\\\\') {\n                currentHeight--;\n            }\n            \n            levels[i] = currentHeight;\n        }\n\n        int floodStart = -1;\n        int maxFloodHeight = 0;\n        int floodArea = 0;\n\n        for (int i = 0; i < levels.length; i++) {\n            if (levels[i] == 0) {\n                if (floodStart != -1) {\n                    int currentFloodHeight = calculateFloodHeight(levels, floodStart, i);\n                    int currentFloodArea = calculateFloodArea(levels, floodStart, i);\n                    \n                    if (currentFloodHeight > maxFloodHeight) {\n                        maxFloodHeight = currentFloodHeight;\n                        floodArea = currentFloodArea;\n                    }\n                }\n                floodStart = -1;\n            } else if (floodStart == -1) {\n                floodStart = i;\n            }\n        }\n\n        return new int[]{maxFloodHeight, floodArea};\n    }\n\n    private int calculateFloodHeight(int[] levels, int start, int end) {\n        int maxHeight = 0;\n        for (int i = start; i < end; i++) {\n            maxHeight = Math.max(maxHeight, Math.abs(levels[i]));\n        }\n        return maxHeight;\n    }\n\n    private int calculateFloodArea(int[] levels, int start, int end) {\n        int area = 0;\n        for (int i = start; i < end; i++) {\n            area += Math.abs(levels[i]);\n        }\n        return area;\n    }\n}",
    "timestamp": "2025-08-05 22:12:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass FloodSimulator {\npublic:\n    int calculateFloodedArea(const std::string& diagram) {\n        int n = diagram.length();\n        std::vector<int> height(n, 0);\n        int maxHeight = 0;\n\n        // Calculate height profile\n        for (int i = 0; i < n; ++i) {\n            if (diagram[i] == '/') {\n                height[i] = (i > 0 ? height[i-1] + 1 : 1);\n            } else if (diagram[i] == '\\\\') {\n                height[i] = (i > 0 ? height[i-1] - 1 : -1);\n            } else {\n                height[i] = (i > 0 ? height[i-1] : 0);\n            }\n            maxHeight = std::max(maxHeight, std::abs(height[i]));\n        }\n\n        // Create 2D grid representing terrain\n        std::vector<std::vector<char>> grid(2 * maxHeight + 1, std::vector<char>(n, '.'));\n        int baseLevel = maxHeight;\n\n        // Mark terrain\n        for (int i = 0; i < n; ++i) {\n            int currentHeight = height[i] + baseLevel;\n            if (diagram[i] == '/') {\n                for (int h = baseLevel; h <= currentHeight; ++h) {\n                    grid[h][i] = '/';\n                }\n            } else if (diagram[i] == '\\\\') {\n                for (int h = baseLevel; h >= currentHeight; --h) {\n                    grid[h][i] = '\\\\';\n                }\n            } else {\n                grid[baseLevel][i] = '_';\n            }\n        }\n\n        // Calculate flooded area\n        int floodedArea = 0;\n        for (int h = 0; h < grid.size(); ++h) {\n            bool inside = false;\n            int start = -1;\n            \n            for (int w = 0; w < n; ++w) {\n                if (grid[h][w] == '\\\\') {\n                    if (!inside) {\n                        inside = true;\n                        start = w;\n                    } else {\n                        inside = false;\n                        floodedArea += w - start;\n                    }\n                } else if (grid[h][w] == '/') {\n                    inside = false;\n                }\n            }\n        }\n\n        return floodedArea;\n    }\n};\n\nint main() {\n    FloodSimulator simulator;\n    std::string diagram;\n    std::cin >> diagram;\n    std::cout << simulator.calculateFloodedArea(diagram) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def flood_damage(diagram):\n    stack = []\n    flooded_sections = []\n    section_sizes = []\n    position = 0\n    \n    for char in diagram:\n        if char == '/':\n            if stack:\n                start_pos = stack.pop()\n                flooded_sections.append((start_pos, position))\n                size = 0\n                while section_sizes and section_sizes[-1][0] > start_pos:\n                    size += section_sizes.pop()[1]\n                section_sizes.append((start_pos, position - start_pos + size))\n            stack.append(position)\n        elif char == '\\\\':\n            stack.append(position)\n        position += 1\n\n    return list(filter(lambda x: x[1] > 0, section_sizes))\n\n# Example usage:\ndiagram = \"__/\\\\__/\\\\___/\\\\\"\nprint(flood_damage(diagram))",
    "timestamp": "2025-08-13 09:26:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FloodDamageSimulation {\n\n    public static void main(String[] args) {\n        String diagram = \"_/\\\\_/__\\\\__/\";\n        List<Integer> floodedAreas = getFloodedAreas(diagram);\n\n        System.out.println(floodedAreas);\n    }\n\n    public static List<Integer> getFloodedAreas(String diagram) {\n        Stack<Integer> stack = new Stack<>();\n        List<Integer> floodedAreas = new ArrayList<>();\n        int totalLength = diagram.length();\n        int[] areaMarkers = new int[totalLength];\n\n        for (int i = 0; i < totalLength; i++) {\n            char currentChar = diagram.charAt(i);\n            if (currentChar == '/') {\n                stack.push(i);\n            } else if (currentChar == '\\\\' && !stack.isEmpty()) {\n                int startIndex = stack.pop();\n                areaMarkers[startIndex] = i; // pair the '/' with '\\'\n            }\n        }\n\n        for (int i = 0; i < totalLength; i++) {\n            if (areaMarkers[i] > 0) {\n                int start = i;\n                int end = areaMarkers[i];\n                floodedAreas.add(end - start - 1); // calculate flooded area size\n            }\n        }\n\n        return floodedAreas;\n    }\n}",
    "timestamp": "2025-08-13 09:26:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 1000\n\ntypedef struct {\n    int start;\n    int area;\n} Section;\n\nint main() {\n    char landscape[MAX_SIZE];\n    Section sections[MAX_SIZE];\n    int top = -1;\n    int totalArea = 0;\n    int areas[MAX_SIZE];\n    int areasIndex = 0;\n\n    fgets(landscape, MAX_SIZE, stdin);\n\n    int length = strlen(landscape);\n    int currentLevel = 0;\n\n    for (int i = 0; i < length; i++) {\n        if (landscape[i] == '/') {\n            currentLevel++;\n            if (top > -1 && sections[top].start == currentLevel - 1) {\n                top--;\n            } else {\n                sections[++top].start = currentLevel;\n            }\n        } else if (landscape[i] == '\\\\') {\n            currentLevel--;\n            if (top > -1 && sections[top].start == currentLevel + 1) {\n                int width = i - sections[top].start;\n                int area = width;\n                totalArea += area;\n                while(areasIndex > 0 && areas[areasIndex - 1] <= area) {\n                    area += areas[--areasIndex];\n                }\n                areas[areasIndex++] = area;\n                top--;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", totalArea);\n    printf(\"%d\", areasIndex);\n    for (int i = 0; i < areasIndex; i++) {\n        printf(\" %d\", areas[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:26:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def flood_area(diagram):\n    n = len(diagram)\n    left_max = [0] * n\n    right_max = [0] * n\n    water_level = [0] * n\n    \n    # Calculate left max height\n    current_height = 0\n    for i in range(n):\n        if diagram[i] == '/':\n            current_height += 1\n        elif diagram[i] == '\\\\':\n            current_height -= 1\n        left_max[i] = current_height\n    \n    # Calculate right max height\n    current_height = 0\n    for i in range(n-1, -1, -1):\n        if diagram[i] == '\\\\':\n            current_height += 1\n        elif diagram[i] == '/':\n            current_height -= 1\n        right_max[i] = current_height\n    \n    # Calculate flood areas\n    total_flood_area = 0\n    for i in range(n):\n        water_level[i] = min(left_max[i], right_max[i])\n        if water_level[i] > 0:\n            total_flood_area += water_level[i]\n    \n    return total_flood_area",
    "timestamp": "2025-08-13 09:26:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_flood_areas(diagram):\n    stack = []\n    total = 0\n    areas = []\n    \n    for i, char in enumerate(diagram):\n        if char == '\\\\':\n            stack.append(i)\n        elif char == '/' and stack:\n            start = stack.pop()\n            area = i - start\n            total += area\n            # Merge with existing areas if they are nested\n            while areas and start < areas[-1][0]:\n                prev_start, prev_area = areas.pop()\n                area += prev_area\n            areas.append((start, area))\n    \n    print(total)\n    print(len(areas), end=' ')\n    if areas:\n        print(' '.join(map(str, [area for _, area in areas])))\n    else:\n        print()\n\n# Read input and process\ndiagram = input().strip()\ncalculate_flood_areas(diagram)",
    "timestamp": "2025-08-13 09:26:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string diagram;\n    cin >> diagram;\n\n    int n = diagram.size();\n    vector<int> water(n, 0);\n    stack<int> s;\n\n    for (int i = 0; i < n; ++i) {\n        if (diagram[i] == '/') {\n            if (!s.empty()) {\n                int j = s.top(); s.pop();\n                water[i] = (i - j);\n                if (!s.empty()) water[i] += water[s.top()];\n            }\n        } else if (diagram[i] == '\\\\') {\n            s.push(i);\n        }\n    }\n\n    vector<int> areas;\n    for (int i = 0; i < n; ++i) {\n        if (water[i] > 0) {\n            areas.push_back(water[i]);\n        }\n    }\n\n    cout << areas.size() << endl;\n    for (size_t i = 0; i < areas.size(); ++i) {\n        cout << areas[i];\n        if (i != areas.size() - 1) {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:51:24"
  }
]