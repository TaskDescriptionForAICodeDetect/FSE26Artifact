[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Position;\n\nint canCompletePatrol(int** grid, int rows, int cols, Position* path, int pathLength, int initialHP, int maxHP) {\n    int currentHP = initialHP;\n    int currentMaxHP = maxHP;\n    \n    for (int i = 0; i < pathLength; i++) {\n        int x = path[i].x;\n        int y = path[i].y;\n        \n        if (x < 0 || x >= rows || y < 0 || y >= cols) {\n            return 0; // Invalid path\n        }\n        \n        currentHP += grid[x][y];\n        \n        if (grid[x][y] > 0) {\n            if (currentHP > currentMaxHP) {\n                currentHP = currentMaxHP;\n            }\n        }\n        \n        if (currentHP <= 0) {\n            return 0;\n        }\n    }\n    \n    return 1;\n}\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n    \n    int** grid = (int**)malloc(rows * sizeof(int*));\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int*)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int pathLength;\n    scanf(\"%d\", &pathLength);\n    \n    Position* path = (Position*)malloc(pathLength * sizeof(Position));\n    for (int i = 0; i < pathLength; i++) {\n        scanf(\"%d %d\", &path[i].x, &path[i].y);\n    }\n    \n    int initialHP, maxHP;\n    scanf(\"%d %d\", &initialHP, &maxHP);\n    \n    if (canCompletePatrol(grid, rows, cols, path, pathLength, initialHP, maxHP)) {\n        printf(\"Survived\\n\");\n    } else {\n        printf(\"Died\\n\");\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    free(path);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canCompletePatrol(const vector<vector<int>>& grid, const vector<pair<int, int>>& route, int initialHP, int maxHP) {\n    int currentHP = initialHP;\n    int currentMaxHP = maxHP;\n    \n    for (const auto& pos : route) {\n        int x = pos.first;\n        int y = pos.second;\n        \n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size()) {\n            return false; // Invalid position\n        }\n        \n        int cellValue = grid[x][y];\n        if (cellValue < 0) {\n            currentHP += cellValue; // Trap reduces HP\n        } else if (cellValue > 0) {\n            currentHP = min(currentHP + cellValue, currentMaxHP); // Potion increases HP, capped at maxHP\n        }\n        \n        if (currentHP <= 0) {\n            return false; // Died\n        }\n    }\n    \n    return true; // Survived\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    \n    vector<vector<int>> grid(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int routeLength;\n    cin >> routeLength;\n    vector<pair<int, int>> route(routeLength);\n    for (int i = 0; i < routeLength; ++i) {\n        cin >> route[i].first >> route[i].second;\n    }\n    \n    int initialHP, maxHP;\n    cin >> initialHP >> maxHP;\n    \n    if (canCompletePatrol(grid, route, initialHP, maxHP)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CavePatrol {\n    public static boolean canCompletePatrol(int[][] grid, int[][] route, int initialHP, int maxHP) {\n        int currentHP = initialHP;\n        int maxPossibleHP = maxHP;\n        \n        for (int[] step : route) {\n            int x = step[0];\n            int y = step[1];\n            \n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {\n                return false; // Out of bounds\n            }\n            \n            int cellValue = grid[x][y];\n            if (cellValue < 0) {\n                currentHP += cellValue; // Trap reduces HP\n            } else if (cellValue > 0) {\n                currentHP = Math.min(currentHP + cellValue, maxPossibleHP); // Potion increases HP, but not beyond max\n            }\n            \n            if (currentHP <= 0) {\n                return false; // Died\n            }\n        }\n        \n        return true; // Survived\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read grid dimensions\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        int[][] grid = new int[rows][cols];\n        \n        // Read grid values\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // Read route length\n        int routeLength = scanner.nextInt();\n        int[][] route = new int[routeLength][2];\n        \n        // Read route steps\n        for (int i = 0; i < routeLength; i++) {\n            route[i][0] = scanner.nextInt();\n            route[i][1] = scanner.nextInt();\n        }\n        \n        // Read initial and max HP\n        int initialHP = scanner.nextInt();\n        int maxHP = scanner.nextInt();\n        \n        // Check if patrol can be completed\n        boolean result = canCompletePatrol(grid, route, initialHP, maxHP);\n        System.out.println(result ? \"YES\" : \"NO\");\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:17:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class SecurityAgentPatrol {\n    public static boolean canCompletePatrol(int initialHitPoints, int maxHitPoints, int[][] traps, int[] route) {\n        int currentHitPoints = initialHitPoints;\n        \n        for (int[] trapLocation : traps) {\n            int trapRow = trapLocation[0];\n            int trapCol = trapLocation[1];\n            int trapDamage = trapLocation[2];\n            int potionValue = trapLocation[3];\n            \n            for (int[] step : route) {\n                int currentRow = step[0];\n                int currentCol = step[1];\n                \n                if (currentRow == trapRow && currentCol == trapCol) {\n                    currentHitPoints -= trapDamage;\n                    \n                    if (potionValue > 0) {\n                        currentHitPoints = Math.min(currentHitPoints + potionValue, maxHitPoints);\n                    }\n                    \n                    if (currentHitPoints <= 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int initialHitPoints = 100;\n        int maxHitPoints = 150;\n        \n        int[][] traps = {\n            {0, 1, 20, 10},   // [row, col, damage, potion]\n            {1, 2, 30, 15},\n            {2, 3, 40, 0}\n        };\n        \n        int[][] route = {\n            {0, 0},\n            {0, 1},\n            {1, 1},\n            {1, 2},\n            {2, 2},\n            {2, 3}\n        };\n        \n        boolean canComplete = canCompletePatrol(initialHitPoints, maxHitPoints, traps, route);\n        System.out.println(\"Can complete patrol: \" + canComplete);\n    }\n}",
    "timestamp": "2025-08-05 21:17:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_GRID_SIZE 100\n\ntypedef struct {\n    int hitPoints;\n    int maxHitPoints;\n} Agent;\n\ntypedef struct {\n    int grid[MAX_GRID_SIZE][MAX_GRID_SIZE];\n    int rows;\n    int cols;\n} Cave;\n\nbool canCompletePatrol(Agent* agent, Cave* cave, int* route, int routeLength) {\n    for (int i = 0; i < routeLength; i++) {\n        int cell = route[i];\n        int row = cell / cave->cols;\n        int col = cell % cave->cols;\n        \n        int damage = cave->grid[row][col];\n        \n        if (damage < 0) {\n            int healAmount = -damage;\n            agent->hitPoints = (agent->hitPoints + healAmount > agent->maxHitPoints) \n                ? agent->maxHitPoints \n                : agent->hitPoints + healAmount;\n        } else {\n            agent->hitPoints -= damage;\n            \n            if (agent->hitPoints <= 0) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    Cave cave;\n    Agent agent;\n    int route[MAX_GRID_SIZE];\n    int routeLength;\n    \n    // Input cave configuration\n    scanf(\"%d %d\", &cave.rows, &cave.cols);\n    for (int i = 0; i < cave.rows; i++) {\n        for (int j = 0; j < cave.cols; j++) {\n            scanf(\"%d\", &cave.grid[i][j]);\n        }\n    }\n    \n    // Input agent configuration\n    scanf(\"%d %d\", &agent.hitPoints, &agent.maxHitPoints);\n    \n    // Input patrol route\n    scanf(\"%d\", &routeLength);\n    for (int i = 0; i < routeLength; i++) {\n        scanf(\"%d\", &route[i]);\n    }\n    \n    bool success = canCompletePatrol(&agent, &cave, route, routeLength);\n    \n    printf(\"%s\\n\", success ? \"Survived\" : \"Dead\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass SecurityAgent {\nprivate:\n    int currentHP;\n    int maxHP;\n    int potions;\n\npublic:\n    SecurityAgent(int initialHP, int maxHP, int potionCount) : \n        currentHP(initialHP), maxHP(maxHP), potions(potionCount) {}\n\n    bool canCompletePath(vector<vector<int>>& grid, vector<pair<int, int>>& route) {\n        for (auto& point : route) {\n            int damage = grid[point.first][point.second];\n            \n            if (damage < 0) {\n                currentHP += abs(damage);\n                if (currentHP > maxHP) currentHP = maxHP;\n            } else {\n                currentHP -= damage;\n                \n                while (currentHP <= 0 && potions > 0) {\n                    currentHP += maxHP / 2;\n                    potions--;\n                }\n            }\n            \n            if (currentHP <= 0) return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    int height, width, initialHP, maxHP, potions;\n    cin >> height >> width >> initialHP >> maxHP >> potions;\n    \n    vector<vector<int>> grid(height, vector<int>(width));\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int routeLength;\n    cin >> routeLength;\n    \n    vector<pair<int, int>> route(routeLength);\n    for (int i = 0; i < routeLength; i++) {\n        cin >> route[i].first >> route[i].second;\n    }\n    \n    SecurityAgent agent(initialHP, maxHP, potions);\n    \n    cout << (agent.canCompletePath(grid, route) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_complete_patrol(grid, initial_hp, max_hp, patrol_route):\n    hp = initial_hp\n\n    for x, y in patrol_route:\n        cell = grid[x][y]\n        \n        # Process the current cell\n        if isinstance(cell, int):\n            hp -= cell  # Trap: subtract hit points\n        elif cell == 'P':\n            hp = min(hp + 10, max_hp)  # Potion: add hit points but do not exceed max_hp\n\n        # Check if agent is dead\n        if hp <= 0:\n            return False\n\n    return True\n\n# Example usage\ngrid = [\n    [0, 'P', -10, 'P'],\n    [-5, 0, 0, -20],\n    [-15, 'P', 0, 'P']\n]\n\ninitial_hp = 20\nmax_hp = 30\npatrol_route = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3)]\n\n# Determine if the patrol can be completed\nresult = can_complete_patrol(grid, initial_hp, max_hp, patrol_route)\nprint(\"Can complete patrol:\", result)",
    "timestamp": "2025-08-13 05:50:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class CavePatrol {\n    \n    static class Point {\n        int row, col;\n        public Point(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    public static boolean canCompletePatrol(int initialHitPoints, int maxHitPoints, int[][] cave, Point[] route, int[] potionValues) {\n        int hitPoints = initialHitPoints;\n\n        for (Point step : route) {\n            int trapDamage = cave[step.row][step.col];\n            hitPoints -= trapDamage;\n            \n            if (hitPoints <= 0) {\n                return false;\n            }\n\n            if (potionValues[step.row * cave[0].length + step.col] > 0) {\n                hitPoints += potionValues[step.row * cave[0].length + step.col];\n                if (hitPoints > maxHitPoints) {\n                    hitPoints = maxHitPoints;\n                }\n            }\n        }\n\n        return hitPoints > 0;\n    }\n\n    public static void main(String[] args) {\n        int initialHitPoints = 10;\n        int maxHitPoints = 15;\n        int[][] cave = {\n            {0, -2, -3},\n            {-1, -5, -10},\n            {-2, -3, -2}\n        };\n        Point[] route = {\n            new Point(0, 0), new Point(0, 1), new Point(0, 2),\n            new Point(1, 2), new Point(2, 2)\n        };\n        int[] potions = new int[9];\n        potions[1] = 5; // Potion at (0, 1)\n\n        boolean canComplete = canCompletePatrol(initialHitPoints, maxHitPoints, cave, route, potions);\n        System.out.println(\"Can the agent complete the patrol? \" + (canComplete ? \"Yes\" : \"No\"));\n    }\n}",
    "timestamp": "2025-08-13 05:50:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX 100\n\ntypedef struct {\n    int row, col;\n} Position;\n\nint main() {\n    int grid[MAX][MAX];\n    int hitPoints, maxHitPoints, rows, cols, numPotions, numTraps, numPathPoints;\n    Position potions[MAX], traps[MAX], path[MAX];\n    \n    // Read the initial and maximum hit points\n    scanf(\"%d %d\", &hitPoints, &maxHitPoints);\n\n    // Read the dimensions of the cave grid\n    scanf(\"%d %d\", &rows, &cols);\n    \n    // Initialize the grid with zero values\n    for (int i = 0; i < rows; ++i)\n        for (int j = 0; j < cols; ++j)\n            grid[i][j] = 0;\n\n    // Read the number of potions and their positions\n    scanf(\"%d\", &numPotions);\n    for (int i = 0; i < numPotions; ++i) {\n        int r, c;\n        scanf(\"%d %d\", &r, &c);\n        grid[r][c] = 1; // mark potion\n    }\n\n    // Read the number of traps and their positions\n    scanf(\"%d\", &numTraps);\n    for (int i = 0; i < numTraps; ++i) {\n        int r, c, damage;\n        scanf(\"%d %d %d\", &r, &c, &damage);\n        grid[r][c] = -damage; // mark trap with its damage\n    }\n\n    // Read the patrol path\n    scanf(\"%d\", &numPathPoints);\n    for (int i = 0; i < numPathPoints; ++i) {\n        scanf(\"%d %d\", &path[i].row, &path[i].col);\n    }\n\n    // Simulate the patrol\n    for (int i = 0; i < numPathPoints; ++i) {\n        int r = path[i].row;\n        int c = path[i].col;\n\n        // Check for traps\n        if (grid[r][c] < 0) {\n            hitPoints += grid[r][c];  // decrease health\n        }\n\n        // Check for potions\n        if (grid[r][c] == 1) {\n            hitPoints = maxHitPoints; // restore to full health\n        }\n\n        // Check if the agent is dead\n        if (hitPoints <= 0) {\n            printf(\"Agent died\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Agent survived\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 05:50:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_complete_patrol(grid, start_hp, max_hp, route, potions):\n    hp = start_hp\n    potions_used = 0\n    current_pos = (0, 0)\n\n    for step in route:\n        x, y = current_pos\n        \n        if step == 'N':\n            x -= 1\n        elif step == 'S':\n            x += 1\n        elif step == 'E':\n            y += 1\n        elif step == 'W':\n            y -= 1\n\n        # Check grid bounds\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return False\n\n        # Damage from trap\n        hp -= grid[x][y]\n\n        # Use potion if needed\n        while hp <= 0 and potions_used < len(potions):\n            hp = min(max_hp, hp + potions[potions_used])\n            potions_used += 1\n\n        # Check if agent dies\n        if hp <= 0:\n            return False\n\n        current_pos = (x, y)\n\n    return True",
    "timestamp": "2025-08-13 05:50:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_complete_patrol(grid, initial_hp, max_hp, route):\n    hp = initial_hp\n    x, y = route[0]  # Starting position\n    for step in route[1:]:\n        dx, dy = step\n        x += dx\n        y += dy\n        cell = grid[y][x]  # Assuming grid is [row][col] or [y][x]\n        if cell < 0:  # It's a trap\n            hp += cell\n            if hp <= 0:\n                return False\n        elif cell > 0:  # It's a potion\n            hp = min(hp + cell, max_hp)\n    return True",
    "timestamp": "2025-08-13 05:50:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canCompletePatrol(const vector<vector<int>>& cave, int initHp, int maxHp, const vector<pair<int, int>>& route) {\n    int currentHp = initHp;\n    \n    for (const auto& position : route) {\n        int x = position.first;\n        int y = position.second;\n\n        if (cave[x][y] < 0) {\n            // Trap cell, reduce HP\n            currentHp += cave[x][y];\n            if (currentHp <= 0) return false; // Agent dies\n        } else if (cave[x][y] > 0) {\n            // Potion cell, increase HP\n            currentHp += cave[x][y];\n            if (currentHp > maxHp) currentHp = maxHp; // Cap HP to maxHp\n        }\n    }\n    \n    return true; // Completed route successfully\n}\n\nint main() {\n    // Sample cave grid:\n    vector<vector<int>> cave = {\n        {0, -2, 5},\n        {-3, 0, -1},\n        {4, 0, -5}\n    };\n\n    // Define initial HP, max HP, and patrol route:\n    int initialHp = 10;\n    int maxHp = 15;\n    vector<pair<int, int>> route = {{0, 0}, {0, 1}, {0, 2}, {1, 2}, {1, 1}, {1, 0}};\n\n    if (canCompletePatrol(cave, initialHp, maxHp, route)) {\n        cout << \"Agent can complete the patrol without dying.\" << endl;\n    } else {\n        cout << \"Agent cannot complete the patrol.\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:33"
  }
]