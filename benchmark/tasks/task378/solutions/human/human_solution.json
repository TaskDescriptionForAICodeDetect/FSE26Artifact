[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\ntypedef vector<int> vi;\n\nconst string dir = \"URDL\";\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int Hini, Hmax;\n  while(cin >> Hini >> Hmax, Hini){\n    int h,w;\n    cin >> h >> w;\n    vector<string> g(h);\n    rep(i,h)cin >> g[i];\n\n    int cost[26] = {}, t;\n    cin >> t;\n    rep(i,t){\n      char c; int d;\n      cin >> c >> d;\n      cost[c-'A'] = d;\n    }\n\n    vi trap;\n    int s, x=0, y=0;\n    cin >> s;\n    rep(i,s){\n      char c; int n;\n      cin >> c >> n;\n      int d = dir.find(c);\n      rep(k,n){\n\tx += dx[d]; y += dy[d];\n\tint tmp = cost[ g[y][x]-'A' ];\n\tif(tmp)trap.push_back(tmp);\n      }\n    }\n\n    int p;\n    cin >> p;\n    vi potion(p);\n    rep(i,p)cin >> potion[i];\n\n    vector<vi> dp(trap.size()+1, vi(1<<p,0));\n    dp[0][0] = Hini;\n\n    rep(i,trap.size()){\n      rep(bit,1<<p){\n\tint cur = dp[i][bit];\n\tif(cur==0)continue;\n\n\tchmax(dp[i+1][bit], cur-trap[i]);\n\trep(j,p){\n\t  if( (bit>>j)&1 )continue;\n\t  int nxt = min(cur+potion[j], Hmax);\n\t  chmax(dp[i+1][bit | (1<<j)], nxt - trap[i]);\n\t}\n      }\n    }\n    \n    bool f = false;\n    rep(bit,1<<p)f |= (dp[trap.size()][bit]>0);\n    cout << (f?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int ALP = 26;\n\nconst int N = 1010;\nint dp[N][1<<12];\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int hp_i, hp_m;\n    while(cin >>hp_i >>hp_m, hp_i){\n        int h,w;\n        cin >>h >>w;\n        vector<string> s(h);\n        rep(i,h) cin >>s[i];\n\n        int T;\n        cin >>T;\n        vector<int> trap(ALP,0);\n        rep(i,T){\n            char c;\n            int d;\n            cin >>c >>d;\n            trap[c-'A'] = d;\n        }\n\n        int S;\n        cin >>S;\n        string route = \"\";\n        int px = 0, py = 0;\n        rep(i,S){\n            char c;\n            int d;\n            cin >>c >>d;\n            while(d--){\n                if(c=='U') --py;\n                if(c=='D') ++py;\n                if(c=='L') --px;\n                if(c=='R') ++px;\n                route += s[py][px];\n            }\n        }\n\n        int P;\n        cin >>P;\n        vector<int> p(P);\n        rep(i,P) cin >>p[i];\n\n        int SZ = route.size();\n        memset(dp,0,sizeof(dp));\n        dp[0][0] = hp_i;\n        rep(i,SZ)rep(mask,1<<P)if(dp[i][mask]>0){\n            // move\n            dp[i+1][mask] = max(dp[i+1][mask], dp[i][mask]-trap[route[i]-'A']);\n\n            // use potion\n            rep(j,P)if(!(mask>>j&1)){\n                int nmask = mask | (1<<j);\n                dp[i][nmask] = max(dp[i][nmask], min(hp_m, dp[i][mask]+p[j]) );\n            }\n        }\n\n        string ans = \"NO\";\n        if(dp[SZ][(1<<P)-1]>0) ans = \"YES\";\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n// テ・ツ?・テ・ツ環?\nint HP, w, h;\n// a[y][x] := (x,y)テ」ツ?ョテ」ツつーテ」ツδェテ」ツδε」ツδ嘉」ツ?ョテァツ環カテヲツ??テヲツ鳴?・ツュツ?A' - 'Z')\nvector<string> a;\n// D[c] := テヲツ鳴?・ツュツ?c テ」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ凝・ツ渉療」ツ?妥」ツつ凝」ツδ?」ツδ。テ」ツδシテ」ツつクテヲツ閉ー\nint D[256] = {0};\n\n// f[c] := テヲツ鳴?・ツュツ?c ('U','D','L','R') テ」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ凝・ツ青妥」ツ??0..3 テ」ツつ津ィツソツ氾」ツ??\nint f[256] = {0};\n// 4ティツソツ妥・ツつ?\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// dp[k][bits] := k テ・ツ崢榲ァツ崢ョテ」ツ?ョテァツァツサテ・ツ仰陛」ツ?ァテァツ渉セテ・ツ慊ィテ」ツ?ョテ、ツスツソテ」ツ?」テ」ツ?淌」ツδ敕」ツδシテ」ツつキテ」ツδァテ」ツδウテ」ツ?ョテァツ環カテヲツ??bits テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ョテヲツ慊?・ツ、ツァテ」ツ?ョテヲツョツ凝」ツつ?HP\nint dp[1001][1<<12];\n\nint main(){\n\tf['U'] = 0; f['D'] = 1; f['L'] = 2; f['R'] = 3;\n\tint hp;\n\t\n\twhile( cin >> hp >> HP, hp || HP ){\n\t\tcin >> h >> w;\n\t\ta = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> a[y];\n\t\t}\n\t\tint T, S, P;\n\t\tcin >> T;\n\t\tfor(int i=0 ; i < T ; i++ ){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tD[c] = d;\n\t\t}\n\t\tcin >> S;\n\t\t// path[k] := k テ・ツ崢榲ァツ崢ョテ」ツ?ョテァツァツサテ・ツ仰陛」ツ?凖」ツつ凝ヲツ鳴ケテ・ツ青?\n\t\tvector<int> path;\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tchar dir;\n\t\t\tint n;\n\t\t\tcin >> dir >> n;\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tpath.push_back( f[dir] );\n\t\t\t}\n\t\t}\n\t\tcin >> P;\n\t\tvector<int> p(P);\n\t\tfor(int i=0 ; i < P ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t// テ・ツ青?」ツつケテ」ツδ?」ツδε」ツδ療」ツ?ァテ、ツスツ陛」ツδ?」ツδ。テ」ツδシテ」ツつクテ・ツ渉療」ツ?妥」ツつ凝」ツ?凝ィツィツ暗ァツョツ?\n\t\tvector<int> damege;\n\t\tint x=0, y=0;\n\t\tdamege.push_back(0);\n\t\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\t\tx += dx[path[i]];\n\t\t\ty += dy[path[i]];\n\t\t\tdamege.push_back( D[a[y][x]] );\n\t\t}\n\t\t\n\t\t// dp テ」ツ?ョテ・ツ按敕ヲツ慊淌・ツ個?\n\t\tint N = path.size() + 1;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tfor(int j=0 ; j < (1<<P) ; j++ ){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = hp;\n\t\t\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tfor(int j = 0 ; j < (1<<P) ; j++ ){\n\t\t\t\tif( i > 0 ){ // i テ・ツ崢榲ァツ崢ョテ」ツ?ョテァツァツサテ・ツ仰陛」ツ?ァテ・ツ渉療」ツ?妥」ツ?淌」ツδ?」ツδ。テ」ツδシテ」ツつクテ」ツつ津ィツィツ暗ァツョツ?\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j] - damege[i]);\n\t\t\t\t}\n\t\t\t\t// HP テ」ツ??0 テ、ツサツ・テ、ツクツ凝」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ッテァツオツづ、ツコツ?\n\t\t\t\tif( dp[i][j] <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tfor(int k=0 ; k < P ; k++ ){\n\t\t\t\t\tif( j & (1<<k) ) continue;\n\t\t\t\t\t\n\t\t\t\t\t// p[k] テ」ツ?ョテ」ツδ敕」ツδシテ」ツつキテ」ツδァテ」ツδウテ」ツつ津、ツスツソテ」ツ??\n\t\t\t\t\tint next = j | (1<<k);\n\t\t\t\t\tdp[i][next] = min(HP, max(dp[i][next], dp[i][j] + p[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0 ; i < (1<<P) ; i++ ){\n\t\t\tans = max(ans, dp[N-1][i]);\n\t\t}\n\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nchar str[120][120],ch[10];\nint  sa[30], po[1010];\nint  hpi, hpm;\nint  r, c, num, t, s, pnum;\nstruct node\n{\n     int step;\n     char di[10];\n}p[1010];\n\nbool  GetAns()\n{\n      int x = 0, y = 0;\n      for(int i = 0; i < s; i ++)\n      {\n             int sum = 0;\n             if(p[i].di[0] == 'U')\n             {\n                 for(int j = x-1; j >= x - p[i].step ;j --)\n                 {\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x -= p[i].step;\n             }\n             if(p[i].di[0] == 'D')\n             {\n                 for(int j = x+1; j <= x + p[i].step ;j ++)\n                 {\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x += p[i].step;\n             }\n             if(p[i].di[0] == 'L')\n             {\n                 for(int j = y-1; j >= y - p[i].step ;j --)\n                 {\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 }\n                  y -= p[i].step;\n             }\n             if(p[i].di[0] == 'R')\n             {\n                 for(int j = y+1; j <= y + p[i].step ;j ++)\n                 {\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 }\n                  y += p[i].step;\n             }\n             \n             bool f = false;\n             if(hpi > sum)\n             {\n                   hpi -= sum;\n                   f = true;\n                   continue;\n             }\n             for(int j = 0; j < pnum; j ++)\n             {\n                    int tmp = min(hpm, hpi + po[j]);\n                    if(tmp > sum)\n                    {\n                         hpi = tmp - sum;\n                         f = true;\n                         po[j] = 0;\n                         break;\n                    }\n             }\n             if(!f) return false;\n\n      }\n      if(hpi <= 0) return false;\n      return true;\n}\nint  main()\n{\n     while(~scanf(\"%d %d\", &hpi, &hpm) && hpi+hpm)\n     {\n           scanf(\"%d %d\", &r, &c);\n           for(int i = 0; i < r; i++)\n           {\n                   scanf(\"%s\", str[i]);\n           }\n           scanf(\"%d\", &t);\n           for(int i = 0; i < t; i ++)\n           {\n                   scanf(\"%s %d\", ch, &num);\n                   int tmp = ch[0] - 'A';\n                   sa[tmp] = num;\n           }\n           scanf(\"%d\", &s);\n           for(int i = 0; i < s; i ++)\n           {\n                   scanf(\"%s %d\", p[i].di, &p[i].step);\n           }\n           scanf(\"%d\", &pnum);\n           for(int i = 0; i < pnum; i ++)\n           {\n                  scanf(\"%d\", &po[i]);\n           }\n           sort(po, po+pnum);\n           bool flag= GetAns();\n           if(flag)\n                   printf(\"YES\\n\");\n           else\n                   printf(\"NO\\n\");\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//32\n#include<iostream>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n\nstruct S{\n  int t,hp,u;\n};\n\nint main(){\n  for(int hi,hm;cin>>hi>>hm,hi|hm;){\n    int r,c;\n    cin>>r>>c;\n    char g[100][100];\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int t;\n    cin>>t;\n    int d[128];\n    while(t--){\n      char a;\n      cin>>a;\n      cin>>d[a];\n    }\n    int s;\n    cin>>s;\n    vector<int> v;\n    int x=0,y=0;\n    while(s--){\n      char u;\n      int n;\n      cin>>u>>n;\n      while(n--){\n\ty+=(u=='D')-(u=='U');\n\tx+=(u=='R')-(u=='L');\n\tv.push_back(d[g[y][x]]);\n      }\n    }\n    int p[12];\n    int np;\n    cin>>np;\n    for(int i=0;i<np;i++){\n      cin>>p[i];\n    }\n    static int dp[1001][1<<12];\n    fill(dp[0],dp[1001],0);\n    deque<S> deq;\n    S is={0,hi,0};\n    deq.push_back(is);\n    while(!deq.empty()){\n      S c=deq.front();\n      if(c.t==v.size())break;\n      deq.pop_front();\n      if(c.hp<=dp[c.t][c.u])continue;\n      dp[c.t][c.u]=c.hp;\n      if(v[c.t]<c.hp){\n\tc.hp-=v[c.t];\n\tc.t++;\n\tdeq.push_back(c);\n      }else{\n\tfor(int i=0;i<np;i++){\n\t  if(!(c.u>>i&1)){\n\t    S n=c;\n\t    n.hp=min(hm,n.hp+p[i]);\n\t    n.u|=1<<i;\n\t    deq.push_front(n);\n\t  }\n\t}\n      }\n    }\n    cout<<(deq.empty()?\"NO\":\"YES\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n\nint dp[MAX][1<<MAX_P];\n\nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n        \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n        \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n\n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n        \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] <= 0) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < P; k++) {\n                    if (j >> k & 1) continue;\n                    dp[i][j|k] = max(dp[i][j|k], min(dp[i][j] + p[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nint hp,Hp,n,m,k,s,dp[1010][4100],p,w[15];\nchar mp[105][105],cost[27],move[1005][2];\nint main()\n{\n    while(scanf(\"%d%d\",&hp,&Hp)==2)\n    {\n        if(hp==0&&Hp==0) break;\n        scanf(\"%d%d\",&n,&m);getchar();\n        for(int i=0;i<n;i++) gets(mp[i]);\n        scanf(\"%d\",&k);\n        for(int i=0;i<k;i++)\n        {\n            int d;\n            char op[5];\n            scanf(\"%s%d\",op,&d);\n            cost[op[0]-'A']=d+'0';\n        }\n        scanf(\"%d\",&s);\n        for(int i=0;i<s;i++)\n        {\n            int d;\n            char op[5];\n            scanf(\"%s%d\",op,&d);\n            move[i][0]=op[0];\n            move[i][1]=d+'0';\n        }\n        scanf(\"%d\",&p);\n        for(int i=0;i<p;i++) scanf(\"%d\",&w[i]);\n        dp[0][0]=hp;\n        for(int i=1;i<=2<<(p-1);i++)\n        {\n            for(int j=0;j<p;j++)\n            {\n                if((i&1<<j)!=0)\n                {\n                    int t=i&(~(1<<j));\n                    dp[0][i]=dp[0][t]+w[j];\n                    break;\n                }\n            }\n            dp[0][i]=min(dp[0][i],Hp);\n        }\n        int in=0,jn=0,n=0;\n        for(int i=0;i<s;i++)\n        {\n            int k;\n            if(move[i][0]=='U') k=0;\n            if(move[i][0]=='D') k=1;\n            if(move[i][0]=='L') k=2;\n            if(move[i][0]=='R') k=3;\n            for(int j=1;j<=move[i][1]-'0';j++)\n            {\n                in+=dir[k][0];\n                jn+=dir[k][1];n++;\n                int ct=cost[mp[in][jn]-'A']-'0';\n                dp[n][0]=dp[n-1][0]-ct;\n                for(int x=1;x<=2<<(p-1);x++)\n                {\n                    for(int y=0;y<p;y++)\n                    {\n                        if((x&1<<y)!=0)\n                        {\n                            int t=x&(~(1<<y));\n                            dp[n][x]=dp[n][t]+w[y]-ct;\n                            break;\n                        }\n                    }\n                    dp[n][x]=min(dp[n][x],Hp);\n                }\n            }\n        }\n        bool f=false;\n        for(int i=0;i<=2<<(p-1);i++) if(dp[n][i]>0) {f=true;break;}\n        if(f) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[1<<12];\npair<int,int> points[1010];\nint dp[1010][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)if(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[i][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nchar str[1010][1010],ch[1010];\nint  sa[1010], po[1010];\nint  hpi, hpm;\nint  r, c, num, t, s, pnum;\nstruct node\n{\n     int step;\n     char di[1010];\n}p[1010];\n\nbool  GetAns()\n{\n      int x = 0, y = 0;\n      for(int i = 0; i < s; i ++)\n      {\n             int sum = 0;\n             if(p[i].di[0] == 'U')\n             {\n                // for(int j = x-1; j >= x - p[i].step ;j --)\n                 //{\n                        int j = x - p[i].step;\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 //}\n                  x -= p[i].step;\n             }\n             if(p[i].di[0] == 'D')\n             {\n                // for(int j = x+1; j <= x + p[i].step ;j ++)\n                 //{\n                        int j = x + p[i].step;\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 //}\n                  x += p[i].step;\n             }\n             if(p[i].di[0] == 'L')\n             {\n                 //for(int j = y-1; j >= y - p[i].step ;j --)\n                 //{\n                        int j = y - p[i].step;\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                //}\n                  y -= p[i].step;\n             }\n             if(p[i].di[0] == 'R')\n             {\n                 //for(int j = y+1; j <= y + p[i].step ;j ++)\n                 //{\n                        int j = y + p[i].step;\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 //}\n                  y += p[i].step;\n             }\n\n             bool f = false;\n             if(hpi > sum)\n             {\n                   hpi -= sum;\n                   f = true;\n                   continue;\n             }\n             for(int j = 0; j < pnum; j ++)\n             {\n                    int tmp = min(hpm, hpi + po[j]);\n                    if(tmp > sum)\n                    {\n                         hpi = tmp - sum;\n                         f = true;\n                         po[j] = 0;\n                         break;\n                    }\n             }\n             if(!f) return false;\n\n      }\n      if(hpi <= 0) return false;\n      return true;\n}\nint  main()\n{\n     while(~scanf(\"%d %d\", &hpi, &hpm) && hpi+hpm)\n     {\n           scanf(\"%d %d\", &r, &c);\n           for(int i = 0; i < r; i++)\n           {\n                   scanf(\"%s\", str[i]);\n           }\n           scanf(\"%d\", &t);\n           for(int i = 0; i < t; i ++)\n           {\n                   scanf(\"%s %d\", ch, &num);\n                   int tmp = ch[0] - 'A';\n                   sa[tmp] = num;\n           }\n           scanf(\"%d\", &s);\n           for(int i = 0; i < s; i ++)\n           {\n                   scanf(\"%s %d\", p[i].di, &p[i].step);\n           }\n           scanf(\"%d\", &pnum);\n           for(int i = 0; i < pnum; i ++)\n           {\n                  scanf(\"%d\", &po[i]);\n           }\n           sort(po, po+pnum);\n           bool flag= GetAns();\n           if(flag)\n                   printf(\"YES\\n\");\n           else\n                   printf(\"NO\\n\");\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint HPini, HPmax;\nint width, height;\nchar field[110][110];\nint trap[300];\nint mapto[300];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint dir[1010];\nint potion[20];\nint dp[1 << 12];\n\nint main() {\n    mapto[(int)'R'] = 0;\n    mapto[(int)'D'] = 1;\n    mapto[(int)'L'] = 2;\n    mapto[(int)'U'] = 3;\n    while (scanf(\"%d %d\", &HPini, &HPmax), HPini|HPmax) {\n        scanf(\"%d %d\", &height, &width);\n        REP(y, height) {\n            REP(x, width) {\n                scanf(\" %c \", &field[y][x]);\n            }\n        }\n        int t;\n        scanf(\"%d\", &t);\n        REP(i, t) {\n            char c;\n            int d;\n            scanf(\" %c %d \", &c, &d);\n            trap[(int)c] = d;\n        }\n        int s;\n        scanf(\"%d\", &s);\n        int m = 0;\n        REP(i, s) {\n            char d;\n            int n;\n            scanf(\" %c %d \", &d, &n);\n            REP(i, n) {\n                dir[m++] = mapto[(int)d];\n            }\n        }\n        int p;\n        scanf(\"%d\", &p);\n        REP(i, p) {\n            scanf(\"%d\", &potion[i]);\n        }\n        MEMSET(dp, 0xfe);\n        int x = 0;\n        int y = 0;\n        dp[0] = HPini;\n        REP(iter1, m) {\n            REP(i, p) {\n                REP(P, 1 << p) {\n                    if ((P >> i) & 1) { continue; }\n                    dp[P | (1 << i)] = min(HPmax, max(dp[P | (1 << i)], dp[P] + potion[i]));\n                }\n            }\n            x += dx[dir[iter1]];\n            y += dy[dir[iter1]];\n            REP(P, 1 << p) {\n                dp[P] -= trap[(int)field[y][x]];\n                if (dp[P] <= 0) { dp[P] = -1000000000; }\n            }\n        }\n        if (dp[(1 << p) - 1] > 0) {\n            puts(\"YES\");\n        } else {\n            puts(\"NO\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <fstream>\n#include <algorithm>\nusing namespace std;\n\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nint dp[1005][1<<12];\n\nint main()\n{\n\t//ifstream cin(\"C.txt\");\n\tint Hmi,Hma,R,C;\n\twhile(cin >> Hmi >> Hma, (Hmi||Hma))\n\t{\n\t\tint dmg[100]={0};\n\t\tint heal[100]={0};\n\n\t\tstring f[200];\n\t\tcin >> R >> C;\n\n\t\tfor(int i=0; i<R; i++)\n\t\t{\n\t\t\tcin >> f[i];\n\t\t}\n\n\t\tint L;\n\t\tcin >> L;\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tstring c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdmg[c[0]-'A']=d;\n\t\t}\n\n\t\tint dir[1005];\n\n\t\tint M,X=0;\n\t\tcin >> M;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint t,n;\n\t\t\tstring d;\n\t\t\tcin >> d >> n;\n\t\t\tif(d[0]=='U')\n\t\t\t{\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tif(d[0]=='D')\n\t\t\t{\n\t\t\t\tt=1;\n\t\t\t}\n\t\t\tif(d[0]=='L')\n\t\t\t{\n\t\t\t\tt=2;\n\t\t\t}\n\t\t\tif(d[0]=='R')\n\t\t\t{\n\t\t\t\tt=3;\n\t\t\t}\n\n\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\tdir[X++]=t;\n\t\t}\n\n\t\tint H;\n\t\tcin >> H;\n\t\tfor(int i=0; i<H; i++)\n\t\t\tcin >> heal[i];\n\n\t\tmemset(dp,0,sizeof(dp));\n\t\t\n\t\tdp[0][0]=Hmi;\n\n\t\tint x=0, y=0;\n\t\tfor(int i=0; i<X; i++)\n\t\t{\n\t\t\tx+=dx[dir[i]], y+=dy[dir[i]];\n\t\t\tfor(int j=0; j<(1<<H); j++)\n\t\t\t{\n\t\t\t\tfor(int k=0; k<H; k++)\n\t\t\t\t{\n\t\t\t\t\tif(j&(1<<k)) continue;\n\t\t\t\t\tif(dp[i][j]==0) continue;\n\t\t\t\t\t\n\t\t\t\t\tdp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], min(Hma, dp[i][j]+heal[k]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[i+1][j]=max(dp[i+1][j], dp[i][j]-dmg[f[y][x]-'A']);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ok=false;\n\t\tfor(int i=0; i<(1<<H); i++)\n\t\t{\n\t\t\tif(dp[X][i]>0) ok=true;\n\t\t}\n\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <set>\n#define MP(x,y) make_pair(x,y)\n#define MAXN 20005\n\nusing namespace std;\n\nint HPinit,HPmax,n,m;\nint potions[30],num,used[30];\nchar g[110][110];\nmap<char,int>mp;\nmap<char,pair<int,int> >Dir;\n\nstruct Node{\n    char dir[3];\n    int step;\n}a[1100];\nint op;\n\nvoid init()\n{\n    memset(used,0,sizeof(used));\n    mp.clear();\n}\n\nint sub(int x)\n{\n    int i,j,ans=0,MIN=100000000;\n    for(i=0;i<(1<<num);i++)\n    {\n        int sum=0,res=0;\n        for(j=0;j<num;j++)\n        {\n            if(used[j])\n                continue;\n            int temp=1<<j;\n            if(i&temp)\n            {\n                sum+=potions[j];\n                res|=temp;\n            }\n        }\n        if(sum-x>0&&sum<MIN)\n        {\n            MIN=sum;\n            ans=res;\n        }\n    }\n    for(i=0;i<num;i++)\n    {\n        int temp=1<<i;\n        if(ans&temp)\n            used[i]++;\n    }\n    if(MIN==100000000)\n        return -100000000;\n    else\n        return min(MIN,HPmax);\n}\n\nbool solve()\n{\n    int x=0,y=0;\n    int Hp=HPinit,i;\n    for(i=0;i<op;i++)\n    {\n        while(a[i].step--)\n        {\n            x=x+Dir[a[i].dir[0]].first;\n            y=y+Dir[a[i].dir[0]].second;\n            int cost=mp[g[x][y]];\n            if(cost>=HPmax)\n                return false;\n            if(cost<Hp)\n                Hp-=cost;\n            else\n                Hp=Hp-cost+sub(cost-Hp);\n            if(Hp<=0)\n                return false;\n          /*  printf(\"Hp=%d,cost=%d\\n\",Hp,cost);\n            printf(\"x=%d,y=%d\\n\",x,y);*/\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    int i,j;\n    Dir['U']=MP(-1,0);\n    Dir['D']=MP(1,0);\n    Dir['R']=MP(0,1);\n    Dir['L']=MP(0,-1);\n    while(scanf(\"%d %d\",&HPinit,&HPmax),HPinit||HPmax)\n    {\n        init();\n        scanf(\"%d %d\",&n,&m);\n        for(i=0;i<n;i++)\n            scanf(\"%s\",g[i]);\n        int Q;\n        scanf(\"%d\",&Q);\n        while(Q--)\n        {\n            char s[3];\n            int x;\n            scanf(\"%s %d\",s,&x);\n            mp[s[0]]=x;\n        }\n        scanf(\"%d\",&op);\n        for(i=0;i<op;i++)\n            scanf(\"%s %d\",a[i].dir,&a[i].step);\n        scanf(\"%d\",&num);\n        for(i=0;i<num;i++)\n            scanf(\"%d\",&potions[i]);\n        bool flag=solve();\n        if(flag)\n            puts(\"YES\");\n        else\n            puts(\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 13][1010];\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nbool solve() {\n\tint SS = step.size();\n\t\n\tvector< int > damage(SS);\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tdamage[i] = trap[grid[y][x]];\n\t}\n\t\n\tmemset(max_hp, -1, sizeof(max_hp));\n\t\n\tmax_hp[0][0] = HPinit;\n\t\n\tfor_(U,0,1<<P) for_(i,0,SS) {\n\t\tif (max_hp[U][i] == -1) continue;\n\t\t\n\t\tmaxUpdate(max_hp[U][i + 1], max_hp[U][i] - damage[i]);\n\t\t\n\t\tfor_(j,0,P) {\n\t\t\tif (U >> j & 1) continue;\n\t\t\tmaxUpdate(max_hp[U | 1 << j][i], min(HPmax, max_hp[U][i] + p[j]));\n\t\t}\n\t}\n\t\n\tbool res = false;\n\tfor_(U,0,1<<P) res |= (max_hp[U][SS] > 0);\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> PII;\n#define MP make_pair;\n\nint hp, hp_max;\nint R, C;\nchar maze[101][101];\nint T;\nint dat[101][101];\nint S;\nPII path[1001];\nint P;\nint portion[16];\nint dp[1<<12][1010];\n\nint main(){\n  while(cin>>hp>>hp_max, hp){\n\tcin >> R >> C;\n\tfor(int y=0;y<R;++y)\n\t  for(int x=0;x<C;++x)\n\t\tcin >> maze[y][x];\n\tcin >> T;\n\tfor(int t=0;t<T;++t){\n\t  char c; int d; cin >> c >> d;\n\t  for(int y=0;y<R;++y)\n\t\tfor(int x=0;x<C;++x)\n\t\t  if(maze[y][x] == c)\n\t\t\tdat[y][x] = d;\n\t}\n\tcin >> S;\n\tint N = 1;\n\tpath[0].first = 0;\n\tpath[0].second = 0;\n\tfor(int i=0;i<S;++i){\n\t  char c; int x;\n\t  cin >> c >> x;\n\t  switch(c){\n\t  case 'U':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].first--;\n\t\t}\n\t\tbreak;\n\t  case 'D':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].first++;\n\t\t}\n\t\tbreak;\n\t  case 'L':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].second--;\n\t\t}\n\t\tbreak;\n\t  case 'R':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].second++;\n\t\t}\n\t\tbreak;\n\t  }\n\t}\n\tcin >> P;\n\tfor(int i=0;i<P;++i) cin >> portion[i];\n\n\tfill((int*)dp, (int*)dp+(1<<12)*1010, 0);\n\tdp[0][0] = hp;\n\tfor(int i=0;i<N;++i){\n\t  int y = path[i].first, x = path[i].second;\n\t  for(int b=0;b<1<<P;++b){\n\t\tif(!dp[b][i]) continue;\n\t\tif(dp[b][i] > dat[y][x])\n\t\t  dp[b][i+1] = max(dp[b][i+1], dp[b][i] - dat[y][x]);\n\t\telse\n\t\t  for(int j=0;j<P;++j)\n\t\t\tif((b>>j&1) == 0)\n\t\t\t  dp[b|(1<<j)][i] = max(dp[b|(1<<j)][i], dp[b][i] + portion[j]);\n\t  }\n\t}\n\n\tbool ans = false;\n\tfor(int b=0;b<1<<P;++b)\n\t  if(dp[b][N]) ans = true;\n\tcout << (ans? \"YES\": \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hpi,hpm;\nint r,c;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint fie[101][101];\nint t;\nint td[31];\nint s;\nint move[1001];\nint p;\nint pr[20];\nint dp[1005][1<<13];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&hpi,&hpm);\n\t\tif(hpi+hpm==0)break;\n\t\tscanf(\"%d%d\",&r,&c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfie[i][j]=str[j]-'A';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%*c\",&t);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tchar type;\n\t\t\tint dam;\n\t\t\tscanf(\"%c%d%*c\",&type,&dam);\n\t\t\ttd[type-'A']=dam;\n\t\t}\n\t\tscanf(\"%d%c\",&s);\n\t\tint all=0;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tchar d;\n\t\t\tint dir,a;\n\t\t\tscanf(\"%c%d%*c\",&d,&a);\n\t\t\tif(d=='U')dir=3;\n\t\t\tif(d=='D')dir=1;\n\t\t\tif(d=='R')dir=0;\n\t\t\tif(d=='L')dir=2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tmove[all++]=dir;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++){\n\t\t\tscanf(\"%d\",&pr[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=hpi;\n\t\tint x=0,y=0;\n\t\tint dall=0;\n\t\tfor(int i=0;i<all;i++){\n\t\t\tx+=dx[move[i]];\n\t\t\ty+=dy[move[i]];\n\t\t\tint dam=td[fie[y][x]];\n\t\t\tdall+=dam;\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tif(dp[i][j]>0){\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tfor(int k=0;k<p;k++){\n\t\t\t\t\t\tif(j>>k & 1)continue;\n\t\t\t\t\t\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],min(hpm,dp[i][j]+pr[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tdp[i+1][j]-=dam;\n\t\t\t}\n\t\t}\n\t\tbool flag=false;\n\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\tif(dp[all][j]>0)flag=true;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint HP, HPm;\nint R, C, T, S, P;\nvector<string> field;\nvector<char> trap;\nmap<char,int> damage;\nvector<pair<char,int> > move;\nvi potion;\n\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\nstring dir = \"UDLR\";\n\nint main()\n{\n    while(cin >> HP >> HPm, HP || HPm){\n\tcin >> R >> C;\n\tfield.resize(R);\n\trep(i,R) cin >> field[i];\n\tcin >> T;\n\ttrap.clear();\n\trep(i,T){\n\t    char a;\n\t    int t;\n\t    cin >> a >> t;\n\t    trap.pb(a);\n\t    damage[a] = t;\n\t}\n\tsort(all(trap));\n\tcin >> S;\n\tmove.clear();\n\trep(i,S){\n\t    char a;\n\t    int t;\n\t    cin >> a >> t;\n\t    move.pb(mp(a,t));\n\t}\n\tcin >> P;\n\tpotion.resize(P);\n\trep(i,P) cin >> potion[i];\n\tsort(all(potion));\n\tint x = 0, y = 0;\n\tint cur = 0;\n\trep(i,S){\n\t    int d = dir.find(move[i].first);\n\t    rep(j,move[i].second){\n\t\tx += dx[d]; y += dy[d];\n\t\tchar c = field[y][x];\n\t\tvector<char>::iterator itr = lower_bound(all(trap),c);\n\t\tHP -= damage[*itr];\n\t\twhile(cur < P && HP < 0){\n\t\t    HP += potion[cur++];\n\t\t}\n\t\tif(HP <= 0) break;\n\t    }\n\t    if(HP <= 0) break;\n\t}\n\tcout << (HP>0? \"YES\\n\": \"NO\\n\");\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<map>\nusing namespace std;\nconst int M=110;\nconst int inf = 9999999;\nchar a[M][M];\nint d[64];\nint dx[]= {-1,1,0,0};\nint dy[]= {0,0,-1,1};\nint yao[64];\nint kou[1100];\nstruct G\n{\n    char s[4];\n    int step;\n} g[1100];\nbool flag;\nint lk,T,snum,hpmax;\nint sum[1<<12];\nint dp[1005][1<<12];\nvoid dfs(int num,int has,int now)\n{\n    int i,j;//cout<<num<< \" \"<<now<<endl;\n    if(flag)return;\n    if(num==lk)\n    {\n        flag=true;\n        return;\n    }\n    if(kou[num]==0){dfs(num+1,has,now);}\n    else\n    {\n        if(flag)return;\n        if(now-kou[num]>0){dfs(num+1,has,now-kou[num]);}\n        else\n        {\n            if(flag)return;\n            for(i=0;i<(1<<snum);i++)\n            {\n                if(i&(has))continue;\n                int tmp = min(hpmax,now+sum[i]);\n                if(tmp-kou[num]<=0)continue;\n                dfs(num+1,i|has,tmp-kou[num]);\n                if(flag)return;\n            }\n        }\n\n    }\n\n\n}\nint main()\n{\n    int hp,n,m,dis,S;\n    char ts[4];\n    int x,y;\n    while(~scanf(\"%d%d\",&hp,&hpmax),hp+hpmax)\n    {\n        x=y=0;\n        scanf(\"%d%d\",&n,&m);\n        for(int i=0; i<n; i++)\n        {\n            scanf(\"%s\",a[i]);\n        }\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            scanf(\"%s%d\",ts,&dis);\n            d[ts[0]-'A']=dis;\n        }\n        scanf(\"%d\",&S);\n        for(int i=0; i<S; i++)\n        {\n            scanf(\"%s%d\",g[i].s,&g[i].step);\n        }\n        int sum1=0,sum2=0,mark=0;\n        scanf(\"%d\",&T);\n\n        snum = T;\n        for(int i=0; i<T; i++)\n        {\n            scanf(\"%d\",&yao[i]);\n            sum1 += yao[i];\n        }\n        lk=0;\n\n        for(int i=0; i<S; i++)\n        {\n            int id;\n            if(g[i].s[0]=='U')\n            {\n                id=0;\n            }\n            else if(g[i].s[0]=='D')\n            {\n                id=1;\n            }\n            else if(g[i].s[0]=='L')\n            {\n                id=2;\n            }\n            else if(g[i].s[0]=='R')\n            {\n                id=3;\n            }\n            for(int j=0; j<g[i].step; j++)\n            {\n                x+=dx[id];\n                y+=dy[id];\n                dis=d[a[x][y]-'A'];\n                kou[lk++]=dis;\n                if(dis>hpmax)mark=1;\n                sum2 += dis;\n            }\n        }\n        if(mark||(sum1+hp<=sum2))\n        {\n            puts(\"NO\");\n            continue;\n        }\n//        for(int i=0; i<lk; i++)\n//        {\n//            printf(\"謇」陦?鬘コ蠎擾シ?d\\n\",kou[i]);\n//        }\n        for(int i=0;i<(1<<T);i++)\n        {\n            sum[i]=0;\n            for(int j=0;j<T;j++)\n            {\n                if(i&(1<<j))sum[i]+=yao[j];\n            }\n        }\n        int Max = 1<<T;\n        dp[0][0]=hp;\n        int i,j;\n        for(i=1;i<Max;i++)\n            dp[0][i]=hp;\n        for(i=0;i<lk;i++)\n        {\n            for(j=Max-1;j>=0;j--)\n            {\n                for(int k=0;k<T;k++)\n                {\n                    if((1<<k)&(j))continue;\n                    if(dp[i-1][j]==inf)continue;\n                    dp[i][j|(1<<k)]=max(dp[i-1][j]+yao[k],dp[i][j|(1<<k)]);\n                    dp[i][j|(1<<k)]=min(dp[i][j|(1<<k)],hpmax);\n                }\n            }\n            for(j=0;j<Max;j++)\n            {\n                dp[i][j]-=kou[i];\n                if(dp[i][j]<=0)dp[i][j]=inf;\n            }\n        }\n        int  ans = inf;\n        for(i=0;i<Max;i++)\n            ans = min(ans,dp[lk-1][i]);\n        if(ans==inf)puts(\"NO\");\n        else puts(\"YES\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main(){\n\tint dmg[26];\n\tstring mp[100];\n\tint HP, HPmax;\n\tint reg[12];\n\tint dp[2][1<<12];\n\twhile(cin >> HP >> HPmax, HP){\n\t\tint R, C; cin >> R >> C;\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tint T; cin >> T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tdmg[c-'A'] = d;\n\t\t}\n\t\tint S; cin >> S;\n\t\tvector<int> act;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tif(c=='U') act.push_back(0);\n\t\t\t\tif(c=='D') act.push_back(1);\n\t\t\t\tif(c=='R') act.push_back(2);\n\t\t\t\tif(c=='L') act.push_back(3);\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tfor(int i=0;i<P;i++) cin >> reg[i];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][(1<<P)-1] = HP;\n\t\tint x = 0, y = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<act.size();i++){\n\t\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\t\tx += dx[act[i]];\n\t\t\ty += dy[act[i]];\n\t\t\tint damage = dmg[mp[x][y]-'A'];\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tif(dp[cur][j] == 0) continue;\n\t\t\t\tif(dp[cur][j] > damage) dp[next][j] = max(dp[next][j], dp[cur][j]-damage);\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!(j&(1<<k))) continue;\n\t\t\t\t\tdp[cur][j^(1<<k)] = max(min(HPmax, dp[cur][j]+reg[k]), dp[cur][j^(1<<k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << (dp[cur][0] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1001];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1001];\nbool passed[1001][1<<12];\n\nconst int INF=1000000000;\n\nint main(){\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(passed,0,sizeof(passed));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tint quan;\n\t\t\tcin>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint nx,ny;\n\t\t\tint pos=i;\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[pos].second;j++){\n\t\t\t\tif(seq[pos].first=='U'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy-1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='D'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy+1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='L'){\n\t\t\t\t\tnx=cx-1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='R'){\n\t\t\t\t\tnx=cx+1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t// ツ個サツ催敖づ個δ可イツフツづ、ツ残ツづィportion\n\t\tqueue<pair<int,int> > q[2];\n\t\tint cur=0;\n\t\tint nxt=1;\n\t\tint cnt=1;\n\t\tbool ok=false;\n\t\tq[cur].push(make_pair(hpInit,0));\n\t\tpassed[hpInit][0]=true;\n\t\twhile(q[cur].size()){\n\t\t\twhile(q[cur].size()){\n\t\t\t\tint clife=q[cur].front().first;\n\t\t\t\tint cs=q[cur].front().second;\n\t\t\t\tq[cur].pop();\n\t\t\t\tint nx=points[cnt].second;\n\t\t\t\tint ny=points[cnt].first;\n\t\t\t\t// ツ個サツ催敖づ個湘ウツ妥板つゥツづァツづづ継ortionツづーツ使ツづづ遷ツ暗堋つキツづゥツつゥ\n\t\t\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\t\t\tint nlife=min(hpMax,clife+combPortionEf[i]-tbl[(int)dmg[ny][nx]]);\n\t\t\t\t\tif(!(i&cs)&&nlife>0&&!passed[nlife][i|cs]){\n\t\t\t\t\t\tpassed[nlife][i|cs]=true;\n\t\t\t\t\t\tq[nxt].push(make_pair(nlife,i|cs));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==idx){\n\t\t\t\tif(q[nxt].size())ok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(passed,0,sizeof(passed));\n\t\t\tcnt++;\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint R,C,HPinit,HPmax,T,S,P,cost[30],iG[200][200],p[12],dp[1<<12];\nchar G[200][200];\n\nint main(){\n  while( cin >> HPinit >> HPmax, HPinit | HPmax){\n    cin >> R >> C;\n    rep(i,R) rep(j,C) cin >> G[i][j];\n    cin >> T;\n    rep(i,T) {\n      char c; \n      cin >> c;\n      cin >> cost[c-'A'];\n    }\n    rep(i,R) rep(j,C) iG[i][j] = cost[G[i][j]-'A'];\n    cin >> S;\n    deque<int> damage;\n    int x = 0,y = 0;\n    rep(i,S){\n      char dir;\n      int n, dx = 0, dy = 0;\n      cin >> dir >> n;\n      if( dir == 'U' )      dy--;\n      else if( dir == 'D' ) dy++;\n      else if( dir == 'R' ) dx++;\n      else                  dx--;\n      rep(_,n){\n        x += dx, y += dy;\n        assert( 0 <= x && x < C && 0 <= y && y < R );\n        if( iG[y][x] != 0 ) damage.push_back(iG[y][x]);\n      }\n    }\n    cin >> P;\n    rep(i,P) cin >> p[i];\n    assert((int)damage.size() <= 1000);\n    rep(i,(1<<P)) dp[i] = 0;\n    dp[0] = HPinit;\n    rep(i,(int)damage.size()){\n      rep(j,(1<<P))if(dp[j]>0){\n        rep(k,P)if( !( (j>>k) & 1 ) ){\n          dp[j|(1<<k)] = max(dp[j|(1<<k)],\n                             min(HPmax,dp[j]+p[k]));\n        }\n      }\n      rep(j,(1<<P)) dp[j] -= damage[i];\n    }\n    bool ok = false;\n    rep(i,(1<<P)) if( dp[i] > 0 ) {\n      ok = true;\n      break;\n    }\n    cout << (ok?\"YES\":\"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int infty = 1<<28;\n\nint main()\n{\n  while(true){\n\n    int initHP;\n    int maxHP;\n    cin >> initHP >> maxHP;\n    if(initHP==0&&maxHP==0)break;\n\n    int R,C;\n    cin >> R >> C;\n    char M[R][C];\n    int damage[256];\n    for(int i = 0; i < R; ++i){\n      for(int j = 0; j < C; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    \n    int T;\n    cin >> T;\n    for(int i = 0; i < T; ++i){\n      char c;\n      int dam;\n      cin >> c >> dam;\n      damage[(int)c]=dam;\n    }\n    \n    int S;\n    cin >> S;\n    string inst;\n    for(int i = 0; i < S; ++i){\n      char c;\n      int step;\n      cin >> c >> step;\n      for(int j = 0; j < step; ++j){\n\tinst += c;\n      }\n    }\n\n    int P;\n    vector<int> potion;\n    cin >> P;\n    for(int i = 0; i < P; ++i){\n      int p;\n      cin >> p;\n      potion.push_back(p);\n    }\n\n    S = inst.length();\n    \n    int Pmax=1<<potion.size();\n    int dp[1+S][Pmax];\n    for(int i = 0; i < 1+S; ++i){\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i][j] = -infty;\n      }\n    }\n    dp[0][0]=initHP;\n    \n    int ni=0;\n    int nj=0;\n    for(int i = 0; i < S; ++i){\n      switch(inst[i]){\n      case 'D':++ni;break;\n      case 'U':--ni;break;\n      case 'R':++nj;break;\n      case 'L':--nj;break;\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tfor(int k = 0; k < (int)potion.size(); ++k){\n\t  if( (j&(1<<k)) == 0 ){\n\t    dp[i][j|(1<<k)] = max( dp[i][j|(1<<k)], min(maxHP, dp[i][j] + potion[k]) );\n\t  }\n\t}\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i+1][j] = max( dp[i+1][j], dp[i][j]-damage[(int)M[ni][nj]] );\n      }\n    }\n\n    int res = -infty;\n    for(int i = 0; i < Pmax; ++i){\n      res = max( res, dp[S][i] );\n    }\n    if(res>0)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,hp,HP;\nchar t[1005][1005];\nint T,S,P;\nmap<char,int> mp;\nvector<int> u;\nint dp[1005][(1<<12)];\nint v[12];\n\nint main(){\n\n  while(1){\n    u.clear();\n    cin>>hp>>HP;\n    if(hp==0&&HP==0)break;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin>>t[i][j];\n    cin>>T;\n    for(int i=0;i<T;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      mp[ch]=num;\n    }\n    int y=0,x=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      while(num--){\n        if(ch=='U')y--;\n        if(ch=='R')x++;\n        if(ch=='D')y++;\n        if(ch=='L')x--;\n        u.push_back(mp[ t[y][x] ]);\n      }\n    }\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>v[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hp;\n    int N=u.size();\n    for(int i=0;i<N;i++){\n      for(int S=0;S<(1<<P);S++){\n        if(dp[i][S]==0)continue;        \n        for(int k=0;k<P;k++){\n          if(S>>k&1)continue;\n          int nS=S|(1<<k);\n          dp[i][nS]=max(dp[i][nS],min(HP,dp[i][S]+v[k]));\n        }\n        dp[i+1][S]=max(dp[i+1][S],dp[i][S]-u[i]);\n      }\n    }\n    string ans=\"NO\";\n    for(int i=0;i<(1<<P);i++)\n      if(dp[N][i]>0)ans=\"YES\";\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint HP, HPm;\nint H, W;\nchar G[100][100];\nint D[256];\nvector<P> v;\nvector<int> p;\n\nstring solve() {\n  int x = 0;\n  int y = 0;\n  vector<int> damage;\n  for(int i = 0; i < v.size(); ++i) {\n    for(int j = 0; j < v[i].second; ++j) {\n      int nx = x + dx[v[i].first];\n      int ny = y + dy[v[i].first];\n      if(nx < 0 || nx >= W) break;\n      if(ny < 0 || ny >= H) break;\n      x = nx;\n      y = ny;\n      if(D[G[y][x]] > 0) damage.push_back(D[G[y][x]]);\n    }\n  }\n  vector<P> add;\n  for(int s = 0; s < (1<<p.size()); ++s) {\n    int sum = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      if(s & (1<<i)) sum += p[i];\n    }\n    add.push_back(make_pair(sum, s));\n  }\n  sort(add.begin(), add.end());\n  int bit = (1<<p.size())-1;\n  for(int i = 0; i < damage.size(); ++i) {\n    if(HP <= damage[i]) {\n      if(damage[i] >= HPm) return \"NO\";\n      int need = damage[i] - HP + 1;\n      int j = distance(add.begin(), lower_bound(add.begin(), add.end(), make_pair(need, 0)));\n      while(j < add.size() && (add[j].second & bit) != add[j].second) ++j;\n      if(j == add.size()) return \"NO\";\n      bit = bit & ~add[j].second;\n      HP = min(HP + add[j].first, HPm);\n    }\n    HP -= damage[i];\n  }\n  return \"YES\";\n}\n\nint main() {\n  while(cin >> HP >> HPm && (HP || HPm)) {\n    v.clear();\n    p.clear();\n    fill(D,D+256,0);\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    int T;\n    cin >> T;\n    for(int i = 0; i < T; ++i) {\n      char c; int d;\n      cin >> c >> d;\n      D[c] = d;\n    }\n    int S;\n    cin >> S;\n    for(int i = 0; i < S; ++i) {\n      char c; int n, d;\n      cin >> c >> n;\n      if(c == 'U') d = 3;\n      if(c == 'D') d = 1;\n      if(c == 'L') d = 2;\n      if(c == 'R') d = 0;\n      v.push_back(make_pair(d,n));\n    }\n    int P;\n    cin >> P;\n    for(int i = 0; i < P; ++i) {\n      int h;\n      cin >> h;\n      p.push_back(h);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n#define inf 2147480000\nint blost,bloend;\nint n,m,x0,y0;\nchar box[111][111];\nint fox[13];\nint dk,ck;\nint final[2][5001];\nint aox[50];\nint o;\nint map[1000001];\nint q;\nint tem[13];\nint change(char a)\n{\n    return int(a)-'A'+1;\n}\nvoid ini()\n{\n   fox[0]=1;\n   for(int i=1;i<=12;i++) fox[i]=fox[i-1]*2;\n}\nint main(int argc, char *argv[])\n{\n    ini();\n    while(cin>>blost)\n    {\n      cin>>bloend;\n      if(blost==0 && bloend==0) break;\n      cin>>n>>m;\n      x0=1;y0=1;\n      for(int i=1;i<=n;i++)\n      {\n         for(int j=1;j<=m;j++)\n         {\n           cin>>box[i][j];\n         }\n      }\n      int kk;\n      cin>>kk;\n      for(int i=1;i<=kk;i++)\n      {\n          char a;int b;\n          cin>>a>>b;\n          aox[change(a)]=b;\n      }\n      o=0;\n      cin>>kk;\n      for(int i=1;i<=kk;i++)\n      {\n          char a;int b;\n          cin>>a>>b;\n          for(int j=1;j<=b;j++)\n          {\n             if(a=='D')\n             {\n                 x0++;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else if(a=='R')\n             {\n                 y0++;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else if(a=='U')\n             {\n                 x0--;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else\n             {\n                 y0--;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n          }\n      }\n      cin>>q;\n      for(int i=1;i<=q;i++)\n         cin>>tem[i];\n      bool con=0;\n      queue < int > k;\n      queue < int > p;\n      dk=0;ck=1;\n      for(int j=0;j<=4100;j++)\n         {\n            final[dk][j]=-1;\n            final[ck][j]=-1;\n         }\n      k.push(0);\n      final[dk][0]=blost;\n      for(int i=1;i<=o;i++)\n      {\n         bool ok=0;\n         while(!k.empty())\n         {\n            int a=k.front();k.pop();\n            if(final[dk][a]>map[i])\n            {\n               if(final[ck][a]<final[dk][a]-map[i]) \n                {final[ck][a]=final[dk][a]-map[i];p.push(a);ok=1;}\n            }\n            else\n            {\n              for(int j=0;j<q;j++)\n              {\n                  int b=a&fox[j];\n                  if(b==0)\n                  {\n                     int c=a+fox[j];\n                     int d=final[dk][a]+tem[j+1];if(d>bloend) d=bloend;\n                     if(d>map[i])\n                     {\n                         if(final[ck][c]<d-map[i]) {final[ck][c]=d-map[i];p.push(c);ok=1;}             \n                     }\n                     else\n                     {\n                         if(final[dk][c]<d)\n                         {\n                            final[dk][c]=d;k.push(c);\n                         }\n                     }\n                  }\n              }\n            }\n         }\n         if(ok==0) {con=1;break;}\n         while(!p.empty())\n         {\n            int a=p.front();p.pop();\n            k.push(a);\n         }  \n         for(int j=0;j<=4100;j++)\n         {\n            final[dk][j]=final[ck][j];\n            final[ck][j]=-1;\n         }\n         dk=1-dk;ck=1-ck;\n      }\n      if(con==0) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\nconst ll INF = 1LL << 60;\n\ntemplate <typename Tp>\nvoid chmax(Tp &A, Tp B) { A = max(A, B); }\n\ntemplate <typename Tp>\nvoid chmin(Tp &A, Tp B) { A = min(A, B); }\n\nll rec[1010][1 << 12][2];\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nconst string pat = \"UDRL\";\n\nint solve_testcase() {\n  ll HP_init, HP_max; cin >> HP_init >> HP_max;\n  if(HP_init == 0 and HP_max == 0) return 1;\n\n  int H, W; cin >> H >> W;\n  vector<string> board(H);\n  for(int i=0; i<H; i++) cin >> board[i];\n\n  int T; cin >> T;\n  vector<ll> damage(26);\n  for(int i=0; i<T; i++) {\n    char c; cin >> c;\n    ll d; cin >> d;\n    chmax(damage[c - 'A'], d);\n  }\n\n  int S; cin >> S;\n  int N = 0;\n  vector<int> op;\n  for(int i=0; i<S; i++) {\n    char c; cin >> c;\n    int n; cin >> n;\n    N += n;\n    int id = pat.find(c);\n    for(int j=0; j<n; j++) op.emplace_back(id); \n  }\n\n  int P; cin >> P;\n  vector<ll> p(P);\n  for(int i=0; i<P; i++) cin >> p[i];\n\n  fill(rec[0][0], rec[N+1][0], -INF);\n  rec[0][0][0] = HP_init;\n\n  // init\n  for(int bit=0; bit<(1<<P); bit++) {\n    for(int i=0; i<P; i++) {\n      if(bit >> i & 1) continue;\n      int nbit = bit | (1 << i);\n      chmax(rec[0][nbit][0], min(rec[0][bit][0] + p[i], HP_max));\n    }\n  }\n\n  int x = 0, y = 0;\n  for(int i=0; i<N; i++) {\n    // move\n    x += dx[ op[i] ], y += dy[ op[i] ];\n    ll dam = damage[ board[x][y] - 'A' ];\n    for(int bit=0; bit<(1<<P); bit++) {\n      // 0 -> 1\n      {\n        chmax(rec[i][bit][1], min(HP_max - dam, rec[i][bit][0] - dam));\n      }\n      // 1 -> 1\n      {\n        for(int k=0; k<P; k++) {\n          if(bit >> k & 1) continue;\n          int nbit = bit | (1 << k);\n          chmax(rec[i][nbit][1], min(HP_max - dam, rec[i][bit][1] + p[k]));\n        }\n      }\n      // 1 -> next 0\n      if(rec[i][bit][1] > 0) {\n        chmax(rec[i+1][bit][0], rec[i][bit][1]);\n      }\n      // fprintf(stderr, \"rec[%d][%d][%d] = %lld\\n\", i, bit, 0, rec[i][bit][0]);\n      // fprintf(stderr, \"rec[%d][%d][%d] = %lld\\n\", i, bit, 1, rec[i][bit][1]);\n    }\n  }\n\n  bool ok = false;\n  for(int bit=0; bit<(1<<P); bit++) {\n    ok |= (rec[N][bit][0] > 0);\n    ok |= (rec[N][bit][1] > 0);\n  }\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n\nint main() {\n  while(!solve_testcase());\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvector<int> damages;\nmap<char, int> traps;\nvector<int> potions;\nchar cave[100][100];\nint H, W, T, S, P;\nint inithp, maxHp;\n\nbool dfs(int pos, int hp, int state){\n  //cout << pos << ' ' << hp << ' ' << state << endl;\n  for(;pos<(int)damages.size()-1 && hp>0;){\n    pos++;\n    hp -= damages[pos];\n  }\n  if(pos == (int)damages.size()-1 && hp > 0){\n    hp -= damages[pos];\n    int sum = 0;\n    for(int i=0;i<P;i++){\n      if((1<<i) & state) continue;\n      sum += potions[i];\n    }\n    return hp + sum > 0;\n  }\n  for(int i=0;i<P;i++){\n    if((1<<i) & state) continue;\n    int nextHp = hp + potions[i];\n    if(nextHp > maxHp) nextHp = maxHp;\n    if(dfs(pos, nextHp, (1<<i) | state)) return true;\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> inithp >> maxHp){\n    if(inithp == 0 && maxHp == 0) break;\n    cin >> H >> W;\n    traps.clear();\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> cave[i][j];\n      }\n    }\n    cin >> T;\n    for(int i=0;i<T;i++){\n      char c;\n      int input;\n      cin >> c >> input;\n      traps[c] = input;\n    }\n    cin >> S;\n    int y = 0;\n    int x = 0;\n    for(int i=0;i<S;i++){\n      char c;\n      int steps, tmp;\n      cin >> c >> steps;\n      switch(c){\n      case 'U':\n\tfor(int i=0;i<steps;i++){\n\t  int ty = y - 1;\n\t  int tx = x;\n\t  if(ty<0 || ty>=H) break;\n\t  if(tx<0 || tx>=W) break;\n\t  if((tmp = traps[cave[ty][tx]]) > 0) damages.push_back(tmp);\n\t  y = ty;\n\t  x = tx;\n\t}\n\tbreak;\n      case 'D':\n\tfor(int i=0;i<steps;i++){\n\t  int ty = y + 1;\n\t  int tx = x;\n\t  if(ty<0 || ty>=H) break;\n\t  if(tx<0 || tx>=W) break;\n\t  if((tmp = traps[cave[ty][tx]]) > 0) damages.push_back(tmp);\n\t  y = ty;\n\t  x = tx;\n\t}\n\tbreak;\n      case 'L':\n\tfor(int i=0;i<steps;i++){\n\t  int ty = y;\n\t  int tx = x - 1;\n\t  if(ty<0 || ty>=H) break;\n\t  if(tx<0 || tx>=W) break;\n\t  if((tmp = traps[cave[ty][tx]]) > 0) damages.push_back(tmp);\n\t  y = ty;\n\t  x = tx;\n\t}\n\tbreak;\n      case 'R':\n\tfor(int i=0;i<steps;i++){\n\t  int ty = y;\n\t  int tx = x + 1;\n\t  if(ty<0 || ty>=H) break;\n\t  if(tx<0 || tx>=W) break;\n\t  if((tmp = traps[cave[ty][tx]]) > 0) damages.push_back(tmp);\n\t  y = ty;\n\t  x = tx;\n\t}\n\tbreak;\n      }\n    }\n    cin >> P;\n    for(int i=0;i<P;i++){\n      int input;\n      cin >> input;\n      potions.push_back(input);\n    }\n    /*for(int i=0;i<damages.size();i++){\n      cout << damages[i] << ' ';\n      }cout << endl;*/\n    if(dfs(0, inithp, 0)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 108\nint dp[M*10][5000];\nchar map1[M][M];\nint a[M];\nint b[M];\nint c[M];\nint n,m;\nint my_hash[M];\nint o[4][2]={\n    0,-1,\n    1,0,\n    0,1,\n    -1,0\n};\nint min(int x,int y){\n    if(x>y) return y;return x;\n}\nint max(int x,int y){\n    if(x<y) return y;return x;\n}\nint main(){\n    int sp,tmax;\n    while(~scanf(\"%d%d\",&sp,&tmax)&&(sp+tmax)){\n        scanf(\"%d%d\",&n,&m);\n        for(int i=0;i<n;i++)scanf(\"%s\",&map1[i]);\n        int n1;scanf(\"%d\",&n1);\n        for(int i=0;i<n1;i++){\n            char str[100];\n            int t1;scanf(\"%s%d\",str,&t1);\n            my_hash[str[0]-'A']=t1;\n        }\n        int m1;scanf(\"%d\",&m1);\n        int sx=0,sy=0;\n        int num=1;\n        memset(b,0,sizeof(b));\n        for(int i=0;i<m1;i++){\n            char str[20];int m2;\n            scanf(\"%s%d\",str,&m2);\n            int oo;\n            if(str[0]=='U') oo=3;\n            else if(str[0]=='R') oo=2;\n            else if(str[0]=='D') oo=1;\n            else if(str[0]=='L') oo=0;\n            for(int i=0;i<m2;i++){\n                sx=sx+o[oo][0];\n                sy=sy+o[oo][1];\n                int t1=map1[sx][sy]-'A';\n                b[num++]=my_hash[t1];\n            }\n        }\n//        puts(\"@@@@@@@@@\");\n        int n2;scanf(\"%d\",&n2);\n        for(int i=0;i<n2;i++){\n            scanf(\"%d\",&c[i]);\n        }\n//        for(int i=0;i<num;i++){\n//            printf(\"%d \",b[i]);\n//        }\n//        printf(\"%d!!!\\n\",num);\n//        puts(\"\");\n        memset(dp,0,sizeof(dp));\n        int t2=1<<n2;\n        t2--;\n//        printf(\"%d\\n\",t2);\n        dp[0][t2]=sp;\n        for(int i=0;i<num-1;i++){\n            for(int j=t2;j>=0;j--){\n                if(dp[i][j]<=0) continue;\n                if(dp[i][j]<=b[i+1]){\n//                    printf(\"%d!!!!!\\n\",b[i+1]);\n                    for(int k=0;k<n2;k++){\n                        if(j&(1<<k)){\n                            int tt=j^(1<<k);\n                            int t1=min(tmax,dp[i][j]+c[k]);\n                            dp[i][tt]=max(t1,dp[i][tt]);\n                        }\n                    }\n                }\n                else{\n//                    if(b[i+1]==10000) puts(\"****************\");\n                    int t1=dp[i][j]-b[i+1];\ndp[i+1][j]=max(dp[i+1][j],t1);\n                }\n            }\n        }\n        int flag=0;\n        for(int i=0;i<=t2;i++){\n            if(dp[num-1][i]>0) flag=1;\n//            printf(\"%d  !!\\n\",dp[num-1][i]);\n        }\n        if(flag) puts(\"YES\");else puts(\"NO\");\n    }\n    return 0;\n}\n/*\n1 10\n3 3\nAAA\nCAA\nCBC\n3\nA 0\nB 10000\nC 9\n3\nD 2\nR 1\nU 2\n5\n4\n4\n4\n4\n4\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n  \n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n  \n  for(int i=0;i<m;i++){\n\n    for(int j=0;j<(1<<P);j++){\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[(int)dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[(int)dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\t\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\t\n\tnhp=max(0,nhp-cost[(int)s[y[i+1]][x[i+1]]]);\n\t\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n      int nhp=max(0,dp[i][j]-cost[(int)s[y[i+1]][x[i+1]]]);\n      \n      if(!nhp) continue;\n\n      dp[i+1][j]=max(dp[i+1][j],nhp);\n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n\n    dir=\"\";\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nstruct mData {\n    int typ,index;\n    int mh;\n};\n\nqueue<mData>que;\n\nint route[1010];\n\nchar map[110][110];\nint LH,H;\nint n,m,num,t,p;\nint reduce[13];\n\nchar str[100];\nint dam[26];\n\nshort vis[1010][1<<12];\n\ninline int minnum(const int &x,const int &y){\n\tif(x<y)return x;return y;\n}\n\nvoid dfs(int index,int typ,int mh,int damage,int np){\n\tif(np==p){\n\t\tif(mh>damage && vis[mh][typ]<index){\n\t\t\tmData tem;\n\t\t\tvis[mh][typ]=index;\n\t\t\ttem.index=index;tem.mh=mh-damage;tem.typ=typ;que.push(tem);\n\t\t}\n\t\treturn;\n\t}\n\tif(mh<=damage && (typ&(1<<np))==0)dfs(index,typ+(1<<np),minnum(mh+reduce[np],LH),damage,np+1);\n\tdfs(index,typ,mh,damage,np+1);\n}\n\nint main() {\n    int i,j,k,ans;\n    int x,y;\n    mData tem;\n    while(scanf(\"%d%d\",&H,&LH)!=EOF) {\n        if(H==0 && LH==0)break;\n        scanf(\"%d%d\",&n,&m);\n        for(i=0; i<n; i++)scanf(\"%s\",map[i]);\n        scanf(\"%d\",&i);\n        for(; i>0; i--) {\n            scanf(\"%s%d\",str,&j);\n            dam[str[0]-'A']=j;\n        }\n        scanf(\"%d\",&t);\n        x=0;y=0;num=0;\n        for(i=0; i<t; i++) {\n            scanf(\"%s%d\",str,&j);\n            if(str[0]=='U')for(; j>0; j--) {\n                    x--;route[num++]=dam[map[x][y]-'A'];\n                }\n            if(str[0]=='D')for(; j>0; j--) {\n                    x++;route[num++]=dam[map[x][y]-'A'];\n                }\n            if(str[0]=='L')for(; j>0; j--) {\n                    y--;route[num++]=dam[map[x][y]-'A'];\n                }\n            if(str[0]=='R')for(; j>0; j--) {\n                    y++;route[num++]=dam[map[x][y]-'A'];\n                }\n        }\n        scanf(\"%d\",&p);\n        for(i=0;i<p;i++)scanf(\"%d\",&reduce[i]);\n        memset(vis,-1,sizeof(vis));\n        while(!que.empty())que.pop();\n        tem.mh=H;tem.typ=0;tem.index=-1;\n        if(H>0)que.push(tem);\n        for(ans=0;ans==0 && !que.empty();){\n        \ttem=que.front();que.pop();\n        \tif(tem.index==num-1){\n        \t\tans=1;continue;\n        \t}\n        \tdfs(tem.index+1,tem.typ,tem.mh,route[tem.index+1],0);\n        }\n        if(ans==1)printf(\"YES\\n\");else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint dp[1005][1<<12];\nint maxhp,hp;\n\n\nint main() {\n    while(cin>>hp>>maxhp, hp|maxhp) {\n        int r,c,t,s,p,d,n;\n        string str;\n        cin>>r>>c;\n        vector<string> mp(r);\n        for(int i=0; i<r; ++i) cin>>mp[i];\n\n        map<string,int> trap;\n        cin>>t;\n        for(int i=0; i<t; ++i) {\n            cin>>str>>d;\n            trap[str] = d;\n        }\n\n        cin>>s;\n        string move;\n        for(int i=0; i<s; ++i) {\n            cin>>str>>n;\n            move += string(n, str[0]);\n        }\n\n        cin>>p;\n        vector<int> pot(p);\n        for(int i=0; i<p; ++i) cin>>pot[i];\n\n        int x = 0,y = 0;\n        vector<int> dam;\n        dam.push_back(0);\n        for(int i=0; i<move.length(); ++i) {\n            if(move[i] == 'U') y--;\n            else if(move[i] == 'D') y++;\n            else if(move[i] == 'R') x++;\n            else if(move[i] == 'L') x--;\n            dam.push_back(trap[string(1,mp[y][x])]);\n        }\n\n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = hp;\n\n        for(int i=0; i<dam.size(); ++i) {\n            for(int j=0; j<(1<<p); ++j) {\n                if(dp[i][j] > 0) {\n                    dp[i+1][j] = dp[i][j];\n                    for(int k=0; k<p; ++k) {\n                        if(j & (1<<k)) continue;\n                        dp[i+1][j|(1<<k)]\n                            = max(dp[i+1][j|(1<<k)],\n                                  min(maxhp, dp[i][j] + pot[k]));\n                    }\n                }\n            }\n            for(int j=0; j<(1<<p); ++j) dp[i+1][j] -= dam[i];\n        }\n\n        bool ok = false;\n        for(int j=0; j<(1<<p); ++j) if(dp[dam.size()][j] > 0) ok = true;\n        if(ok) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int hp_init, hp_max;\n    while(cin >> hp_init >> hp_max, hp_init) {\n        int R, C;\n        cin >> R >> C;\n        vector<string> dungeon(R);\n        for(int i=0; i<R; ++i) {\n            cin >> dungeon[i];\n        }\n\n        int T;\n        cin >> T;\n        vector<int> damage(26, 0);\n        for(int i=0; i<T; ++i) {\n            char c;\n            int d;\n            cin >> c >> d;\n            damage[c - 'A'] = d;\n        }\n\n        int S;\n        cin >> S;\n        vector<char> dir(S);\n        vector<int> dist(S);\n        for(int i=0; i<S; ++i) {\n            cin >> dir[i] >> dist[i];\n        }\n\n        int P;\n        cin >> P;\n        vector<int> portion(P);\n        for(int i=0; i<P; ++i) {\n            cin >> portion[i];\n        }\n\n        vector<int> dp(1 << P);\n        dp[(1 << P) - 1] = hp_init;\n        int y = 0, x = 0;\n        for(int i=0; i<S; ++i) {\n            int dy = 0, dx = 0;\n            if(dir[i] == 'D') {\n                dy = 1;\n            } else if(dir[i] == 'U') {\n                dy = -1;\n            } else if(dir[i] == 'L') {\n                dx = -1;\n            } else {\n                dx = 1;\n            }\n\n            for(int j=0; j<dist[i]; ++j) {\n                int ny = y + dy;\n                int nx = x + dx;\n                for(int p = (1 << P) - 1; p >= 0; --p) {\n                    if(dp[p] <= 0) {\n                        continue;\n                    }\n                    for(int k = 0; k < P; ++k) {\n                        if(!((p >> k) & 1)) {\n                            continue;\n                        }\n                        int next_p = p & ~(1 << k);\n                        int next_hp = min(dp[p] + portion[k], hp_max);\n                        dp[next_p] = max(dp[next_p], next_hp);\n                    }\n                }\n                for(int p=0; p < (1 << P); ++p) {\n                    dp[p] -= damage[dungeon[ny][nx] - 'A'];\n                }\n                y = ny;\n                x = nx;\n            }\n        }\n        if(*max_element(dp.begin(), dp.end()) > 0) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\n#define MAX 101\nusing namespace std;\n\nint a,b,h,w,t,s,p,P[12];\nstring dungeon[MAX];\nint grid[MAX][MAX];\npair<char,int> S[1001];\nint Steps[1001];\nint dp[1001][(1<<12)];\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\n\nint f(char c){\n  if(c=='U')return 0;\n  if(c=='R')return 1;\n  if(c=='D')return 2;\n  return 3;\n}\n\nint main()\n{\n  while(1){\n    cin>>a>>b;\n    if(a+b==0)break;\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n      cin>>dungeon[i];\n    }\n    cin>>t;\n    map<char,int> T;\n    for(int i=0;i<t;i++){\n      char t1;\n      int t2;\n      cin>>t1>>t2;\n      T[t1]=t2;\n    }\n    cin>>s;\n    for(int i=0;i<s;i++)cin>>S[i].f>>S[i].s;\n    cin>>p;\n    for(int i=0;i<p;i++)cin>>P[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)grid[i][j]=T[dungeon[i][j]];\n    }\n    int ni=0,nj=0,c=0;\n    Steps[c++]=0;\n    for(int i=0;i<s;i++){\n      int muki=f(S[i].f);\n      for(int j=0;j<S[i].s;j++){\n\tni+=Y[muki];\n\tnj+=X[muki];\n\tSteps[c++]=grid[ni][nj];\n      }\n    }\n    for(int i=0;i<c;i++){\n      for(int j=0;j<(1<<p);j++)dp[i][j]=0;\n    }\n    dp[0][(1<<p)-1]=a;\n    for(int step=1;step<c;step++){\n      for(int i=0;i<(1<<p);i++){\n\tif(dp[step-1][i]==0)continue;\n\tfor(int j=0;j<p;j++){\n\t  if((i>>j)%2==0)continue;\n\t  int nhp=min(dp[step-1][i]+P[j],b);\n\t  dp[step][i-(1<<j)]=max(dp[step][i-(1<<j)],max(0,nhp-Steps[step]));\n\t}\n\tdp[step][i]=max(dp[step][i],dp[step-1][i]-Steps[step]);\n      }\n    }\n    bool flag=false;\n    for(int i=0;i<(1<<p);i++){\n      if(0<dp[c-1][i])flag=true;\n    }\n    if(flag)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"C.txt\");\n#define cin ifs\n\nint dy[201];\nint dx[201];\nint dp[1010][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000;\n\n// S[©çßÄX^[gÖü©¤\nint dfs(int pos,int s){\n\tif(pos==-1){\n\t\tint sum=0;\n\t\t// Ü¾gpµÄ¢È¢àÌð·×Äg¤\n\t\tfor(int i=0;i<P;i++)if(!((s>>i)&1))sum+=portions[i];\n\t\treturn sum+inithp;\n\t}\n\telse if(dp[pos][s]!=-1)return dp[pos][s];\n\tint res=-INF;\n\t// Ü¾gpµÄ¢È¢portionðgp\n\tfor(int k=0;k<P;k++)if(!((s>>k)&1))res=max(res,min(dfs(pos,s|(1<<k))+portions[k],maxhp));\n\t// ÌêÖ\n\tres=max(res,dfs(pos-1,s)-stepDmg[pos]);\n\tif(res<0)res=-INF;\n\treturn dp[pos][s]=res;\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tcin>>r>>c;\n\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint m;\n\t\t\tcin>>ch>>m;\n\t\t\tdmg[ch]=m;\n\t\t}\n\t\tcin>>S;\n\t\tint cx=0;\n\t\tint cy=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\tfor(int j=0;j<quan;j++){\n\t\t\t\tint ny=cy+dy[ch];\n\t\t\t\tint nx=cx+dx[ch];\n\t\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\t\tstep++;\n\t\t\t\tcx=nx;\n\t\t\t\tcy=ny;\n\t\t\t}\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portions[i];\n//\t\tmemset(dp,-1,sizeof(dp));\n//\t\tif(dfs(step-1,0)>0)cout<<\"YES\"<<endl;\n//\t\telse cout<<\"NO\"<<endl;\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=sum+inithp;\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1))res=max(res,min(dp[pos+1][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[pos][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[pos+1][s]=res;\n\t\t\t}\n\t\t}\n\t\tif(dp[step][0]>0)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<char, int> pci;\nint life, maxi, r, c, t, s, p;\nvector<int> potion;\nmap<char, int> damage;\n\nvoid calcDP(vector<vector<int> > &dp, vector<string> &grid,\n            int nx, int ny, int x, int y, int trun){\n  for (int i = 0; i < (1<<p); i++) {\n    int next_life = dp[i][trun - 1];\n    if(next_life == 0)continue;\n    dp[i][trun] = max(dp[i][trun], next_life -\n                      damage[grid[ny][nx]]);\n    for (int j = 0; j < p; j++) {\n      if(i & (1<<j))continue;\n      next_life = min(maxi, next_life + potion[j]);\n      next_life -= damage[grid[ny][nx]];\n      dp[i + (1<<j)][trun] = max(dp[i + (1<<j)][trun],\n                                 next_life);\n    }\n  }\n}\n\nint main(){\n  while(\n        std::cin >> life >> maxi){\n    std::cin >> r >> c;\n    vector<string> grid(r);\n    for (int i = 0; i < r; i++) {\n      std::cin >> grid[i];\n    }\n    std::cin >> t;\n    for (int i = 0; i < t; i++) {\n      char floor;\n      int d;\n      std::cin >> floor >> d;\n      damage[floor] = d;\n    }\n    std::cin >> s;\n    vector<pci> action(s);\n    int sum = 0;\n    for (int i = 0; i < s; i++) {\n      std::cin >> action[i].first >> action[i].second;\n      sum += action[i].second;\n    }\n    std::cin >> p;\n    for (int i = 0; i < p; i++) {\n      int tmp;\n      std::cin >> tmp;\n      potion.push_back(tmp);\n    }\n    vector<vector<int> > dp((1<<p), vector<int>(sum + 1, 0));\n    for (int i = 0; i < (1<<p); i++) {\n      dp[i][0] = life;\n      for (int j = 0; j < p; j++) {\n        if((i & (1<<j)) == 0)continue;\n        dp[i][0] = min(maxi, dp[i][0] + potion[j]);\n      }\n    }\n    int x = 0, y = 0;\n    map<char, int> dx, dy;\n    dx['U'] = 0;\n    dx['D'] = 0;\n    dx['R'] = 1;\n    dx['L'] = -1;\n    dy['U'] = -1;\n    dy['D'] = 1;\n    dy['R'] = 0;\n    dy['L'] = 0;\n    int trun = 0;\n    for (int i = 0; i < s; i++) {\n      for (int j = 0; j < action[i].second; j++) {\n        trun++;\n        int nx = x + dx[action[i].first],\n          ny = y + dy[action[i].first];\n        calcDP(dp, grid, nx, ny, x, y, trun);\n        x = nx, y = ny;\n      }\n    }\n    // for (int i = 0; i < (1<<p); i++) {\n    //   for (int j = 0; j <= sum; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    if(dp[(1<<p) - 1][sum] == 0){\n      std::cout << \"NO\" << std::endl; \n    }else{\n      std::cout << \"YES\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint main(){\n    int HPinit, HPmax;\n    while(cin>>HPinit>>HPmax&&(HPinit||HPmax)){\n        int h,w;\n        cin>>h>>w;\n        vector<string> vs(h);\n        rep(i,h)cin>>vs[i];\n        \n        int n;\n        cin>>n;\n        map<char,int> dmg;\n        rep(i,n){\n            char ch;\n            int val;\n            cin>>ch>>val;\n            dmg[ch] = val;\n        }\n        \n        int m;\n        cin>>m;\n        vector<pair<char,int>> mv(m);\n        rep(i,m){\n            char ch;\n            int dist;\n            cin>>ch>>dist;\n            mv[i] = make_pair(ch,dist);\n        }\n        \n        int c;\n        cin>>c;\n        vector<int> p(c);\n        rep(i,c)cin>>p[i];\n        \n        static int dp[1001][1<<12];\n        rep(i,1001)rep(j,1<<12)dp[i][j] = -INF;\n        dp[0][(1<<c)-1] = HPinit;\n        \n        int dy[]={1,0,-1,0};\n        int dx[]={0,1,0,-1};\n        \n        int y = 0, x=0;\n        int turn = 0;\n        rep(i,m){\n            int dir = -1;\n            char ch = mv[i].first;\n            if(ch=='D')dir=0;\n            else if(ch=='R')dir=1;\n            else if(ch=='U')dir=2;\n            else if(ch=='L')dir=3;\n            assert(dir!=-1);\n            \n            rep(j,mv[i].second){\n                y += dy[dir];\n                x += dx[dir];\n                for(int bit = 1<<c;bit>=0;bit--){\n                    if(dp[turn][bit]>dmg[vs[y][x]])continue;\n                    if(dp[turn][bit]<=0)continue;\n                    rep(i,c){\n                        if(((1<<i)&bit)==0)continue;\n                        \n                        dp[turn][bit^(1<<i)] = max(dp[turn][bit^(1<<i)], min(HPmax, dp[turn][bit] + p[i]));\n                    }\n                }\n                for(int bit = 1<<12;bit>=0;bit--){\n                    dp[turn+1][bit] = dp[turn][bit]-dmg[vs[y][x]];\n                }\n                turn++;\n            }\n        }\n        int maxi = -INF;\n        rep(i,1<<c)maxi = max(maxi,dp[turn][i]);\n        if(maxi>0)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int N = 1<<12;\nint dp[2][N];\nint n,m;\nint hpi,hpm;\nchar mz[110][110];\nint T,S,P;\nint val[30];\nchar op[1100][2];\nint num[1100],p[15],sum;\nconst int dx[4]={0,0,1,-1};\nconst int dy[4]={1,-1,0,0};\nint idx(char x){\n    if (x == 'U') return 3;\n    if (x == 'D') return 2;\n    if (x == 'L') return 1;\n    if (x == 'R') return 0;\n}\nint hp[N];\nvoid findhp(){\n    memset(hp,0,sizeof(hp));\n    for (int x = 0; x < (1<<P); x++)\n    for (int j = 0; j < P; j++) {\n        if (x & (1<<j)) hp[x] += p[j];\n    }\n}\nint haved;\nint findminhp(int x,int v) {\n    int minhp = -1, f = 0;\n    for (int i = 0; i < (1<<P); i++) {\n        if (min(x + hp[i],hpm) <= v) continue;\n        if (haved & i) continue;\n        if (minhp == -1 || minhp < hp[i]) {\n            minhp = hp[i];\n            f = i;\n        }\n    }\n    haved |= f;\n    return minhp;\n}\nint solve(){\n    findhp();\n    haved = 0;\n    int nowhp = hpi;\n    int x = 0, y = 0;\n    for (int i = 0; i < S; i++) {\n        int d = idx(op[i][0]);\n        for (int j = 0; j < num[i]; j++) {\n            x += dx[d]; y += dy[d];\n            int v = val[ mz[x][y] - 'A' ];\n            if (nowhp - v <= 0) {\n                int thp = findminhp(nowhp,v);\n                if (thp == -1) return 0;\n                if ( min(nowhp + thp,hpm) - v <= 0) return 0;\n                nowhp = min(nowhp+thp,hpm);\n            }\n            nowhp -= v;\n        }\n    }\n    return 1;\n\n\n}\nint main(){\n    while (~scanf(\"%d%d\",&hpi,&hpm),hpi+hpm) {\n        scanf(\"%d%d\",&n,&m);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\",mz[i]);\n        }\n        scanf(\"%d\",&T);\n        for (int i = 0; i < T; i++) {\n            char t[2];\n            scanf(\"%s\",t);\n            scanf(\"%d\",&val[t[0]-'A']);\n        }\n        scanf(\"%d\",&S);\n        for (int i = 0 ;i < S; i++) {\n            scanf(\"%s%d\",op[i],num+i);\n        }\n        scanf(\"%d\",&P);\n        sum = 0;\n        for (int i = 0; i < P; i++) {\n            scanf(\"%d\",&p[i]);\n            sum += p[i]>hpm ? hpm : p[i];\n        }\n        puts(solve() ? \"YES\":\"NO\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][1<<12];\nsigned main(){\n  int hi,hm;\n  while(cin>>hi>>hm,hi||hm){\n    int r,c;\n    cin>>r>>c;\n    string a[r];\n    for(int i=0;i<r;i++) cin>>a[i];\n    int t;\n    cin>>t;\n    char b[t];\n    int d[t];\n    for(int i=0;i<t;i++) cin>>b[i]>>d[i];\n    int s;\n    cin>>s;\n    char e[s];\n    int n[s];\n    for(int i=0;i<s;i++) cin>>e[i]>>n[i];\n    int q;\n    cin>>q;\n    int p[q];\n    for(int i=0;i<q;i++) cin>>p[i];\n    //puts(\"OK\");\n    map<char,int> dm;\n    for(int i=0;i<t;i++) dm[b[i]]=d[i];\n    string udlr=\"UDLR\";\n    map<char,int> rd;\n    for(int i=0;i<(int)udlr.size();i++) rd[udlr[i]]=i;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hi;\n    int z=0;\n    int ax[]={0,0,-1,1};\n    int ay[]={-1,1,0,0};\n    int px=0,py=0;\n    for(int x=0;x<s;x++){\n      for(int y=0;y<n[x];y++){\n\tint k=rd[e[x]];\n\tpx+=ax[k];\n\tpy+=ay[k];\n\tfor(int i=0;i<(1<<q);i++){\n\t  if(!dp[z][i]) continue;\n\t  for(int l=0;l<q;l++){\n\t    if((i>>l)&1) continue;\n\t    int j=i+(1<<l);\n\t    int tmp=min(hm,dp[z][i]+p[l]);\n\t    dp[z][j]=max(dp[z][j],tmp);\n\t    tmp-=dm[a[py][px]];\n\t    dp[z+1][j]=max(dp[z+1][j],tmp);\n\t  }\n\t  dp[z+1][i]=max(dp[z+1][i],dp[z][i]-dm[a[py][px]]);\n\t}      \n\tz++;\n      }\n    }\n    bool f=0;\n    for(int i=0;i<(1<<q);i++) f|=dp[z][i];\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\ntypedef vector<int> vi;\n\nconst string dir = \"URDL\";\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int Hini, Hmax;\n  while(cin >> Hini >> Hmax, Hini){\n    int h,w;\n    cin >> h >> w;\n    vector<string> g(h);\n    rep(i,h)cin >> g[i];\n\n    int cost[26] = {}, t;\n    cin >> t;\n    rep(i,t){\n      char c; int d;\n      cin >> c >> d;\n      cost[c-'A'] = d;\n    }\n\n    vi trap(1,0);\n    int s, x=0, y=0;\n    cin >> s;\n    rep(i,s){\n      char c; int n;\n      cin >> c >> n;\n      int d = dir.find(c);\n      rep(k,n){\n\tx += dx[d]; y += dy[d];\n\ttrap.push_back(cost[ g[y][x]-'A' ]);\n      }\n    }\n\n    int p;\n    cin >> p;\n    vi potion(p);\n    rep(i,p)cin >> potion[i];\n\n    vector<vi> dp(trap.size()+1, vi(1<<p,0));\n    dp[0][0] = Hini;\n\n    rep(i,trap.size()){\n      rep(bit,1<<p){\n\tint cur = dp[i][bit];\n\tif(cur==0)continue;\n\n\tchmax(dp[i+1][bit], cur-trap[i]);\n\trep(j,p){\n\t  if( (bit>>j)&1 )continue;\n\t  int nxt = min(cur+potion[j], Hmax);\n\t  chmax(dp[i+1][bit | (1<<j)], nxt - trap[i]);\n\t}\n      }\n    }\n    \n    bool f = false;\n    rep(bit,1<<p)f |= (dp[trap.size()][bit]>0);\n    cout << (f?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[1<<12];\npair<int,int> points[1010];\nint dp[2][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint cur=(i-1)%2;\n\t\t\t\tint nxt=(i)%2;\n\t\t\t\tdp[nxt][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)if(!((j>>k)&1))dp[nxt][j]=max(dp[nxt][j],min(hpMax,dp[nxt][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[nxt][j]=max(dp[nxt][j],dp[cur][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[nxt][j]<=0)dp[nxt][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[nxt][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main(){\n\tint dmg[26];\n\tstring mp[100];\n\tint HP, HPmax;\n\tint reg[12];\n\tint dp[2][1<<12];\n\twhile(cin >> HP >> HPmax, HP){\n\t\tint R, C; cin >> R >> C;\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tint T; cin >> T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tdmg[c-'A'] = d;\n\t\t}\n\t\tint S; cin >> S;\n\t\tvector<int> act;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tif(c=='U') act.push_back(0);\n\t\t\t\tif(c=='D') act.push_back(1);\n\t\t\t\tif(c=='R') act.push_back(2);\n\t\t\t\tif(c=='L') act.push_back(3);\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tfor(int i=0;i<P;i++) cin >> reg[i];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][(1<<P)-1] = HP;\n\t\tint x = 0, y = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<act.size();i++){\n\t\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\t\tx += dx[act[i]];\n\t\t\ty += dy[act[i]];\n\t\t\tint damage = dmg[mp[x][y]-'A'];\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tif(dp[cur][j] == 0) continue;\n\t\t\t\tif(dp[cur][j] > damage) dp[next][j] = max(dp[next][j], dp[cur][j]-damage);\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!(j&(1<<k))) continue;\n\t\t\t\t\tdp[cur][j^(1<<k)] = max(min(HPmax, dp[cur][j]+reg[k]), dp[cur][j^(1<<k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << (dp[cur][0] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main(){\n\tint dmg[26];\n\tstring mp[100];\n\tint HP, HPmax;\n\tint reg[12];\n\tint dp[2][1<<12];\n\twhile(cin >> HP >> HPmax, HP){\n\t\tint R, C; fin >> R >> C;\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tint T; cin >> T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tdmg[c-'A'] = d;\n\t\t}\n\t\tint S; cin >> S;\n\t\tvector<int> act;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tif(c=='U') act.push_back(0);\n\t\t\t\tif(c=='D') act.push_back(1);\n\t\t\t\tif(c=='R') act.push_back(2);\n\t\t\t\tif(c=='L') act.push_back(3);\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tfor(int i=0;i<P;i++) cin >> reg[i];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][(1<<P)-1] = HP;\n\t\tint x = 0, y = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<act.size();i++){\n\t\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\t\tx += dx[act[i]];\n\t\t\ty += dy[act[i]];\n\t\t\tint damage = dmg[mp[x][y]-'A'];\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tif(dp[cur][j] == 0) continue;\n\t\t\t\tif(dp[cur][j] > damage) dp[next][j] = max(dp[next][j], dp[cur][j]-damage);\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!(j&(1<<k))) continue;\n\t\t\t\t\tdp[cur][j^(1<<k)] = max(min(HPmax, dp[cur][j]+reg[k]), dp[cur][j^(1<<k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << (dp[cur][0] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define chmax(a,b) (a = max(a,b))\nusing namespace std;\ntypedef vector<int> vi;\n\nconst string dir = \"URDL\";\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int Hini, Hmax;\n  while(cin >> Hini >> Hmax, Hini){\n    int h,w;\n    cin >> h >> w;\n    vector<string> g(h);\n    rep(i,h)cin >> g[i];\n\n    int cost[26] = {}, t;\n    cin >> t;\n    rep(i,t){\n      char c; int d;\n      cin >> c >> d;\n      cost[c-'A'] = d;\n    }\n\n    vi trap;\n    int s, x=0, y=0;\n    cin >> s;\n    rep(i,s){\n      char c; int n;\n      cin >> c >> n;\n      int d = dir.find(c);\n      rep(k,n){\n\tx += dx[d]; y += dy[d];\n\ttrap.push_back(cost[ g[y][x]-'A' ]);\n      }\n    }\n\n    int p;\n    cin >> p;\n    vi potion(p);\n    rep(i,p)cin >> potion[i];\n\n    vector<vi> dp(trap.size()+1, vi(1<<p,0));\n    dp[0][0] = Hini;\n\n    rep(i,trap.size()){\n      rep(bit,1<<p){\n\tint cur = dp[i][bit];\n\tif(cur==0)continue;\n\n\tchmax(dp[i+1][bit], cur-trap[i]);\n\trep(j,p){\n\t  if( (bit>>j)&1 )continue;\n\t  int nxt = min(cur+potion[j], Hmax);\n\t  chmax(dp[i+1][bit | (1<<j)], nxt - trap[i]);\n\t}\n      }\n    }\n    \n    bool f = false;\n    rep(bit,1<<p)f |= (dp[trap.size()][bit]>0);\n    cout << (f?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint hpi,hpm,R,C,T,S,n[1010],P,p[19],x,y,dy[]={0,1,0,-1},dx[]={1,0,-1,0},dp[1<<12];\nchar a[110][110],d[1010],c;\nmap<char,int> M,m;\n\nint tc;\nint main(){\n\tm['R']=0,m['D']=1,m['L']=2,m['U']=3;\n\twhile(cin>>hpi>>hpm&&hpi){tc++;\n\t\tvi v;\n\t\tcin>>R>>C;\n\t\trep(i,R)cin>>a[i];\n\t\tcin>>T;\n\t\trep(i,T)cin>>c>>y,M[c]=y;\n\t\tcin>>S;\n\t\trep(i,S)cin>>d[i]>>n[i];\n\t\tcin>>P;\n\t\trep(i,P)cin>>p[i];\n\t\ty=x=0;\n\t\trep(i,S){\n\t\t\trep(j,n[i]){\n\t\t\t\ty+=dy[m[d[i]]],x+=dx[m[d[i]]];\n\t\t\t\tif(M[a[y][x]])v.pb(M[a[y][x]]);\n\t\t\t}\n\t\t}\n\t\tfill(dp,dp+(1<<P),-INF);\n\t\tdp[0]=hpi;\n\t\trep(i,v.sz)rep(j,1<<P)if(dp[j]>0){\n\t\t\trep(k,P)if(!(j&1<<k)){\n\t\t\t\tdp[j|1<<k]=max(dp[j|1<<k],min(hpm,dp[j]+p[k]));\n\t\t\t}\n\t\t\tdp[j]-=v[i];\n\t\t}\n\t\tcout<<(dp[(1<<P)-1]>0||!v.sz?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int infty = 1<<28;\nstatic int dp[1001][1<<12];\n\nint main()\n{\n  while(true){\n\n    int initHP;\n    int maxHP;\n    cin >> initHP >> maxHP;\n    if(initHP==0&&maxHP==0)break;\n\n    int R,C;\n    cin >> R >> C;\n    char M[R][C];\n    int damage[256];\n    for(int i = 0; i < R; ++i){\n      for(int j = 0; j < C; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    \n    int T;\n    cin >> T;\n    for(int i = 0; i < T; ++i){\n      char c;\n      int dam;\n      cin >> c >> dam;\n      damage[(int)c]=dam;\n    }\n    \n    int S;\n    cin >> S;\n    string inst;\n    for(int i = 0; i < S; ++i){\n      char c;\n      int step;\n      cin >> c >> step;\n      for(int j = 0; j < step; ++j){\n\tinst += c;\n      }\n    }\n\n    int P;\n    vector<int> potion;\n    cin >> P;\n    for(int i = 0; i < P; ++i){\n      int p;\n      cin >> p;\n      potion.push_back(p);\n    }\n\n    S = inst.length();\n    \n    int Pmax=1<<potion.size();\n    for(int i = 0; i < 1+S; ++i){\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i][j] = -infty;\n      }\n    }\n    dp[0][0]=initHP;\n    \n    int ni=0;\n    int nj=0;\n    for(int i = 0; i < S; ++i){\n      switch(inst[i]){\n      case 'D':++ni;break;\n      case 'U':--ni;break;\n      case 'R':++nj;break;\n      case 'L':--nj;break;\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tfor(int k = 0; k < (int)potion.size(); ++k){\n\t  if( (j&(1<<k)) == 0 ){\n\t    dp[i][j|(1<<k)] = max( dp[i][j|(1<<k)], min(maxHP, dp[i][j] + potion[k]) );\n\t  }\n\t}\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i+1][j] = max( dp[i+1][j], dp[i][j]-damage[(int)M[ni][nj]] );\n      }\n    }\n\n    int res = -infty;\n    for(int i = 0; i < Pmax; ++i){\n      res = max( res, dp[S][i] );\n    }\n    if(res>0)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n\n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n  \n  for(int i=0;i<m;i++){\n\n    for(int j=0;j<(1<<P);j++){\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\n\tnhp=max(0,nhp-cost[s[y[i+1]][x[i+1]]]);\n\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<char, int> pci;\nint life, maxi, r, c, t, s, p;\nvector<int> potion;\nmap<char, int> damage;\n \nvoid calcDP(vector<vector<int> > &dp, vector<string> &grid,\n            int nx, int ny, int x, int y, int trun){\n  for (int i = 0; i < (1<<p); i++) {\n    int next_life = dp[i][trun - 1];\n    if(next_life == 0)continue;\n    dp[i][trun] = max(dp[i][trun], next_life -\n                      damage[grid[ny][nx]]);\n    for (int j = 0; j < p; j++) {\n      if(i & (1<<j))continue;\n      next_life = min(maxi, next_life + potion[j]);\n      next_life -= damage[grid[ny][nx]];\n      dp[i + (1<<j)][trun] = max(dp[i + (1<<j)][trun],\n                                 next_life);\n    }\n  }\n}\n \nint main(){\n  while(std::cin >> life >> maxi, life){\n    std::cin >> r >> c;\n    vector<string> grid(r);\n    for (int i = 0; i < r; i++) {\n      std::cin >> grid[i];\n    }\n    std::cin >> t;\n    for (int i = 0; i < t; i++) {\n      char floor;\n      int d;\n      std::cin >> floor >> d;\n      damage[floor] = d;\n    }\n    std::cin >> s;\n    vector<pci> action(s);\n    int sum = 0;\n    for (int i = 0; i < s; i++) {\n      std::cin >> action[i].first >> action[i].second;\n      sum += action[i].second;\n    }\n    std::cin >> p;\n    for (int i = 0; i < p; i++) {\n      int tmp;\n      std::cin >> tmp;\n      potion.push_back(tmp);\n    }\n    vector<vector<int> > dp((1<<p), vector<int>(sum + 1, 0));\n    for (int i = 0; i < (1<<p); i++) {\n      dp[i][0] = life;\n      for (int j = 0; j < p; j++) {\n        if((i & (1<<j)) == 0)continue;\n        dp[i][0] = min(maxi, dp[i][0] + potion[j]);\n      }\n    }\n    int x = 0, y = 0;\n    map<char, int> dx, dy;\n    dx['U'] = 0;\n    dx['D'] = 0;\n    dx['R'] = 1;\n    dx['L'] = -1;\n    dy['U'] = -1;\n    dy['D'] = 1;\n    dy['R'] = 0;\n    dy['L'] = 0;\n    int trun = 0;\n    for (int i = 0; i < s; i++) {\n      for (int j = 0; j < action[i].second; j++) {\n        trun++;\n        int nx = x + dx[action[i].first],\n          ny = y + dy[action[i].first];\n        calcDP(dp, grid, nx, ny, x, y, trun);\n        x = nx, y = ny;\n      }\n    }\n    // for (int i = 0; i < (1<<p); i++) {\n    //   for (int j = 0; j <= sum; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    if(dp[(1<<p) - 1][sum] == 0){\n      std::cout << \"NO\" << std::endl; \n    }else{\n      std::cout << \"YES\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 13][1010];\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nbool solve() {\n\tint SS = step.size();\n\t\n\tvector< int > damage(SS);\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tdamage[i] = trap[grid[y][x]];\n\t}\n\t\n\tmemset(max_hp, -1, sizeof(max_hp));\n\t\n\tmax_hp[0][0] = HPinit;\n\t\n\tfor_(U,0,1<<P) for_(i,0,SS) {\n\t\tif (max_hp[U][i] == -1) continue;\n\t\t\n\t\tmaxUpdate(max_hp[U][i + 1], max_hp[U][i] - damage[i]);\n\t\t\n\t\tfor_(j,0,P) {\n\t\t\tif (U >> j & 1) continue;\n\t\t\tmaxUpdate(max_hp[U | 1 << j][i], max_hp[U][i] + p[j]);\n\t\t}\n\t}\n\t\n\tbool res = false;\n\tfor_(U,0,1<<P) res |= (max_hp[U][SS] > 0);\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 1; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] <= 0) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\\\n        for(int k : buff[P][j]) nextdp[j | k] = max(nextdp[j | k], min(malta, beet + add[k]));\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_R = 100;\nconst int MAX_C = 100;\nconst int MAX_S = 1000;\nconst int MAX_N = 1000;\nconst int MAX_SN = MAX_S * MAX_N;\nconst int MAX_P = 12;\nconst int MAX_BITS = 1 << MAX_P;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0 , 1};\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint flds[MAX_R][MAX_C];\nint trps[26], ptns[MAX_P], dmgs[MAX_SN], dp[MAX_BITS];\npii rts[MAX_S];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int h, hmax;\n    cin >> h >> hmax;\n    if (h == 0) break;\n\n    int r, c;\n    cin >> r >> c;\n\n    memset(trps, 0, sizeof(trps));\n\n    for (int y = 0; y < r; y++) {\n      string line;\n      cin >> line;\n      for (int x = 0; x < c; x++) flds[y][x] = line[x] - 'A';\n    }\n\n    int t;\n    cin >> t;\n\n    for (int i = 0; i < t; i++) {\n      char ch;\n      int d;\n      cin >> ch >> d;\n      trps[ch - 'A'] = d;\n    }\n\n    int s;\n    cin >> s;\n\n    for (int i = 0; i < s; i++) {\n      char ch;\n      cin >> ch >> rts[i].second;\n\n      switch (ch) {\n      case 'R': rts[i].first = 0; break;\n      case 'U': rts[i].first = 1; break;\n      case 'L': rts[i].first = 2; break;\n      case 'D': rts[i].first = 3; break;\n      }\n    }\n\n    int p, max_bits;\n    cin >> p;\n    max_bits = 1 << p;\n\n    for (int i = 0; i < p; i++) cin >> ptns[i];\n\n    int x = 0, y = 0;\n    int sn = 0;\n\n    for (int i = 0; i < s; i++) {\n      int di = rts[i].first;\n      int dx = dxs[di], dy = dys[di];\n      int ni = rts[i].second;\n\n      while (ni--) {\n\tx += dx, y += dy;\n\tdmgs[sn++] = trps[flds[y][x]];\n      }\n    }\n    //printf(\"sn=%d\\n\", sn);\n\n    for (int bits = 0; bits < max_bits; bits++) dp[bits] = 0;\n    dp[0] = h;\n\n    for (int i = 0; i < sn; i++) {\n      for (int bits = 0; bits < max_bits; bits++) {\n\tif (dp[bits] <= 0) continue;\n\tfor (int bi = 0; bi < p; bi++) {\n\t  int bits0 = bits | (1 << bi);\n\t  if (bits == bits0) continue;\n\t  int d = min(dp[bits] + ptns[bi], hmax);\n\t  if (dp[bits0] < d) dp[bits0] = d;\n\t}\n\n\tdp[bits] -= dmgs[i];\n      }\n    }\n\n    bool ok = false;\n    for (int bits = max_bits - 1; bits >= 0; bits--)\n      if (dp[bits] > 0) {\n\tok = true;\n\tbreak;\n      }\n\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*By pigeatshit*/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <cmath>\n#include <vector>\n#include <map>\n#define LL long long\n#define reset(c,x) memset (c, x, sizeof (c))\n#define PN printf(\"\\n\")\n#define NN int n;scanf(\"%d\", &n)\n#define NM int n,m;scanf(\"%d%d\", &n, &m)\n#define NMK int n,m,k;scanf(\"%d%d%d\", &n, &m, &k)\n\nusing namespace std;\n\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\n\nint judge(char c)\n{\n    if(c == 'U') return 0;\n    if(c == 'D') return 1;\n    if(c == 'L') return 2;\n    if(c == 'R') return 3;\n    return -1;\n}\n\nstruct MAZE\n{\n    char c;\n    int damage;\n} m[1005][1005];\n\nstruct S\n{\n    char dir;\n    int walk;\n} step[1005];\n\nint potion[20];\nint pflag[20];\n\nint cmp(const int &aa, const int &bb)\n{\n    return aa<bb?1:0;\n}\n\nint dp[20][1005];\n\nint main()\n{\n    int nowh,maxh;\n    scanf(\"%d%d\",&nowh,&maxh);\n    while(nowh != 0 || maxh != 0)\n    {\n        int mark = 0;\n        reset(pflag, 0);\n        int r,c;\n        scanf(\"%d%d\",&r,&c);\n//        getchar();\n        for(int i = 0; i < r; i++)\n        {\n            char st[1005];\n            scanf(\"%s\",st);\n            for(int j = 0; j < c; j++)\n            {\n                m[i][j].c = st[j];\n            }\n        }\n\n//        for(int i = 0; i < r; i++)\n//        {\n//            for(int j = 0; j < c; j++)\n//                printf(\"%c\",m[i][j].c);\n//            PN;\n//        }\n        int t;\n        scanf(\"%d\",&t);\n        while(t--)\n        {\n            char kind[3];\n            int dama;\n            scanf(\"%s\",kind);\n            scanf(\"%d\",&dama);\n            for(int i = 0; i < r; i++)\n                for(int j = 0; j < c; j++)\n                    if(m[i][j].c == kind[0]) m[i][j].damage = dama;\n        }\n        int s;\n        scanf(\"%d\",&s);\n        for(int i = 0; i < s; i++)\n        {\n            char tmp[3];\n            scanf(\"%s\",tmp);\n            step[i].dir = tmp[0];\n            scanf(\"%d\",&step[i].walk);\n        }\n\n        int p;\n        scanf(\"%d\",&p);\n        for(int i = 0; i < p; i++)\n            scanf(\"%d\",potion+i);\n\n        sort(potion, potion+p, cmp);\n\n        int posx = 0, posy = 0;\n        for(int i = 0; i < s; i++)\n        {\n            char dirc = step[i].dir;\n            int wak = step[i].walk;\n            int next = judge(dirc);\n            while(wak--)\n            {\n                struct MAZE posnow = m[posy + (dy[next])][posx + (dx[next])];\n                if(posnow.damage >= maxh)\n                {\n                    printf(\"NO\\n\");\n                    mark = 1;\n                    break;\n                }\n                if(nowh - posnow.damage > 0)\n                {\n                    posx = posx + (dx[next]);\n                    posy = posy + (dy[next]);\n                    nowh -= posnow.damage;\n                    continue;\n                }\n                int flag = 0;\n                int minn = 0x7FFFFFFF;\n                int rec = 0;\n                for(int choose = 1; choose < 1<<p; choose++)\n                {\n                    int sum = 0;\n                    for(int i = 0; i < p; i++)\n                    {\n                        int cc = (choose>>i)&1;\n                        if(cc == 1 && pflag[i] == 0) sum += potion[i];\n                    }\n                    if(sum + nowh - posnow.damage <= 0) continue;\n                    if(sum + nowh < minn)\n                    {\n                        minn = sum + nowh;\n                        rec = choose;\n                        flag = 1;\n                    }\n                }\n                if(flag == 1)\n                {\n                    for(int i = 0; i < p; i++)\n                    {\n                        int cc = (rec>>i)&1;\n                        if(cc == 1 && pflag[i] == 0)\n                            pflag[i] = 1;\n                    }\n                    nowh = min(maxh, minn) - posnow.damage;\n                    posx = posx + (dx[next]);\n                    posy = posy + (dy[next]);\n                }\n\n                if(flag == 0)\n                {\n                    printf(\"NO\\n\");\n                    mark = 1;\n                    break;\n                }\n                if(mark == 1) break;\n            }\n            if(mark == 1) break;\n        }\n\n        if(mark == 0) printf(\"YES\\n\");\n        scanf(\"%d%d\",&nowh,&maxh);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        if(beet >= 1) {\n          nextdp[j] = max(nextdp[j], beet);\n        } else {\n          for(int k : buff[P][j]) {\n            int get = min(malta, beet + add[k]);\n            if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n          }\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nmap<char,int> dmp;\n\nint dp[1010][9200];\nint main() {\n\tdmp['L'] = 0;\n\tdmp['D'] = 1;\n\tdmp['R'] = 2;\n\tdmp['U'] = 3;\n\twhile (1) {\n\t\tint init, amax; cin >> init >> amax;\n\t\tif (!init)break;\n\t\tint R, C; cin >> R >> C;\n\t\tvector<string>fi;\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfi.push_back(st);\n\t\t}\n\t\tint T; cin >> T;\n\t\tmap<char, int>mp;\n\t\tfor (int i = 0; i < T; ++i) {\n\t\t\tchar c; int a; cin >> c >> a;\n\t\t\tmp[c] = a;\n\t\t}\n\t\tint S; cin >> S;\n\n\t\tint nx = 0;\n\t\tint ny = 0;\n\t\tvector<int>damages;\n\t\tdamages.push_back(0);\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tchar c; int a;\n\t\t\tcin >> c >> a;\n\t\t\tint way = dmp[c];\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tnx += dx[way];\n\t\t\t\tny += dy[way];\n\t\t\t\tdamages.push_back(mp[fi[ny][nx]]);\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tvector<int>ps;\n\t\tfor (int i = 0; i < P; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tps.push_back(a);\n\t\t}\n\t\tsort(ps.begin(), ps.end());\n\t\treverse(ps.begin(), ps.end());\n\t\tfor (int i = 0; i < 1010; ++i) {\n\t\t\tfor (int j = 0; j < 9200; ++j) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = init;\n\t\tfor (int i = 0; i < damages.size(); ++i) {\n\t\t\tfor (int j = 0; j < 1 << P; ++j) {\n\t\t\t\tdp[i][j] -= damages[i];\n\t\t\t\tdp[i][j] = max(0, dp[i][j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 1 << P; ++j) {\n\t\t\t\tif (dp[i][j]) {\n\n\t\t\t\t\tbitset<12>bs(j);\n\t\t\t\t\tfor (int k = 0; k < P; ++k) {\n\t\t\t\t\t\tif (!bs[k]) {\n\t\t\t\t\t\t\tbs[k] = true;\n\t\t\t\t\t\t\tdp[i][bs.to_ulong()] = max(dp[i][bs.to_ulong()], min(dp[i][j] + ps[k], amax));\n\t\t\t\t\t\t\tbs[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 1 << P; ++j) {\n\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n\t\tstring ok = \"NO\";\n\t\tfor (int i = damages.size(); true; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j < 1 << P; ++j) {\n\t\t\t\tif (dp[i][j]>0) {\n\t\t\t\t\tok = \"YES\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nint HP, w, h;\nvector<string> a;\n// D[c] := 文字 c に対応する受けるダメージ数\nint D[256] = {0};\n\n// f[c] := 文字 c ('U','D','L','R') に対応する向き 0..3 を返す.\nint f[256] = {0};\n// 4近傍\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// dp[k][bits] := k 回目の移動で現在の使ったポーションの状態 bits のときの最大の残り HP\nint dp[1001][1<<12];\n\nint main(){\n\tf['U'] = 0; f['D'] = 1; f['L'] = 2; f['R'] = 3;\n\tint hp;\n\t\n\twhile( cin >> hp >> HP, hp || HP ){\n\t\tcin >> h >> w;\n\t\ta = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> a[y];\n\t\t}\n\t\tint T, S, P;\n\t\tcin >> T;\n\t\tfor(int i=0 ; i < T ; i++ ){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tD[c] = d;\n\t\t}\n\t\tcin >> S;\n\t\tvector<char> dir(S);\n\t\tvector<int> N(S);\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tcin >> dir[i] >> N[i];\n\t\t}\n\t\tcin >> P;\n\t\tvector<int> p(P);\n\t\tfor(int i=0 ; i < P ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t// 各ステップで何ダメージ受けるか計算\n\t\tvector<int> damege;\n\t\tint x=0, y=0;\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0 ; j < N[i] ; j++ ){\n\t\t\t\tx = x + dx[f[dir[i]]];\n\t\t\t\ty = y + dy[f[dir[i]]];\n\t\t\t\tsum += D[a[y][x]];\n\t\t\t}\n\t\t\tdamege.push_back( sum );\n\t\t}\n\t\t\n\t\t// dp の初期化\n\t\tfor(int i=0 ; i < 1001 ; i++ ){\n\t\t\tfor(int j=0 ; j < (1<<12) ; j++ ){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = hp;\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tfor(int j = (1<<P)-1 ; j >= 0 ; j-- ){\n\t\t\t\tif( dp[i][j] <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tfor(int k=0 ; k < P ; k++ ){\n\t\t\t\t\tif( j & (1<<k) ) continue;\n\t\t\t\t\t\n\t\t\t\t\tint next = j | (1<<k);\n\t\t\t\t\tint nextHP = min(HP, dp[i][next] + p[k] );\n\t\t\t\t\tdp[i][next] = max(dp[i][next], nextHP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0 ; j < (1<<P) ; j++ ){\n\t\t\t\tif( dp[i][j] <= 0 ) continue;\n\t\t\t\tint nextHP = dp[i][j] - damege[i];\n\t\t\t\tdp[i+1][j] = max(dp[i+1][j], nextHP);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0 ; i < (1<<P) ; i++ ){\n\t\t\tans = max(ans, dp[S][i]);\n\t\t}\n\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<map>\n#include<queue>\nusing namespace std;\nint hp,hpm;\nchar ma[110][110];\nint potion[1010];\nint damage[27];\nint rution[1010];\nchar rel[10];\nint r,c;\nbool cmp(int a,int b){return a>b;}\nstruct dir\n{\n    int x,y;\n};\ndir R,D,U,L;\nint T,S;\nint main()\n{\n    int i,j,k,l;\n    R.x=1;R.y=0;\n    L.x=-1;L.y=0;\n    U.x=0;U.y=-1;\n    D.x=0;D.y=1;\n    int nowx,nowy;\n    while(scanf(\"%d%d\",&hp,&hpm)==2)\n    {\n        if(hp==0&&hpm==0)break;\n        scanf(\"%d%d\",&r,&c);\n        gets(ma[0]);\n        for(i=0;i<r;i++)\n            gets(ma[i]);\n            memset(damage,0,sizeof(damage));\n        scanf(\"%d\",&T);\n        printf(\"%d\\n\",T);\n        for(i=1;i<=T;i++)\n        {\n            char ch;\n            int zhi;\n            gets(rel);\n            scanf(\"%c %d\",&ch,&zhi);\n            printf(\"%c %d\\n\",ch,zhi);\n           damage[ch-'A']=zhi;\n        }\n        scanf(\"%d\",&S);\n        nowx=nowy=0;\n        int step=0;\n        while(S--)\n        {\n            int num;\n            char dirc;\n            gets(rel);\n            scanf(\"%c %d\",&dirc,&num);\n            if(dirc=='R')\n            {\n                for(i=1;i<=num;i++)\n                {\n                    nowx+=R.x;\n                    nowy+=R.y;\n                    rution[++step]=damage[ma[nowy][nowx]-'A'];\n\n                }\n            }\n            if(dirc=='L')\n            {\n                for(i=1;i<=num;i++)\n                {\n                    nowx+=L.x;\n                    nowy+=L.y;\n                    rution[++step]=damage[ma[nowy][nowx]-'A'];\n\n                }\n            }\n            if(dirc=='U')\n            {\n                for(i=1;i<=num;i++)\n                {\n                    nowx+=U.x;\n                    nowy+=U.y;\n                    rution[++step]=damage[ma[nowy][nowx]-'A'];\n\n                }\n            }\n            if(dirc=='D')\n            {\n                for(i=1;i<=num;i++)\n                {\n                    nowx+=D.x;\n                    nowy+=D.y;\n                    rution[++step]=damage[ma[nowy][nowx]-'A'];\n                }\n            }\n        }\n        scanf(\"%d\",&T);\n        for(i=0;i<T;i++)\n        scanf(\"%d\",&potion[i]);\n        int flag=1;\n        for(i=0;i<=step;i++)\n        {\n            if(hp<=0){flag=0;break;}\n            if(hp-rution[i]<=0)\n            {\n                sort(potion,potion+T,cmp);\n                int pos;\n                for(j=0;j<T&&potion[j]>0;j++)\n                {  pos=j;\n                    if(hp+potion[j]<=hpm)\n                 {\n                    break;\n                 }\n                }\n                hp+=potion[pos];\n                if(hp>hpm)hp=hpm;\n                potion[pos]=0;\n            }\n            hp-=rution[i];\n        }\n        if(flag)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\nint mod=1e9+7;\n\nsigned main(){\n  while(true){\n    int hp,hpm;\n    cin>>hp>>hpm;\n    if(hp==0&&hpm==0)break;\n    int h,w;\n    cin>>h>>w;\n    vector<string> a(h);\n    for(int i=0;i<h;i++)cin>>a[i];\n    int t;\n    cin>>t;\n    map<char,int> d;\n    for(int i=0;i<t;i++){\n      char c;\n      int e;\n      cin>>c>>e;\n      d[c]=e;\n    }\n    int s;\n    cin>>s;\n    vector<pair<char,int> > udlr(s);\n    for(int i=0;i<s;i++){\n      char c;\n      int e;\n      cin>>c>>e;\n      udlr[i]=make_pair(c,e);\n    }\n    int P;\n    cin>>P;\n    vector<int> p(P);\n    for(int i=0;i<P;i++)cin>>p[i];\n    vector<int> road;\n    int x=0;\n    int y=0;\n    for(int i=0;i<s;i++){\n      for(int j=0;j<udlr[i].second;j++){\n        if(udlr[i].first=='U')y--;\n        if(udlr[i].first=='D')y++;\n        if(udlr[i].first=='L')x--;\n        if(udlr[i].first=='R')x++;\n        road.push_back(d[a[y][x]]);\n      }\n    }\n    vector<vector<int> > dp(1010,vector<int>(4096+10,-1e9));\n    dp[0][0]=hp;\n    for(int i=0;i<road.size();i++){\n      for(int j=0;j<=(1<<P);j++){\n        if(dp[i][j]>0){\n          for(int k=0;k<P;k++){\n            if(!(j&(1<<k))){\n              dp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],min(dp[i][j]+p[k],hpm));\n            }\n          }\n          dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n        }\n      }\n      for(int j=0;j<=(1<<P);j++)dp[i+1][j]-=road[i];\n    }\n\n    bool f=false;\n    for(int i=0;i<(1<<P);i++)if(dp[road.size()][i]>0)f=true;\n    if(f)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb push_back\n\nconst int N = 1010;\nconst int M = 12;\nconst int inf = -inf;\n\nint dp[N][1<<M];\n\nbool solve(int n,int *damage,int m,int *portion,int hpini,int hpmax){\n  rep(i,n)rep(j,(1<<m))dp[i][j]=-inf;\n  dp[0][0]=hpini;\n\n  rep(i,n){\n    rep(j,(1<<m)){\n      if (i)dp[i][j]=max(dp[i-1][j]-damage[i],dp[i][j]);\n      if (dp[i][j] <= 0)continue;\n      //cout << i <<\" \" << j << \" \" << dp[i][j] << endl;\n      rep(k,m){\n\tif ((1<<k)&j)continue;\n\tdp[i][j|(1<<k)]=min(hpmax,max(dp[i][j]+portion[j],dp[i][j|(1<<k)]));\n      }\n    }\n  }\n  rep(i,(1<<m))if (dp[n-1][i] > 0)return true;\n  return false;\n}\n\n\nchar m[100][100];//convert to damage\n//DURL\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid make(vector<int> path,int *damage){\n  int x=0,y=0;\n  rep(i,path.size()){\n    y+=dy[path[i]];\n    x+=dx[path[i]];\n    damage[i+1]=m[y][x];\n  }\n}\n\nmain(){\n  int hpini,hpmax;\n  int damage[N];\n  int portion[M];\n  map<char,int> MAP;\n  while(cin>>hpini >>hpmax && hpmax){\n    int r,c;\n    cin>>r>>c;\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    \n    int ns;\n    cin>>ns;\n    rep(i,ns){\n      char tmp;int a;\n      cin>>tmp>>a;\n      MAP[tmp]=a;\n    }\n    rep(i,r)rep(j,c)m[i][j]=MAP[m[i][j]];\n\n    vector<int> path;\n    int pnum;\n    cin>>pnum;\n    rep(i,pnum){\n      char tmp;int cnt;\n      cin>>tmp>>cnt;\n      int ins;\n      if (tmp == 'D')ins=0;\n      if (tmp == 'U')ins=1;\n      if (tmp == 'R')ins=2;\n      if (tmp == 'L')ins=3;\n      rep(j,cnt)path.pb(ins);\n    }\n\n    int po;\n    cin>>po;\n    rep(i,po)cin>>portion[i];\n\n    make(path,damage);\n\n    //    rep(i,po)cout << portion[i] <<\" \" ;cout << endl;\n    //    rep(i,path.size()+1)cout << damage[i]<<\" \" ;cout << endl;\n\n    if (solve(path.size()+1,damage,po,portion,hpini,hpmax))cout <<\"YES\"<<endl;\n    else cout <<\"NO\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 15][1010];\n\nbool solve() {\n\tint HP = HPinit;\n\t\n\tmultiset< int > pset;\n\tfor_(i,0,P) pset.insert(p[i]);\n\t\n\tint SS = step.size();\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tchar t = grid[y][x];\n\t\tint dmg = trap[t];\n\t\tint nHP = HP - dmg;\n\t\t\n\t\twhile (nHP <= 0) {\n\t\t\tif (pset.empty()) return false;\n\t\t\t\n\t\t\tauto it = pset.upper_bound(-nHP);\t\t\n\t\t\tif (it == pset.end()) --it;\n\t\t\t\n\t\t\tnHP += (*it);\n\t\t\tpset.erase(it);\n\t\t}\n\t\t\n\t\tHP = nHP;\n\t}\n\t\n\treturn true;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 13][1010];\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nbool solve() {\n\tint SS = step.size();\n\t\n\tvector< int > damage(SS);\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tdamage[i] = trap[grid[y][x]];\n\t}\n\t\n\tmemset(max_hp, -1, sizeof(max_hp));\n\t\n\tmax_hp[0][0] = HPinit;\n\t\n\tfor_(U,0,1<<P) for_(i,0,SS) {\n\t\tif (max_hp[U][i] <= 0) continue;\n\t\t\n\t\tmaxUpdate(max_hp[U][i + 1], max_hp[U][i] - damage[i]);\n\t\t\n\t\tfor_(j,0,P) {\n\t\t\tif (U >> j & 1) continue;\n\t\t\tmaxUpdate(max_hp[U | 1 << j][i], min(HPmax, max_hp[U][i] + p[j]));\n\t\t}\n\t}\n\t\n\tbool res = false;\n\tfor_(U,0,1<<P) res |= (max_hp[U][SS] > 0);\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 108\nint dp[M*10][5000];\nchar map1[M][M];\nint a[M];\nint b[M*100];\nint c[M];\nint n,m;\nint my_hash[M];\nint o[4][2]={\n    0,-1,\n    1,0,\n    0,1,\n    -1,0\n};\nint min(int x,int y){\n    if(x>y) return y;return x;\n}\nint max(int x,int y){\n    if(x<y) return y;return x;\n}\nint main(){\n    int sp,tmax;\n    while(~scanf(\"%d%d\",&sp,&tmax)&&(sp+tmax)){\n        scanf(\"%d%d\",&n,&m);\n        for(int i=0;i<n;i++)scanf(\"%s\",&map1[i]);\n        int n1;scanf(\"%d\",&n1);\n        for(int i=0;i<n1;i++){\n            char str[100];\n            int t1;scanf(\"%s%d\",str,&t1);\n            my_hash[str[0]-'A']=t1;\n        }\n        int m1;scanf(\"%d\",&m1);\n        int sx=0,sy=0;\n        int num=1;\n        memset(b,0,sizeof(b));\n        for(int i=0;i<m1;i++){\n            char str[20];int m2;\n            scanf(\"%s%d\",str,&m2);\n            int oo;\n            if(str[0]=='U') oo=3;\n            else if(str[0]=='R') oo=2;\n            else if(str[0]=='D') oo=1;\n            else if(str[0]=='L') oo=0;\n            for(int i=0;i<m2;i++){\n                sx=sx+o[oo][0];\n                sy=sy+o[oo][1];\n                int t1=map1[sx][sy]-'A';\n                b[num++]=my_hash[t1];\n            }\n        }\n//        puts(\"@@@@@@@@@\");\n        int n2;scanf(\"%d\",&n2);\n        for(int i=0;i<n2;i++){\n            scanf(\"%d\",&c[i]);\n        }\n//        for(int i=0;i<num;i++){\n//            printf(\"%d \",b[i]);\n//        }\n//        printf(\"%d!!!\\n\",num);\n//        puts(\"\");\n        memset(dp,0,sizeof(dp));\n        int t2=1<<n2;\n        t2--;\n//        printf(\"%d\\n\",t2);\n        dp[0][t2]=sp;\n        for(int i=0;i<num-1;i++){\n            for(int j=t2;j>=0;j--){\n                if(dp[i][j]<=0) continue;\n                if(dp[i][j]<=b[i+1]){\n//                    printf(\"%d!!!!!\\n\",b[i+1]);\n                    for(int k=0;k<n2;k++){\n                        if(j&(1<<k)){\n                            int tt=j^(1<<k);\n                            int t1=min(tmax,dp[i][j]+c[k]);\n                            dp[i][tt]=max(t1,dp[i][tt]);\n                        }\n                    }\n                }\n                else{\n                    int t1=dp[i][j]-b[i+1];\n                    dp[i+1][j]=max(dp[i+1][j],t1);\n                }\n            }\n        }\n        int flag=0;\n        for(int i=0;i<=t2;i++){\n            if(dp[num-1][i]>0) flag=1;\n//            printf(\"%d  !!\\n\",dp[num-1][i]);\n        }\n        if(flag) puts(\"YES\");else puts(\"NO\");\n    }\n    return 0;\n}\n/*\n1 10\n3 3\nAAA\nCAA\nCBC\n3\nA 0\nB 10000\nC 9\n3\nD 2\nR 1\nU 2\n5\n4\n4\n4\n4\n4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int ALP = 26;\n\nconst int N = 1010;\nint dp[N][1<<12];\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int hp_i, hp_m;\n    while(cin >>hp_i >>hp_m, hp_i){\n        int h,w;\n        cin >>h >>w;\n        vector<string> s(h);\n        rep(i,h) cin >>s[i];\n\n        int T;\n        cin >>T;\n        vector<int> trap(ALP,0);\n        rep(i,T){\n            char c;\n            int d;\n            cin >>c >>d;\n            trap[c-'A'] = d;\n        }\n\n        int S;\n        cin >>S;\n        vector<int> damage;\n        int px = 0, py = 0;\n        rep(i,S){\n            char c;\n            int d;\n            cin >>c >>d;\n            while(d--){\n                if(c=='U') --py;\n                if(c=='D') ++py;\n                if(c=='L') --px;\n                if(c=='R') ++px;\n                damage.pb(trap[s[py][px]-'A']);\n            }\n        }\n\n        int P;\n        cin >>P;\n        vector<int> p(P);\n        rep(i,P) cin >>p[i];\n\n        int SZ = damage.size();\n        memset(dp,0,sizeof(dp));\n        dp[0][0] = hp_i;\n        rep(i,SZ)rep(mask,1<<P)if(dp[i][mask]>0){\n            // move\n            dp[i+1][mask] = max(dp[i+1][mask], dp[i][mask]-damage[i]);\n\n            // use potion\n            rep(j,P)if(!(mask>>j&1)){\n                int nmask = mask | (1<<j);\n                dp[i][nmask] = max(dp[i][nmask], min(hp_m, dp[i][mask]+p[j]) );\n            }\n        }\n\n        string ans = \"NO\";\n        if(dp[SZ][(1<<P)-1]>0) ans = \"YES\";\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\t\tvi;\ntypedef\tvector<vi>\t\tvvi;\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int hpinit,hpmax;scanf(\"%d%d\",&hpinit,&hpmax),hpinit;){\n\t\tint m,n,tmp;\tscanf(\"%d%d\",&m,&n);\n\n\t\tvvi trap(m,vi(n));\n\t\t{\n\t\t\tchar a[100][101];\n\t\t\trep(i,m)\tscanf(\"%s\",a+i);\n\t\t\tint tmp;\tscanf(\"%d \",&tmp);\n\t\t\tint f[128];\n\t\t\trep(i,tmp){\n\t\t\t\tchar ch;\n\t\t\t\tint dmg;\tscanf(\"%c%d \",&ch,&dmg);\n\t\t\t\tf[ch]=dmg;\n\t\t\t}\n\t\t\trep(i,m)rep(j,n)\ttrap[i][j]=f[a[i][j]];\n\t\t}\n\n\t\tscanf(\"%d \",&tmp);\n\t\tvector<pii> step(tmp);\n\t\trep(i,tmp){\n\t\t\tchar ch;\n\t\t\tint d;\tscanf(\"%c%d \",&ch,&d);\n\t\t\tchar f[128];\n\t\t\tf['R']=0,f['U']=1,f['L']=2,f['D']=3;\n\t\t\tstep[i]=mp(d,f[ch]);\n\t\t}\n\t\tstep.pb(mp(1,0));\t// dummy\n\n\t\tint psize;\tscanf(\"%d\",&psize);\n\t\tvi por(psize);\n\t\trep(i,psize)\tscanf(\"%d\",&por[i]);\n\n\t\tvi cure(1<<psize);\n\t\trep(i,1<<psize)rep(j,psize){\n\t\t\tif(i&(1<<j))\tcure[i]+=por[j];\n\t\t}\n\n\t\tint x=0,y=0;\n\t\tvi hp(1<<psize,hpinit);\n\t\trep(t,step.size())rep(k,step[t].first){\n\t\t\tint dmg=trap[y][x];\n\t\t\trep(i,1<<psize){\n\t\t\t\tif(hp[i]<=0)\tcontinue;\n\t\t\t\thp[i]-=dmg;\n\t\t\t\tif(hp[i]<=0){\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif((j&i)==j){\t// stat j is a subset of stat i\n\t\t\t\t\t\t\thp[j]=max(hp[j],min(hp[i]+cure[i&~j],hpmax));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dir=step[t].second;\n\t\t\tx+=dx[dir];\ty+=dy[dir];\n\t\t}\n\n\t\tbool ok=false;\n\t\trep(i,1<<psize) if(hp[i]>0){ ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][1<<12];\nsigned main(){\n  int hi,hm;\n  while(cin>>hi>>hm,hi||hm){\n    int r,c;\n    cin>>r>>c;\n    string a[r];\n    for(int i=0;i<r;i++) cin>>a[i];\n    int t;\n    cin>>t;\n    char b[t];\n    int d[t];\n    for(int i=0;i<t;i++) cin>>b[i]>>d[i];\n    int s;\n    cin>>s;\n    char e[s];\n    int n[s];\n    for(int i=0;i<s;i++) cin>>e[i]>>n[i];\n    int q;\n    cin>>q;\n    int p[q];\n    for(int i=0;i<q;i++) cin>>p[i];\n    //puts(\"OK\");\n    map<char,int> dm;\n    for(int i=0;i<t;i++) dm[b[i]]=d[i];\n    string udlr=\"UDLR\";\n    map<char,int> rd;\n    for(int i=0;i<(int)udlr.size();i++) rd[udlr[i]]=i;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hi;\n    int z=0;\n    int ax[]={0,0,-1,1};\n    int ay[]={-1,1,0,0};\n    int px=0,py=0;\n    for(int x=0;x<s;x++){\n      for(int y=0;y<n[x];y++){\n\tint k=rd[e[x]];\n\tpx+=ax[k];\n\tpy+=ay[k];\n\t//cout<<px<<\" \"<<py<<endl;\n\tfor(int i=0;i<(1<<q);i++){\n\t  if(!dp[z][i]) continue;\n\t  for(int l=0;l<q;l++){\n\t    if((i>>l)&1) continue;\n\t    int j=i+(1<<l);\n\t    int tmp=min(hm,dp[z][i]+p[l]);\n\t    dp[z][j]=max(dp[z][j],tmp);\n\t    tmp-=dm[a[py][px]];\n\t    if(tmp<=0) continue;\n\t    dp[z+1][j]=max(dp[z+1][j],tmp);\n\t  }\n\t}      \n\tz++;\n      }\n    }\n    bool f=0;\n    for(int i=0;i<(1<<q);i++) f|=dp[z][i];\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nchar str[120][120],ch[10];\nint  sa[30], po[1010];\nint  hpi, hpm;\nint  r, c, num, t, s, pnum;\nstruct node\n{\n     int step;\n     char di[10];\n}p[1010];\n\nbool  GetAns()\n{\n      int x = 0, y = 0;\n      for(int i = 0; i < s; i ++)\n      {\n             int sum = 0;\n             if(p[i].di[0] == 'U')\n             {\n                 for(int j = x-1; j >= x - p[i].step ;j --)\n                 {\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x -= p[i].step;\n             }\n             if(p[i].di[0] == 'D')\n             {\n                 for(int j = x+1; j <= x + p[i].step ;j ++)\n                 {\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x += p[i].step;\n             }\n             if(p[i].di[0] == 'L')\n             {\n                 for(int j = y-1; j >= y - p[i].step ;j --)\n                 {\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 }\n                  y -= p[i].step;\n             }\n             if(p[i].di[0] == 'R')\n             {\n                 for(int j = y+1; j <= y + p[i].step ;j ++)\n                 {\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 }\n                  y += p[i].step;\n             }\n             \n             bool f = false;\n             if(hpi >= sum)\n             {\n                   hpi -= sum;\n                   f = true;\n                   continue;\n             }\n             for(int j = 0; j < pnum; j ++)\n             {\n                    int tmp = min(hpm, hpi + po[j]);\n                    if(tmp >= sum)\n                    {\n                         hpi = tmp - sum;\n                         f = true;\n                         po[j] = 0;\n                         break;\n                    }\n             }\n             if(!f) return false;\n\n      }\n      if(hpi <= 0) return false;\n      return true;\n}\nint  main()\n{\n     while(~scanf(\"%d %d\", &hpi, &hpm) && hpi+hpm)\n     {\n           scanf(\"%d %d\", &r, &c);\n           for(int i = 0; i < r; i++)\n           {\n                   scanf(\"%s\", str[i]);\n           }\n           scanf(\"%d\", &t);\n           for(int i = 0; i < t; i ++)\n           {\n                   scanf(\"%s %d\", ch, &num);\n                   int tmp = ch[0] - 'A';\n                   sa[tmp] = num;\n           }\n           scanf(\"%d\", &s);\n           for(int i = 0; i < s; i ++)\n           {\n                   scanf(\"%s %d\", p[i].di, &p[i].step);\n           }\n           scanf(\"%d\", &pnum);\n           for(int i = 0; i < pnum; i ++)\n           {\n                  scanf(\"%d\", &po[i]);\n           }\n           sort(po, po+pnum);\n           bool flag= GetAns();\n           if(flag)\n                   printf(\"YES\\n\");\n           else\n                   printf(\"NO\\n\");\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tconstexpr int dx[] = {-1, 0, 1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tint dir[128];\n\tdir['L'] = 0;\n\tdir['D'] = 1;\n\tdir['R'] = 2;\n\tdir['U'] = 3;\n\t\n\tfor(int HP_init, HP_max; cin >> HP_init >> HP_max && HP_init;) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tint t;\n\t\tcin >> t;\n\n\t\tint damage[128] = {};\n\t\tfor(int i = 0; i < t; ++i) {\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdamage[c] = d;\n\t\t}\n\n\t\tint s;\n\t\tcin >> s;\n\n\t\tvector<pair<int, int>> moves;\n\t\tvector<pair<int, int>> pos{{0, 0}};\n\n\t\tmoves.reserve(s);\n\t\tpos.reserve(s + 1);\n\n\t\tfor(int i = 0; i < s; ++i) {\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tcin >> c >> n;\n\n\t\t\tconst int d = dir[c];\n\t\t\tconst int x = pos.back().first + dx[d] * n;\n\t\t\tconst int y = pos.back().second + dy[d] * n;\n\t\t\tmoves.emplace_back(d, n);\n\t\t\tpos.emplace_back(x, y);\n\t\t}\n\n\t\tint p;\n\t\tcin >> p;\n\n\t\tvector<int> potions(p);\n\t\tfor(auto &e : potions) cin >> e;\n\n\t\tvector<vector<int>> dp(s + 1, vector<int>(1 << p, 0));\n\t\tdp[0][0] = HP_init;\n\n\t\tfor(int i = 0; i < s; ++i) {\n\t\t\tconst int d = moves[i].first;\n\t\t\tconst int n = moves[i].second;\n\t\t\tconst int x = pos[i].first;\n\t\t\tconst int y = pos[i].second;\n\n\t\t\tint dec = 0;\n\t\t\tint cx = x, cy = y;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tcx += dx[d];\n\t\t\t\tcy += dy[d];\n\t\t\t\tdec += damage[field[cy][cx]];\n\t\t\t}\n\n\t\t\tfor(int used = 0; used < (1 << p); ++used) {\n\t\t\t\tif(dp[i][used] == 0) continue;\n\n\t\t\t\tchmin(dp[i][used], HP_max);\n\t\t\t\tfor(int j = 0; j < p; ++j) {\n\t\t\t\t\tif(!(used & (1 << j))) {\n\t\t\t\t\t\tchmax(dp[i][used | (1 << j)], dp[i][used] + potions[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchmax(dp[i + 1][used], dp[i][used] - dec);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dp[s][(1 << p) - 1] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint Hi,HMAX,h,w,N,n,m,dp[1009][1<<12],A[22];\nvector<int>sum;\nmap<char,int>M;\nstring s[1111];\nint main(){\n    while(cin>>Hi>>HMAX,Hi){\n        sum.clear();\n        int X=0,Y=0;\n        M.clear();\n        cin>>h>>w;\n        r(i,h)cin>>s[i];\n        cin>>m;\n        r(i,m){\n            char c;\n            int x;\n            cin>>c>>x;\n            M[c]=x;\n        }\n        cin>>N;\n        r(i,N){\n            char c;\n            int x;\n            cin>>c>>x;\n            while(x--){\n                if(c=='U')Y--;\n                if(c=='D')Y++;\n                if(c=='R')X++;\n                if(c=='L')X--;\n                sum.push_back(M[s[Y][X]]);\n            }\n        }\n        cin>>n;\n        r(i,n){\n            cin>>A[i];\n        }\n        memset(dp,0,sizeof(dp));\n        dp[0][0]=Hi;\n        for(int i=0;i<sum.size();i++){\n            for(int j=0;j<(1<<n);j++){\n                if(dp[i][j]<=0)continue;\n                for(int k=0;k<n;k++){\n                    if((1<<k)&j)continue;\n                    dp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],min(HMAX,dp[i][j]+A[k]));\n                }\n            }\n            for(int j=0;j<(1<<n);j++){\n                dp[i+1][j]=dp[i][j]-sum[i];\n            }\n        }\n        bool ANS=0;\n        r(i,(1<<n)){\n            if(dp[sum.size()][i]>0)ANS=1;\n        }\n        cout<<(ANS?\"YES\":\"NO\")<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        if(dp[j] - damage[A[yy][xx]] >= 1) {\n          nextdp[j] = max(nextdp[j], dp[j] - damage[A[yy][xx]]);\n        }\n        for(int k : buff[P][j]) {\n          int get = min(malta, dp[j] + add[k]) - damage[A[yy][xx]];\n          if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=-(1<<27);\n\nint damage[30];\n\nint low,high;\n\nint line,row;\nchar map[110][110];\n\nchar str[3];\n\nint val[1100];\nint total;\n\nint power[13];\nint sum;\n\nint dp[2][4300];\nint main()\n{\n\twhile(scanf(\"%d%d\",&low,&high))\n\t{\n\t\tif(0==low&&0==high)break;\n\t\t\n\t\tscanf(\"%d%d\",&line,&row);\n\t\t\n\t\tint i,j,k;\n\t\tfor(i=0;i<line;i++)scanf(\"%s\",map[i]);\n\t\t\n\t\tint temp,num;\n\t\tscanf(\"%d\",&temp);\n\t\tfor(i=0;i<temp;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",str,&num);\n\t\t\tdamage[str[0]-'A']=num;\n\t\t}\n\t\t\n\t\tint nowx=0,nowy=0;\n\t\ttotal=0;\n\t\t\n\t\tscanf(\"%d\",&temp);\n\t\tfor(i=0;i<temp;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",str,&num);\n\t\t\tfor(j=0;j<num;j++)\n\t\t\t{\n\t\t\t\tif(str[0]=='D')nowx++;\n\t\t\t\telse if(str[0]=='R')nowy++;\n\t\t\t\telse if(str[0]=='L')nowy--;\n\t\t\t\telse if(str[0]=='U')nowx--;\n\t\t\t\tval[total++]=damage[map[nowx][nowy]-'A'];\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<total;i++)printf(\"%d \",val[i]);printf(\"\\n\");\n\t\t\n\t\tscanf(\"%d\",&sum);\n\t\tfor(i=0;i<sum;i++)scanf(\"%d\",&power[i]);\n\t\t\n\t\tint last=0,now=1;\n\t\tnum=(1<<sum);\n\t\tfor(i=0;i<num;i++)dp[last][i]=low;\n\t\t\n\t\tfor(i=0;i<total;i++)\n\t\t{\n\t\t\tfor(j=0;j<num;j++){dp[now][j]=dp[last][j];}\n\t\t\tfor(k=0;k<sum;k++)\n\t\t\t{\n\t\t\t\ttemp=(1<<k);\n\t\t\t\tfor(j=0;j<num;j++)\n\t\t\t\t{\n\t\t\t\t\tif(temp&j)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[now][j]=max(dp[now][j],dp[now][j-temp]+power[k]);\n\t\t\t\t\t\tdp[now][j]=min(dp[now][j],high);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<num;j++)\n\t\t\t{\n\t\t\t\tdp[now][j]-=val[i];\n\t\t\t\tif(dp[now][j]<0)dp[now][j]=INF;\n\t\t\t}\n\t\t\tnow^=1;\n\t\t\tlast^=1;\n\t\t}\n\t\tbool judge=false;\n\t\tfor(j=0;j<num;j++)\n\t\t{\n\t\t\tif(dp[last][j]>0)\n\t\t\t{\n\t\t\t\tjudge=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(judge)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass route{\npublic:\n  char c;\n  int n;\n};\n\nint main(){\n  int hp,hpmax;\n  while(cin >> hp >> hpmax && hp && hpmax){\n    int h,w,t,s,pp,a[100][100],p[100],dp[2][1<<12];\n    string str[100];\n    bool ans = true;\n    vector<route> v;\n    cin >> h >> w;\n    for(int i=0;i<h;i++) cin >> str[i];\n    cin >> t;\n    for(int k=0;k<t;k++){\n      int n;\n      char c;\n      cin >> c >> n;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++) if(str[i][j] == c) a[i][j] = n;\n      }\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      route r;\n      cin >> r.c >> r.n;\n      v.push_back(r);\n    }\n    cin >> pp;\n    for(int i=0;i<pp;i++) cin >> p[i];\n\n    int x = 0, y = 0;\n    hp -= a[0][0];\n\n    for(int i=0;i<(1<<12);i++) dp[0][i] = dp[1][i] = 0;\n    dp[0][0] = hp;\n\n    for(int i=0;i<s;i++){\n      for(int j=0;j<v[i].n;j++){\n\tif(v[i].c == 'U') y--;\n\telse if(v[i].c == 'D') y++;\n\telse if(v[i].c == 'L') x--;\n\telse if(v[i].c == 'R') x++;\n\tfor(int k=0;k<(1<<pp);k++){\n\t  if(dp[0][k] > 0){\n\t    for(int l=0;l<pp;l++){\n\t      if((k & (1<<l)) == 0){\n\t\tint kk = k | (1<<l);\n\t\tdp[1][kk] = max(dp[0][kk],min(hpmax,dp[0][k]+p[l]));\n\t      }\n\t    }\n\t  }\n\t}\n        ans = false;\n\tfor(int k=0;k<(1<<pp);k++){\n\t  if(dp[1][k] == 0) dp[1][k] = dp[0][k];\n\t  dp[0][k] = dp[1][k] - a[y][x];\n\t  dp[1][k] = 0;\n\t  if(dp[0][k] > 0) ans = true;\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    if(ans) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[1 << 12];\n  for(int i = 0; i < 1 << 12; i++) {\n    for(int j = 0; j < 1 << 12; j++) {\n      if(i & j) continue;\n      buff[i].push_back(j);\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] <= 0) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        if(beet >= 1) {\n          nextdp[j] = max(nextdp[j], beet);\n        } else {\n          for(int k : buff[j]) nextdp[j | k] = max(nextdp[j | k], min(malta, beet + add[k]));\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint ihp, mhp;\nint p;\nvi portion, dmg; \nvector<vi> fld;\nint dp[1111][2222];\n\nbool solve()\n{\n\tdp[0][0] = ihp;\n\tREP(i, dmg.size())\n\t{\n\t\tREP(j, 1 << p)\n\t\t{\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tchmax(dp[i + 1][j], dp[i][j] - dmg[i]);\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif (!((j >> k) & 1))\n\t\t\t\t{\n\t\t\t\t\tchmax(dp[i][j | (1 << k)], min(mhp, dp[i][j] + portion[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 1 << p)\n\t{\n\t\tif (dp[dmg.size()][i] > 0) return true;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile (cin >> ihp >> mhp, ihp)\n\t{\n\t\tportion.clear();\n\t\tdmg.clear();\n\t\tfld.clear();\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfld.resize(h, vi(w));\n\t\tvs fldc(h);\n\t\tREP(i, h) cin >> fldc[i];\n\t\tint t; cin >> t;\n\t\tmap<char, int> mp;\n\t\tREP(i, t)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tmp[c] = d;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tfld[i][j] = mp[fldc[i][j]];\n\t\t}\n\n\t\tint tx = 0, ty = 0;\n\t\tint s; cin >> s;\n\t\tREP(i, s)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tpii tmp;\n\t\t\tif (c == 'U') tmp = pii(-1, 0);\n\t\t\tif (c == 'D') tmp = pii(1, 0);\n\t\t\tif (c == 'L') tmp = pii(0, -1);\n\t\t\tif (c == 'R') tmp = pii(0, 1);\n\t\t\tREP(j, d)\n\t\t\t{\n\t\t\t\ttx += tmp.first, ty += tmp.second;\n\t\t\t\tdmg.push_back(fld[tx][ty]);\n\t\t\t}\n\t\t}\n\t\tcin >> p;\n\t\tREP(i, p)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\tportion.push_back(a);\n\t\t}\n\t\tMS(dp, 0);\n\t\tputs(solve() ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb push_back\n\nconst int N = 1010;\nconst int M = 12;\nconst int inf = -inf;\n\nint dp[N][1<<M];\n\nbool solve(int n,int *damage,int m,int *portion,int hpini,int hpmax){\n  rep(i,n)rep(j,(1<<m))dp[i][j]=-inf;\n  dp[0][0]=hpini;\n\n  rep(i,n){\n    rep(j,(1<<m)){\n      if (i)dp[i][j]=max(dp[i-1][j]-damage[i],dp[i][j]);\n      if (dp[i][j] <= 0)continue;\n      //cout << i <<\" \" << j << \" \" << dp[i][j] << endl;\n      rep(k,m){\n\tif ((1<<k)&j)continue;\n\tdp[i][j|(1<<k)]=min(hpmax,max(dp[i][j]+portion[k],dp[i][j|(1<<k)]));\n      }\n    }\n  }\n  rep(i,(1<<m))if (dp[n-1][i] > 0)return true;\n  return false;\n}\n\n\nchar m[100][100];//convert to damage\n//DURL\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid make(vector<int> path,int *damage){\n  int x=0,y=0;\n  rep(i,path.size()){\n    y+=dy[path[i]];\n    x+=dx[path[i]];\n    damage[i+1]=m[y][x];\n  }\n}\n\nmain(){\n  int hpini,hpmax;\n  int damage[N];\n  int portion[M];\n  map<char,int> MAP;\n  while(cin>>hpini >>hpmax && hpmax){\n    int r,c;\n    cin>>r>>c;\n    rep(i,r)rep(j,c)cin>>m[i][j];\n    \n    int ns;\n    cin>>ns;\n    rep(i,ns){\n      char tmp;int a;\n      cin>>tmp>>a;\n      MAP[tmp]=a;\n    }\n    rep(i,r)rep(j,c)m[i][j]=MAP[m[i][j]];\n\n    vector<int> path;\n    int pnum;\n    cin>>pnum;\n    rep(i,pnum){\n      char tmp;int cnt;\n      cin>>tmp>>cnt;\n      int ins;\n      if (tmp == 'D')ins=0;\n      if (tmp == 'U')ins=1;\n      if (tmp == 'R')ins=2;\n      if (tmp == 'L')ins=3;\n      rep(j,cnt)path.pb(ins);\n    }\n\n    int po;\n    cin>>po;\n    rep(i,po)cin>>portion[i];\n\n    make(path,damage);\n\n    //    rep(i,po)cout << portion[i] <<\" \" ;cout << endl;\n    //    rep(i,path.size()+1)cout << damage[i]<<\" \" ;cout << endl;\n\n    if (solve(path.size()+1,damage,po,portion,hpini,hpmax))cout <<\"YES\"<<endl;\n    else cout <<\"NO\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n#define inf 2147480000\nint blost,bloend;\nint n,m,x0,y0;\nchar box[111][111];\nint fox[13];\nint dk,ck;\nint final[2][5001];\nint aox[50];\nint o;\nint map[1000001];\nint q;\nint tem[13];\nint change(char a)\n{\n    return int(a)-'A'+1;\n}\nvoid ini()\n{\n   fox[0]=1;\n   for(int i=1;i<=12;i++) fox[i]=fox[i-1]*2;\n}\nint main(int argc, char *argv[])\n{\n    ini();\n    while(cin>>blost)\n    {\n      cin>>bloend;\n      if(blost==0 && bloend==0) break;\n      cin>>n>>m;\n      x0=1;y0=1;\n      for(int i=1;i<=n;i++)\n      {\n         for(int j=1;j<=m;j++)\n         {\n           cin>>box[i][j];\n         }\n      }\n      int kk;\n      cin>>kk;\n      for(int i=1;i<=kk;i++)\n      {\n          char a;int b;\n          cin>>a>>b;\n          aox[change(a)]=b;\n      }\n      o=0;\n      cin>>kk;\n      for(int i=1;i<=kk;i++)\n      {\n          char a;int b;\n          cin>>a>>b;\n          for(int j=1;j<=b;j++)\n          {\n             if(a=='D')\n             {\n                 x0++;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else if(a=='R')\n             {\n                 y0++;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else if(a=='U')\n             {\n                 x0--;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n             else\n             {\n                 y0--;int c=change(box[x0][y0]);\n                 if(aox[c]!=0)\n                 {\n                    o++;map[o]=aox[c];\n                 }\n             }\n          }\n      }\n      cin>>q;\n      for(int i=1;i<=q;i++)\n         cin>>tem[i];\n      bool con=0;\n      queue < int > k;\n      queue < int > p;\n      dk=0;ck=1;\n      k.push(0);\n      final[dk][0]=blost;\n      for(int i=1;i<=o;i++)\n      {\n         bool ok=0;\n         while(!k.empty())\n         {\n            int a=k.front();k.pop();\n            if(final[dk][a]>map[i])\n            {\n               if(final[ck][a]<final[dk][a]-map[i]) \n                {final[ck][a]=final[dk][a]-map[i];p.push(a);ok=1;}\n            }\n            else\n            {\n              for(int j=0;j<q;j++)\n              {\n                  int b=a&fox[j];\n                  if(b==0)\n                  {\n                     int c=a+fox[j];\n                     int d=final[dk][a]+tem[j+1];if(d>bloend) d=bloend;\n                     if(d>map[i])\n                     {\n                         if(final[ck][c]<d-map[i]) {final[ck][c]=d-map[i];p.push(c);ok=1;}             \n                     }\n                     else\n                     {\n                         if(final[dk][c]<d)\n                         {\n                            final[dk][c]=d;k.push(c);\n                         }\n                     }\n                  }\n              }\n            }\n         }\n         if(ok==0) {con=1;break;}\n         while(!p.empty())\n         {\n            int a=p.front();p.pop();\n            k.push(a);\n         }  \n         for(int i=0;i<=4100;i++)\n         {\n            final[dk][i]=final[ck][i];\n            final[ck][i]=-1;\n         }\n         dk=1-dk;ck=1-ck;\n      }\n      if(con==0) cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\ntypedef\tvector<vi>\tvvi;\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int hpinit,hpmax;scanf(\"%d%d\",&hpinit,&hpmax),hpinit;){\n\t\tint m,n,tmp;\tscanf(\"%d%d\",&m,&n);\n\n\t\tvvi trap(m,vi(n));\n\t\t{\n\t\t\tchar a[100][101];\n\t\t\trep(i,m)\tscanf(\"%s\",a+i);\n\t\t\tint tmp;\tscanf(\"%d \",&tmp);\n\t\t\tint f[128];\n\t\t\trep(i,tmp){\n\t\t\t\tchar ch;\n\t\t\t\tint dmg;\tscanf(\"%c%d \",&ch,&dmg);\n\t\t\t\tf[ch]=dmg;\n\t\t\t}\n\t\t\trep(i,m)rep(j,n)\ttrap[i][j]=f[a[i][j]];\n\t\t}\n\n\t\tscanf(\"%d \",&tmp);\n\t\tvector<pii> step(tmp);\n\t\trep(i,tmp){\n\t\t\tchar ch;\n\t\t\tint d;\tscanf(\"%c%d \",&ch,&d);\n\t\t\tchar f[128];\n\t\t\tf['R']=0,f['U']=1,f['L']=2,f['D']=3;\n\t\t\tstep[i]=mp(d,f[ch]);\n\t\t}\n\t\tstep.pb(mp(1,0));\n\n\t\tint psize;\tscanf(\"%d\",&psize);\n\t\tvi por(psize);\n\t\trep(i,psize)\tscanf(\"%d\",&por[i]);\n\n\t\tvi cure(1<<psize);\n\t\trep(i,1<<psize)rep(j,psize){\n\t\t\tif(i&(1<<j))\tcure[i]+=por[j];\n\t\t}\n\n\t\tint x=0,y=0;\n\t\tvi hp(1<<psize);\thp[(1<<psize)-1]=hpinit;\n\t\trep(t,step.size())rep(k,step[t].first){\n\t\t\tint dmg=trap[y][x];\n\t\t\trep(i,1<<psize){\n\t\t\t\tif(hp[i]<=0)\tcontinue;\n\t\t\t\thp[i]-=dmg;\n\t\t\t\tif(hp[i]<=0){\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif((j&i)==j){\n\t\t\t\t\t\t\thp[j]=max(hp[j],min(hp[i]+cure[i&~j],hpmax));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dir=step[t].second;\n\t\t\tx+=dx[dir];\ty+=dy[dir];\n\t\t}\n\n\t\tbool ok=false;\n\t\trep(i,1<<psize) if(hp[i]>0){ ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint HPinit,HP;\nint H,W;\nstring a[100];\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\nint d[26];\nstring s;\nint P,p[12];\nmain()\n{\n\twhile(cin>>HPinit>>HP,HP)\n\t{\n\t\tcin>>H>>W;\n\t\tfor(int i=0;i<H;i++)cin>>a[i];\n\t\tint T;cin>>T;\n\t\tfor(int i=0;i<T;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tcin>>d[c-'A'];\n\t\t}\n\t\tint S;cin>>S;\n\t\ts=\"\";\n\t\tfor(int i=0;i<S;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tint n;cin>>n;\n\t\t\tfor(int j=0;j<n;j++)s+=c;\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>p[i];\n\t\tvector<vector<int> >vis(s.size()+1,vector<int>(1<<P,0));\n\t\tvis[0][0]=HPinit;\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<s.size();i++)\n\t\t{\n\t\t\tint dir=s[i]=='U'?0:s[i]=='D'?1:s[i]=='L'?2:3;\n\t\t\tint tx=x+dx[dir],ty=y+dy[dir];\n\t\t\tint lo=d[a[tx][ty]-'A'];\n\t\t\tfor(int j=0;j<1<<P;j++)\n\t\t\t{\n\t\t\t\tif(vis[i][j]==0)continue;\n\t\t\t\tif(vis[i][j]>lo)\n\t\t\t\t{\n\t\t\t\t\tvis[i+1][j]=max(vis[i+1][j],vis[i][j]-lo);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(j>>k&1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvis[i][j|1<<k]=max(vis[i][j|1<<k],min(vis[i][j]+p[k],HP));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx=tx;y=ty;\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<1<<P;i++)if(vis[s.size()][i]>0)ok=true;\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint hpi,hpm,R,C,T,S,n[1010],P,p[19],x,y,dy[]={0,1,0,-1},dx[]={1,0,-1,0},dp[1<<12];\nchar a[110][110],d[1010],c;\nmap<char,int> M,m;\nvi v;\n\nint main(){\n\tm['R']=0,m['D']=1,m['L']=2,m['U']=3;\n\twhile(cin>>hpi>>hpm&&hpi){\n\t\tv.clear();\n\t\tcin>>R>>C;\n\t\trep(i,R)cin>>a[i];\n\t\tcin>>T;\n\t\trep(i,T)cin>>c>>y,M[c]=y;\n\t\tcin>>S;\n\t\trep(i,S)cin>>d[i]>>n[i];\n\t\tcin>>P;\n\t\trep(i,P)cin>>p[i];\n\t\ty=x=0;\n\t\trep(i,S){\n\t\t\trep(j,n[i]){\n\t\t\t\ty+=dy[m[d[i]]],x+=dx[m[d[i]]];\n\t\t\t\tif(M[a[y][x]])v.pb(M[a[y][x]]);\n\t\t\t}\n\t\t}\n\t\tdp[0]=hpi;\n\t\trep(i,v.sz)rep(j,1<<P)if(dp[j]>0){\n\t\t\trep(k,P)if(!(j&1<<k)){\n\t\t\t\tdp[j|1<<k]=max(dp[j|1<<k],min(hpm,dp[j]+p[k]));\n\t\t\t}\n\t\t\tdp[j]-=v[i];\n\t\t}\n\t\tcout<<(dp[(1<<P)-1]>0?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n\nint dp[MAX][1<<MAX_P];\n\nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n        \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n        \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n\n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n        \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] == -1) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < (1<<P); k++) {\n                    if ((j & k) > 0) continue;\n                    int rec = 0;\n                    for (int l = 0; l < P; l++) {\n                        if (k >> l & 1) {\n                            rec += p[l];\n                        }\n                    }\n                    dp[i+1][j|k] = max(dp[i+1][j|k], dp[i][j] - vec[i] + rec);\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 15][1010];\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nbool solve() {\n\tint SS = step.size();\n\t\n\tvector< int > damage(SS);\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tdamage[i] = trap[grid[y][x]];\n\t}\n\t\n\tmemset(max_hp, -1, sizeof(max_hp));\n\t\n\tmax_hp[0][0] = HPinit;\n\t\n\tfor_(U,0,1<<P) for_(i,0,SS) {\n\t\tif (max_hp[U][i] == -1) continue;\n\t\t\n\t\tmaxUpdate(max_hp[U][i + 1], max_hp[U][i] - damage[i]);\n\t\t\n\t\tfor_(j,0,P) {\n\t\t\tif (U >> j & 1) continue;\n\t\t\tmaxUpdate(max_hp[U | 1 << j][i], max_hp[U][i] + p[j]);\n\t\t}\n\t}\n\t\n\tbool res = false;\n\tfor_(U,0,1<<P) res |= (max_hp[U][SS] > 0);\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int HPinit, HPmax; cin >> HPinit >> HPmax;\n        if (HPinit == 0) break;\n\n        int R, C; cin >> R >> C;\n        vector<string> a(R); cin >> a;\n        int T; cin >> T;\n        map<char,int> d;\n        for (int i = 0; i < T; ++i) {\n            char c; cin >> c;\n            cin >> d[c];\n        }\n        int S; cin >> S;\n        string s;\n        for (int i = 0; i < S; ++i) {\n            char c; cin >> c;\n            int n; cin >> n;\n            for (int j = 0; j < n; ++j) {\n                s += c;\n            }\n        }\n        int P; cin >> P;\n        vector<int> p(P); cin >> p;\n\n        map<char,int> dx, dy;\n        dx['R'] = 1, dx['L'] = -1;\n        dy['D'] = 1, dy['U'] = -1;\n\n        vector<int> x(s.size()+1), y(s.size()+1);\n        for (int i = 0; i < s.size(); ++i) {\n            x[i+1] = x[i] + dx[s[i]];\n            y[i+1] = y[i] + dy[s[i]];\n        }\n\n        auto dp = make_v<int>(s.size()+1, 1<<P);\n        dp[0][(1<<P)-1] = HPinit;\n        for (int i = 0; i < s.size(); ++i) {\n            char trap = a[y[i+1]][x[i+1]];\n            for (int bit = 0; bit < 1<<P; ++bit) {\n                if (dp[i][bit] == 0) continue;\n                chmax(dp[i+1][bit], dp[i][bit] - d[trap]);\n                for (int j = 0; j < P; ++j) if (bit >> j & 1) {\n                    chmax(dp[i+1][bit & ~(1<<j)],\n                            min(dp[i][bit] + p[j], HPmax) - d[trap]);\n                }\n            }\n        }\n\n        cout << (dp[s.size()][0] ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\nint HpInit, HpMax;\nint H, W;\nvector<string> G;\nint cost[256];\nint portion[12];\nint calc_heal[1<<12];\n\ntypedef pair<int, int> pii;\nvector<pii> v;\n\nint main() {\n\n  while(cin >> HpInit >> HpMax && (HpInit | HpMax)) {\n    cin >> H >> W;\n    G.clear(); G.resize(H);\n    rep(i, H) cin >> G[i];\n    int Q; cin >> Q;\n    rep(i, Q) {\n      char c; cin >> c;\n      cin >> cost[(int)c];\n    }\n\n    v.clear();\n    int y = 0, x = 0;\n\n    cin >> N;\n    rep(i, N) {\n      char d; cin >> d;\n      int n; cin >> n;\n      if(d == 'L') { rep(i, n) v.push_back({y, x-i-1}); x -= n; }\n      if(d == 'U') { rep(i, n) v.push_back({y-i-1, x}); y -= n; }\n      if(d == 'R') { rep(i, n) v.push_back({y, x+i+1}); x += n; }\n      if(d == 'D') { rep(i, n) v.push_back({y+i+1, x}); y += n; }\n    }\n\n    cin >> M;\n    rep(i, M)\n      cin >> portion[i];\n\n    rep(S, 1<<M) {\n      calc_heal[S] = 0;\n      rep(i, M) if(S >> i & 1)\n        calc_heal[S] += portion[i];\n    }\n\n    static int dp[1010][1<<12];\n    rep(i, 1010) rep(j, 1<<12) dp[i][j] = -inf;\n    dp[0][0] = HpInit;\n\n    rep(i, v.size()) {\n      const int damage = cost[(int)G[v[i].first][v[i].second]];\n      rep(PS, 1<<M) {\n        if(dp[i][PS] <= 0) continue;\n        int remain = (1 << M) - 1 - PS;\n        for(int b=remain; b>=0; b--) {\n          b &= remain;\n          int NPS = PS | ((1 << M) - 1 - PS - b);\n          const int heal = calc_heal[NPS ^ PS];\n          const int cand = min(HpMax, dp[i][PS] + heal) - damage;\n          if(cand > 0) maximize(dp[i+1][NPS], cand);\n        }\n      }\n    }\n\n    bool ok = 0;\n\n    rep(i, 1<<M) {\n      ok |= dp[v.size()][i] > 0;\n    }\n\n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint HPinit, HPmax, R, C, T, S, P, p[22];\nstring grid[111];\nunordered_map< char, int > trap;\n\nstring dirs = \"LURD\";\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntypedef pair< int, int > pii;\nvector< pii > step;\n\nint max_hp[1L << 15][1010];\n\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nbool solve() {\n\tint SS = step.size();\n\t\n\tvector< int > damage(SS);\n\t\n\tfor_(i,0,SS) {\n\t\tpii pos = step[i];\n\t\tint x = pos.first, y = pos.second;\n\t\tdamage[i] = trap[grid[y][x]];\n\t}\n\t\n\tmemset(max_hp, -1, sizeof(max_hp));\n\t\n\tmax_hp[0][0] = HPinit;\n\t\n\tfor_(U,0,1<<P) for_(i,0,SS) {\n\t\tif (max_hp[U][i] == -1) continue;\n\t\t\n\t\tmaxUpdate(max_hp[U][i + 1], max_hp[U][i] - damage[i]);\n\t\t\n\t\tfor_(j,0,P) {\n\t\t\tif (U >> j & 1) continue;\n\t\t\tmaxUpdate(max_hp[U | 1 << j][i], max_hp[U][i] + p[j]);\n\t\t}\n\t}\n\t\n\tbool res = false;\n\tfor_(U,0,1<<P) res |= (max_hp[U][SS] > 0);\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> HPinit >> HPmax, HPinit) {\n\t\tcin >> R >> C;\n\t\tfor_(r,0,R) cin >> grid[r];\n\t\t\n\t\ttrap.clear();\n\t\tcin >> T;\n\t\t\n\t\tfor_(i,0,T) {\n\t\t\tchar alph; int d;\n\t\t\tcin >> alph >> d;\n\t\t\ttrap[alph] = d;\n\t\t}\n\t\t\n\t\tstep.clear();\n\t\tcin >> S;\n\t\t\n\t\tpii pos(0, 0);\n\t\t\n\t\tfor_(i,0,S) {\n\t\t\tchar d; int n;\n\t\t\tcin >> d >> n;\n\t\t\t\n\t\t\tint dr = dirs.find(d);\n\t\t\t\n\t\t\tfor_(j,0,n) {\n\t\t\t\tpos = pii(pos.first + dx[dr], pos.second + dy[dr]);\n\t\t\t\tif (pos.first < 0) pos.first = 0;\n\t\t\t\tif (pos.second < 0) pos.second = 0;\n\t\t\t\tif (pos.first >= C) pos.first = C - 1;\n\t\t\t\tif (pos.second >= R) pos.second = R - 1;\n\t\t\t\tstep.push_back(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor_(i,0,P) cin >> p[i];\n\t\t\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint ihp, mhp;\nint p;\nvi portion, dmg; \nvector<vi> fld;\nint dp[1111][4444];\n\nbool solve()\n{\n\tdp[0][0] = ihp;\n\tREP(i, dmg.size())\n\t{\n\t\tREP(j, 1 << p)\n\t\t{\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tchmax(dp[i + 1][j], dp[i][j] - dmg[i]);\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif (!((j >> k) & 1))\n\t\t\t\t{\n\t\t\t\t\tchmax(dp[i][j | (1 << k)], min(mhp, dp[i][j] + portion[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[dmg.size()][(1 << p) - 1] > 0;\n}\n\n\nint main()\n{\n\twhile (cin >> ihp >> mhp, ihp)\n\t{\n\t\tportion.clear();\n\t\tdmg.clear();\n\t\tfld.clear();\n\t\tMS(dp, 0);\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfld.resize(h, vi(w));\n\t\tvs fldc(h);\n\t\tREP(i, h) cin >> fldc[i];\n\t\tint t; cin >> t;\n\t\tint mp[26];\n\t\tREP(i, t)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tmp[c - 'A'] = d;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tfld[i][j] = mp[fldc[i][j] - 'A'];\n\t\t}\n\n\t\tint tx = 0, ty = 0;\n\t\tint s; cin >> s;\n\t\tREP(i, s)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tpii tmp;\n\t\t\tif (c == 'U') tmp = pii(-1, 0);\n\t\t\tif (c == 'D') tmp = pii(1, 0);\n\t\t\tif (c == 'L') tmp = pii(0, -1);\n\t\t\tif (c == 'R') tmp = pii(0, 1);\n\t\t\tREP(j, d)\n\t\t\t{\n\t\t\t\ttx += tmp.first, ty += tmp.second;\n\t\t\t\tdmg.push_back(fld[tx][ty]);\n\t\t\t}\n\t\t}\n\t\tcin >> p;\n\t\tREP(i, p)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\tportion.push_back(a);\n\t\t}\n\t\tputs(solve() ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int infty = 1<<28;\nstatic int dp[1001][1<<12];\n\nint main()\n{\n  while(true){\n\n    int initHP;\n    int maxHP;\n    cin >> initHP >> maxHP;\n    if(initHP==0&&maxHP==0)break;\n\n    int R,C;\n    cin >> R >> C;\n    char M[R][C];\n    int damage[256];\n    for(int i = 0; i < R; ++i){\n      for(int j = 0; j < C; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    \n    int T;\n    cin >> T;\n    for(int i = 0; i < T; ++i){\n      char c;\n      int dam;\n      cin >> c >> dam;\n      damage[(int)c]=dam;\n    }\n    \n    int S;\n    cin >> S;\n    string inst;\n    for(int i = 0; i < S; ++i){\n      char c;\n      int step;\n      cin >> c >> step;\n      for(int j = 0; j < step; ++j){\n\tinst += c;\n      }\n    }\n\n    int P;\n    vector<int> potion;\n    cin >> P;\n    for(int i = 0; i < P; ++i){\n      int p;\n      cin >> p;\n      potion.push_back(p);\n    }\n\n    S = inst.length();\n    \n    int Pmax=1<<potion.size();\n    for(int i = 0; i < 1+S; ++i){\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i][j] = -infty;\n      }\n    }\n    dp[0][0]=initHP;\n    \n    int ni=0;\n    int nj=0;\n    for(int i = 0; i < S; ++i){\n      switch(inst[i]){\n      case 'D':++ni;break;\n      case 'U':--ni;break;\n      case 'R':++nj;break;\n      case 'L':--nj;break;\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tif(dp[i][j]<=0)continue;\n\tfor(int k = 0; k < (int)potion.size(); ++k){\n\t  if( (j&(1<<k)) == 0 ){\n\t    dp[i][j|(1<<k)] = max( dp[i][j|(1<<k)], min(maxHP, dp[i][j] + potion[k]) );\n\t  }\n\t}\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i+1][j] = max( dp[i+1][j], dp[i][j]-damage[(int)M[ni][nj]] );\n      }\n    }\n\n    int res = -infty;\n    for(int i = 0; i < Pmax; ++i){\n      res = max( res, dp[S][i] );\n    }\n    \n    if(res>0)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\nint HpInit, HpMax;\nint H, W;\nvector<string> G;\nint cost[256];\nint portion[12];\nint calc_heal[1<<12];\n\ntypedef pair<int, int> pii;\nvector<pii> v;\n\nint main() {\n\n  while(cin >> HpInit >> HpMax && (HpInit | HpMax)) {\n    cin >> H >> W;\n    G.clear(); G.resize(H);\n    rep(i, H) cin >> G[i];\n    int Q; cin >> Q;\n    rep(i, Q) {\n      char c; cin >> c;\n      cin >> cost[(int)c];\n    }\n\n    v.clear();\n    int y = 0, x = 0;\n\n    cin >> N;\n    rep(i, N) {\n      char d; cin >> d;\n      int n; cin >> n;\n      if(d == 'L') { rep(i, n) v.push_back({y, x-i-1}); x -= n; }\n      if(d == 'U') { rep(i, n) v.push_back({y-i-1, x}); y -= n; }\n      if(d == 'R') { rep(i, n) v.push_back({y, x+i+1}); x += n; }\n      if(d == 'D') { rep(i, n) v.push_back({y+i+1, x}); y += n; }\n    }\n\n    cin >> M;\n    rep(i, M)\n      cin >> portion[i];\n\n    rep(S, 1<<M) {\n      calc_heal[S] = 0;\n      rep(i, M) if(S >> i & 1)\n        calc_heal[S] += portion[i];\n    }\n\n    static int dp[1010][1<<12];\n    rep(i, 1010) rep(j, 1<<12) dp[i][j] = -inf;\n    dp[0][0] = HpInit;\n\n    rep(i, v.size()) {\n      const int damage = cost[(int)G[v[i].first][v[i].second]];\n      rep(PS, 1<<M) {\n        int remain = (1 << M) - 1 - PS;\n        for(int b=remain; b>=0; b--) {\n          b &= remain;\n          int NPS = PS | ((1 << M) - 1 - PS - b);\n//          cout << \" PS: \" << std::bitset<12>(PS) << \"\\nNPS: \" << std::bitset<12>(NPS) << \"\\n\\n\";\n          const int heal = calc_heal[NPS ^ PS];\n          const int cand = min(HpMax, dp[i][PS] + heal) - damage;\n          if(cand > 0) maximize(dp[i+1][NPS], cand);\n        }\n      }\n    }\n\n    bool ok = 0;\n\n    rep(i, 1<<M) {\n      ok |= dp[v.size()][i] > 0;\n    }\n\n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1001];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1001];\n\nconst int INF=1000000000;\n\nint main(){\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tint quan;\n\t\t\tcin>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++){\n\t\t\t\tif((i>>j)&1)sum+=portion[j];\n\t\t\t}\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint nx,ny;\n\t\t\tint pos=i;\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[pos].second;j++){\n\t\t\t\tif(seq[pos].first=='U'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy-1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='D'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy+1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='L'){\n\t\t\t\t\tnx=cx-1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='R'){\n\t\t\t\t\tnx=cx+1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t// ツ個サツ催敖づ個δ可イツフツづ、ツ残ツづィportion\n\t\tqueue<pair<int,int> > q[2];\n\t\tint cur=0;\n\t\tint nxt=1;\n\t\tint cnt=1;\n\t\tbool ok=false;\n\t\tq[cur].push(make_pair(hpInit,0));\n\t\twhile(q[cur].size()){\n\t\t\twhile(q[cur].size()){\n\t\t\t\tint clife=q[cur].front().first;\n\t\t\t\tint cs=q[cur].front().second;\n\t\t\t\tq[cur].pop();\n\t\t\t\tint nx=points[cnt].second;\n\t\t\t\tint ny=points[cnt].first;\n\t\t\t\t// ツ個サツ催敖づ個湘ウツ妥板つゥツづァツづづ継ortionツづーツ使ツづづ遷ツ暗堋つキツづゥツつゥ\n\t\t\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\t\t\tint nlife=min(hpMax,clife+combPortionEf[i]-tbl[(int)dmg[ny][nx]]);\n\t\t\t\t\tif(!(i&cs)&&nlife>0){\n\t\t\t\t\t\tq[nxt].push(make_pair(nlife,i|cs));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==idx){\n\t\t\t\tif(q[nxt].size())ok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n \nint dp[MAX][1<<MAX_P];\n \nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n \nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n         \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n         \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n \n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n         \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n         \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] <= 0) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < P; k++) {\n                    if (j >> k & 1) continue;\n                    dp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], min(dp[i][j] + p[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nchar t[101][101];\nint dx[256],dy[256];\nint dp[1<<12];\n\nint main(void){\n\tdx['R'] = 1;\n\tdx['L'] = -1;\n\tdy['U'] = -1;\n\tdy['D'] = 1;\n\n\tint hpInit,hpMax;\n\n\twhile(cin>>hpInit>>hpMax && (hpInit||hpMax)){\n\t\tint H,W;\n\t\tcin>>H>>W;\n\t\trep(i,H) cin>>t[i];\n\n\t\tint T;\n\t\tcin>>T;\n\t\tmap<char,int> d;\n\t\trep(i,T){\n\t\t\tint damage;\n\t\t\tchar ch;\n\t\t\tcin>>ch>>damage;\n\t\t\td[ch] = damage;\n\t\t}\n\n\t\tint S;\n\t\tcin>>S;\n\t\tvector<int> v;\n\t\tv.push_back(0);\n\t\tint x=0,y=0;\n\n\t\trep(i,S){\n\t\t\tchar ch;\n\t\t\tint n;\n\t\t\tcin>>ch>>n;\n\t\t\trep(j,n){\n\t\t\t\tint nx = x + dx[ch];\n\t\t\t\tint ny = y + dy[ch];\n\n\t\t\t\tv.push_back(d[t[ny][nx]]);\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t}\n\n\t\tint P;\n\t\tcin>>P;\n\t\tint p[P];\n\t\trep(i,P) cin>>p[i];\n\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0] = hpInit;\n\n\t\trep(i,v.size()){\n\t\t\trep(j,1<<P) if(dp[j] > 0){\n\t\t\t\trep(k,P) if((j & (1<<k)) == 0){\n\t\t\t\t\tint idx = (j | (1<<k));\n\t\t\t\t\tdp[idx] = max(dp[idx],min(hpMax,dp[j]+p[k]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(j,1<<P) dp[j] -= v[i];\n\t\t}\n\n\t\tbool ans = false;\n\t\trep(i,1<<P) if(dp[i] > 0){\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tcout<<(ans?\"YES\":\"NO\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nint main(){\n\tint init_hp,max_hp;\n\twhile(cin>>init_hp>>max_hp,init_hp|max_hp){\n\t\tint r,c;\n\t\tcin>>r>>c;\n\t\tvs a(r,string(c,' '));\n\t\tREP(i,r){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint t;\n\t\tcin>>t;\n\t\tvi trap_damages('Z'+1);\n\t\tREP(i,t){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tcin>>trap_damages[c];\n\t\t}\n\t\tint s;\n\t\tcin>>s;\n\t\tint total_steps=0;\n\t\tint cnt=0;\n\t\tvector<pii> steps(1000);\n\t\tint y=0,x=0;\n\t\tREP(i,s){\n\t\t\tchar direction;\n\t\t\tint step;\n\t\t\tcin>>direction>>step;\n\t\t\tint dy=0,dx=0;\n\t\t\tswitch(direction){\n\t\t\tcase 'U':\n\t\t\t\tdy=-1;break;\n\t\t\tcase 'D':\n\t\t\t\tdy=1;break;\n\t\t\tcase 'L':\n\t\t\t\tdx=-1;break;\n\t\t\tcase 'R':\n\t\t\t\tdx=1;break;\n\t\t\t}\n\t\t\tREP(j,step){\n\t\t\t\ty+=dy;\n\t\t\t\tx+=dx;\n\t\t\t\tsteps[cnt].first=y;\n\t\t\t\tsteps[cnt].second=x;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttotal_steps+=step;\n\t\t}\n\t\tint p;\n\t\tcin>>p;\n\t\tvi potions(p);\n\t\tREP(i,p){\n\t\t\tcin>>potions[i];\n\t\t}\n\n\t\tvvi hp(total_steps+1,vi(1<<p));\n\t\thp[0][0]=init_hp;\n\t\tREP(step,total_steps){\n\t\t\tREP(potion_mask,1<<p){\n\t\t\t\tif(hp[step][potion_mask]<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchar trap=a[steps[step].first][steps[step].second];\n\t\t\t\tint damage=trap_damages[trap];\n\t\t\t\tif(hp[step][potion_mask]<=damage){\n\t\t\t\t\tREP(used_potion_mask,1<<p){\n\t\t\t\t\t\tbool ok=true;\n\t\t\t\t\t\tint cured_hp=0;\n\t\t\t\t\t\tREP(i,p){\n\t\t\t\t\t\t\tif((used_potion_mask&(1<<i))&&(potion_mask&(1<<i))){\n\t\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((used_potion_mask&(1<<i))){\n\t\t\t\t\t\t\t\tcured_hp+=potions[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tint new_hp=min(hp[step][potion_mask]+cured_hp,max_hp)-damage;\n\t\t\t\t\t\t\thp[step+1][potion_mask|used_potion_mask]=max(hp[step+1][potion_mask|used_potion_mask],new_hp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\thp[step+1][potion_mask]=max(hp[step+1][potion_mask],hp[step][potion_mask]-damage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(potion_mask,1<<p){\n\t\t\tans=max(ans,hp[total_steps][potion_mask]);\n\t\t}\n\t\tcout<<(ans>0?\"YES\":\"NO\")<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nint main(){\n\tint init_hp,max_hp;\n\twhile(cin>>init_hp>>max_hp,init_hp|max_hp){\n\t\tint r,c;\n\t\tcin>>r>>c;\n\t\tvs a(r,string(c,' '));\n\t\tREP(i,r){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint t;\n\t\tcin>>t;\n\t\tvi trap_damages('Z'+1);\n\t\tREP(i,t){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tcin>>trap_damages[c];\n\t\t}\n\t\tint s;\n\t\tcin>>s;\n\t\tint total_steps=0;\n\t\tint cnt=0;\n\t\tvector<pii> steps(1000);\n\t\tint y=0,x=0;\n\t\tREP(i,s){\n\t\t\tchar direction;\n\t\t\tint step;\n\t\t\tcin>>direction>>step;\n\t\t\tint dy=0,dx=0;\n\t\t\tswitch(direction){\n\t\t\tcase 'U':\n\t\t\t\tdy=-1;break;\n\t\t\tcase 'D':\n\t\t\t\tdy=1;break;\n\t\t\tcase 'L':\n\t\t\t\tdx=-1;break;\n\t\t\tcase 'R':\n\t\t\t\tdx=1;break;\n\t\t\t}\n\t\t\tREP(j,step){\n\t\t\t\ty+=dy;\n\t\t\t\tx+=dx;\n\t\t\t\tsteps[cnt].first=y;\n\t\t\t\tsteps[cnt].second=x;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttotal_steps+=step;\n\t\t}\n\t\tint p;\n\t\tcin>>p;\n\t\tvi potions(p);\n\t\tREP(i,p){\n\t\t\tcin>>potions[i];\n\t\t}\n\n\t\tvvi hp(total_steps+1,vi(1<<p));\n\t\thp[0][0]=init_hp;\n\t\tREP(step,total_steps){\n\t\t\tchar trap=a[steps[step].first][steps[step].second];\n\t\t\tint damage=trap_damages[trap];\n\t\t\tREP(potion_mask,1<<p){\n\t\t\t\tif(hp[step][potion_mask]<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(hp[step][potion_mask]<=damage){\n\t\t\t\t\tREP(used_potion_mask,1<<p){\n\t\t\t\t\t\tbool ok=true;\n\t\t\t\t\t\tint cured_hp=0;\n\t\t\t\t\t\tREP(i,p){\n\t\t\t\t\t\t\tif((used_potion_mask&(1<<i))&&(potion_mask&(1<<i))){\n\t\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((used_potion_mask&(1<<i))){\n\t\t\t\t\t\t\t\tcured_hp+=potions[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tint new_hp=min(hp[step][potion_mask]+cured_hp,max_hp)-damage;\n\t\t\t\t\t\t\thp[step+1][potion_mask|used_potion_mask]=max(hp[step+1][potion_mask|used_potion_mask],new_hp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\thp[step+1][potion_mask]=max(hp[step+1][potion_mask],hp[step][potion_mask]-damage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(potion_mask,1<<p){\n\t\t\tans=max(ans,hp[total_steps][potion_mask]);\n\t\t}\n\t\tcout<<(ans>0?\"YES\":\"NO\")<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main(){\n\tmap<char, int> dx,dy;\n\tdx['U']=0; dy['U']=-1;\n\tdx['D']=0; dy['D']=1;\n\tdx['L']=-1; dy['L']=0;\n\tdx['R']=1; dy['R']=0;\n\n\twhile(1){\n\t\tint hp,hpmax;\n\t\tcin >> hp >> hpmax;\n\t\tif(hp == 0) break;\n\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tvector<string> field(h);\n\t\tfor(int i=0; i<h; i++){\n\t\t\tcin >> field[i];\n\t\t}\n\t\tint t;\n\t\tcin >> t;\n\t\tvector<int> damage(256, 0);\n\t\tfor(int i=0; i<t; i++){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdamage[c] = d;\n\t\t}\n\t\tint s;\n\t\tcin >> s;\n\t\tvector<int> damageseq;\n\t\tint x=0,y=0;\n\t\tfor(int i=0; i<s; i++){\n\t\t\tchar dir;\n\t\t\tint num;\n\t\t\tcin >> dir >> num;\n\t\t\tfor(int j=0; j<num; j++){\n\t\t\t\tx+=dx[dir];\n\t\t\t\ty+=dy[dir];\n\t\t\t\tif(damage[field[y][x]] > 0){\n\t\t\t\t\tdamageseq.push_back(damage[field[y][x]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tvector<int> portion(p);\n\t\tfor(int i=0; i<p; i++){\n\t\t\tcin >> portion[i];\n\t\t}\n\n\t\tvector<vector<int> > dp(damageseq.size()+1, vector<int>(1<<p, 0));\n\t\tdp[0][0] = hp;\n\t\tfor(int i=0; i<(int)damageseq.size(); i++){\n\t\t\tfor(int j=0; j<(1<<p); j++){\n\t\t\t\tif(dp[i][j] <= 0) continue;\n\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]-damageseq[i]);\n\t\t\t\tfor(int k=0; k<p; k++){\n\t\t\t\t\tif(j>>k & 1) continue;\n\t\t\t\t\tint newhp = min(dp[i][j]+portion[k], hpmax);\n\t\t\t\t\tdp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], newhp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool yes = false;\n\t\tfor(int i=0; i<(1<<p); i++){\n\t\t\tif((dp.back())[i] > 0) yes = true;\n\t\t}\n\t\tif(yes){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[1<<12];\npair<int,int> points[1010];\nint dp[2][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)\n\t\t\tdp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint cur=(i-1)%2;\n\t\t\t\tint nxt=(i)%2;\n\t\t\t\tdp[nxt][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!((j>>k)&1))\n\t\t\t\t\t\tdp[nxt][j]=max(dp[nxt][j],min(hpMax,dp[nxt][j|(1<<k)]+portion[k]));\n\t\t\t\t}\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[nxt][j]=max(dp[nxt][j],dp[cur][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[nxt][j]<=0)dp[nxt][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[nxt][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <complex>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint potion[13];\nint dmg[256];\nint dp[1010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dx[256] = {};\n\tint dy[256] = {};\n\n\trep(i, 4){\n\t\tdx[\"UDRL\"[i]] = vector<int>({-1, 1, 0, 0})[i];\n\t\tdy[\"UDRL\"[i]] = vector<int>({0, 0, 1, -1})[i];\n\t}\t\n\n\tint mhp, hp;\n\twhile (cin >> hp >> mhp, hp){\n\t\tint r, c;\n\t\tcin >> r >> c;\n\t\tvector<string> dangeon(r);\n\t\trep(i, r) cin >> dangeon[i];\n\n\t\tint t;\n\t\tcin >> t;\n\t\trep(i, t){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdmg[c] = d;\n\t\t}\n\n\t\tint x, y;\n\t\tx = y = 0;\n\t\tstring mv;\n\t\tmv += dangeon[y][x];\n\n\t\tint s;\n\t\tcin >> s;\n\t\twhile (s--){\n\t\t\tchar c;\n\t\t\tint k;\n\t\t\tcin >> c >> k;\n\t\t\twhile (k--){\n\t\t\t\tx += dx[c];\n\t\t\t\ty += dy[c];\n\t\t\t\tmv += dangeon[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint p;\n\t\tcin >> p;\n\t\trep(i, p){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tpotion[i] = x;\n\t\t}\n\n\t\tMEMSET(dp, 0);\n\t\tdp[0][0] = hp;\n\n\t\tint sz = mv.size();\n\t\trep(i, sz){\n\t\t\tif(i) rep(j, 1 << p){\n\t\t\t\tdp[i][j] = dp[i-1][j] - dmg[mv[i]];\n\t\t\t}\n\t\t\trep(j, 1 << p){\n\t\t\t\trep(k, p){\n\t\t\t\t\tint x = 1 << k;\n\t\t\t\t\tif (~j&x) continue;\n\t\t\t\t\tif (dp[i][j&~x] <= 0) continue;\n\t\t\t\t\tdp[i][j] = max(dp[i][j], min(mhp, dp[i][j&~x] + potion[k]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//rep(j, 1 << p){\n\t\t\t//\tbitset<2> b(j);\n\t\t\t//\tcout << b.to_string() << ' ' << dp[i][j] << endl;\n\t\t\t//}\n\t\t}\n\t\tbool b = *max_element(dp[sz - 1], dp[sz - 1] + (1 << p)) >= 1;\n\t\tcout << (b ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1001];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1001];\nbool passed[1001][1<<12];\nint dp[1001][1<<12];\n\nconst int INF=1000000000;\n\nint main(){\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tint quan;\n\t\t\tcin>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint nx,ny;\n\t\t\tint pos=i;\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[pos].second;j++){\n\t\t\t\tif(seq[pos].first=='U'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy-1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='D'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy+1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='L'){\n\t\t\t\t\tnx=cx-1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='R'){\n\t\t\t\t\tnx=cx+1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]);\n\t\tbool ok=false;\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1)if(dp[idx-1][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1010;\n\nchar s[105][105];\nint dp[N][1<<12],r,c,HPi,HPm,T,S,P,n,dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nint dam[30],pot[15],hash[300],rot[N];\n\nvoid input(){\n    cin>>r>>c;\n    for(int i=1;i<=r;i++) scanf(\"%s\",s[i]+1);\n    cin>>T;\n    for(int i=0;i<T;i++){\n        char key[5];\n\n        int x;\n        scanf(\"%s%d\",key,&x);\n        dam[key[0]-'A']=x;\n    }\n    n=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n        char key[5];\n        int x;\n        scanf(\"%s%d\",key,&x);\n        for(int j=0;j<x;j++) rot[++n]=hash[key[0]];\n    }\n    cin>>P;\n    for(int i=0;i<P;i++) scanf(\"%d\",&pot[i]);\n    memset(dp,0,sizeof(dp));\n}\n\nvoid init(){\n    hash['U']=0;\n    hash['D']=1;\n    hash['L']=2;\n    hash['R']=3;\n}\n\nvoid DP(){\n    int x=1,y=1;\n    dp[0][0]=HPi;\n    for(int i=1;i<=n;i++){\n        x+=dx[rot[i]],y+=dy[rot[i]];\n        int hr=dam[s[x][y]-'A'];\n        for(int j=0;j<(1<<P);j++){\n            if(!dp[i-1][j]) continue;\n            dp[i][j]=max(dp[i][j],dp[i-1][j]-hr);\n            for(int k=0;k<P;k++){\n                if(j&(1<<k)) continue;\n                int hp=min(HPm,pot[k]+dp[i-1][j]);\n                hp=max(0,hp);\n                dp[i-1][j|(1<<k)]=max(dp[i-1][j|(1<<k)],hp);\n            }\n        }\n    }\n    bool ok=false;\n    for(int i=0;i<(1<<P);i++) if(dp[n][i]>0) ok=true;\n    if(ok) puts(\"YES\");\n    else puts(\"NO\");\n}\n\nint main(){\n   // freopen(\"in\",\"r\",stdin);\n    init();\n    while(cin>>HPi>>HPm){\n        if(HPi+HPm==0) break;\n        input();\n        DP();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n\n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n  if(!m) return true;\n  for(int i=0;i<m;i++){\n\n    for(int j=0;j<(1<<P);j++){\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[(int)dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[(int)dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\t\n\tnhp=max(0,nhp-cost[(int)s[y[i+1]][x[i+1]]]);\n\t\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n\n    dir=\"\";\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int dmg,int i){\n  Max(dp[i][bit],hp-dmg);\n  if(idx==P||hp-dmg>0) return;\n  update(idx+1,bit,hp,dmg,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),dmg,i);\n}\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit],dmg[mp[y][x]],i+1);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  int cnt=0;\n  while(1){\n    cnt++;\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n    \n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint ihp, mhp;\nint p;\nvi portion, dmg; \nvector<vi> fld;\nint dp[1111][2222];\n\nbool solve()\n{\n\tdp[0][0] = ihp;\n\tREP(i, dmg.size())\n\t{\n\t\tREP(j, 1 << p)\n\t\t{\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tchmax(dp[i + 1][j], dp[i][j] - dmg[i]);\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif (!((j >> k) & 1))\n\t\t\t\t{\n\t\t\t\t\tchmax(dp[i][j | (1 << k)], min(mhp, dp[i][j] + portion[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 1 << p)\n\t{\n\t\tif (dp[dmg.size()][i] > 0) return true;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile (cin >> ihp >> mhp, ihp)\n\t{\n\t\tportion.clear();\n\t\tdmg.clear();\n\t\tfld.clear();\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfld.resize(h, vi(w));\n\t\tvs fldc(h);\n\t\tREP(i, h) cin >> fldc[i];\n\t\tint t; cin >> t;\n\t\tmap<char, int> mp;\n\t\tREP(i, t)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tmp[c] = d;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tfld[i][j] = mp[fldc[i][j]];\n\t\t}\n\n\t\tint tx = 0, ty = 0;\n\t\tint s; cin >> s;\n\t\tREP(i, s)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tpii tmp;\n\t\t\tif (c == 'U') tmp = pii(-1, 0);\n\t\t\tif (c == 'D') tmp = pii(1, 0);\n\t\t\tif (c == 'L') tmp = pii(0, -1);\n\t\t\tif (c == 'R') tmp = pii(0, 1);\n\t\t\tREP(j, d)\n\t\t\t{\n\t\t\t\ttx += tmp.first, ty += tmp.second;\n\t\t\t\tdmg.push_back(fld[tx][ty]);\n\t\t\t}\n\t\t}\n\t\tcin >> p;\n\t\tREP(i, p)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\tportion.push_back(a);\n\t\t}\n\t\tMS(dp, -1);\n\t\tputs(solve() ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_num,int arg_state,int arg_currentHP,int arg_sum_damage){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tnum = arg_num;\n\t\tstate = arg_state;\n\t\tcurrentHP = arg_currentHP;\n\t\tsum_damage = arg_sum_damage;\n\t}\n\tint row,col,num,state,currentHP,sum_damage;\n};\n\nint HP,MAX_HP;\nint H,W;\nint damage[26],POW[13],portion[12];\nint max_HP[1001][4096];\nchar base_map[100][101],move_route[1000];\n\n\nvoid func(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tchar buf[2];\n\tint tmp;\n\n\tfor(int i = 0; i < T; i++){\n\t\tscanf(\"%s %d\",buf,&tmp);\n\t\tdamage[buf[0]-'A'] = tmp;\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tint index = 0;\n\n\tfor(int i = 0; i < S; i++){\n\t\tscanf(\"%s %d\",buf,&tmp);\n\t\tfor(int k = 0; k < tmp; k++){\n\t\t\tmove_route[index++] = buf[0];\n\t\t}\n\t}\n\n\tS = index;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tfor(int i = 0; i < P; i++){\n\t\tscanf(\"%d\",&portion[i]);\n\t}\n\n\tfor(int i = 0; i <= S; i++){\n\t\tfor(int k = 0; k < POW[P]; k++)max_HP[i][k] = 0;\n\t}\n\n\tqueue<Info> Q;\n\tmax_HP[0][0] = HP;\n\tQ.push(Info(0,0,0,0,HP,0));\n\n\tint next_row,next_col,next_damage,next_HP;\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().num == S){\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn;\n\t\t}else if(Q.front().currentHP < max_HP[Q.front().num][Q.front().state]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tswitch(move_route[Q.front().num]){\n\t\t\tcase 'U':\n\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnext_damage = damage[base_map[next_row][next_col]-'A'];\n\n\t\t\tif(next_damage == 0){\n\t\t\t\tif(max_HP[Q.front().num+1][Q.front().state] < Q.front().currentHP){\n\t\t\t\t\tmax_HP[Q.front().num+1][Q.front().state] = Q.front().currentHP;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num+1,Q.front().state,Q.front().currentHP,Q.front().sum_damage));\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tfor(int next_state = Q.front().state; next_state < POW[P];next_state++){\n\n\t\t\t\t\tFLG = true;\n\t\t\t\t\ttmp = 0;\n\n\t\t\t\t\tfor(int loop = 0; loop < P; loop++){\n\t\t\t\t\t\tif((Q.front().state&(1 << loop)) == 0 && (next_state&(1 << loop)) != 0){\n\t\t\t\t\t\t\ttmp += portion[loop];\n\t\t\t\t\t\t}else if((Q.front().state&(1 << loop)) != 0 && (next_state&(1 << loop)) == 0){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tnext_HP = min(MAX_HP,Q.front().currentHP+tmp);\n\n\t\t\t\t\tif(next_HP <= next_damage)continue;\n\n\t\t\t\t\tnext_HP -= next_damage;\n\n\t\t\t\t\tif(max_HP[Q.front().num+1][next_state] < next_HP){\n\t\t\t\t\t\tmax_HP[Q.front().num+1][next_state] = next_HP;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num+1,next_state,next_HP,Q.front().sum_damage+next_damage));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"NO\\n\");\n}\n\nint main(){\n\n\tfor(int i = 0; i < 13; i++)POW[i] = pow(2,i);\n\n\tfor(int i = 0; i < 26; i++)damage[i] = 999;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&HP,&MAX_HP);\n\t\tif(HP == 0 && MAX_HP == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\n#define MAX 101\nusing namespace std;\n\nint a,b,h,w,t,s,p,P[12];\nstring dungeon[MAX];\nint grid[MAX][MAX];\npair<char,int> S[1001];\nint Steps[1001];\nint dp[1001][(1<<12)];\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\n\nint f(char c){\n  if(c=='U')return 0;\n  if(c=='R')return 1;\n  if(c=='D')return 2;\n  return 3;\n}\n\nint main()\n{\n  while(1){\n    cin>>a>>b;\n    if(a+b==0)break;\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n      cin>>dungeon[i];\n    }\n    cin>>t;\n    map<char,int> T;\n    for(int i=0;i<t;i++){\n      char t1;\n      int t2;\n      cin>>t1>>t2;\n      T[t1]=t2;\n    }\n    cin>>s;\n    for(int i=0;i<s;i++)cin>>S[i].f>>S[i].s;\n    cin>>p;\n    for(int i=0;i<p;i++)cin>>P[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)grid[i][j]=T[dungeon[i][j]];\n    }\n    int ni=0,nj=0,c=0;\n    Steps[c++]=0;\n    for(int i=0;i<s;i++){\n      int muki=f(S[i].f);\n      for(int j=0;j<S[i].s;j++){\n\tni+=Y[muki];\n\tnj+=X[muki];\n\tSteps[c++]=grid[ni][nj];\n      }\n    }\n    for(int i=0;i<c;i++){\n      for(int j=0;j<(1<<p);j++)dp[i][j]=0;\n    }\n    for(int i=0;i<(1<<p);i++)dp[0][i]=a;\n    for(int step=1;step<c;step++){\n      for(int i=0;i<(1<<p);i++){\n\tif(dp[step-1][i]==0)continue;\n\tfor(int j=0;j<p;j++){\n\t  if((i>>j)%2==0)continue;\n\t  int nhp=min(dp[step-1][i]+P[j],b);\n\t  dp[step][i-(1<<j)]=max(dp[step][i-(1<<j)],\n\t\t\t\t max(0,nhp-Steps[step]));\n\t}\n\tdp[step][i]=max(dp[step][i],dp[step-1][i]-Steps[step]);\n      }\n    }\n    bool flag=false;\n    for(int i=0;i<(1<<p);i++){\n      if(0<dp[c-1][i])flag=true;\n    }\n    if(flag)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h0,hmax;cin>>h0>>hmax && h0|hmax;){\n\t\tint h,w; cin>>h>>w;\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tmap<char,int> dmgs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdmgs[c]=x;\n\t\t\t}\n\t\t}\n\t\tstring dirs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdirs.append(x,c);\n\t\t\t}\n\t\t}\n\t\tint m=dirs.size();\n\t\tint n; cin>>n;\n\t\tvi pots(n);\n\t\trep(i,n) cin>>pots[i];\n\t\t\n\t\tvi decs(m);\n\t\tfor(int i=0,j=0,k=0;k<m;k++){\n\t\t\ti+=\"\\xff\\x1\\0\\0\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tj+=\"\\0\\0\\xff\\x1\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tdecs[k]=dmgs[grid[i][j]];\n\t\t}\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) sums[i]+=pots[j];\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(0,h0,(1<<n)-1); // (step,hp,rest)\n\t\tvvi vis(m,vi(1<<n));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint ci,ch,cr; tie(ci,ch,cr)=q.front(); q.pop();\n\t\t\tif(ci==m){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cr]>=ch) continue;\n\t\t\tvis[ci][cr]=ch;\n\t\t\tch-=decs[ci];\n\t\t\tif(ch>0){\n\t\t\t\tq.emplace(ci+1,ch,cr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int s=cr;s;s=s-1&cr){\n\t\t\t\tint nh=min(ch+sums[s],hmax);\n\t\t\t\tif(nh>0)\n\t\t\t\t\tq.emplace(ci+1,nh,cr^s);\n\t\t\t}\n\t\t}\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\nint HpInit, HpMax;\nint H, W;\nvector<string> G;\nint cost[256];\nint portion[12];\nint calc_heal[1<<12];\n\ntypedef pair<int, int> pii;\nvector<pii> v;\n\nint main() {\n\n  while(cin >> HpInit >> HpMax && (HpInit | HpMax)) {\n    cin >> H >> W;\n    G.clear(); G.resize(H);\n    rep(i, H) cin >> G[i];\n    int Q; cin >> Q;\n    rep(i, Q) {\n      char c; cin >> c;\n      cin >> cost[(int)c];\n    }\n\n    v.clear();\n    int y = 0, x = 0;\n\n    cin >> N;\n    rep(i, N) {\n      char d; cin >> d;\n      int n; cin >> n;\n      if(d == 'L') { rep(i, n) v.push_back({y, x-i-1}); x -= n; }\n      if(d == 'U') { rep(i, n) v.push_back({y-i-1, x}); y -= n; }\n      if(d == 'R') { rep(i, n) v.push_back({y, x+i+1}); x += n; }\n      if(d == 'D') { rep(i, n) v.push_back({y+i+1, x}); y += n; }\n    }\n\n    cin >> M;\n    rep(i, M)\n      cin >> portion[i];\n\n    rep(S, 1<<M) {\n      calc_heal[S] = 0;\n      rep(i, M) if(S >> i & 1)\n        calc_heal[S] += portion[i];\n    }\n\n    static int dp[1010][1<<12];\n    rep(i, 1010) rep(j, 1<<12) dp[i][j] = -inf;\n    dp[0][0] = HpInit;\n\n    rep(i, v.size()) {\n      const int damage = cost[(int)G[v[i].first][v[i].second]];\n      // https://twitter.com/meguru_comp/status/697048789941530624\n      rep(PS, 1<<M) {\n        if(dp[i][PS] <= 0) continue;\n        REP(NPS, PS, 1<<M) if((NPS | PS) == NPS) {\n//          cout << \" PS: \" << std::bitset<12>(PS) << \"\\nNPS: \" << std::bitset<12>(NPS) << \"\\n\\n\";\n          const int heal = calc_heal[NPS ^ PS];\n          const int cand = min(HpMax, dp[i][PS] + heal) - damage;\n          if(cand > 0) maximize(dp[i+1][NPS], cand);\n        }\n      }\n    }\n\n    bool ok = 0;\n\n    rep(i, 1<<M) {\n      ok |= dp[v.size()][i] > 0;\n    }\n\n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][1<<12];\nsigned main(){\n  int hi,hm;\n  while(cin>>hi>>hm,hi||hm){\n    int r,c;\n    cin>>r>>c;\n    string a[r];\n    for(int i=0;i<r;i++) cin>>a[i];\n    int t;\n    cin>>t;\n    char b[t];\n    int d[t];\n    for(int i=0;i<t;i++) cin>>b[i]>>d[i];\n    int s;\n    cin>>s;\n    char e[s];\n    int n[s];\n    for(int i=0;i<s;i++) cin>>e[i]>>n[i];\n    int q;\n    cin>>q;\n    int p[q];\n    for(int i=0;i<q;i++) cin>>p[i];\n    //puts(\"OK\");\n    map<char,int> dm;\n    for(int i=0;i<t;i++) dm[b[i]]=d[i];\n    string udlr=\"UDLR\";\n    map<char,int> rd;\n    for(int i=0;i<(int)udlr.size();i++) rd[udlr[i]]=i;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hi;\n    int z=0;\n    int ax[]={0,0,-1,1};\n    int ay[]={-1,1,0,0};\n    int px=0,py=0;\n    for(int x=0;x<s;x++){\n      for(int y=0;y<n[x];y++){\n\tint k=rd[e[x]];\n\tpx+=ax[k];\n\tpy+=ay[k];\n\t//cout<<px<<\" \"<<py<<endl;\n\tfor(int i=0;i<(1<<q);i++){\n\t  if(!dp[z][i]) continue;\n\t  for(int j=0;j<(1<<q);j++){\n\t    if((j&i)!=i) continue;\n\t    int w=j^i,rs=0;\n\t    for(int l=0;l<q;l++) if((w>>l)&1) rs+=p[l];\n\t    int tmp=min(hm,dp[z][i]+rs)-dm[a[py][px]];\n\t    if(tmp<=0) continue;\n\t    dp[z+1][j]=max(dp[z+1][j],tmp);\n\t  }\n\t}      \n\tz++;\n      }\n    }\n    bool f=0;\n    for(int i=0;i<(1<<q);i++) f|=dp[z][i];\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  int init_hp,max_hp;\n  while(cin>>init_hp>>max_hp,init_hp|max_hp){\n    int r,c;\n    cin>>r>>c;\n    vs a(r);\n    REP(i,r){\n      cin>>a[i];\n    }\n\n    int t;\n    cin>>t;\n    map<char,int> d;\n    REP(i,t){\n      char c;\n      int dd;\n      cin>>c>>dd;\n      d[c]=dd;\n    }\n    int s;\n    cin>>s;\n    int cy=0,cx=0;\n    vi damages(1);\n    int cy=0,cx=0;                                                                                                                                                                                                                                                                                                  [0/1815]\n    vi damages(1);\n    REP(i,s){\n      char dd;\n      int n;\n      cin>>dd>>n;\n      int dy=0,dx=0;\n      switch(dd){\n        case 'U':\n          dy=-1;break;\n        case 'D':\n          dy=1;break;\n        case 'L':\n          dx=-1;break;\n        case 'R':\n          dx=1;break;\n      }\n      REP(j,n){\n        cy+=dy;\n        cx+=dx;\n        damages.push_back(d[a[cy][cx]]);\n      }\n    }\n\n    int P;\n    cin>>P;\n    vi p(P);\n    REP(i,P){\n      cin>>p[i];\n    }\n\n    int n=damages.size();\n    vvi dp(n+1,vi(1<<P));\n    dp[0][0]=init_hp;\n    REP(i,n){\n      REP(j,1<<P){\n        if(dp[i][j]>0){\n          if(dp[i][j]<=damages[i]){\n            REP(k,1<<P){\n              bool ok=true;\n              int cured=0;\n              REP(l,P){\n                if((k>>l)&1){\n                  cured+=p[l];\n                }\n                if((j>>l)&(k>>l)&1){\n                  ok=false;\n                }\n              }\n              if(ok){\n                dp[i+1][j|k]=max(dp[i+1][j|k],min(max_hp,dp[i][j]+cured-damages[i]));\n              }\n            }\n          }else{\n            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-damages[i]);\n          }\n        }\n      }\n    }\n    /*\n    REP(i,n+1){\n      REP(j,1<<P){\n        cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n    */\n    bool ok=false;\n    REP(j,1<<P){\n      if(dp[n][j]>0){\n        ok=true;\n      }\n    }\n    cout<<(ok?\"YES\":\"NO\")<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  int init_hp,max_hp;\n  while(cin>>init_hp>>max_hp,init_hp|max_hp){\n    int r,c;\n    cin>>r>>c;\n    vs a(r);\n    REP(i,r){\n      cin>>a[i];\n    }\n\n    int t;\n    cin>>t;\n    map<char,int> d;\n    REP(i,t){\n      char c;\n      int dd;\n      cin>>c>>dd;\n      d[c]=dd;\n    }\n    int s;\n    cin>>s;\n    int cy=0,cx=0;\n    vi damages;\n    REP(i,s){\n      char dd;\n      int n;\n      cin>>dd>>n;\n      int dy=0,dx=0;\n      switch(dd){\n        case 'U':\n          dy=-1;break;\n        case 'D':\n          dy=1;break;\n        case 'L':\n          dx=-1;break;\n        case 'R':\n          dx=1;break;\n      }\n      REP(j,n){\n        cy+=dy;\n        cx+=dx;\n        damages.push_back(d[a[cy][cx]]);\n      }\n    }\n\n    int P;\n    cin>>P;\n    vi p(P);\n    REP(i,P){\n      cin>>p[i];\n    }\n\n    vi cured(1<<P);\n    REP(i,1<<P){\n      REP(j,P){\n        if((i>>j)&1){\n          cured[i]+=p[j];\n        }\n      }\n    }\n\n    int n=damages.size();\n    vvi dp(n+1,vi(1<<P));\n    dp[0][0]=init_hp;\n    REP(i,n){\n      REP(j,1<<P){\n        if(dp[i][j]>0){\n          if(dp[i][j]<=damages[i]){\n            REP(k,1<<P){\n              bool ok=true;\n              if(j&k){\n                ok=false;\n              }\n              if(ok){\n                dp[i+1][j|k]=max(dp[i+1][j|k],min(max_hp,dp[i][j]+cured[k])-damages[i]);\n              }\n            }\n          }else{\n            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-damages[i]);\n          }\n        }\n      }\n    }\n    /*\n    REP(i,n+1){\n      REP(j,1<<P){\n        cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n    */\n    bool ok=false;\n    REP(j,1<<P){\n      if(dp[n][j]>0){\n        ok=true;\n      }\n    }\n    cout<<(ok?\"YES\":\"NO\")<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n\nint dp[MAX][1<<MAX_P];\n\nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n        \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n        \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n\n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n        \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] <= 0) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < P; k++) {\n                    if (j >> k & 1) continue;\n                    dp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], min(dp[i][j] + p[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\n#define chmax(x,y) x=max(x,y)\nint sh,hmax,H,W,S,T,P;\nvector<int> p;\nmap<char,int> d;\nvector<int> n;\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstring s[100];\nint dp[1<<12];\nint main(){\n\twhile(true){\n\t\tcin>>sh>>hmax;\n\t\tif(sh==0) break;\n\t\tp.clear();\n\t\td.clear();\n\t\tn.clear();\n\t\tcin>>H>>W;\n\t\trep(i,H) cin>>s[i];\n\t\tcin>>T;\n\t\trep(i,T){\n\t\t\tchar c;\n\t\t\tint x;\n\t\t\tcin>>c>>x;\n\t\t\td[c]=x;\n\t\t}\n\t\tcin>>S;\n\t\trep(i,S){\n\t\t\tchar c;\n\t\t\tint x,X;\n\t\t\tcin>>c>>x;\n\t\t\tif(c=='U') X=0;\n\t\t\tif(c=='R') X=1;\n\t\t\tif(c=='D') X=2;\n\t\t\tif(c=='L') X=3;\n\t\t\trep(j,x) n.pb(X);\n\t\t}\n\t\tcin>>P;\n\t\trep(i,P){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tp.pb(x);\n\t\t}\n\t\trep(j,1<<P) dp[j]=0;\n\t\tdp[0]=sh;\n\t\tint x=0,y=0;\n\t\trep(i,n.size()){\n\t\t\tint di=n[i];\n\t\t\tx+=dx[di],y+=dy[di];\n\t\t\tint dam=d[s[x][y]];\n\t\t\trep(j,1<<P){\n\t\t\t\tif(dp[j]==0||dp[j]>dam) continue;\n\t\t\t\tint a[12];\n\t\t\t\trep(k,P) a[k]=(j>>k)&1;\n\t\t\t\trep(k,P) if(a[k]==0) chmax(dp[j+(1<<k)],min(dp[j]+p[k],hmax));\n\t\t\t}\n\t\t\trep(j,1<<P) dp[j]=max(dp[j]-dam,0);\n\t\t}\n\t\tbool ans=false;\n\t\trep(j,1<<P) if(dp[j]>0) ans=true;\n\t\tif(ans) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,H,r,c,t,s;\nint seq[1000],n,p,pot[12];\nchar fl[100][101],dmg[256];\nint dp[1001][1<<12];\n\nbool solve()\n{\n\trep(i,n+1)rep(j,1<<p)dp[i][j]=0;\n\tdp[0][(1<<p)-1]=h;\n\trep(i,n)for(int j=(1<<p)-1;j>=0;j--)if(dp[i][j]>0)\n\t{\n\t\trep(k,p)if(j&1<<k)\n\t\tdp[i][j^1<<k]=max(dp[i][j^1<<k],min(H,dp[i][j]+pot[k]));\n\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]-seq[i]);\n\t}\n\trep(i,1<<p)if(dp[n][i]>0)return 1;\n\treturn 0;\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&H),h)\n\t{\n\t\tscanf(\"%d%d\",&r,&c);\n\t\trep(i,r)scanf(\"%s\",fl+i);\n\t\t\n\t\tchar a; int b;\n\t\tscanf(\"%d\",&t);\n\t\trep(i,t)scanf(\" %c%d\",&a,&b),dmg[a]=b;\n\t\t\n\t\tint y=0,x=0; n=0;\n\t\tscanf(\"%d\",&s);\n\t\trep(i,s)\n\t\t{\n\t\t\tscanf(\" %c%d\",&a,&b);\n\t\t\trep(j,b)\n\t\t\t{\n\t\t\t\tif(a=='U')y--; if(a=='R')x++;\n\t\t\t\tif(a=='D')y++; if(a=='L')x--;\n\t\t\t\tseq[n++]=dmg[fl[y][x]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&p);\n\t\trep(i,p)scanf(\"%d\",pot+i);\n\t\t\n\t\tputs(solve()?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint dp[1<<12];\nint maxhp,hp;\n\n\nint main() {\n    while(cin>>hp>>maxhp, hp|maxhp) {\n        int r,c,t,s,p,d,n;\n        string str;\n        cin>>r>>c;\n        vector<string> mp(r);\n        for(int i=0; i<r; ++i) cin>>mp[i];\n\n        map<string,int> trap;\n        cin>>t;\n        for(int i=0; i<t; ++i) {\n            cin>>str>>d;\n            trap[str] = d;\n        }\n\n        cin>>s;\n        string move;\n        for(int i=0; i<s; ++i) {\n            cin>>str>>n;\n            move += string(n, str[0]);\n        }\n\n        cin>>p;\n        vector<int> pot(p);\n        for(int i=0; i<p; ++i) cin>>pot[i];\n\n        int x = 0,y = 0;\n        vector<int> dam;\n        dam.push_back(0);\n        for(int i=0; i<move.length(); ++i) {\n            if(move[i] == 'U') y--;\n            else if(move[i] == 'D') y++;\n            else if(move[i] == 'R') x++;\n            else if(move[i] == 'L') x--;\n            dam.push_back(trap[string(1,mp[y][x])]);\n        }\n\n        memset(dp, -1, sizeof(dp));\n        dp[0] = hp;\n\n        for(int i=0; i<dam.size(); ++i) {\n            for(int j=0; j<(1<<p); ++j)\n                if(dp[j] > 0)\n                    for(int k=0; k<p; ++k)\n                        if((j & (1<<k)) == 0) {\n                            dp[j|(1<<k)] = max(dp[j|(1<<k)],\n                                               min(maxhp, dp[j] + pot[k]));\n                        }\n            for(int j=0; j<(1<<p); ++j) dp[j] -= dam[i];\n        }\n                 \n\n        bool ok = false;\n        for(int j=0; j<(1<<p); ++j) if(dp[j] > 0) ok = true;\n        if(ok) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        if(rand() % 2 == 0) continue;\n        if(dp[j] - damage[A[yy][xx]] >= 1) {\n          nextdp[j] = max(nextdp[j], dp[j] - damage[A[yy][xx]]);\n        }\n        for(int k : buff[P][j]) {\n          int get = min(malta, dp[j] + add[k]) - damage[A[yy][xx]];\n          if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-12;\n\nconst double pi =acos(-1.0);\n\nchar str[110][110],type[30][5],route[1010][5];\n\nint damage[30],g[110][110],num[1010],p[20],now[10010],temp[10010];\n\nint dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\n\nint main()\n{\n    int init,maxx,typenum,routenum,i,j,d,ii,k,pp,fuck,cao,flag,n,m,ttemp;\n    while(scanf(\"%d%d\",&init,&maxx)==2)\n    {\n        if(!init&&!maxx)\n            break;\n        flag=0;\n        scanf(\"%d%d\",&n,&m);\n        for(i=0;i<n;i++)\n            scanf(\"%s\",str[i]);\n        scanf(\"%d\",&typenum);\n        for(i=1;i<=typenum;i++)\n            scanf(\"%s%d\",type[i],&damage[i]);\n        for(i=0;i<n;i++)\n            for(j=0;j<m;j++)\n                for(k=1;k<=typenum;k++)\n                {\n                    if(str[i][j]==type[k][0])\n                    {\n                        g[i][j]=damage[k];\n                        break;\n                    }\n                }\n        int nowx=0,nowy=0;\n        scanf(\"%d\",&routenum);\n        for(i=1;i<=routenum;i++)\n            scanf(\"%s%d\",route[i],&num[i]);\n        scanf(\"%d\",&pp);\n        for(i=0;i<pp;i++)\n            scanf(\"%d\",&p[i]);\n        for(i=0;i<(1<<pp);i++)\n        {\n            ttemp=init;\n            for(j=0;j<pp;j++)\n            {\n                if((i&(1<<j))>0)\n                   ttemp+=p[j];\n            }\n            if(ttemp>maxx)\n                ttemp=maxx;\n            now[i]=ttemp;\n        }\n        for(i=1;i<=routenum;i++)\n        {\n            if(route[i][0]=='U')\n                d=0;\n            if(route[i][0]=='D')\n                d=1;\n            if(route[i][0]=='L')\n                d=2;\n            if(route[i][0]=='R')\n                d=3;\n            for(j=1;j<=num[i];j++)\n            {\n                nowx=nowx+dx[d];\n                nowy=nowy+dy[d];\n                fuck=g[nowx][nowy];\n                for(k=0;k<(1<<pp);k++)\n                    temp[k]=now[k];\n                flag=1;\n                for(k=0;k<(1<<pp);k++)\n                {\n                    if(temp[k]==-1)\n                        continue;\n                    flag=0;\n                    for(ii=0;ii<pp;ii++)\n                    {\n                        if(((1<<ii)&k)==0)\n                        {\n                            cao=k+(1<<ii);\n                            if(now[k]+p[ii]>now[cao])\n                                now[cao]=now[k]+p[ii];\n                        }\n                    }\n                }\n           //     printf(\"%d %d %d\\n\",i,j,flag);\n                if(flag==1)\n                    break;\n                for(k=0;k<(1<<pp);k++)\n                    if(now[k]>maxx)\n                        now[k]=maxx;\n                for(k=0;k<(1<<pp);k++)\n                {\n                    if(now[k]<=fuck)\n                        now[k]=-1;\n                    else\n                        now[k]-=fuck;\n                }\n/*\n                printf(\"fuck %d %d\\n\",i,j);\n                for(k=0;k<(1<<pp);k++)\n                {\n                    printf(\"%d %d\\n\",k,now[k]);\n                }\n*/\n            }\n            if(flag==1)\n                break;\n        }\n        flag=1;\n        for(i=0;i<(1<<pp);i++)\n            if(now[i]>0)\n            {\n                flag=0;\n                break;\n            }\n        if(flag==1)\n            printf(\"NO\\n\");\n        else\n            printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,hp,HP;\nchar t[1005][1005];\nint T,S,P;\nmap<char,int> mp;\nvector<int> u;\nint dp[1005][(1<<12)];\nint v[12];\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(hp==0&&HP==0)break;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin>>t[i][j];\n    cin>>T;\n    for(int i=0;i<T;i++){\n      char ch;\n      cin>>ch;\n      cin>>mp[ch];\n    }\n    int y=0,x=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      while(num--){\n        if(ch=='U')y--;\n        if(ch=='R')x++;\n        if(ch=='D')y++;\n        if(ch=='L')x--;\n        u.push_back(mp[ t[y][x] ]);\n      }\n    }\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>v[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hp;\n    int N=u.size();\n    for(int i=0;i<N;i++){\n      for(int S=0;S<(1<<P);S++){\n        if(dp[i][S]==0)continue;        \n        for(int k=0;k<P;k++){\n          if(S>>k&1)continue;\n          int nS=S|(1<<k);\n          dp[i+1][nS]=max(dp[i+1][nS],min(HP,dp[i][S]+v[k]));\n        }\n        dp[i+1][S]=max(dp[i+1][S],dp[i][S]-u[i]);\n      }\n    }\n    string ans=\"NO\";\n    for(int i=0;i<(1<<P);i++)\n      if(dp[N][i]>0)ans=\"YES\";\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,hp,HP;\nchar t[1005][1005];\nint T,S,P;\nmap<char,int> mp;\nvector<int> u;\nint dp[1005][(1<<12)];\nint v[12];\n\nint main(){\n\n  while(1){\n    u.clear();\n    cin>>hp>>HP;\n    if(hp==0&&HP==0)break;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin>>t[i][j];\n    cin>>T;\n    for(int i=0;i<T;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      mp[ch]=num;\n    }\n    int y=0,x=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      while(num--){\n        if(ch=='U')y--;\n        if(ch=='R')x++;\n        if(ch=='D')y++;\n        if(ch=='L')x--;\n        u.push_back(mp[ t[y][x] ]);\n      }\n    }\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>v[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hp;\n    int N=u.size();\n    for(int i=0;i<N;i++){\n      for(int S=0;S<(1<<P);S++){\n        if(dp[i][S]==0)continue;        \n        for(int k=0;k<P;k++){\n          if(S>>k&1)continue;\n          int nS=S|(1<<k);\n          dp[i+1][nS]=max(dp[i+1][nS],min(HP,dp[i][S]+v[k]));\n        }\n        dp[i+1][S]=max(dp[i+1][S],dp[i][S]-u[i]);\n      }\n    }\n    string ans=\"NO\";\n    for(int i=0;i<(1<<P);i++)\n      if(dp[N][i]>0)ans=\"YES\";\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n\n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n    for(int j=0;j<(1<<P);j++){  \n  for(int i=0;i<m;i++){\n\n\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\t\n\tnhp=max(0,nhp-cost[s[y[i+1]][x[i+1]]]);\n\t\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n\n    dir=\"\";\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n\n\nint HPi,HPm,R,C,T,S,P;\nchar mapp[1010][1010];\nint dp[1010][10000],val[10010],HP[20];\nint mu[30];\nint dir[4][2]={-1,0,1,0,0,-1,0,1}; //上下左右\n\nint main()\n{\n    while(~scanf(\"%d%d\",&HPi,&HPm)){\n        if(HPi==0&&HPm==0) break;\n        scanf(\"%d%d\",&R,&C);\n        for(int i=0;i<R;i++)\n            scanf(\"%s\",mapp[i]);\n        scanf(\"%d\",&T);\n        for(int i=0;i<T;i++){\n            char tt[3];\n            int ttt;\n            scanf(\"%s%d\",tt,&ttt);\n            mu[tt[0]-'A']=ttt;\n        }\n        scanf(\"%d\",&S);\n        int nowx=0,nowy=0,cnt=0;\n        for(int i=0;i<S;i++){\n            char tt[3];int ttt;\n            scanf(\"%s%d\",tt,&ttt);\n            while(ttt--){\n                if(tt[0]=='U'){\n                    nowx+=dir[0][0];\n                    nowy+=dir[0][1];\n                }\n                if(tt[0]=='D'){\n                    nowx+=dir[1][0];\n                    nowy+=dir[1][1];\n                }\n                if(tt[0]=='L'){\n                    nowx+=dir[2][0];\n                    nowy+=dir[2][1];\n                }\n                if(tt[0]=='R'){\n                    nowx+=dir[3][0];\n                    nowy+=dir[3][1];\n                }\n\n                val[cnt++]=mu[mapp[nowx][nowy]-'A'];\n            }\n        }\n\n        scanf(\"%d\",&P);\n        for(int i=1;i<=P;i++){\n            scanf(\"%d\",&HP[i]);\n        }\n\n        for(int i=1;i<=cnt;i++)\n        for(int j=0;j<=((1<<P)-1);j++){\n            dp[i][j]=-99999999;\n        }\n        dp[0][0]=HPi;\n\n        for(int i=0;i<cnt;i++){\n            for(int j=0;j<=P;j++){\n                if(j==0){\n                    for(int k=0;k<=((1<<P)-1);k++){\n                        dp[i+1][k]=max(dp[i][k]-val[i],dp[i+1][k]);\n                        dp[i+1][k]=min(HPm,dp[i+1][k]);\n                    }\n                }\n                else{\n                    int use=1<<(j-1);\n                    for(int k=0;k<=((1<<P)-1);k++){\n                        if(k&use){\n                            int sun=k^use;\n                            dp[i+1][k]=max(dp[i+1][k],min(dp[i+1][sun]+HP[j],HPm));\n                            dp[i+1][k]=max(dp[i+1][k],min(dp[i][sun]+HP[j],HPm)-val[i]);\n                            dp[i+1][k]=min(HPm,dp[i+1][k]);\n                        }\n                    }\n                }\n            }\n        }\n\n        int ok=0;\n        for(int i=0;i<=((1<<P)-1);i++){\n            if(dp[cnt][i]>0){\n                ok=1;break;\n            }\n        }\n        if(ok) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int i){\n  Max(dp[i+1][bit],hp);\n  if(idx==P||hp>0) return;\n  update(idx+1,bit,hp,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    int cost = dmg[mp[y][x]];\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit]-cost,i);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n\n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Hp,Hpmax;\nint R,C;\nint T;\nchar fie[111][111];\nint D[256];\nint S;\nint M[1001];\nint P;\nint p[13];\n\nint dm[256];\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nint dp[1001][(1<<12)];\n\nint main(){\n  string s = \"UDLR\";\n  for(int i=0;i<4;i++) dm[(int)s[i]] = i;\n  while( cin >> Hp >> Hpmax && (Hp||Hpmax) ){\n    cin >> R >> C;\n    for(int i=0;i<R;i++)\n      for(int j=0;j<C;j++)\n\tcin >> fie[j][i];\n\n    memset(D,0,sizeof(D));\n    memset(dp,0,sizeof(dp));\n\n    cin >> T;\n    for(int i=0;i<T;i++){\n      char c;\n      int d;\n      cin >> c >> d;\n      D[(int)c] = d;\n    }\n    cin >> S;\n    int cnt = 0;\n    int x = 0, y = 0;\n    for(int i=0;i<S;i++){\n      char c;int n;\n      cin >> c >> n;\n      for(int j=cnt;j<cnt+n;j++){\n\tx += dx[dm[(int)c]]; y += dy[dm[(int)c]];\n\tM[j] = D[(int)fie[x][y]];\t\n\t//\tcout << x << \" \"<< y << \" \"<< M[j] << endl;\n      }\n      cnt += n;\n    }\n    cin >> P;\n    for(int i=0;i<P;i++) cin >> p[i];\n   \n\n    dp[0][0] = Hp;\n    for(int i=0;i<cnt;i++){\n      for(int j=0;j<(1<<P);j++){\n\tif( dp[i][j] == 0 ) continue;\n\t//\tcout << i << \" \"<< bitset<12>(j) << \" \"<< dp[i][j] << endl;\n\tint hp = dp[i][j];\n\tfor(int k=0;k<P;k++){\n\t  if( ( j & (1<<k) ) ) continue;\n\t  int nhp = min( hp + p[k] , Hpmax ) - M[i];\n\t  dp[i+1][j|(1<<k)] = max( dp[i+1][j|(1<<k)], nhp );\n\t}\n\tdp[i+1][j] = max( dp[i+1][j], hp - M[i] );      \n      }\n    }\n\n    bool f = false;\n    for(int i=0;i<(1<<P);i++) if( dp[cnt][i] ) f = true;\n    cout << (f?\"YES\":\"NO\") << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,hp,HP;\nchar t[1005][1005];\nint T,S,P;\nmap<char,int> mp;\nvector<int> u;\nint dp[20005][(1<<12)];\nint v[12];\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(hp==0&&HP==0)break;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin>>t[i][j];\n    cin>>T;\n    for(int i=0;i<T;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      mp[ch]=num;\n    }\n    int y=0,x=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      while(num--){\n        if(ch=='U')y--;\n        if(ch=='R')x++;\n        if(ch=='D')y++;\n        if(ch=='L')x--;\n        u.push_back(mp[ t[y][x] ]);\n      }\n    }\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>v[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hp;\n    int N=u.size();\n    for(int i=0;i<N;i++){\n      for(int S=0;S<(1<<P);S++){\n        if(dp[i][S]==0)continue;        \n        for(int k=0;k<P;k++){\n          if(S>>k&1)continue;\n          int nS=S|(1<<k);\n          dp[i+1][nS]=max(dp[i+1][nS],min(HP,dp[i][S]+v[k]));\n        }\n        dp[i+1][S]=max(dp[i+1][S],dp[i][S]-u[i]);\n      }\n    }\n    string ans=\"NO\";\n    for(int i=0;i<(1<<P);i++)\n      if(dp[N][i]>0)ans=\"YES\";\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][1<<12];\nsigned main(){\n  int hi,hm;\n  while(cin>>hi>>hm,hi||hm){\n    int r,c;\n    cin>>r>>c;\n    string a[r];\n    for(int i=0;i<r;i++) cin>>a[i];\n    int t;\n    cin>>t;\n    char b[t];\n    int d[t];\n    for(int i=0;i<t;i++) cin>>b[i]>>d[i];\n    int s;\n    cin>>s;\n    char e[s];\n    int n[s];\n    for(int i=0;i<s;i++) cin>>e[i]>>n[i];\n    int q;\n    cin>>q;\n    int p[q];\n    for(int i=0;i<q;i++) cin>>p[i];\n    //puts(\"OK\");\n    map<char,int> dm;\n    for(int i=0;i<t;i++) dm[b[i]]=d[i];\n    string udlr=\"UDLR\";\n    map<char,int> rd;\n    for(int i=0;i<(int)udlr.size();i++) rd[udlr[i]]=i;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hi;\n    int z=0;\n    int ax[]={0,0,-1,1};\n    int ay[]={-1,1,0,0};\n    int px=0,py=0;\n    for(int x=0;x<s;x++){\n      for(int y=0;y<n[x];y++){\n\tint k=rd[e[x]];\n\tpx+=ax[k];\n\tpy+=ay[k];\n\t//cout<<px<<\" \"<<py<<endl;\n\tfor(int i=0;i<(1<<q);i++){\n\t  if(!dp[z][i]) continue;\n\t  for(int l=0;l<q;l++){\n\t    if((i>>l)&1) continue;\n\t    int j=i+(1<<l);\n\t    int tmp=min(hm,dp[z][i]+p[i]);\n\t    dp[z][j]=max(dp[z][j],tmp);\n\t    tmp-=dm[a[py][px]];\n\t    if(tmp<=0) continue;\n\t    dp[z+1][j]=max(dp[z+1][j],tmp);\n\t  }\n\t}      \n\tz++;\n      }\n    }\n    bool f=0;\n    for(int i=0;i<(1<<q);i++) f|=dp[z][i];\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int dmg,int i){\n  Max(dp[i][bit],hp-dmg);\n  if(idx==P||hp-dmg>0) return;\n  update(idx+1,bit,hp,dmg,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),dmg,i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit],dmg[mp[y][x]],i+1);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  int cnt=0;\n  while(1){\n    cnt++;\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n    \n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\nint HpInit, HpMax;\nint H, W;\nvector<string> G;\nint cost[256];\nint portion[12];\nint calc_heal[1<<12];\n\ntypedef pair<int, int> pii;\nvector<pii> v;\n\nint main() {\n\n  while(cin >> HpInit >> HpMax && (HpInit | HpMax)) {\n    cin >> H >> W;\n    G.clear(); G.resize(H);\n    rep(i, H) cin >> G[i];\n    int Q; cin >> Q;\n    rep(i, Q) {\n      char c; cin >> c;\n      cin >> cost[(int)c];\n    }\n\n    v.clear();\n    int y = 0, x = 0;\n\n    cin >> N;\n    rep(i, N) {\n      char d; cin >> d;\n      int n; cin >> n;\n      if(d == 'L') { rep(i, n) v.push_back({y, x-i-1}); x -= n; }\n      if(d == 'U') { rep(i, n) v.push_back({y-i-1, x}); y -= n; }\n      if(d == 'R') { rep(i, n) v.push_back({y, x+i+1}); x += n; }\n      if(d == 'D') { rep(i, n) v.push_back({y+i+1, x}); y += n; }\n    }\n\n    cin >> M;\n    rep(i, M)\n      cin >> portion[i];\n\n    rep(S, 1<<M) {\n      calc_heal[S] = 0;\n      rep(i, M) if(S >> i & 1)\n        calc_heal[S] += portion[i];\n    }\n\n    static int sum[1010]; rep(i, 1010) sum[i] = 0;\n    rep(i, v.size()) {\n      if(i) sum[i] += sum[i-1];\n      sum[i] += cost[(int)G[v[i].first][v[i].second]];\n    }\n\n    static int dp[1010][1<<12];\n    rep(i, 1010) rep(j, 1<<12) dp[i][j] = -inf;\n    dp[0][0] = HpInit;\n\n    bool ok = 0;\n\n    rep(i, v.size()) {\n      const int damage = cost[(int)G[v[i].first][v[i].second]];\n      rep(PS, 1<<M) {\n        if(dp[i][PS] <= 0) continue;\n        if(sum[v.size() - 1] - sum[i] + damage < dp[i][PS]) { ok = 1; goto ex; }\n\n        int remain = (1 << M) - 1 - PS;\n        for(int b=remain; b>=0; b--) {\n          b &= remain;\n          int NPS = PS | ((1 << M) - 1 - PS - b);\n          const int heal = calc_heal[NPS ^ PS];\n          const int cand = min(HpMax, dp[i][PS] + heal) - damage;\n          if(cand > 0) maximize(dp[i+1][NPS], cand);\n        }\n      }\n    }\n\n    rep(i, 1<<M) {\n      ok |= dp[v.size()][i] > 0;\n    }\n\n  ex:;\n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int h_init, h_max;\n  while (cin >> h_init >> h_max && h_init + h_max){\n    int R, C, T, P, S;\n    cin >> R >> C;\n\n    vector<string> board(R);\n    vector<char>   order;\n    vector<int>    portions;\n    vector<vector<int> > damage(R, vector<int>(C, 0));\n\n    REP(i, R){\n      cin >> board[i];\n    }\n\n    cin >> T;\n    map<char, int> damage_map;\n    REP(i, T){\n      char c;\n      int d;\n      cin >> c >> d;\n      damage_map[c] = d;\n    }\n\n    REP(i, R) REP(j, C){\n      damage[i][j] = damage_map[board[i][j]];\n    }\n\n    cin >> S;\n    REP(i, S){\n      char dir;\n      int num;\n      cin >> dir >> num;\n      REP(j, num){\n        order.push_back(dir);\n      }\n    }\n\n    cin >> P;\n    portions.resize(P);\n    REP(i, P){\n      cin >> portions[i];\n    }\n    \n    vector<vector<int> > dp(order.size() + 1, vector<int>(1 << P, 0));\n\n    \n    dp[0][(1 << P) - 1] = h_init;\n    int r = 0, c = 0;\n    REP(i, order.size()){\n      int nr = r + (order[i] == 'D' ? 1 : order[i] == 'U' ? -1 : 0);\n      int nc = c + (order[i] == 'R' ? 1 : order[i] == 'L' ? -1 : 0);\n      int da = damage[nr][nc];\n      for (int mask = (1 << P) - 1; mask >= 0; mask--){\n        if (dp[i][mask] == 0) continue;\n\n        if (dp[i][mask] - da > 0){\n          dp[i + 1][mask] = max(dp[i + 1][mask], dp[i][mask] - da);\n        }\n\n        REP(j, P) if (mask & (1 << j)){\n          int nmask = mask ^ (1 << j);\n          int nhit  = min(h_max, dp[i][mask] + portions[j]);\n          dp[i][nmask] = max(dp[i][nmask], nhit);\n        }\n      }\n      r = nr;\n      c = nc;\n    }\n\n    bool goal = false;\n    REP(mask, 1 << P) if (dp[order.size()][mask] > 0) goal = true;\n    cout << (goal ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 108\nint dp[M*10][5000];\nchar map1[M][M];\nint a[M];\nint b[M];\nint c[M];\nint n,m;\nint my_hash[M];\nint o[4][2]={\n    0,-1,\n    1,0,\n    0,1,\n    -1,0\n};\nint min(int x,int y){\n    if(x>y) return y;return x;\n}\nint main(){\n    int sp,tmax;\n    while(~scanf(\"%d%d\",&sp,&tmax)&&(sp+tmax)){\n        scanf(\"%d%d\",&n,&m);\n        for(int i=0;i<n;i++)scanf(\"%s\",&map1[i]);\n        int n1;scanf(\"%d\",&n1);\n        for(int i=0;i<n1;i++){\n            char str[100];\n            int t1;scanf(\"%s%d\",str,&t1);\n            my_hash[str[0]-'A']=t1;\n        }\n        int m1;scanf(\"%d\",&m1);\n        int sx=0,sy=0;\n        int num=1;\n        memset(b,0,sizeof(b));\n        for(int i=0;i<m1;i++){\n            char str[20];int m2;\n            scanf(\"%s%d\",str,&m2);\n            int oo;\n            if(str[0]=='U') oo=3;\n            else if(str[0]=='R') oo=2;\n            else if(str[0]=='D') oo=1;\n            else if(str[0]=='L') oo=0;\n            for(int i=0;i<m2;i++){\n                sx=sx+o[oo][0];\n                sy=sy+o[oo][1];\n                int t1=map1[sx][sy]-'A';\n                b[num++]=my_hash[t1];\n            }\n        }\n//        puts(\"@@@@@@@@@\");\n        int n2;scanf(\"%d\",&n2);\n        for(int i=0;i<n2;i++){\n            scanf(\"%d\",&c[i]);\n        }\n//        for(int i=0;i<num;i++){\n//            printf(\"%d \",b[i]);\n//        }\n//        printf(\"%d!!!\\n\",num);\n//        puts(\"\");\n        memset(dp,0,sizeof(dp));\n        int t2=1<<n2;\n        t2--;\n//        printf(\"%d\\n\",t2);\n        dp[0][t2]=sp;\n        for(int i=0;i<num-1;i++){\n            for(int j=t2;j>=0;j--){\n                if(dp[i][j]<=0) continue;\n                if(dp[i][j]<=b[i+1]){\n//                    printf(\"%d!!!!!\\n\",b[i+1]);\n                    for(int k=0;k<n2;k++){\n                        if(j&(1<<k)){\n                            int tt=j^(1<<k);\n                            dp[i][tt]=min(tmax,dp[i][j]+c[k]);\n                        }\n                    }\n                }\n                else{\n//                    if(b[i+1]==10000) puts(\"****************\");\n                    dp[i+1][j]=dp[i][j]-b[i+1];\n                }\n            }\n        }\n        int flag=0;\n        for(int i=0;i<=t2;i++){\n            if(dp[num-1][i]>0) flag=1;\n//            printf(\"%d  !!\\n\",dp[num-1][i]);\n        }\n        if(flag) puts(\"YES\");else puts(\"NO\");\n    }\n    return 0;\n}\n/*\n1 10\n3 3\nAAA\nCAA\nCBC\n3\nA 0\nB 10000\nC 9\n3\nD 2\nR 1\nU 2\n5\n4\n4\n4\n4\n4\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n\n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n  \n  for(int i=0;i<m;i++){\n\n    for(int j=0;j<(1<<P);j++){\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\n\tnhp=max(0,nhp-cost[s[y[i+1]][x[i+1]]]);\n\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n\n    dir=\"\";\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\nint hp,mhp;\nint r,c;\nint p[26];\nchar str[100][100];\nint map[100][100];\nint yao[100];\nint step[1000];\nchar dir[1000];\nint n,num;\nint min(int a,int b)\n{\n\tif(a<b)return a;else return b;\n}\nbool cal(int *x,int y)\n{\n\twhile(1)\n\t{\n  //  printf(\"#\\n\");\n\tint last=*x;\n\tfor(int i=0;i<num;i++) \n\t\tif(*x+yao[i]>y) {*x=min(*x+yao[i],mhp)-y;yao[i]=0;return true;}\n\tfor(int i=0;i<num;i++)\n\t\tif(yao[i]){*x=*x+yao[i];yao[i]=0;break;}\n\tif(last==*x) return false; \n\t}\n}\nbool search(int v,int xhp,int x,int y)\n{\n\tif(v==n)return true;\n\twhile(step[v]--)\n\t{\n     //   printf(\"!\\n\");\n\t\tif(dir[v]=='U') y--;\n\t\tif(dir[v]=='D') y++;\n\t\tif(dir[v]=='L') x--;\n\t\tif(dir[v]=='R') x++;\n\t\tif(xhp<=map[x][y])\n\t\t{\n\t\t\tif(mhp<=map[x][y])return false;\n\t\t\tif(!cal(&xhp,map[x][y])) return false;\n\t\t}else xhp-=map[x][y];\n\t}\n\treturn search(v+1,xhp,x,y);\n};\nint main(int argc, char const *argv[])\n{\n\twhile(scanf(\"%d %d\",&hp,&mhp)!=EOF)\n\t{\n\t\tif(!hp)break;\n\t\tscanf(\"%d %d\",&r,&c);\n\t\tfor(int i=0;i<r;i++) scanf(\"%s\",str[i]);\n\t\tint t;\n\t\tscanf(\"%d\",&t);\t\n\t\tfor(int i=0;i<26;i++) p[i]=0;\n\t\tfor(int i=0;i<t;i++) \n\t\t{\n\t\t\tchar ch[3];\n\t\t\tint o;\n\t\t\tscanf(\"%s %d\",ch,&o);\n\t\t\tp[ch[0]-'A']=o;\n\t\t}\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<c;j++)\n\t\t\t\tmap[i][j]=p[str[i][j]-'A'];\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tchar ch[3];\n\t\t\tint o;\n\t\t\tscanf(\"%s %d\",ch,&o);\n\t\t\tstep[i]=o;\n\t\t\tdir[i]=ch[0];\n\t\t}\n\t\tscanf(\"%d\",&num);\n\t//\t printf(\"%d\\n\",num); \n\t\tfor(int i=0;i<num;i++) scanf(\"%d\",yao+i);\n\t\tfor(int i=0;i<num;i++)\n\t\t{\n\t\t\tint t=i;\n\t\t\tfor(int j=i;j<num;j++)\n\t\t\tif(yao[t]<yao[j]) t=j;\n\t\t \tint temp=yao[t];\n\t\t \tyao[t]=yao[i];\n\t\t \tyao[i]=temp;\n\t\t}\n\t\tif(search(0,hp,0,0)) printf(\"YES\\n\"); else printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int INIT, MAX;\n  while(cin >> INIT >> MAX && (INIT || MAX)){\n    int H, W;\n    cin >> H >> W;\n    string grid[100];\n    REP(i, H) cin >> grid[i];\n\n    int T;\n    cin >> T;\n    int damage[256];\n    REP(i, T){\n      string s;\n      cin >> s;\n      cin >> damage[s[0]];\n    }\n\n    int S;\n    cin >> S;\n    string dir[1000];\n    int step[1000];\n    REP(i, S) cin >> dir[i] >> step[i];\n\n    string DIRS = \"RDLU\";\n\n    int P;\n    cin >> P;\n    int potion[15];\n    REP(i, P) cin >> potion[i];\n\n    int x = 0, y = 0;\n    int hp[1 << 12] = {};\n    hp[(1 << P) - 1] = INIT;\n    REP(i, S){\n      int r;\n      for(r = 0; r < 4; r++) if(DIRS[r] == dir[i][0]) break;\n\n      REP(_, step[i]){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        assert(valid(nx, ny, W, H));\n        int d = damage[grid[ny][nx]];\n\n        int nhp[1 << 12] = {};\n        for(int s = (1 << P) - 1; s >= 0; s--)if(hp[s] > 0){\n          int hp2 = hp[s] - d;\n          if(hp2 > 0){\n            nhp[s] = hp2;\n          }else{\n            for(int j = 0; j < P; j++)if(s >> j & 1){\n              int hp2 = min(MAX, hp[s] + potion[j]);\n              hp[s & ~(1 << j)] = max(hp[s & ~(1 << j)], hp2);\n            }\n          }\n        }\n\n        REP(s, 1 << P) hp[s] = nhp[s];\n        x = nx, y = ny;\n      }\n    }\n\n    bool ok = false;\n    REP(s, 1 << P) if( hp[s] > 0 ) ok = true;\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int i){\n  Max(dp[i+1][bit],hp);\n  if(idx==P) return;\n  update(idx+1,bit,hp,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    int cost = dmg[mp[y][x]];\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit]-cost,i);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n\n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int hpInit, hpMax, r, c;\n        cin >> hpInit >> hpMax >> r >> c;\n        if(hpInit == 0)\n            return 0;\n\n        vector<string> grid(r);\n        for(int i=0; i<r; ++i)\n            cin >> grid[i];\n\n        int t;\n        cin >> t;\n        vector<int> damage(26);\n        for(int i=0; i<t; ++i){\n            char c;\n            cin >> c;\n            cin >> damage[c-'A'];\n        }\n\n        int s;\n        cin >> s;\n        vector<char> dy, dx;\n        for(int i=0; i<s; ++i){\n            char c;\n            int a;\n            cin >> c >> a;\n            for(int i=0; i<a; ++i){\n                if(c == 'U'){\n                    dy.push_back(-1);\n                    dx.push_back(0);\n                }else if(c == 'D'){\n                    dy.push_back(1);\n                    dx.push_back(0);\n                }else if(c == 'R'){\n                    dy.push_back(0);\n                    dx.push_back(1);\n                }else{\n                    dy.push_back(0);\n                    dx.push_back(-1);\n                }\n            }\n        }\n        s = dy.size();\n\n        int p;\n        cin >> p;\n        vector<int> recover(p);\n        for(int i=0; i<p; ++i)\n            cin >> recover[i];\n\n        vector<vector<int> > dp(s+1, vector<int>(1<<p, 0));\n        dp[0][(1<<p)-1] = hpInit;\n        int y0 = 0;\n        int x0 = 0;\n        for(int i=0; i<s; ++i){\n            int y = y0 + dy[i];\n            int x = x0 + dx[i];\n            for(int j=(1<<p)-1; j>=0; --j){\n                if(dp[i][j] == 0)\n                    continue;\n\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j] - damage[grid[y][x]-'A']);\n\n                bitset<12> bs(j);\n                for(int k=0; k<p; ++k){\n                    if(!bs[k])\n                        continue;\n                    bs[k] = false;\n                    dp[i][bs.to_ulong()] = max(dp[i][bs.to_ulong()], min(dp[i][j] + recover[k], hpMax));\n                    bs[k] = true;\n                }\n            }\n            y0 = y;\n            x0 = x;\n        }\n\n        if(dp[s][0] > 0)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  int init_hp,max_hp;\n  while(cin>>init_hp>>max_hp,init_hp|max_hp){\n    int r,c;\n    cin>>r>>c;\n    vs a(r);\n    REP(i,r){\n      cin>>a[i];\n    }\n\n    int t;\n    cin>>t;\n    map<char,int> d;\n    REP(i,t){\n      char c;\n      int dd;\n      cin>>c>>dd;\n      d[c]=dd;\n    }\n    int s;\n    cin>>s;\n    int cy=0,cx=0;\n    vi damages;\n    REP(i,s){\n      char dd;\n      int n;\n      cin>>dd>>n;\n      int dy=0,dx=0;\n      switch(dd){\n        case 'U':\n          dy=-1;break;\n        case 'D':\n          dy=1;break;\n        case 'L':\n          dx=-1;break;\n        case 'R':\n          dx=1;break;\n      }\n      REP(j,n){\n        cy+=dy;\n        cx+=dx;\n        damages.push_back(d[a[cy][cx]]);\n      }\n    }\n\n    int P;\n    cin>>P;\n    vi p(P);\n    REP(i,P){\n      cin>>p[i];\n    }\n\n    vi cured(1<<P);\n    REP(i,1<<P){\n      REP(j,P){\n        if((i>>j)&1){\n          cured[i]+=p[j];\n        }\n      }\n    }\n\n    int n=damages.size();\n    vvi dp(n+1,vi(1<<P));\n    dp[0][0]=init_hp;\n    REP(i,n){\n      REP(j,1<<P){\n        if(dp[i][j]>0){\n          if(dp[i][j]<=damages[i]){\n            REP(k,1<<P){\n              bool ok=true;\n              if(j&k){\n                ok=false;\n              }\n              if(ok){\n                dp[i+1][j|k]=max(dp[i+1][j|k],min(max_hp,dp[i][j]+cured[k]-damages[i]));\n              }\n            }\n          }else{\n            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-damages[i]);\n          }\n        }\n      }\n    }\n    /*\n    REP(i,n+1){\n      REP(j,1<<P){\n        cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n    */\n    bool ok=false;\n    REP(j,1<<P){\n      if(dp[n][j]>0){\n        ok=true;\n      }\n    }\n    cout<<(ok?\"YES\":\"NO\")<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        if(dp[j] - damage[A[yy][xx]] >= 1) {\n          nextdp[j] = max(nextdp[j], dp[j] - damage[A[yy][xx]]);\n          continue;\n        }\n        for(int k : buff[P][j]) {\n          int get = min(malta, dp[j] + add[k]) - damage[A[yy][xx]];\n          if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\nconst int N = 1<<12;\nint n,m;\nint hpi,hpm;\nchar mz[110][110];\nint T,S,P;\nint val[30];\nchar op[1100][2];\nint num[1100];\nint p[15];\nint dp[2][N];\nint hp[N];\nconst int dx[4] = {0,0,1,-1};\nconst int dy[4] = {1,-1,0,0};\nint idx(char s){\n    if (s == 'R') return 0;\n    if (s == 'L') return 1;\n    if (s == 'U') return 3;\n    if (s == 'D') return 2;\n}\nvoid solve(){\n    memset(hp,0,sizeof(hp));\n    for (int i = 0; i < (1<<P); i++) {\n        for (int j = 0; j < P; j++) {\n            if (i&(1<<j)) hp[i] += p[j];\n        }\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = hpi;\n    int x = 0, y = 0;\n    int pos = 0;\n    for (int i = 0; i < (1<<P); i++) {\n        dp[0][i] = hpi+hp[i];\n        if (dp[0][i] > hpm) dp[0][i] = hpm;\n      //  cout<<dp[0][i]<<\" +++ \";\n    }\n    int re = 0;\n    for (int i = 0; i < S; i++) {\n        int d = idx(op[i][0]);\n        for (int j = 0; j < num[i]; j++) {\n            x += dx[d]; y += dy[d];\n            int v = val[mz[x][y] - 'A'];\n          //  re += v;\n            //cout<<x<<\" \"<<y<<\" \"<<v<<\" *** \"<<endl;\n            if (dp[pos][0] - v > 0) {\n                dp[pos^1][0] = max(dp[pos^1][0],dp[pos][0] - v);\n            }\n            for (int k = 1; k < (1<<P); k++) {\n                for (int w = k; w; w = k&(w-1)) {\n                     if (dp[pos][w] - v > 0){\n                        dp[pos^1][k] = max(dp[pos^1][k],dp[pos][w] - v + hp[k^w]);\n                        if (dp[pos^1][k]> hpm) dp[pos^1][k] = hpm;\n                     }\n                }\n\n               // cout<<dp[pos^1][k]<<\" \";\n            }//cout<<endl;\n            memset(dp[pos],0,sizeof(dp[pos]));\n            pos ^= 1;\n        }\n\n    }\n    //cout<<\" --- \"<<re<<endl;\n    int ret = 0;\n    for (int i = 0; i < (1<<P); i++)\n    if (dp[pos][i] > 0) ret = 1;\n    puts(ret?\"YES\":\"NO\");\n}\nint main(){\n    while (~scanf(\"%d%d\",&hpi,&hpm),hpi+hpm) {\n        scanf(\"%d%d\",&n,&m);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\",mz[i]);\n        }\n        scanf(\"%d\",&T);\n        for (int i = 0; i < T;i++) {\n            char t[2];\n            scanf(\"%s\",t);\n            int v;\n            scanf(\"%d\",&v);\n            val[t[0]-'A'] = v;\n        }\n        scanf(\"%d\",&S);\n        for (int i = 0; i < S; i++){\n            scanf(\"%s%d\",op[i],&num[i]);\n        }\n        scanf(\"%d\",&P);\n        for (int i = 0; i < P; i++) {\n            scanf(\"%d\",p+i);\n        }\n        solve();\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint dy[201];\nint dx[201];\nint dp[1010][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000;\n\n// S[©çßÄX^[gÖü©¤\nint dfs(int pos,int s){\n\tif(pos==-1){\n\t\tint sum=0;\n\t\t// Ü¾gpµÄ¢È¢àÌð·×Äg¤\n\t\tfor(int i=0;i<P;i++)if(!((s>>i)&1))sum+=portions[i];\n\t\treturn sum+inithp;\n\t}\n\telse if(dp[pos][s]!=-1)return dp[pos][s];\n\tint res=-INF;\n\t// Ü¾gpµÄ¢È¢portionðgp\n\tfor(int k=0;k<P;k++)if(!((s>>k)&1))res=max(res,min(dfs(pos,s|(1<<k))+portions[k],maxhp));\n\t// ÌêÖ\n\tres=max(res,dfs(pos-1,s)-stepDmg[pos]);\n\tif(res<0)res=-INF;\n\treturn dp[pos][s]=res;\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tcin>>r>>c;\n\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint m;\n\t\t\tcin>>ch>>m;\n\t\t\tdmg[ch]=m;\n\t\t}\n\t\tcin>>S;\n\t\tint cx=0;\n\t\tint cy=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\tfor(int j=0;j<quan;j++){\n\t\t\t\tint ny=cy+dy[ch];\n\t\t\t\tint nx=cx+dx[ch];\n\t\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\t\tstep++;\n\t\t\t\tcx=nx;\n\t\t\t\tcy=ny;\n\t\t\t}\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portions[i];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tif(dfs(step-1,0)>0)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}\n\n//#include <cstdio>\n//#include <iostream>\n//#include <vector>\n//#include <list>\n//#include <cmath>\n//#include <fstream>\n//#include <algorithm>\n//#include <string>\n//#include <queue>\n//#include <set>\n//#include <map>\n//#include <complex>\n//#include <iterator>\n//#include <cstdlib>\n//#include <cstring>\n//#include <sstream>\n//using namespace std;\n//\n//int R,C;\n//int S;\n//int T;\n//int P;\n//int hpInit;\n//int hpMax;\n//char dmg[101][101];\n//int tbl[101];\n//pair<char,int> seq[1010];\n//int portion[101];\n//int combPortionEf[1<<12];\n//pair<int,int> points[1010];\n//int dp[2][1<<12];\n//int dy[101];\n//int dx[101];\n//\n//const int INF=1000000000;\n//\n//int main(){\n//\n//\tdy['U']=-1;\n//\tdx['U']=0;\n//\tdy['R']=0;\n//\tdx['R']=1;\n//\tdy['D']=1;\n//\tdx['D']=0;\n//\tdy['L']=0;\n//\tdx['L']=-1;\n//\n//\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n//\t\tmemset(dp,0,sizeof(dp));\n//\t\tmemset(portion,0,sizeof(portion));\n//\t\tmemset(combPortionEf,0,sizeof(combPortionEf));\n//\t\tmemset(tbl,0,sizeof(tbl));\n//\t\tmemset(dmg,0,sizeof(dmg));\n//\n//\t\tcin>>R>>C;\n//\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n//\t\tcin>>T;\n//\t\tfor(int i=0;i<T;i++){\n//\t\t\tchar ch;\n//\t\t\tint quan;\n//\t\t\tcin>>ch>>quan;\n//\t\t\ttbl[ch]=quan;\n//\t\t}\n//\t\tcin>>S;\n//\t\tfor(int i=0;i<S;i++){\n//\t\t\tint a;char b;\n//\t\t\tcin>>b>>a;\n//\t\t\tseq[i]=make_pair(b,a);\n//\t\t}\n//\t\tcin>>P;\n//\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n//\t\tfor(int i=0;i<(1<<P);i++){\n//\t\t\tint sum=0;\n//\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n//\t\t\tcombPortionEf[i]=sum;\n//\t\t}\n//\t\tint cx,cy;\n//\t\tcx=cy=0;\n//\t\tpoints[0].first=points[0].second=0;\n//\t\tint idx=1;\n//\t\tfor(int i=0;i<S;i++){\n//\t\t\t// seq[pos].secondñ®©·\n//\t\t\tfor(int j=0;j<seq[i].second;j++){\n//\t\t\t\tint nx=cx+dx[seq[i].first];\n//\t\t\t\tint ny=cy+dy[seq[i].first];\n//\t\t\t\tcy=ny,cx=nx;\n//\t\t\t\tpoints[idx].first=cy;\n//\t\t\t\tpoints[idx].second=cx;\n//\t\t\t\tidx++;\n//\t\t\t}\n//\t\t}\n//\t\tfor(int j=0;j<(1<<P);j++)\n//\t\t\tdp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n//\t\tbool ok=false;\n//\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n//\t\t// iÔÚÜÅÝÄjÌportionªcÁÄ¢éÌÅåcèCtðßé\n//\t\tfor(int i=1;i<idx;i++){\n//\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n//\t\t\t\tint cur=(i-1)%2;\n//\t\t\t\tint nxt=(i)%2;\n//\t\t\t\tdp[nxt][j]=-INF;\n//\t\t\t\tfor(int k=0;k<P;k++){\n//\t\t\t\t\tif(!((j>>k)&1))\n//\t\t\t\t\t\tdp[nxt][j]=max(dp[nxt][j],min(hpMax,dp[nxt][j|(1<<k)]+portion[k]));\n//\t\t\t\t}\n//\t\t\t\tint ny=points[i].first;\n//\t\t\t\tint nx=points[i].second;\n//\t\t\t\tdp[nxt][j]=max(dp[nxt][j],dp[cur][j]-tbl[dmg[ny][nx]]);\n//\t\t\t\t// 0ÈºÈçABsÂ\\\n//\t\t\t\tif(dp[nxt][j]<=0)dp[nxt][j]=-INF;\n//\t\t\t\tif(i==idx-1&&dp[nxt][j]>0)ok=true;\n//\t\t\t}\n//\t\t}\n//\t\t// S[BÉAÅåCtª0æèå«¯êÎok\n//\t\tif(ok)cout<<\"YES\"<<endl;\n//\t\telse cout<<\"NO\"<<endl;\n//\t}\n//\treturn 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define inf 1000000000\n\nusing namespace std;\n\nint HP, HPmax;\nint R, C;\nchar a[105][105];\n\nint T;\nmap<char, int> trap;\nint S;\nint dmg[1005];\nint P;\nint potion[13];\n\nint N;\nint dp[1005][1 << 12];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> HP >> HPmax;\n\t\tif(HP == 0 && HPmax == 0) break;\n\t\t\n\t\tcin >> R >> C;\n\t\tfor(int y = 0; y < R; y++){\n\t\t\tfor(int x = 0; x < C; x++){\n\t\t\t\tcin >> a[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> T;\n\t\tchar c; int d;\n\t\ttrap.clear();\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> c >> d;\n\t\t\ttrap[c] = d;\n\t\t}\n\t\t\n\t\tcin >> S;\n\t\tint x = 0, y = 0, cnt = 0, dir;\n\t\tconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> c >> d;\n\t\t\tif(c == 'R') dir = 0;\n\t\t\tif(c == 'U') dir = 1;\n\t\t\tif(c == 'L') dir = 2;\n\t\t\tif(c == 'D') dir = 3;\n\t\t\tfor(int j = 0; j < d; j++){\n\t\t\t\tx += dx[dir], y += dy[dir];\n\t\t\t\tcnt++;\n\t\t\t\tdmg[cnt] = trap[a[x][y]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor(int i = 0; i < P; i++) cin >> potion[i];\n\t\t\n\t\tN = cnt;\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int s = 0; s < (1 << P); s++){\n\t\t\t\tdp[i][s] = -inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = HP;\n\t\t\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int j = 0; j < (1 << P); j++){\n\t\t\t\tif(dp[i][j] <= 0) continue;\n\t\t\t\tif(dp[i][j] - dmg[i+1] <= 0){\n\t\t\t\t\tfor(int k = 0; k < P; k++){\n\t\t\t\t\t\tif(j & (1<<k)) continue;\n\t\t\t\t\t\tdp[i+1][j|(1<<k)] = max(dp[i+1][j|(1<<k)], dp[i][j] + potion[k] - dmg[i+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j] - dmg[i+1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tfor(int i = 0; i < (1<<P); i++){\n\t\t\tif(dp[N][i] > 0){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\t\t\n\t\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nint dy[201];\nint dx[201];\nint dp[2][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000LL;\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tint nxt=(i+1)%2;\n\t\t\tint cur=i%2;\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1)&&dp[nxt][s|(1<<k)]>0){\n\t\t\t\t\t\tres=max(res,min(dp[nxt][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t\t}\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[cur][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[nxt][s]=min(maxhp,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step%2][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int i){\n  Max(dp[i+1][bit],hp);\n  if(idx==P||hp>0) return;\n  update(idx+1,bit,hp,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    int cost = dmg[mp[y][x]];\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit]-cost,i);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>w>>h;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n\n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h0,hmax;cin>>h0>>hmax && h0|hmax;){\n\t\tint h,w; cin>>h>>w;\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tmap<char,int> dmgs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdmgs[c]=x;\n\t\t\t}\n\t\t}\n\t\tstring dirs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdirs.append(x,c);\n\t\t\t}\n\t\t}\n\t\tint m=dirs.size();\n\t\tint n; cin>>n;\n\t\tvi pots(n);\n\t\trep(i,n) cin>>pots[i];\n\t\t\n\t\tvi decs(m);\n\t\tfor(int i=0,j=0,k=0;k<m;k++){\n\t\t\ti+=\"\\xff\\x1\\0\\0\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tj+=\"\\0\\0\\xff\\x1\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tdecs[k]=dmgs[grid[i][j]];\n\t\t}\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) sums[i]+=pots[j];\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(0,h0,(1<<n)-1); // (step,hp,rest)\n\t\tvvi vis(m,vi(1<<n));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint ci,ch,cr; tie(ci,ch,cr)=q.front(); q.pop();\n\t\t\tif(ci==m){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cr]>=ch) continue;\n\t\t\tvis[ci][cr]=ch;\n\t\t\tif(ch-decs[ci]>0){\n\t\t\t\tq.emplace(ci+1,ch-decs[ci],cr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int s=cr;s;s=s-1&cr){\n\t\t\t\tint nh=min(ch+sums[s],hmax);\n\t\t\t\tif(nh-decs[ci]>0)\n\t\t\t\t\tq.emplace(ci+1,nh-decs[ci],cr^s);\n\t\t\t}\n\t\t}\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstring>\n#include<functional>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define f first\n#define s second\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nchar buff[110][110];\nint trap[256];\nchar seqC[1000];\nint seqI[1000];\nint potion[12];\nint stage[100][100];\nint R,C,T,S,P;\nint hpMax, hpInit;\nint memo[1024][1<<12];\nbool visit[1024][1<<12];\nint dm[1024];\nint ptmp[1<<12];\nint dtmp[1024];\n\nint dx[256];\nint dy[256];\n\nint main(){\n  dx['U'] = 0;\n  dx['D'] = 0;\n  dx['R'] = 1;\n  dx['L'] = -1;\n\n  dy['U'] = -1;\n  dy['D'] = 1;\n  dy['R'] = 0;\n  dy['L'] = 0;\n\n  while(scanf(\"%d%d\",&hpInit,&hpMax),hpMax+hpInit){\n\n    scanf(\"%d%d \",&R,&C);\n    REP(i,R) scanf(\"%s \",buff[i]);\n\n    scanf(\"%d \",&T);\n    REP(i,T){\n      char c; int d;\n      scanf(\"%c %d \",&c,&d);\n      trap[c] = d;\n    }\n\n    scanf(\"%d \",&S);\n    REP(i,S) scanf(\"%c %d \",&seqC[i],&seqI[i]);\n\n    scanf(\"%d \",&P);\n    REP(i,P) scanf(\"%d \",&potion[i]);\n\n    REP(i,R) REP(j,C) stage[i][j] = trap[buff[i][j]];\n\n    int ss = 0;\n    {\n      int x = 0;\n      int y = 0;\n\n      REP(i,S){\n        char c = seqC[i];\n        int  n = seqI[i];\n\n        REP(j,n){\n          x += dx[c];\n          y += dy[c];\n          //printf(\"%d %d : %d\\n\",x,y,stage[y][x]);\n          dm[ss++] = stage[y][x];\n        }\n      }\n    }\n\n    REP(i,1<<P){\n      int sum = 0;\n      REP(j,P) if(i & (1<<j))\n        sum += potion[j];\n      ptmp[i] = sum;\n    }\n\n    {\n      int sum = 0;\n      for(int i=ss-1; i>=0; i--){\n        sum += dm[i];\n        dtmp[i] = sum;\n      }\n    }\n    //    REP(i,ss) printf(\"dtmp[%d]: %d\\n\",i,dtmp[i]);\n\n    REP(i,ss+1) REP(j,1<<P) memo[i][j] = 0;\n    memo[0][(1<<P)-1] = hpInit;\n\n    REP(i,ss) for(int j=(1<<P)-1; j>=0; j--){\n      if(memo[i][j]){\n        int tt = j;\n        if(memo[i][j] != hpMax){\n          REP(k,P) if(j & (1<<k)){\n            int hh = min(hpMax,memo[i][j] + potion[k]);\n            memo[i][j^(1<<k)] = max(memo[i][j^(1<<k)], hh);\n          }\n        }\n        memo[i+1][j] = max(memo[i+1][j], memo[i][j] - dm[i]);\n      }\n    }\n\n    bool ans = false;\n    REP(i,1<<P){\n      if(memo[ss][i] != 0)\n        ans = true;\n    }\n\n    puts(ans?\"YES\":\"NO\");\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\n#define N 105\n#define B 12\nusing namespace std;\n\nint HP_init, HP_Max, R, C, S;\n\nstring s[N], dir;\n\nint cost[N*3], P, p[B];\n\nint dp[M][(1<<B)], y[M], x[M], idx[N*3];\n\nint dy[4]={-1,0,1,0}, dx[4]={0,1,0,-1};\n\nbool solve(){\n\n  idx['U']=0; idx['R']=1;\n  \n  idx['D']=2; idx['L']=3;\n  \n  memset(dp,-1,sizeof(dp));\n\n  dp[0][0]=HP_init;\n  \n  y[0]=0, x[0]=0;\n  \n  int m=dir.size();\n  assert(m<=1000);  \n  for(int i=0;i<m;i++){\n\n    for(int j=0;j<(1<<P);j++){\n\n      if(dp[i][j]<0) continue;\n      \n      y[i+1]=y[i]+dy[idx[(int)dir[i]]];\n      \n      x[i+1]=x[i]+dx[idx[(int)dir[i]]];\n\n      for(int k=0;k<P;k++){\n\n\tif(j&(1<<k)) continue;\n\n\tint nhp=min(HP_Max,dp[i][j]+p[k]);\n\t\n\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],nhp);\n\t\n\tnhp=max(0,nhp-cost[(int)s[y[i+1]][x[i+1]]]);\n\t\n\tif(!nhp) continue;\n\t\n\tdp[i+1][j|(1<<k)]=max(dp[i+1][j|(1<<k)],nhp);\n\t\n      }\n      \n    }\n    \n  }\n\n  for(int i=0;i<(1<<P);i++)\n    if(dp[m][i]>0) return true;\n  \n  return false;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>HP_init>>HP_Max;\n\n    if(!HP_init&&!HP_Max) break;\n\n    cin>>R>>C;\n    \n    for(int i=0;i<R;i++) cin>>s[i];\n\n    int T;\n\n    cin>>T;\n    \n    for(int i=0;i<T;i++){\n      \n      char c;\n      int d;\n\n      cin>>c>>d;\n\n      cost[(int)c]=d;\n    }\n    \n    cin>>S;\n\n    dir=\"\";\n    \n    for(int i=0;i<S;i++){\n      \n      char c;\n      int num;\n      \n      cin>>c>>num;\n\n      for(int j=0;j<num;j++) dir+=c;\n      \n    }\n    \n    cin>>P;\n    \n    for(int i=0;i<P;i++) cin>>p[i];\n\n    if(solve()) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"C.txt\");\n#define cin ifs\n\n//typedef long long ll;\nint dy[201];\nint dx[201];\nint dp[2][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000LL;\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tint nxt=(i+1)%2;\n\t\t\tint cur=i%2;\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1)&&dp[nxt][s|(1<<k)]>0){\n\t\t\t\t\t\tres=max(res,min(dp[nxt][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t\t}\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[cur][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[nxt][s]=min(maxhp,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step%2][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\ntypedef long long ll;\nint dy[201];\nint dx[201];\nll dp[1010][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\n\nconst ll INF=100000000000000LL;\n\n//// S[©çßÄX^[gÖü©¤\n//ll dfs(int pos,int s){\n//\tif(pos==-1){\n//\t\tll sum=0;\n//\t\t// Ü¾gpµÄ¢È¢àÌð·×Äg¤\n//\t\tfor(int i=0;i<P;i++)if(!((s>>i)&1))sum+=portions[i];\n//\t\treturn min(maxhp*1LL,sum+inithp);\n//\t}\n//\telse if(dp[pos][s]!=-1)return dp[pos][s];\n//\tll res=-INF;\n//\t// Ü¾gpµÄ¢È¢portionðgp\n//\tfor(int k=0;k<P;k++)\n//\t\tif(!((s>>k)&1))if(dfs(pos,s|(1<<k))>0)res=max(res,min(dfs(pos,s|(1<<k))+portions[k],maxhp*1LL));\n//\t// ÌêÖ\n//\tres=max(res,dfs(pos-1,s)-stepDmg[pos]);\n//\tif(res<0)res=-INF;\n//\treturn dp[pos][s]=res;\n//}\n\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t//memset(dp,-1,sizeof(dp));\n\t\t//for(int i=0;i<1010;i++)for(int j=0;j<(1<<12);j++)dp[i][j]=-1;\n\t\t//if(dfs(step-1,0)>0)cout<<\"YES\"<<endl;\n\t\t//else cout<<\"NO\"<<endl;\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tll sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(1LL*maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tll res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1)&&dp[pos+1][s|(1<<k)]>0){\n\t\t\t\t\t\tres=max(res,min(dp[pos+1][s|(1<<k)]+portions[k],maxhp*1LL));\n\t\t\t\t\t}\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res*1LL,dp[pos][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[pos+1][s]=min(maxhp*1LL,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 1; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        if(beet >= 1) {\n          nextdp[j] = max(nextdp[j], beet);\n        } else {\n          for(int k : buff[P][j]) {\n            int get = min(malta, beet + add[k]);\n            if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n          }\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"C.txt\");\n#define cin ifs\n\ntypedef long long ll;\nint dy[201];\nint dx[201];\nll dp[1010][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\n\nconst ll INF=100000000000000LL;\n\n//// S[©çßÄX^[gÖü©¤\n//ll dfs(int pos,int s){\n//\tif(pos==-1){\n//\t\tll sum=0;\n//\t\t// Ü¾gpµÄ¢È¢àÌð·×Äg¤\n//\t\tfor(int i=0;i<P;i++)if(!((s>>i)&1))sum+=portions[i];\n//\t\treturn min(maxhp*1LL,sum+inithp);\n//\t}\n//\telse if(dp[pos][s]!=-1)return dp[pos][s];\n//\tll res=-INF;\n//\t// Ü¾gpµÄ¢È¢portionðgp\n//\tfor(int k=0;k<P;k++)\n//\t\tif(!((s>>k)&1))if(dfs(pos,s|(1<<k))>0)res=max(res,min(dfs(pos,s|(1<<k))+portions[k],maxhp*1LL));\n//\t// ÌêÖ\n//\tres=max(res,dfs(pos-1,s)-stepDmg[pos]);\n//\tif(res<0)res=-INF;\n//\treturn dp[pos][s]=res;\n//}\n\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t//memset(dp,-1,sizeof(dp));\n\t\t//for(int i=0;i<1010;i++)for(int j=0;j<(1<<12);j++)dp[i][j]=-1;\n\t\t//if(dfs(step-1,0)>0)cout<<\"YES\"<<endl;\n\t\t//else cout<<\"NO\"<<endl;\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tll sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(1LL*maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tll res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1)&&dp[pos+1][s|(1<<k)]>0){\n\t\t\t\t\t\tres=max(res,min(dp[pos+1][s|(1<<k)]+portions[k],maxhp*1LL));\n\t\t\t\t\t}\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res*1LL,dp[pos][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[pos+1][s]=min(maxhp*1LL,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[1<<12];\npair<int,int> points[1010];\nint dp[2][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(portion,0,sizeof(portion));\n\t\tmemset(combPortionEf,0,sizeof(combPortionEf));\n\t\tmemset(tbl,0,sizeof(tbl));\n\t\tmemset(dmg,0,sizeof(dmg));\n\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)\n\t\t\tdp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint cur=(i-1)%2;\n\t\t\t\tint nxt=(i)%2;\n\t\t\t\tdp[nxt][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!((j>>k)&1))\n\t\t\t\t\t\tdp[nxt][j]=max(dp[nxt][j],min(hpMax,dp[nxt][j|(1<<k)]+portion[k]));\n\t\t\t\t}\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[nxt][j]=max(dp[nxt][j],dp[cur][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[nxt][j]<=0)dp[nxt][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[nxt][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1010];\nint dp[1010][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]);\n\t\tbool ok=false;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[i][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//RDLU\nint main(){\n\tint hp,hp_max;\n\twhile(cin>>hp>>hp_max,hp||hp_max){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint t;\n\t\tcin>>t;\n\t\tvi damage(26);\n\t\twhile(t--){\n\t\t\tchar a;int b;\n\t\t\tcin>>a>>b;\n\t\t\tdamage[a-'A']=b;\n\t\t}\n\t\tstring s=\"\";\n\t\tcin>>t;\n\t\twhile(t--){\n\t\t\tchar a;int b;\n\t\t\tcin>>a>>b;\n\t\t\trep(i,b)s+=a;\n\t\t}\n\t\tint P;\n\t\tcin>>P;\n\t\tvi p(P);\n\t\trep(i,P)cin>>p[i];\n\t\t\n\t\tint N=1<<P;\n\t\tvvi dp(s.size()+1,vi(N,-inf));\n\t\tdp[0][0]=hp;\n\t\t//RDLU\n\t\tint x=0,y=0;\n\t\trep(i,s.size()){\n\t\t\trep(j,N)if(dp[i][j]!=-inf){\n\t\t\t\tif(s[i]=='R')t=0;\n\t\t\t\tif(s[i]=='D')t=1;\n\t\t\t\tif(s[i]=='L')t=2;\n\t\t\t\tif(s[i]=='U')t=3;\n\t\t\t\tint nx=x+dx[t],ny=y+dy[t];\n\t\t\t\tint now=dp[i][j];\n\t\t\t\trep(k,P)if((j&1<<k)==0){\n\t\t\t\t\tcmax(dp[i][j|1<<k],min(hp_max,now+p[k]));\n\t\t\t\t}\n\t\t\t\tnow-=damage[in[nx][ny]-'A'];\n\t\t\t\tif(now>0)cmax(dp[i+1][j],now);\n\t\t\t}\n\t\t\tx+=dx[t];\n\t\t\ty+=dy[t];\n\t\t}\t\t\n\t\tbool h=false;\n\t\trep(i,N)h|=dp[s.size()][i]!=-inf;\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint hpi,hpm,R,C,T,S,n[1010],P,p[19],x,y,dy[]={0,1,0,-1},dx[]={1,0,-1,0},dp[1<<12];\nchar a[110][110],d[1010],c;\nmap<char,int> M,m;\nvi v;\n\nint main(){\n\tm['R']=0,m['D']=1,m['L']=2,m['U']=3;\n\twhile(cin>>hpi>>hpm&&hpi){\n\t\tcin>>R>>C;\n\t\trep(i,R)cin>>a[i];\n\t\tcin>>T;\n\t\trep(i,T)cin>>c>>y,M[c]=y;\n\t\tcin>>S;\n\t\trep(i,S)cin>>d[i]>>n[i];\n\t\tcin>>P;\n\t\trep(i,P)cin>>p[i];\n\t\ty=x=0;\n\t\trep(i,S){\n\t\t\trep(j,n[i]){\n\t\t\t\ty+=dy[m[d[i]]],x+=dx[m[d[i]]];\n\t\t\t\tif(M[a[y][x]])v.pb(M[a[y][x]]);\n\t\t\t}\n\t\t}\n\t\tdp[0]=hpi;\n\t\trep(i,v.sz)rep(j,1<<P)if(dp[j]>0){\n\t\t\trep(k,P)if(!(j&1<<k)){\n\t\t\t\tdp[j|1<<k]=max(dp[j|1<<k],min(hpm,dp[j]+p[k]));\n\t\t\t}\n\t\t\tdp[j]-=v[i];\n\t\t}\n\t\tcout<<(dp[(1<<P)-1]>0?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint hp_init, hp_max;\nint R, C;\nchar mas[101][101];\nint T, S, P;\nmap<char, int> mp;\nvector<int> step; // damege in each step\nvector<int> po;\n\nint dp[1010][1<<12];\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst string dir = \"URDL\";\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n\n  while(cin >> hp_init >> hp_max, hp_init+hp_max) {\n    mp.clear();\n    step.clear();\n    po.clear();\n    cin >> R >> C;\n    rep(i, R) rep(j, C) cin >> mas[i][j];\n    cin >> T;\n    rep(i, T) {\n      char c; int d;\n      cin >> c >> d;\n      mp[c] = d;\n    }\n    cin >> S;\n    int y = 0, x = 0;\n    rep(i, S) {\n      char c; int d;\n      cin >> c >> d;\n      int idx = dir.find(c);\n      rep(j, d) {\n\ty += dy[idx], x += dx[idx];\n\tstep.push_back(mp[mas[y][x]]);\n      }\n    }\n    cin >> P;\n    rep(i, P) {\n      int p; cin >> p;\n      po.push_back(p);\n    }\n    fill(dp[0], dp[1010], -inf);\n    dp[0][0] = hp_init;\n    rep(i, step.size()) {\n      rep(j, 1<<P) {\n\trep(k, P) if(!((j>>k)&1)) {\n\t  chmax(dp[i+1][j|(1<<k)], min(hp_max, dp[i][j]+po[k]-step[i]));\n\t}\n      }\n    }\n    bool flag = false;\n    rep(i, 1<<P) if(dp[step.size()][i] > 0) flag = true;\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hpi,hpm;\nint r,c;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint fie[101][101];\nint t;\nint td[31];\nint s;\nint move[1001];\nint p;\nint pr[20];\nint dp[1005][1<<13];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&hpi,&hpm);\n\t\tif(hpi+hpm==0)break;\n\t\tscanf(\"%d%d\",&r,&c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfie[i][j]=str[j]-'A';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%*c\",&t);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tchar type;\n\t\t\tint dam;\n\t\t\tscanf(\"%c%d%*c\",&type,&dam);\n\t\t\ttd[type-'A']=dam;\n\t\t}\n\t\tscanf(\"%d%*c\",&s);\n\t\tint all=0;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tchar d;\n\t\t\tint dir,a;\n\t\t\tscanf(\"%c%d%*c\",&d,&a);\n\t\t\tif(d=='U')dir=3;\n\t\t\tif(d=='D')dir=1;\n\t\t\tif(d=='R')dir=0;\n\t\t\tif(d=='L')dir=2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tmove[all++]=dir;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++){\n\t\t\tscanf(\"%d\",&pr[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=hpi;\n\t\tint x=0,y=0;\n\t\tint dall=0;\n\t\tfor(int i=0;i<all;i++){\n\t\t\tx+=dx[move[i]];\n\t\t\ty+=dy[move[i]];\n\t\t\tint dam=td[fie[y][x]];\n\t\t\tdall+=dam;\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tif(dp[i][j]>0){\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tfor(int k=0;k<p;k++){\n\t\t\t\t\t\tif(j>>k & 1)continue;\n\t\t\t\t\t\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],min(hpm,dp[i][j]+pr[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tdp[i+1][j]-=dam;\n\t\t\t}\n\t\t}\n\t\tbool flag=false;\n\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\tif(dp[all][j]>0)flag=true;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,H,r,c,t,s;\nint seq[1000],n,p,pot[12];\nchar fl[100][101],dmg[256];\nint dp[1001][1<<12];\n\nbool solve()\n{\n\trep(i,n+1)rep(j,1<<p)dp[i][j]=0;\n\tdp[0][(1<<p)-1]=h;\n\trep(i,n)rep(j,1<<p)if(dp[i][j]>0)\n\t{\n\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]-seq[i]);\n\t\trep(k,p)if(j&1<<k)\n\t\tdp[i+1][j^1<<k]=max(dp[i+1][j^1<<k],min(H,dp[i][j]-seq[i]+pot[k]));\n\t}\n\trep(i,1<<p)if(dp[n][i]>0)return 1;\n\treturn 0;\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&H),h)\n\t{\n\t\tscanf(\"%d%d\",&r,&c);\n\t\trep(i,r)scanf(\"%s\",fl+i);\n\t\t\n\t\tchar a; int b;\n\t\tscanf(\"%d\",&t);\n\t\trep(i,t)scanf(\" %c%d\",&a,&b),dmg[a]=b;\n\t\t\n\t\tint y=0,x=0; n=0;\n\t\tscanf(\"%d\",&s);\n\t\trep(i,s)\n\t\t{\n\t\t\tscanf(\" %c%d\",&a,&b);\n\t\t\trep(j,b)\n\t\t\t{\n\t\t\t\tif(a=='U')y--; if(a=='R')x++;\n\t\t\t\tif(a=='D')y++; if(a=='L')x--;\n\t\t\t\tseq[n++]=dmg[fl[y][x]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&p);\n\t\trep(i,p)scanf(\"%d\",pot+i);\n\t\t\n\t\tputs(solve()?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint ihp, mhp;\nint p;\nvi portion, dmg; \nvector<vi> fld;\nint dp[1111][2222];\n\nbool solve()\n{\n\tdp[0][0] = ihp;\n\tREP(i, dmg.size())\n\t{\n\t\tREP(j, 1 << p)\n\t\t{\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tchmax(dp[i + 1][j], dp[i][j] - dmg[i]);\n\t\t\tREP(k, p)\n\t\t\t{\n\t\t\t\tif (!((j >> k) & 1))\n\t\t\t\t{\n\t\t\t\t\tchmax(dp[i][j | (1 << k)], min(mhp, dp[i][j] + portion[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 1 << p)\n\t{\n\t\tif (dp[dmg.size()][i] > 0) return true;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile (cin >> ihp >> mhp, ihp)\n\t{\n\t\tportion.clear();\n\t\tdmg.clear();\n\t\tfld.clear();\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tfld.resize(h, vi(w));\n\t\tvs fldc(h);\n\t\tREP(i, h) cin >> fldc[i];\n\t\tint t; cin >> t;\n\t\tmap<char, int> mp;\n\t\tREP(i, t)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tmp[c] = d;\n\t\t}\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tfld[i][j] = mp[fldc[i][j]];\n\t\t}\n\n\t\tint tx = 0, ty = 0;\n\t\tint s; cin >> s;\n\t\tREP(i, s)\n\t\t{\n\t\t\tchar c; int d;\n\t\t\tcin >> c >> d;\n\t\t\tpii tmp;\n\t\t\tif (c == 'U') tmp = pii(-1, 0);\n\t\t\tif (c == 'D') tmp = pii(1, 0);\n\t\t\tif (c == 'L') tmp = pii(0, -1);\n\t\t\tif (c == 'R') tmp = pii(0, 1);\n\t\t\tREP(j, d)\n\t\t\t{\n\t\t\t\ttx += tmp.first, ty += tmp.second;\n\t\t\t\tdmg.push_back(fld[tx][ty]);\n\t\t\t}\n\t\t}\n\t\tcin >> p;\n\t\tREP(i, p)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\tportion.push_back(a);\n\t\t}\n\n\t\tvector<vi> dp(1111, vi(1 << 13, INF));\n\t\tputs(solve() ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nint main(){\n\tint init_hp,max_hp;\n\twhile(cin>>init_hp>>max_hp,init_hp|max_hp){\n\t\tint r,c;\n\t\tcin>>r>>c;\n\t\tvs a(r,string(c,' '));\n\t\tREP(i,r){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint t;\n\t\tcin>>t;\n\t\tvi trap_damages('Z'+1);\n\t\tREP(i,t){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tcin>>trap_damages[c];\n\t\t}\n\t\tint s;\n\t\tcin>>s;\n\t\tint total_steps=0;\n\t\tint cnt=0;\n\t\tvector<pii> steps(1000);\n\t\tint y=0,x=0;\n\t\tREP(i,s){\n\t\t\tchar direction;\n\t\t\tint step;\n\t\t\tcin>>direction>>step;\n\t\t\tint dy=0,dx=0;\n\t\t\tswitch(direction){\n\t\t\tcase 'U':\n\t\t\t\tdy=-1;break;\n\t\t\tcase 'D':\n\t\t\t\tdy=1;break;\n\t\t\tcase 'L':\n\t\t\t\tdx=-1;break;\n\t\t\tcase 'R':\n\t\t\t\tdx=1;break;\n\t\t\t}\n\t\t\tREP(j,step){\n\t\t\t\ty+=dy;\n\t\t\t\tx+=dx;\n\t\t\t\tsteps[cnt].first=y;\n\t\t\t\tsteps[cnt].second=x;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttotal_steps+=step;\n\t\t}\n\t\tint p;\n\t\tcin>>p;\n\t\tvi potions(p);\n\t\tREP(i,p){\n\t\t\tcin>>potions[i];\n\t\t}\n\n\t\tvi cured_hp_for_potion_mask(1<<p);\n\t\tREP(i,1<<p){\n\t\t\tREP(j,p){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tcured_hp_for_potion_mask[i]+=potions[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi hp(total_steps+1,vi(1<<p));\n\t\thp[0][0]=init_hp;\n\t\tREP(step,total_steps){\n\t\t\tchar trap=a[steps[step].first][steps[step].second];\n\t\t\tint damage=trap_damages[trap];\n\t\t\tREP(potion_mask,1<<p){\n\t\t\t\tif(hp[step][potion_mask]<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(hp[step][potion_mask]<=damage){\n\t\t\t\t\tREP(used_potion_mask,1<<p){\n\t\t\t\t\t\tif((used_potion_mask&potion_mask)==0){\n\t\t\t\t\t\t\tint new_hp=min(hp[step][potion_mask]+cured_hp_for_potion_mask[used_potion_mask],max_hp)-damage;\n\t\t\t\t\t\t\thp[step+1][potion_mask|used_potion_mask]=max(hp[step+1][potion_mask|used_potion_mask],new_hp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\thp[step+1][potion_mask]=max(hp[step+1][potion_mask],hp[step][potion_mask]-damage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(potion_mask,1<<p){\n\t\t\tans=max(ans,hp[total_steps][potion_mask]);\n\t\t}\n\t\tcout<<(ans>0?\"YES\":\"NO\")<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    for(int shp, mhp; cin >> shp >> mhp, shp;){\n        int h, w; cin >> h >> w;\n        vector<string> field(h);\n        for(auto & e : field) cin >> e;\n\n        map<char, int> damageDic;\n        int tn; cin >> tn;\n        rep(loop, tn){\n            char c; int d; cin >> c >> d;\n            damageDic[c] = d;\n        }\n\n        int opn; cin >> opn;\n        vi dirs(opn); vi dists(opn);\n        rep(i, opn){\n            char c; cin >> c >> dists[i];\n            switch(c){\n                case 'R': { dirs[i] = 0; break; }\n                case 'D': { dirs[i] = 1; break; }\n                case 'L': { dirs[i] = 2; break; }\n                case 'U': { dirs[i] = 3; break; }\n            }\n        }\n\n        int pn; cin >> pn;\n        vi potions(pn);\n        for(auto & e : potions) cin >> e;\n\n        vi damages;\n        int cy = 0, cx = 0;\n        rep(i, opn){\n            int di = dirs[i], dist = dists[i];\n\n            rep(d, 1, dist + 1){\n                cy += dy[di], cx += dx[di];\n                damages.push_back(damageDic[field[cy][cx]]);\n            }\n        }\n\n        int n = damages.size();\n        vi emp(1 << pn, -1);\n        auto cur = emp;\n        cur[0] = shp;\n\n        rep(i, n){\n            auto next = emp;\n\n            rep(ps, 1 << pn){\n                if(cur[ps] == -1) continue;\n                int hp = cur[ps];\n\n                rep(pi, pn + 1){\n                    int nhp = hp, nps = ps;\n                    if(pi != pn){\n                        if((ps >> pi) & 1) continue;\n                        nhp = min(mhp, hp + potions[pi]);\n                        nps = (ps | (1 << pi));\n                    }\n                    nhp -= damages[i];\n\n                    if(nhp > 0){\n                        chmax(next[nps], nhp);\n                    }\n                }\n            }\n\n            cur = next;\n        }\n\n        \n        string res = \"NO\";\n        rep(ps, 1 << pn){\n            if(cur[ps] > 0){\n                res = \"YES\";\n            }\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1010];\nint dp[1010][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1){\n\t\t\tfor(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t}\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[i][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tint hp; int mahp;\n\twhile (cin >> hp >> mahp, hp) {\n\t\tint r, c; cin >> r >> c;\n\t\tchar fie[100][100];\n\t\trep(i, r) {\n\t\t\tstring s; cin >> s;\n\t\t\trep(j, c) {\n\t\t\t\tfie[i][j] = s[j];\n\t\t\t}\n\t\t}\n\t\tint t; cin >> t;\n\t\tint dam[26] = {};\n\t\trep(i, t) {\n\t\t\tchar x; int cost; cin >> x >> cost; dam[x - 'A'] = cost;\n\t\t}\n\t\tint s; cin >> s;\n\t\tpair<char, int> move[1000];\n\t\tint sum = 0;\n\t\trep(i, s) {\n\t\t\tchar x; int count; cin >> x >> count; move[i] = { x,count }; sum += count;\n\t\t}\n\t\tint p; cin >> p;\n\t\tint por[12];\n\t\trep(i, p) {\n\t\t\tcin >> por[i];\n\t\t}\n\t\tint dp[1001][1<<12];\n\t\trep(i, 1001) {\n\t\t\trep(j, (1 << 12)) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tdp[0][(1 << p)-1] = hp;\n\t\tP now = { 0,0 };\n\t\tint godam[1000]; int cnt = 0;\n\t\trep(i, s) {\n\t\t\trep(j, move[i].second) {\n\t\t\t\tchar x = move[i].first;\n\t\t\t\tif (x == 'U') {\n\t\t\t\t\tnow.first--;\n\t\t\t\t}\n\t\t\t\telse if (x == 'D') {\n\t\t\t\t\tnow.first++;\n\t\t\t\t}\n\t\t\t\telse if (x == 'L') {\n\t\t\t\t\tnow.second--;\n\t\t\t\t}\n\t\t\t\telse if (x == 'R') {\n\t\t\t\t\tnow.second++;\n\t\t\t\t}\n\t\t\t\tgodam[cnt] = dam[fie[now.first][now.second] - 'A'];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\trep(i, sum) {\n\t\t\tper(j, (1 << p)) {\n\t\t\t\tif (dp[i][j] <= 0)continue;\n\t\t\t\tdp[i + 1][j] = dp[i][j] - godam[i];\n\t\t\t\trep(k, p) {\n\t\t\t\t\tif ((1 << k)&j) {\n\t\t\t\t\t\tdp[i][j ^ (1 << k)] = min(dp[i][j] + por[k], mahp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\trep(j, (1 << p)) {\n\t\t\tif (dp[sum][j] > 0) {\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\nifstream ifs(\"C.txt\");\n#define cin ifs\n\n//typedef long long ll;\nint dy[201];\nint dx[201];\nint dp[2][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000LL;\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tint nxt=(i+1)%2;\n\t\t\tint cur=i%2;\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1))\n\t\t\t\t\t\tres=max(res,min(dp[nxt][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[cur][s]-stepDmg[pos]);\n\t\t\t\tif(res<=0)res=-INF;\n\t\t\t\tdp[nxt][s]=min(maxhp,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step%2][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 1; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        for(int k : buff[P][j]) {\n          int get = min(malta, beet + add[k]);\n          if(get <= 0) continue;\n          nextdp[j | k] = max(nextdp[j | k], min(malta, beet + add[k]));\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, t;\nvector<int> m, l, k;\n\nbool solve(int ope)\n{\n    priority_queue<int, vector<int>, greater<int> > pq;\n    for(int i=0; i<ope; ++i)\n        pq.push(0);\n\n    vector<bool> check(n, false);\n    for(int i=0; i<n; ++i){\n        int currTime = pq.top();\n        pq.pop();\n\n        int minTime = INT_MAX;\n        int select;\n        for(int j=0; j<n; ++j){\n            if(check[j])\n                continue;\n            int time = currTime / (l[j] + k[j]) * (l[j] + k[j]);\n            if(currTime > time + l[j])\n                time += l[j] + k[j];\n            else\n                time = currTime;\n            if(time < minTime){\n                select = j;\n                minTime = time;\n            }\n        }\n\n        check[select] = true;\n        minTime += m[select];\n        if(minTime > t)\n            return false;\n        pq.push(minTime);\n    }\n\n    return true;\n}\n\nint main()\n{\n    for(;;){\n        cin >> n >> t;\n        if(n == 0)\n            return 0;\n\n        m.resize(n);\n        l.resize(n);\n        k.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> m[i] >> l[i] >> k[i];\n\n        int ret = 1;\n        while(!solve(ret))\n            ++ ret;\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tconstexpr int dx[] = {-1, 0, 1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tint dir[128];\n\tdir['L'] = 0;\n\tdir['D'] = 1;\n\tdir['R'] = 2;\n\tdir['U'] = 3;\n\t\n\tfor(int HP_init, HP_max; cin >> HP_init >> HP_max && HP_init;) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tint t;\n\t\tcin >> t;\n\n\t\tint damage[128] = {};\n\t\tfor(int i = 0; i < t; ++i) {\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdamage[c] = d;\n\t\t}\n\n\t\tint s;\n\t\tcin >> s;\n\n\t\tvector<int> moves;\n\t\tvector<pair<int, int>> pos{{0, 0}};\n\n\t\tmoves.reserve(1000);\n\t\tpos.reserve(1001);\n\n\t\tfor(int i = 0; i < s; ++i) {\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tcin >> c >> n;\n\n\t\t\tconst int d = dir[c];\n\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tconst int x = pos.back().first + dx[d];\n\t\t\t\tconst int y = pos.back().second + dy[d];\n\t\t\t\tmoves.emplace_back(d);\n\t\t\t\tpos.emplace_back(x, y);\n\t\t\t}\n\t\t}\n\n\t\tint p;\n\t\tcin >> p;\n\n\t\tvector<int> potions(p);\n\t\tfor(auto &e : potions) cin >> e;\n\n\t\tconst int number_of_steps = moves.size();\n\t\tvector<vector<int>> dp(number_of_steps + 1, vector<int>(1 << p, 0));\n\t\tdp[0][0] = HP_init;\n\n\t\tfor(int i = 0; i < number_of_steps; ++i) {\n\t\t\tconst int d = moves[i];\n\t\t\tconst int x = pos[i].first;\n\t\t\tconst int y = pos[i].second;\n\n\t\t\tconst int dec = damage[field[y + dy[d]][x + dx[d]]];\n\n\t\t\tfor(int used = 0; used < (1 << p); ++used) {\n\t\t\t\tif(dp[i][used] == 0) continue;\n\n\t\t\t\tchmin(dp[i][used], HP_max);\n\t\t\t\tfor(int j = 0; j < p; ++j) {\n\t\t\t\t\tif(!(used & (1 << j))) {\n\t\t\t\t\t\tchmax(dp[i][used | (1 << j)], dp[i][used] + potions[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchmax(dp[i + 1][used], dp[i][used] - dec);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dp[number_of_steps][(1 << p) - 1] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n\nint dp[MAX][1<<MAX_P];\n\nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n        \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n        \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n\n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n\n        int rec[1<<MAX_P] = {};\n        for (int i = 0; i < (1<<P); i++) {\n            int r = 0;\n            for (int j = 0; j < P; j++) {\n                if (i >> j & 1) {\n                    r += p[j];\n                }\n            }\n            rec[i] = r;\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n        \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] <= 0) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < (1<<P); k++) {\n                    if ((j & k) > 0) continue;                    \n                    dp[i+1][j|k] = max(dp[i+1][j|k], min(dp[i][j] - vec[i] + rec[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int i){\n  Max(dp[i+1][bit],hp);\n  if(idx==P||hp>0) return;\n  update(idx+1,bit,hp,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP,hp+p[idx]),i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  mp[0][0] = '@';\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    int cost = dmg[mp[y][x]];\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit]-cost,i);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  while(1){\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n\n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 1; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        for(int k : buff[P][j]) {\n          int get = min(malta, beet + add[k]);\n          if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> PII;\n#define MP make_pair;\n\nint hp, hp_max;\nint R, C;\nchar maze[101][101];\nint T;\nint dat[101][101];\nint S;\nPII path[1001];\nint P;\nint portion[16];\nint dp[1<<12][1010];\n\nint main(){\n  while(cin>>hp>>hp_max, hp){\n\tcin >> R >> C;\n\tfor(int y=0;y<R;++y)\n\t  for(int x=0;x<C;++x)\n\t\tcin >> maze[y][x];\n\tcin >> T;\n\tfor(int t=0;t<T;++t){\n\t  char c; int d; cin >> c >> d;\n\t  for(int y=0;y<R;++y)\n\t\tfor(int x=0;x<C;++x)\n\t\t  if(maze[y][x] == c)\n\t\t\tdat[y][x] = d;\n\t}\n\tcin >> S;\n\tint N = 1;\n\tpath[0].first = 0;\n\tpath[0].second = 0;\n\tfor(int i=0;i<S;++i){\n\t  char c; int x;\n\t  cin >> c >> x;\n\t  switch(c){\n\t  case 'U':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].first--;\n\t\t}\n\t\tbreak;\n\t  case 'D':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].first++;\n\t\t}\n\t\tbreak;\n\t  case 'L':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].second--;\n\t\t}\n\t\tbreak;\n\t  case 'R':\n\t\tfor(int j=0;j<x;++j){\n\t\t  path[N] = path[N-1];\n\t\t  path[N++].second++;\n\t\t}\n\t\tbreak;\n\t  }\n\t}\n\tcin >> P;\n\tfor(int i=0;i<P;++i) cin >> portion[i];\n\n\tfill((int*)dp, (int*)dp+(1<<12)*1010, 0);\n\tdp[0][0] = hp;\n\tfor(int i=0;i<N;++i){\n\t  int y = path[i].first, x = path[i].second;\n\t  for(int b=0;b<1<<P;++b){\n\t\tif(!dp[b][i]) continue;\n\t\tif(dp[b][i] > dat[y][x])\n\t\t  dp[b][i+1] = max(dp[b][i+1], dp[b][i] - dat[y][x]);\n\t\telse\n\t\t  for(int j=0;j<P;++j)\n\t\t\tif((b>>j&1) == 0)\n\t\t\t  dp[b|(1<<j)][i] = max(dp[b|(1<<j)][i], min(hp_max, dp[b][i] + portion[j]));\n\t  }\n\t}\n\n\tbool ans = false;\n\tfor(int b=0;b<1<<P;++b)\n\t  if(dp[b][N]) ans = true;\n\tcout << (ans? \"YES\": \"NO\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,hp,HP;\nchar t[1005][1005];\nint T,S,P;\nmap<char,int> mp;\nvector<int> u;\nint dp[20005][(1<<12)];\nint v[12];\n\nint main(){\n\n  while(1){\n    u.clear();\n    cin>>hp>>HP;\n    if(hp==0&&HP==0)break;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin>>t[i][j];\n    cin>>T;\n    for(int i=0;i<T;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      mp[ch]=num;\n    }\n    int y=0,x=0;\n    cin>>S;\n    for(int i=0;i<S;i++){\n      char ch;\n      int num;\n      cin>>ch>>num;\n      while(num--){\n        if(ch=='U')y--;\n        if(ch=='R')x++;\n        if(ch=='D')y++;\n        if(ch=='L')x--;\n        u.push_back(mp[ t[y][x] ]);\n      }\n    }\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>v[i];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=hp;\n    int N=u.size();\n    for(int i=0;i<N;i++){\n      for(int S=0;S<(1<<P);S++){\n        if(dp[i][S]==0)continue;        \n        for(int k=0;k<P;k++){\n          if(S>>k&1)continue;\n          int nS=S|(1<<k);\n          dp[i+1][nS]=max(dp[i+1][nS],min(HP,dp[i][S]+v[k]));\n        }\n        dp[i+1][S]=max(dp[i+1][S],dp[i][S]-u[i]);\n      }\n    }\n    string ans=\"NO\";\n    for(int i=0;i<(1<<P);i++)\n      if(dp[N][i]>0)ans=\"YES\";\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  int init_hp,max_hp;\n  while(cin>>init_hp>>max_hp,init_hp|max_hp){\n    int r,c;\n    cin>>r>>c;\n    vs a(r);\n    REP(i,r){\n      cin>>a[i];\n    }\n\n    int t;\n    cin>>t;\n    map<char,int> d;\n    REP(i,t){\n      char c;\n      int dd;\n      cin>>c>>dd;\n      d[c]=dd;\n    }\n    int s;\n    cin>>s;\n    int cy=0,cx=0;\n    vi damages(1);\n    REP(i,s){\n      char dd;\n      int n;\n      cin>>dd>>n;\n      int dy=0,dx=0;\n      switch(dd){\n        case 'U':\n          dy=-1;break;\n        case 'D':\n          dy=1;break;\n        case 'L':\n          dx=-1;break;\n        case 'R':\n          dx=1;break;\n      }\n      REP(j,n){\n        cy+=dy;\n        cx+=dx;\n        damages.push_back(d[a[cy][cx]]);\n      }\n    }\n\n    int P;\n    cin>>P;\n    vi p(P);\n    REP(i,P){\n      cin>>p[i];\n    }\n\n    vi cured(1<<P);\n    REP(i,1<<P){\n      REP(j,P){\n        if((i>>j)&1){\n          cured[i]+=p[j];\n        }\n      }\n    }\n\n    int n=damages.size();\n    vvi dp(n+1,vi(1<<P));\n    dp[0][0]=init_hp;\n    REP(i,n){\n      REP(j,1<<P){\n        if(dp[i][j]>0){\n          if(dp[i][j]<=damages[i]){\n            REP(k,1<<P){\n              bool ok=true;\n              if(j&k){\n                ok=false;\n              }\n              if(ok){\n                dp[i+1][j|k]=max(dp[i+1][j|k],min(max_hp,dp[i][j]+cured[k]-damages[i]));\n              }\n            }\n          }else{\n            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-damages[i]);\n          }\n        }\n      }\n    }\n    /*\n    REP(i,n+1){\n      REP(j,1<<P){\n        cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n    */\n    bool ok=false;\n    REP(j,1<<P){\n      if(dp[n][j]>0){\n        ok=true;\n      }\n    }\n    cout<<(ok?\"YES\":\"NO\")<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nbool solve() {\n  int h, hma; cin >> h >> hma;\n  if(h == 0) return false;\n  int r, c; cin >> r >> c;\n  vector<string> g(r);\n  for(int i=0;i<(r);++i) {\n    cin >> g[i];\n  }\n  int t; cin >> t;\n  vi mp(26);\n  for(int i=0;i<(t);++i) {\n    char c; cin >> c;\n    int k; cin >> k;\n    mp[c-'A'] = k;\n  }\n  int s; cin >> s;\n  vector<int> dr(s), dc(s), num(s);\n  for(int i=0;i<(s);++i) {\n    char c; cin >> c >> num[i];\n    if(c == 'L') {\n      dc[i] = -1;\n    } else if(c == 'R') {\n      dc[i] = 1;\n    } else if(c == 'U') {\n      dr[i] = -1;\n    } else if(c == 'D') {\n      dr[i] = 1;\n    }\n  }\n  int p; cin >> p;\n  vi tmpv(p);\n  for(int i=0;i<(p);++i) {\n    cin >> tmpv[i];\n  }\n  set<P> val;\n  for(int i=(1);i<(1<<p);++i) {\n    int now = 0;\n    for(int j=0;j<(p);++j) {\n      if((i>>j)&1) now += tmpv[j];\n    }\n    val.insert({now, i});\n  }\n  P pos = {0, 0};\n  bool ok = true;\n  for(int i=0;i<(s);++i) {\n    if(!ok) break;\n    for(int j=0;j<(num[i]);++j) {\n      int nr = pos.first + dr[i], nc = pos.second + dc[i];\n      int nowval = mp[g[nr][nc]-'A'];\n      h -= nowval;\n      if(h <= 0) {\n        auto it = val.lower_bound(make_pair(-h+1, 0));\n        if(it == val.end()) {\n          ok = false;\n          break;\n        }\n        if(min(h + nowval + it->first, hma) - nowval <= 0) {\n          ok = false;\n          break;\n        }\n        h = min(h + nowval + it->first, hma) - nowval;\n        int bit = it->second;\n        vector<P> er;\n        for(auto &e: val) {\n          if(e.second & bit) {\n            er.emplace_back(e);\n          }\n        }\n        for(auto &e: er) {\n          val.erase(e);\n        }\n      }\n      pos = {nr, nc};\n    }\n  }\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    bool v[100][100] = {};\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      bool flag = v[yy][xx]++;\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        int beet;\n        if(flag) beet = dp[j];\n        else beet = dp[j] - damage[A[yy][xx]];\n        if(beet >= 1) {\n          nextdp[j] = max(nextdp[j], beet);\n        } else {\n          for(int k : buff[P][j]) {\n            int get = min(malta, beet + add[k]);\n            if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n          }\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[1<<12];\npair<int,int> points[1010];\nint dp[1010][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if(!((i>>j)&1))sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]+hpInit);\n\t\tbool ok=false;\n\t\tif(idx==1)for(int j=0;j<(1<<P);j++)if(dp[0][j]>0)ok=true;\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)if(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[i][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<map>\nusing namespace std;\nconst int M=110;\nconst int inf = 0x3fffffff;\nchar a[M][M];\nint d[64];\nint dx[]= {-1,1,0,0};\nint dy[]= {0,0,-1,1};\nint yao[64];\nint kou[1100];\nstruct G\n{\n    char s[4];\n    int step;\n} g[1100];\nbool flag;\nint lk,T,snum,hpmax;\nint dp[1105][1<<12];\nint main()\n{\n    int hp,n,m,dis,S,i,j;\n    char ts[4];\n    int x,y;\n    while(~scanf(\"%d%d\",&hp,&hpmax),hp+hpmax)\n    {\n        x=y=0;\n        scanf(\"%d%d\",&n,&m);\n        for(i=0; i<n; i++)\n        {\n            scanf(\"%s\",a[i]);\n        }\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            scanf(\"%s%d\",ts,&dis);\n            d[ts[0]-'A']=dis;\n        }\n        scanf(\"%d\",&S);\n        for(i=0; i<S; i++)\n        {\n            scanf(\"%s%d\",g[i].s,&g[i].step);\n        }\n        int sum1=0,sum2=0,mark=0;\n        scanf(\"%d\",&T);\n\n        snum = T;\n        for(i=0; i<T; i++)\n        {\n            scanf(\"%d\",&yao[i]);\n            sum1 += yao[i];\n        }\n        lk=0;\n\n        for(i=0; i<S; i++)\n        {\n            int id;\n            if(g[i].s[0]=='U')\n            {\n                id=0;\n            }\n            else if(g[i].s[0]=='D')\n            {\n                id=1;\n            }\n            else if(g[i].s[0]=='L')\n            {\n                id=2;\n            }\n            else if(g[i].s[0]=='R')\n            {\n                id=3;\n            }\n            for(int j=0; j<g[i].step; j++)\n            {\n                x+=dx[id];\n                y+=dy[id];\n                dis=d[a[x][y]-'A'];\n                kou[lk++]=dis;\n                if(dis>hpmax)mark=1;\n                sum2 += dis;\n            }\n        }\n        if(mark||(sum1+hp<=sum2))\n        {\n            puts(\"NO\");\n            continue;\n        }\n        int Max = 1<<snum;\n        for(i=0;i<Max;i++)\n            dp[0][i]=hp;\n        for(i=0;i<lk;i++)\n        {\n            for(j=Max-1;j>=0;j--)\n            {\n                for(int k=0;k<snum;k++)\n                {\n                    if((1<<k)&(j))continue;\n                   // if(i==0)cout<<\"fdsf\"<<j<<endl;\n                    //if(dp[i-1][j]==-inf)continue;\n                    dp[i][(j|(1<<k))]=max(dp[i-1][j]+yao[k],dp[i][j|(1<<k)]);\n                    dp[i][(j|(1<<k))]=min(dp[i][j|(1<<k)],hpmax);\n                }\n            }\n            for(j=0;j<Max;j++)\n            {\n               // if(i==0)cout<<dp[i][j]<<endl;\n                dp[i][j]-=kou[i];\n                if(dp[i][j]<=0)dp[i][j]=-inf;\n            }\n        }\n        int  ans = -inf;\n        for(i=0;i<Max;i++)\n            ans = max(ans,dp[lk-1][i]);\n        //cout<<ans<<\"d\"<<endl;\n        if(ans>0)puts(\"YES\");\n        else puts(\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[200][200];\nint dam[26];\nchar in[2];\nint row[1100];\nint col[1100];\nint q[14];\nint dp[1100][1<<12];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint n,m;scanf(\"%d%d\",&n,&m);\n\t\tfor(int i=0;i<n;i++)scanf(\"%s\",str[i]);\n\t\tint t;scanf(\"%d\",&t);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tint tmp;\n\t\t\tscanf(\"%s%d\",in,&tmp);\n\t\t\tdam[in[0]-'A']=tmp;\n\t\t}\n\t\tint s;scanf(\"%d\",&s);\n\t\tint sz=0;\n\t\trow[0]=col[0]=0;\n\t\tsz++;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tint tmp;\n\t\t\tscanf(\"%s%d\",in,&tmp);\n\t\t\tfor(int j=0;j<tmp;j++){\n\t\t\t\trow[sz]=row[sz-1];col[sz]=col[sz-1];\n\t\t\t\tif(in[0]=='U')row[sz]--;\n\t\t\t\tif(in[0]=='D')row[sz]++;\n\t\t\t\tif(in[0]=='L')col[sz]--;\n\t\t\t\tif(in[0]=='R')col[sz]++;\n\t\t\t\tsz++;\n\t\t\t}\n\t\t}\n\t\tint p;scanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++)scanf(\"%d\",q+i);\n\t\tfor(int i=0;i<=sz;i++)for(int j=0;j<(1<<p);j++)dp[i][j]=0;\n\t\tdp[1][0]=a;\n\t\tfor(int i=1;i<sz;i++){\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tif(dp[i][j]<=0)continue;\n\t\t\t\tint nc=dam[str[row[i]][col[i]]-'A'];\n\t\t\t\tif(dp[i][j]-nc>0)dp[i+1][j]=max(dp[i+1][j],dp[i][j]-nc);\n\t\t\t\tfor(int k=0;k<p;k++){\n\t\t\t\t\tif(j&(1<<k))continue;\n\t\t\t\t\tif(min(dp[i][j]+q[k],b)-nc>0)dp[i+1][j+(1<<k)]=max(dp[i+1][j+(1<<k)],min(dp[i][j]+q[k],b)-nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int i=0;i<(1<<p);i++)if(dp[sz][i]>0)ok=true;\n\t\tif(ok)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint dp[1<<12];\nint maxhp,hp;\n\n\nint main() {\n    ifstream cin(\"C.txt\");\n    while(cin>>hp>>maxhp, hp|maxhp) {\n        int r,c,t,s,p,d,n;\n        string str;\n        cin>>r>>c;\n        vector<string> mp(r);\n        for(int i=0; i<r; ++i) cin>>mp[i];\n\n        map<string,int> trap;\n        cin>>t;\n        for(int i=0; i<t; ++i) {\n            cin>>str>>d;\n            trap[str] = d;\n        }\n\n        cin>>s;\n        string move;\n        for(int i=0; i<s; ++i) {\n            cin>>str>>n;\n            move += string(n, str[0]);\n        }\n\n        cin>>p;\n        vector<int> pot(p);\n        for(int i=0; i<p; ++i) cin>>pot[i];\n\n        int x = 0,y = 0;\n        vector<int> dam;\n        dam.push_back(0);\n        for(int i=0; i<move.length(); ++i) {\n            if(move[i] == 'U') y--;\n            else if(move[i] == 'D') y++;\n            else if(move[i] == 'R') x++;\n            else if(move[i] == 'L') x--;\n            dam.push_back(trap[string(1,mp[y][x])]);\n        }\n\n        memset(dp, -1, sizeof(dp));\n        dp[0] = hp;\n\n        for(int i=0; i<dam.size(); ++i) {\n            for(int j=0; j<(1<<p); ++j)\n                if(dp[j] > 0)\n                    for(int k=0; k<p; ++k)\n                        if((j & (1<<k)) == 0) {\n                            dp[j|(1<<k)] = max(dp[j|(1<<k)],\n                                               min(maxhp, dp[j] + pot[k]));\n                        }\n            for(int j=0; j<(1<<p); ++j) dp[j] -= dam[i];\n        }\n                 \n\n        bool ok = false;\n        for(int j=0; j<(1<<p); ++j) if(dp[j] > 0) ok = true;\n        if(ok) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <assert.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint hp_init, hp_max;\nint R, C;\nchar mas[101][101];\nint T, S, P;\nmap<char, int> mp;\nvector<int> step; // damege in each step\nvector<int> po;\n\nint dp[1010][1<<12];\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst string dir = \"DRUL\";\n\nbool in(int y, int x) {\n  return 0<=y&&y<R&&0<=x&&x<C;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n\n  while(cin >> hp_init >> hp_max, hp_init+hp_max) {\n    mp.clear();\n    step.clear();\n    po.clear();\n    cin >> R >> C;\n    rep(i, R) rep(j, C) cin >> mas[i][j];\n    cin >> T;\n    rep(i, T) {\n      char c; int d;\n      cin >> c >> d;\n      mp[c] = d;\n    }\n    cin >> S;\n    int y = 0, x = 0;\n    rep(i, S) {\n      char c; int d;\n      cin >> c >> d;\n      int idx = dir.find(c);\n      rep(j, d) {\n\ty += dy[idx], x += dx[idx];\n\tassert(in(y, x));\n\tstep.push_back(mp[mas[y][x]]);\n      }\n    }\n    cin >> P;\n    rep(i, P) {\n      int p; cin >> p;\n      po.push_back(p);\n    }\n    fill(dp[0], dp[1010], -inf);\n    dp[0][0] = hp_init;\n    rep(i, step.size()) {\n      rep(j, 1<<P) {\n\tif(dp[i][j] == -inf) continue;\n\tchmax(dp[i+1][j], dp[i][j]-step[i]);\n\trep(k, P) if(!((j>>k)&1)) {\n\t  chmax(dp[i][j|(1<<k)], min(hp_max, dp[i][j]+po[k]));\n\t  chmax(dp[i+1][j|(1<<k)], min(hp_max, dp[i][j]+po[k])-step[i]);\n\t}\n      }\n    }\n    bool flag = false;\n    rep(i, 1<<P) if(dp[step.size()][i] > 0) flag = true;\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int N = 1<<12;\nint dp[2][N];\nint n,m;\nint hpi,hpm;\nchar mz[110][110];\nint T,S,P;\nint val[30];\nchar op[1100][2];\nint num[1100],p[15],sum;\nconst int dx[4]={0,0,1,-1};\nconst int dy[4]={1,-1,0,0};\nint idx(char x){\n    if (x == 'U') return 3;\n    if (x == 'D') return 2;\n    if (x == 'L') return 1;\n    if (x == 'R') return 0;\n}\nint hp[N];\nvoid findhp(){\n    memset(hp,0,sizeof(hp));\n    for (int x = 0; x < (1<<P); x++)\n    for (int j = 0; j < P; j++) {\n        if (x & (1<<j)) hp[x] += p[j];\n    }\n}\nint haved;\nint findminhp(int x,int v) {\n    int minhp = -1, f = 0;\n    for (int i = 0; i < (1<<P); i++) {\n        if (x + hp[i] <= v) continue;\n        if (haved & i) continue;\n        if (minhp == -1 || minhp < hp[i]) {\n            minhp = hp[i];\n            f = i;\n        }\n    }\n    haved |= f;\n    return minhp;\n}\nint solve(){\n    findhp();\n    haved = 0;\n    int nowhp = hpi;\n    int x = 0, y = 0;\n    for (int i = 0; i < S; i++) {\n        int d = idx(op[i][0]);\n        for (int j = 0; j < num[i]; j++) {\n            x += dx[d]; y += dy[d];\n            int v = val[ mz[x][y] - 'A' ];\n            if (nowhp - v <= 0) {\n                int thp = findminhp(nowhp,v);\n                if (nowhp + thp - v <= 0) return 0;\n                nowhp += thp;\n            }\n            nowhp -= v;\n        }\n    }\n    return 1;\n\n\n}\nint main(){\n    while (~scanf(\"%d%d\",&hpi,&hpm),hpi+hpm) {\n        scanf(\"%d%d\",&n,&m);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\",mz[i]);\n        }\n        scanf(\"%d\",&T);\n        for (int i = 0; i < T; i++) {\n            char t[2];\n            scanf(\"%s\",t);\n            scanf(\"%d\",&val[t[0]-'A']);\n        }\n        scanf(\"%d\",&S);\n        for (int i = 0 ;i < S; i++) {\n            scanf(\"%s%d\",op[i],num+i);\n        }\n        scanf(\"%d\",&P);\n        sum = 0;\n        for (int i = 0; i < P; i++) {\n            scanf(\"%d\",&p[i]);\n            sum += p[i]>hpm ? hpm : p[i];\n        }\n        puts(solve() ? \"YES\":\"NO\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define inf 1000000000\n\nusing namespace std;\n\nint HP, HPmax;\nint R, C;\nchar a[105][105];\n\nint T;\nmap<char, int> trap;\nint S;\nint dmg[1005];\nint P;\nint potion[13];\n\nint N;\nint dp[1005][1 << 12];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> HP >> HPmax;\n\t\tif(HP == 0 && HPmax == 0) break;\n\t\t\n\t\tcin >> R >> C;\n\t\tfor(int y = 0; y < R; y++){\n\t\t\tfor(int x = 0; x < C; x++){\n\t\t\t\tcin >> a[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> T;\n\t\tchar c; int d;\n\t\ttrap.clear();\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tcin >> c >> d;\n\t\t\ttrap[c] = d;\n\t\t}\n\t\t\n\t\tcin >> S;\n\t\tint x = 0, y = 0, cnt = 0, dir;\n\t\tconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tcin >> c >> d;\n\t\t\tif(c == 'R') dir = 0;\n\t\t\tif(c == 'U') dir = 1;\n\t\t\tif(c == 'L') dir = 2;\n\t\t\tif(c == 'D') dir = 3;\n\t\t\tfor(int j = 0; j < d; j++){\n\t\t\t\tx += dx[dir], y += dy[dir];\n\t\t\t\tcnt++;\n\t\t\t\tdmg[cnt] = trap[a[x][y]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> P;\n\t\tfor(int i = 0; i < P; i++) cin >> potion[i];\n\t\t\n\t\tN = cnt;\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int s = 0; s < (1 << P); s++){\n\t\t\t\tdp[i][s] = -inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = HP;\n\t\t\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int j = 0; j < (1 << P); j++){\n\t\t\t\tif(dp[i][j] <= 0) continue;\n\t\t\t\tif(dp[i][j] - dmg[i+1] <= 0){\n\t\t\t\t\tfor(int k = 0; k < P; k++){\n\t\t\t\t\t\tif(j & (1<<k)) continue;\n\t\t\t\t\t\tdp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], min(HPmax, dp[i][j] + potion[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j] - dmg[i+1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tfor(int i = 0; i < (1<<P); i++){\n\t\t\tif(dp[N][i] > 0){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n// 入力\nint HP, w, h;\nvector<string> a;\n// D[c] := 文字 c に対応する受けるダメージ数\nint D[256] = {0};\n\n// f[c] := 文字 c ('U','D','L','R') に対応する向き 0..3 を返す.\nint f[256] = {0};\n// 4近傍\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// dp[k][bits] := k 回目の移動で現在の使ったポーションの状態 bits のときの最大の残り HP\nint dp[1001][1<<12];\n\nint main(){\n\tf['U'] = 0; f['D'] = 1; f['L'] = 2; f['R'] = 3;\n\tint hp;\n\t\n\twhile( cin >> hp >> HP, hp || HP ){\n\t\tcin >> h >> w;\n\t\ta = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> a[y];\n\t\t}\n\t\tint T, S, P;\n\t\tcin >> T;\n\t\tfor(int i=0 ; i < T ; i++ ){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tD[c] = d;\n\t\t}\n\t\tcin >> S;\n\t\tvector<char> dir(S);\n\t\tvector<int> N(S);\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tcin >> dir[i] >> N[i];\n\t\t}\n\t\tcin >> P;\n\t\tvector<int> p(P);\n\t\tfor(int i=0 ; i < P ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t// 各ステップで何ダメージ受けるか計算\n\t\tvector<int> damege;\n\t\tint x=0, y=0;\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0 ; j < N[i] ; j++ ){\n\t\t\t\tx += dx[f[dir[i]]];\n\t\t\t\ty += dy[f[dir[i]]];\n\t\t\t\tsum += D[a[y][x]];\n\t\t\t}\n\t\t\tdamege.push_back( sum );\n\t\t}\n\t\t\n\t\t// dp の初期化\n\t\tfor(int i=0 ; i < 1001 ; i++ ){\n\t\t\tfor(int j=0 ; j < (1<<12) ; j++ ){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = hp;\n\t\tfor(int i=0 ; i < S+1 ; i++ ){\n\t\t\tfor(int j = 0 ; j < (1<<P) ; j++ ){\n\t\t\t\tif( i > 0 ){\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j] - damege[i-1]);\n\t\t\t\t}\n\t\t\t\tif( dp[i][j] <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tfor(int k=0 ; k < P ; k++ ){\n\t\t\t\t\tif( j & (1<<k) ) continue;\n\t\t\t\t\t\n\t\t\t\t\tint next = j | (1<<k);\n\t\t\t\t\tint nextHP = min(HP, dp[i][next] + p[k] );\n\t\t\t\t\tdp[i][next] = max(dp[i][next], nextHP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0 ; i < (1<<P) ; i++ ){\n\t\t\tans = max(ans, dp[S][i]);\n\t\t}\n\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\nint dy[201];\nint dx[201];\nint dp[1010][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000;\n\n// S[©çßÄX^[gÖü©¤\nint dfs(int pos,int s){\n\tif(pos==-1){\n\t\tint sum=0;\n\t\t// Ü¾gpµÄ¢È¢àÌð·×Äg¤\n\t\tfor(int i=0;i<P;i++)if(!((s>>i)&1))sum+=portions[i];\n\t\treturn sum+inithp;\n\t}\n\telse if(dp[pos][s]!=-1)return dp[pos][s];\n\tint res=-INF;\n\t// Ü¾gpµÄ¢È¢portionðgp\n\tfor(int k=0;k<P;k++)if(!((s>>k)&1))res=max(res,min(dfs(pos,s|(1<<k))+portions[k],maxhp));\n\t// ÌêÖ\n\tres=max(res,dfs(pos-1,s)-stepDmg[pos]);\n\tif(res<0)res=-INF;\n\treturn dp[pos][s]=res;\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tcin>>r>>c;\n\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint m;\n\t\t\tcin>>ch>>m;\n\t\t\tdmg[ch]=m;\n\t\t}\n\t\tcin>>S;\n\t\tint cx=0;\n\t\tint cy=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\tfor(int j=0;j<quan;j++){\n\t\t\t\tint ny=cy+dy[ch];\n\t\t\t\tint nx=cx+dx[ch];\n\t\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\t\tstep++;\n\t\t\t\tcx=nx;\n\t\t\t\tcy=ny;\n\t\t\t}\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portions[i];\n//\t\tmemset(dp,-1,sizeof(dp));\n//\t\tif(dfs(step-1,0)>0)cout<<\"YES\"<<endl;\n//\t\telse cout<<\"NO\"<<endl;\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=sum+inithp;\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1))res=max(res,min(dp[pos+1][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[pos][s]-stepDmg[pos]);\n\t\t\t\tif(res<0)res=-INF;\n\t\t\t\tdp[pos+1][s]=res;\n\t\t\t}\n\t\t}\n\t\tif(dp[step][0]>0)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1010];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1010];\nint dp[1010][1<<12];\nint dy[101];\nint dx[101];\n\nconst int INF=1000000000;\n\nint main(){\n\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tint quan;\n\t\t\tcin>>ch>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[i].second;j++){\n\t\t\t\tint nx=cx+dx[seq[i].first];\n\t\t\t\tint ny=cy+dy[seq[i].first];\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<(1<<P);j++)dp[0][j]=min(hpMax,combPortionEf[j]);\n\t\tbool ok=false;\n\t\tif(idx){\n\t\t\tfor(int j=0;j<(1<<P);j++)if(dp[0][j])ok=true;\n\t\t}\n\t\t// iツ氾板姪堋づ慊づづ敖づツづ継ortionツつェツ残ツづづつ「ツづゥツ篠楪づ個催妥・ツ残ツづィツδ可イツフツづーツ仰づ淞づゥ\n\t\tfor(int i=1;i<idx;i++){\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tdp[i][j]=-INF;\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((j>>k)&1))dp[i][j]=max(dp[i][j],min(hpMax,dp[i][j|(1<<k)]+portion[k]));\n\t\t\t\tint ny=points[i].first;\n\t\t\t\tint nx=points[i].second;\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i-1][j]-tbl[dmg[ny][nx]]);\n\t\t\t\t// 0ツ暗按可コツづ按づァツ、ツ督楪達ツ不ツ嘉つ能\n\t\t\t\tif(dp[i][j]<=0)dp[i][j]=-INF;\n\t\t\t\tif(i==idx-1&&dp[i][j]>0)ok=true;\n\t\t\t}\n\t\t}\n\t\t// ツゴツーツδ仰督楪達ツ篠楪づ可、ツ催妥・ツδ可イツフツつェ0ツづヲツづィツ妥・ツつォツつッツづェツづ姉k\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int infty = 1<<28;\nstatic int dp[1001][1<<12];\n\nint main()\n{\n  while(true){\n\n    int initHP;\n    int maxHP;\n    cin >> initHP >> maxHP;\n    if(initHP==0&&maxHP==0)break;\n\n    int R,C;\n    cin >> R >> C;\n    char M[R][C];\n    int damage[256];\n    for(int i = 0; i < R; ++i){\n      for(int j = 0; j < C; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    \n    int T;\n    cin >> T;\n    for(int i = 0; i < T; ++i){\n      char c;\n      int dam;\n      cin >> c >> dam;\n      damage[(int)c]=dam;\n    }\n    \n    int S;\n    cin >> S;\n    string inst;\n    for(int i = 0; i < S; ++i){\n      char c;\n      int step;\n      cin >> c >> step;\n      for(int j = 0; j < step; ++j){\n\tinst += c;\n      }\n    }\n\n    int P;\n    vector<int> potion;\n    cin >> P;\n    for(int i = 0; i < P; ++i){\n      int p;\n      cin >> p;\n      potion.push_back(p);\n    }\n\n    S = inst.length();\n    \n    int Pmax=1<<potion.size();\n    for(int i = 0; i < 1+S; ++i){\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i][j] = -infty;\n      }\n    }\n    dp[0][0]=initHP;\n    \n    int ni=0;\n    int nj=0;\n    for(int i = 0; i < S; ++i){\n      switch(inst[i]){\n      case 'D':++ni;break;\n      case 'U':--ni;break;\n      case 'R':++nj;break;\n      case 'L':--nj;break;\n      }\n      for(int j = Pmax-1; j >= 0; --j){\n\tfor(int k = 0; k < (int)potion.size(); ++k){\n\t  if( (j&(1<<k)) == 0 ){\n\t    dp[i][j|(1<<k)] = max( dp[i][j|(1<<k)], min(maxHP, dp[i][j] + potion[k]) );\n\t  }\n\t}\n      }\n      for(int j = 0; j < Pmax; ++j){\n\tdp[i+1][j] = max( dp[i+1][j], dp[i][j]-damage[(int)M[ni][nj]] );\n      }\n    }\n\n    int res = -infty;\n    for(int i = 0; i < Pmax; ++i){\n      res = max( res, dp[S][i] );\n    }\n    \n    if(res>0)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint row,col;\n};\n\nint HP,MAX_HP;\nint H,W;\nint damage[26],POW[13],portion[12];\nint max_HP[1001][4096];\nchar base_map[100][101],move_route[1000];\nInfo info[1001];\n\n\nvoid func(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tchar buf[2];\n\tint tmp;\n\n\tfor(int i = 0; i < T; i++){\n\t\tscanf(\"%s %d\",buf,&tmp);\n\t\tdamage[buf[0]-'A'] = tmp;\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tint index = 0;\n\n\tfor(int i = 0; i < S; i++){\n\t\tscanf(\"%s %d\",buf,&tmp);\n\t\tfor(int k = 0; k < tmp; k++){\n\t\t\tmove_route[index++] = buf[0];\n\t\t}\n\t}\n\n\tS = index;\n\n\tinfo[0].row = 0;\n\tinfo[0].col = 0;\n\n\tfor(int i = 0; i < S; i++){\n\t\tswitch(move_route[i]){\n\t\tcase 'U':\n\t\t\tinfo[i+1].row = info[i].row-1;\n\t\t\tinfo[i+1].col = info[i].col;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tinfo[i+1].row = info[i].row+1;\n\t\t\tinfo[i+1].col = info[i].col;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tinfo[i+1].row = info[i].row;\n\t\t\tinfo[i+1].col = info[i].col+1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tinfo[i+1].row = info[i].row;\n\t\t\tinfo[i+1].col = info[i].col-1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tfor(int i = 0; i < P; i++){\n\t\tscanf(\"%d\",&portion[i]);\n\t}\n\n\tfor(int i = 0; i <= S; i++){\n\t\tfor(int state = 0;state < POW[P];state++)max_HP[i][state] = 0;\n\t}\n\n\tmax_HP[0][0] = HP;\n\n\tint next_damage,next_HP,next_state;\n\n\tfor(int move = 1; move <= S; move++){\n\t\tnext_damage = damage[base_map[info[move].row][info[move].col]-'A'];\n\t\tfor(int state = 0; state < POW[P]; state++){\n\t\t\tif(max_HP[move-1][state] == 0)continue;\n\n\t\t\tif(max_HP[move-1][state] > next_damage){\n\t\t\t\tmax_HP[move][state] = max(max_HP[move][state],max_HP[move-1][state]-next_damage);\n\t\t\t}\n\n\t\t\tfor(int loop = 0; loop < P; loop++){\n\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tnext_HP = min(MAX_HP,max_HP[move-1][state]+portion[loop]);\n\t\t\t\t\tif(next_HP <= next_damage)continue;\n\t\t\t\t\tnext_state = state + POW[loop];\n\n\t\t\t\t\tmax_HP[move][next_state] = max(max_HP[move][next_state],next_HP-next_damage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int state = 0; state < POW[P];state++){\n\t\tif(max_HP[S][state] > 0){\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NO\\n\");\n}\n\nint main(){\n\n\tfor(int i = 0; i < 13; i++)POW[i] = pow(2,i);\n\n\tfor(int i = 0; i < 26; i++)damage[i] = 999;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&HP,&MAX_HP);\n\t\tif(HP == 0 && MAX_HP == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n// 入力\nint HP, w, h;\n// a[y][x] := (x,y)のグリッドの状態(文字'A' - 'Z')\nvector<string> a;\n// D[c] := 文字 c に対応する受けるダメージ数\nint D[256] = {0};\n\n// f[c] := 文字 c ('U','D','L','R') に対応する向き 0..3 を返す.\nint f[256] = {0};\n// 4近傍\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// dp[k][bits] := k 回目の移動で現在の使ったポーションの状態 bits のときの最大の残り HP\nint dp[1001][1<<12];\n\nint main(){\n\tf['U'] = 0; f['D'] = 1; f['L'] = 2; f['R'] = 3;\n\tint hp;\n\t\n\twhile( cin >> hp >> HP, hp || HP ){\n\t\tcin >> h >> w;\n\t\ta = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> a[y];\n\t\t}\n\t\tint T, S, P;\n\t\tcin >> T;\n\t\tfor(int i=0 ; i < T ; i++ ){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tD[c] = d;\n\t\t}\n\t\tcin >> S;\n\t\t// path[k] := k 回目の移動する方向\n\t\tvector<int> path;\n\t\tfor(int i=0 ; i < S ; i++ ){\n\t\t\tchar dir;\n\t\t\tint n;\n\t\t\tcin >> dir >> n;\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tpath.push_back( f[dir] );\n\t\t\t}\n\t\t}\n\t\tcin >> P;\n\t\tvector<int> p(P);\n\t\tfor(int i=0 ; i < P ; i++ ){\n\t\t\tcin >> p[i];\n\t\t}\n\t\t// 各ステップで何ダメージ受けるか計算\n\t\tvector<int> damege;\n\t\tint x=0, y=0;\n\t\tdamege.push_back(0);\n\t\tfor(int i=0 ; i < path.size() ; i++ ){\n\t\t\tx += dx[path[i]];\n\t\t\ty += dy[path[i]];\n\t\t\tdamege.push_back( D[a[y][x]] );\n\t\t}\n\t\t\n\t\t// dp の初期化\n\t\tint N = path.size() + 1;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tfor(int j=0 ; j < (1<<P) ; j++ ){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = hp;\n\t\t\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tfor(int j = 0 ; j < (1<<P) ; j++ ){\n\t\t\t\tif( i > 0 ){ // i 回目の移動で受けたダメージを計算\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j] - damege[i]);\n\t\t\t\t}\n\t\t\t\t// HP が 0 以下のときは終了\n\t\t\t\tif( dp[i][j] <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tfor(int k=0 ; k < P ; k++ ){\n\t\t\t\t\tif( j & (1<<k) ) continue;\n\t\t\t\t\t\n\t\t\t\t\t// p[k] のポーションを使う\n\t\t\t\t\tint next = j | (1<<k);\n\t\t\t\t\tdp[i][next] = min(HP, max(dp[i][next], dp[i][j] + p[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0 ; i < (1<<P) ; i++ ){\n\t\t\tans = max(ans, dp[N-1][i]);\n\t\t}\n\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <assert.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint hp_init, hp_max;\nint R, C;\nchar mas[101][101];\nint T, S, P;\nmap<char, int> mp;\nvector<int> step; // damege in each step\nvector<int> po;\n\nint dp[1010][1<<12];\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst string dir = \"DRUL\";\n\nbool in(int y, int x) {\n  return 0<=y&&y<R&&0<=x&&x<C;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n\n  while(cin >> hp_init >> hp_max, hp_init+hp_max) {\n    mp.clear();\n    step.clear();\n    po.clear();\n    cin >> R >> C;\n    rep(i, R) rep(j, C) cin >> mas[i][j];\n    cin >> T;\n    rep(i, T) {\n      char c; int d;\n      cin >> c >> d;\n      mp[c] = d;\n    }\n    cin >> S;\n    int y = 0, x = 0;\n    rep(i, S) {\n      char c; int d;\n      cin >> c >> d;\n      int idx = dir.find(c);\n      rep(j, d) {\n\ty += dy[idx], x += dx[idx];\n\tassert(in(y, x));\n\tstep.push_back(mp[mas[y][x]]);\n      }\n    }\n    cin >> P;\n    rep(i, P) {\n      int p; cin >> p;\n      po.push_back(p);\n    }\n    fill(dp[0], dp[1010], 0);\n    dp[0][0] = hp_init;\n    rep(i, step.size()) {\n      rep(j, 1<<P) {\n\tif(dp[i][j] == 0) continue;\n\tchmax(dp[i+1][j], dp[i][j]-step[i]);\n\trep(k, P) if(!((j>>k)&1)) {\n\t  chmax(dp[i][j|(1<<k)], min(hp_max, dp[i][j]+po[k]));\n\t  chmax(dp[i+1][j|(1<<k)], min(hp_max, dp[i][j]+po[k])-step[i]);\n\t}\n      }\n    }\n    bool flag = false;\n    rep(i, 1<<P) if(dp[step.size()][i] > 0) flag = true;\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main(){\n\tint dmg[26];\n\tstring mp[100];\n\tint HP, HPmax;\n\tint reg[12];\n\tint dp[2][1<<12];\n\twhile(cin >> HP >> HPmax, HP){\n\t\tint R, C; cin >> R >> C;\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tint T; cin >> T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tdmg[c-'A'] = d;\n\t\t}\n\t\tint S; cin >> S;\n\t\tvector<int> act;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tchar c; int d; cin >> c >> d;\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tif(c=='U') act.push_back(0);\n\t\t\t\tif(c=='D') act.push_back(1);\n\t\t\t\tif(c=='R') act.push_back(2);\n\t\t\t\tif(c=='L') act.push_back(3);\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tfor(int i=0;i<P;i++) cin >> reg[i];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][(1<<P)-1] = HP;\n\t\tint x = 0, y = 0;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<act.size();i++){\n\t\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\t\tx += dx[act[i]];\n\t\t\ty += dy[act[i]];\n\t\t\tint damage = dmg[mp[x][y]-'A'];\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tif(dp[cur][j] == 0) continue;\n\t\t\t\tif(dp[cur][j] > damage) dp[next][j] = max(dp[next][j], dp[cur][j]-damage);\n\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\tif(!(j&(1<<k))) continue;\n\t\t\t\t\tdp[cur][j^(1<<k)] = max(min(HPmax, dp[cur][j]+reg[k]), dp[cur][j^(1<<k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur, next);\n\t\t}\n\t\tcout << (dp[cur][0] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hp,HP;\nint h,w;\nstring mp[101];\nint dmg[1<<8];\nstring seq;\nint P,p[12];\n\nvoid Max(int &a,int b){a=max(a,b);}\n\nvoid Go(int &x,int &y,char ch){\n  if(ch=='U') y--;\n  if(ch=='D') y++;\n  if(ch=='L') x--;\n  if(ch=='R') x++;\n}\n\nint dp[1010][1<<12];\nvoid update(int idx,int bit,int hp,int i){\n  Max(dp[i][bit],hp);\n  if(idx==P||hp>0) return;\n  update(idx+1,bit,hp,i);\n  if(bit>>idx&1)return;\n  update(idx+1,bit|(1<<idx),min(HP-1,hp+p[idx]),i);\n}\n\n\nbool DP(){\n  int x = 0,y = 0,size=seq.size();\n  memset(dp,0,sizeof(dp));\n  dp[0][0] = hp;\n  for(int i=0;i<size;i++){ \n    Go(x,y,seq[i]);\n    for(int bit=0;bit<(1<<P);bit++)\n      if(dp[i][bit])update(0,bit,dp[i][bit]-dmg[mp[y][x]],i+1);\n  }\n\n  for(int i=0;i<(1<<P);i++) if(dp[size][i])return 1;\n  return 0;\n}\n\n\nint main(){\n  int cnt=0;\n  while(1){\n    cnt++;\n    cin>>hp>>HP;\n    if(!hp&&!HP) return 0;\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n\n    int Alpha;\n    cin>>Alpha;\n    for(int i=0,cost;i<Alpha;i++){\n      char ch;\n      cin>>ch>>cost;\n      dmg[ch] = cost;\n    }\n    \n    int s;\n    cin>>s;\n    seq.clear();\n    for(int i=0,num;i<s;i++){\n      char ch;\n      cin>>ch>>num;\n      seq+=string(num,ch);\n    }\n\n    cin>>P;\n    for(int i=0;i<P;i++)cin>>p[i];\n    cout<<(DP()? \"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<char, int> pci;\nint life, maxi, r, c, t, s, p;\nvector<int> potion;\nmap<char, int> damage;\n \nvoid calcDP(vector<vector<int> > &dp, vector<string> &grid,\n            int nx, int ny, int x, int y, int trun){\n  for (int i = 0; i < (1<<p); i++) {\n    int next_life = dp[i][trun - 1];\n    if(next_life == 0)continue;\n    dp[i][trun] = max(dp[i][trun], next_life -\n                      damage[grid[ny][nx]]);\n    for (int j = 0; j < p; j++) {\n      if(i & (1<<j))continue;\n      next_life = min(maxi, next_life + potion[j]);\n      next_life -= damage[grid[ny][nx]];\n      dp[i + (1<<j)][trun] = max(dp[i + (1<<j)][trun],\n                                 next_life);\n    }\n  }\n}\n \nint main(){\n  while(std::cin >> life >> maxi, life){\n    std::cin >> r >> c;\n    vector<string> grid(r);\n    for (int i = 0; i < r; i++) {\n      std::cin >> grid[i];\n    }\n    std::cin >> t;\n    for (int i = 0; i < t; i++) {\n      char floor;\n      int d;\n      std::cin >> floor >> d;\n      damage[floor] = d;\n    }\n    std::cin >> s;\n    vector<pci> action(s);\n    int sum = 0;\n    for (int i = 0; i < s; i++) {\n      std::cin >> action[i].first >> action[i].second;\n      sum += action[i].second;\n    }\n    std::cin >> p;\n    for (int i = 0; i < p; i++) {\n      int tmp;\n      std::cin >> tmp;\n      potion.push_back(tmp);\n    }\n    vector<vector<int> > dp((1<<p), vector<int>(sum + 1, 0));\n    for (int i = 0; i < (1<<p); i++) {\n      dp[i][0] = life;\n      for (int j = 0; j < p; j++) {\n        if((i & (1<<j)) == 0)continue;\n        dp[i][0] = min(maxi, dp[i][0] + potion[j]);\n      }\n    }\n    int x = 0, y = 0;\n    map<char, int> dx, dy;\n    dx['U'] = 0;\n    dx['D'] = 0;\n    dx['R'] = 1;\n    dx['L'] = -1;\n    dy['U'] = -1;\n    dy['D'] = 1;\n    dy['R'] = 0;\n    dy['L'] = 0;\n    int trun = 0;\n    for (int i = 0; i < s; i++) {\n      for (int j = 0; j < action[i].second; j++) {\n        trun++;\n        int nx = x + dx[action[i].first],\n          ny = y + dy[action[i].first];\n        calcDP(dp, grid, nx, ny, x, y, trun);\n        x = nx, y = ny;\n      }\n    }\n    // for (int i = 0; i < (1<<p); i++) {\n    //   for (int j = 0; j <= sum; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    bool flag = 0;\n    for (int i = 0; i < (1<<p); i++) {\n      if(dp[i][sum] > 0)flag = 1;\n    }\n    if(flag){\n      std::cout << \"YES\" << std::endl;\n    }else{\n      std::cout << \"NO\" << std::endl; \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h0,hmax;cin>>h0>>hmax && h0|hmax;){\n\t\tint h,w; cin>>h>>w;\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tmap<char,int> dmgs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdmgs[c]=x;\n\t\t\t}\n\t\t}\n\t\tstring dirs;\n\t\t{\n\t\t\tint len; cin>>len;\n\t\t\trep(i,len){\n\t\t\t\tchar c; int x; cin>>c>>x;\n\t\t\t\tdirs.append(x,c);\n\t\t\t}\n\t\t}\n\t\tint m=dirs.size();\n\t\tint n; cin>>n;\n\t\tvi pots(n);\n\t\trep(i,n) cin>>pots[i];\n\t\t\n\t\tvi decs(m);\n\t\tfor(int i=0,j=0,k=0;k<m;k++){\n\t\t\ti+=\"\\xff\\x1\\0\\0\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tj+=\"\\0\\0\\xff\\x1\"[string(\"UDLR\").find(dirs[k])];\n\t\t\tdecs[k]=dmgs[grid[i][j]];\n\t\t}\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) sums[i]+=pots[j];\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(0,h0,(1<<n)-1); // (step,hp,rest)\n\t\tvvi vis(m+1,vi(1<<n));\n\t\tbool res=false;\n\t\twhile(q.size()){\n\t\t\tint ci,ch,cr; tie(ci,ch,cr)=q.front(); q.pop();\n\t\t\tif(vis[ci][cr]) continue;\n\t\t\tvis[ci][cr]=1;\n\t\t\tif(ci==m){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch-=decs[ci];\n\t\t\tif(ch>0){\n\t\t\t\tq.emplace(ci+1,ch,cr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int s=cr;s;s=s-1&cr)\n\t\t\t\tif(ch+sums[s]>0)\n\t\t\t\t\tq.emplace(ci+1,ch+sums[s],cr^s);\n\t\t}\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\n\nint dp[1005][1<<12];\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while (true) {\n    int hp, hpmax;\n    cin >> hp >> hpmax;\n    if (hp == 0 && hpmax == 0) break;\n    int r, c;\n    cin >> r >> c;\n    vector<vector<char>> g(r, vector<char>(c));\n    rep(i, r)rep(j, c) cin >> g[i][j];\n    int t;\n    cin >> t;\n    map<char, int> trap;\n    rep(i, t) {\n      char ch;\n      int d;\n      cin >> ch >> d;\n      trap[ch] = d;\n    }\n    int s;\n    cin >> s;\n    string move = \"\";\n    rep(i, s) {\n      char dir;\n      int step;\n      cin >> dir >> step;\n      rep(j, step) move += dir;\n    }\n    int p;\n    cin >> p;\n    int potion[p] = {};\n    rep(i, p) {\n      cin >> potion[i];\n    }\n\n    //solve\n    string road = \"\";\n    int nowx = 0;\n    int nowy = 0;\n    for (auto st : move) {\n      if (st == 'U') nowy--;\n      else if (st == 'D') nowy++;\n      else if (st == 'L') nowx--;\n      else nowx++;\n      road += g[nowy][nowx];\n    }\n\n    rep(i, 1005)rep(j, 12) dp[i][j] = 0;\n    dp[0][0] = hp;\n    int n = road.size();\n    rep(i, n) {\n      char now = road[i];\n      rep(j, 1<<p) {\n        dp[i + 1][j] = dp[i][j];\n        rep(k, p) {\n          if (j>>k & 1) {\n            if (dp[i][j^(1<<k)] <= 0) continue;\n            dp[i + 1][j] = max(dp[i + 1][j], min(hpmax, dp[i][j^(1<<k)] + potion[k]));\n          }\n        }\n        dp[i + 1][j] -= trap[now];\n      }\n    }\n    bool ok = false;\n    rep(j, 1<<p) {\n      if (dp[n][j] > 0) {\n        ok = true;\n        break;\n      }\n    }\n    if (ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\t\tvi;\ntypedef\tvector<vi>\t\tvvi;\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int hpinit,hpmax;scanf(\"%d%d\",&hpinit,&hpmax),hpinit;){\n\t\tint m,n,tmp;\tscanf(\"%d%d\",&m,&n);\n\n\t\tvvi trap(m,vi(n));\n\t\t{\n\t\t\tchar a[100][101];\n\t\t\trep(i,m)\tscanf(\"%s\",a+i);\n\t\t\tint tmp;\tscanf(\"%d \",&tmp);\n\t\t\tint f[128];\n\t\t\trep(i,tmp){\n\t\t\t\tchar ch;\n\t\t\t\tint dmg;\tscanf(\"%c%d \",&ch,&dmg);\n\t\t\t\tf[ch]=dmg;\n\t\t\t}\n\t\t\trep(i,m)rep(j,n)\ttrap[i][j]=f[a[i][j]];\n\t\t}\n\n\t\tscanf(\"%d \",&tmp);\n\t\tvector<pii> step(tmp);\n\t\trep(i,tmp){\n\t\t\tchar ch;\n\t\t\tint d;\tscanf(\"%c%d \",&ch,&d);\n\t\t\tchar f[128];\n\t\t\tf['R']=0,f['U']=1,f['L']=2,f['D']=3;\n\t\t\tstep[i]=mp(d,f[ch]);\n\t\t}\n\t\tstep.pb(mp(1,0));\t// dummy\n\n\t\tint psize;\tscanf(\"%d\",&psize);\n\t\tvi por(psize);\n\t\trep(i,psize)\tscanf(\"%d\",&por[i]);\n\n\t\tvi cure(1<<psize);\n\t\trep(i,1<<psize)rep(j,psize){\n\t\t\tif(i&(1<<j))\tcure[i]+=por[j];\n\t\t}\n\n\t\tint x=0,y=0;\n\t\tvi hp(1<<psize);\thp[(1<<psize)-1]=hpinit;\n\t\trep(t,step.size())rep(k,step[t].first){\n\t\t\tint dmg=trap[y][x];\n\t\t\trep(i,1<<psize){\n\t\t\t\tif(hp[i]<=0)\tcontinue;\n\t\t\t\tif(hp[i]<=dmg){\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif((j&i)==j){\t// stat j is a subset of stat i\n\t\t\t\t\t\t\thp[j]=max(hp[j],min(hp[i]+cure[i&~j],hpmax)-dmg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thp[i]-=dmg;\n\t\t\t}\n\t\t\tint dir=step[t].second;\n\t\t\tx+=dx[dir];\ty+=dy[dir];\n\t\t}\n\n\t\tbool ok=false;\n\t\trep(i,1<<psize) if(hp[i]>0){ ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1<<12)\n#define int short\n\nsigned main(){\n    int HPinit, HPmax;\n    while(cin>>HPinit>>HPmax&&(HPinit||HPmax)){\n        int h,w;\n        cin>>h>>w;\n        vector<string> vs(h);\n        rep(i,h)cin>>vs[i];\n        \n        int n;\n        cin>>n;\n        vector<int> dmg(26);\n        rep(i,n){\n            char ch;\n            int val;\n            cin>>ch>>val;\n            dmg[ch-'A'] = val;\n        }\n        \n        int m;\n        cin>>m;\n        vector<pair<char,int>> mv(m);\n        rep(i,m){\n            char ch;\n            int dist;\n            cin>>ch>>dist;\n            mv[i] = make_pair(ch,dist);\n        }\n        \n        int c;\n        cin>>c;\n        vector<int> p(c);\n        rep(i,c)cin>>p[i];\n        \n        static int dp[1<<12];\n        rep(i,1001)rep(j,1<<12)dp[j] = -INF;\n        dp[(1<<c)-1] = HPinit;\n        \n        int dy[]={1,0,-1,0};\n        int dx[]={0,1,0,-1};\n\n        int y = 0, x=0;\n        int turn = 0;\n        int count = 0;\n        rep(i,m){\n            int dir = -1;\n            char ch = mv[i].first;\n            if(ch=='D')dir=0;\n            else if(ch=='R')dir=1;\n            else if(ch=='U')dir=2;\n            else if(ch=='L')dir=3;\n            assert(dir!=-1);\n            \n            rep(j,mv[i].second){\n                y += dy[dir];\n                x += dx[dir];\n                for(int bit = 1<<c;bit>=0;bit--){\n                    if(dp[bit]<=0)continue;\n                    if(dp[bit]>dmg[vs[y][x]-'A'])continue;\n                    rep(i,c){\n                        if(((1<<i)&bit)){\n                            dp[bit^(1<<i)] = max(dp[bit^(1<<i)], min<int>(HPmax, dp[bit] + p[i]));\n                        }\n                    }\n                }\n                for(int bit = 1<<c;bit>=0;bit--){\n                    dp[bit] -= dmg[vs[y][x]-'A'];\n                }\n                turn++;\n            }\n        }\n        int maxi = -INF;\n        rep(i,1<<c)maxi = max(maxi,dp[i]);\n        if(maxi>0)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint HPINT,HPMAX;\nint N,M;\nchar ch[1010][1010];\nint A[1010][1010];\nchar ch1[1201];\nint dp[1010][4100];\nint Q;\nint P[1010];\nint U;\nint K;\nint po[2010];\n#define oo 1000000000\nint main()\n{\n    int i,j,k;\n    int a,b,s;\n    int T;\n    while(scanf(\"%d%d\",&HPINT,&HPMAX)!=EOF)\n    {\n        if(HPINT==0&&HPMAX==0) break;\n        scanf(\"%d%d\",&N,&M);\n        for(i=0;i<N;i++)\n        {\n            scanf(\"%s\",ch[i]);\n        }\n        scanf(\"%d\",&T);\n        for(int t=0;t<T;t++)\n        {\n            scanf(\"%s%d\",ch1,&s);\n            for(i=0;i<N;i++)\n            {\n                for(j=0;j<M;j++)\n                {\n                    if(ch[i][j]==ch1[0])\n                    {\n                        A[i][j]=s;\n                    }\n                }\n            }\n        }\n        scanf(\"%d\",&Q);\n        k=1;\n        for(i=0;i<Q;i++)\n        {\n            scanf(\"%s%d\",ch1,&s);\n            if(ch1[0]=='U') a=0;\n            else if(ch1[0]=='R') a=1;\n            else if(ch1[0]=='D') a=2;\n            else a=3;\n            for(j=0;j<s;j++,k++)\n            {\n                P[k]=a;\n            }\n        }\n        K=k-1;\n        scanf(\"%d\",&U);\n        for(i=0;i<U;i++) scanf(\"%d\",&po[i]);\n        for(i=0;i<=K;i++)\n            for(j=0;j<(1<<U);j++)\n                dp[i][j]=-oo;\n        dp[0][(1<<U)-1]=HPINT;\n        int y=0,x=0;\n        for(i=1;i<=K;i++)\n        {\n            for(j=(1<<U)-1;j>=0;j--)\n            {\n                dp[i][j]=dp[i-1][j];\n                for(k=0;k<U;k++)\n                {\n                    if((j&(1<<k))==0)\n                    {\n                        dp[i][j]=max(dp[i][j],min(dp[i][j|(1<<k)]+po[k],HPMAX));\n                    }\n                }\n            }\n            if(P[i]==0) y--;\n            else if(P[i]==1) x++;\n            else if(P[i]==2) y++;\n            else x--;\n            for(j=0;j<(1<<U);j++)\n            {\n                if(dp[i][j]>A[y][x]) dp[i][j]-=A[y][x];\n                else dp[i][j]=-oo;\n            }\n        }\n        bool ju=false;\n        for(j=0;j<(1<<U);j++) if(dp[K][j]>0) ju=true;\n        if(ju) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 0; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] == -1) continue;\n        for(int k : buff[P][j]) {\n          int get = min(malta, dp[j] + add[k]) - damage[A[yy][xx]];\n          if(get >= 1) nextdp[j | k] = max(nextdp[j | k], get);\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint hpi,hpm,R,C,T,S,n[1010],P,p[19],x,y,dy[]={0,1,0,-1},dx[]={1,0,-1,0},dp[1<<12];\nchar a[110][110],d[1010],c;\nmap<char,int> M,m;\nvi v;\nint tc;\nint main(){\n\tm['R']=0,m['D']=1,m['L']=2,m['U']=3;\n\twhile(cin>>hpi>>hpm&&hpi){tc++;\n\t\tv.clear();\n\t\tcin>>R>>C;\n\t\trep(i,R)cin>>a[i];\n\t\tcin>>T;\n\t\trep(i,T)cin>>c>>y,M[c]=y;\n\t\tcin>>S;\n\t\trep(i,S)cin>>d[i]>>n[i];\n\t\tcin>>P;\n\t\trep(i,P)cin>>p[i];\n\t\ty=x=0;\n\t\trep(i,S){\n\t\t\trep(j,n[i]){\n\t\t\t\ty+=dy[m[d[i]]],x+=dx[m[d[i]]];\n\t\t\t\tif(M[a[y][x]])v.pb(M[a[y][x]]);\n\t\t\t}\n\t\t}\n\t\tfill(dp,dp+(1<<P),-INF);\n\t\tdp[0]=hpi;\n\t\trep(i,v.sz)rep(j,1<<P)if(dp[j]>0){\n\t\t\trep(k,P)if(!(j&1<<k)){\n\t\t\t\tdp[j|1<<k]=max(dp[j|1<<k],min(hpm,dp[j]+p[k]));\n\t\t\t}\n\t\t\tdp[j]-=v[i];\n\t\t}\n\t\tcout<<(dp[(1<<P)-1]>0||!v.sz?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef pair<string, int> psi;\n\n// dp[step][potion(bit)] = max-remains-hp\nint dp[1001][1 << 12];\n\nint main(){\n\twhile(true){\n\t\tint hp_init, hp_max;\n\t\tcin >> hp_init >> hp_max;\n\t\tif(hp_init == 0 && hp_max == 0){ break; }\n\t\tint R, C;\n\t\tcin >> R >> C;\n\t\tvector<string> field(R);\n\t\tfor(int i = 0; i < R; ++i){ cin >> field[i]; }\n\t\tint T;\n\t\tcin >> T;\n\t\tvector<int> traps(26);\n\t\tfor(int i = 0; i < T; ++i){\n\t\t\tstring t;\n\t\t\tint d;\n\t\t\tcin >> t >> d;\n\t\t\ttraps[t[0] - 'A'] = d;\n\t\t}\n\t\tint S;\n\t\tcin >> S;\n\t\tvector<psi> commands(S);\n\t\tfor(int i = 0; i < S; ++i){ cin >> commands[i].first >> commands[i].second; }\n\t\tint P;\n\t\tcin >> P;\n\t\tvector<int> potions(P);\n\t\tfor(int i = 0; i < P; ++i){ cin >> potions[i]; }\n\t\tvector<int> route;\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 0; i < S; ++i){\n\t\t\tint n = commands[i].second;\n\t\t\tint dx = 0, dy = 0;\n\t\t\tswitch(commands[i].first[0]){\n\t\t\t\tcase 'L': dx = -1; break;\n\t\t\t\tcase 'R': dx =  1; break;\n\t\t\t\tcase 'U': dy = -1; break;\n\t\t\t\tcase 'D': dy =  1; break;\n\t\t\t}\n\t\t\twhile(n--){\n\t\t\t\tx += dx; y += dy;\n\t\t\t\troute.push_back(traps[field[y][x] - 'A']);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = hp_init;\n\t\tfor(int i = 0; i < route.size(); ++i){\n\t\t\tint d = route[i];\n//\t\t\tcout << d << \" |\\t\";\n\t\t\tfor(int j = 0; j < (1 << P); ++j){\n//\t\t\t\tcout << dp[i][j] << \"\\t\";\n\t\t\t\tif(dp[i][j] <= 0){ continue; }\n\t\t\t\tif(dp[i][j] - d > 0){\n\t\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] - d);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < P; ++k){\n\t\t\t\t\tif(j & (1 << k)){ continue; }\n\t\t\t\t\tint hp = min(dp[i][j] + potions[k], hp_max);\n\t\t\t\t\tdp[i][j | (1 << k)] = max(dp[i][j | (1 << k)], hp);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << endl;\n\t\t}\n\t\tbool found = false;\n\t\tfor(int i = 0; i < (1 << P); ++i){\n\t\t\tif(dp[route.size()][i] > 0){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (found ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 105;\nstruct Node{\n    char di;\n    int step;\n}e[maxn*10];\nchar Map[maxn][maxn];\nint op[13],mark[13];\nint dir[4][2]={1,0,0,1,-1,0,0,-1};\nint judge(char dd){\n    if(dd=='D') return 0;\n    if(dd=='R') return 1;\n    if(dd=='U') return 2;\n    if(dd=='L') return 3;\n}\nint main(){\n    int h_now,h_max;\n    int r,c;\n    while(~scanf(\"%d %d\",&h_now,&h_max)){\n        if(h_now==0 && h_max==0) break;\n        scanf(\"%d %d\",&r,&c);\n        for(int i=0;i<r;i++){\n            scanf(\"%s\",Map[i]);\n        }\n        int t;\n        map<char,int>trap;\n        scanf(\"%d\",&t);\n        while(t--){\n            char a;\n            int c;\n            getchar();\n            scanf(\"%c %d\",&a,&c);\n            trap[a]=c;\n        }\n        int s;\n        scanf(\"%d\",&s);\n        for(int i=0;i<s;i++){\n            getchar();\n            scanf(\"%c %d\",&e[i].di,&e[i].step);\n        }\n        int p;\n        scanf(\"%d\",&p);\n        for(int i=0;i<p;i++){\n            scanf(\"%d\",&op[i]);\n        }\n        sort(op,op+p);\n        int nowx=0,nowy=0;\n        int flag=0;\n       // printf(\"~~~~~\\n\");\n        for(int i=0;i<s;i++){\n            int dire=judge(e[i].di);\n            for(int j=0;j<e[i].step;j++){\n                int ff=0;\n                nowx=nowx+dir[dire][0],nowy=nowy+dir[dire][1];\n                //printf(\"~~~~%d %d\\n\",nowx,nowy);\n               // printf(\"ho=%d x=%d y=%d\\n\",h_now,nowx,nowy);\n                if(h_now<=trap[Map[nowx][nowy]]){\n                    for(int k=0;k<p;k++){\n                        if(mark[k]) continue;\n                        int ho=h_now+op[k];\n                        while(ho<=trap[Map[nowx][nowy]]){\n                            k++;\n                            if(mark[k]) continue;\n                            mark[k]=1;\n                            ho+=op[k];\n                        }\n                        if(ho>h_max){\n                            ho=h_max;\n                        }\n                        if(ho>trap[Map[nowx][nowy]]){\n                            mark[k]=1;\n                            ff=1;\n                            h_now=ho-trap[Map[nowx][nowy]];\n                            break;\n                        }\n                    }\n                }\n                else{\n                    ff=1;\n                    h_now-=trap[Map[nowx][nowy]];\n                }\n                if(!ff){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        if(flag) printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\t\tvi;\ntypedef\tvector<vi>\t\tvvi;\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int hpinit,hpmax;scanf(\"%d%d\",&hpinit,&hpmax),hpinit;){\n\t\tint m,n,tmp;\tscanf(\"%d%d\",&m,&n);\n\n\t\tvvi trap(m,vi(n));\n\t\t{\n\t\t\tchar a[100][101];\n\t\t\trep(i,m)\tscanf(\"%s\",a+i);\n\t\t\tint tmp;\tscanf(\"%d \",&tmp);\n\t\t\tint f[128];\n\t\t\trep(i,tmp){\n\t\t\t\tchar ch;\n\t\t\t\tint dmg;\tscanf(\"%c%d \",&ch,&dmg);\n\t\t\t\tf[ch]=dmg;\n\t\t\t}\n\t\t\trep(i,m)rep(j,n)\ttrap[i][j]=f[a[i][j]];\n\t\t}\n\n\t\tscanf(\"%d \",&tmp);\n\t\tvector<pii> step(tmp);\n\t\trep(i,tmp){\n\t\t\tchar ch;\n\t\t\tint d;\tscanf(\"%c%d \",&ch,&d);\n\t\t\tchar f[128];\n\t\t\tf['R']=0,f['U']=1,f['L']=2,f['D']=3;\n\t\t\tstep[i]=mp(d,f[ch]);\n\t\t}\n\t\tstep.pb(mp(1,0));\n\n\t\tint psize;\tscanf(\"%d\",&psize);\n\t\tvi por(psize);\n\t\trep(i,psize)\tscanf(\"%d\",&por[i]);\n\n\t\tvi cure(1<<psize);\n\t\trep(i,1<<psize)rep(j,psize){\n\t\t\tif(i&(1<<j))\tcure[i]+=por[j];\n\t\t}\n\n\t\tint x=0,y=0;\n\t\tvi hp(1<<psize);\thp[(1<<psize)-1]=hpinit;\n\t\trep(t,step.size())rep(k,step[t].first){\n\t\t\tint dmg=trap[y][x];\n\t\t\trep(i,1<<psize){\n\t\t\t\tif(hp[i]<=0)\tcontinue;\n\t\t\t\trep(j,i){\n\t\t\t\t\tif((j&i)==j){\n\t\t\t\t\t\thp[j]=max(hp[j],min(hp[i]+cure[i&~j],hpmax)-dmg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thp[i]-=dmg;\n\t\t\t}\n\t\t\tint dir=step[t].second;\n\t\t\tx+=dx[dir];\ty+=dy[dir];\n\t\t}\n\n\t\tbool ok=false;\n\t\trep(i,1<<psize) if(hp[i]>0){ ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(){\n  int init_hp,max_hp;\n  while(cin>>init_hp>>max_hp,init_hp|max_hp){\n    int r,c;\n    cin>>r>>c;\n    vs a(r);\n    REP(i,r){\n      cin>>a[i];\n    }\n\n    int t;\n    cin>>t;\n    map<char,int> d;\n    REP(i,t){\n      char c;\n      int dd;\n      cin>>c>>dd;\n      d[c]=dd;\n    }\n    int s;\n    cin>>s;\n    int cy=0,cx=0;\n    vi damages(1);\n    REP(i,s){\n      char dd;\n      int n;\n      cin>>dd>>n;\n      int dy=0,dx=0;\n      switch(dd){\n        case 'U':\n          dy=-1;break;\n        case 'D':\n          dy=1;break;\n        case 'L':\n          dx=-1;break;\n        case 'R':\n          dx=1;break;\n      }\n      REP(j,n){\n        cy+=dy;\n        cx+=dx;\n        damages.push_back(d[a[cy][cx]]);\n      }\n    }\n\n    int P;\n    cin>>P;\n    vi p(P);\n    REP(i,P){\n      cin>>p[i];\n    }\n\n    int n=damages.size();\n    vvi dp(n+1,vi(1<<P));\n    dp[0][0]=init_hp;\n    REP(i,n){\n      REP(j,1<<P){\n        if(dp[i][j]>0){\n          if(dp[i][j]<=damages[i]){\n            REP(k,1<<P){\n              bool ok=true;\n              int cured=0;\n              REP(l,P){\n                if((k>>l)&1){\n                  cured+=p[l];\n                }\n                if((j>>l)&(k>>l)&1){\n                  ok=false;\n                }\n              }\n              if(ok){\n                dp[i+1][j|k]=max(dp[i+1][j|k],min(max_hp,dp[i][j]+cured-damages[i]));\n              }\n            }\n          }else{\n            dp[i+1][j]=max(dp[i+1][j],dp[i][j]-damages[i]);\n          }\n        }\n      }\n    }\n    /*\n    REP(i,n+1){\n      REP(j,1<<P){\n        cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n    */\n    bool ok=false;\n    REP(j,1<<P){\n      if(dp[n][j]>0){\n        ok=true;\n      }\n    }\n    cout<<(ok?\"YES\":\"NO\")<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint hpi,hpm;\nint r,c;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint fie[101][101];\nint t;\nint td[31];\nint s;\nint move[1001];\nint p;\nint pr[20];\nint dp[1001][1<<13];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&hpi,&hpm);\n\t\tif(hpi+hpm==0)break;\n\t\tscanf(\"%d%d\",&r,&c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfie[i][j]=str[j]-'A';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%*c\",&t);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tchar type;\n\t\t\tint dam;\n\t\t\tscanf(\"%c%d%*c\",&type,&dam);\n\t\t\ttd[type-'A']=dam;\n\t\t}\n\t\tscanf(\"%d%c\",&s);\n\t\tint all=0;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tchar d;\n\t\t\tint dir,a;\n\t\t\tscanf(\"%c%d%*c\",&d,&a);\n\t\t\tif(d=='U')dir=3;\n\t\t\tif(d=='D')dir=1;\n\t\t\tif(d=='R')dir=0;\n\t\t\tif(d=='L')dir=2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tmove[all++]=dir;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++){\n\t\t\tscanf(\"%d\",&pr[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=hpi;\n\t\tint x=0,y=0;\n\t\tint dall=0;\n\t\tfor(int i=0;i<all;i++){\n\t\t\tx+=dx[move[i]];\n\t\t\ty+=dy[move[i]];\n\t\t\tint dam=td[fie[y][x]];\n\t\t\tdall+=dam;\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tif(dp[i][j]>0){\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tfor(int k=0;k<p;k++){\n\t\t\t\t\t\tif(j>>k & 1)continue;\n\t\t\t\t\t\tdp[i][j|(1<<k)]=max(dp[i][j|(1<<k)],min(hpm,dp[i][j]+pr[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\t\tdp[i+1][j]-=dam;\n\t\t\t}\n\t\t}\n\t\tbool flag=false;\n\t\tfor(int j=0;j<(1<<p);j++){\n\t\t\tif(dp[all][j]>0)flag=true;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nchar str[1010][1010],ch[1010];\nint  sa[1010], po[1010];\nint  hpi, hpm;\nint  r, c, num, t, s, pnum;\nstruct node\n{\n     int step;\n     char di[1010];\n}p[1010];\n\nbool  GetAns()\n{\n      int x = 0, y = 0;\n      for(int i = 0; i < s; i ++)\n      {\n             int sum = 0;\n             if(p[i].di[0] == 'U')\n             {\n                 for(int j = x-1; j >= x - p[i].step ;j --)\n                 {\n                        //int j = x - p[i].step;\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x -= p[i].step;\n             }\n             if(p[i].di[0] == 'D')\n             {\n                 for(int j = x+1; j <= x + p[i].step ;j ++)\n                 {\n                       // int j = x + p[i].step;\n                        int tmp = str[j][y] - 'A';\n                        sum += sa[tmp];\n                 }\n                  x += p[i].step;\n             }\n             if(p[i].di[0] == 'L')\n             {\n                 for(int j = y-1; j >= y - p[i].step ;j --)\n                 {\n                       // int j = y - p[i].step;\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                }\n                  y -= p[i].step;\n             }\n             if(p[i].di[0] == 'R')\n             {\n                 for(int j = y+1; j <= y + p[i].step ;j ++)\n                 {\n                       // int j = y + p[i].step;\n                        int tmp = str[x][j] - 'A';\n                        sum += sa[tmp];\n                 }\n                  y += p[i].step;\n             }\n\n             bool f = false;\n             if(hpi > sum)\n             {\n                   hpi -= sum;\n                   f = true;\n                   continue;\n             }\n             for(int j = 0; j < pnum; j ++)\n             {\n                    int tmp = min(hpm, hpi + po[j]);\n                    if(tmp > sum)\n                    {\n                         hpi = tmp - sum;\n                         f = true;\n                         po[j] = 0;\n                         break;\n                    }\n             }\n             if(!f) return false;\n\n      }\n      if(hpi <= 0) return false;\n      return true;\n}\nint  main()\n{\n     while(~scanf(\"%d %d\", &hpi, &hpm) && hpi+hpm)\n     {\n           scanf(\"%d %d\", &r, &c);\n           for(int i = 0; i < r; i++)\n           {\n                   scanf(\"%s\", str[i]);\n           }\n           scanf(\"%d\", &t);\n           for(int i = 0; i < t; i ++)\n           {\n                   scanf(\"%s %d\", ch, &num);\n                   int tmp = ch[0] - 'A';\n                   sa[tmp] = num;\n           }\n           scanf(\"%d\", &s);\n           for(int i = 0; i < s; i ++)\n           {\n                   scanf(\"%s %d\", p[i].di, &p[i].step);\n           }\n           scanf(\"%d\", &pnum);\n           for(int i = 0; i < pnum; i ++)\n           {\n                  scanf(\"%d\", &po[i]);\n           }\n           sort(po, po+pnum);\n           bool flag= GetAns();\n           if(flag)\n                   printf(\"YES\\n\");\n           else\n                   printf(\"NO\\n\");\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAXN 110\n#define MAXM 1010\n#define FI first\n#define SE second\n#define MP(x,y) make_pair(x,y)\nchar ma[MAXN][MAXN];\nint sd[MAXM],len[MAXM],pot[MAXN];\nint cost[MAXN*2],dp[MAXM*4];\nconst int dis[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\nint main()\n{\n    //freopen(\"/home/moor/Code/input\",\"r\",stdin);\n    int hinit,hmax,ss,sp,st,sr,sc,sum,pre;\n    while(scanf(\"%d%d\",&hinit,&hmax)&&(hinit||hmax))\n    {\n        scanf(\"%d%d\",&sr,&sc);\n        for(int i=0;i<sr;++i)    scanf(\"%s\",ma[i]);\n        scanf(\"%d\",&st);\n        for(int i=0;i<st;++i)\n        {\n            char tmp[10];\n            scanf(\"%s\",tmp);\n            scanf(\"%d\",&cost[tmp[0]]);\n        }\n        scanf(\"%d\",&ss);\n        for(int i=0;i<ss;++i)\n        {\n            char tmp[10];\n            scanf(\"%s%d\",tmp,&len[i]);\n            if(tmp[0]=='U') sd[i]=0;\n            else    if(tmp[0]=='R') sd[i]=1;\n            else    if(tmp[0]=='D') sd[i]=2;\n            else    if(tmp[0]=='L') sd[i]=3;\n        }\n        scanf(\"%d\",&sp);\n        for(int i=0;i<sp;++i)    scanf(\"%d\",&pot[i]);\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >que;\n        memset(dp,-1,sizeof(dp));\n        dp[0]=hinit;\n        que.push(MP(hinit,0));\n        int x=0,y=0;\n        sum=0;\n        for(int i=0;i<ss&&que.size();++i)\n        {\n            while(que.size()&&len[i]--)\n            {\n                x+=dis[sd[i]][0],y+=dis[sd[i]][1];\n                pre=sum,sum+=cost[ma[x][y]];\n                while(dp[que.top().SE]!=que.top().FI)\n                {\n                    pair<int,int> tmp=que.top();\n                    que.pop();\n                    que.push(MP(dp[tmp.SE],tmp.SE));\n                }\n                while(que.size()&&sum>=que.top().FI)\n                {\n                    pair<int,int> tmp=que.top();\n                    que.pop();\n                    for(int i=0;i<sp;++i)\n                        if(((1<<i)&tmp.SE)==0)\n                        {\n                            pair<int,int> tt;\n                            tt=MP(tmp.FI+min(pot[i],hmax-(tmp.FI-pre)),tmp.SE|(1<<i));\n                            if(dp[tt.SE]==-1)   dp[tt.SE]=tt.FI,que.push(tt);\n                            else    dp[tt.SE]=max(dp[tt.SE],tt.FI);\n                        }\n                }\n            }\n        }\n        printf(\"%s\\n\",que.size()?\"YES\":\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<char, int> pci;\nint life, maxi, r, c, t, s, p;\nvector<int> potion;\nmap<char, int> damage;\n \nvoid calcDP(vector<vector<int> > &dp, vector<string> &grid,\n            int nx, int ny, int x, int y, int trun){\n  for (int i = 0; i < (1<<p); i++) {\n    int next_life = dp[i][trun - 1], tmp = next_life;\n    if(next_life == 0)continue;\n    dp[i][trun] = max(dp[i][trun], next_life -\n                      damage[grid[ny][nx]]);\n    for (int j = 0; j < p; j++) {\n      if(i & (1<<j))continue;\n      next_life = min(maxi, next_life + potion[j]);\n      next_life -= damage[grid[ny][nx]];\n      dp[i + (1<<j)][trun] = max(dp[i + (1<<j)][trun],\n                                 next_life);\n      next_life = tmp;\n    }\n  }\n}\n \nint main(){\n  map<char, int> dx, dy;\n  dx['U'] = 0;\n  dx['D'] = 0;\n  dx['R'] = 1;\n  dx['L'] = -1;\n  dy['U'] = -1;\n  dy['D'] = 1;\n  dy['R'] = 0;\n  dy['L'] = 0;\n  while(std::cin >> life >> maxi, life){\n    std::cin >> r >> c;\n    vector<string> grid(r);\n    for (int i = 0; i < r; i++) {\n      std::cin >> grid[i];\n    }\n    std::cin >> t;\n    for (int i = 0; i < t; i++) {\n      char floor;\n      int d;\n      std::cin >> floor >> d;\n      damage[floor] = d;\n    }\n    std::cin >> s;\n    vector<pci> action(s);\n    int sum = 0;\n    for (int i = 0; i < s; i++) {\n      std::cin >> action[i].first >> action[i].second;\n      sum += action[i].second;\n    }\n    std::cin >> p;\n    potion.resize(p);\n    for (int i = 0; i < p; i++) {\n      std::cin >> potion[i];\n    }\n    vector<vector<int> > dp((1<<p), vector<int>(sum + 1, 0));\n    for (int i = 0; i < (1<<p); i++) {\n      dp[i][0] = life;\n      for (int j = 0; j < p; j++) {\n        if((i & (1<<j)) == 0)continue;\n        dp[i][0] = min(maxi, dp[i][0] + potion[j]);\n      }\n    }\n    int x = 0, y = 0;\n    int trun = 0;\n    vector<vector<char> > foot_stanp(r, vector<char>(c, ' '));\n    int a = 0;\n    for(int i = 0; i < s; i++) {\n      for (int j = 0; j < action[i].second; j++) {\n        trun++;\n        foot_stanp[y][x] = '.';\n        int nx = x + dx[action[i].first],\n          ny = y + dy[action[i].first];\n        a += damage[grid[ny][nx]];\n        calcDP(dp, grid, nx, ny, x, y, trun);\n        x = nx, y = ny;\n      }\n    }\n    // for (int i = 0; i < (1<<p); i++) {\n    //   for (int j = 0; j <= sum; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    // for (int i = 0; i < r; i++) {\n    //   for (int j = 0; j < c; j++) {\n    //     std::cout << foot_stanp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    // std::cout << a << std::endl;\n    bool flag = 0;\n    for (int i = 0; i < (1<<p); i++) {\n      if(dp[i][sum] > 0)flag = 1;\n    }\n    if(flag){\n      std::cout << \"YES\" << std::endl;\n    }else{\n      std::cout << \"NO\" << std::endl; \n    }\n    potion.clear();\n    damage.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n\nint dp[MAX][1<<MAX_P];\n\nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n\nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n        \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n        \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n\n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n\n        int rec[1<<MAX_P] = {};\n        for (int i = 0; i < (1<<P); i++) {\n            int r = 0;\n            for (int j = 0; j < P; j++) {\n                if (i >> j & 1) {\n                    r += p[j];\n                }\n            }\n            rec[i] = r;\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n        \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] == -1) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < (1<<P); k++) {\n                    if ((j & k) > 0) continue;                    \n                    dp[i+1][j|k] = max(dp[i+1][j|k], min(dp[i][j] - vec[i] + rec[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 105;\nstruct Node{\n    char di;\n    int step;\n}e[maxn*10];\nchar Map[maxn][maxn];\nint op[13],mark[13];\nint dir[4][2]={1,0,0,1,-1,0,0,-1};\nint judge(char dd){\n    if(dd=='D') return 0;\n    if(dd=='R') return 1;\n    if(dd=='U') return 2;\n    if(dd=='L') return 3;\n}\nint main(){\n    int h_now,h_max;\n    int r,c;\n    while(~scanf(\"%d %d\",&h_now,&h_max)){\n            if(h_now==0 && h_max==0) break;\n        scanf(\"%d %d\",&r,&c);\n        for(int i=0;i<r;i++){\n            scanf(\"%s\",Map[i]);\n        }\n        int t;\n        map<char,int>trap;\n        scanf(\"%d\",&t);\n        while(t--){\n            char a;\n            int c;\n            getchar();\n            scanf(\"%c %d\",&a,&c);\n            trap[a]=c;\n        }\n        int s;\n        scanf(\"%d\",&s);\n        for(int i=0;i<s;i++){\n            getchar();\n            scanf(\"%c %d\",&e[i].di,&e[i].step);\n        }\n        int p;\n        scanf(\"%d\",&p);\n        for(int i=0;i<p;i++){\n            scanf(\"%d\",&op[i]);\n        }\n        sort(op,op+p);\n        int nowx=0,nowy=0;\n        int flag=0;\n       // printf(\"~~~~~\\n\");\n        for(int i=0;i<s;i++){\n            int dire=judge(e[i].di);\n            for(int j=0;j<e[i].step;j++){\n                int ff=0;\n                nowx=nowx+dir[dire][0],nowy=nowy+dir[dire][1];\n                if(h_now<trap[Map[nowx][nowy]]){\n                    for(int k=0;k<p;k++){\n                        if(mark[k]) continue;\n                        int ho=h_now+op[k];\n                        if(ho>h_max){\n                            ho=h_max;\n                        }\n                        if(ho>trap[Map[nowx][nowy]]){\n                            mark[k]=1;\n                            ff=1;\n                            h_now=ho-trap[Map[nowx][nowy]];\n                            break;\n                        }\n                    }\n                }\n                else{\n                    ff=1;\n                    h_now-=trap[Map[nowx][nowy]];\n                }\n                if(!ff){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        if(flag) printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, 1, 0, 0};\nconst int vx[] = {0, 0, -1, 1};\nconst string temp = \"UDLR\";\n\nint main()\n{\n  vector< int > buff[13][1 << 12];\n  for(int k = 1; k < 13; k++) {\n    for(int i = 0; i < 1 << k; i++) {\n      for(int j = 0; j < 1 << k; j++) {\n        if(i & j) continue;\n        buff[k][i].push_back(j);\n      }\n    }\n  }\n\n  int latte, malta, H, W, T, S, P;\n  string A[100];\n  int damage[256], B[1000], C[12];\n\n  while(cin >> latte >> malta, latte) {\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) cin >> A[i];\n    cin >> T;\n    for(int i = 0; i < T; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      damage[c] = d;\n    }\n    cin >> S;\n    int curr = 0;\n    for(int i = 0; i < S; i++) {\n      char c;\n      int d;\n      cin >> c >> d;\n      int dir = (int) temp.find(c);\n      while(d--) B[curr++] = dir;\n    }\n    cin >> P;\n    for(int i = 0; i < P; i++) {\n      cin >> C[i];\n    }\n\n    int yy = 0, xx = 0;\n\n    vector< int > add(1 << P, 0);\n    for(int i = 0; i < 1 << P; i++) {\n      for(int j = 0; j < P; j++) {\n        if((i >> j) & 1) add[i] += C[j];\n      }\n    }\n\n    vector< int > dp(1 << P, -1);\n    dp[0] = latte;\n    for(int i = 0; i < curr; i++) {\n      vector< int > nextdp(1 << P, -1);\n      yy += vy[B[i]], xx += vx[B[i]];\n      for(int j = 0; j < 1 << P; j++) {\n        if(dp[j] <= 0) continue;\n        int beet = dp[j] - damage[A[yy][xx]];\n        if(beet >= 1) {\n          nextdp[j] = max(nextdp[j], beet);\n        } else {\n          for(int k : buff[P][j]) nextdp[j | k] = max(nextdp[j | k], min(malta, beet + add[k]));\n        }\n      }\n      dp.swap(nextdp);\n    }\n    bool beet = false;\n    for(int k : dp) if(k >= 1) beet = true;\n    if(beet) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <complex>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint potion[13];\nint dmg[256];\nint dp[1010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dx[256] = {};\n\tint dy[256] = {};\n\n\trep(i, 4){\n\t\tdx[\"UDRL\"[i]] = vector<int>({ 0, 0, 1, -1 })[i];\n\t\tdy[\"UDRL\"[i]] = vector<int>({ -1, 1, 0, 0 })[i];\n\t}\t\n\n\tint mhp, hp;\n\twhile (cin >> hp >> mhp, hp){\n\t\tint r, c;\n\t\tcin >> r >> c;\n\t\tvector<string> dangeon(r);\n\t\trep(i, r) cin >> dangeon[i];\n\n\t\tint t;\n\t\tcin >> t;\n\t\trep(i, t){\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdmg[c] = d;\n\t\t}\n\n\t\tint x, y;\n\t\tx = y = 0;\n\t\tstring mv;\n\t\tmv += dangeon[y][x];\n\n\t\tint s;\n\t\tcin >> s;\n\t\twhile (s--){\n\t\t\tchar c;\n\t\t\tint k;\n\t\t\tcin >> c >> k;\n\t\t\twhile (k--){\n\t\t\t\tx += dx[c];\n\t\t\t\ty += dy[c];\n\t\t\t\tmv += dangeon[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint p;\n\t\tcin >> p;\n\t\trep(i, p){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tpotion[i] = x;\n\t\t}\n\n\t\tMEMSET(dp, 0);\n\t\tdp[0][0] = hp;\n\n\t\tint sz = mv.size();\n\t\trep(i, sz){\n\t\t\tif(i) rep(j, 1 << p){\n\t\t\t\tdp[i][j] = dp[i-1][j] - dmg[mv[i]];\n\t\t\t}\n\t\t\trep(j, 1 << p){\n\t\t\t\trep(k, p){\n\t\t\t\t\tint x = 1 << k;\n\t\t\t\t\tif (~j&x) continue;\n\t\t\t\t\tif (dp[i][j&~x] <= 0) continue;\n\t\t\t\t\tdp[i][j] = max(dp[i][j], min(mhp, dp[i][j&~x] + potion[k]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//rep(j, 1 << p){\n\t\t\t//\tbitset<2> b(j);\n\t\t\t//\tcout << b.to_string() << ' ' << dp[i][j] << endl;\n\t\t\t//}\n\t\t}\n\t\tbool b = *max_element(dp[sz - 1], dp[sz - 1] + (1 << p)) >= 1;\n\t\tcout << (b ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\nconst ll INF = 1LL << 60;\n\ntemplate <typename Tp>\nvoid chmax(Tp &A, Tp B) { A = max(A, B); }\n\ntemplate <typename Tp>\nvoid chmin(Tp &A, Tp B) { A = min(A, B); }\n\nll rec[1010][1 << 12][2];\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nconst string pat = \"UDRL\";\n\nint solve_testcase() {\n  ll HP_init, HP_max; cin >> HP_init >> HP_max;\n  if(HP_init == 0 and HP_max == 0) return 1;\n\n  int H, W; cin >> H >> W;\n  vector<string> board(H);\n  for(int i=0; i<H; i++) cin >> board[i];\n\n  int T; cin >> T;\n  vector<ll> damage(26);\n  for(int i=0; i<T; i++) {\n    char c; cin >> c;\n    ll d; cin >> d;\n    chmax(damage[c - 'A'], d);\n  }\n\n  int S; cin >> S;\n  int N = 0;\n  vector<int> op;\n  for(int i=0; i<S; i++) {\n    char c; cin >> c;\n    int n; cin >> n;\n    N += n;\n    int id = pat.find(c);\n    for(int j=0; j<n; j++) op.emplace_back(id); \n  }\n\n  int P; cin >> P;\n  vector<ll> p(P);\n  for(int i=0; i<P; i++) cin >> p[i];\n\n  fill(rec[0][0], rec[N+1][0], -INF);\n  rec[0][0][0] = HP_init;\n\n  // init\n  for(int bit=0; bit<(1<<P); bit++) {\n    for(int i=0; i<P; i++) {\n      if(bit >> i & 1) continue;\n      int nbit = bit | (1 << i);\n      chmax(rec[0][nbit][0], min(rec[0][bit][0] + p[i], HP_max));\n    }\n  }\n\n  int x = 0, y = 0;\n  for(int i=0; i<N; i++) {\n    // move\n    x += dx[ op[i] ], y += dy[ op[i] ];\n    ll dam = damage[ board[x][y] - 'A' ];\n    for(int bit=0; bit<(1<<P); bit++) {\n      // 0 -> 1\n      {\n        chmax(rec[i][bit][1], min(HP_max - dam, rec[i][bit][0] - dam));\n      }\n      // 1 -> 1\n      {\n        for(int k=0; k<P; k++) {\n          if(bit >> k & 1) continue;\n          int nbit = bit | (1 << k);\n          chmax(rec[i][nbit][1], min(HP_max - dam, rec[i][bit][1] + p[k]));\n        }\n      }\n      // 1 -> next 0\n      if(rec[i][bit][1] > 0) {\n        chmax(rec[i+1][bit][0], rec[i][bit][1]);\n      }\n      // fprintf(stderr, \"rec[%d][%d][%d] = %lld\\n\", i, bit, 0, rec[i][bit][0]);\n      // fprintf(stderr, \"rec[%d][%d][%d] = %lld\\n\", i, bit, 1, rec[i][bit][1]);\n    }\n  }\n\n  bool ok = false;\n  for(int bit=0; bit<(1<<P); bit++) {\n    ok |= (rec[N][bit][0] > 0);\n    ok |= (rec[N][bit][1] > 0);\n  }\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n\nint main() {\n  while(!solve_testcase());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint init, MAX;\nint R, C;\nbool dp[1010][1 << 13];\nint num[1010][1 << 13];\nchar a[110][110];\nint num[300];\nint tot, S, P;\nint sum[1010];\nint nump, p[20], ok[1 << 13];\nint x[1010], y[1010];\n\nvoid pre() {\n\tmemset(ok, 0, sizeof(ok));\n\tfor(int i = 0; i < nump; i++) {\n\t\tok[1 << i] = p[i];\n\t}\n\tfor(int i = 1; i < (1 << nump); i++) {\n\t\tok[i] = ok[i & (-i)] + ok[i - (i & (-i))];\n\t}\n}\n\nbool solve() {\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(num, 0, sizeof(num));\n\tdp[0][(1 << nump) - 1] = 1;\n\tnum[0][(1 << nump) - 1] = init;\n\tfor(int i = 0; i < tot; i++) {\n\t\tfor(int j = 0; j < (1 << nump); j++) {\n\t\t\tif(dp[i][j] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint tt = num[i][j];\n\t\t\ttt = min(tt, MAX);\n\t\t\tfor(int k = j; k; k = (k-1) & j) {\n\t\t\t\tif(tt + ok[k] - num[a[x[i+1]][y[i+1]]] > 0) {\n\t\t\t\t\tdp[i + 1][j ^ k] = 1;\n\t\t\t\t\tnum[i + 1][j ^ k] = min(tt + ok[k] - num[a[x[i+1]][y[i+1]]], MAX);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tt - num[a[x[i+1]][y[i+1]]] > 0) {\n\t\t\t\tdp[i + 1][j] = 1;\n\t\t\t\tnum[i + 1][j] = min(tt + ok[k] - num[a[x[i+1]][y[i+1]]], MAX);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < (1 << nump); i++) {\n\t\tif(dp[tot][i] == 1) {\n//\t\t\tcout << \"fuck\" << endl;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(~scanf(\"%d%d\", &init, &MAX)) {\n\t\tif(init == 0 && MAX == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d%d\", &R, &C);\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tscanf(\"%s\", a[i]);\n\t\t}\n\t\tint T;\n\t\tscanf(\"%d\", &T);\n\t\tfor(int i = 0; i < T; i++) {\n\t\t\tchar tmp[5];\n\t\t\tint id;\n\t\t\tscanf(\"%s%d\", tmp, &id);\n\t\t\tnum[tmp[0]] = id;\n\t\t}\n\t\tscanf(\"%d\", &S);\n\t\ttot = 0;\n\t\tint tx = 0, ty = 0, inc = 0;\n\t\tx[0] = 0; y[0] = 0; sum[0] = 0;\n\t\tfor(int i = 1; i <= S; i++) {\n\t\t\tchar tmp[5];\n\t\t\tint id;\n\t\t\tscanf(\"%s%d\", tmp, &id);\n\t\t\twhile(id--) {\n\t\t\t\tif(tmp[0] == 'U') {\n\t\t\t\t\ttx--;\n\t\t\t\t} else if(tmp[0] == 'D') {\n\t\t\t\t\ttx++;\n\t\t\t\t} else if(tmp[0] == 'L') {\n\t\t\t\t\tty--;\n\t\t\t\t} else if(tmp[0] == 'R') {\n\t\t\t\t\tty++;\n\t\t\t\t}\n\t\t\t\t++tot;\n\t\t\t\tx[tot] = tx; y[tot] = ty;\n\t\t\t\tsum[tot] = sum[tot - 1] + num[a[tx][ty]];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= tot; i++) {\n//\t\t\tcout << sum[i] << endl;\n\t\t}\n\t\tscanf(\"%d\", &nump);\n\t\tfor(int i = 0; i < nump; i++) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tpre();\n\t\tfor(int i = 0; i < (1 << nump); i++) {\n\t\t//\tcout << i << \" \" << ok[i] << endl;\n\t\t}\n\t\tif(solve()) {\n\t\t\tputs(\"YES\");\n\t\t}else {\n\t\t\tputs(\"NO\");\n\t\t}\n\t\tfor(int i = 0; i <= tot; i++) {\n\t\t\tfor(int j = 0; j < (1 << nump); j++) {\n//\t\t\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n/*\nint st;\n\tst = 9;\n\tfor (int mask = st ; mask ; mask = st & (mask - 1)) {\n\t\tprintf(\"%d\\n\",mask);\n\t}*/\nvector<int>son[1 << 12];\nint hp, mhp;\nint n, m;\nchar stp[1100][3];\nint step[1100];\nchar mz[110][113];\nint dam[110][113];\nint dic[444];\nint p;\nint mp;\nint ad[33];\nint dp[1100][1 << 12];\nint gx[4] = {0, 0, 1, -1};\nint gy[4] = {1, -1, 0, 0};\nint cnm(char c)\n{\n    if ( c == 'U' ) return 3;\n    if ( c == 'D' ) return 2;\n    if ( c == 'L' ) return 1;\n    if ( c == 'R' ) return 0;\n    return 0;\n}\nint bak[11000];\nint gao( int c )\n{\n    //if ( c == 0 ) printf(\"$$$$$$$$$$$$$$$ %d\\n\",bak[c]);\n    if ( bak[c] != -1 ) return bak[c];\n    int sum = 0, pc = c;\n    for ( int i = 0; i < mp; i ++ )\n    {\n        if ( c & 1 ) sum += ad[i];\n        c >>= 1;\n    }\n    bak[pc] = sum;\n    return sum;\n}\nint main()\n{\n    for ( int st = 0; st < 4096; st ++ )\n    {\n        for (int mask = st ; mask ; mask = st & (mask - 1))\n        {\n            son[st].push_back(mask);\n        }\n        son[st].push_back(0);\n    }\n    while ( ~scanf(\"%d%d\", &hp, &mhp) )\n    {\n        if ( hp == 0 && mhp == 0 ) break;\n        memset(bak, -1, sizeof(bak));\n        cin >> n >> m;\n        for ( int i = 0; i < n; i ++ ) scanf(\"%s\", mz[i]);\n        memset( dic, 0, sizeof(dic));\n        int tmp;\n        cin >> tmp;\n        while ( tmp -- )\n        {\n            char ts[10];\n            int tx;\n            scanf(\"%s%d\", ts, &tx);\n            dic[(int)ts[0]] = tx;\n        }\n        //puts(\"--\");\n        for ( int i = 0; i < n; i ++ )\n        {\n            for ( int j = 0; j < m; j ++ )\n            {\n                dam[i][j] = dic[(int)mz[i][j]];\n            }\n        }\n        cin >> p;\n        for ( int i = 0; i < p; i ++ )\n        {\n            scanf(\"%s%d\", stp[i], &step[i]);\n        }\n        cin >> mp;\n        for ( int i = 0; i < mp; i ++ ) scanf(\"%d\", &ad[i]);\n        int bj = (1 << mp) - 1;\n        memset(dp, 0, sizeof(dp));\n        dp[0][bj] = hp;\n        int x = 0, y = 0, sum = 0;\n        //printf(\"***%d\\n\",gao(0));\n        for ( int i = 0; i < p; i ++ )\n        {\n            int dr = cnm(stp[i][0]);\n\n            for ( int j = 0; j < step[i]; j ++ )\n            {\n                x += gx[dr], y += gy[dr];\n                for ( int st = 0; st <= bj; st ++ )\n                {\n                    //puts(\"**\");\n                    if ( dp[sum][st] <= 0 ) continue;\n                    if ( gao(st) + dp[sum][st] <= mhp )\n                    {\n                        if ( dp[sum][st] + bak[st] > dam[x][y] )\n                        dp[sum + 1][0] = max(dp[sum + 1][0], dp[sum][st] + bak[st] - dam[x][y]);\n                        continue;\n                    }\n                    if ( bak[st] + dp[sum][st] <= dam[x][y] ) continue;\n                    for ( int k = 0; k < son[st].size(); k ++ )\n                    {\n                        int mask = son[st][k];\n                        int addup = gao(mask);\n                        int nhp = min(dp[sum][st] + addup, mhp) - dam[x][y];\n                        if ( nhp > 0 ) dp[sum + 1][st ^ mask] = max(dp[sum + 1][st ^ mask], nhp);\n                    }\n                }\n                sum ++;\n            }\n        }\n        bool fg = false;\n        for ( int i = 0; i <= bj; i ++ )\n        {\n            if ( dp[sum][i] > 0 )\n            {\n                //printf(\"$%d\\n\", dp[sum][i]);\n                fg = true;\n                break;\n            }\n        }\n        puts(fg ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n/*\n1234\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint damage[26];\nint step[1010];\nchar ba[100][100];\n\nint dp[2][1<<12];                   // dp[i][j] = 集合jのポーションを使ったときの体力の最大\n\nint main() {\n  int HPini, HPmax;\n  while(cin>>HPini>>HPmax,HPini||HPmax) {\n    int r,c;\n    cin >> r >> c;\n    REP(i,r) REP(j,c) cin>>ba[i][j];\n    int t;cin >> t;\n    REP(i,t) {\n      char c; int m;\n      cin >> c >> m;\n      damage[c-'A'] = m;\n    }\n    int s; cin >> s;\n    int num = 1;\n    step[0] = damage[ba[0][0]-'A'];\n    int y=0, x=0;\n    const int dx[] = {0,1,0,-1};\n    const int dy[] = {-1,0,1,0};\n    REP(i,s) {\n      char c; int m;\n      cin >> c >> m;\n      int d = 0;\n      if (c=='D') d=2;\n      else if (c=='L') d=3;\n      else if (c=='R') d=1;\n      REP(i,m) {\n        y += dy[d];\n        x += dx[d];\n        step[num++] = damage[ba[y][x]-'A'];\n      }\n    }\n    int P; cin >> P;\n    int p[P];\n    REP(i,P) cin >> p[i];\n\n    memset(dp,0,sizeof(dp));\n    dp[0][0] = HPini;\n    REP(i,num) {\n      //cout << step[i] << endl;\n      REP(S,1<<P) dp[(i+1)%2][S] = 0;\n      REP(S,1<<P) {\n        if (dp[i%2][S] == 0) continue; // 死んでる\n        // ポーションを使わない\n        dp[(i+1)%2][S] = max(dp[(i+1)%2][S], dp[i%2][S]-step[i]);\n        // ポーションを使う\n        REP(j,P) {\n          if (S>>j&1) continue;\n          dp[(i+1)%2][S|1<<j] = max(dp[(i+1)%2][S|1<<j], min(HPmax, dp[i%2][S]+p[j])-step[i]);\n        }\n      }\n    }\n    bool ans = 0;\n    REP(S,1<<P)\n      if (dp[num%2][S] > 0) {\n        ans = 1;\n        //cout << bitset<5>(S) << endl;\n      }\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\nstruct E {\n\tint p, h;\n};\nint main(){\n\twhile (true) {\n\t\tint hp_init, hp_max; std::cin >> hp_init >> hp_max; if (hp_init == 0 && hp_max == 0) break;\n\t\tint row, column; std::cin >> row >> column;\n\t\tstd::vector<std::string> state(row); for (auto& line : state) std::cin >> line;\n\t\tint t; std::cin >> t;\n\t\tstd::unordered_map<char, int> damage;\n\t\tfor (auto i = 0; i < t; ++i) {\n\t\t\tchar c; int d; std::cin >> c >> d;\n\t\t\tdamage[c] = d;\n\t\t}\n\t\tint s; std::cin >> s;\n\t\tstd::vector<std::pair<char, int>> order(s); for (auto& o : order) std::cin >> o.first >> o.second;\n\t\tstd::vector<std::pair<int, int>> position{ std::make_pair(0, 0) };\n\t\tfor (const auto o : order) {\n\t\t\tfor (auto i = 0; i < o.second; ++i) {\n\t\t\t\tconst auto last = position.back();\n\t\t\t\tswitch (o.first) {\n\t\t\t\tcase 'U': position.emplace_back(last.first - 1, last.second); break;\n\t\t\t\tcase 'D': position.emplace_back(last.first + 1, last.second); break;\n\t\t\t\tcase 'R': position.emplace_back(last.first, last.second + 1); break;\n\t\t\t\tcase 'L': position.emplace_back(last.first, last.second - 1); break;\n\t\t\t\tdefault: throw 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p; std::cin >> p;\n\t\tstd::vector<int> potion(p); for (auto& pi : potion) std::cin >> pi;\n\t\tstd::vector<std::vector<int>> max_hp(2, std::vector<int>(1 << p, 0));\n\t\tstd::deque<E> queue;\n\t\tmax_hp[0][0] = hp_init; queue.push_back(E{ 0, hp_init });\n\t\tfor (auto i = 0; i < position.size(); ++i) {\n\t\t\tconst auto pos = position[i];\n\t\t\tconst auto prev = i & 1;\n\t\t\tconst auto current = prev ^ 1;\n\t\t\tstd::fill(max_hp[current].begin(), max_hp[current].end(), 0);\n\t\t\tfor (int count = queue.size(); count > 0; --count) {\n\t\t\t\tconst auto top = queue.front(); queue.pop_front();\n\t\t\t\tif (max_hp[prev][top.p] != top.h) continue;\n\t\t\t\tif (max_hp[prev][top.p] <= damage[state[pos.first][pos.second]]) {\n\t\t\t\t\tfor (auto j = 0; j < p; ++j) if ((top.p & (1 << j)) == 0) {\n\t\t\t\t\t\tif (max_hp[prev][top.p | (1 << j)] < std::min(hp_max, top.h + potion[j])) {\n\t\t\t\t\t\t\tqueue.push_front(E{ top.p | (1 << j), std::min(hp_max, top.h + potion[j]) });\n\t\t\t\t\t\t\tmax_hp[prev][top.p | (1 << j)] = std::min(hp_max, top.h + potion[j]);\n\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (max_hp[current][top.p] < top.h - damage[state[pos.first][pos.second]]) {\n\t\t\t\t\t\tif (max_hp[current][top.p] == 0) queue.push_back(E{ top.p, top.h - damage[state[pos.first][pos.second]] });\n\t\t\t\t\t\tmax_hp[current][top.p] = top.h - damage[state[pos.first][pos.second]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (std::all_of(max_hp[position.size() & 1].begin(), max_hp[position.size() & 1].end(), [](int i) {return i == 0; })) {\n\t\t\tstd::cout << \"NO\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"YES\\n\";\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * C.cpp\n *\n *  Created on: 2010/11/28\n *      Author: Computer Club\n */\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nclass State\n{\npublic:\n\tint x,y,c,h,l;\n\tState(int x, int y, int c, int h, int l)\n\t:x(x),y(y),c(c),h(h),l(l)\n\t {}\n\n\tbool operator<(const State& s) const\n\t\t\t{\n\t\t\t\treturn c>s.c;\n\t\t\t}\n};\n\nbool v[10050][1<<12];\n\nint main()\n{\n\t//ifstream cin(\"C.txt\");\n\tint Hmi,Hma,R,C;\n\twhile(cin >> Hmi >> Hma, (Hmi||Hma))\n\t{\n\t\tint dmg[100]={0};\n\t\tint heal[100]={0};\n\n\t\tstring f[200];\n\t\tcin >> R >> C;\n\n\t\tfor(int i=0; i<R; i++)\n\t\t{\n\t\t\tcin >> f[i];\n\t\t}\n\n\t\tint L;\n\t\tcin >> L;\n\t\tfor(int i=0; i<L; i++)\n\t\t{\n\t\t\tstring c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdmg[c[0]-'A']=d;\n\t\t}\n\n\t\tint Dir[10500];\n\t\tint num[10500];\n\n\t\tint M,X=0;\n\t\tcin >> M;\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint t;\n\t\t\tstring d;\n\t\t\tcin >> d >> num[i];\n\t\t\tif(d[0]=='U')\n\t\t\t{\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tif(d[0]=='D')\n\t\t\t{\n\t\t\t\tt=1;\n\t\t\t}\n\t\t\tif(d[0]=='L')\n\t\t\t{\n\t\t\t\tt=2;\n\t\t\t}\n\t\t\tif(d[0]=='R')\n\t\t\t{\n\t\t\t\tt=3;\n\t\t\t}\n\n\t\t\tfor(int j=0; j<num[i]; j++)\n\t\t\t\tDir[X++]=t;\n\t\t}\n\n\t\tint H;\n\t\tcin >> H;\n\t\tfor(int i=0; i<H; i++)\n\t\t{\n\t\t\tcin >> heal[i];\n\t\t}\n\n\t\tmemset(v,0,sizeof(v));\n\n\n\t\tbool ok=false;\n\t\tpriority_queue<State> q;\n\t\tq.push(State(0,0,0,0,Hmi));\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.top(); q.pop();\n\t\t\tif(v[s.c][s.h]) continue;\n\t\t\tv[s.c][s.h]=1;\n\n\t\t\tif(s.c==X)\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<H; i++)\n\t\t\t{\n\t\t\t\tif(s.h&(1<<i)) continue;\n\t\t\t\tint tsh=(s.h|(1<<i)),tl=s.l+heal[i];\n\t\t\t\tif(tl>Hma) tl=Hma;\n\n\n\t\t\t\t//cout << s.x << \" \" << s.y << \" \" << s.c << \" \" << tsh << endl;\n\t\t\t\tif(v[s.c][tsh]) continue;\n\t\t\t\t//v[s.c][tsh]=1;\n\n\t\t\t\t//cout << s.x << \" \" << s.y << \" \" << s.c << \" \" << tsh << endl;\n\t\t\t\t//cout << endl;\n\t\t\t\tq.push(State(s.x,s.y,s.c,tsh,tl));\n\t\t\t}\n\n\t\t\tbool g=true;\n\t\t\tint tx=s.x, ty=s.y,tl=s.l;\n\n\t\t\ttx+=dx[Dir[s.c]]; ty+=dy[Dir[s.c]];\n\n\n\t\t\tif(tx<0||ty<0||tx>=C||ty>=R)\n\t\t\t{\n\t\t\t\tif(tx<0) tx=0;\n\t\t\t\tif(ty<0) ty=0;\n\t\t\t\tif(tx>=C) tx=C;\n\t\t\t\tif(ty>=R) ty=R;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\ttl-=dmg[f[ty][tx]-'A'];\n\t\t\t\tif(tl<=0) continue;\n\n\t\t\t}\n\n\t\t\tif(v[s.c+1][s.h]) continue;\n\n\n\t\t\t//cout << tx << \" \" << ty << \" \" << tl << \" \" << s.h << endl;\n\t\t\tq.push(State(tx,ty,s.c+1,s.h,tl));\n\n\t\t}\n\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n\nusing namespace std;\n\n\n//typedef long long ll;\nint dy[201];\nint dx[201];\nint dp[2][1<<12];\nchar field[101][101];\nint dmg[201];\nint stepDmg[2001];\nint portions[101];\nint inithp;\nint maxhp;\nint r,c;\nint step;\nint S,P,T;\n\nconst int INF=1000000000LL;\n\nvoid input(){\n\tcin>>r>>c;\n\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>field[i][j];\n\tcin>>T;\n\tfor(int i=0;i<T;i++){\n\t\tchar ch;\n\t\tint m;\n\t\tcin>>ch>>m;\n\t\tdmg[ch]=m;\n\t}\n\tcin>>S;\n\tint cx=0;\n\tint cy=0;\n\tfor(int i=0;i<S;i++){\n\t\tchar ch;\n\t\tint quan;\n\t\tcin>>ch>>quan;\n\t\tfor(int j=0;j<quan;j++){\n\t\t\tint ny=cy+dy[ch];\n\t\t\tint nx=cx+dx[ch];\n\t\t\tstepDmg[step]=dmg[field[ny][nx]];\n\t\t\tstep++;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t}\n\t}\n\tcin>>P;\n\tfor(int i=0;i<P;i++)cin>>portions[i];\n}\n\nint main(){\n\tdy['U']=-1;\n\tdx['U']=0;\n\tdy['R']=0;\n\tdx['R']=1;\n\tdy['D']=1;\n\tdx['D']=0;\n\tdy['L']=0;\n\tdx['L']=-1;\n\twhile(cin>>inithp>>maxhp&&(inithp|maxhp)){\n\t\tstep=0;\n\t\tinput();\n\t\t// startn_ÅÍ,cÁ½¨ð·×Äg¤\n\t\tfor(int j=0;j<(1<<P);j++){\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<P;i++)if(!((j>>i)&1))sum+=portions[i];\n\t\t\tdp[0][j]=min(maxhp,sum+inithp);\n\t\t}\n\t\tfor(int i=0;i<step;i++){\n\t\t\tint nxt=(i+1)%2;\n\t\t\tint cur=i%2;\n\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\tint res=-INF;\n\t\t\t\tint s=j;\n\t\t\t\tint pos=i;\n\t\t\t\t// Ü¾gpµÄ¢È¢portionðgp\n\t\t\t\tfor(int k=0;k<P;k++)\n\t\t\t\t\tif(!((s>>k)&1))\n\t\t\t\t\t\tres=max(res,min(dp[nxt][s|(1<<k)]+portions[k],maxhp));\n\t\t\t\t// ÌêÖ\n\t\t\t\tres=max(res,dp[cur][s]-stepDmg[pos]);\n\t\t\t\tif(res<=0)res=-INF;\n\t\t\t\tdp[nxt][s]=min(maxhp,res);\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int j=0;j<(1<<P);j++)if(dp[step%2][j]>0)ok=true;\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tconstexpr int dx[] = {-1, 0, 1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tint dir[128];\n\tdir['L'] = 0;\n\tdir['D'] = 1;\n\tdir['R'] = 2;\n\tdir['U'] = 3;\n\t\n\tfor(int HP_init, HP_max; cin >> HP_init >> HP_max && HP_init;) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) cin >> e;\n\n\t\tint t;\n\t\tcin >> t;\n\n\t\tint damage[128] = {};\n\t\tfor(int i = 0; i < t; ++i) {\n\t\t\tchar c;\n\t\t\tint d;\n\t\t\tcin >> c >> d;\n\t\t\tdamage[c] = d;\n\t\t}\n\n\t\tint s;\n\t\tcin >> s;\n\n\t\tvector<pair<int, int>> moves;\n\t\tvector<pair<int, int>> pos{{0, 0}};\n\n\t\tmoves.reserve(s);\n\t\tpos.reserve(s + 1);\n\n\t\tfor(int i = 0; i < s; ++i) {\n\t\t\tchar c;\n\t\t\tint n;\n\t\t\tcin >> c >> n;\n\n\t\t\tconst int d = dir[c];\n\t\t\tconst int x = pos.back().first + dx[d] * n;\n\t\t\tconst int y = pos.back().second + dy[d] * n;\n\t\t\tmoves.emplace_back(d, n);\n\t\t\tpos.emplace_back(x, y);\n\t\t}\n\n\t\tint p;\n\t\tcin >> p;\n\n\t\tvector<int> potions(p);\n\t\tfor(auto &e : potions) cin >> e;\n\n\t\tvector<vector<int>> dp(s + 1, vector<int>(1 << p, 0));\n\t\tdp[0][0] = HP_init;\n\n\t\tfor(int i = 0; i < s; ++i) {\n\t\t\tconst int d = moves[i].first;\n\t\t\tconst int n = moves[i].second;\n\t\t\tconst int x = pos[i].first;\n\t\t\tconst int y = pos[i].second;\n\n\t\t\tint dec = 0;\n\t\t\tint cx = x, cy = y;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tcx += dx[d];\n\t\t\t\tcy += dy[d];\n\t\t\t\tdec += damage[field[cy][cx]];\n\t\t\t}\n\n\t\t\tfor(int used = 0; used < (1 << p); ++used) {\n\t\t\t\tif(dp[i][used] == 0) continue;\n\n\t\t\t\tchmin(dp[i][used], HP_max);\n\t\t\t\tfor(int j = 0; j < p; ++j) {\n\t\t\t\t\tif(!(used & (1 << j))) {\n\t\t\t\t\t\tchmax(dp[i][used | (1 << j)], dp[i][used] + potions[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchmax(dp[i + 1][used], dp[i][used] - dec);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dp[s][(1 << p) - 1] > 0 ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Hp,Hpmax;\nint R,C;\nint T;\nchar fie[111][111];\nint D[256];\nint S;\nint M[1001];\nint P;\nint p[13];\n\nint dm[256];\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nint dp[1001][(1<<12)];\n\nint main(){\n  string s = \"UDLR\";\n  for(int i=0;i<4;i++) dm[(int)s[i]] = i;\n  while( cin >> Hp >> Hpmax && (Hp||Hpmax) ){\n    cin >> R >> C;\n    for(int i=0;i<R;i++)\n      for(int j=0;j<C;j++)\n\tcin >> fie[j][i];\n\n    memset(D,0,sizeof(D));\n    memset(dp,0,sizeof(dp));\n\n    cin >> T;\n    for(int i=0;i<T;i++){\n      char c;\n      int d;\n      cin >> c >> d;\n      D[(int)c] = d;\n    }\n    cin >> S;\n    int cnt = 0;\n    int x = 0, y = 0;\n    for(int i=0;i<S;i++){\n      char c;int n;\n      cin >> c >> n;\n      for(int j=cnt;j<cnt+n;j++){\n\tx += dx[dm[(int)c]]; y += dy[dm[(int)c]];\n\tM[j] = D[(int)fie[x][y]];\t\n\t//\tcout << x << \" \"<< y << \" \"<< M[j] << endl;\n      }\n      cnt += n;\n    }\n    cin >> P;\n    for(int i=0;i<P;i++) cin >> p[i];\n   \n\n    dp[0][0] = Hp;\n    for(int i=0;i<cnt;i++){\n      for(int j=0;j<(1<<P);j++){\n\tif( dp[i][j] == 0 ) continue;\n\t//\tcout << i << \" \"<< bitset<12>(j) << \" \"<< dp[i][j] << endl;\n\tint hp = dp[i][j];\n\tif( hp - M[i] < 0 ){\n\t  for(int k=0;k<P;k++){\n\t    if( ( j & (1<<k) ) ) continue;\n\t    int nhp = min( hp + p[k] , Hpmax ) - M[i];\n\t    if( nhp <= 0 ) continue;\n\t    dp[i+1][j|(1<<k)] = max( dp[i+1][j|(1<<k)], nhp );\n\t  }\n\t} else {\n\t  dp[i+1][j] = max( dp[i+1][j], hp - M[i] );\n\t}\n      }\n    }\n\n    bool f = false;\n    for(int i=0;i<(1<<P);i++) if( dp[cnt][i] ) f = true;\n    cout << (f?\"YES\":\"NO\") << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n/*\nint st;\n\tst = 9;\n\tfor (int mask = st ; mask ; mask = st & (mask - 1)) {\n\t\tprintf(\"%d\\n\",mask);\n\t}*/\nint hp, mhp;\nint n, m;\nchar stp[1100][3];\nint step[1100];\nchar mz[110][113];\nint dam[110][113];\nint dic[444];\nint p;\nint mp;\nint ad[33];\nint dp[1100][1 << 12];\nint gx[4] = {0, 0, 1, -1};\nint gy[4] = {1, -1, 0, 0};\nint cnm(char c)\n{\n    if ( c == 'U' ) return 3;\n    if ( c == 'D' ) return 2;\n    if ( c == 'L' ) return 1;\n    if ( c == 'R' ) return 0;\n    return 0;\n}\nint gao( int c )\n{\n    int sum = 0;\n    for ( int i = 0; i < mp; i ++ )\n    {\n        if ( c & 1 ) sum += ad[i];\n        c >>= 1;\n    }\n    return sum;\n}\nint main()\n{\n    while ( scanf(\"%d%d\", &hp, &mhp) )\n    {\n        if ( hp == 0 && mhp == 0 ) break;\n        cin >> n >> m;\n        for ( int i = 0; i < n; i ++ ) scanf(\"%s\", mz[i]);\n        memset( dic, 0, sizeof(dic));\n        int tmp;\n        cin >> tmp;\n        while ( tmp -- )\n        {\n            char ts[10];\n            int tx;\n            scanf(\"%s%d\", ts, &tx);\n            dic[(int)ts[0]] = tx;\n        }\n        //puts(\"--\");\n        for ( int i = 0; i < n; i ++ )\n        {\n            for ( int j = 0; j < m; j ++ )\n            {\n                dam[i][j] = dic[(int)mz[i][j]];\n            }\n        }\n        cin >> p;\n        for ( int i = 0; i < p; i ++ )\n        {\n            scanf(\"%s%d\", stp[i], &step[i]);\n        }\n        cin >> mp;\n        for ( int i = 0; i < mp; i ++ ) scanf(\"%d\", &ad[i]);\n        int bj = (1 << mp) - 1;\n        memset(dp, 0, sizeof(dp));\n        dp[0][bj] = hp;\n        int x = 0, y = 0, sum = 0;\n        for ( int i = 0; i < p; i ++ )\n        {\n            int dr = cnm(stp[i][0]);\n\n            for ( int j = 0; j < step[i]; j ++ )\n            {\n                x += gx[dr], y += gy[dr];\n                for ( int st = 0; st <= bj; st ++ )\n                {\n                    //puts(\"**\");\n                    if ( dp[sum][st] <= 0 ) continue;\n\n                    if ( dp[sum][st] > dam[x][y] )\n                    {\n                        dp[sum + 1][st] = max(dp[sum + 1][st], dp[sum][st] - dam[x][y]);\n                        //printf(\"~(%d %d %d) - >%d %d %d %d %d %d\\n\", sum,st,dp[sum][st],sum+1,st,dp[sum+1][st],x,y,dam[x][y]);\n                    }\n                    for (int mask = st ; mask ; mask = st & (mask - 1)) {\n                        //printf(\"%d\\n\",mask);\n                        int addup = gao(mask);\n                        //printf(\"~~%d %d\\n\", nx, ny);\n                        int nhp = min(dp[sum][st] + addup, mhp) - dam[x][y];\n                        if ( nhp > 0 ) dp[sum + 1][st ^ mask] = max(dp[sum + 1][st ^ mask], nhp);\n                        //printf(\"~!%d %d %d\\n\", sum+1,st^mask,dp[sum+1][st^mask]);\n                    }\n                }\n                sum ++;\n            }\n        }\n        bool fg = false;\n        for ( int i = 0; i <= bj; i ++ )\n        {\n            if ( dp[sum][i] > 0 )\n            {\n                //printf(\"$%d\\n\", dp[sum][i]);\n                fg = true;\n                break;\n            }\n        }\n        puts(fg ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n/*\n1234\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct node\n{\n\tint st,hp,len;\n\tnode(){}\n\tnode(int st,int hp,int len) :\n\t\tst(st),hp(hp),len(len) {}\n};\n\nint n,m,ind;\nint HP_init,HP_mx;\nchar adj[205][205];\nint T,hurt[30];\nint S,route[1205];\nint P,pi[20];\nint dp[(1<<12)+10][1005];\nbool vis[ (1<<12)+10 ][1005];\n\nint dx(char chr)\n{\n\tif(chr=='D') return 1;\n\tif(chr=='U') return -1;\n\tif(chr=='L') return 0;\n\treturn 0;\n}\nint dy(char chr)\n{\n\tif(chr=='D') return 0;\n\tif(chr=='U') return 0;\n\tif(chr=='L') return -1;\n\treturn 1;\n}\nint fun(int x,int y)\n{\n\treturn hurt[ adj[x][y]-'A' ];\n}\nvoid getNxt(int hp,int len,int &hp_nxt,int &len_nxt)\n{\n\tint lft=len,rht=ind;\n\twhile(lft<=rht)\n\t{\n\t\tint mid=(lft+rht)>>1;\n\n\t\tint sum=route[mid]-route[len];\n\t\tif(sum<hp) lft=mid+1,len_nxt=mid,hp_nxt=hp-sum;\n\t\telse rht=mid-1;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"C.in\",\"r\",stdin);\n\n\twhile(scanf(\"%d%d\",&HP_init,&HP_mx)!=EOF)\n\t{\n\t\tif(HP_init==0&&HP_mx==0) break;\n\n\t\tind=1;\n\t\tmemset(hurt,0,sizeof(hurt));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(route,0,sizeof(route));\n\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=0;i<n;i++) scanf(\"%s\",adj[i]);\n\n\t\tscanf(\"%d\",&T);\n\t\tfor(int i=0;i<T;i++)\n\t\t{\n\t\t\tchar str[10]; int tmp;\n\t\t\tscanf(\"%s%d\",str,&tmp);\n\t\t\thurt[ str[0]-'A' ]=tmp;\n\t\t}\n\n\t\t//for(int i=0;i<30;i++) cout<<hurt[i]<<\" \";cout<<endl;\n\n\t\tscanf(\"%d\",&S);\n\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<S;i++)\n\t\t{\n\t\t\tchar str[10]; int tmp;\n\t\t\tscanf(\"%s%d\",str,&tmp);\n\t\t\tfor(int j=0;j<tmp;j++)\n\t\t\t{\n\t\t\t\tx+=dx(str[0]);\n\t\t\t\ty+=dy(str[0]);\n\t\t\t\troute[++ind]+=fun(x,y);\n\t\t\t//\tcout<<str[0]<<\" x=\"<<x<<\" y=\"<<y<<\" fun=\"<<fun(x,y)<<endl;\n\t\t\t\troute[ind]+=route[ind-1];\n\t\t\t}\n\t\t}\n\n\t\t//for(int i=1;i<=ind;i++) cout<<route[i]<<\" \";cout<<endl;\n\n\t\tscanf(\"%d\",&P);\n\t\tfor(int i=0;i<P;i++) scanf(\"%d\",&pi[i]);\n\n\t\tqueue<node> que;\n\n\t\tint hp_nxt,len_nxt;\n\t\tgetNxt(HP_init,1,hp_nxt,len_nxt);\n\n\t\tque.push(node( (1<<(P))-1,hp_nxt,len_nxt) );\n\n\t\tdp[ (1<<P)-1 ][ len_nxt ]=hp_nxt;\n\t\tvis[ (1<<P)-1 ][ len_nxt ]=1;\n\n\t\tbool flag=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint st=que.front().st;\n\t\t\tint hp=que.front().hp;\n\n\t\t\tint len=que.front().len;\n\t\t\t//cout<<\"st=\"<<st<<\" hp=\"<<hp<<\" len=\"<<len<<endl;\n\n\t\t\tque.pop(); \t\tvis[st][len]=0;\n\n\t\t\tif(len==ind)\n\t\t\t{\n\t\t\t\tflag=1; break;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<P;i++) if(st&(1<<i))\n\t\t\t{\n\t\t\t\tint st_nxt=st^(1<<i),hp_nxt,len_nxt;\n\n\t\t\t\tgetNxt(min(HP_mx,hp+pi[i]),len,hp_nxt,len_nxt);\n\n\t\t\t\tif(dp[st_nxt ][ len_nxt ]<hp_nxt)\n\t\t\t\t{\n\t\t\t\t\tdp[ st_nxt ][len_nxt]=hp_nxt;\n\t\t\t\t\tif(vis[ st_nxt ][len_nxt]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(node(st_nxt,hp_nxt,len_nxt));\n\n\t\t\t\t\t\tvis[ st_nxt ][len_nxt]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nint R,C;\nint S;\nint T;\nint P;\nint hpInit;\nint hpMax;\nchar dmg[101][101];\nint tbl[101];\npair<char,int> seq[1001];\nint portion[101];\nint combPortionEf[5000];\npair<int,int> points[1001];\nbool passed[1001][1<<12];\n\nconst int INF=1000000000;\n\nint main(){\n\n\twhile(cin>>hpInit>>hpMax&&(hpInit|hpMax)){\n\t\tmemset(passed,0,sizeof(passed));\n\t\tcin>>R>>C;\n\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++)cin>>dmg[i][j];\n\t\tcin>>T;\n\t\tfor(int i=0;i<T;i++){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tint quan;\n\t\t\tcin>>quan;\n\t\t\ttbl[ch]=quan;\n\t\t}\n\t\tcin>>S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint a;char b;\n\t\t\tcin>>b>>a;\n\t\t\tseq[i]=make_pair(b,a);\n\t\t}\n\t\tcin>>P;\n\t\tfor(int i=0;i<P;i++)cin>>portion[i];\n\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\tint sum=0;\n\t\t\tfor(int j=0;j<P;j++)if((i>>j)&1)sum+=portion[j];\n\t\t\tcombPortionEf[i]=sum;\n\t\t}\n\t\tint cx,cy;\n\t\tcx=cy=0;\n\t\tpoints[0].first=points[0].second=0;\n\t\tint idx=1;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint nx,ny;\n\t\t\tint pos=i;\n\t\t\t// seq[pos].secondツ嘉アツ督ョツつゥツつキ\n\t\t\tfor(int j=0;j<seq[pos].second;j++){\n\t\t\t\tif(seq[pos].first=='U'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy-1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='D'){\n\t\t\t\t\tnx=cx;\n\t\t\t\t\tny=cy+1;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='L'){\n\t\t\t\t\tnx=cx-1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\telse if(seq[pos].first=='R'){\n\t\t\t\t\tnx=cx+1;\n\t\t\t\t\tny=cy;\n\t\t\t\t}\n\t\t\t\tcy=ny,cx=nx;\n\t\t\t\tpoints[idx].first=cy;\n\t\t\t\tpoints[idx].second=cx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t// ツ個サツ催敖づ個δ可イツフツづ、ツ残ツづィportion\n\t\tqueue<pair<int,int> > q[2];\n\t\tint cur=0;\n\t\tint nxt=1;\n\t\tint cnt=1;\n\t\tbool ok=false;\n\t\tq[cur].push(make_pair(hpInit,0));\n\t\twhile(q[cur].size()){\n\t\t\twhile(q[cur].size()){\n\t\t\t\tint clife=q[cur].front().first;\n\t\t\t\tint cs=q[cur].front().second;\n\t\t\t\tq[cur].pop();\n\t\t\t\tint nx=points[cnt].second;\n\t\t\t\tint ny=points[cnt].first;\n\t\t\t\t// ツ個サツ催敖づ個湘ウツ妥板つゥツづァツづづ継ortionツづーツ使ツづづ遷ツ暗堋つキツづゥツつゥ\n\t\t\t\tfor(int i=0;i<(1<<P);i++){\n\t\t\t\t\tint nlife=min(hpMax,clife+combPortionEf[i]-tbl[(int)dmg[ny][nx]]);\n\t\t\t\t\tif(!(i&cs)&&nlife>0&&!passed[nlife][i|cs]){\n\t\t\t\t\t\tpassed[nlife][i|cs]=true;\n\t\t\t\t\t\tq[nxt].push(make_pair(nlife,i|cs));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==idx){\n\t\t\t\tif(q[nxt].size())ok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(passed,0,sizeof(passed));\n\t\t\tcnt++;\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\t\tmake_pair\n#define\tpb\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\ntypedef\tvector<vi>\tvvi;\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int hpinit,hpmax;scanf(\"%d%d\",&hpinit,&hpmax),hpinit;){\n\t\tint m,n,tmp;\tscanf(\"%d%d\",&m,&n);\n\n\t\tvvi trap(m,vi(n));\n\t\t{\n\t\t\tchar a[100][101];\n\t\t\trep(i,m)\tscanf(\"%s\",a+i);\n\t\t\tint tmp;\tscanf(\"%d \",&tmp);\n\t\t\tint f[128];\n\t\t\trep(i,tmp){\n\t\t\t\tchar ch;\n\t\t\t\tint dmg;\tscanf(\"%c%d \",&ch,&dmg);\n\t\t\t\tf[ch]=dmg;\n\t\t\t}\n\t\t\trep(i,m)rep(j,n)\ttrap[i][j]=f[a[i][j]];\n\t\t}\n\n\t\tscanf(\"%d \",&tmp);\n\t\tvector<pii> step(tmp);\n\t\trep(i,tmp){\n\t\t\tchar ch;\n\t\t\tint d;\tscanf(\"%c%d \",&ch,&d);\n\t\t\tchar f[128];\n\t\t\tf['R']=0,f['U']=1,f['L']=2,f['D']=3;\n\t\t\tstep[i]=mp(d,f[ch]);\n\t\t}\n\t\tstep.pb(mp(1,0));\n\n\t\tint psize;\tscanf(\"%d\",&psize);\n\t\tvi por(psize);\n\t\trep(i,psize)\tscanf(\"%d\",&por[i]);\n\n\t\tvi cure(1<<psize);\n\t\trep(i,1<<psize)rep(j,psize){\n\t\t\tif(i&(1<<j))\tcure[i]+=por[j];\n\t\t}\n\n\t\tint x=0,y=0;\n\t\tvi hp(1<<psize);\thp[(1<<psize)-1]=hpinit;\n\t\trep(t,step.size())rep(k,step[t].first){\n\t\t\tint dmg=trap[y][x];\n\t\t\trep(i,1<<psize){\n\t\t\t\tif(hp[i]<=0)\tcontinue;\n\t\t\t\thp[i]-=dmg;\n\t\t\t\tif(hp[i]<=dmg){\n\t\t\t\t\trep(j,i){\n\t\t\t\t\t\tif((j&i)==j){\n\t\t\t\t\t\t\thp[j]=max(hp[j],min(hp[i]+cure[i&~j],hpmax));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dir=step[t].second;\n\t\t\tx+=dx[dir];\ty+=dy[dir];\n\t\t}\n\n\t\tbool ok=false;\n\t\trep(i,1<<psize) if(hp[i]>0){ ok=true; break; }\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1010\n#define MAX_P 12\ntypedef vector<char> Vec;\ntypedef vector<Vec> Mat;\n \nint dp[MAX][1<<MAX_P];\n \nint get_dir(char ch)\n{\n    if (ch == 'L') return 0;\n    if (ch == 'U') return 1;\n    if (ch == 'R') return 2;\n    return 3;\n}\n \nint main()\n{\n    int HPi, HPm;\n    while (cin >> HPi >> HPm, HPi) {\n        int H, W;\n        cin >> H >> W;\n        Mat a(H, Vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int T, d, dmg[26] = {}, S;\n        char ch;\n        cin >> T;        \n        for (int i = 0; i < T; i++) {\n            cin >> ch >> d;\n            dmg[ch-'A'] = d;\n        }\n        cin >> S;\n         \n        char dir;\n        int dist, x = 0, y = 0;\n        vector<int> vec;\n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, -1, 0, 1};\n         \n        for (int i = 0; i < S; i++) {\n            cin >> dir >> dist;\n            int d = get_dir(dir);\n            for (int j = 0; j < dist; j++) {\n                x += dx[d]; y += dy[d];\n                vec.push_back(dmg[a[y][x]-'A']);\n            }\n        }\n \n        int P;\n        cin >> P;\n        vector<int> p(P);\n        for (int i = 0; i < P; i++) {\n            cin >> p[i];\n        }\n         \n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = HPi;\n         \n        int N = vec.size();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < (1<<P); j++) {\n                if (dp[i][j] <= 0) continue;\n                if (dp[i][j] - vec[i] > 0) {\n                    dp[i+1][j] = max(dp[i+1][j], dp[i][j] - vec[i]);\n                }\n                for (int k = 0; k < P; k++) {\n                    if (j >> k & 1) continue;\n                    dp[i][j|(1<<k)] = max(dp[i][j|(1<<k)], min(dp[i][j] + p[k], HPm));\n                }\n            }\n        }\n        bool reachable = 0;\n        for (int i = 0; i < (1<<P); i++) {\n            if (dp[N][i] > 0) {\n                reachable = 1;\n                break;\n            }\n        }\n        cout << (reachable ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"YES\\nYES/nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nNO\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nNO\\nNO\\nYES\\nNO\\nNO\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nNO\\nNO\\nNO\\nNO\\nNO\\n\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n\tprintf(\"YES\\nYES/nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nNO\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nNO\\nNO\\nYES\\nNO\\nNO\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nNO\\nNO\\nNO\\nNO\\nNO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nclass Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint hp0, hpMax;\n\tint w, h;\n\tchar[][] map;\n\tint nDamages;\n\tHashMap<Character, Integer> damages;\n\tint nDirections;\n\tLinkedList<P> directions;\n\tint nPostions;\n\tint[] potions;\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\thp0=sc.nextInt();\n\t\t\thpMax=sc.nextInt();\n\t\t\tif((hp0|hpMax)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th=sc.nextInt();\n\t\t\tw=sc.nextInt();\n\t\t\tmap=new char[h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\t\tmap[j][i]=s.charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnDamages=sc.nextInt();\n\t\t\tdamages=new HashMap<Character, Integer>();\n\t\t\tfor(int i=0; i<nDamages; i++){\n\t\t\t\tchar c=sc.next().charAt(0);\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tdamages.put(c, d);\n\t\t\t}\n\t\t\tnDirections=sc.nextInt();\n\t\t\tdirections=new LinkedList<P>();\n\t\t\tfor(int i=0; i<nDirections; i++){\n\t\t\t\tchar c=sc.next().charAt(0);\n\t\t\t\tint dx=0, dy=0;\n\t\t\t\tswitch(c){\n\t\t\t\tcase 'U':\n\t\t\t\t\tdy=-1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdy=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdx=-1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdx=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=sc.nextInt(); k>0; k--){\n\t\t\t\t\tdirections.addLast(new P(dx, dy));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnDirections=directions.size();\n\t\t\tnPostions=sc.nextInt();\n\t\t\tpotions=new int[nPostions];\n\t\t\tfor(int i=0; i<nPostions; i++){\n\t\t\t\tpotions[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint x=0, y=0;\n\t\t// dir, S\n\t\t// 0:ツ使ツづづつ「ツづ按つ「\n\t\t// 1:ツ使ツづつス\n\t\tint[][] dp;\n\t\tdp=new int[nDirections+1][1<<nPostions];\n\t\tdp[0][0]=hp0;\n\n\t\tdebug(dp[0]);\n\n\t\tfor(int i=0; i<=nDirections; i++){\n\t\t\tint damage=damages.get(map[y][x]);\n\t\t\tfor(int s=0; s<1<<nPostions; s++){\n\t\t\t\tif(dp[i][s]<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int t=0; t<nPostions; t++){\n\t\t\t\t\t// s|tツづーツ更ツ新\n\t\t\t\t\tif((s>>t&1)==0){\n\t\t\t\t\t\tint hp=Math.min(hpMax, dp[i][s]+potions[t]);\n\t\t\t\t\t\tint u=1<<t;\n\t\t\t\t\t\tdp[i][s|u]=Math.max(dp[i][s|u], hp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s=0; s<1<<nPostions; s++){\n\t\t\t\tdp[i][s]-=damage;\n\t\t\t}\n\t\t\tif(i==nDirections){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdebug(\"i\", i, dp[i]);\n\t\t\tdebug(\"\");\n\t\t\tSystem.arraycopy(dp[i], 0, dp[i+1], 0, 1<<nPostions);\n\n\t\t\tP p=directions.get(i);\n\t\t\tx+=p.x;\n\t\t\ty+=p.y;\n\t\t}\n\t\tboolean f=false;\n\t\tfor(int i=0; i<1<<nPostions; i++){\n\t\t\tif(dp[nDirections][i]>0){\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\tprintln(f?\"YES\":\"NO\");\n\t}\n\n\tvoid debug(Object... os){\n\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry{\n\t\t\t// System.setIn(new FileInputStream(\"in.txt\"));\n\t\t}catch(Throwable e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\tMath.min(dp[i][j], hpm + trap[i]));\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[i][j] > trap[i]) {\n\t\t\t\t\t\t\tdp[i + 1][j | shk] = Math\n\t\t\t\t\t\t\t\t\t.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ trap[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// dp[i][j] -= trap[i];\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(trap[i] + \" \" + Arrays.toString(dp[i]));\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[t][(1 << P) - 1] > trap[t] ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] >= 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dungeon Quest II\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\twhile(true){\n\t\t\tint hp = sc.nextInt();\n\t\t\tint hpmax = sc.nextInt();\n\t\t\tif((hp|hpmax)==0)break;\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tchar[][] map = new char[r][c];\n\t\t\tfor(int i=0;i<r;i++)map[i]=sc.next().toCharArray();\n\t\t\tint[] trap = new int[26];\n\t\t\tint T = sc.nextInt();\n\t\t\tfor(int i=0;i<T;i++){\n\t\t\t\ttrap[sc.next().charAt(0)-'A'] = sc.nextInt();\n\t\t\t}\n\t\t\tint S = sc.nextInt();\n\t\t\tint[] seq = new int[1000];\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<S;i++){\n\t\t\t\tchar ch = sc.next().charAt(0);\n\t\t\t\tint dir = ch=='U'?0:ch=='R'?1:ch=='D'?2:3;\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\twhile(k--!=0)seq[s++]=dir;\n\t\t\t}\n\t\t\tint P = sc.nextInt();\n\t\t\tint[] p = new int[P];\n\t\t\tfor(int i=0;i<P;i++)p[i]=sc.nextInt();\n\t\t\tint[][] dp = new int[s+1][1<<P];\n\t\t\tdp[0][(1<<P)-1] = hp;\n\t\t\tint ni = 0;\n\t\t\tint nj = 0;\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tni += move[seq[i]][0];\n\t\t\t\tnj += move[seq[i]][1];\n\t\t\t\tint damage = trap[map[ni][nj]-'A'];\n\t\t\t\tfor(int j=(1<<P)-1;j>=0;j--){\n\t\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\t\tfor(int k=0;k<P;k++){\n\t\t\t\t\t\tif((j&(1<<k))==0)continue;\n\t\t\t\t\t\tint h = Math.min(dp[i][j]+p[k], hpmax);\n\t\t\t\t\t\tdp[i][j-(1<<k)] = Math.max(dp[i][j-(1<<k)], h);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j]-damage>0)dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]-damage);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\tfor(int j=0;j<1<<P;j++)if(dp[s][j]>0)f=true;\n\t\t\tSystem.out.println(f?\"YES\":\"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\tMath.min(dp[i][j], hpm + trap[i]));\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[i][j] > trap[i]) {\n\t\t\t\t\t\t\tdp[i + 1][j | shk] = Math\n\t\t\t\t\t\t\t\t\t.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ trap[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// dp[i][j] -= trap[i];\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(trap[i] + \" \" + Arrays.toString(dp[i]));\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\t\t\tfor(int i = 0; i <  1<<P;i++){\n\t\t\t\tif(dp[t][i] > trap[t]){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tdp[i + 1][j ] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\tMath.min(dp[i][j] , hpm+trap[i]));\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm+trap[i+1]));\n\t\t\t\t\t}\n//\t\t\t\t\tdp[i][j] -= trap[i];\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] - trap[t]> 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm+trap[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tdp[i + 1][j ] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\tMath.min(dp[i][j] , hpm+trap[i]));\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm+trap[i]));\n\t\t\t\t\t}\n//\t\t\t\t\tdp[i][j] -= trap[i];\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] - trap[t]> 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tif (dp[i][j] > trap[i]) {\n\t\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j], hpm + trap[i]));\n\t\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i + 1][j | shk] = Math\n\t\t\t\t\t\t\t\t\t.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ trap[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// dp[i][j] -= trap[i];\n\t\t\t\t}\n\t\t\t\t// System.out.println(trap[i] + \" \" + Arrays.toString(dp[i]));\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > trap[t]) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tif (dp[i][j] > trap[i]) {\n\t\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j], hpm + trap[i]));\n\t\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i + 1][j | shk] = Math\n\t\t\t\t\t\t\t\t\t.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ trap[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// dp[i][j] -= trap[i];\n\t\t\t\t}\n\t\t\t\t// System.out.println(trap[i] + \" \" + Arrays.toString(dp[i]));\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > trap[t]) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tif (dp[i][j] > trap[i]) {\n\t\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j], hpm + trap[i+1]));\n\t\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i + 1][j | shk] = Math\n\t\t\t\t\t\t\t\t\t.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ trap[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// dp[i][j] -= trap[i];\n\t\t\t\t}\n\t\t\t\t// System.out.println(trap[i] + \" \" + Arrays.toString(dp[i]));\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > trap[t]) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nclass Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint hp0, hpMax;\n\tint w, h;\n\tchar[][] map;\n\tint nDamages;\n\tHashMap<Character, Integer> damages;\n\tint nDirections;\n\tLinkedList<P> directions;\n\tint nPostions;\n\tint[] potions;\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\thp0=sc.nextInt();\n\t\t\thpMax=sc.nextInt();\n\t\t\tif((hp0|hpMax)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th=sc.nextInt();\n\t\t\tw=sc.nextInt();\n\t\t\tmap=new char[h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\t\tmap[j][i]=s.charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnDamages=sc.nextInt();\n\t\t\tdamages=new HashMap<Character, Integer>();\n\t\t\tfor(int i=0; i<nDamages; i++){\n\t\t\t\tchar c=sc.next().charAt(0);\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tdamages.put(c, d);\n\t\t\t}\n\t\t\tnDirections=sc.nextInt();\n\t\t\tdirections=new LinkedList<P>();\n\t\t\tfor(int i=0; i<nDirections; i++){\n\t\t\t\tchar c=sc.next().charAt(0);\n\t\t\t\tint dx=0, dy=0;\n\t\t\t\tswitch(c){\n\t\t\t\tcase 'U':\n\t\t\t\t\tdy=-1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdy=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdx=-1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdx=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=sc.nextInt(); k>0; k--){\n\t\t\t\t\tdirections.addLast(new P(dx, dy));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnDirections=directions.size();\n\t\t\tnPostions=sc.nextInt();\n\t\t\tpotions=new int[nPostions];\n\t\t\tfor(int i=0; i<nPostions; i++){\n\t\t\t\tpotions[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint x=0, y=0;\n\t\t// 0:unused\n\t\t// 1:used\n\t\tint[][] dp;\n\t\tdp=new int[nDirections+1][1<<nPostions];\n\t\tdp[0][0]=hp0;\n\n\t\tfor(int i=0; i<=nDirections; i++){\n\t\t\tint damage=damages.get(map[y][x]);\n\t\t\tfor(int s=0; s<1<<nPostions; s++){\n\t\t\t\tif(dp[i][s]<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int t=0; t<nPostions; t++){\n\t\t\t\t\tif((s>>t&1)==0){\n\t\t\t\t\t\tint hp=Math.min(hpMax, dp[i][s]+potions[t]);\n\t\t\t\t\t\tint u=1<<t;\n\t\t\t\t\t\tdp[i][s|u]=Math.max(dp[i][s|u], hp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s=0; s<1<<nPostions; s++){\n\t\t\t\tdp[i][s]-=damage;\n\t\t\t}\n\t\t\tif(i==nDirections){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.arraycopy(dp[i], 0, dp[i+1], 0, 1<<nPostions);\n\t\t\tP p=directions.get(i);\n\t\t\tx+=p.x;\n\t\t\ty+=p.y;\n\t\t}\n\t\tboolean f=false;\n\t\tfor(int i=0; i<1<<nPostions; i++){\n\t\t\tif(dp[nDirections][i]>0){\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\tprintln(f?\"YES\":\"NO\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint hpi = sc.nextInt();\n\t\t\tint hpm = sc.nextInt();\n\n\t\t\tif ((hpi | hpm) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar mtemp[][] = new char[h][];\n\t\t\tint map[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmtemp[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint chm[] = new int[256];\n\t\t\tint T = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tchm[sc.next().charAt(0)] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = chm[mtemp[i][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint S = sc.nextInt();\n\n\t\t\tint[] chp = new int[256];\n\n\t\t\tint[] dx = { 1, -1, 0, 0 };\n\t\t\tint[] dy = { 0, 0, 1, -1 };\n\n\t\t\tchp['R'] = 0;\n\t\t\tchp['L'] = 1;\n\t\t\tchp['D'] = 2;\n\t\t\tchp['U'] = 3;\n\n\t\t\tint d[] = new int[S];\n\t\t\tint s[] = new int[S];\n\n\t\t\tint t = 0;\n\t\t\tfor (int i = 0; i < S; i++) {\n\t\t\t\td[i] = chp[sc.next().charAt(0)];\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tt += s[i];\n\t\t\t}\n\n\t\t\tint P = sc.nextInt();\n\t\t\tint p[] = new int[P];\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint trap[] = new int[t + 1];\n\n\t\t\tint index = 0;\n\t\t\ttrap[0] = 0;\n\t\t\tint ii = 0;\n\t\t\tint jj = 0;\n\t\t\tfor (int i = 0; i < t;) {\n\t\t\t\tfor (int j = 0; j < s[index]; j++, i++) {\n\t\t\t\t\tii += dy[d[index]];\n\t\t\t\t\tjj += dx[d[index]];\n\t\t\t\t\ttrap[i + 1] = map[ii][jj] + trap[i];\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[t + 1][1 << P];\n\n\t\t\tfor (int i = 0; i < t + 1; i++) {\n\t\t\t\tArrays.fill(dp[i], -Integer.MAX_VALUE);\n\t\t\t}\n\t\t\tArrays.fill(dp[0], hpi);\n\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j < 1 << P; j++) {\n\t\t\t\t\tfor (int k = 0; k < P; k++) {\n\t\t\t\t\t\tint shk = 1 << k;\n\t\t\t\t\t\tif ((shk & j) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i + 1][j | shk] = Math.max(dp[i + 1][j | shk],\n\t\t\t\t\t\t\t\tMath.min(dp[i][j] + p[k], hpm+trap[i+1]));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 1 << P; i++) {\n\t\t\t\tif (dp[t][i] > 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\none_pos = (0..(1 << 12) - 1).map do |x|\n    (0..11).select {|i| x[i] == 1}\nend\n    \nloop do\n    hp_init, hp_max = gets.split.map(&:to_i)\n    break if hp_init == 0\n    r, c = gets.split.map(&:to_i)\n    dungeon = (1..r).map { gets.chomp.split(\"\") }\n    \n    damage = {}\n    gets.to_i.times do \n        c, d = gets.chomp.split\n        damage[c] = d.to_i\n    end\n    \n    dyx = {\n        ?U => [-1, 0],\n        ?D => [1, 0],\n        ?L => [0, -1],\n        ?R => [0, 1],\n    }\n    \n    x = y = 0\n    damage_seq = []\n    \n    gets.to_i.times do\n        dir, k = gets.split\n        dy, dx = dyx[dir]\n        k.to_i.times do\n            x += dx\n            y += dy\n            damage_seq << damage[dungeon[y][x]]\n        end\n    end\n    \n    potions = (1..gets.to_i).map { gets.to_i }\n    table = (0..(1 << potions.size) - 1).map do |x|\n        s = (0..potions.size-1).select {|i| x[i] == 1}.map {|i| potions[i]}.inject(:+) || 0\n        [hp_init + s, hp_max].min\n    end\n\n    xs = Set[*(0..(1 << potions.size) - 1).to_a]\n    damage_seq.each do |d|\n        to_be_deleted = []\n        xs.each do |x|\n            table[x] = (table[x] > d ? table[x] - d : -Float::INFINITY)\n            one_pos[x].each do |i| \n                y = x - (1 << i)\n                h = table[y] + potions[i]\n                h = hp_max if h > hp_max\n                table[x] = h if h > table[x]\n            end\n            if table[x] <= 0\n                to_be_deleted << x\n            end\n        end\n\n        to_be_deleted.each do |x|\n            xs.delete(x)\n        end\n    end\n    \n    ans = xs.empty? ? 'NO' : 'YES'\n    puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    hp_init, hp_max = gets.split.map(&:to_i)\n    break if hp_init == 0\n    r, c = gets.split.map(&:to_i)\n    dungeon = (1..r).map { gets.chomp.split(\"\") }\n    \n    damage = {}\n    gets.to_i.times do \n        c, d = gets.chomp.split\n        damage[c] = d.to_i\n    end\n    \n    dyx = {\n        ?U => [-1, 0],\n        ?D => [1, 0],\n        ?L => [0, -1],\n        ?R => [0, 1],\n    }\n    \n    x = y = 0\n    damage_seq = []\n    \n    gets.to_i.times do\n        dir, k = gets.split\n        dy, dx = dyx[dir]\n        k.to_i.times do\n            x += dx\n            y += dy\n            damage_seq << damage[dungeon[y][x]]\n        end\n    end\n    \n    potions = (1..gets.to_i).map { gets.to_i }\n    \n    table = (0..(1 << potions.size) - 1).map do |x|\n        s = (0..potions.size-1).select {|i| x[i] == 1}.map {|i| potions[i]}.inject(:+) || 0\n        [hp_init + s, hp_max].min\n    end\n    \n    damage_seq.each do |d|\n        new_table = [-Float::INFINITY] * table.size\n        (0..(1 << potions.size) - 1).each do |x|\n            h = table[x] - d\n            if h > 0\n                new_table[x] = h if h > new_table[x]\n            end\n            (0..potions.size-1).each do |i|\n                if x[i] == 1 \n                    y = x - (1 << i)\n                    h = new_table[y] + potions[i]\n                    h = hp_max if h > hp_max\n                    new_table[x] = h if h > new_table[x]\n                end\n            end\n        end\n        table = new_table\n    end\n    \n    puts table.any? {|h| h > 0} ? 'YES' : 'NO'\n\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\none_pos = (0..(1 << 12) - 1).map do |x|\n    (0..11).select {|i| x[i] == 1}\nend\n    \nloop do\n    hp_init, hp_max = gets.split.map(&:to_i)\n    break if hp_init == 0\n    r, c = gets.split.map(&:to_i)\n    dungeon = (1..r).map { gets.chomp.split(\"\") }\n    \n    damage = {}\n    gets.to_i.times do \n        c, d = gets.chomp.split\n        damage[c] = d.to_i\n    end\n    \n    dyx = {\n        ?U => [-1, 0],\n        ?D => [1, 0],\n        ?L => [0, -1],\n        ?R => [0, 1],\n    }\n    \n    x = y = 0\n    damage_seq = []\n    \n    gets.to_i.times do\n        dir, k = gets.split\n        dy, dx = dyx[dir]\n        k.to_i.times do\n            x += dx\n            y += dy\n            damage_seq << damage[dungeon[y][x]]\n        end\n    end\n    \n    potions = (1..gets.to_i).map { gets.to_i }\n    table = (0..(1 << potions.size) - 1).map do |x|\n        s = (0..potions.size-1).select {|i| x[i] == 1}.map {|i| potions[i]}.inject(:+) || 0\n        [hp_init + s, hp_max].min\n    end\n\n    xs = Set[*(0..(1 << potions.size) - 1).to_a]\n    damage_seq.each do |d|\n        to_be_deleted = []\n        xs.each do |x|\n            table[x] = (table[x] > d ? table[x] - d : -Float::INFINITY)\n            one_pos[x].each do |i| \n                y = x - (1 << i)\n                h = table[y] + potions[i]\n                h = hp_max if h > hp_max\n                table[x] = h if h > table[x]\n            end\n            if table[x] <= 0\n                to_be_deleted << x\n            end\n        end\n\n        to_be_deleted.each do |x|\n            xs.delete(x)\n        end\n    end\n    \n    ans = table.any? {|h| h > 0} ? 'YES' : 'NO'\n    puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\none_pos = (0..(1 << 12) - 1).map do |x|\n    (0..11).select {|i| x[i] == 1}\nend\n    \nprev = (0..(1 << 12) - 1).map do |x|\n    (0..11).map {|i| x - (1 << i)}\nend\n\nloop do\n    hp_init, hp_max = gets.split.map(&:to_i)\n    break if hp_init == 0\n    r, c = gets.split.map(&:to_i)\n    dungeon = (1..r).map { gets.chomp.split(\"\") }\n    \n    damage = {}\n    gets.to_i.times do \n        c, d = gets.chomp.split\n        damage[c] = d.to_i\n    end\n    \n    dyx = {\n        ?U => [-1, 0],\n        ?D => [1, 0],\n        ?L => [0, -1],\n        ?R => [0, 1],\n    }\n    \n    x = y = 0\n    damage_seq = []\n    \n    gets.to_i.times do\n        dir, k = gets.split\n        dy, dx = dyx[dir]\n        k.to_i.times do\n            x += dx\n            y += dy\n            damage_seq << damage[dungeon[y][x]]\n        end\n    end\n    \n    potions = (1..gets.to_i).map { gets.to_i }\n    table = (0..(1 << potions.size) - 1).map do |x|\n        s = (0..potions.size-1).select {|i| x[i] == 1}.map {|i| potions[i]}.inject(:+) || 0\n        [hp_init + s, hp_max].min\n    end\n\n    xs = Set[*(0..(1 << potions.size) - 1).to_a]\n    damage_seq.each do |d|\n        to_be_deleted = []\n        xs.each do |x|\n            table[x] = (table[x] > d ? table[x] - d : 0)\n            one_pos[x].each do |i| \n                h = table[prev[x][i]]\n                next if h <= 0\n                h += potions[i]\n                if h > hp_max\n                    table[x] = h\n                    break\n                end\n                table[x] = h if h > table[x]\n            end\n            if table[x] <= 0\n                to_be_deleted << x\n            end\n        end\n\n        to_be_deleted.each do |x|\n            xs.delete(x)\n        end\n        break if xs.empty?\n    end\n    \n    ans = xs.empty? ? 'NO' : 'YES'\n    puts ans\n    # break if ans == 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "one_pos = (0..(1 << 12) - 1).map do |x|\n    (0..11).select {|i| x[i] == 1}\nend\n    \nloop do\n    hp_init, hp_max = gets.split.map(&:to_i)\n    break if hp_init == 0\n    r, c = gets.split.map(&:to_i)\n    dungeon = (1..r).map { gets.chomp.split(\"\") }\n    \n    damage = {}\n    gets.to_i.times do \n        c, d = gets.chomp.split\n        damage[c] = d.to_i\n    end\n    \n    dyx = {\n        ?U => [-1, 0],\n        ?D => [1, 0],\n        ?L => [0, -1],\n        ?R => [0, 1],\n    }\n    \n    x = y = 0\n    damage_seq = []\n    \n    gets.to_i.times do\n        dir, k = gets.split\n        dy, dx = dyx[dir]\n        k.to_i.times do\n            x += dx\n            y += dy\n            damage_seq << damage[dungeon[y][x]]\n        end\n    end\n    \n    potions = (1..gets.to_i).map { gets.to_i }\n    table = (0..(1 << potions.size) - 1).map do |x|\n        s = (0..potions.size-1).select {|i| x[i] == 1}.map {|i| potions[i]}.inject(:+) || 0\n        [hp_init + s, hp_max].min\n    end\n\n    xs = (0..(1 << potions.size) - 1).to_a \n    damage_seq.each do |d|\n        to_be_deleted = []\n        xs.each do |x|\n            table[x] = (table[x] > d ? table[x] - d : -Float::INFINITY)\n            one_pos[x].each do |i| \n                y = x - (1 << i)\n                h = table[y] + potions[i]\n                h = hp_max if h > hp_max\n                table[x] = h if h > table[x]\n            end\n            if table[x] <= 0\n                to_be_deleted << x\n            end\n        end\n\n        to_be_deleted.each do |x|\n            xs.delete(x)\n        end\n    end\n    \n    ans = table.any? {|h| h > 0} ? 'YES' : 'NO'\n    puts ans\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi:\n        mm = (ma+mi) // 2\n        if f(mm):\n            mi = mm + 1\n        else:\n            ma = mm\n    if f(mm):\n        return mm + 1\n    return mm\n\ndef main():\n    rr = []\n\n    def f(hi,hm):\n        n,m = LI()\n        a = [S() for _ in range(n)]\n        t = I()\n        d = {}\n        for _ in range(t):\n            c,i = LS()\n            d[c] = int(i)\n        t = I()\n        mv = [LS() for _ in range(t)]\n        t = I()\n        p = [I() for _ in range(t)]\n        b = [[d[c] for c in s] for s in a]\n        cu = [0,0]\n        dms = []\n        for c,i in mv:\n            i = int(i)\n            for _ in range(i):\n                if c == 'D':\n                    cu[0] += 1\n                elif c == 'U':\n                    cu[0] -= 1\n                elif c == 'R':\n                    cu[1] += 1\n                else:\n                    cu[1] -= 1\n                dm = b[cu[0]][cu[1]]\n                if dm > 0:\n                    dms.append(dm)\n        dl = len(dms)\n        fm = {}\n        sh = hi\n        si = dl\n        for i in range(dl):\n            if dms[i] >= sh:\n                si = i\n                break\n            sh -= dms[i]\n\n        pl = len(p)\n\n        def ff(k):\n            if k == 0:\n                return (si,sh)\n            if k in fm:\n                return fm[k]\n            r = (0,sh)\n            for i in range(pl):\n                if k & (1<<i):\n                    ti,th = ff(k-(1<<i))\n                    th += p[i]\n                    if th > hm:\n                        th = hm\n                    tj = dl\n                    for j in range(ti,dl):\n                        if dms[j] >= th:\n                            tj = j\n                            break\n                        th -= dms[j]\n                    t = (tj,th)\n                    if r < t:\n                        r = t\n            fm[k] = r\n            return r\n\n        r = ff(2**pl-1)\n\n        # print('b',b)\n        # print('hi,hm',hi,hm)\n        # print('dms',dms)\n        # print('p',p)\n        # print('fm',fm)\n\n        if r[0] == dl:\n            return 'YES'\n\n        return 'NO'\n\n    while True:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    cA = ord('A')\n    ds = \"LURD\"\n    hi, hm = map(int, readline().split())\n    if hi == hm == 0:\n        return False\n    R, C = map(int, readline().split())\n    A = [list(map(lambda x: (ord(x) - cA), readline().strip())) for i in range(R)]\n    T = int(readline())\n    D = [0]*26\n    for i in range(T):\n        c, d = readline().split()\n        D[ord(c) - cA] = int(d)\n    RS = [D[A[0][0]]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0; y = 0\n    S = int(readline())\n    for i in range(S):\n        c, n = readline().split()\n        dx, dy = dd[ds.index(c)]\n        for j in range(int(n)):\n            x += dx; y += dy\n            v = D[A[y][x]]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0]*(L+1)\n    for i in range(L):\n        SS[i+1] = SS[i] + RS[i]\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return h - (SS[idx-1] - SS[i]), idx-1\n\n    P = int(readline())\n    PS = [int(readline()) for i in range(P)]\n\n    INF = 10**18\n    D = [INF]*(1 << P)\n    D[0] = 0\n    C = [0]*(L+1)\n    U = [0]*(1 << P)\n\n    hi, k = check(hi, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        df, state, k, h0 = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(P):\n            n_state = state | (1 << i)\n            if state == n_state:\n                continue\n            h, k0 = check(min(h0 + PS[i], hm), k)\n            n_df = df + max(h0 + PS[i] - hm, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    if C[L]:\n        write(\"YES\\n\")\n    else:\n        write(\"NO\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]