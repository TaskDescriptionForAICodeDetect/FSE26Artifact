[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint dp[1<<15][15];\nvector<pair<int,int>> ls[15];\nint main(){\n\tint v,e;\tcin>>v>>e;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,d;\tcin>>s>>t>>d;\n\t\tls[s].push_back(make_pair(t,d));\n\t}\n\tfor(int i=0;i<15;i++){\n\t\tfor(int j=0;j<1<<15;j++)\tdp[j][i]=inf;\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<(int)ls[0].size();i++){\n\t\tint to=ls[0][i].first,cost=ls[0][i].second;\n\t\tdp[1<<to][to]=cost;\n\t}\n\tfor(int i=1;i<(1<<v);i++){\n\t\tfor(int j=0;j<v;j++){\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\t\tif(dp[i][j]==inf)\tcontinue;\n\t\t\tfor(int k=0;k<(int)ls[j].size();k++){\n\t\t\t\tint to=ls[j][k].first,cost=ls[j][k].second;\n\t\t\t\tif(i&(1<<to))\tcontinue;\n\t\t\t\tdp[i|(1<<to)][to]=min(dp[i|(1<<to)][to],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\tif(dp[(1<<v)-1][0]==inf)\tcout<<-1<<endl;\n\telse \tcout<<dp[(1<<v)-1][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define int long long\nconst int inf = 100100100100100;\nconst int mod = 1000000007;\n\nconst int maxn = 15;\nint n, m;\nint dist[maxn][maxn];\nint dp[1<<maxn][maxn];\n\nint dfs(int s, int v){\n\n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n\n    if(s == (1<<n)-1 && v == 0){\n        return dp[s][v] = 0;\n    }\n\n    int ans = inf;\n    rep(u,0,n){\n        if(!(s >> u & 1)){\n            ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n        }\n    }\n\n    dp[s][v] = ans;\n    return ans;\n\n\n}\n\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    \n    cin >> n >> m;\n\n    memset(dp,-1,sizeof(dp));\n    fill(dist[0],dist[0]+maxn*maxn,inf);\n\n    \n\n    \n    rep(i,0,m){\n        int f, t, c;\n        cin >> f >> t >> c;\n        dist[f][t] = c;\n    }\n    int ans = dfs(0,0);\n    cout << (ans == inf ? -1 : ans) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n\n#define MAX_V 15\n#define MAX_D 1000\n#define SUP (MAX_V * MAX_D + 1)\nint V, E;\nint d[MAX_V][MAX_V];\nint memo[1<<MAX_V][MAX_V]; // nodes already walked * current node\n\nint recur(int s, int v) {\n    if (memo[s][v] < SUP) return memo[s][v];\n    if (s == (1<<V)-1 and v == 0) return memo[s][v] = 0;\n    int result = SUP;\n    repeat (i,V) if (not (s&1<<i)) {\n        result = min(result, d[v][i] + recur(s|1<<i,i));\n    }\n    return memo[s][v] = result;\n}\n\nint main() {\n    cin >> V >> E;\n    repeat (i,V) repeat (j,V) d[i][j] = SUP;\n    repeat (i,E) { int a, b; cin >> a >> b; cin >> d[a][b]; } // there are no multiedge\n    repeat (i,1<<V) repeat (j,V) memo[i][j] = SUP;\n    cout << (recur(0,0) < SUP ? recur(0,0) : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint v, n, dis[15][15];\nint dp[(1 << 15)][15];\nconst int INF = 100000000;\n\nint main() {\n\tcin >> v >> n;\n\tfor (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dis[i][j] = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdis[a][b] = c;\n\t}\n\tfor (int i = 0; i < (1 << v); i++)for (int j = 0; j < v; j++)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << v) - 1; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (i && !(i & (1 << j)))continue;\n\t\t\tfor (int k = 0; k < v; k++) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif (!(i & (1 << k))) {\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dis[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << v) - 1][0] == INF)cout << -1 << endl;\n\telse cout << dp[(1 << v) - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\ni64 N;\ni64 M;\nvector<vector<i64>> G;\n\ni64 tsp(i64 start, i64 cur, i64 visited) {\n    if(visited == (1<<N) - 1) return G[cur][start];\n\n    i64 res = INF;\n    REP(to, N) {\n        if(GETBIT(visited,to)) continue;\n        if(G[cur][to] == INF) continue;\n\n        i64 val = tsp(start, to, SETBIT(visited,to));\n        if(val == INF) continue;\n        chmin(res, G[cur][to] + val);\n    }\n\n    return res;\n}\n\nvoid solve() {\n    i64 ans = INF;\n    REP(start, N) {\n        i64 val = tsp(start, start, SETBIT(0,start));\n        if(val == INF) continue;\n        chmin(ans, val);\n    }\n\n    PRINTLN(ans != INF ? ans : -1);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    RD(N);\n    RD(M);\n\n    G.assign(N, vector<i64>(N, INF));\n    REP(_, M) {\n        i64 from,to; RD(from); RD(to);\n        i64 cost;    RD(cost);\n        G[from][to] = cost;\n    }\n\n    DBG(G);\n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(ALL((x))), end(x))\n#define gcd(x, y) __gcd(x, y)\n#define lcm(x, y) ((x)/gcd(x,y)*(y))\n#define isin(x, l, r) ((l) <= (x) and (x) < (r))\n#define fcout(n) cout << fixed << setprecision(n)\n#define rcout(n) cout << right << setw(n)\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define PI (acosl(-1))\n#define EPS (1e-10)\n#define INF LLONG_MAX\n#define INF32 INT32_MAX\n#define MOD 1000000007LL\nusing namespace std;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<pair<int, int>>;\nusing VTIII = vector<tuple<int, int, int>>;\nusing Complex = complex<double>;\ntemplate<typename T, template<typename> typename C = less> using PQ = priority_queue<T, vector<T>, C<T>>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a == b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a == b)){ a=b; return true; } return false; }\n\n\nint V, E;\nint G[20][20];\nint dp[1<<15][20];\n\n\nsigned main(){\n    cin >> V >> E;\n    rep(i, 0, V) rep(j, 0, V) G[i][j] = INF;\n    rep(i, 0, E){\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    rep(i, 0, 1<<V) rep(j, 0, V) dp[i][j] = INF;\n    dp[1][0] = 0;\n    rep(i, 0, 1<<V) rep(j, 0, V){\n        if(dp[i][j] == INF) continue;\n        rep(k, 0, V) if(((i>>k)&1) == 0 and G[j][k] != INF) chmin(dp[i|(1<<k)][k], dp[i][j]+G[j][k]);\n    }\n    int ans = INF;\n    rep(i, 1, V) if(G[i][0] != INF and dp[(1<<V)-1][i] != INF) chmin(ans, dp[(1<<V)-1][i]+G[i][0]);\n    if(ans == INF) ans = -1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\nstruct edge{\n    int to,cost;\n    edge(int a,int b):to(a),cost(b){}\n};\n\nint dp[1<<16][15];\nint N,M;\nvector<edge>G[15];\n\nint solve(int s){\n    fill_n(*dp,(1<<16)*15,INF);\n    dp[0][s]=0;\n\n    for(int i=0;i<(1<<N);i++){\n        for(int j=0;j<N;j++){\n            if(dp[i][j]==INF)continue;\n            for(int k=0;k<G[j].size();k++){\n                edge &e=G[j][k];\n                if(i>>e.to&1)continue;\n                dp[i|(1<<e.to)][e.to]=min(dp[i|(1<<e.to)][e.to],dp[i][j]+e.cost);\n            }\n        }\n    }\n\n    return dp[(1<<N)-1][s];\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n\n    int mi=INF;\n\n    for(int i=0;i<N;i++)mi=min(mi,solve(i));\n    cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\n#define INF 1000000007\n#define MAX 15\nint v,e;\nint d[MAX][MAX] = {{0}};\n\nint dp[1 << MAX][MAX] = {{0}};\n\nint dfs(int s, int n){\n  // cout << dp[s][n] << endl;\n  if(dp[s][n] >= 0) return dp[s][n];\n  if(s == (1 << v) - 1 && n == 0) return dp[s][n] = 0;\n  int res = INF;\n  for(int u = 0; u < v; u++){\n    if(!(s >> u & 1) && d[n][u] != -1){\n      // cout << s << \" \" << n << \" \" << u << endl;\n      res = min(res, dfs( s | (1 << u), u) + d[n][u]);\n    }\n  }\n  return dp[s][n] = res;\n}\n\nint main(){\n  cin >> v >> e;\n  for(int i = 0; i < v; i++){\n    for(int j = 0; j < v; j++){\n      d[i][j] = -1;\n    }\n  }\n  for(int i = 0; i < (1<<v); i++){\n    for(int j = 0; j < v; j++){\n      dp[i][j] = -1;\n    }\n  }\n  // cout << dp[0][0] << endl;\n  for(int i = 0; i < e; i++){\n    int s,t,c;\n    cin >> s >> t >> c;\n    d[s][t] = c;\n  }\n   // cout << \"hi\" << endl;\n  int ans = dfs(0, 0);\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 15\n#define INF (INT_MAX/MAX_V)\n\nstruct edge { int to, cost; };\n\nint V, E;\nvector<edge> G[MAX_V];\n\nint dist[MAX_V][MAX_V];\n\nint dp[1 << MAX_V][MAX_V];\n\nint tsp( int mask,int pos, int s )\n{\n\tif( mask == (1 << V) - 1 ) {\n\t\treturn dist[pos][s];\n\t}\n\tif( dp[mask][pos] != -1 ) {\n\t   return dp[mask][pos];\n\t}\n\n\tint ans = INT_MAX;\n\n\tfor( int city = 0; city < V; city++ ) {\n\t\tif( (mask & (1 << city) ) == 0 ) {\n\t\t\tint nans = dist[pos][city] + tsp( mask | (1 << city), city, s );\n\t\t\tans = min( ans, nans );\n\t\t}\n\t}\n\n\treturn dp[mask][pos] = ans;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\tfor( int i = 0; i < E; i++ ) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge e;\n\t\te.to = t;\n\t\te.cost = d;\n\t\tG[s].push_back( e );\n\t}\n\n\tfor( int i = 0; i < V; i++ ) {\n\t\tfor( int j = 0; j < V; j++ ) {\n\t\t\tdist[i][j] = INF;\n\t\t}\n\t}\n\tfor( int i = 0; i < V; i++ ) {\n\t\tfor( int j = 0; j < G[i].size(); j++ ) {\n\t\t\tdist[ i ][ G[i][j].to ] = G[i][j].cost;\n\t\t}\n\t}\n\n\tint min_ans = INT_MAX;\n\tfor( int i = 0; i < V; i++ ) {\n\t\tif( G[i].empty() ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < (1 << V); i++ ) {\n\t\t\tfor(int j = 0; j < V; j++ ) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint ans = tsp( 1 << i, i, i );\n\t\tmin_ans = min( min_ans, ans );\n\t}\n\n\tif( min_ans >= INF ) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << min_ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nstruct edge {\n\tll u;\n\tll v;\n\tll cost;\n\tedge() {}\n\tedge(ll u, ll v, ll c) :u(u), v(v), cost(c) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll V, E; cin >> V >> E;\n\tvector<vector<edge>> G(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tll s, t, d; cin >> s >> t >> d;\n\t\tG[s].emplace_back(edge(s, t, d));\n\t}\n\t/* dp[i][j] := ?????????j???????????¨???, bit???i??????????????°????????§???????????????????????¢ */\n\tvector<vector<ll>> dp(1 << V, vector<ll>(V, INF));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << V);i++) {\n\t\tfor (int j = 0; j < V;j++) {\n\t\t\tfor (auto e : G[j]) {\n\t\t\t\tif (!((i >> e.v) & 1)) {\n\t\t\t\t\tdp[i | (1 << e.v)][e.v] = min(dp[i | (1 << e.v)][e.v], dp[i][e.u] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ret = dp[(1 << V) - 1][0];\n\tif (ret == INF)ret = -1;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOOP(n) for (int _i = 0; _i < (n); _i++)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define RREP(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, r, n) for (int i = (r); i < (n); ++i)\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\nusing ll = long long;\nconst int INF = 1000100100;\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint V, E;\nint G[20][20];  // グラフ\nint dp[50000][20];\n\nint rec(int S, int v) {  // メモ化再帰\n    if (S == 0) {\n        if (v == 0) {\n            return 0;\n        } else {\n            return INF;\n        }\n    }\n    if ((S & (1 << v)) == 0) {\n        return INF;\n    }\n\n    int &ret = dp[S][v];\n    if (ret != 0) return ret;\n\n    ret = INF;\n    REP(u, V) { chmin(ret, rec(S ^ (1 << v), u) + G[u][v]); }\n    return ret;\n}\n\nint main() {\n    cin >> V >> E;\n\n    // グラフの初期化\n    REP(i, 20) {\n        REP(j, 20) { G[i][j] = INF; }\n    }\n    REP(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    int ans = rec((1 << V) - 1, 0);\n\n    if (ans != INF) {\n        cout << ans << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (!dis[s][t])\n\t\t\t{\n\t\t\t\tdis[s][t] = INT_MAX / 10;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 18\n#define INF 1000000000\nint N, M, a, b, c, x[MAX_N][MAX_N];\nint dp[MAX_N][1 << MAX_N];\n\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) { x[i][j] = INF; }\n\t\tfor (int j = 0; j < (1 << MAX_N); j++) { dp[i][j] = INF; }\n\t\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b >> c;\n\t\tx[a][b] = c;\n\t}\n\tdp[0][1] = 0;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (dp[j][i] < INF) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint dist1 = dp[j][i] + x[j][k];\n\t\t\t\t\t\tint pos = i + (1 << k);\n\t\t\t\t\t\tif (dp[k][pos] > dist1) {\n\t\t\t\t\t\t\tdp[k][pos] = dist1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tmaxn = min(dp[i][(1 << N) - 1] + x[0][i], maxn);\n\t}\n\tif (maxn == INF) { maxn = -1; }\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <map>\n\n//#include <bits/stdc++.h>\nusing namespace std;\n#define print(x) cout<<(x)<<endl\n#define prints(x, y) cout<<(x)<<\" \"<<(y)<<endl\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define r_rep(i, n) for(int i = (int)n-1; i >= 0; i--)\n#define ll long long\n#define pb push_back\nconst long long MOD = 1000000007;\nconst long long INF = 1LL << 60;\n\nint N; // 頂点の数\nconst int MAX_N = 16;\nll dp[1 << MAX_N][MAX_N];\nll d[1100][1100];\n\nvoid solve(){\n  // テーブルを大きな値で初期化\n  for(int S = 0; S < 1 << N; S++){\n    fill(dp[S], dp[S]+N, INF);\n  }\n  dp[(1 << N) - 1][0] = 0;\n\n  // 漸化式に従って順に計算\n  for(int S=(1 << N) - 2; S >= 0; S--){\n    for(int v = 0; v < N; v++){\n      for(int u = 0; u < N; u++){\n        if(!(S >> u & 1)){\n          dp[S][v] = min(dp[S][v], dp[S | 1 << u][u]+ d[v][u]);\n        }\n      }\n    }\n  }\n\n  if(dp[0][0] == INF){\n    cout << -1 << endl;\n  } else {\n    cout << dp[0][0] << endl;\n  }\n  \n}\n\nint main() {\n  int E;\n  cin >> N >> E;\n  // INFで初期化\n  rep(i, 1100){\n    rep(j, 1100){\n      d[i][j] = INF;\n    }\n  }\n\n  int a, b, distance;\n  rep(i, E){\n    cin >> a >> b >> distance;\n    d[a][b] = distance;\n  }\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define INF 0x33433433\n\nstruct Edge {\n    int len;\n    int to;\n};\n\nint n;\nint m;\nint state;\nint ans;\nint dp[1 << 16][15];\nint adj[15][15];\n\nvoid calc(int s) {\n    int state = 1 << n;\n    int start = 1 << s;\n\n    for (int i=0; i<state; i++) {\n        for (int j=0; j<n; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    dp[start][s] = 0;\n    for (int i=start+1; i<state; i++) {\n        for (int j=0; j<n; j++) {\n            for (int k=0; k<n; k++) {\n                bool s1 = ((i >> j) & 1);\n                bool s2 = ((i >> k) & 1);\n\n                if (j == k) continue;\n                if (adj[k][j] == -1) continue;\n                if (s1 && s2) {\n                    dp[i][j] = min(dp[i][j], dp[i & ~(1 << j)][k] + adj[k][j]);\n                }\n            }\n        }\n    }\n\n    for (int i=0; i<n; i++) {\n        if (adj[i][s] == -1) continue;\n        ans = min(ans, dp[state-1][i] + adj[i][s]);\n    }\n}\n\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n            adj[i][j] = -1;\n        }\n    }\n    \n    for (int i=0; i<m; i++) {\n        int s, t, l;\n\n        scanf(\"%d%d%d\", &s, &t, &l);\n        adj[s][t] = l;\n    }\n\n    ans = INF;\n    for (int i=0; i<n; i++) {\n        calc(i);\n    }\n\n    if (ans == INF) puts(\"-1\");\n    else printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\nint memo[16][100000];\nvector<vector<pair<int,int> > > graph;\n\nint dp(int n,int c,int bit){\n\n  if(bit == (pow(2,v)-1)){\n    for(int i = 0;i < graph[n].size();i++){\n      if(graph[n][i].first == 0){\n        return graph[n][i].second;\n      }\n    }\n    return 1000000;\n  }\n\n  if(memo[n][bit] != 0){\n    return memo[n][bit];\n  }\n\n  int a = 1000000;\n\n  for(int i = 0;i < graph[n].size();i++){\n    if((bit & (1 << graph[n][i].first)) == 0){\n      a = min(a,dp(graph[n][i].first,c+1,bit | (1 << graph[n][i].first))+graph[n][i].second);\n    }\n  }\n\n  return memo[n][bit] = a;\n}\n\n\n\nint main(){\n  cin >> v >> e;\n  graph.resize(v);\n  for(int i = 0;i < e;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    pair<int,int> p = make_pair(t,d);\n    graph[s].push_back(p);\n  }\n\n  int ans = dp(0,0,1);\n\n  if(ans >= 20000){\n    cout << -1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tint table[15] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384};\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint** dp = new int*[N];\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i] = new int[limit];\n\t\tfor(int k = 0; k < limit; k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\n\ttmp = pow(2,0);\n\n\tdp[0][tmp] = 0;\n\n\tfor(int state = 0; state <= limit-1; state++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(dp[k][state] == BIG_NUM)continue;\n\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\tif(state == limit-1 && a == 0){\n\t\t\t\t\t\tif(cost[k][0] != BIG_NUM)dp[0][limit-1] = min(dp[0][limit-1],dp[k][state]+cost[k][0]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\ttmp = state + table[a];\n\t\t\t\t\t\tdp[a][tmp] = min(dp[a][tmp],dp[k][state]+cost[k][a]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tminimum = min(minimum,dp[0][limit-1]);\n\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint a, b, c, d;\n\tcin >> a >> b >> c\n\tfor( int i = a; i <= b; i++){\n\tif( c&i == 0 ){ ++d }\n\t}\n\tcout << d << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp_solve(vector<vector<pair<int, int>>> &g,\n             vector<vector<int>> &dp,\n             int bit,\n             int v,\n             int V)\n{\n    if (dp[bit][v] != -1)\n    {\n        return dp[bit][v];\n    }\n    if (bit == 1)\n    {\n        for (auto vv : g[v])\n        {\n            if (vv.first == 0)\n            {\n                return dp[bit][v] = vv.second;\n            }\n        }\n        return dp[bit][v] = 1000000;\n    }\n    int ret = 1000000;\n    for (auto vv : g[v])\n    {\n        if (vv.first == 0 || !(bit & (1 << vv.first)))\n        {\n            continue;\n        }\n        int prev_bit = bit & ~(1 << vv.first);\n        ret = min(ret, dp_solve(g, dp, prev_bit, vv.first, V) + vv.second);\n    }\n    return dp[bit][v] = ret;\n}\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    vector<vector<pair<int, int>>> g(V);\n    for (int i = 0; i < E; i++)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s].push_back(make_pair(t, d));\n    }\n    int ans = 1000000;\n    int bit = (1 << V) - 1;\n    vector<vector<int>> dp(bit + 1, vector<int>(V, -1));\n    for (auto v : g[0])\n    {\n        if (v.first == 0)\n            continue;\n        int prev_bit = bit & ~(1 << v.first);\n        ans = min(ans, dp_solve(g, dp, prev_bit, v.first, V) + v.second);\n    }\n    if (ans == 1000000)\n    {\n        cout << \"-1\" << endl;\n    }\n    else\n    {\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll mod=1000000007;\nconst ll LINF=1LL<<60;\nconst int INF=1<<30;\n//巡回セールスマン問題\nint main(){\n\tint v,e;cin>>v>>e;\n\tvector<vector<int>> d(v,vector<int>(v,INF));\n\tfor(int i = 0; i < e; i++) {\n\t\tint s,t,D;cin>>s>>t>>D;\n\t\td[s][t] = D;\n\t}\n\n\tvector<vector<ll>> dp(1 << v,vector<ll>(v + 1,INF));\n\tdp[(1 << v) - 1][0] = 0;\n\tfor(int s = (1 << v) - 2; s >= 0; s--) {\n\t\tfor(int j = 0; j < v; j++) {\n\t\t\tfor(int k = 0; k < v; k++) {\n\t\t\t\tif (!((s >> k) & 1)){\n\t\t\t\t\tdp[s][j] = min(dp[s][j], dp[s|(1 << k)][k] + d[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[0][0] == INF){\n\t\tcout << -1 << endl;\n\t}\n\telse{\n\t\tcout << dp[0][0] << endl;\n\t}\n\n\t// for(int i = 0; i < (1 << v); i++) {\n\t// \tfor(int j = 0; j < v; j++) {\n\t// \t\tcout << dp[i][j] << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\t// for(int i = 0; i < v; i++) {\n\t// \tfor(int j = 0; j < v; j++) {\n\t// \t\tcout << d[i][j] << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 1000000\n\nint main()\n{\n    int v, e, s, t, d;\n    int G[15][15];\n    cin >> v >> e;\n    for (int i = 0; i < v; i++) {\n        fill(G[i], G[i] + v, INF);\n    }\n    for (int i = 0; i < v; i++) {\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < e; i++) {\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int dp[1 << 15][15];\n    for (int i = 0; i < 1 << 15; i++) {\n        fill(dp[i], dp[i] + 15, INF);\n    }\n    dp[0][0] = 0;\n    \n    for (int S = 0; S < 1 << v; S++) {\n        for (int i = 0; i < v; i++) {\n            for (int u = 0; u < v; u++) {\n                if (!((S >> u) & 1)) {\n                    dp[S | (1 << u)][u] = min(dp[S | (1 << u)][u], dp[S][i] + G[i][u]);\n                }\n            }\n        }\n    }\n    if (dp[(1 << v) - 1][0] == INF) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << dp[(1 << v) - 1][0] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\nvoid Main() {\n    ll V, E;\n    cin >> V >> E;\n    vector<pair<ll, P>> info(E);\n    rep(i, E) {\n        ll s, t, d;\n        cin >> s >> t >> d;\n        info[i] = make_pair(s, make_pair(t, d));\n    }\n    vector<vector<ll>> dp(V, vector<ll>(1 << V, INF));\n    dp[0][0] = 0;\n    rep(i, 1 << V) {\n        rep(j, E) {\n            ll s = info[j].first;\n            ll t = info[j].second.first;\n            ll d = info[j].second.second;\n            if (!(i & (1 << t))) {\n                dp[t][i | (1 << t)] = min(dp[t][i | (1 << t)], dp[s][i] + d);\n            }\n        }\n    }\n    ll ans = dp[0][(1 << V) - 1];\n    if (ans == INF) {\n        cout << -1 << '\\n';\n    } else {\n        cout << ans << '\\n';\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint MOD=1e9+7;\nll INF=1e18;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint main(){\n    int V, E; cin>>V>>E;\n    ll dist[V][V];\n\n    for(int i=0; i<V; i++){\n        for(int j=0; j<V; j++){\n            dist[i][j]=INF;\n        }\n    }\n\n    for(int i=0; i<E; i++){\n        int s, t, d; cin>>s>>t>>d;\n        dist[s][t]=d;\n    }\n\n    ll dp[(1<<V)][V];\n    for(int i=0; i<(1<<V); i++){\n        for(int j=0; j<V; j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][0]=0;\n\n    for(int S=1; S<(1<<V); S++){\n        for(int v=0; v<V; v++){\n            for(int j=0; j<V; j++){\n                if((1<<v) & S){\n                    dp[S][v]=min(dp[S][v], dp[S-(1<<v)][j]+dist[j][v]);\n                }\n            }\n        }\n    }\n    if(dp[(1<<V)-1][0] == INF) cout << -1 << endl;\n    else cout << dp[(1<<V)-1][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 49\n    https://onlinejudge.u-aizu.ac.jp/problems/DPL_2_A\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\nconst int MAX = 20;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nint V, E;\nvector<vector<int>> dist(MAX, vector<int>(MAX, NIL));\n/* function */\nvoid solve1() {\n    int upper = 1 << V;\n    // dp[状態][最後に訪れた街] : min\n    vector<vector<int>> dp(upper , vector<int>(V, INF));\n    // 頂点0startとする\n    dp[1][0] = 0;\n    for (int b = 1; b < upper; b++) {\n        for (int from = 0; from < V; from++) {\n            if (dp[b][from] == INF) continue;\n            // 配るDP\n            for (int to = 0; to < V; to++) {\n                // toがすでに訪れていたら次へ\n                if (b & (1 << to)) continue;\n                // 辺がないなら次へ\n                if (dist[from][to] == NIL) continue;\n                // 次の状態をbitで管理\n                int nextB = b | (1 << to);\n                dp[nextB][to] = min(dp[nextB][to], dp[b][from] + dist[from][to]);\n            }\n        }\n    }\n    // dp[1<<V-1][i]\n    // 0 -> 4 -> ... -> i\n    // 0からstartして最後にiに着くような全部の街を通る最短距離\n    // i -> 0を足して 0 -> ... -> i -> 0の距離を求める\n    int ans = INF;\n    for (int i = 0; i < V; i++) {\n        if (dist[i][0] == NIL) continue;\n        ans = min(ans, dp[upper - 1][i] + dist[i][0]);\n    }\n    cout << ((ans == INF) ? -1 : ans) << '\\n';\n}\nvoid solve2() {\n    int upper = 1 << V;\n    // dp[状態][最後に訪れた街] : min\n    vector<vector<int>> dp(upper , vector<int>(V, INF));\n    dp[0][0] = 0;\n    for(int s = 0; s < upper ; s++) {\n        for(int i = 0; i < V; i++) {\n            if(dp[s][i] == INF) continue;\n            for(int j = 0; j < V; j++) {\n                if(i == j || dist[i][j] == NIL || (s & (1<<j)))   continue;\n                int nextS = s | (1 << j);\n                dp[nextS][j] = min(dp[nextS][j], dp[s][i]+dist[i][j]);\n            }\n        }\n    }\n\n    int ans = dp[upper - 1][0];\n    if(ans == INF)  ans = -1;\n    cout << ans << endl;\n}\n/* main */\nint main(){\n    cin >> V >> E;\n\n    for (int i = 0; i < E; i++) {\n        int a, b, w;\n        a--, b--;\n        cin >> a >> b >> w;\n        dist[a][b] = w;\n    }\n    // solve1();\n    solve2();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, s, n) for(int i = s; i < n; i++)\nusing namespace std;\n\nconst int INF = 100000000;\nint V, E;\nint dist[16][16];\nint dp[(1<<16)+1][16];\n\nint rec(int bit, int v){\n  if (dp[bit][v] != -1) return dp[bit][v];\n  if (bit == (1<<v)){\n    if (dist[0][v] == -1)\n      return dp[bit][v] = INF;\n    else\n      return dp[bit][v] = dist[0][v];\n  }\n  int res = INF;\n  int prev_bit = bit & ~(1<<v);\n  rep(u, V){\n    if (!(prev_bit & (1<<u))) continue;\n    if (dist[u][v] == -1) continue;\n    if (res > rec(prev_bit, u) + dist[u][v]){\n      res = rec(prev_bit, u) + dist[u][v];\n    }\n  }\n  return dp[bit][v] = res;\n}\n\nint main(){\n  cin >> V >> E;\n  memset(dist, -1, sizeof(dist));\n  memset(dp, -1, sizeof(dp));\n  int s, t, d;\n  rep(i, E){\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n  int res = INF;\n  res = rec((1<<V)-1, 0);\n  if (res == INF)\n    cout << -1 << endl;\n  else\n    cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\n#define INF 1<<15\n\nint main(){\n\tint n,m;\n\tint s,t,d;\n\tint e[15][15];\n\tint dp[1<<15][15];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<15;i++) fill_n(e[i],15,INF);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\te[s][t]=d;\n\t}\n\t\n\tfor(int i=0;i<(1<<n);i++) fill_n(dp[i],n,INF);\n\tdp[(1<<n)-1][0]=0;\n\t\n\tfor(int i=(1<<n)-2;i>=0;i--){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(!(i>>k&1))\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i|1<<k][k]+e[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(dp[0][0]==INF ? -1 : dp[0][0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int inf = 987654321;\nint n, m;\nvector< vector<int> > G;\nvector< vector<int> > dp;\n\nint rec(int visited, int now) {\n  if (dp[visited][now] != -1) return dp[visited][now];\n  if (visited == (1<<n)-1 && now == 0) return dp[visited][now] = 0;\n  int res = inf;\n  for (int i = 0; i < n; i++) {\n    if (visited >> i & 1) continue; /* ??¢????¨??????? */\n    res = min(res, rec(visited | (1 << i), i) + G[now][i]);\n  }\n  return dp[visited][now] = res;\n}\n\nint main(void) {\n  cin >> n >> m;\n  G.assign(n, vector<int>(m, inf));\n  for (int i = 0; i < m; i++) {\n    int p, q, c;\n    cin >> p >> q >> c;\n    G[p][q] = c;\n  }\n  dp.assign(1<<n, vector<int>(n, -1));\n  int res = rec(0, 0);\n  if(res != inf) cout << res << endl;\n  else cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repi(i, a, b) for (int i = int(a); i < int(b); ++i)\ntypedef long long ll;\nlong long mod = 1e9 + 7;\nconst long long INF = 10000;\nusing namespace std;\n\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint V, E;\nvector<vector<int>> dist(16, vector<int>(16, INF));\n// dp[i][j] := 今まで{i}を通って現在jにいる時の最短経路長\nint dp[(1 << 15) + 1][16];\n\nint main()\n{\n  cin >> V >> E;\n\n  rep(i, E)\n  {\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n\n  for (int bit = 0; bit < (1 << V); ++bit)\n    for (int v = 0; v < V; ++v)\n      dp[bit][v] = 10000;\n\n  dp[0][0] = 0;\n\n  rep(bit, 1 << V) rep(j, V)\n  {\n    rep(k, V)\n    {\n      if (bit >> k & 1)\n        continue; // kを使用済み\n      int next_bit = (bit | 1 << k);\n\n      dp[next_bit][k] = min(dp[next_bit][k], dp[bit][j] + dist[j][k]);\n    }\n  }\n\n  cout << (dp[(1 << V) - 1][0] == 10000 ? -1 : dp[(1 << V) - 1][0]) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp((1 << V), vector<int>(V, -1));\n\tfunction<int(int, int)>tsp = [&](int S, int v) {\n\t\tif (dp[S][v] != -1)return dp[S][v];\n\t\tif (S == (1 << V) - 1 && v == 0)return dp[S][v] = 0;\n\t\tint ret(INF);\n\t\trep(i, 0, V) {\n\t\t\tif (!(S&(1 << i)))chmin(ret, tsp(S | (1 << i), i)+G[v][i]);\n\t\t}\n\t\treturn dp[S][v] = ret;\n\t};\n\tint ans = tsp(0, 0);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint dp[1<<20][20];\nint cost[20][20];\nint main(){\n\tint V,E;\n\tcin>>V>>E;\n\tmemset(cost, INF, sizeof(cost));\n\tfor(int i =0;i < E;i++){\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\tcost[x][y] =c;\n\t}\n\tfor(int i =0;i <(1<<V);i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\tif(((i>>j)&1)==0)continue;\n\t\t\tfor(int k =0;k < V;k++){\n\t\t\t\tif((i>>j&1)==1)continue;\n\t\t\t\tdp[i|(1<<k)][k] =min(dp[i|1<<k][k],dp[i][j]+cost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans =INF;\n\tfor(int i =0;i <V;i++){\n\t\tans =min(ans,dp[(1<<V)][i]+cost[i][0]);\n\t}\n\tif(ans>=INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define now dp[st][pos][bits]\n\nconst int N = 15, INF = 0x3f3f3f3f;\n\nint n, m, end;\nint G[N][N];\nint dp[N][N][1 << 16];\n//dp i,j,k ??¨??????i????????????????????¨j????????????????????¶??????k??¶????????°?????????????°???????\n//??¨??????????????¶??????????????¶????§???????0??????????????¶????????\\??¨???????????\\\n\ninline int nextInt(void) {\n\tint res;\n\tscanf(\"%d\", &res);\n\treturn res;\n}\n\ninline void addEdge(int x, int y, int w) {\n\tG[x][y] = w;\n}\n\ninline void makeEnd(void) {\n\tend = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tend |= (1 << i);\n}\n\nint DP(int st, int pos, int bits) {\n\t//cout << \"Searching for DP \" << st << \" \" << pos << \" \" << bits << endl;\n\tif (~now)\t//??°??????????´¢\n\t\treturn now;\n\tif (st == pos&&bits == end)\t//???????????°??????????????????????????????\n\t\treturn now = 0;\n\tnow = INF;\n\tfor (int i = 0; i < n; i++)\t//????????????\n\t\tif (i != pos &&!( (bits >> i) & 1))\t//?????????????\\??????????\n\t\t\tnow = min(now, DP(st, i, bits | (1 << i)) + G[pos][i]);\n\t//cout << \"Found DP \" << st << \" \" << pos << \" \" << bits << \" = \" << now << endl;\n\treturn now;\n}\n\nsigned main(void) {\n\tmemset(G, 0x3f, sizeof(G));\n\tmemset(dp, -1, sizeof(dp));\n\tn = nextInt();\n\tm = nextInt();\n\tfor (int i = 0; i < m; i++) {\n\t\tint x = nextInt();\n\t\tint y = nextInt();\n\t\tint w = nextInt();\n\t\taddEdge(x, y, w);\n\t}\n\tmakeEnd();\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++)\n\t\tans = min(ans, DP(i, i, 0));\n\tprintf(\"%d\\n\", ans < INF ? ans : -1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint dp[1 << 15][15];\nint n;\nint m[15][15];\n\nint rec(int s,int v){\n  if(dp[s][v]>=0){\n    return dp[s][v];\n  }\n\n  if(s ==((1 << n)-1) && v==0){\n    //printf(\"v=0\\n\");\n\n    return dp[s][v]=0;\n  }\n\n  int res = 1000*15+1;\n\n  for(int u=0;u<n;u++){\n    if((!(s >> u & 1)) && m[v][u]>=0){\n      //printf(\"m:%d\",m[v][u]);\n      res = min(res,rec(s | (1 << u),u)+m[v][u]);\n    } \n  }\n  //printf(\"res=%d\\n\",res);\n  return dp[s][v]=res;\n}\n\nint main(){\n  int v,e;\n  cin >> v >> e;\n  n=v;\n  \n    memset(m,-1,sizeof(m));\n\n\n  int s,t,d;\n  for(int i=0;i<e;i++){\n    cin >> s >> t >> d;\n    m[s][t]=d;\n  }\n  \n  memset(dp,-1,sizeof(dp));\n  int ans=rec(0,0);\n  if(ans==15001){\n    printf(\"%d\\n\",-1);\n  }\n  else{\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"DataStructure.h\"\n#include <map>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <math.h>\n#include <string.h>\nusing namespace std;\nconst int num = 15, num1 = 10000000;\ntypedef long long int ll;\ntypedef pair<int, int> p;\nconst int INF = 20000000;\nint dp[1 << num][num], m[num][num];\nint n, e;\nbool close = false;\nint solve(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) {\n\t\tclose = true;\n\t\treturn dp[s][v] = 0;\n\t}\n\tif (dp[s][v] != INF)\n\t\treturn dp[s][v];\n\tint res = INF;\n\tfor (int t = 0; t < n; t++)\n\t\tif (!(s >> t & 1))\n\t\t\tres = min(res, m[v][t] + solve(s | 1 << t, t));\n\treturn dp[s][v] = res;\n}\nint main() {\n\tcin >> n >> e;\n\tfill(m[0], m[num], INF);\n\tfill(dp[0], dp[1 << num], INF);\n\tfor (int i = 0; i < e; i++) {\n\t\tint  s, t, u;\n\t\tcin >> s >> t >> u;\n\t\tm[s][t] = u;\n\t}\n\tif (close)\n\t\tcout << solve(0, 0) << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LLP;\n\nconst int INF = (1 << 30) - 1;\n// const ll LL_INF = (1LL << 62) - 1;\n// const ll MOD = 1e9 + 7;\n// const double PI = M_PI;\n\nint V, E;\nvector<vector<int> > d;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> V >> E;\n  d.resize(V, vector<int>(V, INF));\n  rep(i, E) {\n    int si, ti, di;\n    cin >> si >> ti >> di;\n    d[si][ti] = di;\n  }\n\n  int dp[1 << V][V];\n  rep(i, 1 << V) { fill(dp[i], dp[i] + V, INF); }\n  dp[0][0] = 0;\n\n  rep(i, 1 << V) {\n    rep(s, V) {\n      rep(t, V) {\n        if (s == t) {\n          continue;\n        }\n        if ((i & (1 << t)) > 0) {\n          continue;\n        }\n        if (d[s][t] == INF) {\n          continue;\n        }\n        dp[i | (1 << t)][t] = min(dp[i | (1 << t)][t], dp[i][s] + d[s][t]);\n      }\n    }\n  }\n\n  if (dp[(1 << V) - 1][0] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[(1 << V) - 1][0] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000\n\nusing namespace std;\n\n#define MAXN 16\nint d[MAXN][MAXN];\nint dp[1<<MAXN][MAXN];\n\nint main(){\n  int n,e;cin>>n>>e;\n  rep(i, MAXN)rep(j, MAXN)d[i][j]=-1;\n  rep(i, e){\n    int s,t,dist;cin>>s>>t>>dist;\n    d[s][t]=dist;\n  }\n\n  rep(i, 1<<MAXN)rep(j, MAXN)dp[i][j]=INF;\n  // rep(i, n)dp[(1<<n)-1][i]=0;\n  dp[(1<<n)-1][0]=0;\n\n  for(int s=(1<<n)-2; s>=0; s--){\n    rep(from, n)rep(to, n){\n      // 頂点toに未到達 かつ fromからtoに行くパスが存在している\n      if( !(s>>to & 1) && d[from][to]>=0 ){\n        dp[s][from] = min( dp[s][from], dp[s | 1<<to][to] + d[from][to] );\n      }\n    }\n\n    // rep(i, 1<<n){rep(j, n)cout<<dp[i][j]<<' ';cout<<endl;}cout<<endl;\n\n  }\n\n  // int result = INF;\n  // rep(i, n)result = min(result, dp[0][i]);\n\n  cout<<(dp[0][0]==INF ? -1 :dp[0][0])<<endl;\n\n//  rep(i, 1<<n){rep(j, n)cout<<dp[i][j]<<' ';cout<<endl;}cout<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int INF = 1001001001;\nusing namespace std;\n///////////////////////////////////////\nstruct edge {\n\tint to, cost;\n\tedge(int a, int b) :to(a), cost(b) {}\n};\nint n, m;\nvector<edge>G[15];\nint dp[1 << 16][15];\nint solve(int s) {\n\tfill_n(*dp, (1 << 16) * 15, INF);\n\tdp[0][s] = 0;\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (dp[i][j] == INF)continue;\n\t\t\tfor (int k = 0; k < G[j].size(); ++k) {\n\t\t\t\tedge  &e = G[j][k];\n\t\t\t\tif (i>>e.to&1)continue;\n\t\t\t\tdp[i | (1 << e.to)][e.to] = min(dp[i | (1 << e.to)][e.to], dp[i][j] + e.cost);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[(1 << n) - 1][s];\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tG[a].push_back(edge(b,c));\n\t}\n\tint mi = INF;\n\tfor (int i = 0; i < n; ++i)mi = min(mi, solve(i));\n\tif (mi == INF)cout << -1 << endl;\n\telse cout << mi << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nusing usize = ::std::size_t;\n//using u64 = ::std::uint_least64_t;\ntypedef int u64;\n//static constexpr u64 Inf = ::std::numeric_limits<u64>::max() / 2;\nconst int Inf = 0x3f3f3f3f;\n\nu64 N, V, E;\nu64 dp[1 << 16][16], g[16][16];\n\nu64 dfs(int mask , int u){\n    \n    \n    if (mask == (1 << V) - 1) {\n        return g[u][0];\n    }\n    \n    if (~dp[mask][u]) return dp[mask][u];\n    \n    u64 r = Inf;\n    \n    for (int v = 0; v < V; v++) {\n        if (v != u && !(mask & (1 << v))) {\n            r = min(r, g[u][v] + dfs(mask | (1 << v), v));\n        }\n    }\n    \n    return dp[mask][u] = r;\n    \n}\n\nint main(int argc, char *argv[])\n{\n    \n \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> V >> E;\n    memset(g, Inf, sizeof(g));\n    for (int i = 0; i < E; i++) {\n        u64 v1, v2;\n        cin >> v1 >> v2;\n        cin >> g[v1][v2];\n    }\n    memset(dp, -1, sizeof(dp));\n    \n    dfs(1, 0);\n    \n    if (dp[1][0] >= Inf) {\n        cout << -1 << endl;\n    } else {\n        cout << dp[1][0] << endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nconst int INF = 10000000;\n \nint solve(vector<vector<int>> &dists)\n{\n    const int v = dists.size();\n \n    vector<vector<int>> dp(1 << v, vector<int>(v, INF));\n    dp[1][0] = 0;\n \n    const int all = (1 << v) - 1;\n \n    for (int S = 1; S <= all; S++)\n    {\n        int tS = S;\n        while (tS > 0) {\n            int bs = tS - (tS & ~(tS - 1));\n            int s = __builtin_ctzll(bs);\n            for (int e = 0; e < v; e++) {\n                if (dists[s][e] != INF && (~S & (1 << e)) != 0) {\n                    const int nS = S | (1 << e);\n                    if (nS == all) {\n                        dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e] + dists[e][0]);\n                    } else {\n                        dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e]);\n                    }\n                }\n            }\n            tS -= bs;\n        }\n    }\n \n    int ans = INF;\n    for (int i = 0; i < v; i++) {\n        ans = min(ans, dp[all][i]);\n    }\n    return ans == INF ? -1 : ans;\n}\n \nint main()\n{\n    int v, e;\n    cin >> v >> e;\n     \n    vector<vector<int>> dists(v, vector<int>(v, INF));\n    for (int i = 0; i < e; i++) {\n        int s, e, d;\n        cin >> s >> e >> d;\n        dists[s][e] = d;\n    }\n \n    cout << solve(dists) << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nint n,m,dp[(1 << 16)][15];\nvector<P> g[15];\n\nint solve(int s){\n\tREP(i, 0, (1 << 16)) REP(j, 0, 15) dp[i][j] = INF;\n\tdp[0][s] = 0;\n\t\n\tREP(i, 0, (1 << n)){\n\t\tREP(j, 0, n){\n\t\t\tif(dp[i][j] == INF) continue;\n\t\t\tfor(auto e:g[j]){\n\t\t\t\tif((i >> e.first) & 1) continue;\n\t\t\t\tdp[i | (1 << e.first)][e.first] = min(dp[i | (1 << e.first)][e.first], dp[i][j] + e.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[(1 << n) - 1][s];\n}\n\nint main(){\n\tcin >> n >> m;\n\tREP(i,0,m){\n\t\tint a,b,c; cin >> a >> b >> c;\n\t\tg[a].push_back({b, c});\n\t}\n\t\n\tint mi = INF;\n\tREP(i,0,n) mi = min(mi, solve(i));\n\tcout << (mi == INF ? -1 : mi) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint edge[15][15], v, e, dp[15][1 << 15];\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < v;i++){\n\t\tdp[i][0] = 0;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << v);i++){\n\t\tfor(int j = 0;j < v;j++){ // now place\n\t\t\tif(dp[j][i] != -1){\n\t\t\t\tfor(int k = 0;k < v;k++){ // next place\n\t\t\t\t\tif((i >> k & 1) == 0 && edge[j][k] != -1 && (dp[k][i | (1 << k)] == -1 || dp[k][i | (1 << k)] > dp[j][i] + edge[j][k])){\n\t\t\t\t\t\tdp[k][i | (1 << k)] = dp[j][i] + edge[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = -1;\n\tfor(int i = 0;i < v;i++){\n\t\tif(dp[i][(1 << v) - 1] != -1 && (ans == -1 || dp[i][(1 << v) - 1] < ans)){\n\t\t\tans = dp[i][(1 << v) - 1];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define RS resize\n#define CLR clear\n#define PB push_back\n#define ALL(x) (x).begin(), (x).end()\n#define LLI long long int\nusing namespace std;\n\nconst int inf = INT_MAX / 100;\n\nint TSP(vector<vector<int>> &graph, int src){\n  int v = graph.size(), n = 1 << v;\n  vector<vector<int>> dp(v, vector<int>(n, inf));\n\n  REP(i,v){\n    dp[i][1<<i] = graph[src][i];\n  }\n  \n  FOR(s,1,n){\n    REP(i,v){\n      if(!(s & (1<<i))) continue;\n      REP(j,v){\n\tif(s & (1<<j)) continue;\n\tdp[j][s | (1<<j)] = min(dp[j][s | (1<<j)], dp[i][s] + graph[i][j]);\n      }\n    }\n  }\n\n  return dp[src][n-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int v,e;\n  cin >> v >> e;\n  \n  vector<vector<int>> graph(v, vector<int>(v,inf));\n\n  REP(i,e){\n    int s,t,d; cin >> s >> t >> d;\n    graph[s][t] = d;\n  }\n\n  int ans = TSP(graph, 0);\n  cout << (ans>=inf ? -1 : ans) << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Traveling Salesman Problem - ?????????????????????????????? ?????¢???*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n\n#define V_MAX 15\nconst int INF=1<<30;\n\nint DP[1<<V_MAX][V_MAX]; //[S][now] : now ?????? U\\S ????¨???????0????????????????????????\nint G[V_MAX][V_MAX];\nint V,E;\nint rec(int S,int now){\n  if( DP[S][now] >= 0 ) return DP[S][now];\n  if( S == (1<<V)-1 && now==0 ) return DP[S][now]=0;\n  int ret=INF;\n  rep(v,V){\n    if(( S & (1<<v)) || G[now][v] == INF)continue;\n    ret = min( ret , rec(S | 1<<v,v)+G[now][v] );\n  }\n  return DP[S][now]=ret;\n}\n\nint main()\n{\n  cin>>V>>E;\n  rep(i,V)rep(j,V)G[i][j]=INF;\n  rep(i,1<<V)rep(j,V)DP[i][j]=-1;\n  rep(i,E){\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  int ans=rec(0,0);\n  cout<< (ans>=INF ? -1 : ans) <<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <algorithm> // std::min\n#include <limits> // std::numeric_limits\n#include <map> // std::map\n#include <utility> // std::pair, std::make_pair\n#include <vector> // std::vector\n\nusing ll = long long;\n\ntemplate <class AdjacencyMatrix, class Distance>\nDistance traveling_salesman_from(AdjacencyMatrix &a, size_t start) {\n    size_t n = a.size();\n    std::vector<std::vector<Distance>> dp(1 << n, std::vector<Distance>(n, std::numeric_limits<Distance>::infinity()));\n\n    for (size_t goal = 0; goal < n; ++goal) {\n        dp[0][goal] = a.distance(start, goal);\n    }\n\n    for (int b = 1; b < (1 << n); ++b) {\n        for (size_t goal = 0; goal < n; ++goal) {\n            if (b & (1 << goal)) {\n                continue;\n            }\n            for (size_t v = 0; v < n; ++v) {\n                if (v == start || v == goal || (b & (1 << v)) == 0) {\n                    continue;\n                }\n                dp[b][goal] = std::min(dp[b][goal], dp[b ^ (1 << v)][v] + a.distance(v, goal));\n            }\n        }\n    }\n    return dp[((1 << n) - 1) ^ (1 << start)][start];\n}\n\nclass adjacency_matrix {\nprivate:\n    const size_t n;\n    std::map<std::pair<size_t, size_t>, double> m;\npublic:\n    adjacency_matrix (size_t n) : n(n) { }\n    void make_edge(size_t from, size_t to, double weight) {\n        m[std::make_pair(from, to)] = weight;\n    }\n    size_t size() const {\n        return n;\n    }\n    double distance(size_t from, size_t to) {\n        auto e = std::make_pair(from, to);\n        if (m.count(e)) {\n            return m[e];\n        } else if (from == to) {\n            return 0.0;\n        } else {\n            return std::numeric_limits<double>::infinity();\n        }\n    }\n};\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    adjacency_matrix a(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t, d;\n        std::cin >> s >> t >> d;\n        a.make_edge(s, t, d);\n    }\n    double result = traveling_salesman_from<adjacency_matrix, double>(a, 0);\n    if (result == std::numeric_limits<double>::infinity()) {\n        result = -1;\n    }\n    std::cout << result << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define inf (1<<28)\n\nstruct g{\n  int to, cost;\n};\nint k;\nint v, e;\nvector<g> glaph[16];\nint dp[1<<15][15];\n\nint solve(int bit, int now){\n\n  int ret = inf;\n\n  if(dp[bit][now] != -1) return dp[bit][now];\n  if(bit == (1<<v)-1 && now == k){\n    return dp[bit][now] = 0;\n  }\n  for(int i = 0; i < (int)glaph[now].size(); i++){\n\n    if((bit & (1<<glaph[now][i].to)) == 0){\n      ret = min(ret, solve(bit | (1<<glaph[now][i].to), glaph[now][i].to) + glaph[now][i].cost);\n    }\n  }\n  return dp[bit][now] = ret;\n}\n\n\nint main(){\n\n  cin >> v >> e;\n\n\n\n  for(int i = 0; i < e; i++){\n    int s, t, d;\n    cin >> s >> t >> d;\n    glaph[s].push_back((g){t,d});\n  }\n\n  // for(int i = 0; i < v; i++) glaph[i][i] = 0;\n  /*\n  for(int a = 0; a < v; a++){\n    for(int b = 0; b < v; b++){\n      for(int c = 0; c < v; c++){\n\tglaph[b][c] = min(glaph[b][c], glaph[b][a] + glaph[a][c]);\n      } \n    } \n  }\n  */\n  int ans = inf;\n  for(int i = 0; i < v; i++){\n    memset(dp,-1,sizeof(dp));\n    k = i;\n    ans = min(solve(0,i),ans);\n  }\n  if(ans != inf)  cout << ans << endl;\n  else cout << -1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n#define INF 1e9\n// const ll INF = 1LL << 60;\n\nint V, E;\nvector<vector<int>> g;\nint dp[1<<20][20];\n\nvoid solve(){\n  REP(bit, 1<<V){\n    REP(i, V){\n      if(bit != 0 && (bit>>i & 1)==0) continue;\n      REP(j, V){\n        if(bit >> j & 1) continue;\n        dp[bit|1 << j][j] = min(dp[bit|1<<j][j], dp[bit][i] + g[i][j]);\n      }\n    }\n  }\n}\n\nint rec(int bit, int v){\n  if(dp[bit][v] != -1){\n    return dp[bit][v];\n  }\n  if(bit == 1){\n    return dp[bit][v] = g[v][0];\n  }\n  int ans = INF;\n  FOR(nv, 1, V){\n    if(!(bit & 1<<nv)) continue;\n    int nbit = bit & ~(1<<nv);\n    ans = min(ans, rec(nbit, nv)+g[v][nv]);\n  }\n  return dp[bit][v] = ans;\n}\nint main(){\n  cin >> V >> E;\n  g.resize(V, vector<int>(V, INF));\n  REP(i, E){\n    int s, t, d;\n    cin >> s >> t >> d;\n    g[s][t] = d;\n  }\n  REP(i, 1<<20){\n    REP(j, 20){\n      dp[i][j] = -1;\n    }\n  }\n  rec((1<<V)-1, 0);\n  if(dp[(1<<V)-1][0] >= INF){\n    cout << -1 << endl;\n  }\n  else{\n    cout << dp[(1<< V)-1][0] << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst int M = 20;\nWeight best[1<<M][M];\nint    prev[1<<M][M];\nvoid buildPath(int S, int i, vector<int> &path) {\n  if (!S) return;\n  buildPath(S^(1<<i), prev[S][i], path);\n  path.push_back(i);\n}\nWeight shortestHamiltonCycle(Matrix w, vector<int> &path) {\n  int n=w.size();\n  int N = 1 << n;\n  REP(S,N) REP(i,n) best[S][i] = INF;\n  best[0][0] = 0;\n  REP(S,N) REP(i,n) REP(j,n) if (!(S&(1<<j)))\n    if (best[S|(1<<j)][j] > best[S][i] + w[i][j])\n      best[S|(1<<j)][j] = best[S][i] + w[i][j],\n      prev[S|(1<<j)][j] = i;\n  //int t = min_element(best[N-1], best[N-1]+n) - best[N-1];\n  //path.clear(); buildPath(N-1, t, path);\n  return best[N-1][0]==INF ? -1 : best[N-1][0];\n}\n\nint main(){\n\tint V,E,s,t,d;\n\tscanf(\"%d%d\",&V,&E);\n\tMatrix m(V,Array(V));\n\tfor(s=0;s<V;s++)for(t=0;t<V;t++)if(s!=t)m[s][t]=INF;\n\tvector<int>path;\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&d),m[s][t]=d;\n\tprintf(\"%d\\n\",shortestHamiltonCycle(m,path));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 99999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint M=INF;\nvoid salesman(const Graph g,int s, int w,vector<int>path) {\n\tif(path.size()==g.size()){\n\t\tif(s==0&&M>w)M=w;\n\t\treturn;\n\t}\n\tFOR(e,g[s])if(w+e->weight<M&&find(path.begin(),path.end(),e->dst)==path.end()){\n\t\tpath.push_back(e->dst);\n\t\tsalesman(g,e->dst,w+e->weight,path);\n\t\tpath.pop_back();\n\t}\n}\n\nint main(){\n\tint T,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g(V);\n\t\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&e),g[s].push_back(Edge(s,t,e));\n\t\tvector<int>path;\n\t\tsalesman(g,0,0,path);\n\t\tprintf(\"%d\\n\",M==INF?-1:M);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define maxi 1000000000\nusing namespace std;\n\nvector < vector < int > > g, mas, reb;\n\nint getbit(int mask, int num){\n\treturn (mask >> num) & 1;\n}\nint addbit(int mask, int num){\n\treturn mask | (1 << num);\n}\n\nint main(){\n\tint n,m,a,b,c;\n\tcin >> n >> m;\n\tint nn = (1 << n);\n\n\treb.resize(n);\n\tfor(int i=0; i<n; i++)\n\t\treb[i].resize(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\treb[i][j] = -1;\n\t\t}\n\t}\n\n\tmas.resize(n);\n\tfor(int i=0; i<n; i++)\n\t\tmas[i].resize(nn);\n\n\tg.resize(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> a >> b >> c;\n\t\tg[a].push_back(b);\n\t\treb[a][b] = c;\n\t}\n\n\tmas[0][1] = 1;\n\tint nextvert, nextmask;\n\n\tfor(int mask = 1; mask < nn - 1; mask+=2){\n\t\tfor(int vert=0; vert<n; vert++){\n\t\t\tif(mas[vert][mask] != 0){\n\t\t\t\tfor(int e=0; e<g[vert].size(); e++){\n\t\t\t\t\tnextvert = g[vert][e];\n\t\t\t\t\tif(!getbit(mask,nextvert)){\n\t\t\t\t\t\tnextmask = addbit(mask,nextvert);\n\t\t\t\t\t\tif(mas[nextvert][nextmask] == 0 || mas[nextvert][nextmask] > mas[vert][mask] + reb[vert][nextvert]){\n\t\t\t\t\t\t\tmas[nextvert][nextmask] = mas[vert][mask] + reb[vert][nextvert];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*//\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<nn; j++){\n\t\t\tcout << mas[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t//*/\n\n\tint mask = nn - 1; int mi = maxi;\n\tfor(int vert=0; vert<n; vert++){\n\t\tif(reb[vert][0] != -1 && mas[vert][mask] != 0 && mi > mas[vert][mask] + reb[vert][0]){\n\t\t\tmi = mas[vert][mask] + reb[vert][0];\n\t\t}\n\t}\n\n\tif(mi != maxi){\n\t\tcout << mi - 1;\n\t}else{\n\t\tcout << -1;\n\t}\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define INF 100100100\n\nint main(){\n\n  int v, e; cin >> v >> e;\n  int n = v;\n  vector<vector<int> > dis(v, vector<int> (v, INF));\n  for(int i = 0; i < e; i++){\n    int a, b, c; cin >> a >> b >> c;\n    dis[a][b] = c;\n  }\n\n  vector<vector<int> > dp((1 << n), vector<int> (n, INF));\n  dp[0][0] = 0;\n  for(int i = 0; i < (1 << n); i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < v; k++){\n        if((i & (1 << k)) != 0) continue;\n\n        int cost = dp[i][j] + dis[j][k];\n\n        chmin(dp[i | (1 << k)][k], cost);\n      }\n    }\n  }  \n\n  if(dp[(1 << v) - 1][0] == INF) cout << -1 << endl;\n  else cout << dp[(1 << v) - 1][0] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll;\nconst int INF = 10000000;\nint n, e;\nint d[15][15], dp[1 << 15][15];\nint rec(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) return dp[s][v] = 0;\n\telse if (dp[s][v] != -1) return dp[s][v];\n\telse {\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!(s >> i & 1)) res = min(res, d[v][i] + rec(s | 1 << i, i));\n\t\t}\n\t\treturn dp[s][v] = res;\n\t}\n}\nint main() {\n\tcin >> n >> e;\n\tfill(d[0], d[15], INF);\n\tfill(dp[0], dp[1 << 15], -1);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, dis; cin >> s >> t >> dis;\n\t\td[s][t] = dis;\n\t}\n\tcout << rec(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit(int mask, int num) \n{\n\treturn (mask >> num)&1;\n}\ninline int add_bit(int mask, int num) \n{\n\treturn (mask + (1 << num));\n}\n\n\nint main()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tscanf(\"%d %d\", &n, &m);\n\tvector<vector<pair<int,int>>> graph(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tint source, destiny, len;\n\t\tscanf(\"%d %d %d\", &source, &destiny, &len);\n\t\tgraph[source].push_back(make_pair(destiny, len));\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\t\n\tint max_mask = pow(2,n);\n\tvector<vector<int>> dp(max_mask, vector<int>(n,-1));\n\tdp[1][0] = 0;\n\tfor (int mask = 1; mask < max_mask; mask++) \n\t{\n\t\tfor (int vertex = 0; vertex < n; vertex++)\n\t\t{\n\t\t\tfor (i = 0; i < graph[vertex].size(); i++)\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif (!get_bit(mask, next)) \n\t\t\t\t{\n\t\t\t\t\tif ((dp[add_bit(mask,next)][next] < dp[mask][vertex])||(-1 == dp[add_bit(mask,next)][next])) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit(mask,next)][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor (i = 1; i < n; i++) \n\t{\n\t\tfor (j = 0; j < graph[i].size(); j++) \n\t\t{\n\t\t\tif (0 == graph[i][j].first) \n\t\t\t{\n\t\t\t\tif ((result > dp[max_mask-1][i] + graph[i][j].second) || (result = -1)) \n\t\t\t\t{\n\t\t\t\t\tresult = dp[max_mask-1][i] + graph[i][j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\", result);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nconst ll mod = 1000000007;\n\nll rec(ll n, vvll& dist, vvll& dp, ll s, ll v) {\n  if (dp[s][v] != -1) return dp[s][v];\n\n  if (s == (1 << v)) {\n    return dp[s][v] = INF;\n  }\n\n  ll ans = INF;\n  ll prevs = s & ~(1 << v);\n  rep(i, n) {\n    bool conda = (prevs & (1 << i)) > 0;\n    bool condb = (dist[i][v] != INF);\n    bool cond = conda && condb;\n    if (!cond) continue;\n    ll tmp = min(INF, rec(n, dist, dp, prevs, i) + dist[i][v]);\n    chmin(ans, tmp);\n  }  // i\n\n  return (dp[s][v] = ans);\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n\n  vvll dist(n, vll(n, INF));\n  vvll dp(1 << n, vll(n, -1));\n\n  rep(i, m) {\n    ll s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n\n  ll ans = INF;\n  dp[1][0] = 0;\n  rep(i, n) {\n    if (i == 0) continue;\n    ll tmp = rec(n, dist, dp, ((1 << n) - 1), i) + dist[i][0];\n    chmin(ans, tmp);\n  }\n\n  if (ans == INF) {\n    ans = -1;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\n#define INF 1000000\n\nint main()\n{\n  int v,e;cin>>v>>e;\n  vector<int> s(e);\n  vector<int> t(e);\n  vector<int> d(e);\n  int i,j,k;\n  rep(i,e)cin>>s[i]>>t[i]>>d[i];\n  vector<vector<int>> g(v,vector<int>(v,INF));\n  rep(i,e)\n  {\n    g[s[i]][t[i]]=d[i];\n  }\n  int ans=INF;\n  bool exist=false;\n  vector<vector<int>> dp(1<<v,vector<int>(v,INF));\n  dp[0][0]=0;\n  rep(i,1<<v)\n  {\n    rep(j,v)\n    {\n      rep(k,v)\n      {\n        if(g[j][k]==INF)continue;\n        if(i&(1<<k))continue;\n        int to=(i|(1<<k));\n        dp[to][k]=min(dp[to][k],dp[i][j]+g[j][k]);\n      }\n    }\n  }\n  if(dp[(1<<v)-1][0]==INF)cout<<-1<<endl;\n  else cout<<dp[(1<<v)-1][0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nconst int MAX_V = 15;\nconst int INF = 1e9;\n  \nint V,E;\nint d[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\n \n//bitDP\n//????????????v?????????????????????????????????????????????£???v?????????£??????????????????????????????\n// = ??????0??????????????????????????????£????????????????????????0?????????£?????????\n \nint dfs(int mask,int v){\n    if(mask==(1<<V)-1) return d[v][0];\n    if(dp[mask][v]!=-1) return dp[mask][v];\n    int res = INF;\n    rep(u,V){\n        if(d[v][u]==INF || (mask&(1<<u))) continue;\n        res = min(res, dfs(mask|(1<<u),u)+d[v][u]);\n    }\n    return dp[mask][v] = res;\n}\n \nint main() {\n    cin>>V>>E;\n    rep(i,V)rep(j,V) d[i][j]=INF;\n    rep(i,V) d[i][i]=0;\n    rep(i,E){\n        int s,t;\n        cin>>s>>t;\n        cin>>d[s][t];\n    }\n    memset(dp, -1, sizeof(dp));\n    int res=dfs(1,0);\n    cout<<(res==INF ? -1 : res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Traveling Salesman Problem - ?????????????????????????????? ?????¢???*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n\n#define V_MAX 15\nconst int INF=1<<30;\nint DP[1<<V_MAX][V_MAX]; //[S][now] : now ?????? U\\S ????¨???????0????????????????????????\nint G[V_MAX][V_MAX];\n\nint V,E;\n\nint rec(int S,int now){\n  if(DP[S][now]>=0)return DP[S][now];\n  if(S==(1<<V)-1 and now==0)return DP[S][now]=0;\n  int ret=INF;\n  rep(v,V){\n    if( S & (1<<v) )continue;\n    if(G[now][v] == INF)continue;\n    \n    ret = min( ret , rec(S|(1<<v),v) ) + G[now][v];\n  }\n  return DP[S][now]=ret;\n}\n\nint main()\n{\n  cin>>V>>E;\n  rep(i,V)rep(j,V)G[i][j]=INF;\n  rep(i,1<<V)rep(j,V)DP[i][j]=-1;\n  rep(i,E){\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  int ans=rec(0,0);\n  cout<< (ans>=INF ? -1 : ans) <<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF=1e9+10;\n\n\nint main()\n{\n    int V,E;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin>>V>>E)\n    {\n        vector<vector<int> > mat(20,vector<int>(20));\n        vector<vector<int> > dp(1<<V,vector<int>(V));\n        for(int i=0;i<mat.size();i++)\n        {\n            fill(mat[i].begin(),mat[i].end(),INF);\n        }\n        for(int i=0;i<E;i++)\n        {\n            int s,t,d;\n            cin>>s>>t>>d;\n            mat[s][t]=d;\n\n        }\n        for(int i=0;i<dp.size();i++)\n        {\n            fill(dp[i].begin(),dp[i].end(),INF);\n        }\n        dp[0][0]=0;\n        for(int i=0;i<(1<<V);i++)\n        {\n            for(int j=0;j<V;j++)\n            {\n                for(int k=0;k<V;k++)\n                {\n                    if(!(i>>k&1))\n                    {\n                        dp[i^(1<<k)][k]=min(dp[i][j]+mat[j][k],dp[i^(1<<k)][k]);\n                    }\n                }\n            }\n        }\n        cout<<(dp[(1<<V)-1][0]==INF?-1:dp[(1<<V)-1][0])<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//巡回セールスマン\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct{\n  int cost,to;\n}Edge;\n\nint v,e;\nvector<Edge>G[16];\nint ans=-1;\nint starts;\n\nvoid bitdp(int bit,int cnt,int now);\n\n\nint main(){\n  cin>>v>>e;\n  for(int i=0,a,b,c;i<e;i++){\n    cin>>a>>b>>c;\n    G[a].push_back((Edge){c,b});\n    //  G[b].push_back((Edge){c,a});\n  }\n  for(int i=0;i<v;i++){\n    for(int j=0;j<G[i].size();j++){\n      int a=0;\n      starts=i;\n      bitdp(0,G[i][j].cost,G[i][j].to);\n      //cout<<\"OUOU\"<<endl;\n      a=0;\n    }\n  }\n  cout<<ans<<endl;\n}\n\nvoid bitdp(int bit,int cnt,int now){\n  int temp;\n  int co=0;\n  temp=bit;\n  if(bit & 1<<now)return; \n  bit=bit | 1<<now;\n  //  bitset<4>bs((long)bit);\n  //  cout<<cnt<<\" \"<<now<<\" \" <<bs<<endl;\n\n  //カウント\n  for(int i=0;i<v;i++){\n    if(bit & 1<<i)co++;\n    else break;\n  }\n  if(co==v && now==starts){\n    // cout<<cnt<<endl;\n    if(ans==-1)ans=cnt;\n    else ans=min(ans,cnt);\n    return;\n  }\n  \n  //そのエッジからの道\n  for(int i=0;i<G[now].size();i++){  \n    bitdp(bit,cnt+G[now][i].cost,G[now][i].to);\n    bit=temp;\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint path[15][15];\nint dp[1 << 15][15];\nconst int INF = 999999;\n\nint main()\n{\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tfor (int j = 0; j < 15; j++)\n\t\t{\n\t\t\tpath[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << 15); i++)\n\t{\n\t\tfor (int j = 0; j < 15; j++)\n\t\t{\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\tint V, E;\n\tcin >> V >> E;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tpath[s][t] = d;\n\t}\n\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << V); i++)\n\t{\n\t\tfor (int j = 0; j < V; j++)\n\t\t{\n\t\t\tif (dp[i][j] == INF) continue;\n\t\t\tfor (int k = 0; k < V; k++)\n\t\t\t{\n\t\t\t\tif (i & (1 << k)) continue;\n\t\t\t\tif (path[j][k] == INF) continue;\n\t\t\t\tdp[i + (1 << k)][k] = min(dp[i + (1 << k)][k], dp[i][j] + path[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << V) - 1][0] == INF) cout << -1 << endl;\n\telse cout << dp[(1 << V) - 1][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 15;\nconst int INF = 1<<29;\n\nint main(int argc, char const *argv[])\n{\n    int n, e;\n    int d[MAX_N][MAX_N];\n    cin >> n >> e;\n\n    for (int i = 0; i < n; ++i) {\n        fill(d[i], d[i]+n, INF);\n    }\n\n    for (int i = 0; i < e; ++i) {\n        int si, ti, di;\n        cin >> si >> ti >> di;\n        d[si][ti] = di;\n    }\n\n    int dp[1<<MAX_N][MAX_N];\n\n    for (int i = 0; i < 1<<n; ++i) {\n        fill(dp[i], dp[i]+n, INF);\n    }\n\n    dp[(1<<n)-1][0] = 0;\n\n    for (int s = (1<<n) - 2; s >= 0 ; s--) {\n        for (int v = 0; v < n; ++v) {\n            for (int u = 0; u < n; ++u) {\n                if (!(s >> u & 1)) {\n                    dp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n\n    int ans;\n\n    if (dp[0][0]<INF) {\n        ans = dp[0][0];\n    }\n    else {\n        ans = -1;\n    }\n\n    printf(\"%d\\n\", ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\nvoid chmin (int &a, int b) {\n\tif (a > b) a = b;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> g(n, vector<int>(n, INF));\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tg[a][b] = c;\n\t}\n\n\tvector<vector<int>> dp(1 << n, vector<int>(n, INF));\n\tdp[0][0] = 0;\n\t\n\tfor (int s = 0; s < (1 << n); s++) {\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (u == v or (s & (1 << u))) continue;\n\t\t\t\tchmin(dp[s | (1 << u)][u], dp[s][v] + g[v][u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = dp[(1 << n) - 1][0];\n\tif (ans == INF) ans = -1;\n\t\n\tcout << ans << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <climits>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\n#define MAX_V 16\nint adjMat[MAX_V][MAX_V];\nbool visited[MAX_V][1<<MAX_V];//visited????????????????????????????¨???????,????????????????????????????????????\nint dp[MAX_V][1<<MAX_V];//DP??¨???,?¬¬???????????¬?????£??¨???????????¨??????\n//?¬¬???????????¬?????£??¨?????????????????????(ex:0101011,??¨???1,3,5??????????????°???,?????\\??´??\\??¨bitwise?????????????????????)\n//??????DP??¨??????N*2^N?¬????,?????\\????????????????°±???O(N*2^N)\nint v,e;\n\nconst char *byte_to_binary(int x)\n{\n    static char b[9];\n    b[0] = '\\0';\n\n    int z;\n    for (z = 128; z > 0; z >>= 1)\n    {\n        strcat(b, ((x & z) == z) ? \"1\" : \"0\");\n    }\n\n    return b;\n}\nint TSP(int at,int state)\n{\n    // printf(\"at=%d,state=%s\\n\",at, byte_to_binary(state));\n    if(state == (1<<v)-1 && at==0){ //??¨??¨??????????????°??????????????°?????????\n        visited[at][state]=true;\n        return dp[at][state];\n    }\n    if(dp[at][state]) //??????????????????,??´??\\????????????\n        return dp[at][state];\n    int ans = INT_MAX>>1;\n    int cost;\n    for(int i=0;i<v;i++){\n        //state&(1<<i)==0??¨?????????????????????????¬¬i???bit?????????0,??¨?????????????????????????????°???\n        //state|(1<<i)??¨????°???????????¨??????°???\n        if(adjMat[at][i]!=-1 && (state & (1<<i))==0){\n            // printf(\"at=%d->i=%d\\n\",at,i);\n            cost = TSP(i,state|(1<<i)) + adjMat[at][i];//???????¨??????\\??°??????????????°??????\n            // printf(\"at=%d->i=%d,cost=%d\\n\",at,i,cost);\n            ans = min(ans,cost);//?±????????°????\n        }\n    }\n    return dp[at][state] = ans;\n}\n//\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d %d\",&v,&e)){\n        memset(adjMat,-1,sizeof(adjMat));\n        for(int i=0;i<e;i++){\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            adjMat[u][v]=w;\n        }\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        int ans = TSP(0,0);\n        if(ans>=INT_MAX>>1)\n            puts(\"-1\");\n        else\n            printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n// rec(S_bit, v) dp[S_bit][v] を再帰的に求める\n// v \\in S を仮定\nint rec(int S_bit, int v, vector<vector<int>> edges, vector<vector<int>>& dp, int V){\n    if(dp[S_bit][v] != -1) return dp[S_bit][v];\n    else{\n        int INF = 1<<30;\n        int ans = INF;\n        for(int u=0; u<V; u++){ \n            if(u == v) continue;\n            int v_bit = 1<<v;\n            int u_bit = 1<<u;\n            int prev_S_bit = S_bit & (~v_bit);\n            if((S_bit & u_bit) == u_bit && edges[u][v] != -1){\n                // u -> v の辺がある\n                int d_u = rec(prev_S_bit, u, edges, dp, V);\n                if(d_u == -1) continue;\n                if(ans > d_u + edges[u][v]){\n                    ans = d_u + edges[u][v];\n                }\n            }\n        }\n        return dp[S_bit][v] = ans;\n    }\n}\n\nsigned main(){\n    // cout << fixed << setprecision(10) << flush;\n\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> edges(V, vector<int>(V, -1));\n    for(int i=0; i<E; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edges[s][t] = d;\n    }\n\n    int INF = 1<<30;\n\n    // dp[bit][v] は bit の頂点をすべて回る経路の距離のうち、0 で始まり v で終わるものの最小値\n    vector<vector<int>> dp(1<<V, vector<int>(V, -1));\n    dp[1<<0][0] = 0;\n\n    int U = (1<<V)-1, res = INF;\n    for(int v=0; v<V; v++){\n        // スタート は 0 としてもよい、どうせ一回は通るので\n        if(edges[v][0] != -1){\n            int r = rec(U, v, edges, dp, V);\n            if(res > r + edges[v][0]){\n                res = r + edges[v][0];\n            }\n        }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    rep(i, v){\n        cost[1][0] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, v){\n        if(ans > cost[(1 << v) - 1][i] + edge[i][0]){\n            ans = cost[(1 << v) - 1][i] + edge[i][0];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PL;\n#define rep(i, srt, end) for (long long i = (srt); i < (long long)(end); i++)\n\nll V, E;\nvector< vector< pair<ll,ll> > > G;\nll rec[15][1<<15];\nconst ll INF = 1e9;\n\nvoid rec_init() {\n    rep(i, 0, 15) rep(j, 0, 1<<15) rec[i][j] = -1;\n}\n\nll dfs(int bit, ll last, ll srt) {\n\n    // check memo\n    if(rec[last][bit] != -1) return rec[last][bit];\n\n    // end point\n    if(bit == (1<<last)){\n        for(PL g : G[last]) {\n            if(g.first == srt) return rec[last][bit] = g.second;\n        }\n        return rec[last][bit] = INF;\n    }\n\n    // move to previous node\n    ll res = INF;\n    int prev = bit & ~(1<<last);\n    for(PL g : G[last]){\n        if(!(prev & (1<<g.first))) continue;\n        res = min(res, dfs(prev, g.first, srt) + g.second); \n    }\n\n    // return\n    return rec[last][bit] = res;\n}\n\nint main(){\n\n    // input\n    cin >> V >> E;\n    G.resize(V);\n    rep(i, 0, E){\n        ll s, t, d;\n        cin >> s >> t >> d;\n        G[t].push_back({s, d});\n    }\n\n    // memorizing dfs\n    ll ans = INF;\n    rep(srt, 0, V){\n        rec_init();\n        ans = min(ans, dfs((1<<V)-1, srt, srt));\n    }\n\n    // output\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\n\nconst int inf = INT_MAX / 3;\nconst int max_v = 15;\n\nint d[max_v][max_v];\nint dp[(1 << max_v) - 1][max_v];  // S?????¢????????£????????????????????????v??????????????´???\n\n\nusing namespace std;\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\td[i][j] = (i == j) ? 0 : inf;\n\n\t\t}\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint ts,tt , td;\n\t\tcin >> ts >> tt >> td;\n\t\td[ts][tt] = td;\n\t}\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tdp[s][v] = inf;\n\t\t}\n\t}\n\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tfor (int u = 0; u < V;u++) {\n\t\t\t\t//cout << \"s:\" << s << \" v:\" << v << \" u:\" << u << endl;\n\t\t\t\tif (!((s >> u) & 1)) {\n\t\t\t\t\tdp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[u][v]);\n\t\t\t\t//\tcout << \" dp:\" << dp[s][v] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[0][0] >= inf) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << dp[0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double lb;\n#define rep(i,j,n) for (ll i = j; i < (n); i++)\n#define repr(i,j,n) for(ll i = j; i >= (n); i--)\n#define all(x) (x).begin(),(x).end()\n#define CLR(mat,f) memset(mat, f, sizeof(mat))\n#define IN(a, b, x) (a<=x&&x<b)\n#define out(ans) cout << ans << endl\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\ntypedef pair<ll,ll>P;\nconst ll mod=1e9+7;\nconst ll INF = 1LL<<60;\nconst ll m=1LL<<32;\n\nint main(){\n\n  ll V,E;cin>>V>>E;\n  ll dist[V][V];\n  // CLR(dist,0);\n  rep(i,0,V)rep(j,0,V)dist[i][j]=INF;\n  rep(i,0,E){\n    ll a,b,d;cin>>a>>b>>d;\n    dist[a][b]=d;\n  }\n\n  ll dp[(1<<V)][V];\n  rep(i,0,(1<<V))rep(j,0,V)dp[i][j]=INF;\n  dp[1][0]=0;\n\n  rep(bit,0,(1<<V)){\n    rep(i,0,V){\n      if(dp[bit][i]==INF)continue;\n      rep(j,0,V){\n        if((bit>>j)%2==1)continue;\n\n        ll next=bit|(1<<j);\n        chmin(dp[next][j],dp[bit][i]+dist[i][j]);\n      }\n    }\n  }\n  \n  ll all=(1<<V)-1;\n  ll ans=INF;\n  rep(i,0,V){\n    if(dp[all][i]==INF)continue;\n    chmin(ans,dp[all][i]+dist[i][0]);\n  }\n  \n  if(ans==INF)out(-1);\n  else out(ans);\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int inf = 0x3f3f3f3f;\nconstexpr ll linf = 0x3f3f3f3f3f3f3f3fLL;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e; cin >> v >> e;\n    vector<vector<int>> g(v, vector<int>(v, inf));\n    for (int i = 0; i < e; i++) {\n        int s, t, d; cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    vector<vector<int>> dp(1 << v, vector<int>(v, inf));\n    dp[0][0] = 0;\n    for (int i = 0; i < (1 << v); i++) {\n        for (int j = 0; j < v; j++) {\n            if ((i >> j) & 1) continue;\n            for (int k = 0; k < v; k++) {\n                if (g[j][k] >= inf) continue;\n                dp[i | (1 << j)][k] = min(dp[i | (1 << j)][k], dp[i][j] + g[j][k]);\n            }\n        }\n    }\n    cout << (dp[(1 << v) - 1][0] < inf ? dp[(1 << v) - 1][0] : -1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int v, int used) {\n    if (used == (1 << V) - 1) return G[v][0];\n    if (memo[v][used] >= 0) return memo[v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || G[v][u] == INF || (used & (1 << u))) continue;\n        chmin(ret, dfs(u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[v][used] = ret;\n}\nint TSP() {\n    init();\n    return dfs(0, 1);\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans >= INF ? -1 : Ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(((1 << k) & tmp) == 0) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    for(int i = 0; i < v; i++){\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ninline int getbit(int mask, int v) {\n    return (mask >> v) & 1;\n}\n\ninline int newmask(int mask, int v) {\n    return mask | (1 << v);\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int cost[n][n];\n    vector <int> g[n];\n    int x, y, c;\n    for (int i = 0; i < m; i++) {\n        cin >> x >> y >> c;\n        g[x].push_back(y);\n       // g[y].push_back(x);\n        cost[x][y] = c;\n       // cost[y][x] = c;\n    }\n    int P = pow(2, n);\n    int d[P][n];\n    for (int i = 1; i < P; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = -1;\n        }\n    }\n    d[1][0] = 0;\n    const int INF = 1e9;\n    int ans = INF;\n    for (int mask = 1; mask < P; mask++) {\n        for (int v = 0; v < n; v++) {\n            if (d[mask][v] != -1) {\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    int u = g[v][i];\n                    if (mask < P - 1) {\n                        if (!getbit(mask, u)) {\n                            d[newmask(mask, u)][u] = d[mask][v] + cost[v][u];\n                        }\n                    } else {\n                        if (u == 0) {\n                            ans = min(ans, d[mask][v] + cost[v][0]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (ans == INF) {\n        cout << -1;\n    } else {\n        cout << ans;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint dp[1 << 20][20];\n\nint dist[20][20];\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  fill((int*)dist, (int*)dist + sizeof(dist) / sizeof(int), INF);\n  for(int i = 0; i < m; ++i){\n  \tint s, t, d;\n  \tcin >> s >> t >> d;\n  \tdist[s][t] = d;\n  }\n\n  for(int i = 0; i < (1 << 20); ++i){\n  \tfor(int j = 0; j < 20; ++j){\n  \t\tdp[i][j] = INF;\n  \t}\n  }\n\n  dp[0][0] = 0; \n  for(int s = 0; s < (1 << n); ++s){\n  \tfor(int v = 0; v < n; ++v){ \n  \t\tif(!(s & (1 << v)))continue;\n  \t\tint prev_s = s - (1 << v); \n  \t\tfor(int u = 0; u < n; ++u){ \n   \t\t\tdp[s][v] = min(dp[s][v], dp[prev_s][u] + dist[u][v]);\n  \t\t}\n  \t}\n  }\n\n  if(dp[(1 << n) - 1][0] == INF)cout << -1 << endl;\n  else cout << dp[(1 << n) - 1][0] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 15;\nconst int MAX_M = 225\n\nint n,m;\nll dp[1 << MAX_N][MAX_N];\nll d[MAX_N][MAX_N];\nint s[MAX_M];\nint t[MAX_M];\nint D[MAX_M];\n\nll solve()\n{\n\trep(S,1<<n){\n\t\tfill(dp[S],dp[S]+n,INF);\n\t}\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\trep(v,n){\n\t\t\trep(u,n){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tll ans=INF-1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> s[i] >> t[i] >> D[i];\n\t}\n\trep(i,n){\n\t\tfill(d[0],d[n],INF);\n\t\trep(j,m){\n\t\t\td[(s[j]+n-i)%n][(t[j]+n-i)%n] = D[j];\n\t\t} \n\t\tans = min(ans,solve());\n\t}\n\tif(ans > 16000){\n\t\tcout << \"-1\\n\";\n\t}else{\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 2000000000\n#define int long long int\n#define MOD 1000000007\n#define pb push_back\n#define cin1(n) (cin >> n)\n#define cin2(a,b) (cin >> a >> b)\n#define cin3(a,b,c) (cin >> a >> b >> c)\n#define cout(n) (cout << n << endl)\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define fr first \n#define sc second \n#define EPS (1e-10)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector< vector<int> > vvi;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<string> vs;\ntypedef vector<vector<string>> vss;\ntypedef pair<int,int> pii;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint a,b;\nint p,q;\n\n\nsigned main() {\n\n\tint V,E; cin2(V,E);\n\n\tvvi edge(V,vi(V,INF));\n\n\trep(i,0,E) {\n\t\tint s,t; cin2(s,t);\n\t\tint d; cin >> d;\n\t\tedge[s][t] = d;\n\t}\n\tvvi dp((1 << V),vi(V, INF));\n\tdp[0][0]=0;\n\n\trep(i,0,(1 << V)) {\n\t\trep(j,0,V) {\n\t\t\trep(k,0,V) {\n\t\t\t\tif ((i & (1 << k)) != 0) continue;\n\n\t\t\t\tint cost = dp[i][j] + edge[j][k];\n\t\t\t\tif (cost < dp[i | (1 << k)][k]) {\n\t\t\t\t\tdp[i | (1 << k)][k] = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(dp[(1 << V)-1][0] == INF){\n\t\tcout << -1 << endl;\n\t}else {\n\t\tcout << dp[(1 << V)-1][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\ntypedef pair<int, int> P;\nstruct edge { int to, cost; };\n\nconst int MAX_V =500000;\nconst int INF = 1LL<<30;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s) {\n    // greater<P>を指定することでfirstが小さい順に取り出せるようにする\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        rep(i,G[v].size()) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main() {\n    int N, E, s, t, e;\n    cin >> N >> E;\n    if (E == 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    V = (1 << N) * N;\n    rep(i, E) {\n        cin >> s >> t >> e;\n        rep(j, 1 << N) {\n            G[(1 << N) * s + (j | (1 << t)) ^ (1 << t)].push_back({(1 << N) * t + (j | (1 << t)), e});\n            //G[(1 << N) * s + j].push_back({(1 << N) * t + (j | (1 << t)), e});\n        }\n    }\n    dijkstra(0);\n    int ans = d[(1 << N) - 1];\n    if (ans == INF) cout << \"-1\\n\";\n    else cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint dp[(1 << 15)][15];\nint d[15][15];\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = INF;\n        }\n    }\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    int ans = INF;\n    rep(id,n){\n        rep(i,(1 << n)){\n            rep(j,n){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][id] = 0;\n        rep(i,1<<n){\n            rep(j,n){\n                rep(k,n){\n                    if(!(i & (1 << k))){\n                        dp[i|(1<<k)][j] = min(dp[i|(1<<k)][j],dp[i][k] + d[k][j]);\n                    }\n                }\n            }\n        }\n        rep(i,n){\n            ans = min(ans,dp[(1<<n)-1][id]);\n        }\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n5 10\n3 2 1\n2 1 1\n1 0 3\n0 4 5\n3 0 6\n4 2 7\n2 3 0\n3 4 2\n4 1 7\n2 4 3\n*/\n\n\n#include <bits/stdc++.h>\n#define MAX 20\n#define INF LLONG_MAX\nusing namespace std;\n\ntypedef long long int ll;\n\nll wt[MAX][MAX];\n\n// O based indexing is being used for ease\n// Node 1 will be represented at the Lowest Significant bit of the number\n// Simply subtract one from each Node number incase the nodes are one based\n// n is the number of cities\n\n// Logic in short:\n// Suppose we have some elements in the Set A (i)\n// We see all the cities (in set A only) at which ending is possible\n// Let the possible ending be j\n// Since we have already calculated all these values for the present set i.e dp[i][j]\n// We see other cities which have not been included in the set A\n// Let these non included cities be k\n// Let a new set B = set A U {k} \n// Let set B be called p\n// dp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\n\n\nll dp[(1 << MAX) + 5][MAX];\nll n, m;\nll u,v,w;\nll p;\n\nvoid initialize(){\n\n\tfor(ll i = 0; i < n; i++)\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\twt[i][j] = INF;\n\t\t}\n\tfor(ll i = 0; i < ( 1 << n); i++)\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tdp[i][j] = -1;\n\tdp[1][0] = 0;\n}\n\nvoid floyd_warshall(){\n\t\tfor (ll k=0; k < n; k++) {\n            for (ll i=0; i < n; i++) {\n                for (ll j=0; j < n; j++) {\n                \tif(wt[i][k] != INF && wt[k][j] != INF) \n                \t\twt[i][j] = min(wt[i][j], wt[i][k] + wt[k][j]);\n                \t}\n                }\n            }\n\t\t}\t\n\nvoid tsp()\n{\n\tfor(ll i = 1; i < (1 << n); i++){ \n\t\t// This loop represents the current state, i.e the contents of the set\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\t// j variable tells the ending city\n\t\t\t// during the current state, the last station is j\n\t\t\tif(dp[i][j] == -1)\n\t\t\t{\n\t\t\t\tcontinue;// Incase its impossible to start at 0 and end at j, for eg dp[anyNumber][0], \n\t\t\t\t//Since you cant start at 0 and end at 0\n\t\t\t} \n\t\t\tfor(ll k = 1; k < n; k++){\n\t\t\t\t//cout<<k<<endl;\n\t\t\t\t// This indicates the new city which is going to be included\n\t\t\t\tif(((i & (1 << k)) != 0) || wt[j][k] == INF) // Note that relational op > bitwise op\n\t\t\t\t{\n\t\t\t\t\tcontinue; // i.e. the city was already in the set\n\t\t\t\t}\n\t\t\t\tp = i | (1 << k); // the new state(join k)\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\tif(dp[p][k] == -1)\n\t\t\t\t\tdp[p][k] = dp[i][j] + wt[j][k];\n\t\t\t\telse\n\t\t\t\t\tdp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nll minimum_cost()\n{\n\tll ans = INF;\n\tfor(ll i = 1; i < n; i++)\n\t{\n\t\tif(dp[(1 << n) - 1][i] == -1 || wt[i][0] == INF) continue;\n\t\tans = min(ans, dp[(1 << n) - 1][i] + wt[i][0]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n; // number of cities\n\tcin>>m; // number of edges\n\tinitialize();\n\tfor(ll i = 0; i < m; i++)\n\t{\n\t\tcin>>u>>v>>w;\n\t\twt[u][v] = w;\n\t\t//wt[v][u] = w;\n\t}\n\tfloyd_warshall();\n\ttsp();\n\tll ans = minimum_cost();\n\tif(ans != INF) \n\t\tcout<<ans<<endl;\n\telse cout<<-1<<endl;\n\t/*for(ll i = 0; i < n; i++)\n\t{\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tcout<<wt[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<n<<endl;\n\tfor(ll i = 0; i < (1 << n); i++)\n\t{\n\t\tfor(ll j = 0 ; j < n; j++)\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define rrep(i,n) for(int i=(int)n-1;i>=0;--i)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T& a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U& u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U& u,const V... v){for(auto& e:u)fill_v<T>(e,v...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int V, E;\n    cin >> V >> E;\n    struct edge { int to, weight;};\n    auto g = make_vec<edge>(V, 0);\n    rep(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s].push_back({t, d});\n    }\n    auto dp = make_vec<int>(1 << V, V);\n    const int inf = 1001001001;\n    fill_v<int>(dp, inf);\n    dp[0][0] = 0;\n    rep(bit, 1 << V) {\n        rep(i, V) {\n            for (edge& e : g[i]) {\n                if (bit >> e.to & 1) continue;\n                chmin(dp[bit | (1 << e.to)][e.to], dp[bit][i] + e.weight);\n            }\n        }\n    }\n    int ans = dp[(1 << V) - 1][0];\n    cout << (ans == inf ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nclass Route {\npublic:\n\tRoute(const int &n = 0) :state(n) {};\n\tbool filled() const { return state == ((1 << size) - 1); }\n\tRoute remove(const int &n) const { return Route(state & (-1 - (1 << n))); }\n\tRoute add(const int &n) const { return Route(state | (1 << n)); }\n\tbool include(const int &n) const { return (state & (1 << n)) != 0; }\n\tbool operator<(const Route &other) const { return state < other.state; }\n\tbool operator>(const Route &other) const { return other.state < state; }\n\tbool operator==(const Route &other) const { return state == other.state; }\n\tbool operator<=(const Route &other) const { return *this < (other) || *this == (other); }\n\tbool operator>=(const Route &other) const { return *this > (other) || *this == (other); }\n\tint to_i() const { return state; }\n\tvoid inspect() const;\n\tvoid inspect(int) const;\n\tstatic int size;\nprivate:\n\tint state;\n};\nvoid Route::inspect() const {\n\tinspect(state);\n\tstd::cout << std::endl;\n}\nvoid Route::inspect(int s) const {\n\tif (s > 1) {\n\t\tinspect(s / 2);\n\t\tstd::cout << s % 2;\n\t}\n\telse {\n\t\tstd::cout << s;\n\t}\n}\nclass Edge {\npublic:\n\tEdge(const int &f = 0, const int &t = 0, const int &w = 0) :from(f), to(t), weight(w) {};\n\tbool operator<(const Edge &other) const { return (to < other.to); }\n\tint from, to, weight;\n};\nint dp(std::vector<std::vector<int>> &memo, std::vector<std::vector<Edge>> &edge, const Route &route, const int &vertex) {\n\tif (memo.at(route.to_i()).at(vertex) != -1) {\n\t\treturn memo.at(route.to_i()).at(vertex);\n\t}\n\telse if (route.filled() && vertex == 0) {\n\t\treturn memo.at(route.to_i()).at(vertex) = 0;\n\t}\n\telse {\n\t\tint min = 15001;\n\t\tfor (auto &e : edge.at(vertex)) {\n\t\t\t//std::cout << \"from \" << e.from << \" to \" << e.to << std::endl;\n\t\t\tif (!route.include(e.to)) {\n\t\t\t\tauto temp = dp(memo, edge, route.add(e.to), e.to) + e.weight;\n\t\t\t\t//std::cout << vertex << \"->\" << e.to << \" == \";\n\t\t\t\t//std::cout << temp << \"---\";\n\t\t\t\t//route.inspect();\n\t\t\t\tif (min > temp) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t//std::cout << \"vertex = \" << vertex << \"min = \" << min << std::endl;\n\t\treturn memo.at(route.to_i()).at(vertex) = min;\n\t}\n}\nint Route::size = 30;\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tRoute::size = v;\n\tstd::vector<std::vector<int>> vector((1 << v), std::vector<int>(v, -1));\n\tstd::vector<std::vector<Edge>> edges(v, std::vector<Edge>(0));\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t, d;\n\t\tstd::cin >> s >> t >> d;\n\t\tedges.at(s).push_back(Edge(s, t, d));\n\t}\n\tif (dp(vector, edges, Route(0), 0) > 15000) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << dp(vector, edges, Route(0), 0) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);(i)++)\n#define rept(i,n) for(ll (i)=0;(i)<=(ll)(n);(i)++)\n#define reps(i,s,n) for(ll (i)=(s);(i)<(ll)(n);(i)++)\n#define repst(i,s,n) for(ll (i)=(s);(i)<=(ll)(n);(i)++)\n#define repr(i,n) for(ll (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\???\n// .???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????\n// ?????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\??????????????????\n\nint V, E, s, t, d, dp[1<<15][15], e[15][15];\n\nint main() {\n\tcin >> V >> E;\n\trep(i,V) {\n\t\tfill(e[i], e[i]+V, inf);\n\t\te[i][i] = 0;\n\t}\n\trep(i,E) {\n\t\tcin >> s >> t >> d;\n\t\te[s][t] = d;\n\t}\n\t// dp[i][j] i: ???????¨???????????????????????????? j:?????¨??°\n\trep(i,1<<V) fill(dp[i], dp[i]+V, inf);\n\tdp[0][0] = 0;\n\treps(i,1,1<<V) {\n\t\trep(v,V) {\n\t\t\trep(u,V) {\n\t\t\t\tif (i>>u & 1) chmin(dp[i][v], dp[i^(1<<u)][u] + e[v][u]);\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1<<V)-1][0]!=inf) cout << dp[(1<<V)-1][0] << ln;\n\telse cout << -1 << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<string>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<bitset>\nusing namespace std;\n\nconst int inf = 1001001000;\n\nint TSP(int bit,int v, vector<vector<int>> &dist, vector<vector<int>> &dp){\n\tif (dp[bit][v] >= 0) return dp[bit][v];\n\tif (bit == ((1 << dist.size()) - 1) && v == 0) {\n\t\tdp[bit][v] = 0;\n\t\treturn dp[bit][v];\n\t}\n\tint res = inf;\n\n\tfor (int u = 0; u < dist.size(); u++){\n\t\tif ((bit>>u&1) == 0) {\n\t\t\tres = min(res,TSP((bit|(1<<u)),u,dist,dp) + dist[v][u]);\n\t\t}\n\t}\n\tdp[bit][v] = res;\n\treturn dp[bit][v];\n}\nint main(){\n\tint v, e; cin >> v >> e;\n\tvector<vector<int>> dist(v,vector<int>(v,inf));\n\tvector<vector<int>> dp((1 << v),vector<int>(v,-1));\n\tfor (int i = 0; i < e; i++){\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tdist[s][t] = d;\n\t}\n\n\tint ans = TSP(0,0,dist,dp);\n\t\n\tif (ans == inf) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint glaf[15][15];\nint V,E;\n\nint salesman(int count,int cost, int s,bool check[]){\n  int ans = -1;\n  if(count != 0) check[s] = true;\n  for(int i=0;i<V;i++){\n    if(!check[i]) break;\n    else if(i==V-1) return cost;\n  }\n  for(int i=0;i<V;i++){\n    if(glaf[s][i]!=-1&&!check[i]){\n      int goal_cost = salesman(count+1,cost+glaf[s][i],i,check);\n      if(ans==-1 || ( goal_cost!=-1 && goal_cost < ans )) ans = goal_cost;\n    }\n  }\n  check[s] = false;\n  return ans;\n}\n\nint main(){\n  cin >> V >> E;\n  for(int i=0;i<15;i++)\n    for(int j=0;j<15;j++)\n      glaf[i][j] = -1;\n\n  bool check[V];\n  for(int i=1;i<V;i++)\n    check[i] = false;\n\n  int s,t,d;\n  for(int i=0;i<E;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  int ans = salesman(0,0,0,check);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <climits>\n#include <bitset>\n#define MOD 1000000007\n// INT_MAX\nusing namespace std;\n\n// struct Node\n// {\n// \tbitset<16> bit;\n// \t// vector<int> indeg;\n// \tint cur;\n// \tint path;\n// };\n\nclass Solver\n{\nprivate:\n\tint v;\n\tint e;\n\tvector<vector<int> > adj;\npublic:\n\tSolver(){\n\t\tcin >> v >> e;\n\t\tadj.resize(v);\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tadj[i].resize(v);\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tadj[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < e; ++i)\n\t\t{\n\t\t\tint s, t, d;\n\t\t\tcin >> s >> t >> d;\n\t\t\tadj[s][t] = d;\n\t\t}\n\t\tdp = vector<vector<int> >(1 << v, vector<int>(v, INT_MAX) );\n\t}\n\n\tint recursive(int bit, int cur){\n\t\tif(dp[bit][cur] != INT_MAX){\n\t\t\treturn dp[bit][cur];\n\t\t}\n\n\t\tif(bit == (1 << v) - 1 && cur = 0) return 0;\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tif(bit >> i & 0){\n\t\t\t\tans = min(ans, recursive(bit | 1 << i, i));\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][cur] = ans; \n\t}\n\n\tvoid exec(){\n\t\tint ans = recursive(0, 0);\n\t\tif(ans == INT_MAX) ans = -1;\n\t\tcout << ans << endl;\n\t}\n};\n\n\nint main(){\n\tSolver s = Solver();\n\ts.exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct TSP{\n  int n,d[16][16],dp[(1<<16)][16];\n  TSP(int sz):n(sz){\n    for(int i=0;i<16;i++)\n      for(int j=0;j<16;j++) d[i][j]=1e8;\n  }\n  void add(int a,int b,int c){\n    d[a][b] = c;\n    //d[b][a] = c;\n  }\n  int solve(){\n    for(int i=0;i<(1<<n);i++)\n      for(int j=0;j<n;j++) dp[i][j]=1e8;\n    dp[0][0]=0;\n    for(int i=0;i<(1<<n);i++){\n      for(int j=0;j<n;j++){\n        if(!((1<<j)&i)){\n          for(int k=0;k<n;k++){\n            dp[i|(1<<j)][j]=min(dp[i|(1<<j)][j],dp[i][k]+d[k][j]);\n          }\n        }\n      }\n    }\n    if(dp[(1<<n)-1][0]==1e8)return -1;\n    return dp[(1<<n)-1][0];\n  }\n};\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSP T(n);\n  for(int i=0;i<m;i++){\n    int x,y,z;\n    cin>>x>>y>>z;\n    T.add(x,y,z);\n  }\n  cout<<T.solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconstexpr int inf = 0x3FFFFFFF;\nint dist[15][15];\nint dp[1<<15][15];\n\nvoid read_dist(int V, int E){\n    for (int i = 0; i != V; ++i){\n        for (int j = 0; j != V; ++j){\n            dist[i][j] = inf;\n        }\n    }\n    while (E--){\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n}\n\nint TSP(int V);\nvoid init_dp(int V);\nvector<int> find_visited_vertex(int mask);\n\nint main()\n{\n    int V = 0;\n    int E = 0;\n    cin >> V >> E;\n    read_dist(V, E);\n    cout << TSP(V) << endl;\n    return 0;\n}\n\nint TSP(int V){\n    init_dp(V);\n    int all = 1 << V;\n    for (int mask = 1; mask != all; ++mask){\n        auto vs = find_visited_vertex(mask);\n        for (auto v : vs){\n            int prev_mask = mask ^ (1 << v);\n            for (auto u : vs){\n                if (v == u) continue;\n                dp[mask][v] = min(dp[mask][v], dp[prev_mask][u] + dist[u][v]);\n            }\n        }\n    }\n    int min_cost = dp[all - 1][V - 1];\n    return (min_cost < inf) ? min_cost : -1;\n}\n\nvoid init_dp(int V){\n    for (int mask = 0; mask != 1 << V; ++mask){\n        for (int i = 0; i != V; ++i){\n            dp[mask][i] = inf;\n        }\n    }\n    dp[0][V - 1] = 0;\n    for (int i = 0; i != V - 1; ++i) dp[1 << i][i] = dist[V - 1][i];\n}\n\nvector<int> find_visited_vertex(int mask){\n    vector<int> vs;\n    int idx = 0;\n    while (mask){\n        if (mask & 1) vs.push_back(idx);\n        ++idx;\n        mask >>= 1;\n    }\n    return vs;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nint V,E;\nconst int MAX = 1 << 20;\nconst int V_MAX = 15;\n\nint dp[1<<V_MAX][V_MAX];\n\nint G[V_MAX][V_MAX];\n\n/// 110111\n/// 001000\n\nint rec(int bits, int cur)\n{\n  if(dp[bits][cur]>-1){return dp[bits][cur]; }\n  \n  //if((~bits)==0){ return MAX;}\n  \n  int cost = MAX;\n  for(int i=0;i<V;i++){\n    //if((~bits)&(1<<i) && G[cur][i] > 0){\n    //if(!(bits >> i & 1)){\n    if((~bits)&(1<<i)){\n      cost = min(rec(bits|1<<i,i) + G[cur][i],cost);\n    }\n  }\n  \n  //cout << \"COST:\" << cost << \",bits:\" << bitset<8>(bits) << \",cur:\" << cur << endl;\n  \n  dp[bits][cur] = cost;\n  return dp[bits][cur];\n}\n\nvoid clear()\n{\n  for(int i=0;i<V_MAX;i++){\n    for(int j=0;j<V_MAX;j++){\n      G[i][j] = MAX;\n    }\n  }\n  \n  for(int i=0;i<1<<V_MAX;i++){\n    for(int j=0;j<V_MAX;j++){\n      dp[i][j] = -1;\n    }\n  }\n}\n\n\nint main(void){\n  cin >> V >> E;\n  \n  clear();\n  \n  for(int i=0;i<E;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    G[s][t] = d;\n  }\n  \n  dp[(1<<V)-1][0] = 0;\n  \n  int answer = rec(0,0);\n  \n  /*\n  for(int i=0;i<V;i++){\n    cout << bitset<8>((1<<V)-1) << endl;\n    cout << \"i:\"<< i << \",dp:\" << dp[(1<<V)-1][i] << endl;\n  }\n  */\n  \n  if(answer == MAX){ answer = -1; }\n  \n  cout << answer << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\n#define INF 10000000;\nbool checked(int chouten,int i){\n  if( ((1<<i)|chouten)==chouten){\n    return true;\n  }\n  else return false;\n}\nint pluscheck(int chouten,int i){\n  return (chouten|(1<<i));\n}\n\nbool ren(){\n  \n}\nint graph[16][16];\nint dynamic[((1<<16)-1)][16];\nint V,E;\nint roop(int chouten,int genzai,int len){\n\n  //cout<<\"hehe\"<<chouten<<' '<<genzai<<' '<<len<<endl;;\n  if(dynamic[chouten][genzai]!=-1)\n    return dynamic[chouten][genzai];\n  if(len>=10000000){ \n    return INF;\n  }\n  if(chouten==(1<<(V))-1){\n    if(genzai==0)  \n      return len;\n    else return INF;\n  }\n  else{\n    //    cout<<\"hehe\"<<chouten<<' '<<genzai<<' '<<len<<endl;;\n    int newlen,out;\n    out=INF;\n    for(int i=0;i<16;i++){\n      if(checked(chouten,i)) continue;\n      //cout<<\"i  \"<<genzai<<' '<<i<<' '<<(graph[genzai][i])<<endl;;\n      if(graph[genzai][i]){\n\n\tnewlen=len+graph[genzai][i];\n\t//\tcout<<len<<' '<<newlen<<endl;\n\tout=min(out,roop(pluscheck(chouten,i),i,newlen));\n      }\n    }\n    return out;\n  }\n}\n\nint main(){\n\n\n  cin>>V>>E;\n  int s,t,d;\n\n  for(int i=0;i<16;i++){\n    for(int j=0;j<16;j++){\n      graph[i][j]=0;\n    }\n  }\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>d;\n    graph[s][t]=d;\n  }\n\n  for(int i=0;i<((1<<16)-1);i++){\n    for(int j=0;j<16;j++){\n     \n      dynamic[i][j]=-1;\n    }\n  }\n  int rinzi=roop(0,0,0);\n  if (rinzi<10000000)\n    cout<<rinzi<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<20)\n#define MAX_V 15\n\nint V, E, d[MAX_V][MAX_V], dp[1<<MAX_V][MAX_V][MAX_V];\n\nint rec(int bit, int u, int v){\n    \n    if(dp[bit][u][v] != -1) return dp[bit][u][v];\n    \n    if(bit == (1<<u)) return dp[bit][u][v] = 0;\n    \n    int res = INF;\n    int prev_bit = bit & ~(1<<v);\n    \n    for(int v0 = 0; v0 < V; v0++){\n        if(!(prev_bit & (1<<v0))) continue;\n        res = min(res, rec(prev_bit, u, v0) + d[v0][v]);\n    }\n    \n    return dp[bit][u][v] = res;\n}\n\nint main(){\n    for(int i = 0; i < MAX_V; i++)\n        fill(d[i], d[i] + MAX_V, INF);\n    for(int i = 0; i < (1<<MAX_V); i++)\n        for(int j = 0; j < MAX_V; j++)\n            fill(dp[i][j], dp[i][j] + MAX_V, -1);\n    cin >> V >> E;\n    for(int i = 0; i < E; i++){\n        int u, v, x;\n        cin >> u >> v >> x;\n        d[u][v] = x;\n    }\n    int res = INF;\n    for(int u = 0; u < V; u++)\n        for(int v = 0; v < V; v++){\n            if(u == v) continue;\n            res = min(res, rec((1<<V) - 1, u, v) + d[v][u]);\n        }\n    \n    cout << (res >= INF ? -1 : res) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream &operator << (ostream &os, const vector<T> &);\ntemplate<size_t n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, const tuple<T...> &){}\ntemplate<size_t n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream &os, const tuple<T...> &t){\n    os << (n == 0 ? \"\" : \" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T> ostream &operator << (ostream &os, const tuple<T...> &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U> ostream & operator << (ostream &os, const pair<T,U> &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T> ostream &operator << (ostream &os, const vector<T> &v){\n    for(size_t i = 0; i < v.size(); i++) os << v[i] << (i + 1 == v.size() ? \"\" : \", \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << make_tuple(__VA_ARGS__) \\\n                   << \" (L : \" << __LINE__ << \")\" << endl)\n#else\n#define dump(...)\n#endif\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i = a; i < (int)(b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\nusing ll = long long;\n// #define int ll\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int,int>;\nvoid fastios(){ ios_base::sync_with_stdio(0); cin.tie(0); }\nint const mod = 1000000007;\nauto const inf = numeric_limits<int>::max()/8;\n\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n\nWeight travelingSalesman(const Graph &g){\n    int n = g.size();\n    Matrix dp(1<<n, Array(n, inf));\n    dp[0][0] = 0;\n    for(int S = 0; S < 1<<n; S++){\n        for(auto &es : g){\n            for(auto &e : es){\n                int u = e.src, v = e.dst; auto w = e.weight;\n                if(~S >> v & 1) dp[S|1<<v][v] = min(dp[S|1<<v][v], dp[S][u] + w);\n            }\n        }\n    }\n    return dp[(1<<n)-1][0];\n}\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m){\n        Graph g(n);\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            g[a].eb(a,b,c);\n        }\n        int ans = travelingSalesman(g);\n        cout << (ans==inf ? -1 : ans) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=20;\nconst int MAXN=1<<16;\nconst int INF=1e9+10;;\nint min(int a,int b){return a>b?b:a;}\nint main(){\n    int n,dis[N][N],m,l,r,w,dp[MAXN][N],ans=INF,all;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dis[i][j]=INF;\n    while(m--){\n        scanf(\"%d%d%d\",&l,&r,&w);\n        dis[l][r]=w;\n    }\n    all=1<<n;\n    dp[0][0]=0;\n    for(int i=1;i<all;i++)for(int j=1;j<n;j++)if(i&(1<<j)){\n        if(i==1<<j)dp[i][j]=dis[0][j];\n        else{\n            dp[i][j]=INF;\n            for(int k=0;k<n;k++)if(k!=j&&i&(1<<k))dp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+dis[k][j]);\n        }\n    }\n    for(int i=1;i<n;i++)ans=min(ans,dp[all-2][i]+dis[i][0]);\n    if(ans==INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <stdio.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\n#define fi first\n#define se second\n#define mp make_pair\n \nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1ll << 60;\nconst double PI = 2 * asin(1);\n\nvoid yes() {printf(\"yes\\n\");}\nvoid no() {printf(\"no\\n\");}\nvoid Yes() {printf(\"Yes\\n\");}\nvoid No() {printf(\"No\\n\");}\nvoid YES() {printf(\"YES\\n\");}\nvoid NO() {printf(\"NO\\n\");}\n\nint V, E, Bit[16], DP[15][32768], ans = 1e9;\nbool visited[32768];\nvector <Pii> Graph[15];\n\nint Solve(int start){\n  fill((int*)DP, (int*)(DP + V), 1e9);\n  fill((bool*)visited, (bool*)(visited + Bit[V] - 1), false);\n\n  queue <int> que; que.push(0);\n  visited[0] = true; DP[start][0] = 0;\n\n  while (!que.empty()){\n    int Q = que.front(); que.pop();\n    for (int i = 0; i < V; i++){\n      if (DP[i][Q] == 1e9) continue;\n\n      for (int j = 0; j < Graph[i].size(); j++){\n        int node = Graph[i][j].fi, cost = Graph[i][j].se;\n        int flag = Bit[node] & Q;\n        if (flag > 0) continue;\n        int next = Q + Bit[node];\n        if (visited[next] == false){\n          que.push(next); visited[next] = true;\n        }\n        DP[node][next] = min(DP[node][next], DP[i][Q] + cost);\n      }\n    }\n  }\n  ans = min(ans, DP[start][Bit[V] - 1]);\n  return 0;\n}\n\nint main(){\n  Bit[0] = 1;\n  for (int i = 1; i < 16; i++) Bit[i] = Bit[i - 1] * 2;\n  scanf(\"%d%d\", &V, &E);\n  for (int i = 0; i < E; i++){\n    int S, T, D; scanf(\"%d%d%d\", &S, &T, &D);\n    Graph[S].push_back(mp(T, D));\n  }\n\n\n  Solve(0);\n  if (ans == 1e9) ans = -1;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream> \n#include <fstream>\nusing namespace std;\ninline bool ChekBit(int mask, int index) {\n\treturn (bool)((mask >> index) & 1);\n}\ninline int UpDateMask(int mask, int index) {\n\treturn mask | (1 << index);\n}\ninline unsigned int Min(unsigned int a, unsigned int b) {\n\tif (a < b&&a != 0)return a;\n\telse\n\t{\n\t\treturn b;\n\t}\n}\nint main()\n{\n\tint n;\n\tint m;\n\tcin >> n;\n\tcin >> m;\nvector<vector<pair<int, int>>> map(n);\nvector<int> weightToEnd(n,-1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint vertuxStart;\n\t\tint vertuxEnd;\n\t\tint weight;\n\t\tcin >> vertuxStart;\n\t\tcin >> vertuxEnd;\n\t\tcin >> weight;\n\n\t\tmap[vertuxStart].push_back(make_pair(vertuxEnd, weight));\n\t\tif (vertuxEnd == 0) {\n\t\t\tweightToEnd[vertuxStart] = weight;\n\t\t}\n\t}\n\tint exp = (int)pow(2, n);\n\t\nvector<vector<unsigned int>> dState= vector<vector<unsigned int>>(exp, vector<unsigned int>(n,(unsigned int)-1));\n\tdState[1][0] = 0;\n\tfor (int mask = 1; mask < exp; mask++)\n\t{\n\t\tfor (int vertexCurrent = 0; vertexCurrent < n; ++vertexCurrent)\n\t\t{\n\t\t\tif (!ChekBit(mask,vertexCurrent))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dState[mask][vertexCurrent]==(unsigned int)-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < map[vertexCurrent].size(); ++i)\n\t\t\t{\n\t\t\t\tint vertexEnd = map[vertexCurrent][i].first;\n\t\t\t\tint weight = map[vertexCurrent][i].second;\n\t\t\t\tif (!ChekBit(mask, vertexEnd)) {\n\t\t\t\t\tint tmpMask = UpDateMask(mask, vertexEnd);\n\t\t\t\t\tdState[tmpMask][vertexEnd] = Min(dState[tmpMask][vertexEnd], dState[mask][vertexCurrent] + weight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t unsigned int answer = (unsigned int)-1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (weightToEnd[i]==-1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (dState[exp-1][i]==(unsigned int)-1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tanswer = Min(answer, dState[exp - 1][i] + weightToEnd[i]);\n\t\t\n\t}\n\tcout << (int)answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n#define INF int(1e9)\n#define maxn 16\n\n#define bset(n, bit) (n | 1<<bit)\n#define bclr(n, bit) (n & ~(1<<bit))\n\nint dp[1<<maxn][maxn];\nint n,E;\nint dist[maxn][maxn];\n\nint path(int S,int v)\n{\n    if(dp[S][v]>=0){\n        return dp[S][v];\n    }\n    if((S==0) && (v==0)){\n        return dp[S][v]=0;\n    }\n    int res = INF;\n    for(int u=0; u<n; u++){\n        if(((S>>u)&1) == 1 && u!=v){\n            res=min(res, path(bclr(S, u), u) + dist[u][v]);\n        }\n    }\n    return dp[S][v]=res;\n}\n\nint main()\n{\n    cin>>n>>E;\n    memset(dist,0x3f,sizeof(dist));\n    for(int i=0;i<E;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        dist[a][b]=c;\n    }\n    memset(dp,-1,sizeof(dp));\n    int ans = path((1<<n) - 1, 0);\n    if(ans==INF) ans=-1;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <climits>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\n#define MAX_V 16\nint adjMat[MAX_V][MAX_V];\nbool visited[MAX_V][1<<MAX_V];//visited????????????????????????????¨???????,????????????????????????????????????\nint dp[MAX_V][1<<MAX_V];//DP??¨???,?¬¬???????????¬?????£??¨???????????¨??????\n//?¬¬???????????¬?????£??¨?????????????????????(ex:0101011,??¨???1,3,5??????????????°???,?????\\??´??\\??¨bitwise?????????????????????)\n//??????DP??¨??????N*2^N?¬????,?????\\????????????????°±???O(N*2^N)\nint v,e;\n\nconst char *byte_to_binary(int x)\n{\n    static char b[9];\n    b[0] = '\\0';\n\n    int z;\n    for (z = 128; z > 0; z >>= 1)\n    {\n        strcat(b, ((x & z) == z) ? \"1\" : \"0\");\n    }\n\n    return b;\n}\nint TSP(int at,int state)\n{\n    // printf(\"at=%d,state=%s\\n\",at, byte_to_binary(state));\n    if(state == (1<<v)-1){ //??¨??¨??????????????°??????\n        visited[at][state]=true;\n        return dp[at][state];\n    }\n    if(dp[at][state]) //??????????????????,??´??\\????????????\n        return dp[at][state];\n    int ans = INT_MAX>>1;\n    int cost;\n    for(int i=0;i<v;i++){\n        //state&(1<<i)==0??¨?????????????????????????¬¬i???bit?????????0,??¨?????????????????????????????°???\n        //state|(1<<i)??¨????°???????????¨??????°???\n        if(adjMat[at][i]!=-1 && (state & (1<<i))==0){\n            // printf(\"at=%d,i=%d\\n\",at,i);\n            cost = TSP(i,state|(1<<i)) + adjMat[at][i];//???????¨??????\\??°??????????????°??????\n            // printf(\"at=%d,i=%d,cost=%d\\n\",at,i,cost);\n            ans = min(ans,cost);//?±????????°????\n        }\n    }\n    return dp[at][state] = ans;\n}\n\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d %d\",&v,&e)){\n        memset(adjMat,-1,sizeof(adjMat));\n        for(int i=0;i<e;i++){\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            adjMat[u][v]=w;\n        }\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        int ans = TSP(0,0);\n        if(ans>=INT_MAX>>1)\n            puts(\"-1\");\n        else\n            printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\nconst int MOD=1e9+7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false); \n\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> d(n,vector<int>(n,-1));\n    rep(i,m) {\n        int a,b,din,tin;\n        cin >> a >> b >> din;\n        d[a][b]=din;\n    }\n    vector<vector<int>> dp((1<<n),vector<int>(n,1e9));\n    dp[0][0]=0;\n    rep(bit,(1<<n)) {\n        rep(i,n) {\n            if (bit & (1<<i)) {\n                rep(k,n) {\n                    if (dp[bit-(1<<i)][k]!=1e9 && i!=k && d[k][i]>=0) {\n                        dp[bit][i]=min(dp[bit][i],dp[bit-(1<<i)][k]+d[k][i]);\n                    }\n                }\n            }\n        }\n    }\n    int ans=1e9;\n    ans=dp[(1<<n)-1][0];\n    if (ans==1e9) ans=-1;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nconst int INF = 1 << 28;\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n\n    auto dist = Vec<int>(N, N, INF);\n    for (int i = 0; i < M; ++i) {\n        int u, v, d;\n        std::cin >> u >> v >> d;\n        dist[u][v] = d;\n    }\n\n    auto dp = Vec<int>(1 << (N - 1), N - 1, INF);\n    // dp[b][i] = 集合bを探索済みで、今iにいるときの最小コスト\n    // ただし頂点N-1を最初と最後に訪れるものとする\n\n    for (int v = 0; v < N - 1; ++v) dp[1 << v][v] = dist[N - 1][v];\n\n    for (int b = 0; b < (1 << (N - 1)); ++b) {\n        for (int from = 0; from < N - 1; ++from) {\n            if (((b >> from) & 1) == 0) continue;\n            for (int to = 0; to < N - 1; ++to) {\n                if (from == to || ((b >> to) & 1) == 0) continue;\n                dp[b][to] = std::min(dp[b][to], dp[b ^ (1 << to)][from] + dist[from][to]);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int v = 0; v < N - 1; ++v) {\n        ans = std::min(ans, dp[(1 << (N - 1)) - 1][v] + dist[v][N - 1]);\n    }\n\n    std::cout << (ans == INF ? -1 : ans) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\nusing namespace std;\n\nconst int INF = 100000000; // 十分大きな値\n\n/*\nやりたいこと\t実装\nmask で表された部分のフラグをまとめて立てる\tbit ｜= mask\nmask で表された部分のフラグをまとめて消す\tbit &= ~mask\nmask で表された部分の情報のみを取り出したもの\tbit & mask\nmask で表された部分のどれかのフラグが立っているかどうか\tif (bit & mask)\nmask で表された部分のすべてのフラグが立っているかどうか\tif ((bit & mask) == mask)\n*/\n\n/* 入力 */\nint N,V;\nint dist[21][21];\n\n/* メモ再帰 */\nint dp[(1<<20) + 1][21]; // dpテーブルは余裕をもったサイズにする\nint rec(int bit, int v)\n{\n  // すでに探索済みだったらリターン\n  if (dp[bit][v] != -1) return dp[bit][v];\n\n  // 初期値\n  if (bit == (1<<v)) {\n    return dp[bit][v] = dist[0][v];\n  }\n\n  // 答えを格納する変数\n  int res = INF;\n\n  // bit の v を除いたもの\n  int prev_bit = bit & ~(1<<v);\n\n  // v の手前のノードとして u を全探索\n  for (int u = 0; u < N; ++u) {\n    if (!(prev_bit & (1<<u))) continue; // u が prev_bit になかったらダメ\n\n    // 再帰的に探索\n    if (res > rec(prev_bit, u) + dist[u][v]) {\n      res = rec(prev_bit, u) + dist[u][v];\n    }\n  }\n\n  return dp[bit][v] = res; // メモしながらリターン\n}\n\nint main()\n{\n  // 入力\n  cin >> N >> V;\n  for(int i=0;i<21;i++)for(int j=0;j<21;j++){\n    if(i==j) dist[i][j]=0;\n    else dist[i][j]=INF;\n  }\n  for(int i=0;i<V;i++){\n    int s,t,d; cin >> s >> t >> d;\n    dist[s][t]=d;\n  }\n\n  // テーブルを全部 -1 にしておく (-1 でなかったところは探索済)\n  for (int bit = 0; bit < (1<<N); ++bit) for (int v = 0; v < N; ++v) dp[bit][v] = -1;\n\n  // 探索\n  int res = INF;\n  if (res > rec((1<<N)-1, 0)) {\n    res = rec((1<<N)-1, 0);\n  }\n\n  if(res>=INF/2) cout << -1 << endl;\n  else cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/*\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_map>\n#include <map>\n*/\n#define INF 100000000\n#define rep(i, a) for (int i = 0; i < (a); i++)\nusing namespace std;\nint main() {\n   int n;\n   int e;\n   \n   cin >> n >> e;\n   int dist[n][n];\n   \n   int i, j, k;\n   //隣接行列作成\n   for(i = 0; i < n; i++){\n       for(j = 0; j < n; j++){    \n           dist[i][j] = INF;\n        }\n    }\n\n    int s, t, d;\n    for(i = 0; i < e; i++){\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    \n    int dp[1<<n][n];\n\n   //dp初期化\n   for(i = 0; i < (1<<n); i++){\n       for(j = 0; j < n; j++){\n           dp[i][j] = INF;\n       }\n   }\n   dp[1][0] = 0;\n\n   for(i = 0; i < (1<<n); i++){\n       for(j = 0; j < n; j++){\n           if(dp[i][j] == INF) continue;\n           for(k = 0; k < n; k++){\n               //もしkが訪問済みだったら何もしない\n               if((i>>k)%2 == 1) continue;\n               if(dist[j][k] == INF) continue;\n               //集合の更新\n               int nexti = i | (1<<k);\n               //経路長を求める\n               int nextd = dp[i][j] + dist[j][k];\n               //現在の値より小さいなら更新する\n               dp[nexti][k] = min(dp[nexti][k], nextd);\n           }\n       }\n   }\n\n   //全て訪問した時の状態\n   int all = (1<<n) - 1;\n   int ans = INF;\n   int goal;\n   for(i = 0; i < n; i++){\n       if(dp[all][i] == INF) continue;\n       int tmp = dp[all][i] + dist[i][0];\n       ans = min(ans, tmp);\n   }\n\n   if(ans == INF){\n       cout << -1 << endl;\n   }else{\n       cout << ans << endl;\n   }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\nstruct edge{\n    int to,cost;\n    edge(int a,int b):to(a),cost(b){}\n};\n\nint dp[1<<16][15];\nint N,M;\nvector<edge>G[15];\n\nint solve(int s){\n    fill_n(*dp,(1<<16)*15,INF);\n    dp[0][s]=0;\n\n    for(int i=0;i<(1<<N);i++){\n        for(int j=0;j<N;j++){\n            if(dp[i][j]==INF)continue;\n            for(int k=0;k<G[j].size();k++){\n                edge &e=G[j][k];\n                if(i>>e.to&1)continue;\n                dp[i|(1<<e.to)][e.to]=min(dp[i|(1<<e.to)][e.to],dp[i][j]+e.cost);\n            }\n        }\n    }\n\n    return dp[(1<<N)-1][s];\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(edge(b,c));\n    \n    }\n\n    int mi=INF;\n\n    for(int i=0;i<N;i++)mi=min(mi,solve(i));\n\n    if(mi==INF)cout<<-1<<endl;\n    else cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define INF 0x1fffffff\n#define MAX_V 13\n\nint main(void){\n  int v, e, st[MAX_V][MAX_V], i, j, k, l, d[MAX_V][MAX_V][1 << MAX_V]/*スタート地点,今いる地点,通過した編の情報(bit)*/, ans = INF;\n  scanf(\"%d%d\",&v,&e);\n  memset(st,-1,sizeof(st));\n  for(i = 0;i < e;i++){\n    int s, t, dt;\n    scanf(\"%d%d%d\",&s,&t,&dt);\n    st[s][t] = dt;\n  }\n  for(i = 0;i < v;i++){\n    for(j = 0;j < v;j++){\n      for(k = 0;k < 1 << v;k++){\n\td[i][j][k] = INF;\n      }\n    }\n  }\n  for(i = 0;i < v;i++){ // スタート地点\n    d[i][i][1 << i] = 0;\n    while(1){\n      int flag = 1;\n      for(j = 0;j < v;j++){ // 今いる地点\n\tfor(k = 0;k < 1 << v;k++){ // 通過辺の情報\n\t  for(l = 0;l < v;l++){ // 行き先\n\t    if(st[j][l] != -1 && d[i][l][k | (1 << l)] > d[i][j][k] + st[j][l]){\n\t      flag = 0;\n\t      d[i][l][k | (1 << l)] = d[i][j][k] + st[j][l];\n\t      \n\t    }\n\t  }\n\t}      \n    \n      }\n      if(flag){\n\tbreak;\n      }\n    }\n\n  }\n  for(i = 0;i < v;i++){\n    if(d[i][i][(1 << v) - 1] < ans){\n      ans = d[i][i][(1 << v) - 1];\n    }\n  }\n  if(ans == INF){\n    ans = -1;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,o,n) for(long long i = o;i<n;i++)\n#define oneforall ios::sync_with_stdio(false);cin.tie(0);\n#define all(v) (v).begin(),(v).end()\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n//#define int long long \n#define inf 1000000000\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef long long ll;\ntypedef vector<pair<long, long > > vpll;\ntypedef vector<pair<int, int > > vpii;\n#define FORR(x,arr) for(auto& x:arr)\n#define ZERO(a) memset(a,0,sizeof(a))\n\n\n\n\n\n//3111111111111111111111111111111\n\t\n\tint dp[31][1<<20];\n\tint x[31][31];\n\t\n\tvoid solve(){\n\n\t\tFOR(i,0,31)FOR(i1,0,1<<20)dp[i][i1] = inf;\n\t\tFOR(i,0,31)FOR(i1,0,31)x[i][i1] = inf;\n\t\tini(n);\n\t\tini(n1);\n\t\tFOR(i,0,n1){\n\t\t\tini(x1,tmp1,tmp);\n\t\t\tx[x1][tmp1] = tmp;\n\t\t}\n\t\tdp[0][1] = 0;\n\t\tFOR(i,0,1<<n){\n\t\t\tFOR(i1,0,n){\n\t\t\t\tif(dp[i1][i]!=inf){\n\t\t\t\t\t//out(\"start:\",i1,\"to\",i);\n\t\t\t\t\tFOR(i2,0,n){\n\t\t\t\t\t\tif(!((1<<i2)&i)){\n\t\t\t\t\t\t\tdp[i2][i+(1<<i2)] = min(dp[i2][i+(1<<i2)],dp[i1][i]+x[i1][i2]);\n\t\t\t\t\t\t\t//out(\"in: \",i1,\"i2: \",i2,\"kore\",dp[i2][i+(1<<i2)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//out(\"end:\",i1,\"to\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rick  = inf;\n\t\tFOR(i,0,n){\n\t\t\trick  = min(rick,dp[i][(1<<n)-1]+x[i][0]);\n\t\t}\n\t\tif(rick == inf)rick = -1;\n\t\tout(rick);\n\t\n\t\t\n\t\t\n\n\t\t\n\n\n\t\t\n\t\t\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint32_t main() {\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall \n\toneforall\n\n\tsolve();\n\t\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint V,E;\nint d[20][20];\nint dp[1<<16][16];\nint main(){\n\tcin>>V>>E;\n\t//memset(d, INF, sizeof(d));\n\tfor(int S =0;S <(1<<V);S++){\n\t\tfill(dp[S], dp[S]+V, INF);\n\t}\n\tfor(int i =0;i <V;i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i <E;i++){\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\td[x][y]=c;\n\t}\n\tdp[(1<<V)-1][0]=0;\n\tfor(int S =(1<<V)-2;S >=0;S--){\n\t\tfor(int v = 0; v <V;v++){\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v]=min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t\t//cout <<dp[S][v]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<dp[0][0]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp[1<<15][15];\nint path[15][15];\n\nint main(){\n\t\n\tfor(int i=0;i<(1<<15)*15;i++)dp[i/15][i%15]=114514;\n\tfor(int i=0;i<15*15;i++)path[i/15][i%15]=114514;\n\t\n\tint v,e;\n\tcin>>v>>e;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,d;\n\t\tcin>>s>>t>>d;\n\t\tpath[s][t]=d;\n\t}\n\t\n\t//?????????\n\tdp[0][0]=0;\n\t\n\tfor(int i=0;i<(1<<v);i++){\n\t\tfor(int j=0;j<v;j++){\n\t\t\tif(dp[i][j]==114514)continue;\n\t\t\t\n\t\t\tfor(int k=0;k<v;k++){\n\t\t\t\tif(i & (1<<k))continue;\n\t\t\t\tdp[i+(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+path[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(dp[(1<<v)-1][0]==114514?-1:dp[(1<<v)-1][0])<<endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n\nstruct Edge {\n  int dst,weight;\n};\n\nint TravelingSalesmanProblem(int V,int E,vector<int> s,vector<int> t,vector<int> d) {\n  vector<vector<Edge> > G(V);\n  vector<int> cost(V,INT_MAX);\n  cost[0] = 0;\n  for(int i=0;i<E;++i) {\n    G[s[i]].push_back((Edge){t[i],d[i]});\n    if( t[i] == 0 ) {\n      cost[s[i]] = min(cost[s[i]],d[i]);\n    }\n  }\n  vector<vector<int> > dp((1<<V),vector<int>(V,INT_MAX));\n  dp[1][0] = 0;\n  for(int state=0;state<(1<<V);++state) {\n    for(int cur=0;cur<V;++cur) if( dp[state][cur] != INT_MAX ) {\n        for(int i=0;i<(int)G[cur].size();++i) {\n          Edge &e = G[cur][i];\n          if( (state>>e.dst) & 1 ) continue;\n          dp[state|(1<<e.dst)][e.dst] = min(dp[state|(1<<e.dst)][e.dst],\n                                            dp[state][cur]+e.weight);\n        }\n      }\n  }\n\n  int mini = INT_MAX;\n  for(int i=0;i<V;++i) if( dp[(1<<V)-1][i] != INT_MAX && cost[i] != INT_MAX ) {\n    mini = min(mini,dp[(1<<V)-1][i]+cost[i]);\n  }\n  return (mini!=INT_MAX)?mini:-1;\n}\n\nint main() {\n  int V,E;\n  cin >> V >> E;\n  vector<int> s(E), t(E), d(E);\n  for(int i=0;i<E;++i) cin >> s[i] >> t[i] >> d[i];\n  cout << TravelingSalesmanProblem(V,E,s,t,d) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 15;\nconst int MAX_M = 225;\n\nint n,m;\nll dp[1 << MAX_N][MAX_N];\nll d[MAX_N][MAX_N];\nint s[MAX_M];\nint t[MAX_M];\nint D[MAX_M];\n\nll solve()\n{\n\trep(S,1<<n){\n\t\tfill(dp[S],dp[S]+n,INF);\n\t}\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\trep(v,n){\n\t\t\tif(S>>v&1){\n\t\t\t\trep(u,n){\n\t\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\t\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tll ans=INF-1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> s[i] >> t[i] >> D[i];\n\t}\n\trep(i,n){\n\t\tfill(d[0],d[n],INF);\n\t\trep(j,m){\n\t\t\td[(s[j]+n-i)%n][(t[j]+n-i)%n] = D[j];\n\t\t} \n\t\tans = min(ans,solve());\n\t}\n\tif(ans > 16000){\n\t\tcout << \"-1\\n\";\n\t}else{\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1 << 15][15],d[15][15],a,b,c,n,p,INF=1<<30;\nint rec(int s,int v){\n\tif(dp[s][v]!=-1)return dp[s][v];\n\tif(s == (1<< n) -1 && v == 0)return dp[s][v] = 0;\n\tint res = INF;\n\tfor(int i = 0;i<n;i++)if(!(s>>i & 1) && d[v][i] != 0)res = min(res,rec(s|(1<<i),i)+d[v][i]);\n\treturn dp[s][v] = res;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> n >> p;\n\tfor(int u = 0; u < p;u++)cin>>a>>b>>c,d[a][b]=c;\n\tcout<<(INF == (a = rec(0,0))?-1:a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint d[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint tsp(int v, int b){\n    if(b < (1 << MAX_CITY_NUM) - 1) return d[v][0];   //??¨??¨?¨???????\n    int res = MAX;\n    for (int w = 0; w < MAX_CITY_NUM; w++) {\n        if(b & (1<<w))continue;             //???????¨???????\n        res = min(res, d[v][w] + tsp(w, b | (1 << w)));\n    }\n    return res;\n}\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(d, -1, sizeof(d));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        d[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp[1 << 15][15];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int INF = 15000;\n    int V, E;\n    cin >> V >> E;\n    \n    int d[V][V];\n    for (int i = 0; i < V; ++i) {\n        fill(d[i], d[i] + V, INF);\n    }\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        cin >> d[s][t];\n    }\n    for (int s = 0; s < 1 << V; ++s) {\n        fill(dp[s], dp[s] + V, INF);\n    }\n\n    dp[(1 << V) - 1][0] = 0;\n\n    for (int s = (1 << V) - 2; s >= 0; --s) {\n        for (int v = 0; v < V; ++v) {\n            for (int u = 0; u < V; ++u) {\n                if (!(s >> u & 1)) {\n                    dp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n\n    if (dp[0][0] < INF) {\n        cout << dp[0][0] << '\\n';\n    } else {\n        cout << -1 << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define trace1(a)                    cout<<#a<<\": \"<<a<<endl\n#define trace2(a,b)                  cout<<#a<<\": \"<<a<<\" | \", trace1(b)\n#define trace3(a,b,c)                cout<<#a<<\": \"<<a<<\" | \", trace2(b,c)\n#define trace4(a,b,c,d)              cout<<#a<<\": \"<<a<<\" | \", trace3(b,c,d)\n#define trace5(a,b,c,d,e)            cout<<#a<<\": \"<<a<<\" | \", trace4(b,c,d,e)\n#define trace6(a,b,c,d,e,f)          cout<<#a<<\": \"<<a<<\" | \", trace5(b,c,d,e,f)\n#define trace7(a,b,c,d,e,f,g)        cout<<#a<<\": \"<<a<<\" | \", trace6(b,c,d,e,f,g)\n#define trace8(a,b,c,d,e,f,g,h)      cout<<#a<<\": \"<<a<<\" | \", trace7(b,c,d,e,f,g,h)\n#define trace9(a,b,c,d,e,f,g,h,i)    cout<<#a<<\": \"<<a<<\" | \", trace8(b,c,d,e,f,g,h,i)\n#define trace10(a,b,c,d,e,f,g,h,i,j) cout<<#a<<\": \"<<a<<\" | \", trace9(b,c,d,e,f,g,h,i,j)\n#define rep(i,a,b)      for(int (i)=(int)(a);(i)<(int)(b); ++(i))\n#define reps(i,a,b,c)   for(int (i)=(int)(a);(i)<(int)(b); (i)+=(c))\n#define rrep(i,a,b)     for(int (i)=(int)(a);(i)>=(int)(b);--(i))\n#define rreps(i,a,b,c)  for(int (i)=(int)(a);(i)>=(int)(b);(i)-=(c))\n#define fore(x,a)       for(auto &x:a)\n#define foreach(i,a)    for(auto i=(a).begin(); i!=(a).end(); ++i)\n#define rforeach(i,a)   for(auto i=(a).rbegin();i!=(a).rend();++i)\n#define all(a)  (a).begin(), (a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define isin(i,a,b) ((a) <= (i) && (i) <= (b))\n#define uni(a) (a).erase(unique(all(a)),(a).end())\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(a) ((long long)(a).size())\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\nusing ll  = long long;          using vi  = vector<int>;\nusing ld  = long double;        using vl  = vector<ll>;\nusing unit= unsigned;           using vvi = vector<vi>;\nusing ull = unsigned long long; using vvl = vector<vl>;\nusing pii = pair<int,int>;      using vpii= vector<pii>;\nusing pil = pair<int,ll>;       using vpil= vector<pil>;\nusing pli = pair<ll,int>;       using vpli= vector<pli>;\nusing pll = pair<ll,ll>;        using vpll= vector<pll>;\nvoid _main(); int main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntemplate<class T>string join(const v(T)&v){ stringstream s; rep(i,0,sz(v))s<<' '<<v[i]; return s.str().substr(1); }\ntemplate<class T>istream &operator>>(istream&i, v(T)&v){ fore(x,v){ i >> v; } return i; }\ntemplate<class T>ostream &operator<<(ostream&o, const v(T)&v){ o<<\"[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const deque<T>&v){ o<<\"deq[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T1,class T2>ostream &operator<<(ostream &o, const pair<T1,T2>&p){ o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const unordered_map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>void YES(T c){ if(c) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl; }\ntemplate<class T>void Yes(T c){ if(c) cout<<\"Yes\"<< endl; else cout<<\"No\"<<endl; }\ntemplate<class T>void POSS(T c){ if(c) cout<<\"POSSIBLE\"<<endl; else cout<<\"IMPOSSIBLE\"<<endl; }\ntemplate<class T>void Poss(T c){ if(c) cout<<\"Possible\"<<endl; else cout<<\"Impossible\"<<endl; }\ntemplate<class T>bool chmax(T &a,const T &b){ return a<b?(a=b,true):false; }\ntemplate<class T>bool chmin(T &a,const T &b){ return a>b?(a=b,true):false; }\ntemplate<class T>T gcd(T a,T b){ return b?gcd(b,a%b):a; }\ntemplate<class T>T lcm(T a,T b){ return a/gcd(a,b)*b; }\nconst double  EPS = 1e-10;\nconst double  PI  = acos(-1.0);\nconst int     INF = 1001002003;\nconst ll      LINF= 1001002003004005006LL;\nconst int DX[] = { -1, 0, 1, 0 , -1,-1, 1, 1 };\nconst int DY[] = {  0, 1, 0,-1 , -1, 1,-1, 1 };\n\nint V, E;\nint G[20][20];\nint dp[50000][20];\n\nint f(int S, int v) {\n  if (S == 0) {\n    if (v == 0) return 0;\n    return INF;\n  }\n  if ((S & (1 << v)) == 0) return INF;\n  int& ret = dp[S][v];\n  if (ret != 0) return ret;\n  ret = INF;\n  rep(u,0,V) chmin(ret, f(S ^ (1 << v), u) + G[u][v]);\n  return ret;\n}\n\nvoid _main() {\n  cin >> V >> E;\n  rep(i,0,20)rep(j,0,20) G[i][j] = INF;\n  rep(i,0,E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    G[s][t] = d;\n  }\n  int ans = f((1<<V)-1, 0);\n  if (ans == INF) ans = -1;\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nconst int MAX_N = 16;\nconst int INF = 100000000;\n\nint g[MAX_N][MAX_N];\nint dp[1 << MAX_N][MAX_N];\nint n;\n\nint tsp(int visited, int v) {\n  int& res = dp[visited][v];\n  if (res != -1) return res;\n\n  if (visited == (1 << n) - 1 && v == 0) return 0;\n\n  res = INF;\n\n  rep(u, n) {\n    if (visited & (1 << u)) continue;\n    res = min(res,\n      tsp(visited | (1 << u), u) + g[v][u]);\n  }\n  return res;\n}\n\nint main() {\n  int m;\n  cin >> n >> m;\n\n  rep(i, n) rep(j, n) g[i][j] = INF;\n  rep(i, 1 << n) rep(j, n) dp[i][j] = -1;\n\n  rep(i, m) {\n    int s, t, d;\n    cin >> s >> t >> d;\n\n    g[s][t] = d;\n  }\n\n  int ans = tsp(0, 0);\n  if (ans == INF) ans = -1;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\nll n,e;\nll d[20][20];\n\nll dp[1 << 20][20];\n\nll rec(ll s, ll v){\n  //?????????????????????????????§?????????????????????\n  if(dp[s][v] >= 0){\n    return dp[s][v];\n  }\n  //??????????????????????¨?????????????\n  if(s == (1 << n) - 1 && v == 0){\n    return dp[s][v] = 0;\n  }\n  ll res = inf;\n  rep(u,n){\n    //???????§???????????????????????????????????????????\n    if( !(s >> u & 1) && d[v][u] != 0){\n      res = min(res,rec(s | 1 << u, u) + d[v][u]);\n    }\n  }\n  return dp[s][v] = res;\n}\n\nvoid solve(){\n  memset(dp,-1,sizeof(dp));\n  ll ans = rec(0,0);\n  if(ans == inf) ans = -1;\n  cout << ans<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> e;\n  ll s,t,dis;\n  rep(i,e){\n    cin >> s >> t >> dis;\n    d[s][t] = dis;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\n#define INF (int)1e8\n\nusing namespace std;\n\nsigned main(){\n\tint V, E; cin >> V >> E;\n\tvector<vector<int> > adj(V, vector<int>(V,INF));\n\tfor(int i = 0; i < E; i++){\n\t\tint s,t,d; cin >> s >> t >> d;\n\t\tadj[s][t] = d;\n\t}\n\tvector<vector<int> > dp((1 << V), vector<int>(V, INF));\n\tdp[(1 << V)-1][0] = 0;\n\tfor(int i = (1 << V) -2; i >= 0; i--){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif((i & (1 << j)) == 0){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i | (1 << j)][j] + adj[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0] == INF)dp[0][0] = -1;\n\tcout << dp[0][0] << endl;\n\t\n\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1e9;\nint v,e;\nint g[15][15];\nint dp[1<<15][15];\n\nvoid dfs(int idx,int bit)\n{\n\tfor(int i = 0;i<v;i++)\n\t{\n\t\t if((bit&(1<<i))==0)\n\t\t {\n\t\t\t //cout<<i<<endl;\n\t\t\t if(g[idx][i]!=-1)\n\t\t\t {\n\t\t\t\tif(dp[bit|(1<<i)][i]>dp[bit][idx]+g[idx][i])\n\t\t\t \t{\n\t\t\t\t\t dp[bit|(1<<i)][i] = dp[bit][idx]+g[idx][i];\n\t\t\t\t dfs(i,bit|(1<<i));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t}\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tfor(int i = 0 ;i<15;i++)\n\t{\n\t\tfor(int j = 0;j<15;j++)\n\t\t{\n\t\t\tg[i][j] = -1;\n\t\t}\n\t}\n\tfor(int i = 0;i<(1<<15);i++)\n\t{\n\t\tfor(int j = 0;j < 15;j++)\n\t\t{\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0;i<e;i++)\n\t{\n\t\tint fr,to,cost;\n\t\tcin >> fr >> to >> cost;\n\t\tfr;\n\t\tto;\n\t\tg[fr][to] = cost;\n\t}\n\tdp[0][0] = 0;\n\tdfs(0,0);\n\tint ans = INF;\n\tfor(int i = 0;i<v;i++){ans = min(ans,dp[(1<<v)-1][0]);}\n\t//for(int i = 0;i<(1<<v);i++){for(int j = 0;j<v;j++){cout<<dp[i][j]<<' ';}cout<<endl;}\n\tcout<<(ans==INF?-1:ans)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit(int mask, int num)\n{\n\treturn (mask >> num) & 1;\n}\ninline int add_bit(int mask, int num)\n{\n\treturn (mask + (1 << num));\n}\n\n\nint main()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back(make_pair(destiny, len));\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow(2, n);\n\tvector < vector < int > > dp(max_mask, vector < int > (n, -1));\n\tdp[1][0] = 0;\n\tfor (int mask = 1; mask < max_mask; mask++)\n\t{\n\t\tfor (int vertex = 0; vertex < n; vertex++)\n\t\t{\n\t\t\tfor (i = 0; i < graph[vertex].size(); i++)\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif (!get_bit(mask, next))\n\t\t\t\t{\n\t\t\t\t\tif ((dp[add_bit(mask, next)][next] < dp[mask][vertex]) || (-1 == dp[add_bit(mask, next)][next]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit(mask, next)][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tfor (j = 0; j < graph[i].size(); j++)\n\t\t{\n\t\t\tif (0 == graph[i][j].first)\n\t\t\t{\n\t\t\t\tif ((result > dp[max_mask - 1][i] + graph[i][j].second) || (result = -1))\n\t\t\t\t{\n\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tlong long int V, E;\n\tcin >> V >> E;\n\t\n\tlong long int cost[V][V];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tcost[u][v] = c;\n\t}\n\t\n\tlong long int DP[V][(1 << V)];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < (1 << V); j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tDP[0][0] = 0;\n\t\n\tfor(int i = 0; i < (1 << V); i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tDP[j][i] = min(DP[j][i], DP[k][i - (1 << j)] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int ans = DP[0][(1 << V) - 1];\n\tif(ans == INF){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 15;\n\nint n,m;\nll dp[1 << MAX_N][MAX_N];\nll d[MAX_N][MAX_N];\nint s[MAX_N];\nint t[MAX_N];\nint D[MAX_N];\n\nll solve()\n{\n\trep(S,1<<n){\n\t\tfill(dp[S],dp[S]+n,INF);\n\t}\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\trep(v,n){\n\t\t\trep(u,n){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tll ans=INF-1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> s[i] >> t[i] >> D[i];\n\t}\n\trep(i,n){\n\t\tfill(d[0],d[n],INF);\n\t\trep(j,m){\n\t\t\td[(s[j]+n-i)%n][(t[j]+n-i)%n] = D[j];\n\t\t} \n\t\tans = min(ans,solve());\n\t}\n\tif(ans > 16000){\n\t\tcout << \"-1\\n\";\n\t}else{\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\ntemplate<class T> bool chmin(T &a, T b) {if(a>b) {a=b;return 1;}return 0;}\nusing namespace std;\nusing ll = long long;\nconst int inf = 1e8;\n\nint main() {\n    int n, e;\n    cin >> n >> e;\n    int dp[1<<n][n];\n    vector<vector<int>> d(n,vector<int>(n,-1));\n    rep(i,e) {\n        int s, t, cost;\n        cin >> s >> t >> cost;\n        d[s][t] = cost;\n    }\n    int ans = inf;\n    rep(V,n) {\n        rep(i,1<<n)rep(j,n) dp[i][j] = inf;\n        dp[(1<<n)-1][V] = 0;\n        for (int S = (1<<n) - 2; S >= 0; S--) {\n            for (int v = 0; v < n; v++) {\n                for (int u = 0; u < n; u++) {\n                    if (!(S >> u & 1) && (d[v][u] != -1)) {\n                        dp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n                    }\n                }\n            }\n        }\n        ans = min(ans,dp[0][V]);\n    }\n    if (ans == inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// DPL_2_A\n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ipair;\ntypedef pair<ll,ll> lpair;\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v) //vectorの中身を見る\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nint n,hen;\nint inf=pow(10,9);\nvector<vector<int>> dist(15,vector<int>(15,inf));\nvector<vector<int>> dp(1<<15,vector<int>(15,-1)); \n\nint dfs(int S,int now,int count){ //Sは訪れたことのある頂点の記録、nowは現在地点、countは訪れた頂点数\n    if(dp[S][now]!=-1) return dp[S][now]; //記録済み\n    if(count==n && now==0) return dp[S][now]=0; //ゴール\n    int ans=inf; //記録の候補のスタートはinf\n    for(int next=0;next<n;next++){\n        if(!(S>>next&1)){ //まだnextを訪問していない\n            if(next==0){\n                if(count!=n-1) continue; //次に0を訪問できるのは、既にn-1地点訪問してるときのみ\n            }\n            if(dist[now][next]!=inf) ans=min(ans,dfs(S|1<<next,next,count+1)+dist[now][next]); //now→nextにいけないときはスルー\n        }\n    }\n    dp[S][now]=ans;\n    return ans;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n\n    cin>>n>>hen;\n    rep(i,hen){\n        int s,t,d;\n        cin>>s>>t>>d;\n        dist[s][t]=d;\n    }\n    int ans=dfs(0,0,0);\n    if(ans==inf) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != 0 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    flag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\tif(e.exp[j] == 0) flag = false;\n\t\t    }\n\t\t}\n\t\tif(flag){\n\t\t    res = min(res,e.t);\n\t\t}\n\t\tst.push(e);\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) e.t = -1;\n    cout << e.t << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Contents   : DPL 2 A\n * Author     : Kitaura Hiromi\n * LastUpdate : 20180626\n * Since      : 20180626\n */\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 15\n#define INF 1<<20\nint n, E;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\n\nint main(void){\n    cin >> n >> E;\n    fill((int*)dp, (int*)(dp+(1<<MAX_N)), INF);\n    fill((int*)d, (int*)(d+MAX_N), INF);\n    for(int e=0; e<E; e++){\n        int i, j;\n        cin >> i >> j;\n        cin >> d[i][j];\n    }\n    dp[(1<<n) - 1][0] = 0;\n\n    for(int S=(1<<n)-2; S>=0; S--){\n        for(int v=0; v<n; v++){\n            for(int u=0; u<n; u++){\n                if(!(S>>u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n    if(dp[0][0] >= INF) cout << -1 << endl;\n    else cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconstexpr int inf = 0x3FFFFFFF;\nint dist[15][15];\nint dp[1<<15][15];\n\nvoid read_dist(int V, int E){\n    for (int i = 0; i != V; ++i){\n        for (int j = 0; j != V; ++j){\n            dist[i][j] = inf;\n        }\n    }\n    while (E--){\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n}\n\nint TSP(int V);\nvoid init_dp(int V);\nvector<int> find_visited_vertex(int mask);\n\nint main()\n{\n    int V = 0;\n    int E = 0;\n    cin >> V >> E;\n    read_dist(V, E);\n    cout << TSP(V);\n    return 0;\n}\n\nint TSP(int V){\n    init_dp(V);\n    int all = 1 << V;\n    for (int mask = 1; mask != all; ++mask){\n        auto vs = find_visited_vertex(mask);\n        for (auto v : vs){\n            int prev_mask = mask ^ (1 << v);\n            for (auto u : vs){\n                if (v == u) continue;\n                dp[mask][v] = min(dp[mask][v], dp[prev_mask][u] + dist[u][v]);\n            }\n        }\n    }\n    int min_cost = dp[all - 1][V - 1];\n    return (min_cost < inf) ? min_cost : -1;\n}\n\nvoid init_dp(int V){\n    for (int mask = 0; mask != 1 << V; ++mask){\n        for (int i = 0; i != V; ++i){\n            dp[mask][i] = inf;\n        }\n    }\n    dp[0][V - 1] = 0;\n    for (int i = 0; i != V - 1; ++i) dp[1 << i][i] = dist[V - 1][i];\n}\n\nvector<int> find_visited_vertex(int mask){\n    vector<int> vs;\n    int idx = 0;\n    while (mask){\n        if (mask & 1) vs.push_back(idx);\n        ++idx;\n        mask >>= 1;\n    }\n    return vs;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep_1 (i,j,n) for(int i=j;i<n;i++)\ntypedef long long ll;\ntypedef long l;\nconst ll l_INF = 1010101010101010;\nconst int INF = 1010101010;\nconst int dx[] = {-1,0,1,0,-1,-1,1,1};\nconst int dy[] = {0,-1,0,1,1,-1,1,-1};\nint n,m,a,b,c,x[20][20];\nint dp[20][1<<20];\n\nint main(){\n  rep(i,20){\n    rep(j,20) x[i][j]=INF;\n    rep(j,(1<<20)) dp[i][j]=INF;\n  }\n  cin>>n>>m;\n  rep(i,m){\n    cin>>a>>b>>c;\n    x[a][b]=c;\n  }\n  dp[0][1]=0;\n  rep(i,(1<<n)){\n    rep(j,n){\n      if(dp[j][i]<INF){\n        rep(k,n){\n          if((i/(1<<k))%2==0){\n            int dist=dp[j][i]+x[j][k];\n            int pos=i+(1<<k);\n            if(dp[k][pos]>dist){\n              dp[k][pos]=dist;\n            }\n          }\n        }\n      }\n    }\n  }\n  int maxn=INF;\n  rep(i,n) maxn=min(dp[i][(1<<n)-1]+x[i][0],maxn);\n  if(maxn==INF) maxn=-1;\n  cout<<maxn<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define P(X) cout<<\"db \"<<X<<endl;\n#define P2(X,Y) cout<<\"d2 \"<<X<<\" \"<<Y<<endl;\n#define P3(X,Y,Z) cout<<\"d3 \"<<X<<\" \"<<Y<<\" \"<<Z<<endl;\n#define SQ(x) ((x) * (x))\n\n#define ll long long\n#define pii pair<int,int>\n\n#define bchk(n,i) ((bool)(n&(1<<i)))\n#define bon(n,i) (n|(1<<i))\n#define boff(n,i) n=n&(~(1<<i))\n\n#define distance(a,b) (sq(a.x-b.x) + sq(a.y-b.y))\n#define MAX3(a,b,c) max(a,max(b,c))\n#define MS(XX,YY) memset(XX,YY,sizeof(XX));\n#define FastIO ios_base::sync_with_stdio(0);cin.tie(nullptr);\n#define eps 10e-9\n#define MX 10000005\n\nusing namespace std;\nint m,n,dp[16][(1<<16)+1];\nvector <int> edge[16],ecost[16];\nint tsp(int u,int mask){\n    if(dp[u][mask]!=-1) return dp[u][mask];\n    if(mask==((1<<n)-1)){\n        for(int i=0;i<edge[u].size();i++){\n            if(edge[u][i]==0) return ecost[u][i];\n        }\n        return MX;\n    }\n    int i,v,r,rm=MX;\n    for(i=0;i<edge[u].size();i++){\n        v=edge[u][i];\n        if(!bchk(mask,v)){\n            r=ecost[u][i]+tsp(v,bon(mask,v));\n            rm=min(rm,r);\n        }\n    }\n    return dp[u][mask]=rm;\n}\nint main()\n{\n    int i,j,test,cas=0;\n    int a,b,r,w;\n    //freopen(\"test.txt\",\"r\",stdin);\n    scanf(\"%d %d\",&n,&m);\n    MS(dp,-1)\n    for(i=0;i<m;i++){\n        scanf(\"%d %d %d\",&a,&b,&w);\n        edge[a].push_back(b);\n        ecost[a].push_back(w);\n    }\n    r=tsp(0,1);\n    if(r>=MX)r = -1;\n    printf(\"%d\\n\",r);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdint>\n  \nusing namespace std;\n  \nconst int INF = 10000000;\n  \nint solve(vector<vector<int>> &dists)\n{\n    const int v = dists.size();\n  \n    vector<vector<int>> dp(1 << v, vector<int>(v, INF));\n    dp[1][0] = 0;\n  \n    const int all = (1 << v) - 1;\n  \n    for (std::size_t S = 1; S <= all; S++)\n    {\n        std::size_t tS = S;\n        while (tS > 0) {\n            int bs = tS & ~(tS - 1);\n            int s = __builtin_ctzll(bs);\n            for (int e = 0; e < v; e++) {\n                if (dists[s][e] != INF && (~S & (1 << e)) != 0) {\n                    const int nS = S | (1 << e);\n                    if (nS == all) {\n                        dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e] + dists[e][0]);\n                    } else {\n                        dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e]);\n                    }\n                }\n            }\n            tS -= bs;\n        }\n    }\n  \n    int ans = INF;\n    for (int i = 0; i < v; i++) {\n        ans = min(ans, dp[all][i]);\n    }\n    return ans == INF ? -1 : ans;\n}\n  \nint main()\n{\n    int v, e;\n    cin >> v >> e;\n      \n    vector<vector<int>> dists(v, vector<int>(v, INF));\n    for (int i = 0; i < e; i++) {\n        int s, e, d;\n        cin >> s >> e >> d;\n        dists[s][e] = d;\n    }\n  \n    cout << solve(dists) << endl;\n  \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\nll dp[50000][20]; // 集合sまで巡回済みで、最後にjを訪れた時の最小コスト\nll G[20][20];\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  ll n,m; cin>>n>>m;\n  \n  rep(i,n) rep(j,n) G[i][j]=INF;\n  rep(i,m){\n    ll a,b,c; cin>>a>>b>>c;\n    G[a][b]=c;\n  }\n  \n  rep(i,50000) rep(j,n) dp[i][j]=INF;\n  dp[0][0]=0;\n  \n  // (2^n)*(n^2) ... n=15なら10^8程度\n  rep(s,1<<n){\n    // i => j への移動を考える\n    rep(i,n) rep(j,n){\n      if((s>>j&1)==0 && G[i][j]!=INF) chmin(dp[s|(1<<j)][j],dp[s][i]+G[i][j]);\n    }\n  }\n  \n  ll ans=dp[(1<<n)-1][0];\n  if(ans!=INF) cout<<ans<<endl;\n  else cout<<-1<<endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll;\nconst int INF = 10000000;\nint n, e;\nint d[15][15], dp[1 << 15][15];\nint rec(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) return dp[s][v] = 0;\n\telse if (dp[s][v] != -1) return dp[s][v];\n\telse {\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!(s >> i & 1)) res = min(res, d[v][i] + rec(s | 1 << i, i));\n\t\t}\n\t\treturn dp[s][v] = res;\n\t}\n}\nint main() {\n\tcin >> n >> e;\n\tfill(d[0], d[15], INF);\n\tfill(dp[0], dp[1 << 15], -1);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, dis; cin >> s >> t >> dis;\n\t\td[s][t] = dis;\n\t}\n\tif (rec(0, 0) >= 10000000) cout << -1 << endl;\n\telse cout << rec(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint V,E,G[15][15],dp[1<<15][15];\nconst int INF = 1000000;\n\nint solve() {\n  for (int s=(1<<V)-1;s>=0;--s) {\n    for (int t=0;t<V;++t) {\n      if (s == (1<<V)-1) {\n        dp[s][t] = 0;\n      } else {\n        dp[s][t] = INF;\n      }\n    }\n  }\n  for (int s=(1<<V)-2;s>=0;--s) {\n    for (int t=0;t<V;++t) {\n      for (int u=0;u<V;++u) {\n        if (!(s>>u&1)) {\n          dp[s][t] = min(dp[s][t],dp[s|(1<<u)][u]+G[t][u]);\n        }\n      }\n    }\n  }\n\n  return (dp[0][0] != INF)?dp[0][0]:-1;\n}\n\nint main() {\n  for (int i=0;i<15;++i) {\n    for (int j=0;j<15;++j) {\n      G[i][j] = INF;\n    }\n  }\n\n  cin>>V>>E;\n  for (int i=0;i<E;++i) {\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t] = d;\n  }\n\n  cout<<solve()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nclass edge{\n\tpublic:\n\tint t,d;\n\tedge(int it,int id){\n\t\tt=it;\td=id;\n\t}\n};\nvector<edge> e[20];\nll dp[16][1<<16];\nint main(){\n\tint n,m;\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint s,t,d;\tcin>>s>>t>>d;\n\t\te[s].push_back(edge(t,d));\n\t\te[t].push_back(edge(s,d));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=(1<<n)-1;j>=0;j--){\n\t\t\tdp[i][j]=2e14;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<(1<<n)-1;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[j][i]==2e14)\tcontinue;\n\t\t\tfor(int k=0;k<(int)e[j].size();k++){\n\t\t\t\tint next=i|(1<<e[j][k].t);\n\t\t\t\tif(next==i)\tcontinue;\n\t\t\t\tif(dp[e[j][k].t][next]>dp[j][i]+e[j][k].d){\n\t\t\t\t\tdp[e[j][k].t][next]=dp[j][i]+e[j][k].d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][(1<<n)-1]==2e14){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<dp[0][(1<<n)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 15;\nconst int MAX_M = 225;\n\nint n,m;\nll dp[1 << MAX_N][MAX_N];\nll d[MAX_N][MAX_N];\nint s[MAX_M];\nint t[MAX_M];\nint D[MAX_M];\n\nll solve()\n{\n\trep(S,1<<n){\n\t\tfill(dp[S],dp[S]+n,INF);\n\t}\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\trep(v,n){\n\t\t\tif(S==0 || (S>>v&1)){\n\t\t\t\trep(u,n){\n\t\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tll ans=INF-1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> s[i] >> t[i] >> D[i];\n\t}\n\trep(i,n){\n\t\tfill(d[0],d[n],INF);\n\t\trep(j,m){\n\t\t\td[(s[j]+n-i)%n][(t[j]+n-i)%n] = D[j];\n\t\t} \n\t\tans = min(ans,solve());\n\t}\n\tif(ans > 16000){\n\t\tcout << \"-1\\n\";\n\t}else{\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 15\n#define INF 10000\n\n\nint main()\n{\n    int v, e, s, t, p;\n    int d[MAX][MAX];\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            d[i][j] = INF;\n        }\n    }\n    for (int i = 0; i < MAX; i++) {\n        d[i][i] = 0;\n    }\n    cin >> v >> e;\n    for (int i = 0; i < e; i++) {\n        cin >> s >> t >> p;\n        d[s][t] = p;\n    }\n    \n    int dp[1<<MAX][MAX];\n    for (s = 0; s < 1 << v; s++) {\n        fill(dp[s], dp[s] + v, INF);\n    }\n    dp[(1 << v) - 1][0] = 0;\n    for (int s = (1 << v) - 2; s >= 0; s--) {\n        for (int i = 0; i < v; i++) {\n            for (int j = 0; j < v; j++) {\n                if (!(s >> j & 1)) {\n                    dp[s][i] = min(dp[s][i], dp[s | 1 << j][j] + d[i][j]);\n                }\n            }\n        }\n    }\n    if (dp[0][0] == INF) {\n        cout << -1 << endl;\n    }else{\n        cout << dp[0][0] << endl;\n    }\n    \n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec                vector<int>\n#define vecll              vector<ll>\n#define vecd               vector<double>\n#define vecst              vector<string>\n#define vecb               vector<bool>\n#define vec2(var, n, m)    vector<vector<int>>  var(n, vector<int>(m, 0))\n#define vecb2(var, n, m)   vector<vector<bool>> var(n, vector<bool>(m, false))\n#define vecll2(var, n, m)  vector<vector<ll>>   var(n, vector<ll>(m, INF))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define chmin(v1, v2)    v1 = min(v1, v2)\n#define chmax(v1, v2)    v1 = max(v1, v2)\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\nvoid prtok(bool ok){prt(ok ? \"Yes\" : \"No\");}\n//----------------------------------------------------------------\n\nint main(void) {\n  int v, e;\n  cin >> v >> e;\n  vector<vector<ll>> dist(v, vector<ll>(v, -1));\n  rep(i,e){\n    ll a, b, d;\n    cin >> a >> b >> d;\n    dist[a][b] = d;\n  }\n\n  ll INF = 1e18;\n  vector<vector<ll>> dp((1<<v), vector<ll>(v, INF));\n  dp[1][0] = 0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==INF) continue;\n      rep(k,v){\n        if(i&(1<<k)) continue;\n        if(dist[j][k]<0) continue;\n\n        int next_i = i | (1<<k);\n        chmin(dp[next_i][k], dp[i][j] + dist[j][k]);\n      }\n    }\n  }\n\n  ll ans=INF;\n  rep(i,v){\n    if(dist[i][0]<0)continue;\n    chmin(ans, dp[(1<<v)-1][i] + dist[i][0]);\n  }\n\n  if(ans==INF){\n    prt(-1);\n  } else {\n    prt(ans);\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int s,t,d;\n    cin>>s>>t>>d;\n    G[s].emplace_back(t,d);\n  }\n  const Int INF = 1e15;\n  Int ans=INF;\n  \n  for(Int p=0;p<n;p++){\n    auto dp=make_v<Int>(n,1<<n);\n    fill_v(dp,INF);\n    dp[p][1<<p]=0;\n    for(Int b=0;b<(1<<n);b++){\n      for(Int v=0;v<n;v++){\n\tif((~b>>v)&1) continue;\n\tfor(auto e:G[v]){\n\t  Int u,d;\n\t  tie(u,d)=e;\n\t  if(u==p&&b==(1<<n)-1) chmin(ans,dp[v][b]+d);\n\t  if((b>>u)&1) continue;   \n\t  chmin(dp[u][b|(1<<u)],dp[v][b]+d);\n\t}\n      }\n    }\n  }\n  \n  if(ans==INF) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nll dp[(1 << 16) + 1][20];\nll G[20][20];\nint main() {\n    int n, m, i, j, k;\n    cin >> n >> m;\n    for(i = 0; i <= n; i++) {\n        for(j = 0; j <= n; j++) {\n            G[i][j] = 1e9;\n        }\n    }\n    for(i = 0; i < m; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    for(i = 0; i < 1 << n; i++) {\n        for(j = 0; j < n; j++) {\n            dp[i][j] = 1e9;\n        }\n    }\n    dp[1][0] = 0; //始点は0に固定\n    for(i = 0; i < 1 << n; i++) {\n        for(j = 0; j < n; j++) {\n            if(i >> j & 1) {\n                for(k = 0; k < n; k++) {\n                    if(j != k && (i >> k & 1)) dp[i][j] = min(dp[i][j], dp[i ^ (1 << j)][k] + G[k][j]);\n                }\n            }\n        }\n    }\n    ll ret = 1e9;\n    for(i = 0; i < n; i++) {\n        ret = min(dp[(1 << n) - 1][i] + G[i][0], ret);\n    }\n    cout << (ret != 1e9 ? ret : -1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\nconst ll INF = 1e17;\n\nint main(){\n  int v, e;\n  cin >> v >> e;\n  vector<vector<ll>> d(v,vector<ll>(v,INF));\n  rep(i,e) {\n    ll s, t, a;\n    cin >> s >> t >> a;\n    d[s][t] = a;\n  }\n  vector<vector<ll>> dp(1<<v,vector<ll>(v,INF));\n  dp[0][0] = 0;\n  rep(i,1<<v) {\n    rep(j,v) {\n      rep(k,v) {\n        if(!(i&(1<<k))) dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k],dp[i][j]+d[j][k]);\n      } \n    }\n  }\n  cout << (dp[(1<<v)-1][0] == INF? -1 : dp[(1<<v)-1][0]) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ループverです。移動後はvisitedが増えるので, visited昇順にループを回せば良いです。\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint INF = 1000000007;\nint n, m;\nbool canMove[15][15] = {false};\nint ecost[15][15];\nint dp[1 << 15][15];\t//dp[visited][pos] = これまでの最小コスト（visitedの下位i(>=0)ビット目が1⇔頂点iを訪問済み, pos…現在地.）\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tecost[s][t] = d;\n\t\tcanMove[s][t] = true;\n\t}\n\t\n\tfor (i = 0; i < (1 << n); i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n\tdp[1][0] = 0;\n\tfor (i = 1; i < (1 << n) - 1; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\t//if (dp[i][j] >= INF) continue;\t//この行は無くてもよい\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\tif (!canMove[j][k]) continue;\n\t\t\t\t//if ((i >> k) & 1) continue;\n\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + ecost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (j = 0; j < n; j++) {\n\t\tif (dp[(1 << n) - 1][j] < INF && canMove[j][0]) {\n\t\t\tans = min(ans, dp[(1 << n) - 1][j] + ecost[j][0]);\n\t\t}\n\t}\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #Sazaの1日1AC\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+7;\nconst long long INF = 9e15;\nconst double PI = 3.14159265358979323846;\n\n//マクロ\n//型エイリアス\nusing ll = long long;\nusing P = pair<long long, long long>;\nusing vl = vector<long long>;\nusing vvl = vector<vector<long long>>;\nusing vP = vector<pair<long long, long long>>;\n//ショートカット\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define rep2(i, k, n) for (int i = k; i < n; i++) //半開区間\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb push_back\n#define mkp make_pair\n//入力\n#define vin(v, N) for (long long i = 0; i < N; i++) cin >> v.at(i)\n#define lin(n)long long n;cin >> n\n#define chin(x)char x;cin >> x;\n#define sin(s)string s;cin >> s;\n#define vlin(v, N)vector<long long> v(N);for (long long i = 0; i < N; i++)cin >> v.at(i)\n#define max(a, b) max((ll)a, (ll)b)\n#define min(a, b) min((ll)a, (ll)b)\n\n//関数\n//最大公約数\nlong long gcd(long long m, long long n){\n  long long a = max(m, n);\n  long long b = min(m, n);\n  long long r = a % b;\n  while (r != 0){\n    a = b;\n    b = r;\n    r = a % b;\n  }\n  return b;\n}\n// 最小公倍数\nlong long lcd(long long m, long long n){\n  return m * n / gcd(m, n);\n}\n//xのn乗\nlong long power(long long x, long long N){\n  long long ret = 1;\n  for (long long i = 0; i < N; i++)\n    ret *= x;\n  return ret;\n}\n//繰り返し二乗法\nlong long repeat_squaring(long long x, long long n){\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n  {\n    long long t = repeat_squaring(x, n / 2);\n    return t * t % mod;\n  }\n  else\n    return x * repeat_squaring(x, n - 1);\n}\n//素因数分解(mapで返す)\nmap<long long, long long> factor(long long p){\n  ll p1 = p;\n  map<long long, long long> ret;\n  for (long long i = 2; i * i <= p1; i++)\n  {\n    while (p % i == 0)\n    {\n      ret[i]++;\n      p /= i;\n    }\n  }\n  if (p != 1)\n    ret[p]++;\n  return ret;\n}\n//素数判定\nbool is_prime(long long N){\n  for (long long i = 2; i * i <= N; i++)\n  {\n    if (N % i == 0)\n      return false;\n  }\n  return true;\n}\n//最大値更新\nvoid chmax(long long &a, long long b){\n  a = max(a, b);\n}\n//最小値更新\nvoid chmin(long long &a, long long b){\n  a = min(a, b);\n}\n\n//構造体\n//Union-Find木\nstruct UnionFind\n{\n  //メンバ変数\n  vector<long long> par; //par[i]:=頂点iの親\n  vector<long long> s;   //s[i]:=頂点iが属する集合の個数(iが根のとき)\n\n  //コンストラクタ\n  UnionFind(long long N) : par(N), s(N){\n    for (long long i = 0; i < N; i++)\n    {\n      par[i] = i; //最初はすべてが根として初期化\n      s[i] = 1;\n    }\n  }\n  //メンバ関数\n  //root(i):=頂点iの根\n  long long root(long long i){\n    if (par[i] == i)\n      return i;\n    par[i] = root(par[i]); //経路圧縮\n    return root(par[i]);   //再帰\n  }\n  //size[i]:=iが属する集合の個数\n  long long size(long long i){\n    return s[root(i)];\n  }\n  //same(x,y) xとyが同じ根を持つか(同じ集合に含まれるか)\n  bool same(long long x, long long y){\n    return root(x) == root(y);\n  }\n  //unite(x,y) xの根をyの根に繋げる(集合を合併)\n  void unite(long long x, long long y){\n    if (!same(x, y)){\n      long long rx = root(x);\n      long long ry = root(y);\n      par[rx] = par[ry];\n      s[ry] = s[rx] + s[ry];\n    }\n  }\n};\n//Binary Indexed Tree\nstruct BIT{\n  vector<long long> bit;\n  long long N;\n\n  BIT(long long n){\n    N = n;\n    bit.resize(N + 1);\n  }\n\n  void add(long long i, long long w){\n    for (long long x = i; x <= N; x += x & -x){\n      bit[x] += w;\n    }\n  }\n  long long sum(long long i){\n    long long ret = 0;\n    for (long long x = i; x > 0; x -= x & -x){\n      ret += bit[x];\n    }\n    return ret;\n  }\n};\n/////////////////⊂('ω'⊂ )))Σ≡GO!/////////////////\nvvl dp;\nvvl G;\nll V,E;\n\nlong long rec(ll bit, ll v){\n  if(dp[bit][v] != -1) return dp[bit][v];\n\n  ll ret = INF;\n  ll prebit = bit - (1<<v);\n  if(prebit == 0){\n    return G[0][v];\n  }\n  rep(u, V){\n    if(prebit & 1<<u)\n      chmin(ret, rec(prebit, u) + G[u][v]);\n  }\n\n  return dp[bit][v] = ret;\n}\n\nint main(){\n  //doubleの桁数\n  std::cout << fixed << setprecision(10);\n\n  cin >> V >> E;\n  if(E == 0){\n    std::cout << -1 << endl;\n    return 0;\n  }\n  G.resize(E);\n  rep(i,E){\n    G[i].resize(E);\n    rep(j,E) G[i][j] = INF;\n  }\n  rep(i,E){\n    lin(s);lin(t);lin(d);\n    G[s][t] = d;\n  }\n  dp.resize((1<<V) + 1);\n  rep(i, dp.size()){\n    dp[i].resize(V);\n    rep(j,V) dp[i][j] = -1;\n  }\n  ll start = 0;\n  rep(i,V) start += 1<<i;\n\n  ll res = rec(start, 0);\n  if(res == INF) res = -1;\n  std::cout << res << endl;\n  //cout << rec(14, 2) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{int to,dist;};\nusing Graph  = vector<vector<edge>>;\n#define INF 1e9\n\nint main(){\n    int V,E;\n    cin >> V >> E;  \n\n    Graph G(V);\n    for(int i = 0;i < E;i++){\n        int s,t,d;\n        cin >> s >> t >> d;\n        G[s].push_back({t,d});\n    }\n\n    vector<vector<int>> dp(1 << V, vector<int>(V,INF));\n    dp[0][0] = 0;\n\n    for(int bit = 0;bit < (1 << V);bit++){\n        for(int nowV = 0; nowV < V;nowV++){\n            if(dp[bit][nowV] == INF) continue;\n            for(auto e : G[nowV]){\n                if((bit >> e.to) & 1) continue;\n                int nbit = bit | (1 << e.to);\n                dp[nbit][e.to] = min(dp[nbit][e.to], dp[bit][nowV] + e.dist);\n            }\n        }\n    }\n    cout << (dp[(1 << V) -1][0] == INF ? -1 : dp[(1 << V) -1][0]) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint V, E;\nint dp[1 << 15][20];\nsigned main() {\n    cin >> V >> E;\n    vector< vector<pii> > G(V);\n    rep(i,0,E) {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].pb(pii(t, d));\n    }\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,(1<<V)) rep(j,0,20) dp[i][j] = INF;\n    dp[(1<<V)-1][0] = 0;\n    \n    repr(bit,(1<<V)-2,0) {\n        rep(i,0,V) {\n            rep(j,0,G[i].size()) {\n                int to = G[i][j].fr, cost = G[i][j].sc;\n                if(bit >> to & 1) continue;\n                int nbit = bit | (1 << to);\n                dp[bit][i] = min(dp[bit][i], dp[nbit][to] + cost);\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,V) ans = min(ans, dp[0][0]);\n    if(ans != INF) cout << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <climits>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\n#define MAX_V 16\nint adjMat[MAX_V][MAX_V];\nbool visited[MAX_V][1<<MAX_V];//visited存的並非節點是否有訪問過,而是這個?態是否有出現過\nint dp[MAX_V][1<<MAX_V];//DP表格,第一個中括號代表目前所在的點\n//第二個中括號代表目前節點的?態(ex:0101011,表示1,3,5節點還沒走過,可以直接用bitwise操作來判斷?態)\n//因為DP表格是N*2^N次方,所以時間複雜度就是O(N*2^N)\nint v,e;\n\nconst char *byte_to_binary(int x)\n{\n    static char b[9];\n    b[0] = '\\0';\n\n    int z;\n    for (z = 128; z > 0; z >>= 1)\n    {\n        strcat(b, ((x & z) == z) ? \"1\" : \"0\");\n    }\n\n    return b;\n}\nint TSP(int at,int state)\n{\n    // printf(\"at=%d,state=%s\\n\",at, byte_to_binary(state));\n    if(state == (1<<v)-1 && at==0){ //全部的?態都走完而且回到起點惹\n        visited[at][state]=true;\n        return dp[at][state];\n    }\n    if(dp[at][state]) //出現過的?態,直接回傳結果\n        return dp[at][state];\n    int ans = INT_MAX>>1;\n    int cost;\n    for(int i=0;i<v;i++){\n        //state&(1<<i)==0表示判斷右邊數過來第i個bit是否為0,用來判斷該節點是否有走過\n        //state|(1<<i)表示將該節點設成走過\n        if(adjMat[at][i]!=-1 && (state & (1<<i))==0){\n            // printf(\"at=%d->i=%d\\n\",at,i);\n            cost = TSP(i,state|(1<<i)) + adjMat[at][i];//往?種可以走的路線都走下去\n            // printf(\"at=%d->i=%d,cost=%d\\n\",at,i,cost);\n            ans = min(ans,cost);//求出最小?\n        }\n    }\n    return dp[at][state] = ans;\n}\n//\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d %d\",&v,&e)){\n        memset(adjMat,-1,sizeof(adjMat));\n        for(int i=0;i<e;i++){\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            adjMat[u][v]=w;\n        }\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        int ans = TSP(0,0);\n        if(ans>=INT_MAX>>1)\n            puts(\"-1\");\n        else\n            printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=15,INF=1<<30;\nint S[MAX][MAX];\n\nint main(){\n\n    int V,E;cin>>V>>E;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            S[i][j]=INF;\n        }\n    }\n    \n    for(int i=0;i<E;i++){\n        int a,b,c;cin>>a>>b>>c;\n        S[a][b]=min(S[a][b],c);\n    }\n    \n    int ans=INF;\n    \n    for(int k=0;k<V;k++){\n        vector<vector<int>> dp((1<<V),vector<int>(V,INF));\n        dp[0][k]=0;\n        for(int x=0;x<=V;x++){\n            for(int bit=0;bit<(1<<V);bit++){\n                int cnt=0;\n                for(int i=0;i<V;i++){\n                    if(bit&(1<<i)) cnt++;\n                }\n                if(cnt!=x) continue;\n                for(int i=0;i<V;i++){\n                    if(dp[bit][i]==INF) continue;\n                    if(x&&!(bit&(1<<i))) continue;\n                    for(int j=0;j<V;j++){\n                        if(bit&(1<<j)) continue;\n                        if(S[i][j]==INF) continue;\n                        dp[bit|(1<<j)][j]=min(dp[bit|(1<<j)][j],dp[bit][i]+S[i][j]);\n                    }\n                }\n                //if(k==0) cout<<bit<<\" \"<<endl;\n            }\n        }\n        ans=min(ans,dp[(1<<V)-1][k]);\n    }\n    \n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n   V<V<int>> A(n, V<int>(n, INF));\n   REP(i, m) {\n      int s, t, d; cin >> s >> t >> d;\n      A[s][t] = d;\n   }\n\n   V<V<V<int>>> dp(n, V<V<int>>(1<<n, V<int>(n, INF)));\n   REP(k, n) {\n      dp[k][0][k] = 0;\n      REP(s, 1<<n) {\n         REP(i, n) {\n            REP(j, n) if (!(s >> j & 1)) {\n               chmin(dp[k][s | 1<<j][j], dp[k][s][i] + A[i][j]);\n            }\n         }\n      }\n   }\n   int ans = INF;\n   REP(k, n) {\n      chmin(ans, dp[k][(1<<n)-1][k]);\n   }\n   cout << (ans == INF ? -1 : ans) << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n#define p pair<ll,ll>\nconst ll MAX_N = 16;\nconst ll MAX_V = 1<<MAX_N; // 2^MAX_N (subsets of S)\nconst ll INF = (ll)1e18;\nvector<vector<p> > g(MAX_N);\nll dp[MAX_N][MAX_V];\nll n, m;\n\nll solve(ll v, unsigned int S) {\n    if (!(S&(1<<v))) return INF;\n    if (dp[v][S]) return dp[v][S];\n    if (v == 0 && S == 1) return 0;\n    ll res = INF;\n    for (p tp : g[v]) {\n        ll u = tp.first, w = tp.second;\n        //printf(\"exploring edge: (%lld, %lld)\\n\", v, u);\n        res = min(res, w+solve(u, S^(1<<v))); // v\\in S\n    }\n    //printf(\"%lld %u: %lld\\n\", v, S, res);\n    return dp[v][S] = res;\n}\n\n// n^2*2^n time, n*2^n space\nint main() {\n    cin >> n >> m;\n    if (n > 25) {\n        // 20 billion cycles > 20s\n        cout << \"This gonna take too long, lol\\n\";\n        return 0;\n    }\n    else if (n == 0) {\n        cout << \"Don't be silly\\n\";\n        return 0;\n    }\n    ll u, v, w, i;\n    for (i = 0; i < m; i++) {\n        cin >> u >> v >> w;\n        g[u].push_back(p(v,w));\n        //g[v].push_back(p(u,w));\n    }\n    ll res = INF;\n    unsigned int S = (1<<n)-1;\n    for (p tp : g[0]) {\n        ll v = tp.first, w = tp.second;\n        res = min(res, w+solve(v, S));\n    }\n    if (res == INF) cout << \"-1\\n\";\n    else cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/dpl_2_a_3rd/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\n\nusing namespace std;\n\n#define ll long long\n\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n\nclass Bits {\npublic:\n  inline static bool included(ll S, ll v) {\n    return ((S&(1<<v))>>v) == 1;\n  }\n  inline static ll add(ll S, ll v) {\n    return S|(1<<v);\n  }\n  inline static ll remove(ll S, ll v) {\n    return S&(~(1<<v));\n  }\n};\n\nconst ll INF = 100000000000000000;\nconst int MAX = 20;\nint V, E;\nint G[MAX][MAX] = {-1};\n\nll all = 1;\n// dp[S][i] := S: これまでに訪れた頂点集合（iを含む）, i: 今いる頂点\nll dp[0b111111111111111111][MAX];\n\nvoid input() {\n  memset(G, -1, sizeof(G));\n  cin >> V >> E;\n  ll v, u, d;\n  loop(n,0,E) {\n    cin >> v >> u >> d;\n    G[v][u] = d;\n  }\n\n  for (int v=0; v<V; v++) {\n    all = Bits::add(all, v);\n  }\n}\n\nvoid solve() {\n  loop(S,0,all+1) loop(i,0,V+1) dp[S][i] = INF;\n  dp[1][0] = 0;\n  for (ll S=1; S<=all; S++) {\n    for (int to=1; to<V; to++) {\n      if (!Bits::included(S, to)) continue;\n      for (int from=0; from<V; from++) {\n        if (G[from][to] == -1) continue;\n        if (!Bits::included(S, from)) continue;\n        if (chmin(dp[S][to], dp[Bits::remove(S, to)][from] + G[from][to])) {\n          // cout << S << \" \" << to << \" \" << from << \" \" << dp[S][to] << endl;\n        }\n      }\n    }\n  }\n  ll min_ = INF;\n  loop(i,0,V) {\n    if (dp[all][i] != INF && G[i][0] >= 0) {\n      chmin(min_, dp[all][i] + G[i][0]);\n    }\n  }\n  if (min_ == INF) cout << -1 << endl;\n  else cout << min_ << endl;\n}\n\nvoid dump() {\n  for (ll S=0; S<all; S++) {\n    for (int i=0; i<V; i++) {\n      if (!Bits::included(S, i)) continue;\n      cout << S << \": i = \" << i << \" dp = \" << dp[S][i] << endl;\n    }\n  }\n}\n\nint main() {\n  // cout.precision(15);\n  input();\n  solve();\n  // dump();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1 || dis[s][i] == -1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (!dis[s][t])\n\t\t\t{\n\t\t\t\tdis[s][t] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\nvoid rec(vector<vector<int> > &Y, int i, int S, vector<int> &path) {\n    if (S != 0) rec(Y, Y[i][S], S & ~(1 << i), path);\n    path.push_back(i);\n}\n\nint TSP(vector<vector<int> > &E, int s, vector<int> &result) {\n    const int n = E.size(), N = 1 << n;\n    vector<vector<int> > X(n, vector<int>(N, INT_MAX));\n    vector<vector<int> > Y(n, vector<int>(N, -1));\n    for (int i = 0; i < n; ++i) {\n        X[i][1 << i] = E[s][i];\n        Y[i][1 << i] = s;\n    }\n    for (int S = 1; S < N; ++S) {\n        for (int i = 0; i < n; ++i) {\n            if (!(S & (1 << i))) continue;\n            for (int j = 0; j < n; ++j) {\n                if (S & (1 << j)) continue;\n                if (X[j][S | (1 << j)] > X[i][S] + E[i][j]) {\n                    X[j][S | (1 << j)] = X[i][S] + E[i][j];\n                    Y[j][S | (1 << j)] = i;\n                }\n            }\n        }\n    }\n    result.clear();\n    rec(Y, s, (1 << n) - 1, result);\n    return X[s].back();\n}\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    vector<vector<int>> edges(v, vector<int>(v, INT_MAX / 100));\n\n    rep(i, e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        edges[s][t] = d;\n    }\n    vector<int> results;\n    int ans = TSP(edges, 0, results);\n    if (ans >= INT_MAX / 100) {\n        cout << -1 << endl;\n        return 0;\n    }\n    cout << ans << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\nint memo[100000];\nvector<vector<pair<int,int> > > graph;\n\nint dp(int n,int c,int bit){\n\n  if(bit == (pow(2,v)-1)){\n    for(int i = 0;i < graph[n].size();i++){\n      if(graph[n][i].first == 0){\n        return memo[bit] = graph[n][i].second;\n      }\n    }\n    return 1000000;\n  }\n\n  //if(memo[bit] != 0){\n  //  return memo[bit];\n  //}\n\n  if(graph[n].size() == 0){\n    return 1000000;\n  }\n\n\n  int a = 20000;\n\n  for(int i = 0;i < graph[n].size();i++){\n    if((bit & (1 << graph[n][i].first)) == 0){\n      a = min(a,dp(graph[n][i].first,c+1,(bit | (1 << graph[n][i].first)))+graph[n][i].second);\n    }\n  }\n\n  return memo[bit] = a;\n}\n\n\n\nint main(){\n  cin >> v >> e;\n  graph.resize(v);\n  for(int i = 0;i < e;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    pair<int,int> p = make_pair(t,d);\n    graph[s].push_back(p);\n  }\n\n  int ans = dp(0,0,1);\n\n  if(ans >= 20000){\n    cout << -1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ninline int getbit(int mask, int v) {\n    return (mask >> v) & 1;\n}\n\ninline int newmask(int mask, int v) {\n    return mask | (1 << v);\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int cost[n][n];\n    vector <int> g[n];\n    int x, y, c;\n    for (int i = 0; i < m; i++) {\n        cin >> x >> y >> c;\n        g[x].push_back(y);\n       // g[y].push_back(x);\n        cost[x][y] = c;\n       // cost[y][x] = c;\n    }\n    int P = pow(2, n);\n    int d[P][n];\n    for (int i = 1; i < P; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = -1;\n        }\n    }\n    d[1][0] = 0;\n    const int INF = 1e9;\n    int ans = INF;\n    for (int mask = 1; mask < P; mask++) {\n        for (int v = 0; v < n; v++) {\n            if (d[mask][v] != -1) {\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    int u = g[v][i];\n                    if (mask < P - 1) {\n                        if (!getbit(mask, u)) {\n                            d[newmask(mask, u)][u] = d[mask][v] + cost[v][u];\n                        }\n                    } else {\n                        if (u == 0) {\n                            ans = min(ans, d[mask][v] + cost[v][0]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint dp[1<<15][15];\nvector<pair<int,int>> ls[15];\nint main(){\n\tint v,e;\tcin>>v>>e;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,d;\tcin>>s>>t>>d;\n\t\tls[s].push_back(make_pair(t,d));\n\t}\n\tfor(int i=0;i<15;i++){\n\t\tfor(int j=0;j<1<<15;j++)\tdp[j][i]=inf;\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<(int)ls[0].size();i++){\n\t\tint to=ls[0][i].first,cost=ls[0][i].second;\n\t\tdp[1<<to][to]=cost;\n\t}\n\tfor(int i=1;i<1<<v;i++){\n\t\tfor(int j=0;j<v;j++){\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\t\tif(dp[i][j]==inf)\tcontinue;\n\t\t\tfor(int k=0;k<(int)ls[j].size();k++){\n\t\t\t\tint to=ls[j][k].first,cost=ls[j][k].second;\n\t\t\t\tif(i&(1<<to))\tcontinue;\n\t\t\t\tdp[i|(1<<to)][to]=min(dp[i|(1<<to)][to],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\tif(dp[(1<<v)-1][0]==inf)\tcout<<-1<<endl;\n\telse \tcout<<dp[(1<<v)-1][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nlong long gcd(long long a,long long b){if(a%b==0){return b;}else return gcd(b,a%b);}\nlong long lcm(long long a,long long b){if(a==0){return b;} return a/gcd(a,b)*b;}\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define WHITE 1\n#define BLACK 2\n#define GRAY 1\n#define RE return 0\n#define int ll\n\nint n,m;\nint d[100][100];\nint dp[1<<15][100];\n\nsigned main(){\n  cin>>n>>m;\n  for(int i=0; i<n; i++) for(int j=0; j<n; j++) d[i][j]=INF;\n  for(int i=0; i<m; i++){\n    int a,b,c; cin>>a>>b>>c;\n    d[a][b]=c;\n  }\n  for(int s=0; s<(1<<15); s++){\n    fill(dp[s], dp[s]+n, INF);\n  }\n  \n  dp[(1<<n)-1][0]=0;\n  \n  for(int S=(1<<n)-2; S>=0; S--){\n    for(int v=0; v<n; v++){\n      for(int u=0; u<n; u++){\n        if(!(S>>u&1)){\n          dp[S][v]=min(dp[S][v], dp[S|1<<u][u]+d[v][u]);\n        }\n      }\n    }\n  }\n  if(dp[0][0]<INF) cout<<dp[0][0]<<en;\n  else cout<<-1<<en;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cfloat>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps DBL_EPSILON\n#define mod (ll)1000000007\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique priority_queue\nusing namespace std;\nint v, e, s, t, d, edge[15][15];;\nint dp[100000][15];\nsigned main() {\n\tcin >> v >> e;\n\trep(i, v) {\n\t\trep(j, v)edge[i][j] = INF;\n\t}\n\trep(i, e) {\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tint ans = INF;\n\trep(s, v) {\n\t\trep(i, ((ll)1 << v)) {\n\t\t\trep(j, v)dp[i][j] = INF;\n\t\t}\n\t\tdp[((ll)1 << v) - 1 - ((ll)1 << s)][s] = 0;\n\t\tfor (int i = ((ll)1 << v) - 1; i > 0; i--) {\n\t\t\trep(j, v) {\n\t\t\t\tif (((i >> j) & 1) == 0)continue;\n\t\t\t\trep(k, v) {\n\t\t\t\t\tif (edge[k][j] != INF) {\n\t\t\t\t\t\tdp[i - ((ll)1 << j)][j] = min(dp[i - ((ll)1 << j)][j], dp[i][k] + edge[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, v) {\n\t\t\tans = min(ans, dp[0][i] + edge[i][s]);\n\t\t}\n\t}\n\tif(ans!=INF)cout << ans << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,m,a,b,c,d[15][15],dp[(1<<15)][15];\nint main(void){\n    cin>>n>>m;\n    for(int i=0;i<15;i++){\n        for(int j=0;j<15;j++){\n            d[i][j]=-1;\n        }\n    }\n    for(int i=0;i<m;i++){\n        cin>>a>>b>>c;\n        d[a][b]=c;\n    }\n    for(int i=0;i<(1<<n);i++){\n        for(int j=0;j<15;j++){\n            dp[i][j]=1e9;\n        }\n    }\n    \n    dp[0][0]=0;\n    for(int i=0;i<(1<<n);i++){\n        for(int k=0;k<n;k++){\n            for(int j=0;j<n;j++){\n                if(((i>>j)&1)==1)continue;\n                if(d[k][j]!=-1){\n                    dp[i|(1<<j)][j]=min(dp[i|(1<<j)][j],dp[i][k]+d[k][j]);\n                }\n            }\n        }\n    }\n    if(dp[(1<<n)-1][0]==1e9)cout<<-1<<endl;\n    else cout<<dp[(1<<n)-1][0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n \n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n \n//typedef\n//------------------------------------------\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF=INT_MAX/10;\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n\n#define MAX_N 20\nint n;\nint d[MAX_N][MAX_N];\n\nint dp[1<<MAX_N][MAX_N];\n\nint rec(int S,int v){//??¢????????£??????????????????S??¨???????????????v\n\t\n\tif(dp[S][v]>=0){//??¢?????????S????????????v??????????????????????????????\n\t\treturn dp[S][v];\n\t}\n\tif(S==(1<<n)-1&&v==0){//S?????¨??????????????????????????¶?????§???????????????????????£?????????\n\t\tdp[S][v]=0;\n\t\treturn 0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<n;u++){\n\t\tif(!(S>>u & 1)){//??????u??????????????£??????????????¨???\n\t\t\tres=min(res,rec(S|1<<u, u)+d[v][u]);//??????u???S???????????????u->v????????????????????????????????´?????¨????????¨???res????????????\n\t\t}\n\t}\n\tdp[S][v]=res;\n\t//cout<<res<<endl;\n\treturn res;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\t\n\tint V,E;\n\tcin>>V>>E;\n\tn=V;\n\tREP(i,n)REP(j,n)d[i][j]=INF;\n\tREP(i,E){\n\t\tint s,t,cost;\n\t\tcin>>s>>t>>cost;\n\t\td[s][t]=cost;\t\t\n\t}\n\tint res=rec(0,0);\n\tif(res<INF)cout<<res<<endl;\n\telse cout<<-1<<endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, e) for (int i = (int)(s); i <= (int)(e); i++)\n#define printYesNo(is_ok) puts(is_ok ? \"Yes\" : \"No\");\n#define SORT(v) sort(v.begin(), v.end());\n#define RSORT(v) sort(v.rbegin(), v.rend());\n#define REVERSE(v) reverse(v.begin(), v.end());\n\nint main()\n{\n  int V, E;\n  cin >> V >> E;\n  vector<vector<int>> graph(V, vector<int>(V, -1));\n  rep(i, E)\n  {\n    int s, t, d;\n    cin >> s >> t >> d;\n    graph[s][t] = d;\n  }\n\n  long long ans = 1e9;\n  rep(s, V)\n  {\n    vector<vector<long long>> dp(pow(2, V), vector<long long>(V, 1e9));\n    dp[1 << s][s] = 0;\n    rep(i, pow(2, V) - 1)\n    {\n      rep(j, V)\n      {\n        rep(nj, V)\n        {\n          if (graph[j][nj] == -1)\n            continue;\n          if ((i >> nj & 1) == 1)\n            continue;\n          if ((i >> j & 1) == 0)\n            continue;\n          int ni = i + (1 << nj);\n          dp[ni][nj] = min(dp[ni][nj], dp[i][j] + graph[j][nj]);\n        }\n      }\n    }\n    long long score = 1e9;\n    rep(i, V)\n    {\n      if (graph[i][s] == -1)\n        continue;\n      score = min(score, dp[pow(2, V) - 1][i] + graph[i][s]);\n    }\n    ans = min(ans, score);\n  }\n  if (ans == 1e9)\n    ans = -1;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint** dp = new int*[N];\n\tbool* check = new bool[limit];\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i] = new int[limit];\n\t\tfor(int k = 0; k < limit; k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < limit; i++)check[i] = false;\n\n\tminimum = BIG_NUM;\n\n\ttmp = pow(2,0);\n\n\tdp[0][tmp] = 0;\n\n\tcheck[tmp] = true;\n\n\tfor(int state = 0; state <= limit-1; state++){\n\t\tif(!check[state])continue;\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(dp[k][state] == BIG_NUM)continue;\n\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\tif(state == limit-1 && a == 0){\n\t\t\t\t\t\tif(cost[k][0] != BIG_NUM)dp[0][limit-1] = min(dp[0][limit-1],dp[k][state]+cost[k][0]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\ttmp = state + pow(2,a);\n\n\t\t\t\t\t\tif(dp[a][tmp] > dp[k][state]+cost[k][a]){\n\t\t\t\t\t\t\tdp[a][tmp] = dp[k][state]+cost[k][a];\n\t\t\t\t\t\t\tcheck[tmp] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tminimum = min(minimum,dp[0][limit-1]);\n\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tlong long int V, E;\n\tcin >> V >> E;\n\t\n\tlong long int cost[V][V];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tcost[u][v] = c;\n\t}\n\t\n\tlong long int DP[V][(1 << V)];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < (1 << V); j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tDP[0][0] = 0;\n\t\n\tfor(int i = 0; i < (1 << V); i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tint hoge = i - (1 << j);\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tDP[j][i] = min(DP[j][i], DP[k][hoge] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << DP[j][i] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\t\n\tif(DP[0][(1 << V) - 1] == INF){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << DP[0][(1 << V) - 1] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define RS resize\n#define CLR clear\n#define PB push_back\n#define ALL(x) (x).begin(), (x).end()\n#define LLI long long int\nusing namespace std;\n\nconst int inf = INT_MAX / 100;\n\nint TSP(vector<vector<int>> &graph, int src){\n  int v = graph.size(), n = 1 << v;\n  vector<vector<int>> dp(v, vector<int>(n, inf));\n\n  REP(i,v){\n    dp[i][1<<i] = graph[src][i];\n  }\n  \n  FOR(s,1,n){\n    REP(i,v){\n      if(!(s & (1<<i))) continue;\n      REP(j,v){\n\tif(s & (1<<j)) continue;\n\tif(graph[i][j] != -1)\n\t  dp[j][s | (1<<j)] = min(dp[j][s | (1<<j)], dp[i][s] + graph[i][j]);\n      }\n    }\n  }\n\n  return dp[src][n-1];\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int v,e;\n  cin >> v >> e;\n  \n  vector<vector<int>> graph(v, vector<int>(v,-1));\n\n  REP(i,e){\n    int s,t,d; cin >> s >> t >> d;\n    graph[s][t] = d;\n  }\n\n  int ans = TSP(graph, 0);\n  cout << (ans>=inf ? -1 : ans) << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s = 0, int d = 0, Weight w = 0)\n    : src(s), dst(d), weight(w) {\n  }\n};\n\nusing Edges  = vector<Edge>;\nusing Graph  = vector<Edges>;\nusing Array  = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  g[a].emplace_back(a, b, w);\n}\n\nvoid addEdge(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  addArc(g, a, b, w);\n  addArc(g, b, a, w);\n}\n\nvoid solve() {\n  int v, e;\n  cin >> v >> e;\n  Graph g(v);\n  while (e--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    addArc(g, s, t, d);\n  }\n  vvi dp(1 << v, vi(v, INF));\n  dp[0][0] = 0;\n  rep(s, 1 << v) {\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (~s >> e.dst & 1) cmin(dp[s | 1 << e.dst][e.dst], dp[s][e.src] + e.weight);\n      }\n    }\n  }\n  int x = dp.back().front();\n  cout << (x == INF ? -1 : x) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[1 << i][i] = 0;\n    }\n    for(int s = 1; s < (1 << v); s++){\n        rep(i, v){\n            if((s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> G(V, vector<int>(V, INF));\n\tfor (int i=0;i<E;i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\n\tint ans = INF;\n\tfor (int s=0;s<V;s++) {\n\t\tvector<vector<int>> dp((1<<V), vector<int>(V, INF));\n\t\tdp[(1<<s)][s] = 0;\n\t\tfor (int i=0;i<(1<<V);i++) {\n\t\t\tfor (int j=0;j<V;j++) {\n\t\t\t\tfor (int k=0;k<V;k++) {\n\t\t\t\t\tif (dp[i][j] != INF && G[j][k] != INF && (i&(1<<k)) == 0) {\n\t\t\t\t\t\tdp[i+(1<<k)][k] = min(dp[i+(1<<k)][k], dp[i][j]+G[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tif (G[i][s] != INF) {\n\t\t\t\tans = min(ans, dp[(1<<V)-1][i]+G[i][s]);\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n     \n#define REP( i, n )     for( int (i) = 0; (i) < (n); (i)++ )\n#define ALL( a )        (a).begin(), (a).end()\n     \nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n     \ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n     \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nint G[20][20];\nint dp[1 << 15][20];\n\nint rec( int S, int v, int n ){\n  if( dp[S][v] >= 0 ){\n    return dp[S][v];\n  }\n\n  if( S == ( 1 << n ) - 1 && v == 0 ){\n    return dp[S][v] = 0;\n  }\n\n  int res = INF;\n  REP( i, n ){\n    if( !( S >> i & 1 ) ){\n      chmin( res, rec( S | 1 << i, i, n ) + G[v][i] );\n    }\n  }\n  \n  return dp[S][v] = res;\n}\n\nint main(){\n  int v, e; cin >> v >> e;\n\n  fill( G[0], G[v], INF );\n  \n  REP( i, e ){\n    int f, t, d; cin >> f >> t >> d;\n    G[f][t] = d;\n  }\n\n  fill( dp[0], dp[1 << 15], -1 );\n\n  int ans = rec( 0, 0, v );\n  if( ans != INF ){\n    cout << ans << endl;\n  }else{\n    cout << -1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 100000;\n\nconst int MAX_V = 15;\nint d[MAX_V][MAX_V];\nint V;\n\nint dp[1 << MAX_V][MAX_V];\n\nint solve(int S, int v)\n{\n  if(dp[S][v] >= 0) return dp[S][v];\n\n  if(S == (1 << V) - 1 && v == 0) return dp[S][v] = 0;\n\n  int ans = INF;\n  for(int u = 0; u < V; u++)\n    if(!(S >> u & 1))\n      ans = min(ans, solve(S | 1 << u, u) + d[v][u]);\n\n  return dp[S][v] = ans;\n}\n\nint main()\n{\n  int E;\n  scanf(\"%d %d\", &V, &E);\n\n  fill(&d[0][0], &d[MAX_V][0], INF);\n  for(int i = 0; i < E; i++){\n    int s, t, c;\n    scanf(\"%d %d %d\", &s, &t, &c);\n    d[s][t] = c;\n  }\n\n  fill(&dp[0][0], &dp[1 << MAX_V][0], -1);\n  int ans = solve(0, 0);\n  if(ans != INF)\n    printf(\"%d\\n\", ans);\n  else\n    printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define INF 0x3f3f3f3f\nusing namespace std;\n\nint V;\nint d[15][15];\nint dp[1 << 15][15];\n\nint rec(int S, int v) {\n\tif (dp[S][v] >= 0)return dp[S][v];\n\tif (S == (1 << V) - 1 && v == 0)return dp[S][v] = 0;\n\tint res = INF;\n\trep(u, V) {\n\t\tif (!(S >> u & 1))res = min(res, rec(S | 1 << u, u) + d[v][u]);\n\t}\n\treturn dp[S][v] = res;\n}\nint main() {\n\tint E; scanf(\"%d%d\", &V, &E);\n\tmemset(d, 0x3f, sizeof(d));\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, E) {\n\t\tint s, t, c; scanf(\"%d%d%d\", &s, &t, &c);\n\t\td[s][t] = c;\n\t}\n\tint ans = rec(0, 0);\n\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 0x3fffffff\nusing namespace std;\n\nint v, e, edge[15][15], dp[15][1 << 15];\n\nint rec(int S/*ノード集合*/,int s/*スタート地点*/,int n/*現在地点*/){\n\tif(dp[s][S] != -1){\n\t\treturn dp[s][S];\n\t}\n\tif(S == ((1 << v) - 1) && edge[n][s] != -1){\n\t\treturn dp[s][S] = edge[n][s];\n\t}\n\tint res = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tif(((S >> i) & 1) == 0 && edge[n][i] != -1){\n\t\t\tres = min(rec(S | (1 << i),s,i) + edge[n][i],res);\n\t\t}\n\t}\n\treturn dp[s][S] = res;\n}\n\nint main() {\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < v;i++){\n\t\trec(1 << i,i,i);\n\t}\n\tint ans = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tans = min(dp[i][1 << i],ans);\n\t}\n\tif(ans >= INF){\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\nconst int INF = 1e9;\nconst int MOD = 1000000007;\nint v,e;\nvector<vector<int>> Graph(15,vector<int>(15,INF));\nvector<vector<int>> dp(pow(2,15),vector<int>(15,INF));\n\n\nint main(){\n        cin >> v >> e;\n        rep(i,e){\n                 int a,b,c;\n                 cin >> a >> b >>c;\n                Graph.at(a).at(b) = c;\n        }\n        dp[1][0] = 0;\n  \n  //配るdp\n        rep(i,pow(2,v)){   //iはこれまでに通った頂点の集合\n                rep(j,v){  //jは最後に通った頂点\n                        if(dp.at(i).at(j) ==INF) continue;\n                        rep(k,v){//kはjの次に通る頂点\n                                if(Graph.at(j).at(k) ==INF) continue;\n                                if(i>>k & 1) continue;\n                                dp.at((1<<k)|i).at(k) = min(dp.at((1<<k)|i).at(k),dp.at(i).at(j) + Graph.at(j).at(k));\n                        }\n                }\n        }                \n        \n        int ans = INF;\n        rep(i,v){\n                if(i == 0) continue;\n                if(dp.at(pow(2,v)-1).at(i) ==INF) continue;\n                if(Graph.at(i).at(0) ==INF) continue;\n                ans = min(ans,dp.at(pow(2,v)-1).at(i)+Graph.at(i).at(0));\n        }\n        if(ans == INF) cout << -1 << endl;\n        else cout << ans <<endl; \n        \n  \n                                                                   \n        return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);(i)++)\n#define rept(i,n) for(ll (i)=0;(i)<=(ll)(n);(i)++)\n#define reps(i,s,n) for(ll (i)=(s);(i)<(ll)(n);(i)++)\n#define repst(i,s,n) for(ll (i)=(s);(i)<=(ll)(n);(i)++)\n#define repr(i,n) for(ll (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\???\n// .???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????.???.:( ^??^)?????????\n// ?????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\????????????????????\\??????????????????\n\nint V, E, s, t, d, dp[1<<15][15], e[15][15];\n\nint main() {\n\tcin >> V >> E;\n\trep(i,V) {\n\t\tfill(e[i], e[i]+V, inf);\n\t\te[i][i] = 0;\n\t}\n\trep(i,E) {\n\t\tcin >> s >> t >> d;\n\t\te[s][t] = d;\n\t}\n\trep(i,1<<V) fill(dp[i], dp[i]+V, inf);\n\tdp[(1<<V)-1][0] = 0;\n\trepr(i,(1<<V)-2) {\n\t\trep(j,V) {\n\t\t\trep(k,V) {\n\t\t\t\tif (!(i>>k & 1)) chmin(dp[i][j], dp[i|(1<<k)][k]+e[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[0][0]!=inf) cout << dp[0][0] << ln;\n\telse cout << -1 << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint V, E;\nint const max_v = 20;\nconst int INF = 100000000;\nvector<int> G[max_v];\nint C[max_v][max_v];\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n\n    //初期化\n    for (int i = 0; i < max_v; i++)\n    {\n        for (int j = 0; j < max_v; j++)\n        {\n            if (i == j)\n            {\n                C[i][i] = 0;\n            }\n            else\n            {\n\n                C[i][j] = INF;\n            }\n        }\n    }\n\n    // グラフの入力\n    for (int i = 0; i < E; i++)\n    {\n        int from, to, cost;\n        cin >> from >> to >> cost;\n        C[from][to] = cost;\n    }\n\n    // DPの初期化\n    int dp[1 << V][V];\n    for (int i = 0; i < (1 << V); i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][0] = 0;\n\n    // DP開始\n    // S = 10010などすでに訪れた頂点を示す\n    for (int S = 0; S < (1 << V); S++)\n    {\n        //v = 次に訪れる頂点\n        for (int v = 0; v < V; v++)\n        {\n            for (int u = 0; u < V; u++)\n            {\n                if ((S & (1 << v)) == 0 || v == u)\n                {\n                    continue;\n                }\n                dp[S][v] = min(dp[S][v], dp[S & ~(1 << v)][u] + C[u][v]);\n                /*\n                if ((S & (1 << v)) == 0 && C[u][v] != INF)\n                {\n                    dp[S | (1 << v)][v] = min(dp[S | (1 << v)][v], dp[S][u] + C[u][v]);\n                }\n                */\n            }\n        }\n    }\n\n    if (dp[(1 << V) - 1][0] == INF)\n    {\n        cout << -1 << endl;\n    }\n    else\n    {\n        cout << dp[(1 << V) - 1][0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nstruct TSPSuffix {\n    int n;\n    vector<vector<int>> graph;\n\n    TSPSuffix(int n) : n(n) {\n        graph.assign(n, vector<int>(n, INF));\n    }\n\n    void addEdge(int u, int v, int w) {\n        graph[u][v] = w;\n    }\n\n    int search() {\n        int m = (1 << n) - 1;\n\n        vector<vector<int>> memo(m + 1, vector<int>(n, -1));\n\n        memo[m][0] = 0;\n\n        return dp(0, 0, memo);\n    }\n\n    int dp(int s, int i, vector<vector<int>>&memo) {\n        if (memo[s][i] != -1) {\n            return memo[s][i];\n        }\n        int result = INF;\n        for (int j = 0; j < n; j++) {\n            if ((s & (1 << j)) == 0) {\n                int l = dp(s ^ (1 << j), j, memo);\n                result = min(result, graph[i][j] + l);\n            }\n        }\n        memo[s][i] = result;\n\n        return result;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    TSPSuffix tsp(n);\n    for (int i = 0; i < m; i++) {\n        int from, to, w;\n        cin >> from >> to >> w;\n        tsp.addEdge(from, to, w);\n    }\n\n    int ans = tsp.search();\n\n    cout << (ans == INF? -1 : ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst int M = 20;\nWeight best[1<<M][M];\nint    prev[1<<M][M];\nvoid buildPath(int S, int i, vector<int> &path) {\n  if (!S) return;\n  buildPath(S^(1<<i), prev[S][i], path);\n  path.push_back(i);\n}\nWeight shortestHamiltonCycle(Matrix w, vector<int> &path) {\n  int n=w.size();\n  int N = 1 << n;\n  REP(S,N) REP(i,n) best[S][i] = INF;\n  best[0][0] = 0;\n  REP(S,N) REP(i,n) REP(j,n) if (!(S&(1<<j)))\n    if (best[S|(1<<j)][j] > best[S][i] + w[i][j])\n      best[S|(1<<j)][j] = best[S][i] + w[i][j],\n      prev[S|(1<<j)][j] = i;\n  int t = min_element(best[N-1], best[N-1]+n) - best[N-1];\n  path.clear(); buildPath(N-1, t, path);\n  return best[N-1][0]==INF ? -1 : best[N-1][0];\n}\n\nint main(){\n\tint V,E,s,t,d;\n\tscanf(\"%d%d\",&V,&E);\n\tMatrix m(V,Array(V));\n\tfor(s=0;s<V;s++)for(t=0;t<V;t++)if(s!=t)m[s][t]=INF;\n\tvector<int>path;\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&d),m[s][t]=d;\n\tprintf(\"%d\\n\",shortestHamiltonCycle(m,path));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 15001\n\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n\n\t巡回セールスマン問題。\n\n\tdp[V][0] = 0\n\tdp[S][v] = min {dp[S ∪ [u]][u] + d(v,u)| u ? S}\n\n\t参考：蟻本 p 174\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MAX_V = 15;\n\nint V, E;\nint d[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\t// メモ化テーブル\nint s;\t\t\t\t// スタート位置\n\n// すでに訪れた頂点がS、現在位置が v\nint dfs (int S, int v ){\n\tif (dp[S][v] >= 0 ) return dp[S][v];\n\n\tif (S == (1<<V)-1 && v == s ){\n\t// すべての頂点を訪れて戻って来た\n\t\treturn dp[S][v] = 0;\n\t} // end if\n\n\tint res = INF;\n\tfor (int u = 0; u < V; u++ ){\n\t\tif (!(S>>u & 1 ) ){\n\t\t\t// 次に u に移動する\n\t\t\tres = min (res, dfs (S | (1<<u), u ) + d[v][u] );\n\t\t} // end if\n\t} // end for\n\n\treturn dp[S][v] = res;\n}\n\nint main()\n{\n\trep (i, MAX_V ) rep (j, MAX_V ) d[i][j] = INF;\n\n\tios_base::sync_with_stdio(0);\n\tcin >> V >> E;\n\trep (i, E ){\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\td[from][to] = cost;\n\t} // end rep\n\n\tint res = INF;\n\trep (i, V ){\n\t\tmemset (dp, -1, sizeof (dp ) );\n\t\ts = i;\n\t\tres = min (res, dfs (0, i ) );\n\t} // end rep\n\tcout << (res == INF ? -1 : res ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int inf = 987654321;\nint n, m;\nvector< vector<int> > G;\nvector< vector<int> > dp;\n\nint rec(int visited, int now) {\n  if (dp[visited][now] != -1) return dp[visited][now];\n  if (visited == (1<<n)-1 && now == 0) return dp[visited][now] = 0;\n  int res = inf;\n  for (int i = 0; i < n; i++) {\n    if (visited >> i & 1) continue; /* ??¢????¨??????? */\n    res = min(res, rec(visited | (1 << i), i) + G[now][i]);\n  }\n  return dp[visited][now] = res;\n}\n\nint main(void) {\n  cin >> n >> m;\n  G.assign(n, vector<int>(m, inf));\n  for (int i = 0; i < m; i++) {\n    int p, q, c;\n    cin >> p >> q >> c;\n    G[p][q] = c;\n  }\n  dp.assign(1<<n, vector<int>(n, -1));\n  int res = rec(0, 0);\n  if(res != inf) cout << res << endl;\n  else cout << inf << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tf(v, v', k):- min f(v, v',k - 1) + e(v, v'), \n\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = (1 << 30) - 1;\nconst int mxv = 16;\nint V, E;\nint adj[mxv][mxv], dp[( 1 << mxv )][mxv], a, b, c;\n\n\nint tsp( int v, int bitmask ){\n\n\tif( bitmask == ( 1 << V ) - 1 )\n\t\treturn adj[v][0];\n\n\tif( dp[bitmask][v] < INF )\n\t\treturn dp[bitmask][v];\t\n\n\tfor( int i = 0; i < V; ++i )\n\t\tif( !(bitmask & ( 1 << i ) ) )\n\t\t\tdp[bitmask][v] = min( dp[bitmask][v], adj[v][i] + tsp( i, bitmask|( 1 << i ) ) );\n\treturn dp[bitmask][v];\n}\n\n\n\n\nint main( void ){\n\t\n\t//freopen(\"input.in\", \"r\", stdin);\n\tscanf(\"%d%d\", &V, &E);\n\n\tfor( int i = 0; i < V; ++i )\n\t\tfor( int j = 0; j < V; ++j )\n\t\t\tadj[i][j] = INF;\n\n\tfor( int i = 0; i < ( 1 << V ); ++i )\n\t\tfor( int j = 0; j < V; ++j )\n\t\t\tdp[i][j] = INF;\n\n\tfor( int i = 0; i < E; ++i )\n\t\tscanf(\"%d%d%d\", &a, &b, &c), adj[a][b] = c;\n\n\tint sol = tsp( 0, 1 );\n\tprintf(\"%d\\n\", ( sol == INF)?-1:sol);\n\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_V 15\n\nint main(void){\n  int v, e, st[MAX_V][MAX_V], i, j, k, l, d[MAX_V][1 << MAX_V]/*スタート地点,今いる地点,通過した編の情報(bit)*/, ans = -1;\n  scanf(\"%d%d\",&v,&e);\n  memset(st,-1,sizeof(st));\n  for(i = 0;i < e;i++){\n    int s, t, dt;\n    scanf(\"%d%d%d\",&s,&t,&dt);\n    st[s][t] = dt;\n  }\n  for(i = 0;i < v;i++){ // スタート地点\n    memset(d,-1,sizeof(d));\n    d[i][1 << i] = 0;\n    for(k = 0;k < 1 << v;k++){ // 通過辺の情報\n      for(j = 0;j < v;j++){ // 今いる地点\n\tfor(l = 0;l < v;l++){ // 行き先\n\t  if(d[j][k] != -1 && st[j][l] != -1 && (d[l][k | (1 << l)] == -1 || d[l][k | (1 << l)] > d[j][k] + st[j][l])){\n\t    d[l][k | (1 << l)] = d[j][k] + st[j][l];\n\t      \n\t  }\n\t}\n      }      \n    \n    }\n    if(d[i][(1 << v) - 1] != -1 && (ans == -1 || d[i][(1 << v) - 1] < ans)){\n      ans = d[i][(1 << v) - 1];\n    }\n\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 99999999\n#define INF_M 2147483647\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint dist[15][15];\nint dp[1 << 15][15];\nint V,E;\nint s,t,d;\n\nint rec(int S, int v) {\n    if(dp[S][v] >= 0) return dp[S][v];\n    if(S == (1 << V) - 1 && v == 0) return dp[S][v] = 0;\n\n    int res = INF;\n    for(int r = 0; r < V; r++) {\n        if(!(S & 1 << r)) {\n            res = min(res, rec(S | 1 << r, r) + dist[v][r]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    cin >> V >> E;\n    rep(i,0,20) rep(j,0,20) dist[i][j] = INF;\n\n    rep(i,0,E) {\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    memset(dp, -1, sizeof(dp));\n\n    int ans = rec(0,0);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 15;\nconst int INF = (int)1e8;\n\nint V;\nint dp[MAX_N][1 << MAX_N];\nvector<pair<int, int>> G[MAX_N];\n\nint start;\n\nint tsp(unsigned S, int v) {\n  if(dp[v][S] != -1) return dp[v][S];\n  if(S == 0 && v == start) return 0;\n  int res = INF;\n  for(int i = 0; i < (int)G[v].size(); i++) {\n    int next = G[v][i].first;\n    int d = G[v][i].second;\n    if(S >> next & 1) {\n      res = min(res, d + tsp(S & ~(1 << next), next));\n    }\n  }\n  return dp[v][S] = res;\n}\n\nint main() {\n  int E; cin >> V >> E;\n  while(E--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    G[s].push_back(make_pair(t, d));\n  }\n  int res = INF;\n  for(int i = 0; i < V; i++) {\n    start = i;\n    memset(dp, -1, sizeof(dp));\n    res = min(res, tsp((1 << V) - 1, i));\n  }\n  if(res == INF) cout << \"-1\" << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 15\n#define INF 1<<28\nint n;\nint d[MAX][MAX];\nint dp[1<<MAX][MAX];\n//s=?¨??????????,v=?????¨??????\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v==0)return dp[s][v]=0;\n  int res=INF;\n  for(int u=0;u<n;u++)\n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nint main(){\n  memset(dp,-1,sizeof(dp));\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  int m;\n  cin>>n>>m;\n  while(m--){\n    int s,t,dd;\n    cin>>s>>t>>dd;\n    d[s][t]=dd;\n  }\n  int p=rec(0,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <ctime>\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXISTch(s,c) ((((s).find_first_of(c)) != std::string::npos)? 1 : 0)//cがあれば1 if(1)\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define loop(n) FOR(i,0,n)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = (int)1000000007;\nconst LL MOD = (LL)1000000007;//10^9+7\nconst LL INF2 = (LL)100000000000000000;//10^18\n\nint main() {\n\tint V, E; cin >> V >> E;\n\n\tvector<vector<int>> adj(V, vector<int>(V,-1));\n\n\tfor (int e = 0; e < E; e++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\n\t\tadj[s][t] = d;\n\t}\n\t\t\t\n\t\n\t//dp[既に訪れた部分集合][最後に訪れた頂点]のときの最短距離\n\t//dp[S][v]\n\tvector<vector<int>> dp(1 << V, vector<int>(V));\n\t\n\t//dp初期化\n\tfor (int i = 0; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\t//頂点0から出発。\n\t//部分集合としては0…0001\n\t//最後に訪れたのは頂点0で頂点0からの距離は0\n\tdp[1][0] = 0;\n\n\tfor (int s = 0; s < (1 << V); s++) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (dp[s][v] == INF)continue;\n\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (s >> k & 1)continue;\n\t\t\t\tif (adj[v][k] == -1)continue;\n\t\t\t\tint nexts = s | (1<<k);\n\n\t\t\t\t\n\t\t\t\tdp[nexts][k] = min(dp[nexts][k], dp[s][v] + adj[v][k]);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tint all = (1 << V) - 1;\n\tint ans = INF;\n\tfor (int v = 0; v < V; v++) {\n\t\tif (dp[all][v] == INF)continue;\n\t\tif (adj[v][0] == -1)continue;\n\n\t\tans = min(ans, dp[all][v] + adj[v][0]);\n\t}\n\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nmain(){\n  int v,e;\n  cin>>v>>e;\n  WG<int> es(v);\n  vector<vector<int>> dp((1<<v),vector<int>(v,INF));\n  vector<int> cost(v,INF);\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s].PB(edge<int>(t,d));\n    if(t==0){\n      cost[s]=min(cost[t],d);\n    }\n  }\n  dp[1][0]=0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==inf) continue;\n      for(auto et:es[j]){\n        if(i&(1<<et.to)) continue;\n        dp[i|(1<<et.to)][et.to]=min(dp[i|(1<<et.to)][et.to],dp[i][j]+et.cost);\n      }\n    }\n  }\n\n  int ans=INF;\n  rep(i,v){\n    if(dp[(1<<v)-1][i]!=INF&&cost[i]!=INF)\n      ans=min(ans,dp[(1<<v)-1][i]+cost[i]);\n    }\n\n  cout<<((ans==INF)?-1:ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define INF 100100100\n \nint main(){\n \n  int v, e; cin >> v >> e;\n  int n = v;\n  vector<vector<int> > dis(v, vector<int> (v, INF));\n  for(int i = 0; i < e; i++){\n    int a, b, c; cin >> a >> b >> c;\n    dis[a][b] = c;\n  }\n \n  vector<vector<int> > dp((1 << n), vector<int> (n, INF));\n  dp[0][0] = 0;\n  for(int i = 0; i < (1 << n); i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < v; k++){\n        if((i & (1 << k)) != 0) continue;\n \n        int cost = dp[i][j] + dis[j][k];\n \n        chmin(dp[i | (1 << k)][k], cost);\n      }\n    }\n  }  \n \n  if(dp[(1 << v) - 1][0] == INF) cout << -1 << endl;\n  else cout << dp[(1 << v) - 1][0] << endl;\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\n\nsigned main(){\n  int V, E; cin >> V >> E;\n  vector<vector<int> > dist(V, vector<int> (V, INF));\n  for(int i = 0; i < E; i++){\n    int s, t, d; cin >> s >> t >> d;\n    dist[s][t] = d;\n }  \n vector<vector<int> > dp(V, vector<int> (1 << V, INF));\n dp[0][0] = 0;\n for(int i = 0; i < (1 << V); i++){\n   for(int j = 0; j < V; j++){\n     if(!(i & (1 << j))){\n       for(int k = 0; k < V; k++){\n         dp[j][i + (1 << j)] = min(dp[j][i + (1 << j)], dp[k][i] + dist[k][j]);\n       }\n     }\n   }\n }\n int ans = dp[0][(1 << V) - 1];\n if(ans == INF) cout << -1 << endl;\n else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n//#define SIZE 200005\n//#define INF 1000000005LL\n#define SIZE 1<<16\n#define INF 1e18\n//#define INF 1e18\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint V,E;\nll d[17][17];\nll dp[SIZE][17];\n\nvoid bitDP_init(){\n  fill(d[0],d[17],INF);\n}\n\nll bitDP(){\n  fill(dp[0],dp[SIZE],INF);\n  dp[0][0] = 0;\n  for(int S=0;S<1<<V;S++){\n    rep(v,0,V) rep(u,0,V){ //Sを通り次にvに進む\n      if(S>>u & 1){\n        dp[S][v] = min(dp[S][v],dp[S-(1<<u)][u]+d[u][v]);\n      }\n    }\n  }\n  return dp[(1<<V)-1][0];\n}\n\nint main(){\n\n  cin >> V >> E;\n  bitDP_init();\n  rep(i,0,E){\n    int s,t;\n    ll D;\n    cin >> s >> t >> D;\n    d[s][t] = D;\n  }\n\n  ll ans = bitDP();\n  if(ans >= INF) ans = -1;\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main(){\n    int v, e, s, t, d;\n    cin >> v >> e;\n\n    int dp[v][1<<v], dist[v][v];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < 1<<v; j++){\n            dp[i][j] = INF;\n            if(j < v)   dist[i][j] = INF;\n        }\n    }\n\n    // 巡回路なので始点を0に固定してしまっても問題ない\n    dp[0][0] = 0;\n\n    for(int i = 0; i < e; i++){\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    for(int s = 0; s < 1<<v; s++){\n        for(int i = 0; i < v; i++){\n            if(dp[i][s] == INF) continue;\n            for(int j = 0; j < v; j++){\n                if(i == j || dist[i][j] == INF || (s&(1<<j)))   continue;\n                dp[j][s|(1<<j)] = min(dp[j][s|(1<<j)], dp[i][s]+dist[i][j]);\n            }\n        }\n    }\n\n    int ans = dp[0][(1<<v)-1];\n    if(ans == INF)  ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int V,E;\n    cin>>V>>E;\n    int G[V][V];\n    fill(G[0],G[V],-1);\n    for(int i=0;i<E;i++){\n        int s,t,d;\n        cin>>s>>t>>d;\n        G[s][t]=d;\n    }\n    int dp[1<<V][V];\n    fill(dp[0],dp[1<<V],1e8);\n    dp[(1<<V)-1][0]=0;\n    for(int S=(1<<V)-2;S>=0;S--){\n        for(int v=0;v<V;v++){\n            for(int u=0;u<V;u++){\n                if(G[v][u]==-1){\n                    continue;\n                }\n                if(!(S&(1<<u))){\n                    dp[S][v]=min(dp[S][v],dp[S|(1<<u)][u]+G[v][u]);\n                }\n            }\n        }\n    }\n    cout<<(dp[0][0]==1e8?-1:dp[0][0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct TSP{\n  int n,d[16][16],dp[(1<<16)][16];\n  TSP(int sz):n(sz){\n    for(int i=0;i<16;i++)\n      for(int j=0;j<16;j++) d[i][j]=1e8;\n  }\n  void add(int a,int b,int c){\n    d[a][b] = c;\n    //d[b][a] = c;\n  }\n  int solve(){\n    for(int i=0;i<(1<<n);i++)\n      for(int j=0;j<n;j++) dp[i][j]=1e8;\n    dp[0][0]=0;\n    for(int i=0;i<(1<<n);i++){\n      for(int j=0;j<n;j++){\n        if(!((1<<j)&i)){\n          for(int k=0;k<n;k++){\n            dp[i|(1<<j)][j]=min(dp[i|(1<<j)][j],dp[i][k]+d[k][j]);\n          }\n        }\n      }\n    }\n    if(dp[(1<<n)-1][0]=1e8)return -1;\n    return dp[(1<<n)-1][0];\n  }\n};\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSP T(n);\n  for(int i=0;i<m;i++){\n    int x,y,z;\n    cin>>x>>y>>z;\n    T.add(x,y,z);\n  }\n  cout<<T.solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    vector<int> temp(V);\n    fill(temp.begin(),temp.end(),-1);\n    fill(v.begin(),v.end(),temp);\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != -1 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    flag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\tif(e.exp[j] == 0) flag = false;\n\t\t    }\n\t\t}\n\t\tif(flag){\n\t\t    res = min(res,e.t);\n\t\t}else{\n\t\t    st.push(e);\n\t\t}\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) res = -1;\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define vi vector<int>\n#define vl vector<long long>\n#define vvi vector< vector<int> >\n#define vvl vector< vector<ll> >\n#define vp vector<P>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define REPD(i, n) for (int i = (int)(n-1); i >= 0; i--)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define FORD(i, a, b) for (int i = (int)(a); i >= (int)(b); i--)\n#define INF 1e18\nconst int INFTY = 10000000;\nconst int mod = 1000000007;\n#define SIZE_OF_ARRAY(array) (sizeof(array)/sizeof(array[0]))\n\ntemplate<class T> bool chmax(T &a, const T & b) {\n    if (a<b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> bool chmin(T &a, const T & b) {\n    if (a>b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint n, m;\nconst int MAX_N = 16;\nint dp[1<<MAX_N][MAX_N];\nint d[MAX_N][MAX_N];\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1<<n)-1 && v == 0) return dp[S][v] = 0;\n\n    int res = INFTY;\n    REP(u, n) {\n        if (d[v][u] == INFTY) continue;\n        if (!(S & (1<<u))) {\n            chmin(res, rec((S | (1<<u)), u)+d[v][u]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    cin >> n >> m;\n    memset(dp, -1, sizeof(dp));\n    REP(i, n) {\n        REP(j, n) {\n            d[i][j] = INFTY;\n        }\n    }\n    REP(i, m) {\n        int s, t, dist;\n        cin >> s >> t >> dist;\n        d[s][t] = dist;\n    }\n    int res = rec(0, 0);\n    if (res == INFTY) cout << -1 << endl;\n    else cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXV = 15;\n\nint d[MAXV][MAXV];\nint dp[1<<MAXV][MAXV];\n \nint main(){\n    \n    int V, E;\n    cin >> V >> E;\n\n    memset(d,-1,sizeof(d));\n    for (int i=0; i<E; i++){\n        int s, t, _d;\n        cin >> s >> t >> _d;\n        d[s][t] = _d;\n    }\n\n    for(int i=0; i<V-1; i++){\n        if (d[V-1][i] >= 0) dp[1<<i][i] = d[V-1][i];\n        else                dp[1<<i][i] = -1;\n    }\n\n    for(int i=0; i<(1<<V-1); i++){\n        if (!(i&(i-1))) continue;\n        \n        for(int j=0; j<V-1; j++){\n            if(!((i>>j)&1)) continue;\n            \n            dp[i][j] = -1;\n            int p = i^(1<<j);\n            for(int k=0; k<V-1; k++){\n                if(!(p>>k&1) || d[k][j] < 0 || dp[p][k] == -1) continue;\n                \n                if (dp[i][j] == -1 || dp[i][j] > dp[p][k] + d[k][j]) dp[i][j] = dp[p][k]+d[k][j];\n            }\n        }\n    }\n\n    int b = -1;\n    for(int i=0; i<V-1; i++){\n        if(d[i][V-1] < 0 || dp[(1<<V-1)-1][i] == -1) continue;\n        \n        if (b == -1 || b > dp[(1<<V-1)-1][i] + d[i][V-1]) b=dp[(1<<V-1)-1][i]+d[i][V-1];\n    }\n\n    cout << b << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ninline int getbit(int mask, int v) {\n    return (mask >> v) & 1;\n}\n\ninline int newmask(int mask, int v) {\n    return mask | (1 << v);\n}\n\nconst int INF = 1e9;\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int cost[n][n];\n    vector <int> g[n];\n    int x, y, c;\n    for (int i = 0; i < m; i++) {\n        cin >> x >> y >> c;\n        g[x].push_back(y);\n       // g[y].push_back(x);\n        cost[x][y] = c;\n       // cost[y][x] = c;\n    }\n    int P = pow(2, n);\n    int d[P + 1][n];\n    for (int i = 1; i < P; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = INF;\n        }\n    }\n    d[1][0] = 0;\n    int ans = INF;\n    for (int mask = 1; mask < P; mask++) {\n        for (int v = 0; v < n; v++) {\n            if (d[mask][v] != INF) {\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    int u = g[v][i];\n                    if (mask < P - 1) {\n                        if (!getbit(mask, u)) {\n                            d[newmask(mask, u)][u] = min(d[newmask(mask, u)][u], d[mask][v] + cost[v][u]);\n                        }\n                    } else {\n                        if (u == 0) {\n                            ans = min(ans, d[mask][v] + cost[v][0]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\nusing namespace std;\nconst int INF=INT_MAX/2;\n\nstruct edge { int to, weight;};\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nint  DP[1 << 15][15];\n\nint rec(int S, int v, int V, Graph &G){\n\tif(DP[S][v]>=0){\n\t\treturn DP[S][v];\n\t}\n\tif (S==(1 << V)-1 && v==0) \n\t{\n\t\treturn DP[S][v]=0;\n\t}\n\n\tint r = INF;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge f = G[v][i];\n\t\tif((S >> f.to)%2==0){\n\t\t\tr=min(r,rec((S | (1 << f.to)) ,f.to,V,G)+f.weight);\n\t\t}\n\t}\n\treturn DP[S][v]=r;\n}\n\nint main(){\n\tint V,E,d,s;\n\tedge e;\n\tcin >> V >> E ;\n\n\tGraph G(V);\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> e.to >> e.weight;\n\t\tG[s].push_back(e);\n\t}\n\n\tmemset(DP,-1,sizeof(DP));\n\tint result =rec(0,0,V,G) ;\n\tif(result>=INF){\n\t\tcout << -1<< endl;\n\t}else{\n\t\tcout << result <<endl;\n\t}\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint const inf = 1<<29;\n\nWeight visit(Graph const & g, int S, int v, Weight dp[1<<16][16]){\n    Weight & res = dp[S][v];\n    if(res != -1) return res;\n    if (S == (1 << g.size()) - 1 && v == 0) {\n        res = 0;\n    } else {\n        res = inf;\n        for(Edge const & e : g[v]){\n            int dst = e.dst;\n            if(S >> e.dst & 1) continue;\n            res = min(res, visit(g,S|1<<dst,dst,dp)+e.weight);\n        }\n    }\n    return res;\n}\nWeight TravelingSalesmanProblem(Graph const & g){\n    static Weight dp[1<<16][16];\n    memset(dp,-1,sizeof(dp));\n    return visit(g,0,0,dp);\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    rep(i,m){\n        int s,t,d; cin >> s >> t >> d;\n        g[s].eb(s,t,d);\n    }\n    Weight res = TravelingSalesmanProblem(g);\n    if(res >= inf) res = -1;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconstexpr int INF = 1000000000;\nconstexpr int MAX_V = 15;\n\nint V, E;\nint memo[1 << MAX_V][MAX_V] = {-1}, dis[MAX_V][MAX_V] = {-1};\n\nint tsp(int s = 1, int v = 0);\n\nint main(){\n    scanf(\"%d%d\", &V, &E);\n    for(int i = 0; i < 1 << V; ++i){\n        for(int j = 0; j < V; ++j){\n            memo[i][j] = -1;\n        }\n    }\n    for(int i = 0; i < V; ++i){\n        for(int j = 0; j < V; ++j){\n            dis[i][j] = INF;\n        }\n    }\n    for(int i = 0; i < E; ++i){\n        int s, t, d;\n        scanf(\"%d%d%d\", &s, &t, &d);\n        dis[s][t] = d;\n    }\n    int tmp = tsp();\n    if(tmp >= INF){\n        puts(\"-1\");\n    }\n    else{\n        printf(\"%d\\n\", tmp);\n    }\n    return 0;\n}\n\nint tsp(int s, int v){\n    if(memo[s][v] != -1){\n        return memo[s][v];\n    }\n    if(s == ((1 << V) - 1)){\n        return dis[v][0];\n    }\n    \n    int res = INF;\n    for(int i = 0; i < V; ++i){\n        if(s & 1 << i){\n            continue;\n        }\n        res = std::min(res, tsp(s | (1 << i), i) + dis[v][i]);\n    }\n\n    return memo[s][v] = res;\n}\n#include <cstdio>\n#include <algorithm>\n\nconstexpr int INF = 1000000000;\nconstexpr int MAX_V = 15;\n\nint V, E;\nint memo[1 << MAX_V][MAX_V] = {-1}, dis[MAX_V][MAX_V] = {-1};\n\nint tsp(int s = 1, int v = 0);\n\nint main(){\n    scanf(\"%d%d\", &V, &E);\n    for(int i = 0; i < 1 << V; ++i){\n        for(int j = 0; j < V; ++j){\n            memo[i][j] = -1;\n        }\n    }\n    for(int i = 0; i < V; ++i){\n        for(int j = 0; j < V; ++j){\n            dis[i][j] = INF;\n        }\n    }\n    for(int i = 0; i < E; ++i){\n        int s, t, d;\n        scanf(\"%d%d%d\", &s, &t, &d);\n        dis[s][t] = d;\n    }\n    int tmp = tsp();\n    if(tmp >= INF){\n        puts(\"-1\");\n    }\n    else{\n        printf(\"%d\\n\", tmp);\n    }\n    return 0;\n}\n\nint tsp(int s, int v){\n    if(memo[s][v] != -1){\n        return memo[s][v];\n    }\n    if(s == ((1 << V) - 1)){\n        return dis[v][0];\n    }\n    \n    int res = INF;\n    for(int i = 0; i < V; ++i){\n        if(s & 1 << i){\n            continue;\n        }\n        res = std::min(res, tsp(s | (1 << i), i) + dis[v][i]);\n    }\n\n    return memo[s][v] = res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX_N = 16;\nstatic const int INFTY = (1 << 29);\nint V;\nint G[MAX_N][MAX_N];\nint dp[1 << MAX_N][MAX_N];\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << V) -1 && v == 0) return dp[S][v] = 0;\n    int res = INFTY;\n    for (int u = 0;  u < V; u++) {\n        if (! (S >> u & 1)) {\n            res = min(res, rec(S | 1 << u, u) + G[v][u]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\n\nint main()\n{\n    int E, source, target, cost;\n    scanf(\"%d %d\", &V, &E);\n    for (int i = 0; i < V; i++) fill(G[i], G[i]+V, INFTY);\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &source, &target, &cost);\n        G[source][target] = cost;\n    }\n\n    memset(dp, -1, sizeof (dp));\n    int res = rec(0, 0);\n    (res == INFTY) ? printf(\"%d\\n\", -1) : printf(\"%d\\n\", res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp(shinobu_menkoi) {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\n// clang-format off\n#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rep1(n) rep2(_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, n) rep4(i, a, n, 1)\n#define rep4(i, a, n, s) for (lint i = (a); i < (lint)(n); i += (s))\n#define rrep(...) GET_MACRO(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rrep1(a) rrep2(_, a)\n#define rrep2(i, a) rrep3(i, a, 0)\n#define rrep3(i, a, n) rrep4(i, a, n, 1)\n#define rrep4(i, a, n, s) for (lint i = (a); i >= (lint)(n); i -= (s))\n#define each(i, ctn) for (auto &&i : (ctn))\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr << (x) << \" (L:\" << __LINE__ << \")\" << '\\n'\n#define TEMP_T template <class T>\n#define TEMP_TU template <class T, class U>\n\nTEMP_T using vec = vector<T>;\nTEMP_T using heap = priority_queue<T>;\nTEMP_T using minheap = priority_queue<T, vec<T>, greater<T>>;\nusing lint = long long;\nusing ulint = unsigned long long;\nusing ld = long double;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing vvvi = vec<vvi>;\nusing pii = pair<int, int>;\nusing vs = vec<string>;\n\nTEMP_TU ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.fi << \" \" << p.se; }\nTEMP_TU istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.fi >> p.se; }\n\nconst int INF{1001001001};\nconst lint LINF{1001001001001001001ll};\nconst int MOD{(int)1e9 + 7};\nconst double EPS{1e-9};\nconst double PI{acos(-1)};\nconst int dx[]{0, 1, 0, -1, 1, -1, 1, -1}, dy[]{1, 0, -1, 0, 1, -1, -1, 1};\n\ninline bool inside(int y, int x, int h, int w) { return y >= 0 && x >= 0 && y < h && x < w; }\nTEMP_T inline bool chmin(T &a, const T &b) { if (a > b) a = b; return a > b; }\nTEMP_T inline bool chmax(T &a, const T &b) { if (a < b) a = b; return a < b; }\nTEMP_T inline void print(const T &x) { cout << x << '\\n'; }\nTEMP_T inline void print(const vec<T> &v, string d = \"\\n\") { rep(i, v.size()) cout << v[i] << (i == v.size() - 1 ? \"\\n\" : d); }\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = string> vec<T> split(const string &s, char d = ',') {\n  vec<T> v; stringstream ss(s); for (string b; getline(ss, b, d); ) {\n    stringstream conv(b); T t; conv >> t; v.eb(t); } return v;\n}\nstruct pre_ { pre_() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } pre__;\n// clang-format on\n/* }}} */\n\nint V, E;\nint G[16][16];\nint memo[16][1 << 16];\n\nint dfs(int idx, int S) {\n  if (S == (1 << V) - 1) return G[idx][0];\n  if (memo[idx][S] != -1) return memo[idx][S];\n\n  int res = INF;\n  rep(i, V) {\n    if (S & (1 << i)) continue;\n    if (G[idx][i] == INF) continue;\n    chmin(res, G[idx][i] + dfs(i, S | (1 << i)));\n  }\n\n  return memo[idx][S] = res;\n}\n\nsigned main() {\n  rep(i, 16) rep(j, 16) G[i][j] = INF;\n  cin >> V >> E;\n  rep(i, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    G[s][t] = d;\n  }\n  memset(memo, -1, sizeof(memo));\n  int res = dfs(0, 1);\n\n  print(res >= INF ? -1 : res);\n\n}"
  },
  {
    "language": "C++",
    "code": "/* C++ */\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = ll(0); i < ll(n); i++)\n#define Rep(i, n) for(ll i = ll(1); i < ll(n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,(ll)s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll ans=0;\n  while(n!=0) ans+=n%10,n/=10;\n  return ans;\n}\n\nll Svec(vector<ll> v){\n  ll n=0;\n  rep(i,(ll)v.size()) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  rep(i,(ll)s.size()-1){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\nvoid dis(vector<ll> v){ rep(i,v.size()) cout<<v[i]<<endl; }\n\nvoid dis2(vector<vector<ll>> v){\n  rep(i,v.size()){\n    rep(j,v[0].size()) cout<<v[i][j]<<' ';\n    cout<<endl;\n  }\n}\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  ll v,e;cin>>v>>e;\n  vector<vector<ll>> g(v,vector<ll>(v,1e16)),dp((1<<v),vector<ll>(v,1e16));\n  rep(i,v) rep(j,v) if(i==j) g[i][j]=0;\n  rep(i,e){\n    ll s,t,d;cin>>s>>t>>d;\n    g[s][t]=d;\n  }\n  dp[0][0]=0;\n  Rep(bit,(1<<v)) rep(i,v) if(bit&(1<<i)) rep(j,v) chmin(dp[bit][i],dp[bit-(1<<i)][j]+g[j][i]);\n  if(dp[(1<<v)-1][0]==1e16) cout<<-1<<endl;\n  else cout<<dp[(1<<v)-1][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n\nint V, E;\nint dist[20][20];\n\nint dp[20][(1<<20)+1];\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            dist[i][j] = INF;\n        }\n    }\n    for (int i = 0; i < E; i++)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    for(int i = 0; i < V; i++) for(int j = 0; j < (1<<V); j++) dp[i][j] = INF;\n    dp[0][0] = 0;\n\n    for (int i = 0; i < (1<<V); i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if((i >> j) & 1) continue;\n            for (int k = 0; k < V; k++)\n            {\n                dp[j][i | (1<<j)] = min(dp[j][i | (1<<j)], dp[k][i] + dist[k][j]);\n            }\n        }\n    }\n\n    if(dp[0][(1<<V) - 1] == INF) cout << \"-1\" << endl;\n    else cout << dp[0][(1<<V) - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\n\nconst int inf = INT_MAX / 3;\nconst int max_v = 15;\n\nint d[max_v][max_v];\nint dp[(1 << max_v) - 1][max_v];  // S?????¢????????£????????????????????????v??????????????´???\n\n\nusing namespace std;\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\td[i][j] = (i == j) ? 0 : inf;\n\n\t\t}\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint ts,tt , td;\n\t\tcin >> ts >> tt >> td;\n\t\td[ts][tt] = td;\n\t}\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tdp[s][v] = inf;\n\t\t}\n\t}\n\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tfor (int u = 0; u < V;u++) {\n\t\t\t\tcout << \"s:\" << s << \" v:\" << v << \" u:\" << u << endl;\n\t\t\t\tif (!((s >> u) & 1)) {\n\t\t\t\t\tdp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[u][v]);\n\t\t\t\t\tcout << \" dp:\" << dp[s][v] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[0][0] >= inf) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << dp[0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i=0; i < (int)(n); i++)\nusing ull = unsigned long long;\nusing ll = long long;\n\nconst int INF = 1E+9;\n\nint V, E;\nstruct city{\n    int t;\n    int d;\n};\nvector<vector<city>> G(16);\n\nint dp[1<<16][16];\n\nint main() {\n    cin >> V >> E;\n\n    int si, ti, di;\n    rep(i, E) {\n        cin >> si >> ti >> di;\n        G[si].push_back({ti, di});\n    }\n\n    rep(i, 1<<16) rep(j, 16) dp[i][j] = INF;\n    dp[0][0] = 0;\n\n    for (int bit=0; bit < (1<<V); bit++) {\n        for (int now=0; now<V; now++) {\n            for (auto c: G[now]) {\n                if (!(bit & (1<<c.t))) {\n                    dp[bit | (1<<c.t)][c.t] = min(dp[bit | (1<<c.t)][c.t], dp[bit][now] + c.d);\n                }\n            }\n        }\n    }\n\n    int ans = dp[(1<<V)-1][0];\n    if (ans == INF) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//using Graph = vector<vector<edge>>;\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n#define rep(i, n)         for(int i = 0; i < (int)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define erep(i,container) for (auto i : container)\n#define irep(i, n)        for(int i = n-1; i >= (int)0; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\": \"\n#define res resize\n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define ssum(a) accumulate(a,0ll) \n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n//typedef long long T;\nconst int INF = 1000000000;\nconst ll INF64 = 922337203685477580ll;\nconst ll MOD = 1000000007ll;\nconst dou pi=3.141592653589793;\n\n\nint main(){\n    int v,e;\n    std::cin >> v>>e;\n    vvector(g,int,v,v,INF);\n    vvector(dp,int,(1<<v),v,INF);\n    \n    dp[0][0]=0;\n    rep(i,e){\n        int a,b,c;\n        std::cin >> a>>b>>c;\n        g[a][b]=c;\n\n    }\n    rep(bit,(1<<v)){\n        rep(i,v){\n            if(bit&(1<<i)){\n                rep(j,v){\n                    chmin(dp[bit][i],dp[bit-(1<<i)][j]+g[i][j]);\n                }\n            }\n        }\n    }\n    if(INF!=dp[(1<<v)-1][0])std::cout << dp[(1<<v)-1][0] << std::endl;\n    else std::cout << -1 << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(((1 << k) & tmp) == 0) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    for(int i = 0; i < v; i++){\n        if(result[(1 << v) - 1][i].first == mod) continue;\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int v, int used) {\n    if (used == (1 << V) - 1) return G[v][0];\n    if (memo[v][used] >= 0) return memo[v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || (used & (1 << u))) continue;\n        ret = min(ret, dfs(u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[v][used] = ret;\n}\nint TSP() {\n    int ret = INF;\n    init();\n    for (int i = 0; i < V; i++) {\n        ret = min(ret, dfs(i, (1 << i)) + G[0][i]);\n    }\n    return ret;\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans == INF ? -1 : Ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst ll mod =  1000000007;  //出力は (ans % mod + mod) % mod  (負の剰余を正にする)\nconst int inf = 1e9;\nconst long long INF = 1LL << 60;   // INF = 1152921504606846976\n\nint main()\n{\n    int V,e; cin >> V >> e;\n    ll dp[(1<<V)][V];\n    rep(i,(1<<V)) rep(j,V) dp[i][j] = INF;\n    dp[0][0] = 0;\n    ll g[V][V];\n    rep(i,V) rep(j,V) g[i][j] = INF;\n    rep(i,e){\n        int s,t,d; cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n    for(int S = 0; S < (1 << V); S++){\n        for(int v = 0; v < V; v++){\n            for(int u = 0; u < V; u++){\n                if(S & (1<<v)){\n                    //もらうDP\n                    //S-{v}からSになるときの最小値を更新していく\n                    dp[S][v] = min(dp[S][v],dp[S - (1<<v)][u] + g[u][v]);\n                }\n            }\n        }\n    }\n    if(dp[(1<<V)-1][0] != INF){\n        cout << dp[(1<<V)-1][0] << endl;\n    }else{\n        cout << -1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nint main(){\n  int v,e;\n  cin>>v>>e;\n  WG<int> es(v);\n  vector<vector<int>> dp((1<<v),vector<int>(v,inf));\n  vector<int> cost(v,inf);\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s].PB(edge<int>(t,d));\n    es[t].PB(edge<int>(s,d));\n    if(t==0){\n      cost[s]=min(cost[t],d);\n    }\n  }\n  dp[1][0]=0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==inf) continue;\n      for(auto et:es[j]){\n        if(i&(1<<et.to)) continue;\n        dp[i|(1<<et.to)][et.to]=min(dp[i|(1<<et.to)][et.to],dp[i][j]+et.cost);\n      }\n    }\n  }\n\n  int ans=inf;\n  rep(i,v){\n    ans=min(ans,dp[(1<<v)-1][i]+cost[i]);\n  }\n\n  cout<<((ans==inf)?-1:ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint glaf[15][15];\nint V,E;\n\nint salesman(int count,int cost, int s,bool check[]){\n  int ans = -1;\n  if(count != 0) check[s] = true;\n  for(int i=0;i<V;i++){\n    if(!check[i]) break;\n    else if(i==V-1) return cost;\n  }\n  for(int i=0;i<V;i++){\n    if(glaf[s][i]!=-1&&!check[i]){\n      int goal_cost = salesman(count+1,cost+glaf[s][i],i,check);\n      if(ans==-1 || ( goal_cost!=-1 && goal_cost < ans )) ans = goal_cost;\n    }\n  }\n  check[s] = false;\n  return ans;\n}\n\nint main(){\n  cin >> V >> E;\n  for(int i=0;i<15;i++)\n    for(int j=0;j<15;j++)\n      glaf[i][j] = -1;\n\n  bool check[V];\n  for(int i=1;i<V;i++)\n    check[i] = false;\n\n  int s,t,d;\n  for(int i=0;i<E;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  int ans = salesman(0,0,0,check);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\nint main(){\n    int V,E;\n    cin >> V >> E;\n    int dist[V][V];\n    int dp[1<<V][V];\n    for(int i=0;i<(1<<V);i++){\n        for(int j=0;j<V;j++){\n            dp[i][j]=INF;\n        }\n    }\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            dist[i][j]=INF;\n        }\n    }\n    for(int i=0;i<E;i++){\n        int s,t,d;\n        cin >> s >> t >> d;\n        dist[s][t]=d;\n    }\n    dp[0][0]=0;\n    for(int S=0;S<(1<<V);S++){\n        for(int j=0;j<V;j++){\n            if(dp[S][j]==INF) continue;\n            for(int k=0;k<V;k++){\n                if((S>>k)&1) continue;\n                dp[S|(1<<k)][k]=min(dp[S|(1<<k)][k],dp[S][j]+dist[j][k]);\n            }\n        }\n    }\n    int ans=INF;\n    ans=dp[(1<<V)-1][0];\n    if(ans==INF) puts(\"-1\");\n    else cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n#include <string.h>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define max3(A,B,C) max((A),max((B),(C)))\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n\nconst int N = 16;\nconst int INF = 0x3f3f3f3f;\n\nint pd[1 << N][N][N];\n\nint main(void) {\n   int n, m;\n   int adj[N][N];\n\n   for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n         adj[i][j] = (i == j ? 0 : INF);\n      }\n   }\n   for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) pd[0][i][j] = 0;\n   for(int i = 1; i < 1 << N; i++) {\n      for(int j = 0; j < N; j++) {\n         for(int k = 0; k < N; k++) {\n            pd[i][j][k] = INF;\n         }\n      }\n   }\n\n   scanf(\"%d %d\", &n, &m);\n   for(int i = 0; i < m; i++) {\n      int a, b, c;\n      scanf(\"%d %d %d\", &a, &b, &c);\n      adj[a][b] = c;\n   }\n\n   for(int i = 1; i < 1 << n; i++) {\n      for(int j = 0; j < n; j++) {\n         if( (i & (1 << j)) == 0) continue;\n         for(int w = 0; w < n; w++) {\n            if( (i & (1 << w)) == 0) continue;\n            for(int k = 0; k < n; k++) {\n               if(i & (1 << k)) {\n                  if(i - k != 0 || k == w) {\n                     pd[i][j][w] = min(pd[i][j][w], pd[i^(1<<j)][k][w] + adj[k][j]);\n                  }\n               }\n            }\n         }\n      }\n   }\n\n   int minn = INF;\n   int idx = (1 << n) - 1;\n   for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n         minn = min(minn, pd[idx][i][j] + adj[i][j]);\n      }\n   }\n\n   if(minn == INF) puts(\"-1\");\n   else printf(\"%d\\n\", minn);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i < (n);i++)\n#define ALL(obj) (obj).begin(),(obj).end()\nusing namespace std;\n\nconst long long INF = 1LL << 60;\nconst int IINF = 100000000;\nconst int MOD = (int)1e9 + 7;\ntypedef long long ll;\n//約数列挙\nvector<long long> divisor(long long n) {\n    vector<long long> ret;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            if (i * i != n) ret.push_back(n / i);\n        }\n    }\n    //sort(ret.begin(), ret.end()); // 昇順に並べる\n    return ret;\n}\nvector<int> dx={1,0,-1,0};vector<int> dy={0,-1,0,1};\n\nint n,m;\nint dp[1<<15][15];\nvector<vector<int>> cost;\n\nint rec(int s, int v){\n    if(dp[s][v]!=-1)return dp[s][v];\n    if(s == (1<<n)-1 && v == 0){\n        return dp[s][v] = 0;\n    } \n    int res = IINF;\n    REP(u,n){\n        if(!(s>>u & 1) && cost[v][u] !=-1){\n            res = min(res, rec(s | 1 << u, u) + cost[v][u]);\n        }\n    }\n    return dp[s][v]= res;\n}\nsigned main () {\n    scanf(\"%d %d\",&n,&m);\n    REP(i,(1<<n))REP(j,n)dp[i][j] = -1;\n    cost.assign(n,vector<int>(n,-1));\n    REP(i,m){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        cost[a][b] = c;\n    }\n    int ans = rec(0,0);\n    if(ans==IINF)ans = -1;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 18\n#define INF 1000000000\nint N, M, a, b, c, x[MAX_N][MAX_N];\nint dp[MAX_N][1 << MAX_N];\n\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) { x[i][j] = INF; }\n\t\tfor (int j = 0; j < (1 << MAX_N); j++) { dp[i][j] = INF; }\n\t\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b >> c;\n\t\tx[a][b] = c;\n\t}\n\tdp[0][1] = 0;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (dp[j][i] < INF) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint dist1 = dp[j][i] + x[j][k];\n\t\t\t\t\t\tint pos = i + (1 << k);\n\t\t\t\t\t\tif (dp[k][pos] > dist1) {\n\t\t\t\t\t\t\tdp[k][pos] = dist1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tmaxn = min(dp[i][(1 << N) - 1] + x[i][0], maxn);\n\t}\n\tif (maxn == INF) { maxn = -1; }\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"math.h\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vin;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define drep(i,a,b) for(ll i=(a);i>=(b);--i)\n#define SIZE(a) int((a).size())\n#define out(a) cout<<(a)<<endl;\nconst int INF=INT_MAX;\nconst int MAX = 510000;\nconst ll MOD = 10000;\nll fac[MAX], finv[MAX], inv[MAX];\n\nint main(){\n  ll v,e;cin>>v>>e;\n  vvll g(v,vll(v,INF)),dp(1<<v,vll(v,INF));\n  rep(i,0,e){\n    ll s,t,d;cin>>s>>t>>d;\n    g[s][t]=d;\n  }\n  dp[(1<<v)-1][0]=0;\n  drep(s,(1<<v)-2,0){\n    rep(i,0,v){\n      rep(j,0,v){\n        if(!(s>>j&1)){\n          dp[s][i]=min(dp[s][i],dp[s|1<<j][j]+g[i][j]);\n        }\n      }\n    }\n  }\n  cout<<(dp[0][0]==INF?-1:dp[0][0])<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int value;\n};\n\nstruct Node {\n    int value;\n    vector<Edge> edge;\n};\n\nint v, e;\nint s, t, d;\nNode node[15];\n\nint dp[15][1 << 16];\n\nint solve(int pos, int stat){\n\n    if(dp[pos][stat] != -1) return dp[pos][stat];\n\n    int cost = 1 << 24;\n\n    if(stat == (1 << v) - 1) return 0;\n    else if(stat & 1) return cost;\n\n    for(int i = 0; i < node[pos].edge.size(); ++i) {\n        if(!(stat & 1 << node[pos].edge[i].to)) {\n            cost = min(cost, solve(node[pos].edge[i].to, stat | 1 << node[pos].edge[i].to) + node[pos].edge[i].value);\n        }\n    }\n\n    return dp[pos][stat] = cost;\n\n}\n\nint main() {\n\n    cin >> v >> e;\n\n    for(int i = 0; i < e; ++i) {\n        cin >> s >> t >> d;\n        node[s].edge.push_back((Edge){t, d});\n    }\n\n    memset(dp, -1, sizeof(dp));\n\n    int dst = solve(0, 0);\n\n    if(dst == 1 << 24) {\n        cout << -1 << endl;\n    } else {\n        cout << dst << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint n, m;\nint start;\nstruct edge\n{\n    int to, cost;\n    edge(int to, int cost) : to(to), cost(cost) {}\n};\nvector<edge> G[18];\nvector<vector<int>> dp(1<<18, vector<int>(18, INF));\nint dfs(int now, int bit)\n{\n    if(__builtin_popcount(bit) == n)\n    {\n        for(int u = 0; u < G[now].size(); u++) if(G[now][u].to == start) return G[now][u].cost;\n        return INF;\n    }\n    if(dp[bit][now] != INF) return dp[bit][now];\n    int res = INF;\n    for(int u = 0; u < G[now].size(); u++)\n    {\n        edge e = G[now][u];\n        if(bit & (1<<e.to)) continue;\n        res = min(res, dfs(e.to, bit | (1<<e.to)) + e.cost);\n    }\n    return dp[bit][now] = res;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].push_back(edge(t, d));\n    }\n    int ans = INF;\n    for(int i = 0; i < n; i++)\n    {\n        start = i;\n        ans = min(ans, dfs(i, 0 | (1<<i)));\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int INF=1<<29; \nint n;\nint d[16][16];\nint dp[1<<16][16];\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      d[i][j]=INF;\n    }\n  }\n  int v1,v2,cost;\n  for(int i=0;i<m;i++){\n    cin>>v1>>v2>>cost;\n    d[v1][v2]=cost; \n  }\n  \n  for(int S=0;S<1<<n;S++){\n    fill(dp[S],dp[S]+n,INF);\n  }\n  dp[(1 << n)-1][0]=0;\n  \n  for(int S=(1<<n)-2;S>=0;S--){\n    for(int v=0;v<n;v++){\n      for(int u=0;u<n;u++){\n\tif(!(S>>u&1)){ \n\t  dp[S][v]=min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t}\n      }\n    }\n  }\n  if(dp[0][0]==INF){\n    cout<<-1<<\"\\n\";\n  }else{\n    cout<<dp[0][0]<<\"\\n\";\n  }\n  return 0;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\tmemset(dis, -1, sizeof(dis));\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (dis[s][t] == -1)\n\t\t\t{\n\t\t\t\tdis[s][t] = 1000000;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tmemset(dp, -1, sizeof(dp));\n\tans = min(ans, solve(0, 1));\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, m, adjMat[105][105], dp[100005][105];\n\nint main() {\n\n    memset(dp, -1, sizeof(dp));\n\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j)\n                adjMat[i][j] = 0;\n            else\n                adjMat[i][j] = INF;\n        }\n    }\n\n    for (int i = 0, u, v, w; i < m; i++) {\n        cin >> u >> v >> w;\n\n        adjMat[u][v] = w;\n    }\n\n    // start tour at vertex (n - 1)\n    int nn = n - 1;\n    \n    // base case\n    for (int i = 0; i < nn; i++) {\n        dp[1 << i][i] = adjMat[n - 1][i];\n    }\n\n    int num_states = 1 << nn;\n    for (int i = 0; i < num_states; i++) {\n        if (!(i & (i-1)))\n            continue;\n        for (int j = 0; j < nn; j++) {\n            if (!((i >> j) & 1))\n                continue;\n            dp[i][j] = INF;\n            for (int k = 0; k < nn; k++) {\n                if (k == j || !((i >> k) & 1) || adjMat[k][j] == INF)\n                    continue;\n                dp[i][j] = min(dp[i][j], dp[i ^ (1 << j)][k] + adjMat[k][j]);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < nn; i++) {\n        ans = min(ans, dp[num_states - 1][i] + adjMat[i][n - 1]);\n    }\n\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nstruct edge {\n    int to;\n    int cost;\n    edge(int x=0, int y=0):to(x), cost(y) {}\n};\n\nvector<vector<edge> > G; // resizeの必要あり\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int v, e;\n    cin >> v >> e;\n    G.resize(v);\n    rep(i, e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s].emplace_back(t, d);\n    }\n\n    vector<vvi> dp(v, vvi(1<<v, vi(v, INF)));\n    rep(i, v) {\n        dp[i][1<<i][i] = 0;\n    }\n    rep(i, 1<<v) {\n        rep(j, v) if((i>>j)&1) {\n            int now = i^(1<<j);\n            for(edge ne:G[j]) if((now>>ne.to)&1) rep(hhh, v) {\n                dp[hhh][i][j] = min(dp[hhh][i][j], dp[hhh][now][ne.to] + ne.cost);\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, v) {\n        for(edge ne:G[i]) {\n            ans = min(ans, dp[i][(1<<v)-1][ne.to] + ne.cost);\n        }\n    }\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 15;\nconst int MAX_M = 225;\n\nint n,m;\nll dp[1 << MAX_N][MAX_N];\nll d[MAX_N][MAX_N];\nint s[MAX_M];\nint t[MAX_M];\nint D[MAX_M];\n\nll solve()\n{\n\trep(S,1<<n){\n\t\tfill(dp[S],dp[S]+n,INF);\n\t}\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\trep(v,n){\n\t\t\trep(u,n){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tll ans=INF-1;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tcin >> s[i] >> t[i] >> D[i];\n\t}\n\trep(i,n){\n\t\tfill(d[0],d[n],INF);\n\t\trep(j,m){\n\t\t\td[(s[j]+n-i)%n][(t[j]+n-i)%n] = D[j];\n\t\t} \n\t\tans = min(ans,solve());\n\t}\n\tif(ans > 16000){\n\t\tcout << \"-1\\n\";\n\t}else{\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E, mat[15][15]={0}, m[1<<15][15]={0};\nint INF =1e8 ;\n\nint TSP(int x, int y){\n\tint i;\n\tif(m[x][y]>=0){\n\t\treturn (m[x][y]);\n\t}\n\tif(x==(1<<V) -1 && y==0){\n\t\treturn (m[x][y]= 0);\n\t}\n\tint min_path=INF;\n\n\tfor(i=0; i<V; i++){\n\t\tif(!(x>>i & 1)){\n\t\t\tmin_path=min(min_path, TSP(x | 1<<i, i) + mat[y][i]);\n\t\t}\n\t}\n\n\n\treturn (m[x][y]=min_path);\n}\n\nint main(){\n\tint s, t, d, i, j;\n\tint out;\n\n\tcin>>V>>E; //getchar();\n\tfor(i=0; i<V;i++){\n\t\tfor(j=0; j<V; j++){\n\t\t\tmat[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0; i<E; i++){\n\t\tcin>>s>>t>>d; //getchar();\n\t\tmat[s][t]=d;\n\t}\n\n\tmemset(m, -1, sizeof(m));\n\n\tout=TSP(0,0);\n\tif(out == INF){\n\t\tcout<< -1 ;\n\t}else{\n\t\tcout<< out;\n\t}\n    cout<<endl;\n    //getchar();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconstexpr int INF = 1e9;\nint V, E;\nvector<vector<int>> dp, dist;\n\nint dfs(int vis, int v) {\n    if (vis == ((1<<V)-1)) return v ? INF : 0;\n    int& res = dp[vis][v];\n    if (res < INF) return res;\n    for (int i = 0; i < V; i++) {\n        if ((vis>>i)&1) continue;\n        res = min(res, dist[v][i]+dfs(vis|(1<<i), i));\n    }\n    return res;\n}\n\nint main() {\n   cin >> V >> E;\n   dist = vector<vector<int>>(V, vector<int>(V, INF));\n   for (int i = 0; i < E; i++) {\n       int s, t, d;\n       cin >> s >> t >> d;\n       dist[s][t] = d;\n   }\n   dp = vector<vector<int>>(1<<V, vector<int>(V, INF));\n   int res = dfs(0, 0);\n   cout << (res < INF ? res : -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class Type>struct is_vector : std::false_type {};\n\ttemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\n\ttemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n\t\tif (v.empty())return out;\n\t\tconstexpr bool is_vector_v = is_vector<T>::value;\n\t\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\t\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\t\treturn out;\n\t}\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\tinline void putn() {}\n\ttemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\n\tint rec(int S, int v, vector<vector<int>>& dp, vector<vector<int>>& path) {\n\t\tif (dp[S][v] >= 0) {\n\t\t\treturn dp[S][v];\n\t\t}\n\t\tif (S == (1 << v) && path[v][0] >= 0) {\n\t\t\treturn dp[S][v] = path[v][0];\n\t\t}\n\t\t\n\t\tint n = path.size();\n\t\tint res = INT_MAX;\n\t\tint nS = S & ~(1 << v);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (S >> i & 1) {\n\t\t\t\tif (path[v][i] >= 0) {\n\t\t\t\t\tint d = rec(nS, i, dp, path);\n\t\t\t\t\tif (d != INT_MAX) {\n\t\t\t\t\t\tchmin(res, d + path[v][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[S][v] = res;\n\t}\n\n\tvoid solve() {\n\t\tIOS;\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> s(m), t(m), d(m);\n\t\t//using e=edge<int>;\n\t\tvector<vector<int>> path(n, vector<int>(n, -1));\n\t\tREP(i, m) {\n\t\t\tcin >> s[i] >> t[i] >> d[i];\n\t\t\tpath[s[i]][t[i]] = d[i];\n\t\t}\n\t\tint b = 1 << n;\n\t\tvector<vector<int>> dp(b, vector<int>(n, -1));\n\t\tint res = rec(b-1, 0, dp, path);\n\t\tif (res == INT_MAX) {\n\t\t\tput(-1);\n\t\t} else {\n\t\t\tput(res);\n\t\t}\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=20;\nconst int MAXN=1<<16;\nconst int INF=1e9+10;;\nint min(int a,int b){return a>b?b:a;}\nint main(){\n    int n,dis[N][N],m,l,r,w,dp[MAXN][N],ans=INF,all;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dis[i][j]=INF;\n    while(m--){\n        scanf(\"%d%d%d\",&l,&r,&w);\n        dis[l][r]=w;\n    }\n    all=1<<n;\n    dp[0][0]=0;\n    for(int i=1;i<all;i++)for(int j=1;j<n;j++)if(i&(1<<j)){\n        if(i==1<<j)dp[i][j]=dis[0][j];\n        else{\n            dp[i][j]=INF;\n            for(int k=0;k<n;k++)if(k!=j&&i&(1<<k))dp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+dis[k][j]);\n        }\n    }\n    for(int i=1;i<n;i++)ans=min(ans,dp[all-2][i]+dis[i][0]);\n    if(ans==INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit(int mask, int num)\n{\n\treturn (mask >> num) & 1;\n}\ninline int add_bit(int mask, int num)\n{\n\treturn (mask + (1 << num));\n}\n\n\nint main()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back(make_pair(destiny, len));\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow(2, n);\n\tvector < vector < int > > dp(max_mask, vector < int > (n, -1));\n\tdp[1][0] = 0;\n\tfor (int mask = 1; mask < max_mask; mask++)\n\t{\n\t\tfor (int vertex = 0; vertex < n; vertex++)\n\t\t{\n\t\t\tfor (i = 0; i < graph[vertex].size(); i++)\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif (!get_bit(mask, next))\n\t\t\t\t{\n\t\t\t\t\tif ((dp[add_bit(mask, next)][next] < dp[mask][vertex]) || (-1 == dp[add_bit(mask, next)][next]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit(mask, next)][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tfor (j = 0; j < graph[i].size(); j++)\n\t\t{\n\t\t\tif (0 == graph[i][j].first)\n\t\t\t{\n\t\t\t\tif ((result > dp[max_mask - 1][i] + graph[i][j].second) || (result = -1))\n\t\t\t\t{\n\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<16][16][16];\n\nint to[16][16];\n\nconst int inf = 1e9;\n\nvoid chmin(int &a, int b){\n  if( a > b ){ swap(a,b);} return ;\n}\n\nsigned main(void){\n  \n  int V,E; cin >> V >> E;\n  \n  for(int i = 0; i < (1<<16); i++){\n    for(int j = 0; j < 16; j++){ \n      for(int k = 0; k < 16; k++){\n      dp[i][j][k] = inf;\n      }\n    }\n  }\n  for(int i = 0; i < V; i++){ dp[(1<<i)][i][i] = 0;}\n  \n  for(int i = 0; i < 16; i++){\n    for(int j = 0; j < 16; j++){ \n      to[i][j] = inf;\n    }\n  }\n  \n  for(int i = 0; i < E; i++){\n    int s,t,d; cin >> s >> t >> d;\n    to[s][t] = d; \n  }\n  \n  for(int S = 0; S < (1<<V); S++){ \n    for(int pos = 0; pos < V; pos++){ \n      for(int start = 0; start < V; start++){\n      \n       if( !(S >> pos & 1) || dp[S][pos][start] == inf ){ continue;}\n      \n        for(int i = 0; i < V; i++){\n         int next = i;\n         int dist = to[pos][next];\n        \n         if( S >> next & 1 || to[pos][next] == inf ){ continue;} \n          //一度行ったことのある点/繋がっていない点にはいかない\n        \n         chmin(dp[S|(1<<next)][next][start], dp[S][pos][start]+dist);\n          \n        }\n        \n      }\n    }\n  }\n  \n  int ans = inf; \n  \n  for(int pos = 0; pos < V; pos++){\n    for(int start = 0; start < V; start++){ \n      \n      if( to[pos][start] == inf ){ continue;}\n      \n      chmin(ans,dp[(1<<V)-1][pos][start]+to[pos][start]);\n      //最後にスタートまで戻ってくる必要がある\n      \n    }\n  }\n      \n  if( ans == inf ){ ans = -1;}\n  \n  cout << ans << endl;\n  \n  return 0;\n}\n  \n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream> \n#include <fstream>\nusing namespace std;\ninline bool ChekBit(int mask, int index)\n{\n\treturn (bool)((mask >> index) & 1);\n}\ninline int UpDateMask(int mask, int index)\n{\n\treturn mask | (1 << index);\n}\ninline unsigned int Min(unsigned int a, unsigned int b)\n{\n\tif (a < b&&a != 0)return a;\n\telse\n\t{\n\t\treturn b;\n\t}\n}\nint main()\n{\n\tint n;\n\tint m;\n\tcin >> n;\n\tcin >> m;\n\tvector<vector<pair<int, int> > > map(n);\n\tvector<int> weightToEnd(n, -1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint vertuxStart;\n\t\tint vertuxEnd;\n\t\tint weight;\n\t\tcin >> vertuxStart;\n\t\tcin >> vertuxEnd;\n\t\tcin >> weight;\n\n\t\tmap[vertuxStart].push_back(make_pair(vertuxEnd, weight));\n\t\tif (vertuxEnd == 0)\n\t\t{\n\t\t\tweightToEnd[vertuxStart] = weight;\n\t\t}\n\t}\n\tint exp = (int)pow(2, n);\n\n\tvector<vector<unsigned int> > dState = vector<vector<unsigned int> >(exp, vector<unsigned int>(n, (unsigned int)-1));\n\tdState[1][0] = 0;\n\tfor (int mask = 1; mask < exp; mask++)\n\t{\n\t\tfor (int vertexCurrent = 0; vertexCurrent < n; ++vertexCurrent)\n\t\t{\n\t\t\tif (!ChekBit(mask, vertexCurrent))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dState[mask][vertexCurrent] == (unsigned int)-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < map[vertexCurrent].size(); ++i)\n\t\t\t{\n\t\t\t\tint vertexEnd = map[vertexCurrent][i].first;\n\t\t\t\tint weight = map[vertexCurrent][i].second;\n\t\t\t\tif (!ChekBit(mask, vertexEnd))\n\t\t\t\t{\n\t\t\t\t\tint tmpMask = UpDateMask(mask, vertexEnd);\n\t\t\t\t\tdState[tmpMask][vertexEnd] = Min(dState[tmpMask][vertexEnd], dState[mask][vertexCurrent] + weight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tunsigned int answer = (unsigned int)-1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (weightToEnd[i] == -1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (dState[exp - 1][i] == (unsigned int)-1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tanswer = Min(answer, dState[exp - 1][i] + weightToEnd[i]);\n\n\t}\n\tcout << (int)answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nvector<vector<int>> dp;\nint func(int i, int state, int n, vector<vector<int>> &graph) {\n    if (dp[state][i] >= 0) {\n        return dp[state][i];\n    }\n\n    if (state == (1 << n) - 1 and i == 0) {\n        return dp[state][i] = 0;\n    }\n\n    int res = INF;\n    for (int a = 0; a < n; ++a) {\n        if (graph[i][a] == INF) { continue; }\n        if (!(state >> a & 1)) {\n            res = min(res, func(a, state | 1 << a, n, graph) + graph[i][a]);\n        }\n    }\n\n    return dp[state][i] = res;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> graph(V, vector<int>(V, INF));\n    FOR(i, 0, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n\n    dp.resize(1 << V, vector<int>(V, -1));\n    int ans = func(0, 0, V, graph);\n\n    if (ans == INF) {\n        print(-1);\n    }\n    else {\n        print(ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 987654321\nint V, E, A[15][15], MEMO[15][32768], VISIT[15][32768];\nvoid input(void);\nvoid init_A(void);\nvoid init_MEMO(void);\nint DP(int origin, int dest, int VIA);\nint TSP(void);\nint main(void) {\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    printf(\"%d\\n\", TSP());\n    return 0;\n}\nint TSP(void){\n    int i, VIA_init, min = MAX;\n    for(i = 0; i < V; i++){\n        init_MEMO();\n        VIA_init = (1 << V) - 1 & ~(1 << i);\n        int cnd = DP(i, i, VIA_init);\n        if (cnd < min) min = cnd;\n    }\n    if (min >= MAX)\n        return -1;\n    else\n        return min;\n}\nint DP(int origin, int dest, int VIA){ // single source memoization\n    if(VIA == 0){\n        if (A[origin][dest] != -1) return A[0][dest];\n        else return MAX;\n    }\n    if(VISIT[dest][VIA] == 1) return MEMO[dest][VIA];\n    VISIT[dest][VIA] = 1;\n    int i, min = MAX;\n    for (i = 0; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(origin, i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    MEMO[dest][VIA] = min;\n    return min;\n}\n/*\nint DP(int dest, int VIA){ // single source backward tracking\n    if(VIA == 0) return A[0][dest];\n    int i, min = MAX;\n    for (i = 1; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    return min;\n}*/\nvoid input(void){\n    scanf(\"%d%d\", &V, &E);\n    init_A();\n    int i, s, t, d;\n    for(i = 0; i < E; i++){\n        scanf(\"%d%d%d\", &s, &t, &d);\n        A[s][t] = d;\n    }\n}\nvoid init_A(void){\n    int i, j;\n    for(i = 0; i < V; i++)\n        for(j = 0; j < V; j++) A[i][j] = -1;\n}\nvoid init_MEMO(void){\n    int i, j;\n    for(i = 0; i < V; i++){\n        for(j = 0; j < (1<<V); j++){\n            MEMO[i][j] = 0;\n            VISIT[i][j] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Contents   : DPL 2 A\n * Author     : Kitaura Hiromi\n * LastUpdate : 20180626\n * Since      : 20180626\n */\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 15\n#define INF 1<<20\nint n, E;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\n\nint main(void){\n    cin >> n >> E;\n    fill((int*)dp, (int*)(dp+(1<<MAX_N)), INF);\n    fill((int*)d, (int*)(d+MAX_N), INF);\n    for(int e=0; e<E; e++){\n        int i, j;\n        cin >> i >> j;\n        cin >> d[i][j];\n    }\n    dp[(1<<n) - 1][0] = 0;\n\n    for(int S=(1<<n)-2; S>=0; S--){\n        for(int v=0; v<n; v++){\n            for(int u=0; u<n; u++){\n                if(!(S>>u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n    cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"DataStructure.h\"\n#include <map>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <math.h>\n#include <string.h>\nusing namespace std;\nconst int num = 15, num1 = 10000000;\ntypedef long long int ll;\ntypedef pair<int, int> p;\nconst int INF = 20000000;\nint dp[1 << num][num], m[num][num];\nint n, e;\nbool close = false;\nint solve(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) {\n\t\tclose = true;\n\t\treturn dp[s][v] = 0;\n\t}\n\tif (dp[s][v] != INF)\n\t\treturn dp[s][v];\n\tint res = INF;\n\tfor (int t = 0; t < n; t++)\n\t\tif (!(s >> t & 1))\n\t\t\tres = min(res, m[v][t] + solve(s | 1 << t, t));\n\treturn dp[s][v] = res;\n}\nint main() {\n\tcin >> n >> e;\n\tfill(m[0], m[num], INF);\n\tfill(dp[0], dp[1 << num], INF);\n\tfor (int i = 0; i < e; i++) {\n\t\tint  s, t, u;\n\t\tcin >> s >> t >> u;\n\t\tm[s][t] = u;\n\t}\n\tint minv = solve(0, 0);\n\tif (close)\n\t\tcout << minv << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n\n#define MAX_V 15\n#define MAX_D 1000\n#define SUP (MAX_V * MAX_D + 1)\nint V, E;\nint d[MAX_V][MAX_V];\nint memo[1<<MAX_V][MAX_V]; // nodes already walked * current node\n\nint recur(int s, int v) {\n    if (memo[s][v] != SUP) return memo[s][v];\n    if (s == (1<<V)-1 and v == 0) return memo[s][v] = 0;\n    int result = SUP+1;\n    repeat (i,V) if (not (s&1<<i)) if (d[v][i] < SUP) {\n        result = min(result, d[v][i] + recur(s|1<<i,i));\n    }\n    return memo[s][v] = result;\n}\n\nint main() {\n    cin >> V >> E;\n    repeat (i,V) repeat (j,V) d[i][j] = SUP;\n    repeat (i,E) { int a, b; cin >> a >> b; cin >> d[a][b]; } // there are no multiedge\n    repeat (i,1<<V) repeat (j,V) memo[i][j] = SUP;\n    cout << (recur(0,0) < SUP ? recur(0,0) : -1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX_V = 16;\nconst int MAX_E = (1<<MAX_V); \nconst int INF = INT_MAX / 3; \n\nint V, E;\nint dist[MAX_V][MAX_V];\nint dp[MAX_E][MAX_V]; //?????£?????????????????????is_visit??§????????¨???????????????v?????§???????????????\n\n// v: ?????¨????????????is_visit: ?????£??????????????????\nint dfs(int v, int is_visit) {\n\tif(dp[is_visit][v] != INF) return dp[is_visit][v];\t\n\tif(is_visit == (1<<V)-1) return dist[v][0];\t\n\n\trep(i, V) {\n\t\tif(is_visit & (1<<i)) continue;\n\t\tdp[is_visit][v] = min(dfs(i, (is_visit | (1<<i))) + dist[v][i], dp[is_visit][v]);\n\t}\n\treturn dp[is_visit][v];\n}\n\nint main() {\n\tcin >> V >> E;\t\t\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INF);\n\tfill_n((int *)dp, sizeof(dp) / sizeof(int), INF);\n\tint s, t, d;\n\trep(i, E) {\n\t\tcin >> s >> t >> d;\n\t\tdist[s][t] = d;\n\t}\n\n\tint is_visit = 0;\n\tint ans = dfs(0, (is_visit | 1));\n\n\tcout << ((ans == INF) ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nvector<edge> graph[16];\nint dp[16][1 << 16];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n\n    REP(i, E)\n    {\n        int s, t, d;\n\n        cin >> s >> t >> d;\n\n        graph[s].push_back(edge{t, d});\n    }\n\n    REP(i, V)\n    {\n        REP(j, 1 << V)\n        {\n            dp[i][j] = iINF;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    REP(S, 1 << V)\n    {\n        REP(i, V)\n        {\n            if (dp[i][S] == iINF)\n                continue;\n\n            for (auto e : graph[i])\n            {\n\n                if ((S >> e.to) & 1)\n                    continue;\n\n                dp[e.to][S | 1 << e.to] = min(dp[e.to][S | 1 << e.to], dp[i][S] + e.cost);\n            }\n        }\n    }\n\n    cout << (dp[0][(1 << V) - 1] == iINF ? -1 : dp[0][(1 << V) - 1]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define MAX_N 15\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint V,E;\nll K;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint color[MAX_N];\n\nvoid solve(){\n\tfor(int S=0;S<1<<V;S++){\n\t\tfill(dp[S],dp[S]+V,INF);\n\t}\n\tdp[(1<<V)-1][0] = 0;\n\tfor(int S=(1<<V)-2;S>=0;S--){\n\t\tfor(int v=0;v<V;v++){\n\t\t\tfor(int u=0;u<V;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",dp[0][0]);\n}\n\n//dfsで塗る\nint dfs(int v,int a){\n\tcolor[v] = 1;\n\ta++;\n\tfor(int i=0;i<V;i++){\n\t\tif(d[v][i]!=INF && color[i]==0){\n\t\t\ta = dfs(i,a);\n\t\t}\n\t}\n\treturn a;\n}\n\n\nint main()\n{\n\tint s,t,dd;\n\tscanf(\"%d %d\",&V,&E);\n\tif(E==0){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=V;i++){\n\t\tfill(d[i],d[i]+V+1,INF);\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&dd);\n\t\td[s][t] = dd;\n\t}\n\t//printf(\"%d\\n\",dfs(0,0));\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n#define int long long\nconst int inf = 999999999999999999;\ntypedef long long ll;\ntypedef long double ld;\nint n, m;\nstruct B {\n\tint to, cost;\n};\nvector<B>e[15];\nint b[15], ma=1, dp[15][33000];\nint solve(int i, int s, int st) {\n\tif (s == ma&&i == st)\n\t\treturn dp[i][s] = 0;\n\tif (s != 0 && i == st) return inf;\n\tif (dp[i][s] != inf)\n\t\treturn dp[i][s];\n\tint sum = inf;\n\tfor (int j = 0; j < e[i].size(); j++) {\n\t\tif (!(s&b[e[i][j].to])) {\n\t\t\tsum = min(sum, solve(e[i][j].to, s | b[e[i][j].to], st) + e[i][j].cost);\n\t\t}\n\t}\n\treturn dp[i][s] = sum;\n}\nsigned main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u1, u2, u3;\n\t\tcin >> u1 >> u2 >> u3;\n\t\te[u1].push_back(B{ u2,u3 });\n\t}\n\tb[0] = 1;\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = b[i - 1] * 2, ma += b[i];\n\tint ans = inf;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 15; j++)\n\t\t\tfor (int z = 0; z < 33000; z++)\n\t\t\t\tdp[j][z] = inf;\n\t\tans = min(ans, solve(i, 0, i));\n\t}\n\tcout << (ans != inf ? ans : -1) << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=998244353;\nconst ll mod=1000000007;\nll GCD(ll a,ll b) {return b ? GCD(b,a%b):a;}\nll LCM(ll c,ll d){return c/GCD(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nll dp[(1<<16)][20];\nstruct edge{\n    int s,t;\n    ll d;\n};\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<(1<<16);i++)for(int j=0;j<20;j++)dp[i][j]=inf;\n    dp[0][0]=0;\n    V<edge> v(m);\n    for(int i=0;i<m;i++){\n        cin>>v[i].s>>v[i].t>>v[i].d;\n    }\n    for(int i=0;i<(1<<n);i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<m;k++){\n                if(v[k].s!=j)continue;\n                if(i&(1<<v[k].t))continue;\n                chmin(dp[i|(1<<v[k].t)][v[k].t],dp[i][j]+v[k].d);\n            }\n        }\n    }\n    if(dp[(1<<n)-1][0]>=inf)cout<<-1<<\"\\n\";\n    else cout<<dp[(1<<n)-1][0]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  vector<P> v[n];\n  while(m--) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    v[x].pb(P(y,z));\n  }\n  int ans=MAX;\n  rep(k,n) {\n    int dp[1<<n][n];\n    fill(dp[0],dp[1<<n],MAX);\n    rep(i,v[k].size()) {\n      int y=v[k][i].F;\n      dp[1<<y][y]=v[k][i].S;\n    }\n    rep(t,1<<n) {\n      rep(i,n) {\n        rep(j,v[i].size()) {\n          int y=v[i][j].F;\n          if(t&(1<<y)) continue;\n          dp[t|(1<<y)][y]=min(dp[t|(1<<y)][y],dp[t][i]+v[i][j].S);\n        }\n      }\n    }\n    ans=min(ans,dp[(1<<n)-1][k]);\n  }\n  if(ans==MAX) ans=-1;\n  pr(ans);\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\nint main(){\n  int INF=(1<<29);\n  int v,e,s,t,d,g[20][20],i,j,k,dp[(1<<16)][20];\n  scanf(\"%d %d\\n\",&v,&e);\n  for(i=0;i<v;i++){\n    for(j=0;j<v;j++){\n      g[i][j]=-1;\n    }\n  }\n  for(i=0;i<e;i++){\n    scanf(\"%d %d %d\\n\",&s,&t,&d);\n    g[s][t]=d;\n  }\n  for(i=0;i<(1<<v);i++){\n    for(j=0;j<v;j++){\n      dp[i][j]=INF;\n    }\n  }\n  dp[0][0]=0;\n  for(i=0;i<(1<<v);i++){\n    for(j=0;j<v;j++){\n      for(k=0;k<v;k++){\n        if(g[j][k]!=-1 && (i&(1<<k))==0){\n          dp[i|(1<<k)][k]=min(dp[i][j]+g[j][k],dp[i|(1<<k)][k]);\n        }\n      }\n    }\n  }\n  if(dp[(1<<v)-1][0]==INF){\n    printf(\"-1\\n\");\n  }\n  else{\n    printf(\"%d\\n\",dp[(1<<v)-1][0]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <array>\n#include <cmath>\n#include <memory>\nusing namespace std;\n//変数デバッグ\n#define DEB(variable) cout << #variable << '=' << variable << endl\n\n//for簡易表記(引数ミス防止)\n#define FOR(LoopVariable,numberOFbegin,numberOFend) for (long long int LoopVariable = (numberOFbegin); (LoopVariable) < (numberOFend); (LoopVariable)++)\n#define DEFOR(LoopVariable,numberOFbegin,numberOFend) for (long long int LoopVariable = (numberOFbegin)-1; (LoopVariable) >= (numberOFend); (LoopVariable)--)\n#define REP(LoopVariable,numberOFend) for(long long int LoopVariable = 0;(LoopVariable)<(numberOFend);LoopVariable++)\n\nusing llint = long long int;\n\nconstexpr long long int linf = numeric_limits<long long int>::max()-5;\nconstexpr int inf= numeric_limits<int>::max()-5;\nconstexpr long long int mod = 1000000007;\nclass Graph{\npublic:\n    Graph(llint n):g_size(n),edges(n,vector<llint>(n,linf/100)),dp(1<<n,vector<llint>(n,-1)){\n        REP(i,n){\n          //  edges[i][i] = 0;\n        }\n\n    }\n    void add_edge(llint a,llint b,llint cost){\n        edges[a][b] = cost;\n    }\n    llint search(llint bit,llint v){\n        if(dp[bit][v]>=0){\n            return dp[bit][v];\n        }\n        if(bit==((1<<g_size)-1)&&v==0){\n            return dp[bit][v]=0;\n        }\n        llint result = linf/100;\n        llint prevbit = bit & (~(1 << v));\n        REP(i,g_size){\n            if(!(bit>>i&1)){     \n                result = min(result, search(bit|1<<i, i) + edges[v][i]);\n            }\n        }\n        return dp[bit][v] = result;\n    }\n\nprivate:\n    vector<vector<llint>> edges;\n    llint g_size;\n    vector<vector<llint>> dp;\n};\n\n\nint main(){\n    llint v, e;\n    cin >> v >> e;\n    Graph graph(v);\n    llint tmpa, tmpb, tmpc;\n    REP(i,e){\n        cin >> tmpa >> tmpb >> tmpc;\n        graph.add_edge(tmpa, tmpb, tmpc);\n\n    }\n    llint result = linf;\n    result = min(result,graph.search(0, 0));\n    if(result>inf){\n        result = -1;\n    }\n    cout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>int popcount(T &a){int c=0; rep(i, 8*(int)sizeof(a)){if((a>>i)&1) c++;} return c;}\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} pr(a[a.size()-1]);}\ntemplate<class T>void prarr(arr<T>& a){rep(i, a.size()) if(a[i].empty()) pr(\"\"); else prvec(a[i]);}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nint v, e;\nint dp[1<<15][15];\nint G[15][15];\n\nint dfs(int s, int t){\n    // cout << bitset<3>(s) << \": \" << t << \": \" << dp[s][t] << endl;\n\n    if(dp[s][t]>=0) return dp[s][t];\n    \n    if(s==(1<<v)-1 && t==0){\n        return dp[s][t] = 0;\n    } \n\n    int m = INF;\n    // pr(v);\n    rep(i, v){\n        if(!((s>>i)&1) && G[t][i]!=INF){\n            m = min(m, dfs(s|(1<<i), i) + G[t][i]);\n        }\n    }\n    return dp[s][t] = m;\n}\n\nint main()\n{\n    cin >> v >> e;\n    rep(i, 15) rep(j, 15) G[i][j] = INF;\n    rep(i, 1<<15) rep(j, 15) dp[i][j] = -1;\n    rep(i, e){\n        int a, b, c;    \n        cin >> a >> b >> c;\n        G[a][b] = c; \n    }\n    // rep(i, v){\n    //     if(G[0][i]==INF) continue;\n    //     dp[1<<i][i] = G[0][i];\n    //     cout << \"dp[\" << bitset<3>(1<<i) << \"][\" << i << \"]=\" << G[0][i] << endl;\n    // }\n    int ans = dfs(0, 0);\n    if(ans==INF) pr(-1);\n    else pr(ans);\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define MOD 1000000007\n#define REP(i, N) for (int i = 0; i < N; ++i)\n#define REP1(i, N) for (int i = 1; i <= N; ++i)\n#define RREP(i, N) for (int i = N - 1; i >= 0; --i)\n#define ALL(a) a.begin(), a.end()\n\nconst int INF = 1e9;\nint V, E;\nint dist[15][15];\nint dp[1 << 15][15];\n\nint rec(int S, int v) {\n  if (0 <= dp[S][v]) {\n    return dp[S][v];\n  }\n  if (S == (1 << V) - 1 && v == 0) {\n    return dp[S][v] = 0;\n  }\n  int res = INF;\n  REP(u, V) {\n    if (!(S >> u & 1)) {\n      res = min(res, rec(S | 1 << u, u) + dist[v][u]);\n    }\n  }\n  return dp[S][v] = res;\n}\n\nint main() {\n  cin >> V >> E;\n  REP(i, V) REP(j, V) {\n    dist[i][j] = INF;\n    if (i == j) dist[i][j] = 0;\n  }\n  REP(i, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n  REP(i, 1 << V) REP(j, V) dp[i][j] = -1;\n  int ans = rec(0, 0);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<ll> vll;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<string>> vvs;\ntypedef vector<vector<char>> vvc;\ntypedef vector<vector<bool>> vvb;\ntypedef pair<int,int> P;\ntypedef pair<ll, ll> Pll;\n#define vrep(v,n) for(int i=0;i<n;i++){cin >> v.at(i);} \n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repn(i, n) for (int i = 0; i <= (int)(n); i++)\n#define srep(i, l, n) for (int i = l; i < (int)(n); i++)\n#define srepn(i, l, n) for (int i = l; i <= (int)(n); i++)\n#define pb push_back \nvoid chmin(int &a, int b) {if(a > b) a = b;}\nvoid chmax(int &a, int b) {if(a < b) a = b;}\n\nconst int mod = 1000000007;\nconst int inf = 1e9;\n#define PI 3.14159265369;\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\nint ddx[8] = {1,1,1,-1,-1,-1,0,0};\nint ddy[8] = {0,1,-1,0,1,-1,1,-1};\n\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n    int dis[v][v];\n    rep(i,v) fill(dis[i], dis[i]+v, inf);\n    while(e--){\n        int a, b, c;\n        cin >> a >> b >> c;\n        dis[a][b] = c;\n    }\n    int dp[(1<<v)][v];\n    rep(i,1<<v) fill(dp[i], dp[i]+v, inf);\n    dp[1][0] = 0;\n    for(int i = 0 ; i < (1<<v) ; i++){\n        for(int j = 0 ; j < v ; j++){\n            if(dp[i][j]==inf) continue;\n            for(int k = 0 ; k < v ; k++){\n                if(!(1&(i>>k))&&dis[j][k]!=inf){\n                    int nexti = (1 << k) | i;\n                    int nextd = dp[i][j] + dis[j][k];\n                    dp[nexti][k] = min(dp[nexti][k], nextd);\n                }\n            }\n        }\n    }\n    int ans = inf;\n    for(int i = 0 ; i < v ;i++){\n        if(dis[i][0] != inf){\n            chmin(ans, dp[(1<<v)-1][i] + dis[i][0]);\n        }\n    }\n    if(ans == inf) cout << -1 << endl;\n    else cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr int INF = 100000007;\n\nint dfs(vector<vector<int>> &dist, vector<vector<int>> &dp, int V, int S, int v) {\n\n    if (dp[S][v] >= 0) return dp[S][v];\n\n    if (S == (1 << V) - 1 && v == 0) return dp[S][v] = 0;\n\n    int ans = INF;\n    for (int u = 0; u < V; u++) {\n        if (!(S & (1 << u))) {\n            ans = min(ans, dfs(dist, dp, V, S | (1 << u), u) + dist[v][u]);\n        }\n    }\n    return dp[S][v] = ans;\n}\n\nint main() {\n\n    int V, E;\n    cin >> V >> E;\n\n    auto dist = vector<vector<int>>(V, vector<int>(V, INF));\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    auto dp = vector<vector<int>>(1 << V, vector<int>(V, -1));\n    int ans = dfs(dist, dp, V, 0, 0);\n\n    cout << (ans == INF ? -1 : ans) << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <sstream>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n#define print(s) cout << (s) << endl\n\nconst int INF = 2e9;\n\nvector<vector<int>> dp;\nvector<vector<int>> dist;\nint n;\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1<<n)-1 && v == 0) return dp[S][v] = 0;\n    \n    int res = INF;\n    REP(i,n) {\n        if (!(S>>i & 1) && dist[v][i] >= 0) {\n            // ith vertex is not in S\n            // move from v to i\n            res = min(res, rec(S | 1<<i, i) + dist[v][i]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    n = V;\n    dist = vector<vector<int>>(V,vector<int>(V,-1));\n    REP(i,E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    \n    dp = vector<vector<int>>(1<<V,vector<int>(V+1,-1));\n    // dp[S][j] denotes the minimum distance from jth vertex to 0th vertex passing all unpassed vertices\n    \n    int ans = rec(0,0);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint*** dp = new int**[N+1];\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[i] = new int*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new int[limit];\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\tfor(int start = 0; start <= 0; start++){\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int p = 0; p < limit; p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\ttmp = pow(2,start);\n\n\t\tdp[0][start][tmp] = 0;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int p = 0; p < limit; p++){\n\t\t\t\t\tif(dp[i-1][k][p] != BIG_NUM){\n\t\t\t\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\t\t\t\tif(p & (1 << a)){\n\t\t\t\t\t\t\t\tif(i == N && a == start){\n\t\t\t\t\t\t\t\t\tif(cost[k][start] != BIG_NUM)dp[i][start][limit-1] = min(dp[i][start][limit-1],dp[i-1][k][p]+cost[k][start]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\t\t\t\ttmp = p + pow(2,a);\n\t\t\t\t\t\t\t\t\tdp[i][a][tmp] = min(dp[i][a][tmp],dp[i-1][k][p]+cost[k][a]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminimum = min(minimum,dp[N][start][limit-1]);\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (sum > Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != 0 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    flag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\tif(e.exp[j] == 0) flag = false;\n\t\t    }\n\t\t}\n\t\tif(flag){\n\t\t    res = min(res,e.t);\n\t\t}\n\t\tst.push(e);\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) e.t = -1;\n    cout << e.t << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false,tflag=false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    vector<int> temp(V);\n    fill(temp.begin(),temp.end(),-1);\n    fill(v.begin(),v.end(),temp);\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\ttflag = false;\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != -1 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    tflag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\t//cout <<\"exp = \"<<e.exp[j]<<endl;\n\t\t\tif(e.exp[j] == 0){\n\t\t\t    tflag = false;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif(tflag){\n\t\t    res = min(res,e.t);\n\t\t    flag = true;\n\t\t}else{\n\t\t    st.push(e);\n\t\t}\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) res = -1;\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int inf = 987654321;\nint n, m;\nvector< vector<int> > G;\nvector< vector<int> > dp;\n\nint rec(int visited, int now) {\n  if (dp[visited][now] != -1) return dp[visited][now];\n  if (visited == (1<<n)-1 && now == 0) return dp[visited][now] = 0;\n  int res = inf;\n  for (int i = 0; i < n; i++) {\n    if (visited >> i & 1) continue; /* ??¢????¨??????? */\n    res = min(res, rec(visited | (1 << i), i) + G[now][i]);\n  }\n  return dp[visited][now] = res;\n}\n\nint main(void) {\n  cin >> n >> m;\n  G.assign(n, vector<int>(n, inf));\n  for (int i = 0; i < m; i++) {\n    int p, q, c;\n    cin >> p >> q >> c;\n    G[p][q] = c;\n  }\n  dp.assign(1 << n, vector<int>(n, -1));\n  int res = rec(0, 0);\n  if(res != inf) cout << res << endl;\n  else cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n \nusing namespace std;\n \nint V,E;\nint map[15][15];\nint dp[1<<15][15];\n \nint saiki(int vis,int pos){\n \n    int r = 1<<28;\n    if(dp[vis][pos] != -1) return dp[vis][pos];\n    if(pos == 0 && vis == (1<<V)-1){\n        return 0;\n    }\n    for(int i=0;i<V;i++){\n    if(map[pos][i] != -1 && !(vis & (1<<i)) ){\n        r = min(r,saiki( vis | (1<<i) ,i) + map[pos][i]);\n     \n    }\n    }\n \n    return dp[vis][pos] = r;\n}\nint main(){\n \n    int s,t;\n    cin >> V >> E;\n    fill(&map[0][0],&map[15][0],-1);\n    for(int i=0;i<E;i++){\n    cin >> s >> t;\n    cin >> map[s][t];\n    }\n    fill(&dp[0][0],&dp[1<<15][0],-1);\n \n    int res = saiki(0,0);\n \n    if(res >= 1<<28) res = -1;\n    cout << res << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define int long long\nconst int inf = 100100100100100;\nconst int mod = 1000000007;\n\nconst int maxn = 15;\nint n, m;\nint dist[maxn][maxn];\nint dp[1<<maxn][maxn];\n\nint dfs(int s, int v){\n\n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n\n    if(s == (1<<n)-1 && v == 0){\n        return dp[s][v] = 0;\n    }\n\n    int ans = inf;\n    rep(u,0,n){\n        if(!(s >> u & 1)){\n            ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n        }\n    }\n\n    dp[s][v] = ans;\n    return ans;\n\n\n}\n\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    \n    cin >> n >> m;\n\n    memset(dp,-1,sizeof(dp));\n    fill(dist[0],dist[0]+maxn*maxn,inf);\n\n    \n\n    \n    rep(i,0,m){\n        int f, t, c;\n        cin >> f >> t >> c;\n        dist[f][t] = c;\n    }\n    int ans = dfs(0,0);\n    cout << (ans == inf ? -1 : ans) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tMatrix g(V, Array(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tg[s][t] = d;\n\t}\n\tvector<int> p(V);\n\tiota(all(p), 0);\n\tWeight ans = INF;\n\tdo {\n\t\tWeight tmp = 0;\n\t\trep(i, 0, V) {\n\t\t\ttmp += g[p[i]][p[(i + 1) % V]];\n\t\t\tchmin(tmp, INF);\n\t\t}\n\t\tchmin(ans, tmp);\n\t} while (next_permutation(all(p)));\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\n\nconst int inf = INT_MAX / 3;\nconst int max_v = 15;\n\nint d[max_v][max_v];\nint dp[(1 << max_v)][max_v];  // S?????¢????????£????????????????????????v??????????????´???\n\n\nusing namespace std;\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\td[i][j] = (i == j) ? 0 : inf;\n\n\t\t}\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint ts,tt , td;\n\t\tcin >> ts >> tt >> td;\n\t\td[ts][tt] = td;\n\t}\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tdp[s][v] = inf;\n\t\t}\n\t}\n\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tfor (int u = 0; u < V;u++) {\n\t\t\t\t//cout << \"s:\" << s << \" v:\" << v << \" u:\" << u << endl;\n\t\t\t\tif (!((s >> u) & 1)) {\n\t\t\t\t\tdp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[u][v]);\n\t\t\t\t//\tcout << \" dp:\" << dp[s][v] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[0][0] >= inf) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << dp[0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<bool>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false,tflag=false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    vector<int> temp(V);\n    fill(temp.begin(),temp.end(),-1);\n    fill(v.begin(),v.end(),temp);\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\ttflag = false;\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != -1 && !e.exp[i]){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = true;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    tflag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\t//cout <<\"exp = \"<<e.exp[j]<<endl;\n\t\t\tif(e.exp[j] == 0){\n\t\t\t    tflag = false;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif(tflag){\n\t\t    res = min(res,e.t);\n\t\t    flag = true;\n\t\t}else{\n\t\t    st.push(e);\n\t\t}\n\t\te.pos = pre;\n\t\te.exp[i] = false;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) res = -1;\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\ntypedef long long ll;\n\nint V,E;\n\n\nvector<vector<int>> G(15,vector<int>(15,INF));\n\nvector<vector<int>> dp((1<<15), vector<int>(15,-1));\n\nint rec(int bit, int v){\n\n    if (dp[bit][v] >= 0) return dp[bit][v];//メモ化\n\n    if(bit==0){//初期化\n        if(v==0){\n            return 0;\n        }else{\n            return INF;\n        }\n    }\n\n    if((bit&(1<<v)) == 0) return INF;//、矛盾する状態なら\n\n    dp[bit][v] = INF;//ここからdp\n\n    REP(i,V){\n        dp[bit][v] = min(dp[bit][v], rec(bit^(1<<v),i) + G[i][v]);\n    }\n    return dp[bit][v];\n}\n\nint main() {\n    cin >> V >> E;\n    REP(i, E){\n        int s,t,d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    int ans = rec((1<<V)-1, 0);\n\n    if(ans == INF) ans = -1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[15][15];\nint dp[1<<15][15];\n\nint main(){\n    int N, M; cin >> N >> M;\n    int INF=pow(10,9);\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n            d[i][j]=INF;\n        }\n    }\n    for(int i=0; i<M; i++){\n        int s, t, di;\n        cin >> s >> t >> di;\n        d[s][t]=di;\n    }\n    for(int i=0; i< 1<<15; i++){\n        for(int j=0; j<15; j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[(1<<N)-1][0]=0;\n    for(int S=(1<<N)-2; S>=0; S--){\n        for(int v=0; v<N; v++){\n//            if( ! (1<<v &S) ) continue;\n            for(int u=0; u<N; u++){\n                if(!(S>>u &1)){\n                    dp[S][v]=min(dp[S][v], dp[S|1<<u][u]+d[v][u]);\n                }\n            }\n        }\n    }\n    if(dp[0][0]<INF){\n    cout << dp[0][0] << endl;\n    }\n    else cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nint main(){\n  int v,e;\n  cin>>v>>e;\n  WG<int> es(v);\n  vector<vector<int>> dp((1<<v),vector<int>(v,inf));\n  vector<int> cost(v,inf);\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s].PB(edge<int>(t,d));\n    es[t].PB(edge<int>(s,d));\n    if(t==0){\n      cost[s]=min(cost[t],d);\n    }\n  }\n  dp[1][0]=0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==inf) continue;\n      for(auto et:es[j]){\n        if(i&(1<<et.to)) continue;\n        dp[i|(1<<et.to)][et.to]=min(dp[i|(1<<et.to)][et.to],dp[i][j]+et.cost);\n      }\n    }\n  }\n\n  int ans=inf;\n  rep(i,v){\n    ans=min(ans,dp[(1<<v)-1][i]+cost[i]);\n  }\n\n  cout<<((ans==inf)?-1:ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre,res = 1<<29;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != 0 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    flag = true;\n\t\t    for(int j=0;j<V;j++){\n\t\t\tif(e.exp[j] == 0) flag = false;\n\t\t    }\n\t\t}\n\t\tif(flag){\n\t\t    res = min(res,e.t);\n\t\t}\n\t\tst.push(e);\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) res = -1;\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\nusing namespace std;\nconst int INF=INT_MAX/2;\n\nstruct edge { int to, weight;};\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nint  DP[1 << 15][15];\n\nint rec(int S, int v, int V, Graph &G){\n\tif(DP[S][v]>=0){\n\t\treturn DP[S][v];\n\t}\n\tif (S==(1 << V)-1 && v==0) \n\t{\n\t\treturn DP[S][v]=0;\n\t}\n\n\tint r = INF;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge f = G[v][i];\n\t\tif((S >> f.to)%2==0){\n\t\t\tr=min(r,rec((S | (1 << f.to)) ,f.to,V,G)+f.weight);\n\t\t}\n\t}\n\treturn DP[S][v]=r;\n}\n\nint main(){\n\tint V,E,d,s;\n\tedge e;\n\tcin >> V >> E ;\n\n\tGraph G(V);\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> e.to >> e.weight;\n\t\tG[s].push_back(e);\n\t}\n\n\tmemset(DP,-1,sizeof(DP));\n\tcout << rec(0,0,V,G) <<endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (sum == -1 || sum < Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n  int V,E;\n  cin>>V>>E;\n  int d[15][15];\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      d[i][j]=-1;\n    }\n  }\n  while(E--){\n    int s,t,d_;\n    cin>>s>>t>>d_;\n    d[s][t]=d_;\n  }\n  int dp[1<<15][15];\n  for(int i=0;i<V-1;i++){\n    if(d[V-1][i]>=0){\n      dp[1<<i][i]=d[V-1][i];\n    }else{\n      dp[1<<i][i]=1e9;\n    }\n  }\n  for(int i=0;i<1<<V-1;i++){\n    if(!(i&i-1))continue;\n    for(int j=0;j<V-1;j++){\n      if(!(i>>j&1))continue;\n      dp[i][j]=1e9;\n      int p=i^1<<j;\n      for(int k=0;k<V-1;k++){\n\tif(!(p>>k&1)||d[k][j]<0)continue;\n\tdp[i][j]=min(dp[i][j],dp[p][k]+d[k][j]);\n      }\n    }\n  }\n  int b=1e9;\n  for(int i=0;i<V-1;i++){\n    if(d[i][V-1]<0)continue;\n    b=min(b,dp[(1<<V-1)-1][i]+d[i][V-1]);\n  }\n  cout<<(b>1e8?-1:b)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,c;\n};\n\nint V,E,ST;\nvector<edge> G[20];\nint dp[(1<<15)][16];\nint solve(int st,int id){\n  if( dp[st][id] != -1 ) return dp[st][id];\n  if( st == (1<<V)-1 && id == ST ) return dp[st][id] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<(int)G[id].size();i++){\n    edge e = G[id][i];\n    if( (st & (1<<e.to) ) ) continue;\n    ret = min( ret, solve(st|(1<<e.to),e.to) + e.c );\n  }\n  return dp[st][id] = ret;\n}\n\nint main(){\n  cin >> V >> E;\n  for(int i=0;i<E;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    G[s].push_back((edge){t,d});\n  }\n  int res = (1<<29);\n  for(int i=0;i<V;i++){\n    memset(dp,-1,sizeof(dp));\n    res = min ( res, solve(0,i) );\n    ST++;\n  }\n  cout << (res==(1<<29)?-1:res) << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nconst int INF = 1000100100;\n    int dp[(1 << 16)][16]={};\n    int  Graph[16][16];\n    int V;\n\nint rec(int selection, int last_node){\n\n    if(selection ==0){\n        if(last_node ==0){//始点の0に戻ってくる場合\n            return 0;\n        }else{\n            return INF;//セレクションは0だけど、last_nodeは0以外の値の場合\n        }\n    }\n    else if((selection &(1 << last_node)) == 0){\n        return INF;\n    }\n    int &ret = dp[selection][last_node];\n    if(ret!= 0){\n        return ret;\n    }\n        ret = INF;//最小値をとるので、このタイミングでretをINFにする。（最初から全部しても多分いい。\n    for (int i=0;i<V;i++){//どのノードを減らした奴からの増分が一番大きいか確認する）\n            ret=min(ret,rec(selection ^ (1 << last_node),i)+Graph[i][last_node]);\n    }\n    return  ret;\n}\n\n\n\nint main(){\n    int E;\n    cin >> V >> E;\n    for(int i=0;i<V; i++){\n        for(int j =0; j <V;j++){\n           Graph[i][j] = INF;\n        }\n    }\n    for (int i=0;i < E;i++){\n        int tmp1,tmp2,tmp3;\n        cin >> tmp1 >> tmp2 >>tmp3;\n        Graph[tmp1][tmp2]=tmp3;\n    }\n\n    //ここからメモ化再帰\n    int ret=INF;\n    ret = rec((1 << V)-1, 0);//どの頂点から出発しても、一周回ればおなじこと\n    if(ret == INF){\n        cout << -1 << endl;\n    }\n    else{\n        cout << ret << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit(int mask, int num)\n{\n\treturn (mask >> num) & 1;\n}\ninline int add_bit(int mask, int num)\n{\n\treturn (mask + (1 << num));\n}\n\n\nint main()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back(make_pair(destiny, len));\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow(2, n);\n\tvector < vector < int > > dp(max_mask, vector < int >(n, -1));\n\tdp[1][0] = 0;\n\tfor (int mask = 1; mask < max_mask; mask++)\n\t{\n\t\tfor (int vertex = 0; vertex < n; vertex++)\n\t\t{\n\t\t\tfor (i = 0; i < graph[vertex].size(); i++)\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif (!get_bit(mask, next))\n\t\t\t\t{\n\t\t\t\t\tif ((dp[add_bit(mask, next)][next] < dp[mask][vertex] + graph[vertex][i].second) || (-1 == dp[add_bit(mask, next)][next]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit(mask, next)][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tfor (j = 0; j < graph[i].size(); j++)\n\t\t{\n\t\t\tif (0 == graph[i][j].first)\n\t\t\t{\n\t\t\t\tif ((result > dp[max_mask - 1][i] + graph[i][j].second) || (result = -1))\n\t\t\t\t{\n\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nstruct edge {int to, cost;};\nint g[20][20];\nint dp[1<<15][15];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n)rep(j, n) g[i][j] = INT_MAX;\n    rep(i, m) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    rep(i, 1<<n)rep(j, n) dp[i][j] = 100000;\n    int start = 0;\n    dp[1<<start][start] = 0;\n\n    rep(i, 1<<n) {\n        rep(j, n) {\n            if (i>>j & 1) {\n                rep(k, n) {\n                    dp[i][j] = min(dp[i][j], dp[i^(1<<j)][k] + g[k][j]);\n                }\n            }\n        }\n    }\n    int ans = INT_MAX;\n    rep(j, n) ans = min(ans, dp[(1<<n) - 1][j] + g[j][start]);\n    cout << (ans == INT_MAX ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int v, int used) {\n    if (used == (1 << V) - 1) return G[v][0];\n    if (memo[v][used] >= 0) return memo[v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || G[v][u] == INF || (used & (1 << u))) continue;\n        ret = min(ret, dfs(u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[v][used] = ret;\n}\nint TSP() {\n    init();\n    return dfs(0, 0);\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans == INF ? -1 : Ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF (1 << 30)\n#define ll long long\n#define MAX_N 16\nusing namespace std;\n\nll V, E;\nll G[MAX_N][MAX_N];\nll dp[1 << MAX_N][MAX_N];\n\nll rec(int S, int v) {\n\tif (dp[S][v] >= 0) {\n\t\treturn dp[S][v];\n\t}\n\n\tif (S == (1 << V) - 1 && v == 0) {\n\t\treturn dp[S][v] = 0;\n\t}\n\n\tll res = INF;\n\tfor (int u = 0; u < V; u++) {\n\t\tif (!(S >> u & 1)) {\n\t\t\tres = min(res, rec(S | 1 << u, u) + G[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> V >> E;\n\tfor (int i = 0; i < MAX_N;i++) {\n\t\tfor (int j = 0; j < MAX_N;j++) {\n\t\t\tG[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int inf = 987654321;\nint n, m;\nvector< vector<int> > G;\nvector< vector<int> > dp;\n\nint rec(int visited, int now) {\n  if (dp[visited][now] != -1) return dp[visited][now];\n  if (visited == (1<<n)-1 && now == 0) return dp[visited][now] = 0;\n  int res = inf;\n  for (int i = 0; i < n; i++) {\n    if (visited >> i & 1) continue; /* ??¢????¨??????? */\n    res = min(res, rec(visited | (1 << i), i) + G[now][i]);\n  }\n  return dp[visited][now] = res;\n}\n\nint main(void) {\n  cin >> n >> m;\n  G.assign(n, vector<int>(n, inf));\n  for (int i = 0; i < m; i++) {\n    int p, q, c;\n    cin >> p >> q >> c;\n    G[p][q] = c;\n  }\n  dp.assign(1 << n, vector<int>(n, -1));\n  int res = rec(0, 0);\n  if(res >= inf) cout << res << endl;\n  else cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\nusing namespace std;\nconst int INF=INT_MAX/2;\n\nstruct edge { int to, weight;};\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nint  DP[1 << 15][15];\n\nint rec(int S, int v, int V, Graph &G){\n\tif(DP[S][v]>=0){\n\t\treturn DP[S][v];\n\t}\n\tif (S==(1 << V)-1 && v==0) \n\t{\n\t\treturn DP[S][v]=0;\n\t}\n\n\tint r = INF;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge f = G[v][i];\n\t\tif((S >> f.to)%2==0){\n\t\t\tr=min(r,rec((S | (1 << f.to)) ,f.to,V,G)+f.weight);\n\t\t}\n\t}\n\treturn DP[S][v]=r;\n}\n\nint main(){\n\tint V,E,d,s;\n\tedge e;\n\tcin >> V >> E ;\n\n\tGraph G(V);\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> e.to >> e.weight;\n\t\tG[s].push_back(e);\n\t}\n\n\tmemset(DP,-1,sizeof(DP));\n\tcout << rec(0,0,V,G) <<endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define INF 20000000\n#define FER 0.0000000001\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nint dp[1 << 15][15];\nint dist[15][15];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 15; i++)for (int j = 0; j < 15; j++)\n\t{\n\t\tdist[i][j] = INF;\n\t}\n\n\tint V, E;\n\tcin >> V >> E;\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tdist[s][t] = d;\n\t}\n\n\tfor (int i = 0; i < 1 << V; i++)\n\t{\n\t\tfill(dp[i], dp[i] + V, INF);\n\t}\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int S = (1 << V) - 2; S >= 0; S--)\n\t{\n\t\tfor (int v = 0; v < V; v++)\n\t\t{\n\t\t\tfor (int u = 0; u < V; u++)\n\t\t\t{\n\t\t\t\tif (!(S >> u & 1))\n\t\t\t\t{\n\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S | (1 << u)][u] + dist[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(dp[0][0] == INF ? \"-1\\n\" : \"%d\\n\", dp[0][0]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int v, int used) {\n    if (used == (1 << V) - 1) return G[v][0];\n    if (memo[v][used] >= 0) return memo[v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || G[v][u] == INF || (used & (1 << u))) continue;\n        ret = min(ret, dfs(u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[v][used] = ret;\n}\nint TSP() {\n    init();\n    return dfs(0, 1);\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans >= INF ? -1 : Ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl;\n#define show2(a, n, m) rep(i, n) { rep(j, m) {cout << a[i][j] << ' ';} cout << endl;}\n#define chmin(a, b) a = min((a), (b));\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\n\n//const int INF = 1 << 30;\nconst int INF = 10000;\nconst long long INFL = 1LL << 62;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 100010;\n\nint main() {\n//\tcout << fixed << setprecision(15);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vi> d(n, vi(n, INF));\n\trep(i, m) {\n\t\tint s, t, dt;\n\t\tcin >> s >> t >> dt;\n\t\td[s][t] = dt;\n\t}\n\n\tvector<vi> dp(1 << n, vi(n, INF));\n\tdp[0][0] = 0;\t// limit start to 0 because cyclic\n\n\trep(i, 1 << n) rep(j, n) rep(k, n) {\n\t\tif(i & (1 << j)) continue;\t// already visited\n\t\tchmin(dp[i | (1 << j)][j], dp[i][k] + d[k][j]);\n\t}\n\n\tint ans = dp[(1 << n) - 1][0];\n\tcout << (ans == INF ? -1 : ans) << endl;\n//\tshow2(dp[15], n, n);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, s, t, d;\n\n\tcin >> V >> E;\n\n\tvector<vector<int> > M(V, vector<int>(V, 1 << 27));\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> s >> t >> d;\n\n\t\tM[s][t] = d;\n\t}\n\n\tvector<vector<int> > dp(V, vector<int>(1 << V, 1 << 27));\n\n\tdp[0][0] = 0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < V; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < (1 << V); k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l < V; l++)\n\t\t\t\t{\n\t\t\t\t\tif ((k / (1 << j)) % 2 == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[j][k] = min(dp[j][k], dp[l][k - (1 << j)] + M[l][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (dp[0][(1 << V) - 1] != (1 << 27) ? dp[0][(1 << V) - 1] : -1) << endl;\n\n\treturn 0;\n}\n\n// Time : O ( V ^ 3 * 2 ^ V ) = 110,592,000"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint d[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint tsp(int start, int visited_flag, int city_num){\n    int rtn = MAX;\n    //??¨????????????????¨???????????????´???\n    if(visited_flag == (1 << city_num) - 1){\n        if (d[start][0] == -1) {\n            return rtn;\n        }else{\n            return d[start][0];\n        }\n    }\n    \n    for (int i = 0; i < city_num; i++) {\n        //??????????¨???????????????§????????´???\n        if (\n            !(visited_flag & (1 << i))\n            &&\n            d[start][i] != -1\n            )\n        {\n            rtn = min(\n                      rtn,\n                      d[start][i] + tsp(i, visited_flag | (1 << i), city_num)\n                      );\n        }\n    }\n    \n    return rtn;\n}\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(d, -1, sizeof(d));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        d[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1, V);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\n\nint DP[50000][20];\nvector<vector<pair<int, int> > > edge(20);\nint V;\n\nint solve(int S, int v){\n    if(DP[S][v]>=0) return DP[S][v];\n    DP[S][v] = inf;\n    for(int i=0;i<edge[v].size();++i){\n        if((S&(1<<edge[v][i].fi))==0){\n            DP[S][v] = min(DP[S][v], solve(S|(1<<edge[v][i].fi), edge[v][i].fi) + edge[v][i].se);\n        }\n    }\n    return DP[S][v];\n}\n\nint main() {\n    for(int i=0;i<50000;++i){\n        for(int j=0;j<20;++j){\n            DP[i][j] = -1;\n        }\n    }\n    int E;\n    cin>>V>>E;\n    DP[(1<<V)-1][0] = 0;\n    int s, t, d;\n    for(int i=0;i<E;++i){\n        cin>>s>>t>>d;\n        edge[s].push_back(make_pair(t, d));\n    }\n    int ans = solve(0, 0);\n    if(ans==inf) cout<<-1<<endl;\n    else cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nWeight travel_salesman(const Graph &g) {\n    size_t V=g.size();\n    vector<vector<size_t>> dp(1<<V, vector<size_t>(V, INF));\n    dp[(1<<V)-1][0] = 0;\n\n    for (size_t s=(1<<V)-2; ~s; --s)\n        for (size_t v=0; v<V; ++v)\n            for (const Edge &e: g[v]) {\n                size_t u=e.dst;\n                if (!(1<<u & s))\n                    dp[s][v] = min(dp[s][v], dp[1<<u|s][u]+e.weight);\n            }\n\n    return dp[0][0]<INF? dp[0][0]:-1;\n}\n\nint main() {\n    size_t V, E;\n    scanf(\"%zu %zu\", &V, &E);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        Weight d;\n        scanf(\"%zu %zu %lld\", &s, &t, &d);\n\n        connect(g, s, t, d);\n    }\n\n    printf(\"%lld\\n\", travel_salesman(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp((1 << V), vector<int>(V, -1));\n\tfunction<int(int, int)>tsp = [&](int S, int v) {\n\t\tif (dp[S][v] != -1)return dp[S][v];\n\t\tif (S == (1 << V) - 1 && v == 0)return dp[S][v] = 0;\n\t\tint ret(INF);\n\t\trep(i, 0, V) {\n\t\t\tif (!(S&(1 << i))) {\n\t\t\t\tchmin(ret, tsp(S | (1 << i), i) + G[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[S][v] = ret;\n\t};\n\tint ans = tsp(0, 0);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int s, t, d;\n  vector<vector<int> > adjmatrix(v, vector<int>(v, INF));\n  for(int i = 0; i < e; i++){\n    cin >> s >> t >> d;\n    adjmatrix[s][t] = d;\n  }\n\n  // dp[i][j] = ??????i?????????????????????????????????????????????j????????????????????´??????????°??????????\n  vector<vector<int> > dp(1 << v, vector<int>(v, INF));\n  dp[0][0] = 0;\n  \n  // ??????????????????????????????\n  for(int i = 0; i < (1 << v); i++){\n    for(int j = 0; j < v; j++){\n      // ?????????????????????k????????????????????¨????????????\n      for(int k = 0; k < v; k++){\n        // ?????§?????????k?????°??????????????£???????£???°???\n        if((i & (1 << k)) != 0){ continue; }\n\n        // ????£????: ????????¶????????? + ??????j????????????k???????§?????????????\n        int cost = dp[i][j] + adjmatrix[j][k];\n\n        // ?????¨???????????????????£?????????????????°????????????°?????????????????´??°\n        if(cost < dp[i | (1 << k)][k]){ dp[i | (1 << k)][k] = cost; }\n      }\n    }\n  }\n\n  // ??????\n  if(dp[(1 << v) - 1][0] == INF){ cout << -1 << endl; }\n  else{ cout << dp[(1 << v) - 1][0] << endl; }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <tuple>\nusing ll = long long;\nusing namespace std;\n\nint d[15][15];\nint dp[1 << 15][15];\nint main(void)\n{\n    int V, E;\n    cin >> V >> E;\n    for (int i = 0; i < V; ++i)\n        for (int j = 0; j < V; ++j)\n            d[i][j] = 1e8;\n    for (int i = 0; i < E; ++i)\n    {\n        int s, t, ds;\n        cin >> s >> t >> ds;\n        d[s][t] = ds;\n    }\n\n    for (int S = 0; S < 1 << V; ++S)\n    {\n        for (int i = 0; i < V; ++i)\n        {\n            dp[S][i] = 1e8;\n        }\n    }\n\n    dp[(1 << V) - 1][0] = 0;\n\n    for (int S = (1 << V) - 2; S >= 0; S--)\n    {\n        for (int v = 0; v < V; ++v)\n        {\n            for (int u = 0; u < V; ++u)\n            {\n                if (!(S >> u & 1))\n                {\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n    if (dp[0][0] != 1e8)\n        cout << dp[0][0] << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 987654321\nint V, E, A[15][15], MEMO[15][32768], VISIT[15][32768];\nvoid input(void);\nvoid init_A(void);\nvoid init_MEMO(void);\nint DP(int dest, int VIA);\nint TSP(void);\nint main(void) {\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    printf(\"%d\\n\", TSP());\n    return 0;\n}\nint TSP(void){\n    int i, VIA_init, min = MAX;\n    for(i = 0; i < V; i++){\n        init_MEMO();\n        VIA_init = (1 << V) - 1 & ~(1 << i);\n        int cnd = DP(i, VIA_init);\n        if (cnd < min) min = cnd;\n    }\n    if (min >= MAX)\n        return -1;\n    else\n        return min;\n}\nint DP(int dest, int VIA){ // single source memoization\n    if(VIA == 0){\n        if (A[0][dest] != -1) return A[0][dest];\n        else return MAX;\n    }\n    if(VISIT[dest][VIA] == 1) return MEMO[dest][VIA];\n    VISIT[dest][VIA] = 1;\n    int i, min = MAX;\n    for (i = 0; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    MEMO[dest][VIA] = min;\n    return min;\n}\n/*\nint DP(int dest, int VIA){ // single source backward tracking\n    if(VIA == 0) return A[0][dest];\n    int i, min = MAX;\n    for (i = 1; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    return min;\n}*/\nvoid input(void){\n    scanf(\"%d%d\", &V, &E);\n    init_A();\n    int i, s, t, d;\n    for(i = 0; i < E; i++){\n        scanf(\"%d%d%d\", &s, &t, &d);\n        A[s][t] = d;\n    }\n}\nvoid init_A(void){\n    int i, j;\n    for(i = 0; i < V; i++)\n        for(j = 0; j < V; j++) A[i][j] = -1;\n}\nvoid init_MEMO(void){\n    int i, j;\n    for(i = 0; i < V; i++){\n        for(j = 0; j < (1<<V); j++){\n            MEMO[i][j] = 0;\n            VISIT[i][j] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (1e9);\n\nint main(){\n  int V, E;\n  cin >> V >> E;\n  vector< vector<int> > G(V, vector<int>(V,INF));\n  for(int i = 0; i < E; ++i){\n    int s, t, d;\n    cin >> s >> t >> d;\n    G[s][t] = d;\n  }\n  for(int i = 0; i < V; ++i) G[i][i] = 0;\n  vector< vector<int> > DP((1<<V),vector<int>(V,INF));\n  DP[1][0] = 0;\n  for(int i = 1; i < (1<<V); ++i){\n    for(int j = 0; j < V; ++j){\n      if(!((i>>j)&1)) continue;\n      for(int k = 0; k < V; ++k){\n        if(((i>>k) & 1) || j == k) continue;\n        DP[i|(1<<k)][k] = min(DP[i|(1<<k)][k], DP[i][j] + G[j][k]);\n        //cerr << \"DP[\" << (i|(1<<k)) << \"] = \" << DP[i|(1<<k)][k] << endl;\n      }\n    }\n  }\n  int ans = INF;\n  for(int i = 0; i < V; ++i) ans = min(ans, DP[(1<<V)-1][i] + G[i][0]);\n  if(ans < INF) cout << ans << endl;\n  else cout << -1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint dmin(int a, int b){\n    return (-(a < b) & a) + (-(a >= b) & b);\n}\nint main(){\n    int V, E;\n    scanf(\"%d%d\", &V, &E);\n    int *d = (int *)malloc(sizeof(int)*V*V);\n    for(int i=0; i<V*V; i++) d[i] = (int)1e7;\n    for(int i=0; i<E; i++){\n        int s, t, x;\n        scanf(\"%d%d%d\", &s, &t, &x);\n        d[s*V+t] = x;\n    }\n    int *dp = (int *)malloc(sizeof(int)*V*(1<<V));\n    for(int i=0; i<(1<<V); i++)\n        for(int j=0; j<V; j++)\n            dp[i*V+j] = 1e7;\n    \n    int *state = (int *)malloc(sizeof(int)*(1<<(V))*(V+1));\n    int *num = (int *)malloc(sizeof(int)*(V+1));\n    for(int i=0; i<(1<<V); i++){\n        int c = 0;\n        for(int j=1; j<(1<<V); j<<=1){\n            if(i&j) c++;\n        }\n        state[num[c]*V+c] = i;\n        num[c]++;\n    }\n    for(int i=0; i<=V; i++){\n        for(int j=0; j<num[i]; j++){\n            for(int k=0; k<V; k++){\n                if(state[j*V+i] == 0 && k == 0) dp[0] = 0;\n                if(!((state[j*V+i]>>k)&1)) continue;\n                for(int l=0; l<V; l++){\n                    dp[state[j*V+i]*V+k] = dmin(dp[state[j*V+i]*V+k], dp[(state[j*V+i]^(1<<k))*V+l]+d[l*V+k]);\n                }\n            }\n        }\n    }\n\n    int ans = dmin((int)1e7, dp[((1<<V)-1)*V+0]);\n    if(ans == 1e7) ans = -1;\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <ctime>\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXISTch(s,c) ((((s).find_first_of(c)) != std::string::npos)? 1 : 0)//cがあれば1 if(1)\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define loop(n) FOR(i,0,n)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = (int)1000000007;\nconst LL MOD = (LL)1000000007;//10^9+7\nconst LL INF2 = (LL)100000000000000000;//10^18\n\nint main() {\n\tint V, E; cin >> V >> E;\n\n\tvector<vector<int>> adj(V, vector<int>(V));\n\n\tfor (int e = 0; e < E; e++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\n\t\tadj[s][t] = d;\n\t}\n\t\t\t\n\t\n\t//dp[既に訪れた部分集合][最後に訪れた頂点]のときの最短距離\n\t//dp[S][v]\n\tvector<vector<int>> dp(1 << V, vector<int>(V));\n\t\n\t//dp初期化\n\tfor (int i = 0; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\t//頂点0から出発。\n\t//部分集合としては0…0001\n\t//最後に訪れたのは頂点0で頂点0からの距離は0\n\tdp[1][0] = 0;\n\n\tfor (int s = 0; s < (1 << V); s++) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (dp[s][v] == INF)continue;\n\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (s >> k & 1)continue;\n\t\t\t\tint nexts = s | (1<<k);\n\n\t\t\t\tif (adj[v][k] != 0) {\n\t\t\t\t\tdp[nexts][k] = min(dp[nexts][k], dp[s][v] + adj[v][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tint all = (1 << V) - 1;\n\tint ans = INF;\n\tfor (int v = 0; v < V; v++) {\n\t\tif (dp[all][v] == INF)continue;\n\t\tif (adj[v][0] == 0)continue;\n\n\t\tans = min(ans, dp[all][v] + adj[v][0]);\n\t}\n\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint V,E;//頂点数\nint d[16][16];\nint dp[16][1<<16];//頂点Sを全て巡って頂点iに至る最短経路とする\nint main(){\n\tcin>>V>>E;\n\tfor(int i =0; i <(1<<16);i++){\n\t\tfor(int j = 0;j <V;j++){\n\t\t\tdp[j][i]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i <V;i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i <E;i++){\n\t\tint s,t,c;\n\t\tcin>>s>>t>>c;\n\t\td[s][t]=c;\n\t}\n\tdp[0][1]=0;\n\tfor(int i =0;i <(1<<V);i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\tif((i>>j&1)==0)continue;\n\t\t\tfor(int k =0;k < V;k++){\n\t\t\t\tif((i>>k&1)==1)continue;\n\t\t\t\tdp[k][i|(1<<k)] = min(dp[k][i|(1<<k)], dp[j][i]+d[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint res =INF;\n\tfor(int i =0;i <V;i++){\n\t\tres =min(res,dp[i][(1<<V)-1]+d[i][0]);\n\t}\n\tif(res==INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nclass edge{\n\tpublic:\n\tint t,d,lim;\n\tedge(int it,int id,int ilim){\n\t\tt=it;\td=id;\tlim=ilim;\n\t}\n\tbool operator>(edge a){\n\t\treturn lim>a.lim;\n\t}\n\tbool operator<(edge a){\n\t\treturn lim<a.lim;\n\t}\n\tbool operator>=(edge a){\n\t\treturn lim>=a.lim;\n\t}\n\tbool operator<=(edge a){\n\t\treturn lim<=a.lim;\n\t}\n\tbool operator==(edge a){\n\t\treturn lim==a.lim;\n\t}\n};\nvector<edge> e[20];\nll dp[16][1<<16];\nint main(){\n\tint n,m;\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint s,t,d,ti;\tcin>>s>>t>>d>>ti;\n\t\te[s-1].push_back(edge(t-1,d,ti));\n\t\te[t-1].push_back(edge(s-1,d,ti));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=(1<<n)-1;j>=0;j--){\n\t\t\tdp[i][j]=2e14;\n\t\t}\n\t}\n\tdp[0][0]=0;\tcnt[0][0]=1;\n\tfor(int i=0;i<(1<<n)-1;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[j][i]==2e14)\tcontinue;\n\t\t\tfor(int k=0;k<(int)e[j].size();k++){\n\t\t\t\tif(dp[j][i]+e[j][k].d<=e[j][k].lim){\n\t\t\t\t\tint next=i|(1<<e[j][k].t);\n\t\t\t\t\tif(next==i)\tcontinue;\n\t\t\t\t\tif(dp[e[j][k].t][next]>dp[j][i]+e[j][k].d){\n\t\t\t\t\t\tdp[e[j][k].t][next]=dp[j][i]+e[j][k].d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][(1<<n)-1]==2e14){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<dp[0][(1<<n)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n    int INF = 1000000000;\n\n    int N, M;\n    cin >> N >> M;\n    int g[N][N];\n\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n            g[i][j] = -1;\n        }\n    }\n    for(int i=0; i<M; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    int dp[(1<<N)][N];\n    for(int i=0; i<(1<<N); i++){\n        for(int j=0; j<N; j++){\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][0] = 0;\n    for(int S=1; S<=(1<<N)-1; S++){\n        for(int i=0; i<N; i++){\n            for(int j=0; j<N; j++){\n                int t = S ^ (1<<j);\n                if(g[i][j] == -1) continue;\n                if(!(S>>j)) continue;\n                if(dp[t][i] == INF) continue;\n                dp[S][j] = min(dp[S][j], dp[t][i]+g[i][j]);\n            }\n        }\n    }\n\n    if(dp[(1<<N)-1][0] == INF) cout << -1 << endl;\n    else cout << dp[(1<<N)-1][0] <<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <climits>\n#include <bitset>\n#define MOD 1000000007\n// INT_MAX\nusing namespace std;\n\n// struct Node\n// {\n// \tbitset<16> bit;\n// \t// vector<int> indeg;\n// \tint cur;\n// \tint path;\n// };\n\nclass Solver\n{\nprivate:\n\tint v;\n\tint e;\n\tvector<vector<int> > adj;\n\tvector<vector<int> > dp;\npublic:\n\tSolver(){\n\t\tcin >> v >> e;\n\t\tadj.resize(v);\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tadj[i].resize(v);\n\t\t\tfor (int j = 0; j < v; ++j)\n\t\t\t{\n\t\t\t\tadj[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < e; ++i)\n\t\t{\n\t\t\tint s, t, d;\n\t\t\tcin >> s >> t >> d;\n\t\t\tadj[s][t] = d;\n\t\t}\n\t\tdp = vector<vector<int> >(1 << v, vector<int>(v, INT_MAX) );\n\t}\n\n\tint recursive(int bit, int cur){\n\t\tif(dp[bit][cur] != INT_MAX){\n\t\t\treturn dp[bit][cur];\n\t\t}\n\n\t\tif(bit == (1 << v) - 1 && cur == 0) return 0;\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tif(bit >> i & 0){\n\t\t\t\tans = min(ans, recursive(bit | 1 << i, i));\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][cur] = ans; \n\t}\n\n\tvoid exec(){\n\t\tint ans = recursive(0, 0);\n\t\tif(ans == INT_MAX) ans = -1;\n\t\tcout << ans << endl;\n\t}\n};\n\n\nint main(){\n\tSolver s = Solver();\n\ts.exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nll d[16][16],dp[(1<<16)][16];\nll n,e;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tFOR(i,0,(1<<16))FOR(j,0,16)dp[i][j]=INF;\n\tFOR(i,0,16)FOR(j,0,16)d[i][j]=INF;\n\tcin>>n>>e;\n\tdp[(1<<n)-1][0]=0;\n\tFOR(i,0,e){\n\t\tll x,y,c;\n\t\tcin>>x>>y>>c;\n\t\td[x][y] = c;\n\t}\n\tFORR(S,0,(1<<n)-1){\n\t\tFOR(v,0,n){\n\t\t\tFOR(u,0,n){\n\t\t\t\tif( !(S >> u & 1))\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S | 1<<u][u] + d[v][u]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[0][0]==INF ? -1 : dp[0][0]) <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 巡回セールスマン問題(traveling-salesman problem)を扱います\n *\n * @note  巡回セールスマン問題はハミルトン閉路問題に密接に関連した問題で、セールスマンはn個の都市を訪問しなければならない\n *        この問題をn個の頂点を持つ完全グラフとして定式化すると、各都市を正確に1回だけ訪れ、最初に出発した都市で終わる巡回路(tour)\n *        あるいはハミルトン閉路を構成することがセールスマンの目的であるが、都市iから都市jに移動するのに非負整数のコストc(i, j)が\n *        かかるので、全コストが最小になるようにしたいというのがセールスマンの希望である. ここで、全コストは巡回路の辺に\n *        割り当てられていたコストの総和である\n *\n * @note  巡回セールスマン問題はNP完全であり、多項式時間の効率的なアルゴリズムは知られていない. しかし、動的計画法を用いることで\n *        ある程度nが小さいサイズならば、厳密解を与えることができる\n *\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A\n * @date  2016/05/08\n */\n\n\n\n//********************************************************************************\n// 必要なヘッダファイルのインクルード\n//********************************************************************************\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n\n\n//********************************************************************************\n// オブジェクト形式マクロの定義\n//********************************************************************************\n\n#define GRAPH_BEGIN namespace graph {\n#define GRAPH_END   }\n\n\n\n//********************************************************************************\n// 名前空間の始端\n//********************************************************************************\n\nGRAPH_BEGIN\n\n\n\n//********************************************************************************\n// 型シノニム\n//********************************************************************************\n\nusing weight_t   = std::int32_t;  /**< 辺(u, v)への重みwを表す型 */\nusing index_t    = std::int32_t;  /**< 頂点vの添字を表す型       */\nusing capacity_t = weight_t;      /**< 辺(u, v)の容量を表す型    */\nusing bool_t     = std::int32_t;  /**< ブール値は整数型で、{ false 0 true それ以外 }とする */\n\n\n\n//********************************************************************************\n// 構造体の定義\n//********************************************************************************\n\n/**\n * @brief  頂点色列挙構造体(scoped enum)\n * @detail (u, v) ∈ Eで頂点uが黒ならば頂点vは灰か黒である\n *         すなわち、黒頂点に隣接する全ての頂点は発見済みである\n *         灰頂点は白頂点に隣接することがあり、これらの頂点が既発見頂点と未発見頂点の境界をなす\n */\nenum struct vcolor : std::int32_t {\n    white,  /**< 未発見頂点 */\n    black,  /**< 既発見頂点 */\n    gray,   /**< 既見済頂点 */\n};\n\n/**\n * @brief グラフ用ノード(頂点) \n */\nstruct vertex {\n    union {\n        weight_t d;       /**< 始点sからの距離  */\n        weight_t key;     /**< Primのアルゴリズムにおいて木に属するある頂点とを結ぶ重み */\n    };\n    index_t pi;           /**< 先行頂点(の添字) */\n    union {\n        vcolor color;     /**< 頂点の色        */\n        bool_t  visited;  /**< 発見済みか?     */\n    };\n    // weight_t f;           /**< 終了時刻印(DFSにおいて、黒色に彩色されたとき、刻まれる)     */\n    vertex() : d(0), pi(0), color(vcolor::white)/*, f(0)*/ {}\n};\n\n/**\n * @brief グラフ用エッジ(辺)\n * @note  G = (V, E)を重み関数wを持つ重み付きグラフとすると、\n *        辺(u, v) ∈ Eの重みはw(u, v)と表される\n */\nstruct edge {\n    index_t  src;   /**< 辺の始点u */\n    index_t  dst;   /**< 辺の終点v */\n    union {\n        weight_t w;     /**< 辺(u, v)への重み(コスト) */\n        capacity_t c;   /**< 辺(u, v)の容量 */\n    };\n    edge() = default;\n    edge(index_t src, index_t dst) : src(src), dst(dst), w(1) {}\n    edge(index_t src, index_t dst, weight_t w) : src(src), dst(dst), w(w) {}\n};\n\n\n\nnamespace limits {\n    enum {  // scopedではあるが強く型付けされたenum(strongly-typed enum)ではない\n        inf = std::numeric_limits<weight_t>::max() / 3,  /**< @brief 辺が存在しない場合に使用される値     */\n        nil = std::numeric_limits<index_t>::min() / 3,   /**< @brief 先行点が存在しない場合に使用される値 */\n    };\n}\n\n\n\n//********************************************************************************\n// 型シノニムその2\n//********************************************************************************\n\nusing edges_t    = std::vector<edge>;      /**< グラフG=(V, E)の辺集合E   */\nusing vertices_t = std::vector<vertex>;    /**< グラフG=(V, E)の頂点集合V */\nusing array_t    = std::vector<weight_t>;  /**< 重みwの配列  */\nusing indices_t  = std::vector<index_t>;   /**< 頂点の添字配列 */\nusing stamps_t   = std::vector<bool_t>;    /**< ブーリアンの集合 */\nusing matrix_t   = std::vector<array_t>;   /**< グラフGの隣接行列表現(および表行列表現) */\nusing graph_t    = std::vector<edges_t>;   /**< グラフGの隣接リスト表現(こちらを主に使用する) */\n\n\n\n//********************************************************************************\n// 型シノニムその3\n//********************************************************************************\n\nusing vset_t = std::int64_t;  // 頂点集合のビット表現\n\n\n\n//********************************************************************************\n// 関数の定義\n//********************************************************************************\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param vset_t  S    最小重みが決定された頂点集合S(ビット表現)\n * @param index_t u    現在探索している頂点u\n * @param const matrix_t& W  隣接行列W\n * @param matrix_t& D  uにいる状態から残りすべての頂点を辿って始点s(=0)に戻る閉路の重みの総和の最小値をD[S][u]に格納した行列D\n */\nweight_t lookup_tsp(vset_t S, index_t u, const matrix_t& W, matrix_t& D)\n{\n    // 訪問済みなら返ります\n    if (D[S][u] >= 0) { return D[S][u]; }\n\n    // すべての頂点を訪れて戻ってきた\n    index_t n = W.size();\n    if ((S == ((1 << n) - 1)) && u == 0) { return D[S][u] = 0; }\n\n    weight_t d = limits::inf;  // uにいる状態から残りすべての頂点を辿って始点に戻る閉路の重みの総和の最小値をdとする\n    \n    for (index_t v = 0; v < n; v++) {       // 次の状態vを探索\n        if ((S >> v) & 0x01) { continue; }  // 訪問済みならcontinue\n        d = std::min(d, (lookup_tsp((S | (1 << v)), v, W, D) + W[u][v]));  // dの更新\n    }\n    return D[S][u] = d;\n}\n\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param  index_t s    始点s\n * @param  const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t memoized_tsp(index_t s, const matrix_t& W)\n{\n    std::size_t n = W.size();            // n = W.rows\n    matrix_t D(1 << n, array_t(n, -1));  // Dを2^n x n型の新しい行列とする\n\n    return lookup_tsp(0, s, W, D);\n}\n\n\n/**\n * @brief トップダウン方式の動的計画法により巡回セールスマン問題に厳密解を与える\n *\n * @param index_t s  始点s\n * @param const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t top_down_tsp(const matrix_t& W)\n{\n    index_t n = W.size();                         // n = W.rows\n    matrix_t D(1 << n, array_t(n, limits::inf));  // Dを2^n x n型の新しい行列とする\n\n    D[(1 << n) - 1][0] = 0;  // 始点s(=0)の初期化\n\n    for (vset_t S = (1 << n) - 2; S >= 0; S--) {\n        \n        for (index_t u = 0; u < n; u++) {\n            \n            for (index_t v = 0; v < n; v++) {    \n                if ((S >> v) & 0x01) { continue; }  // 訪問済みならば、continue\n                D[S][v] = std::min(D[S][v], D[(S | (1 << v))][u] + W[u][v]);  // Dの更新\n            }\n        }\n    }\n    return D[0][0];\n}\n\n\n\n//********************************************************************************\n// 名前空間の終端\n//********************************************************************************\n\nGRAPH_END\n\n\n\n//********************************************************************************\n// エントリポイント\n//********************************************************************************\n\nint main()\n{\n    using namespace std;\n\n    using namespace graph;\n\n    index_t V, E;\n    cin >> V >> E;\n\n    matrix_t W(V, array_t(V, limits::inf));\n    for (index_t i = 0; i < V; i++) { W[i][i] = 0; }\n\n    index_t s, t;\n    weight_t d;\n    for (index_t i = 0; i < E; i++) {\n        cin >> s >> t >> d;\n        W[s][t] = d;\n    }\n\n    d = top_down_tsp(W);\n    if (d >= limits::inf) { cout << -1 << endl; }\n    else { cout << d << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n#define p pair<ll,ll>\nconst ll MAX_N = 16;\nconst ll MAX_V = 1<<MAX_N; // 2^MAX_N (subsets of S)\nconst ll INF = (ll)1e18;\nvector<vector<p> > g(MAX_N);\nll dp[MAX_N][MAX_V];\nll n, m;\n\nll solve(ll v, unsigned int S) {\n    if (!(S&(1<<v))) return INF;\n    if (dp[v][S]) return dp[v][S];\n    if (v == 0 && S == 1) return 0;\n    ll res = INF;\n    for (p tp : g[v]) {\n        ll u = tp.first, w = tp.second;\n        //printf(\"exploring edge: (%lld, %lld)\\n\", v, u);\n        res = min(res, w+solve(u, S^(1<<v))); // v\\in S\n    }\n    //printf(\"%lld %u: %lld\\n\", v, S, res);\n    return dp[v][S] = res;\n}\n\n// n^2*2^n time, n*2^n space\nint main() {\n    cin >> n >> m;\n    if (n > 25) {\n        // 20 billion cycles > 20s\n        cout << \"This gonna take too long, lol\\n\";\n        return 0;\n    }\n    else if (n == 0) {\n        cout << \"Don't be silly\\n\";\n        return 0;\n    }\n    ll u, v, w, i;\n    for (i = 0; i < m; i++) {\n        cin >> u >> v >> w;\n        g[u].push_back(p(v,w));\n        //g[v].push_back(p(u,w));\n    }\n    ll res = INF;\n    unsigned int S = (1<<n)-1;\n    for (p tp : g[0]) {\n        ll v = tp.first, w = tp.second;\n        res = min(res, w+solve(v, S));\n    }\n    if (res == INF) cout << \"-1\\n\";\n    else cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (Max == -1 || sum < Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s = 0, int d = 0, Weight w = 0)\n    : src(s), dst(d), weight(w) {\n  }\n};\n\nusing Edges  = vector<Edge>;\nusing Graph  = vector<Edges>;\nusing Array  = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  g[a].emplace_back(a, b, w);\n}\n\nvoid addEdge(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  addArc(g, a, b, w);\n  addArc(g, b, a, w);\n}\n\nvoid solve() {\n  int v, e;\n  cin >> v >> e;\n  Graph g(v);\n  while (e--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    addArc(g, s, t, d);\n  }\n  vvi dp(1 << v, vi(v, INF));\n  dp[0][0] = 0;\n  rep(s, 1 << v) {\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (~s >> e.dst & 1) cmin(dp[s | 1 << e.dst][e.dst], dp[s][e.src] + e.weight);\n      }\n    }\n  }\n  int x = dp.back()[0];\n  cout << (x == INF ? -1 : x) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename TYPE>\nvoid print_vec(const vector<TYPE>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\ntemplate <typename TYPE>\nvoid print_vec2(const vector<vector<TYPE>>& v){\n  cout << endl; cout << \"       \";\n  for(int i=0; i<v[0].size(); i++) cout << i << \"   \"; \n  cout << endl;\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << \"i=\" << i << \":   \";\n\t\tfor(int j=0; j<v[i].size(); j++){\n\t\t\tif(v[i][j] == 0) cout << \"\\x1B[0m\" << v[i][j] << \"   \";\n      else cout << \"\\x1B[31m\" << v[i][j] << \"   \";//https://stackoverrun.com/ja/q/12618775\n\t\t}\n\t\tcout << \"\\x1B[0m\" << endl;\n\t}\n}\n\n\nll chmin(ll &a, ll b){ return a = min(a, b); }\nint main(){\n\tint V;\n\tll E;\n\tcin >> V >> E;\n\ttypedef pair<int ,ll> P;\n\tvector<vector<P>> vec(V, vector<P>());//vec[i][j].first: 頂点iと繋がる頂点j, second: iとjを結ぶ辺の長さ\n\tconst ll INF = 1001001001001001;\n\tvector<vector<ll>> dist(V, vector<ll>(V, INF));\n\tfor(ll i=0; i<E; i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\t//int bin = 1<<t;//tを2進表記する\n\t\tvec[s].emplace_back(t, d);\n\t\tdist[s][t] = d;\n\t}\n\t\n\t// dp[state][town]: 現在頂点townにいて，状態stateになりうる最小コスト\n\tvector<vector<ll>> dp_((1<<V), vector<ll>(V, INF));\n\t\n\tll ans = INF;\n\tfor(int begin=0; begin<V; begin++){\n\t\tvector<vector<ll>> dp = dp_;\n\t\tdp[1<<begin][begin] = 0;\n\t\tfor(int s=0; s<(1<<V); s++){\n\t\t\tfor(int town=0; town<V; town++){\n\t\t\t\t//cout << \" begin: \" << begin << \" s: \" << s << \" town: \" << town << endl;\n\t\t\t\tif(dp[s][town] == INF) continue;\n\t\t\t\tfor(int k=0; k<vec[town].size(); k++){\n\t\t\t\t\tint n_town = vec[town][k].first;\n\t\t\t\t\tif((s>>n_town) % 2 == 1) continue; //すでに訪れている場合はcontinue\n\t\t\t\t\tint n_s = s | (1 << n_town);\n\t\t\t\t\tint cost = dp[s][town] + vec[town][k].second;\t\n\t\t\t\t\tchmin(dp[n_s][n_town], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<V; i++){\n\t\t\tchmin(ans, dp[(1<<V)-1][i] + dist[i][begin]);\n\t\t}\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o << \" \" << o << endl; }\n#define dumpc(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//dx[i],dy[i]???i?????????????§???????????????¢???\n//  3\n// 2 0\n//  1\n\n//??\\?????¨?????°\nint X, Y;\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\t/* ?????? */\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tconst int MAX = 1; //????????´???\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\t//???????????¢\n\tint d[MAX][MAX];\n\tmemset(d, 0x3f, sizeof(d));\n\td[sx][sy] = 0;\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (u == pii(gx, gy))break; //??´??????????????¢?´¢????????????\n\t\tfor (int i = 0; i < 4; i++) {//?§????4???????????¢?´¢\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\t\tif (d[nx][ny] != INF)continue; //??¢?´¢???????£???°???\n\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[gx][gy];\n}\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INFG); //distance\n\tdist[s] = 0; PQ.push(State(0, s, -1)); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.push(State(dist[e.d], e.d, v));\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Bellman Ford O(|V||E|)\n//dist: ?§????????????????????????§??????????????¢\n//prev: ???????????¨????????????\n//?????????: ???????????????:true ??????:false\nbool bellmanFord(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n\tint n = g.size();\n\tEdges es; for (int i = 0; i < n; i++) for (auto &e : g[i]) es.emplace_back(e);\n\tdist.assign(n, INFG); dist[s] = 0;\n\tprev.assign(n, -1);\n\tbool negative_cycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\tfor (auto &e : es) {\n\t\t\tif (dist[e.s] != INFG && dist[e.d] > dist[e.s] + e.w) {\n\t\t\t\tdist[e.d] = dist[e.s] + e.w;\n\t\t\t\tprev[e.d] = e.s;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif (!update) break;\n\t\tif (i > n) { negative_cycle = true; break; }\n\t}\n\treturn !negative_cycle;\n}\n\n//?§?????????????????????§??????????????????\n//???????????????????????°?????????????§??????????????????§?????????????????¢????????????\nvector<int> getPath(int s, int g, vector<int> prev) {\n\tvector<int> path;\n\tpath.push_back(g);\n\tfor (int i = g; i != s; ) path.push_back(i = prev[i]);\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n\n//??¨????????????????????? All Pairs Shortest Path\n//Warshall Floyd O(|V|^3)\n//?????????: ???????????????:true ??????:false\nbool warshallFloyd(const Graph &g, Matrix &dist) {\n\tbool negative_cycle = false;\n\tint n = g.size();\n\tdist.assign(n, Array(n, INFG));\n\tfor (int i = 0; i < n; i++) dist[i][i] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto e : g[i])\n\t\t\tdist[e.s][e.d] = min(dist[e.s][e.d], e.w);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (dist[j][i] != INFG&&dist[i][k] != INFG)\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i][i] != 0)\n\t\t\tnegative_cycle = true;\n\treturn !negative_cycle;\n}\n\n//???????????????\nvoid printPath(vector<int> path) {\n\tcout << \"Path: \";\n\tfor (auto p : path) cout << p << \" \";\n\tcout << endl;\n}\n\n//???????????????????????????\n//??\\?¬???°???0????????¨???????????????????????????ret????????£??????\nvector<int> topologicalSort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), indeg(n); //??\\?¬???°\n\tfor (auto &es : g) for (auto &e : es) indeg[e.d]++;\n\tqueue<int> Q;\n\tfor (int i = 0; i < n; i++) if (indeg[i] == 0) Q.push(i);\n\twhile (!Q.empty()) {\n\t\tint v = Q.front(); Q.pop(); ord[k++] = v;\n\t\tfor (auto &e : g[v]) if (--indeg[e.d] == 0) Q.push(e.d);\n\t}\n\treturn *max_element(indeg.begin(), indeg.end()) == 0 ? ord : vector<int>();\n}\n\n//??¨?????´???\nEdge diameter(const Graph &g, int s = 0) {\n\tvector<Weight> dist;\n\tdijkstra(g, s, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (u == -1 || dist[i] > dist[u])) u = i;\n\tdijkstra(g, u, dist);\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (v == -1 || dist[i] > dist[v])) v = i;\n\tWeight d = dist[v];\n\tif (u > v) swap(u, v);\n\treturn Edge(u, v, d);\n}\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tGraph g(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, d; scanf(\"%d%d%d\", &s, &t, &d);\n\t\tg[s].push_back(Edge(s, t, d));\n\t}\n\n\tstatic ll dp[1 << 15][15]; //??¶??? ?¬??????????\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0][0] = 0;\n\tint bend = 1 << V;\n\tfor (int i = 0; i < bend; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tif (dp[i][j] == INFG)continue;\n\t\t\tfor (auto &e : g[j]) {\n\t\t\t\tif (i&(1 << e.d))continue; //?¨??????????????£???°???\n\t\t\t\tdp[i | (1 << e.d)][e.d] = min(dp[i | (1 << e.d)][e.d], dp[i][j] + e.w);\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[bend - 1][0] == INFG) cout << -1 << endl;\n\telse cout << dp[bend - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOOP(n) for (int _i = 0; _i < (n); _i++)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define RREP(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, r, n) for (int i = (r); i < (n); ++i)\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\nusing ll = long long;\nconst int INF = 1000100100;\n \ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n \nint V, E;\nint G[20][20];  // グラフ\nint dp[50000][20];\n// メモ化再帰\nint rec(int S, int v) {  \n    if (S == 0) {\n        if (v == 0) {\n            return 0;\n        } else {\n            return INF;\n        }\n    }\n    if ((S & (1 << v)) == 0) {  // Sに{v}が含まれていない\n        return INF;\n    }\n \n    int &ret = dp[S][v];\n    if (ret != 0) return ret;\n \n    ret = INF;\n    REP(u, V) { chmin(ret, rec(S ^ (1 << v), u) + G[u][v]); }\n    return ret;\n}\n \nint main() {\n    cin >> V >> E;\n \n    // グラフの初期化\n    REP(i, 20) {\n        REP(j, 20) { G[i][j] = INF; }\n    }\n    REP(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n \n    int ans = rec((1 << V) - 1, 0);\n \n    if (ans != INF) {\n        cout << ans << endl;\n    } else {\n        cout << -1 << endl;\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define INF 0x1fffffff\n#define MAX_V 15\n\nint main(void){\n  int v, e, st[MAX_V][MAX_V], i, j, k, l, d[MAX_V][MAX_V][1 << MAX_V]/*スタート地点,今いる地点,通過した編の情報(bit)*/, ans = INF;\n  scanf(\"%d%d\",&v,&e);\n  memset(st,-1,sizeof(st));\n  for(i = 0;i < e;i++){\n    int s, t, dt;\n    scanf(\"%d%d%d\",&s,&t,&dt);\n    st[s][t] = dt;\n  }\n  for(i = 0;i < v;i++){\n    for(j = 0;j < v;j++){\n      for(k = 0;k < 1 << v;k++){\n\td[i][j][k] = INF;\n      }\n    }\n  }\n  for(i = 0;i < v;i++){ // スタート地点\n    d[i][i][1 << i] = 0;\n    while(1){\n      int flag = 1;\n      for(j = 0;j < v;j++){ // 今いる地点\n\tfor(k = 0;k < 1 << v;k++){ // 通過辺の情報\n\t  for(l = 0;l < v;l++){ // 行き先\n\t    if(st[j][l] != -1 && d[i][l][k | (1 << l)] > d[i][j][k] + st[j][l]){\n\t      flag = 0;\n\t      d[i][l][k | (1 << l)] = d[i][j][k] + st[j][l];\n\t      \n\t    }\n\t  }\n\t}      \n    \n      }\n      if(flag){\n\tbreak;\n      }\n    }\n\n  }\n  for(i = 0;i < v;i++){\n    if(d[i][i][(1 << v) - 1] < ans){\n      ans = d[i][i][(1 << v) - 1];\n    }\n  }\n  if(ans == INF){\n    ans = -1;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing vpll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nll N, E;\nll dist[15][15];\nll dp[1<<15][15];\n\nll rec(ll s, ll v) {\n    if (dp[s][v] != -1) return dp[s][v];\n    if (s == (1<<N)-1 && v == 0) return dp[s][v];\n\n    ll res = INF;\n    rep(u, N) {\n        if (!(s>>u&1) && dist[v][u] != -1) chmin(res, rec(s | 1<<u , u) + dist[v][u]);\n    }\n    return dp[s][v] = res;\n}\n\nint main() {\n    memset(dist, -1, sizeof(dist));\n    memset(dp, -1, sizeof(dp));\n\n    cin >> N >> E;\n    rep(i, E) {\n        ll s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    dp[(1<<N)-1][0] = 0;\n    ll ans = rec(0, 0);\n    if (ans >= INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<ll> > Adj_Mat;\n\n\nbool contain(int mask, int pos){\n\t  return ( mask & (1<<pos) ) != 0;\n}\n\nint main(){\n\n\t  // Input Graph\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_Mat G(V,vector<ll>(V,INT_MAX));\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t,d; cin >> s >> t >> d;\n\t\t\tG[s][t] = d;\n\t  }\n\n\t  ll ans = INT_MAX;\n\t  // Dynamic Programming for TSP\n\t  for(int st=0; st<V; st++){\n\n\t\t\tll dp[ (1<<V) ][ V ];\n\t\t\tfor(int i=0; i<(1<<V); i++) for(int j=0; j<V; j++) dp[i][j] = INT_MAX;\n\t\t\tdp[ 0 ][ st ] = 0;\n\n\t\t\tfor(int S=1; S<(1<<V); S++)\n\t\t\t\t  for(int v=0; v<V; v++)\n\t\t\t\t\t\tif( contain(S,v) )\n\t\t\t\t\t\t\t  for(int j=0; j<V; j++)\n//\t\t\t\t\t\t\t\t\tif( contain(S,j) and v!=j)\n\t\t\t\t\t\t\t\t\t\t  dp[S][v] = min(dp[S][v], dp[S-(1<<v)][j] + G[j][v]);\n\t\t\tans = min(ans,dp[ (1<<V)-1 ][st]);\n\t  }\n\t  if( ans >= 1e+9 ) ans = -1;\n\t  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int value;\n};\n\nstruct Node {\n    int value;\n    vector<Edge> edge;\n};\n\nint v, e;\nint s, t, d;\nNode node[15];\n\nint solve(int pos, int stat){\n\n    if(stat == (1 << v) - 1) return 0;\n\n    int cost = 1 << 24;\n\n    for(int i = 0; i < node[pos].edge.size(); ++i) {\n        if(!(stat & 1 << node[pos].edge[i].to)) {\n            cost = min(cost, solve(node[pos].edge[i].to, stat | 1 << node[pos].edge[i].to) + node[pos].edge[i].value);\n        }\n    }\n\n    return cost;\n\n}\n\nint main() {\n\n    cin >> v >> e;\n\n    for(int i = 0; i < e; ++i) {\n        cin >> s >> t >> d;\n        node[s].edge.push_back((Edge){t, d});\n    }\n\n    int dst = solve(0, 0);\n\n    if(dst == 1 << 24) {\n        cout << -1 << endl;\n    } else {\n        cout << dst << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(pair<int, int> a, pair<int, int> b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\n\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\nvector<vector<ll>> dist(15,vector<ll>(15,INF));\nvector<vector<vector<ll>>> dp(15,vector<vector<ll>>(15,vector<ll>((1<<16),-1)));\nll V,E;\n\n\nll rec(ll st, ll v, ll bit){\n    //cout << v<< endl;\n    if(dp[st][v][bit] != -1){\n        return dp[st][v][bit];\n    }\n\n    if(st == v && bit == (1<<V)-1){\n        //cout << \"OK\"<< endl;\n        return dp[st][v][bit] = 0;\n    }\n\n    ll res = INF;\n    rep(i,V){\n        if(i != v&& !((bit>>i)&1)){\n            chmin(res,rec(st,i,bit | (1<<i))+dist[v][i]);\n            \n        }\n    }\n    return dp[st][v][bit] = res;\n\n\n    \n}\n\nint main() {\n    cin >> V>>E;\n\n    rep(i,E){\n        ll a,b,c;\n        cin >>a>>b>>c;\n        dist[a][b] = c;\n        //dist[b][a] = c;\n    }\n\n    ll ans = INF;\n    rep(i,V){\n        chmin(ans,rec(i,i,0));\n    }\n    if(ans >= INF){\n        ans = -1;\n    }\n    cout <<ans<<endl;\n    \n    return 0;\n    \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nint dp[1<<16][20];\nint d[20][20];\nint main(){\n\tint V,E;\n\tcin>>V>>E;\n\tfor(int i =0;i <(1<<16);i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i < V;i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor(int i =0;i < E;i++){\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\td[x][y] =c;\n\t}\n\tdp[1][0]=0;\n\tfor(int i =0;i <(1<<V);i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\tif((i>>j&1)==0)continue;\n\t\t\tfor(int k =0;k < V;k++){\n\t\t\t\tif((i>>k&1)==1)continue;\n\t\t\t\tdp[i|(1<<k)][k] =min(dp[i|(1<<k)][k],dp[i][j]+d[j][k]);\n\t\t\t\t//cout <<\"dp = \"<<dp[i|(1<<k)][k]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans =INF;\n\tfor(int i =0;i <V;i++){\n\t\tans =min(ans,dp[(1<<V)-1][i]+d[i][0]);\n\t}\n\tif(ans>=INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    int es[V][V];\n    fill(es[0], es[V], inf);\n    rep(i, E){\n        int u, v, c; cin >> u >> v >> c;\n        es[u][v] = c;\n    }\n    int dp[1<<V][V];\n    fill(dp[0], dp[1<<V], inf);\n    dp[1][0] = 0;\n    rep(i, 1<<V){\n        rep(j, V){\n            rep(k, V){\n                if(i&(1<<k)) continue;\n                chmin(dp[i|(1<<k)][k], dp[i][j]+es[j][k]);\n            }\n        }\n    }\n    int ans = inf;\n    rep(i, V) chmin(ans, dp[(1<<V)-1][i]+es[i][0]);\n    cout << (ans == inf? -1 : ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\nstruct edge{\n    i64 to,dist;\n};\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n    i64 V,E;\n    cin >> V >> E;\n\n    vector<vector<edge>> graph(V);\n    rep(u,0,E){\n        i64 s,t,d;\n        cin >> s >> t >> d;\n        graph[s].emplace_back(edge{t,d});\n    }\n\n    constexpr i64 maxv=15;\n    static i64 memo[1l<<maxv][maxv];\n    static bool done[1l<<maxv][maxv];\n    fill(memo,inf64);\n    fill(done,false);\n    function<i64(i64,i64)> rec=[&](i64 b,i64 u){\n        auto& res=memo[b][u];\n        if(done[b][u]) return res;\n        done[b][u]=true;\n\n        if(b==((1l<<V)-1) and u==0) return res=0;\n\n        for(auto& e:graph[u]){\n            i64 v=e.to;\n            i64 d=e.dist;\n            if((b>>v)&1) continue;\n            chmin(res,rec(b|(1l<<v),v)+d);\n        }\n\n        return res;\n    };\n\n    i64 ans=rec(0,0);\n\n    cout << (ans==inf64?-1:ans) << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\nll dp[1 << 15][15];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<ll>> g(n, vector<ll>(n, LLINF));\n    for (int i = 0; i < m; i++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        g[a][b] = c;\n    }\n    for (int i = 0; i < (1 << 15); i++)\n    {\n        for (int j = 0; j < 15; j++)\n        {\n            dp[i][j] = LLINF;\n        }\n    }\n    dp[0][0] = 0;\n    for (int S = 1; S < (1 << n); S++)\n    {\n        for (int v = 0; v < n; v++)\n        {\n            if (S & (1 << v) == 0)\n            {\n                continue;\n            }\n            int sub = S ^ (1 << v);\n            for (int u = 0; u < n; u++)\n            {\n                chmin(dp[S][v], dp[sub][u] + g[u][v]);\n            }\n        }\n    }\n    cout << (dp[(1 << n) - 1][0] == LLINF ? -1 : dp[(1 << n) - 1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nconst int INF = (1<<29); \nusing namespace std;\nint V, d[15][15],dp[1 << 15][15];\nint rec(int S, int v) {\n\tif (dp[S][v] >= 0)return dp[S][v];\n\tif (S == (1 << V) - 1 && v == 0)return dp[S][v] = 0;\n\tint res = INF;\n\trep(u, V) {\n\t\tif (!(S >> u & 1))res = min(res, rec(S | 1 << u, u) + d[v][u]);\n\t}\n\treturn dp[S][v] = res;\n}\nint main() {\n\tint E; cin >> V >>E;\n\tmemset(d, 0x3f, sizeof(d));\n\tmemset(dp, -1, sizeof(dp));\n\trep(i, E) {\n\t\tint s, t, c; cin >> s >> t >>c;\n\t\td[s][t] = c;\n\t}\n\tint ans = rec(0, 0);\n\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst int M = 20;\nWeight best[1<<M][M];\nint    prev[1<<M][M];\nvoid buildPath(int S, int i, vector<int> &path) {\n  if (!S) return;\n  buildPath(S^(1<<i), prev[S][i], path);\n  path.push_back(i);\n}\nWeight shortestHamiltonCycle(Matrix w, vector<int> &path) {\n  int n=w.size();\n  int N = 1 << n;\n  REP(S,N) REP(i,n) best[S][i] = INF;\n  best[0][0] = 0;\n  REP(S,N) REP(j,n) REP(i,n) if (!(S&(1<<j)))\n    if (best[S|(1<<j)][j] > best[S][i] + w[i][j])\n      best[S|(1<<j)][j] = best[S][i] + w[i][j],\n      prev[S|(1<<j)][j] = i;\n  //int t = min_element(best[N-1], best[N-1]+n) - best[N-1];\n  //path.clear(); buildPath(N-1, t, path);\n  return best[N-1][0]==INF ? -1 : best[N-1][0];\n}\n\nint main(){\n\tint V,E,s,t,d;\n\tscanf(\"%d%d\",&V,&E);\n\tMatrix m(V,Array(V));\n\tfor(s=0;s<V;s++)for(t=0;t<V;t++)if(s!=t)m[s][t]=INF;\n\tvector<int>path;\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&d),m[s][t]=d;\n\tprintf(\"%d\\n\",shortestHamiltonCycle(m,path));\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\t\tusing LL = long long;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using pq = priority_queue<T>;\ntemplate<class T>using pqs = priority_queue<T, vector<T>, greater<T>>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nusing Weight = long long;\nconstexpr Weight INF = numeric_limits<Weight>::max();\nstruct Edge {\n\tint to; Weight cost;\n\tEdge() :to(-1), cost(-1) {}\n\tEdge(int _to, Weight _cost = 1) :to(_to), cost(_cost) {}\n};\nbool operator>(const Edge& e1, const Edge& e2) { return e1.cost > e2.cost; }\nstruct Edge2 {\n\tint u, v; Weight cost;\n\tEdge2() :u(-1), v(-1), cost(0) {}\n\tEdge2(int _u, int _v, Weight _cost) :u(_u), v(_v), cost(_cost) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\nusing UnWeightedGraph = vector<vector<int>>;\n\nint main() {\n\tint n = in, e = in;\n\tMatrix g(n, Array(n, inf_ll));\n\trep(i, n)g[i][i] = 0;\n\trep(i, e) {\n\t\tint s = in, t = in; LL d = in;\n\t\tchmin(g[s][t], d);\n\t}\n\n\tint size = BIT(n);\n\tVVL dp(size, VL(n, inf_ll));\n\tdp[size - 1][0] = 0;\n\trfor(S, size - 2, 0)rep(v, n)rep(u, n) {\n\t\tif (!(S >> u & 1)) {\n\t\t\tchmin(dp[S][v], dp[S | BIT(u)][u] + g[v][u]);\n\t\t}\n\t}\n\tout(dp[0][0] == inf_ll ? -1 : dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<limits>\n#include<cstdio>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define clr(a,v) memset((a),(v),sizeof(a))\n\nconst int MAX_V = 15, INF = std::numeric_limits<int>::max()>>2;\n\nint V, E;\nstd::vector<std::vector<int> > d( MAX_V, std::vector<int>( MAX_V, INF ) );\nint dp[1<<MAX_V+1][MAX_V];\n\nint sv;\n\nint rec( int S, int v )\n{\n    if( S == (1<<V)-1 && v == sv )\n        return dp[S][v] = 0;\n\n    if( ~dp[S][v] )\n        return dp[S][v];\n\n    int ret = INF;\n\n    rep( u, V ) if( !(S>>u&1) )\n        ret = std::min( ret, rec( S|1<<u, u )+d[v][u] );\n\n    return dp[S][v] = ret;\n}\n\nint main()\n{\n    scanf( \"%d%d\", &V, &E );\n    rep( i, E )\n    {\n        int s, t;\n        scanf( \"%d%d\", &s, &t );\n        scanf( \"%d\", &d[s][t] );\n    }\n\n    int ans = INF;\n    rep( v, V )\n    {\n        clr( dp, -1 );\n        sv = v;\n        ans = std::min( ans, rec( 0, v ) );\n    }\n\n    printf( \"%d\\n\", ans==INF?-1:ans );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1e9;\nconst int MAX_V = 16;\nconst int MAX_S = 1 << 16;\n\nint V,E;\nint dist[MAX_V][MAX_V];\nint dp[MAX_S][MAX_V];\n\nvoid chmin(int &a, int b){ if( a > b){ swap(a,b);} return ;}\n\nint rec(int S, int a){\n  if( dp[S][a] >= 0){ return dp[S][a];}\n  if( S == (1<<V)-1 && a == 0){ return 0;}\n  \n  int res = INF;\n  for(int u = 0; u < V; u++){\n    if( !(( S >> u) & 1)){//まだuに未到達\n      chmin(res, rec(S|(1<<u),u)+dist[a][u]);}}\n   \n  return dp[S][a] = res;\n}\n                             \n      \n    \n\nint main(){\n scanf(\"%d\",&V); scanf(\"%d\",&E);\n \n  \n  for(int i = 0; i < MAX_V; i++){\n    for(int j = 0; j < MAX_V; j++){\n      dist[i][j] = INF;}}\n  //繋がっていない状態をINFとする\n  for(int i = 0; i < MAX_S; i++){\n    for(int j = 0; j < MAX_V; j++){ \n      dp[i][j] = -1;}}\n \n  //未更新を-1とする\n  while(E--){\n    int s,t,d; cin >> s >> t >> d; dist[s][t] = d;}\n  \n  if( rec(0,0) != INF){ printf(\"%d\\n\", rec(0,0)); }\n  else{ printf(\"%d\\n\", -1) ;}return 0;}\n  \n  \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll LINF = 1e18;\nconst int INF = 1e9;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint V;\nint dist[20][20];\nint dp[(1<<20)-1][15];\nint seen[(1<<20)-1][20];\n\nint rec(int bit, int v){    \n    if(dp[bit][v]!=INF||seen[bit][v]==true)return dp[bit][v];\n    seen[bit][v]=true;\n\n    if(bit==0&&v==0)return dp[bit][v]=0;\n\n    if(!(bit&(1<<v)))return INF;\n\n    int pbit=bit&~(1<<v);\n\n    rep(u,V){\n        dp[bit][v]=min(rec(pbit,u)+dist[u][v],dp[bit][v]);\n    }\n    return dp[bit][v];\n}\n\nint main(){\n    cin>>V;\n    int E; cin>>E;\n    rep(i,V)rep(j,V)dist[i][j]=INF;\n    rep(i,E){\n        int s,t,v; cin>>s>>t>>v;\n        dist[s][t]=v;\n    }\n\n    int ans=INF;\n    rep(i,1<<V)rep(j,V){\n        dp[i][j]=INF;\n        seen[i][j]=false;\n    }\n    ans=min(ans,rec((1<<V)-1,0));\n    if(ans!=INF)cout<<ans<<endl;\n    else cout<<-1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll =long long;\ntypedef pair<int,int> P;\n#define SORT(a) sort((a).begin(),(a).end())\n#define rSORT(a) reverse((a).begin(),(a).end())\n#define For(i, a, b)    for(int i = (a) ; i < (b) ; ++i)\n#define rep(i, n)       For(i, 0, n)\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//Write From this Line\n\nint dist[15][15];\nconst int inf = 1e6;\nll dp[(1<<15)][15];\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\trep(i,v) rep(j,v) dist[i][j] = inf;\n\trep(i,v) dist[i][i] = 0;\n\trep(i,e){\n\t\t// 辺を受け取る\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdist[a][b] = c;\n\t}\n\n\trep(i,(1<<v)){\n\t\trep(j,v){\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdp[1][0] = 0; // 今いるのが0で,０のみ訪問済みのときの最小コストは0\n\tfor(int i = 0; i < (1<<v); i++){\n\t\tfor(int j = 0; j < v; j++){\n\t\t\t// 次訪問するところを全部見る\n\t\t\tif(dp[i][j] == inf) continue;\n\t\t\trep(k,v){\n\t\t\t\t// kが既に訪れた町であれば次へ\n\t\t\t\tif((i>>k)%2) continue;\n\t\t\t\t// 次の集合に、今の集合からk bit目を立てる\n\t\t\t\tint nexti = i | (1<<k);\n\t\t\t\t// 距離はdist[j][k]\n\t\t\t\tif(dist[j][k] == inf) continue;\n\t\t\t\tll nextd = dp[i][j] + dist[j][k];\n\t\t\t\tdp[nexti][k] = min(dp[nexti][k], nextd);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e9;\n\tFor(i,1,v){\n\t\tchmin(ans, dp[(1<<v)-1][i] + dist[i][0]);\n\t}\n\tif(ans >= inf){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\nusing namespace std;\nconst int INF=INT_MAX/2;\n\nstruct edge { int to, weight;};\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nint  DP[1 << 15][15];\n\nint rec(int S, int v, int V, Graph &G){\n\tif(DP[S][v]>=0){\n\t\treturn DP[S][v];\n\t}\n\tif (S==(1 << V)-1 && v==0) \n\t{\n\t\treturn DP[S][v]=0;\n\t}\n\n\tint r = INF;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge f = G[v][i];\n\t\tif((S >> f.to)%2==0){\n\t\t\tr=min(r,rec((S | (1 << f.to)) ,f.to,V,G)+f.weight);\n\t\t}\n\t}\n\treturn DP[S][v]=r;\n}\n\nint main(){\n\tint V,E,d,s;\n\tedge e;\n\tcin >> V >> E ;\n\n\tGraph G(V);\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> e.to >> e.weight;\n\t\tG[s].push_back(e);\n\t}\n\n\tmemset(DP,-1,sizeof(DP));\n\tcout << rec(0,0,V,G) <<endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\nint memo[100000] = {};\nvector<vector<pair<int,int> > > graph;\n\nint first;\nint dp(int n,int c,int bit){\n  if(memo[bit] != 0){\n    return memo[bit];\n  }\n\n  if(c == v-1){\n    for(int i = 0;i < graph[n].size();i++){\n      if(graph[n][i].first == first){\n        return memo[bit] = graph[n][i].second;\n      }\n    }\n    return 1000000;\n  }\n\n  if(graph[n].size() == 0){\n    return memo[bit] = 1000000;\n  }\n\n\n  int a = 20000;\n\n  for(int i = 0;i < graph[n].size();i++){\n    if((bit & (1 << graph[n][i].first)) == 0){\n      a = min(a,dp(graph[n][i].first,c+1,(bit | (1 << graph[n][i].first)))+graph[n][i].second);\n    }\n  }\n\n  return memo[bit] = a;\n}\n\n\n\nint main(){\n  cin >> v >> e;\n  graph.resize(v);\n  for(int i = 0;i < e;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    pair<int,int> p = make_pair(t,d);\n    graph[s].push_back(p);\n  }\n\n  int ans = 20000;\n  for(int i = 0;i < v;i++){\n    first = i;\n    ans = min(ans,dp(i,0,(1 << i)));\n  }\n\n  if(ans >= 20000){\n    cout << -1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp*/\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nconst int INF = 1001001;\n\n\nint next_combination(int sub) {\n    int x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\n\n\nint main(){\n    int v,e;\n    cin >> v >> e;\n    int edge[v][v];\n    int dp[1<<v][v];\n    rep(i,v) rep(j,v) edge[i][j]=INF;\n    rep(i,1<<v) rep(j,v) dp[i][j] = INF;\n    \n    rep(i,e){\n        int s,t,d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n\n    for(int i=1;i<v;++i){\n        dp[1<<i][i] = edge[0][i];\n    }\n\n\n    for(int k=2;k<=(v-1);++k){\n        int bit = (1<<k)-1;\n        for(;bit < (1<<(v-1)); bit = next_combination(bit)){\n            int net_bit = 2*bit; \n            for(int i=1; i<v; ++i){\n                for(int j=1;j<v;++j){\n                    if(i==j) continue;\n                    if((net_bit>>i&1)&&(net_bit>>j&1)){\n                    dp[net_bit][i]=min(dp[net_bit][i],dp[net_bit&~(1<<i)][j]+edge[j][i]);\n                    }\n                }\n            }\n        }\n    }\n\n    for(int i=1; i<v;++i){\n        dp[(1<<v)-1][0] = min(dp[(1<<v)-1][0],dp[(1<<v)-2][i]+edge[i][0]);\n    }\n\n    if(dp[(1<<v)-1][0]<INF) cout << dp[(1<<v)-1][0] << endl;\n    else cout << -1 << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nlong long INF = 10000000;\nlong long dp[1<<15][15];\nlong long dist[15][15];\n\nlong long rec(long long p, long long s, long long t, long long V){\n    if(dp[p][t] >= 0){\n        return dp[p][t];\n    }\n    if(p == (1<<t)){\n        return dp[p][t] = dist[s][t];\n    }\n    long long i, val = INF;\n    for(i = 0; i < V; i++){\n        if(!((p^(1<<t)) & (1<<i))){\n            continue;\n        }\n        val = min(val,rec(p^(1<<t),s,i,V)+dist[i][t]);\n    }\n    return dp[p][t] = val;\n}\n\nint main(){\n    //input\n    long long i,j,k;\n    for(i = 0; i < 15; i++){\n        for(j = 0; j < 15; j++){\n            dist[i][j] = INF;\n        }\n    }\n    long long V, E;\n    cin >> V >> E;\n    long long s,t,d;\n    for(i = 0; i < E; i++){\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    //calc\n    long long ans = INF;\n    for(i = 0; i < V; i++){\n        for(j = 0; j < (1<<15); j++){\n            for(k = 0; k < 15; k++){\n                dp[j][k] = -1;\n            }\n        }\n        ans = min(ans,rec((1<<V)-1,i,i,V));\n    }\n\n    //answer\n    if(ans < INF){\n        cout << ans << endl;\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e3;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n   V<V<int>> A(n, V<int>(n, INF));\n   REP(i, m) {\n      int s, t, d; cin >> s >> t >> d;\n      A[s][t] = d;\n   }\n\n   V<V<V<int>>> dp(n, V<V<int>>(1<<n, V<int>(n, INF)));\n   REP(k, n) {\n      dp[k][0][k] = 0;\n      REP(s, 1<<n) {\n         REP(i, n) {\n            REP(j, n) if (!(s >> j & 1)) {\n               chmin(dp[k][s | 1<<j][j], dp[k][s][i] + A[i][j]);\n            }\n         }\n      }\n   }\n   int ans = INF;\n   REP(k, n) {\n      chmin(ans, dp[k][(1<<n)-1][k]);\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <vector>\n//#include <algorithm>\n\nusing namespace std;\n\n//vector < vector < int > > rebra;\n\nint getbit(int mask, int num)\n{\n    return (mask >> num) &1;\n}\n\nint main()\n{\n    int n, m, a, b, c, l = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        l *= 2;\n    l--;\n    int rebra[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            rebra[i][j] = -1;\n    for (int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            rebra[a][b] = c;\n        }\n    long long dp[l+1][n];\n    for (int i = 0; i <= l; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = -1;\n    dp[1][0] = 0;\n    long long f = 1;\n    for (long long mask = 1; mask <= l; mask++)\n        for (int j = 0; j < n; j++)\n            if ((getbit(mask, j) == 1) && (dp[mask][j] != -1))\n                for (int q = 0; q < n; q++)\n                    if ((rebra[j][q] != -1) && (getbit(mask, q) == 0)){\n                        f = 1;\n                        for (int y = 0; y < q; y++)\n                            f *= 2;\n                        f += mask;\n                        if ((dp[f][q] == -1) || (dp[mask][j] + rebra[j][q] < dp[f][q])){\n                            dp[f][q] = dp[mask][j] + rebra[j][q];\n                            f = 0;\n                            }\n\n                    }\n    int mm = -1;\n    for (int i = 1; i < n; i++)\n        if ((dp[l][i] != -1) && (rebra[i][0] != -1))\n            if (mm == -1){\n                mm = dp[l][i] + rebra[i][0];\n            } else {\n                if ((mm == -1) || (dp[l][i] + rebra[i][0] < mm))\n                    mm = dp[l][i] + rebra[i][0];\n            }\n    /*for (int i = 0; i < n; i++){\n        for (int j = 1; j <= l; j++)\n            cout << dp[j][i] << ' ';\n        cout << endl;\n    }*/\n    if (mm == -1)\n        cout << \"-1\";\n    else\n        cout << mm;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstatic const int INF = 1 << 20;\n\nint main(){\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int> > adj(V, vector<int>(V, INF));\n\tfor(int i = 0; i < E; i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tadj[s][t] = min(adj[s][t], d);\n\t}\n\tvector<vector<int> > memo(1 << V, vector<int>(V, INF));\n\tint res = INF;\n\tfor(int i = 1; i < (1 << V); i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i == 1){\n\t\t\t\tif(j == 0) memo[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!(i & (1 << j))) continue;\n\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\tif(k == j) continue;\n\t\t\t\tif(!(i & (1 << k))) continue;\n\t\t\t\tmemo[i][j] = min(memo[i][j], memo[i - (1 << j)][k] + adj[k][j]);\n\t\t\t}\n\t\t\tif(i == (1 << V) - 1){\n\t\t\t\tif(adj[j][0] == INF) continue;\n\t\t\t\tres = min(res, memo[i][j] + adj[j][0]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (res == INF ? -1 : res) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n\n#define int long long\n#define dotimes(i, n) for (int i : range(n))\n\nusing namespace std;\n\nclass range {\n  class iterator {\n    int i, s;\n  public:\n    iterator(int i, int s): i(i), s(s) {}\n    int& operator*() {\n      return i;\n    }\n    void operator++() {\n      i += s;\n    }\n    bool operator!=(iterator const& that) {\n      return i < that.i;\n    }\n  };\n  iterator b, e;\npublic:\n  range(int e): b({0, 1}), e({e, 1}) {}\n  range(int b, int e): b({b, 1}), e({e, 1}) {}\n  range(int b, int e, int s): b({b, s}), e({e, s}) {}\n  iterator begin() {\n    return b;\n  }\n  iterator end() {\n    return e;\n  }\n};\n\nint rint() {\n  int n;\n  scanf(\"%lld\", &n);\n  return n;\n}\n\nvoid wint(int n) {\n  printf(\"%lld\\n\", n);\n}\n\ntemplate<typename T>\ninline int size(T container) {\n  return static_cast<int>(container.size());\n}\n\ntemplate<typename T>\ninline bool maxs(T& a, T const& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline bool mins(T& a, T const& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main() {\n  int n = rint();\n  int m = rint();\n  const int inf = 1 << 29;\n  vector<vector<pair<int, int>>> edges(n), coedges(n);\n  dotimes(i, m) {\n    int s = rint();\n    int t = rint();\n    int d = rint();\n    edges[s].emplace_back(t, d);\n    coedges[t].emplace_back(s, d);\n  }\n  int r = inf;\n  dotimes(u, n) {\n    vector<vector<int>> dp(1 << n, vector<int>(n, -1));\n    dotimes(t, n)\n      if (t != u)\n        dp[0][t] = inf;\n    for (auto p : edges[u]) {\n      int t = p.first, d = p.second;\n      dp[0][t] = d;\n    }\n    function<int(int, int)> rec;\n    rec =\n      [&](int S, int t) {\n        if (dp[S][t] >= 0)\n          return dp[S][t];\n        dp[S][t] = inf;\n        for (auto p : coedges[t]) {\n          int s = p.first, d = p.second;\n          if (s != u && S & (1 << s))\n            mins(dp[S][t], rec(S ^ (1 << s), s) + d);\n        }\n        return dp[S][t];\n      };\n    for (auto p : coedges[u]) {\n      int t = p.first, d = p.second;\n      mins(r, rec(((1 << n) - 1) ^ (1 << t) ^ (1 << u), t) + d);\n    }\n  }\n  wint(r == inf ? -1 : r);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst double PI = acos(-1.0);\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nint dp[100000][20];\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    vector<vector<int>> dist(N, vector<int>(N,1e9));\n    rep(i,M) {\n        int u,v,d; cin >> u >> v >> d;\n        dist[u][v] = d;\n    }\n\n    int ans = 1e9;\n    rep(i,N) {\n        rep(mask,1<<N) rep(j,N) dp[mask][j] = 1e9;\n        dp[1<<i][i] = 0;\n        rep(mask,1<<N) {\n            bitset<15> s(mask);\n            rep(j,N) {\n                if (dp[mask][j]==1e9) continue;\n                rep(k,N) {\n                    if (s.test(k)) continue;\n                    if (dist[j][k]==1e9) continue;\n                    chmin(dp[mask|(1<<k)][k],dp[mask][j] + dist[j][k]);\n                }\n            }\n        }\n        rep(j,N) {\n            chmin(ans,dp[(1<<N)-1][j]+dist[j][i]);\n        }\n    }\n\n    cout << (ans == 1e9 ? -1 : ans) << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <ctime>\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXISTch(s,c) ((((s).find_first_of(c)) != std::string::npos)? 1 : 0)//cがあれば1 if(1)\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define loop(n) FOR(i,0,n)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = (int)1000000007;\nconst LL MOD = (LL)1000000007;//10^9+7\nconst LL INF2 = (LL)100000000000000000;//10^18\n\nint main() {\n\tint V, E; cin >> V >> E;\n\n\tvector<vector<int>> adj(V, vector<int>(V));\n\n\tfor (int e = 0; e < E; e++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\n\t\tadj[s][t] = d;\n\t}\n\t\t\t\n\t\n\t//dp[既に訪れた部分集合][最後に訪れた頂点]のときの最短距離\n\t//dp[S][v]\n\tvector<vector<int>> dp(1 << V, vector<int>(V));\n\t\n\t//dp初期化\n\tfor (int i = 0; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\t//頂点0から出発。\n\t//部分集合としては0…0001\n\t//最後に訪れたのは頂点0で頂点0からの距離は0\n\tdp[1][0] = 0;\n\n\tfor (int s = 0; s < (1 << V); s++) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (dp[s][v] == INF)continue;\n\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (s >> k & 1)continue;\n\t\t\t\tint nexts = s | (1<<k);\n\n\t\t\t\tif (adj[v][k] != 0) {\n\t\t\t\t\tdp[nexts][k] = min(dp[nexts][k], dp[s][v] + adj[v][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tint all = (1 << V) - 1;\n\tint ans = INF;\n\tfor (int v = 0; v < V; v++) {\n\t\tif (dp[all][v] == INF)continue;\n\t\tif (adj[v][0] == 0)continue;\n\n\t\tans = min(ans, dp[all][v] + adj[v][0]);\n\t}\n\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\nll n,e;\nvvl(d,20,20,inf);\nll dp[1 << 15][20];\n\nll rec(ll s, ll v){\n  //?????????????????????????????§?????????????????????\n  if(dp[s][v] >= 0){\n    return dp[s][v];\n  }\n  //??????????????????????¨?????????????\n  if(s == (1 << n) - 1 && v == 0){\n    return dp[s][v] = 0;\n  }\n  ll res = inf;\n  rep(u,n){\n    //???????§???????????????????????????????????????????\n    if( !(s >> u & 1) && d[v][u] != 0){\n      res = min(res,rec(s | 1 << u, u) + d[v][u]);\n    }\n  }\n  return dp[s][v] = res;\n}\n\nvoid solve(){\n  memset(dp,-1,sizeof(dp));\n  ll ans = rec(0,0);\n  if(ans == inf) ans = -1;\n  cout << ans<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> e;\n  ll s,t,dis;\n  rep(i,e){\n    cin >> s >> t >> dis;\n    d[s][t] = dis;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 100000;\nconst int NUM = 16;\nclock_t START, END;\nint G[NUM][NUM], dist[NUM][1 << 16];\nint V;\n\nint TSP(int k, int set) {\n\tif (set == 0)\n\t\treturn dist[k][set] = G[k][0];\n\tif (dist[k][set] != -1)\n\t\treturn dist[k][set];\n\tint i = 0, t, _min = INF;\n\twhile (i < V - 1) {\n\t\tt = set & 1 << i;\n\t\tif (t) {\n\t\t\t_min = min(_min, G[k][i + 1] + TSP(i + 1, set & (~(1 << i))));\n\t\t}\n\t\ti++;\n\t}\n\treturn dist[k][set] = _min;\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t};\n\tint E, s, t, d;\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; i++)\n\t\tfor (int j = 0; j < V; j++)\n\t\t\tG[i][j] = -1;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tif (G[i][j] == -1)\n\t\t\t\tG[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < V; i++)\n\t\tfor (int j = 0; j < 1 << V; j++)\n\t\t\tdist[i][j] = -1;\n\tint ans = TSP(0, (1 << V - 1) - 1);\n\tif (ans == 100000)\n\t\tcout << \"-1\" << endl;\n\telse\n\t\tcout << ans << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \n#define MAX_V (15)\n#define INF   (1<<29)\n \nint V;\nint cost[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\n \nint main() {\n   \n  cin >> V;\n   \n  for(int i = 0; i < V; i++)\n    for(int j = 0; j < V; j++)\n      cost[i][j] = INF;\n   \n  int m;\n   \n   \n  cin >> m;\n  for(int i = 0; i < m; i++) {\n    int s, t, c;\n    cin >> s >> t >> c;\n    cost[s][t] = c;\n  }\n \n  int SMAX = 1<<V;\n   \n  for(int i = 0; i < SMAX; i++)\n    for(int j = 0; j < V; j++)\n      dp[i][j] = INF;\n   \n  dp[SMAX-1][0] = 0;\n  for(int S = SMAX-2; S >= 0; S--)\n    for(int i = 0; i < V; i++)\n      for(int j = 0; j < V; j++)\n    if(!(S >> j & 1))\n      dp[S][i] = min(dp[S][i], dp[S|(1 << j)][j] + cost[i][j]);\n     \n  cout << ( dp[0][0] == INF ? -1 : dp[0][0] ) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1 || dis[s][i] == -1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (!dis[s][t])\n\t\t\t{\n\t\t\t\tdis[s][t] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n#include <limits.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INF = INT_MAX / 2;\n\nint solve(const int bits, const int current, const int start,\n        vector<vector<int> > &dp, const vector<vector<int> > &adj, const int V, const int E) {\n    // cout << \"bits, current, start: \" << bits << \",\" << current << \",\" << start << endl;\n    if (bits == (1 << V) - 1) {\n        if (current == start) {\n            // cout << \"dp[\" << bits << \"][\" << current << \"] = \" << 0 << endl;\n            return 0;\n        } else {\n            // cout << \"dp[\" << bits << \"][\" << current << \"] = \" << INF << endl;\n            return INF;\n        }\n    }\n\n    if (dp[bits][current] != -1) {\n        return dp[bits][current];\n    }\n\n    int min = INF;\n    for (int i = 0; i < V; i++) {\n        int next_bits = bits | (1 << i);\n        if (next_bits == bits) continue;\n        chmin(min, solve(next_bits, i, start, dp, adj, V, E) + adj[current][i]);\n    }\n\n    dp[bits][current] = min;\n    // cout << \"dp[\" << bits << \"][\" << current << \"] = \" << min << endl;\n    return min;\n}\n\nint main(void) {\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int> > adj(V, vector<int>(V, INF));\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        adj[s][t] = d;\n    }\n\n    vector<vector<int> > dp(((1 << V) - 1), vector<int>(V, -1));\n\n    int answer = solve(0, 0, 0, dp, adj, V, E);\n    if (answer == INF) answer = -1;\n\n    cout << answer << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    int result[(1 << 15)][15];\n    for(int i = 0; i < (1 << (v - 1)); i++){\n        for(int j = 0; j < v - 1; j++){\n            result[i][j] = mod;\n        }\n    }\n    // ??´?????????v-1????????????????????????????????£????????????????????¨???????????????v-1????????????????????????????????¢????¶?????????????\n    for(int i = 0; i < v - 1; i++){\n            if(graph[v - 1][i] != mod) result[(1 << i)][i] = graph[v - 1][i];\n    }\n    // ??????????????????v-1??????????????????????????§?¨????\n    for(int i = 1; i < (1 << (v - 1)); i++){\n        for(int j = 0; j < v - 1; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v - 1; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(((1 << k) & tmp) == 0 || result[tmp][k] == mod || graph[k][j] == mod) continue;\n                result[i][j] = min(result[i][j], result[tmp][k] + graph[k][j]);\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    // v-1???????????????v-1??????????????????????¶?????????¨\n    for(int i = 0; i < v - 1; i++){\n        if(result[(1 << (v - 1)) - 1][i] == mod || graph[i][v - 1] == mod) continue;\n        ans = min(ans, result[(1 << (v - 1)) - 1][i] + graph[i][v - 1]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint glaf[15][15];\nint V,E;\n\nint salesman(int count,int cost, int s,bool check[]){\n  int ans = -1;\n  if(count != 0) check[s] = true;\n  for(int i=0;i<V;i++){\n    if(!check[i]) break;\n    else if(i==V-1) return cost;\n  }\n  for(int i=0;i<V;i++){\n    if(glaf[s][i]!=-1&&!check[i]){\n      int goal_cost = salesman(count+1,cost+glaf[s][i],i,check);\n      if(ans==-1 || ( goal_cost!=-1 && goal_cost < ans )) ans = goal_cost;\n    }\n  }\n  check[s] = false;\n  return ans;\n}\n\nint main(){\n  cin >> V >> E;\n  for(int i=0;i<15;i++)\n    for(int j=0;j<15;j++)\n      glaf[i][j] = -1;\n\n  bool check[V];\n  for(int i=1;i<V;i++)\n    check[i] = false;\n\n  int s,t,d;\n  for(int i=0;i<E;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  int ans = salesman(0,0,0,check);\n  cout << ans;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\nstruct Edge {ll s,t,d;};\ntypedef vector<vector<Edge>> Graph;\n\nint main(){\n  ll V,E; cin>>V>>E;\n  Graph G(V);\n  REP(i,E) {Edge e; cin>>e.s>>e.t>>e.d; G[e.t].PB(e);}\n  vvi dist((1ll<<V),vi(V,INF));\n  dist[1][0]=0;\n\n  FOR(i,2,(1ll<<V)) REP(j,V) {\n    if((1ll<<j)&i) for(Edge e:G[j]) dist[i][j]=min(dist[i][j],dist[(1ll<<j)^i][e.s]+e.d);\n  }\n\n  ll ans=INF;\n  for(Edge e:G[0]) ans=min(ans,dist[(1ll<<V)-1][e.s]+e.d);\n  if(ans==INF) ans=-1;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <numeric>\n#include<iostream>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<algorithm>\n#include <sstream>\n#include<string.h>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 1000000007\n#define int long long\n#define rep(i,j,n) for(int i=j;i<n;++i)\ntypedef pair<int,int>  P;\nstring alph(\"abcdefghijklmnopqrstuvwxyz\");\nstruct edge{int from,to,cost;};\nvector<edge> G;\ndouble pi = 3.141592653589793;\nP sg[10];\nint a[55],b[55];\nint n,m;\nint d[16][16];\nint dp[1<<16][16];\nint  solve(int s,int v){\n    if(dp[s][v]>=0)return dp[s][v];\n    if(s==(1<<n)-1&&v==0)return dp[s][v]=0;\n    int res=inf;\n    rep(u,0,n){\n        if(!(s>>u&1)){\n            res=min(res,solve(s|1<<u,u)+d[v][u]);\n        }\n    }\n    return dp[s][v]=res;\n}\n\nsigned main(){\ncin>>n>>m;\n    rep(i,0,n)rep(j,0,n)d[i][j]=inf;\n    rep(i,0,m){\n        int a,b,c;cin>>a>>b>>c;\n        d[a][b]=c;\n    }\n    memset(dp,-1,sizeof(dp));\n    int h=solve(0,0);\n    if(h==inf)cout<<-1<<endl;\n    else cout<<h<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a) for(int i=0; i<(a); i++)\ntypedef long long ll;\nconst int inf = 1001001001;\n\nint main()\n{\n  int n, m; cin >> n >> m;\n  vector<vector<int>> tr(n, vector<int>(n, inf));\n  rep(i, m) {\n    int s, t, d; cin >> s >> t >> d;\n    tr[s][t] = d;\n  }\n  vector<vector<int>> dp(1<<n, vector<int>(n, inf));\n  dp[(1<<n)-1][0] = 0;\n\n  for (int S=(1<<n)-1; S>=0; S--) {\n    for (int v=0; v<n; v++) {\n      for (int u=0; u<n; u++) {\n        if (!(S>>u&1)) {\n          dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + tr[v][u]);\n        }\n      }\n    }\n  }\n  if (dp[0][0] == inf) cout << -1 << endl;\n  else cout << dp[0][0] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\n\nint V,E;\nint map[15][15];\nint dp[1<<15][15];\n\nint saiki(int vis,int pos){\n\n    int r = 1<<28;\n    if(dp[vis][pos] != -1) return dp[vis][pos];\n    if(pos == 0 && vis == (1<<V)-1){\n       \treturn 0;\n    }\n    for(int i=0;i<V;i++){\n\tif(map[pos][i] != -1 && !(vis & (1<<i)) ){\n\t    r = min(r,saiki( vis | (1<<i) ,i) + map[pos][i]);\n\t\n\t}\n    }\n\n    return dp[vis][pos] = r;\n}\nint main(){\n\n    int s,t;\n    cin >> V >> E;\n    fill(&map[0][0],&map[15][0],-1);\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> map[s][t];\n    }\n    fill(&dp[0][0],&dp[1<<15][0],-1);\n\n    int res = saiki(0,0);\n\n    if(res >= 1<<28) res = -1;\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\ni64 N;\ni64 M;\nvector<vector<i64>> G;\n\ni64  memo[15][15][1<<15];\nbool done[15][15][1<<15];\n\ni64 tsp(i64 start, i64 cur, i64 visited) {\n    if(visited == (1<<N) - 1) return G[cur][start];\n\n    if(!done[start][cur][visited]) {\n        memo[start][cur][visited] = INF;\n        REP(to, N) {\n            if(GETBIT(visited,to)) continue;\n            if(G[cur][to] == INF) continue;\n\n            i64 val = tsp(start, to, SETBIT(visited,to));\n            if(val == INF) continue;\n            chmin(memo[start][cur][visited], G[cur][to] + val);\n        }\n\n        done[start][cur][visited] = true;\n    }\n\n    return memo[start][cur][visited];\n}\n\nvoid solve() {\n    i64 ans = INF;\n    REP(start, N) {\n        i64 val = tsp(start, start, SETBIT(0,start));\n        if(val == INF) continue;\n        chmin(ans, val);\n    }\n\n    PRINTLN(ans != INF ? ans : -1);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    RD(N);\n    RD(M);\n\n    G.assign(N, vector<i64>(N, INF));\n    REP(_, M) {\n        i64 from,to; RD(from); RD(to);\n        i64 cost;    RD(cost);\n        G[from][to] = cost;\n    }\n\n    DBG(G);\n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout <<\"DEBUG\"<<\" \"<< #x << \":\" << x << '\\n'\n\n// n回繰り返し\n#define rep(i,n) for(int i = 0; i < ((int)(n)); i++)   // 0-indexed昇順\n#define rep1(i,n) for(int i = 1; i <= ((int)(n)); i++) // 1-indexed昇順\n#define rrep(i,n) for(int i = ((int)(n)-1); i >= 0; i--)  // 0-indexed降順\n#define rrep1(i,n) for(int i = ((int)(n)); i >= 1; i--)   // 1-indexed降順\n#define all(x) (x).begin(),(x).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;  // 2次元配列\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef pair<int, int> PII;\n\ntemplate<typename T>\nusing vec = vector<T>;\ntemplate<class T>\nusing maxheap = std::priority_queue<T>;\ntemplate<class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<class T,class U> inline bool chmax(T &a, const U &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T,class U> inline bool chmin(T &a, const U &b){if(a>b){a=b;return 1;}return 0;}\n\nconst ld Pi = std::acos(-1.0L);\nconst ll infll = (1LL<<62)-1;\nconst int inf = (1<<30)-1;\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n\n//-----------///////////////////////////////\nvii dp;\nstruct edge {\n    int to;\n    int dist;\n    edge(int to, int dist): to(to), dist(dist){};\n};\n\n/*MAIN==================================================*/\nsigned main(){\n    int _StartTime_ = clock();\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);   //cin cout 高速化\n    // cout << fixed << setprecision(15);\n\n    int v, e; cin >> v >> e;\n    vii dp_init(1<<v, vi(v, inf));\n    vec<vec<edge>> graph(v);\n    vec<set<int>> G(v);\n    rep(i,e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s].push_back(edge(t, d));\n        G[s].insert(t);\n    }\n\n    // 各頂点から\n    vi ans(v, inf);\n    for(int StartNode = 0; StartNode < v; ++StartNode) {\n        dp = dp_init;\n        dp[1<<StartNode][StartNode] = 0;\n\n        for(int Set = (1<<StartNode); Set < (1<<v); ++Set) {\n            for(int node = 0; node < v; ++node) if((Set>>node) & 1) {\n                for(auto NextNode : graph[node]) if(!(Set>>NextNode.to & 1)) {\n                    chmin(dp[Set | (1<<NextNode.to)][NextNode.to], dp[Set][node] + NextNode.dist);\n\n                    // スタート点に戻れるか。戻れたら答えを記録\n                    if((Set|(1<<NextNode.to)) == (1<<v)-1) {\n                        if(G[NextNode.to].find(StartNode) != G[NextNode.to].end()) {\n                            int p;\n                            for(auto u : graph[NextNode.to]) {\n                                if(u.to == StartNode) {p = u.dist; break;}\n                            }\n                            chmin(ans[StartNode], dp[Set | (1<<NextNode.to)][NextNode.to] + p);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int answer = inf;\n    for(auto i : ans) chmin(answer, i);\n    if(answer == inf) cout << -1 << '\\n';\n    else cout << answer << '\\n';\n\n    // printf(\"ExecutionTime: %d /ms\\n\",1000*(int)((clock()-_StartTime_)/CLOCKS_PER_SEC));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int s, int v, int used) {\n    if (used == (1 << V) - 1) return G[v][s];\n    if (memo[s][v][used] >= 0) return memo[s][v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || G[v][u] == INF || (used & (1 << u))) continue;\n        ret = min(ret, dfs(s, u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[s][v][used] = ret;\n}\nint TSP() {\n    int ret = INF;\n    init();\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            if (i == j) continue;\n            ret = min(ret, dfs(i, j, (1 << i) | (1 << j)) + G[i][j]);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans == INF ? -1 : Ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define MAX_N 15\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint V,E;\nll K;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint color[MAX_N];\n\nvoid solve(){\n\tfor(int S=0;S<1<<V;S++){\n\t\tfill(dp[S],dp[S]+V,INF);\n\t}\n\tdp[(1<<V)-1][0] = 0;\n\tfor(int S=(1<<V)-2;S>=0;S--){\n\t\tfor(int v=0;v<V;v++){\n\t\t\tfor(int u=0;u<V;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",dp[0][0]);\n}\n\n//dfsで塗る\nint dfs(int v,int a){\n\tcolor[v] = 1;\n\ta++;\n\tfor(int i=0;i<V;i++){\n\t\tif(d[v][i]!=INF && color[i]==0){\n\t\t\ta = dfs(i,a);\n\t\t}\n\t}\n\treturn a;\n}\n\n\nint main()\n{\n\tint s,t,dd;\n\tscanf(\"%d %d\",&V,&E);\n\tif(E==0){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=V;i++){\n\t\tfill(d[i],d[i]+V+1,INF);\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&dd);\n\t\td[s][t] = dd;\n\t}\n\t//printf(\"%d\\n\",dfs(0,0));\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint edge[15][15], v, e, dp[15][1 << 15];\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < v;i++){\n\t\tdp[i][0] = 0;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << v);i++){\n\t\tfor(int j = 0;j < v;j++){ // now place\n\t\t\tif(dp[j][i] != -1){\n\t\t\t\tfor(int k = 0;k < v;k++){ // next place\n\t\t\t\t\tif((i >> k & 1) == 0 && edge[j][k] != -1 && (dp[k][i | (1 << k)] == -1 || dp[k][i | (1 << k)] < dp[j][i] + edge[j][k])){\n\t\t\t\t\t\tdp[k][i | (1 << k)] = dp[j][i] + edge[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = -1;\n\tfor(int i = 0;i < v;i++){\n\t\tif(dp[i][(1 << v) - 1] != -1 && (ans == -1 || dp[i][(1 << v) - 1] < ans)){\n\t\t\tans = dp[i][(1 << v) - 1];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <immintrin.h>\n#ifdef _MSC_VER\n#include <ppl.h>\n#endif\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT std::cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<std::endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if(m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for(auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if(m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for(auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if(v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for(auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if(s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for(auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if(s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for(auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if(s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while(!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if(l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for(auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for(size_t i = 0; i < v.size(); i++) is >> v[i]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << std::endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if(sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\ntemplate<typename Ty>Ty modpow(Ty n, Ty e, Ty m) { Ty result = 1; while(e > 0) { if(e & 1)result = (result*n) % m; e >>= 1; n = (n*n) % m; }return result; }\n\n\n#define PI 3.14159265358979323846\n#define EPS 1e-10\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\n\n\nint INF = 1e8;\nint n, d[15][15], dp[1<<15][15];\npii p[1<<15][15];\nsigned main(void)\n{\n  int m;\n  cin >> n >> m;\n  REP(i, n) REP(j, n) {\n    d[i][j] = INF;\n    p[i][j].first = p[i][j].second = -1;\n  }\n  REP(i, m) {\n    int s, t, dd;\n    cin >> s >> t >> dd;\n    d[s][t] = dd;\n  }\n  REP(i, 1<<n) fill(dp[i], dp[i]+n, INF);\n  dp[(1<<n)-1][0] = 0;\n  for(int s=(1<<n)-2; s>=0; --s) {\n    REP(v, n) REP(u, n) {\n      if(!(s>>u&1)) { // s の u ビット目が下りている\n        if(dp[s][v] > dp[s|1<<u][u]+d[v][u]){ // (s+{u} and last=u) -> (s and last=v)\n          dp[s][v] = dp[s|1<<u][u] + d[v][u]; // v->u を採用\n          p[s][v]=pii(s|1<<u, u);\n        }\n      }\n    }\n  }\n  if(dp[0][0] >= INF) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int s=0,u=0;\n  vector<int> path;\n  while(s!=(1<<n)-1){\n    path.push_back(u);\n    tie(s, u)=p[s][u];\n    if(s==(1<<n)-1) break;\n  }\n  path.push_back(path.front());\n  //cout << path << endl;\n  cout << dp[0][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) FOR(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\n#define INF 1e8;\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nint V,E;\nint to[17][17];\nint dp[(1<<20)+1][17];\n\nint dfs(){\n    rep(i,(1<<V)){\n        rep(j,V){\n            if(!((1<<j)&i)){\n                rep(k,V){\n                    dp[i|(1<<j)][j] = min(dp[i|(1<<j)][j],dp[i][k]+to[k][j]);\n                }\n            }\n        }\n    }\n    if(dp[(1<<V)-1][0] == 1e8) return -1;\n    return dp[(1<<V)-1][0];\n}\nint main(){\n    cin >> V >> E;\n    rep(i,17) rep(j,17) to[i][j] = 1e8;\n    rep(i,(1<<20)) rep(j,17) dp[i][j] = 1e8;\n    int a,b,d;\n    rep(i,E){\n        cin >> a >> b >> d;\n        to[a][b] = d;\n    }\n    dp[0][0] = 0;\n    PRINT(dfs());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i,n) for(ll i=0;i<n;++i)\n#define ALL(a) (a).begin(),(a).end()\n \nusing namespace std;\nusing ll  = long long;\nusing pll = pair<ll, ll>;\n \nconst ll MOD  = 1e9+7;\nconst ll LINF = 1LL << 60;\nconst int INF = 1e9 + 7;\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n\n    ll dist[v][v];//dist[i][j]:iとjを結ぶ辺の距離、\n    rep(i, v)rep(j, v)dist[i][j] = INF;\n\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n\n        dist[s][t] = d;\n    }\n\n    ll dp[(1<<v)][v];//dp[r][i]:集合r(立っているbitの番号の辺が訪問済)から頂点iへ行くときの最短距離\n    rep(i, (1<<v))rep(j, v)dp[i][j] = INF;\n\n    dp[0][0] = 0;\n    rep(r, (1<<v)){\n        rep(i, v){\n            if(r&(1<<i)){\n                rep(j, v)dp[r][i] = min(dp[r][i], dp[r-(1<<i)][j]+dist[j][i]);\n            }\n        }\n    }\n\n    ll ans = dp[(1<<v)-1][0];\n    if(ans >= INF)cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ninline int getbit(int mask, int v) {\n    return (mask >> v) & 1;\n}\n\ninline int newmask(int mask, int v) {\n    return mask | (1 << v);\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int cost[n][n];\n    vector <int> g[n];\n    int x, y, c;\n    for (int i = 0; i < m; i++) {\n        cin >> x >> y >> c;\n        g[x].push_back(y);\n       // g[y].push_back(x);\n        cost[x][y] = c;\n       // cost[y][x] = c;\n    }\n    int P = pow(2, n);\n    int d[P][n];\n    for (int i = 1; i < P; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = -1;\n        }\n    }\n    d[1][0] = 0;\n    const int INF = 1e9;\n    int ans = INF;\n    for (int mask = 1; mask < P; mask++) {\n        for (int v = 0; v < n; v++) {\n            if (d[mask][v] != -1) {\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    int u = g[v][i];\n                    if (mask < P - 1) {\n                        if (!getbit(mask, u)) {\n                            d[newmask(mask, u)][u] = d[mask][v] + cost[v][u];\n                        }\n                    } else {\n                        if (u == 0) {\n                            ans = min(ans, d[mask][v] + cost[v][0]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (ans == INF) {\n        cout << -1;\n    } else {\n        cout << ans;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> ostream &operator << (ostream &os, const vector<T> &);\ntemplate<size_t n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, const tuple<T...> &){}\ntemplate<size_t n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream &os, const tuple<T...> &t){\n    os << (n == 0 ? \"\" : \" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T> ostream &operator << (ostream &os, const tuple<T...> &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U> ostream & operator << (ostream &os, const pair<T,U> &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T> ostream &operator << (ostream &os, const vector<T> &v){\n    for(size_t i = 0; i < v.size(); i++) os << v[i] << (i + 1 == v.size() ? \"\" : \", \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << make_tuple(__VA_ARGS__) \\\n                   << \" (L : \" << __LINE__ << \")\" << endl)\n#else\n#define dump(...)\n#endif\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i = a; i < (int)(b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\nusing ll = long long;\n// #define int ll\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int,int>;\nvoid fastios(){ ios_base::sync_with_stdio(0); cin.tie(0); }\nint const mod = 1000000007;\nauto const inf = numeric_limits<int>::max()/8;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nWeight tsp(const Graph &g){\n    int n = g.size();\n    Matrix m(n, Array(n, inf));\n    for(auto &es : g) for(auto &e : es) m[e.src][e.dst] = min(m[e.src][e.dst], e.weight);\n    Matrix dp(1<<n, Array(n, inf));\n    dp[0][0] = 0;\n    for(int S = 0; S < 1<<n; S++)\n        for(int u = 0; u < n; u++)\n            for(int v = 0; v < n; v++)\n                if(!((S >> v) & 1))\n                    dp[S|1<<v][v] = min(dp[S|1<<v][v], dp[S][u] + m[u][v]);\n    return dp[(1<<n)-1][0];\n}\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m){\n        Graph g(n);\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            g[a].eb(a,b,c);\n        }\n        int ans = tsp(g);\n        cout << (ans==inf ? -1 : ans) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint dp[1 << 15][15];\nint n;\nint m[15][15];\n\nint rec(int s,int v){\n  if(dp[s][v]>=0){\n    return dp[s][v];\n  }\n\n  if(s ==((1 << n)-1) && v==0){\n    //printf(\"v=0\\n\");\n\n    return dp[s][v]=0;\n  }\n\n  int res = 1000*15+1;\n\n  for(int u=0;u<n;u++){\n    if((!(s >> u & 1)) && m[v][u]>=0){\n      //printf(\"m:%d\",m[v][u]);\n      res = min(res,rec(s | (1 << u),u)+m[v][u]);\n    } \n  }\n  //printf(\"res=%d\\n\",res);\n  return dp[s][v]=res;\n}\n\nint main(){\n  int v,e;\n  cin >> v >> e;\n  n=v;\n  \n    memset(m,-1,sizeof(m));\n\n\n  int s,t,d;\n  for(int i=0;i<e;i++){\n    cin >> s >> t >> d;\n    m[s][t]=d;\n  }\n  \n  memset(dp,-1,sizeof(dp));\n  int ans=rec(0,0);\n  if(ans==15001){\n    printf(\"%d\\n\",-1);\n  }\n  else{\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<map>\n#include<string.h>\n#include<complex>\n#include<math.h>\n#include<queue>\n#include <functional>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef pair<int, int> pint;\ntypedef pair<llint, llint> pllint;\ntypedef vector<int> vint;\ntypedef vector<llint> vllint;\ntypedef vector<pint> vpint;\ntypedef vector<string> vstring;\ntypedef vector<pair<llint, llint>> vpllint;\ntypedef vector<vector<int>> vvint;\ntypedef vector<vector<llint>> vvllint;\ntypedef vector<vector<pint>> vvpint;\ntypedef vector<bool> vbool;\ntypedef vector<vbool> vvbool;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define drep(i,n) for(int i=n-1;0<=i;i--)\n#define yes(ans) if(ans)cout<<\"yes\"<<endl;else cout<<\"no\"<<endl;\n#define Yes(ans) if(ans)cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;\n#define YES(ans) if(ans)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n#define POSSIBLE(ans) if(ans)cout<<\"POSSIBLE\"<<endl;else cout<<\"IMPOSSIBLE\"<<endl;\n#define Pi 3.1415926535897932384626\n#define mod llint(1e9+7)\n#define Inf 2147483647\n#define llInf 9223372036854775807\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define isin(n,i) 0<=i&&i<n\n\nclass UnionFind {\npublic:\n\t//親の番号を格納する。親だった場合は-(その集合のサイズ)\n\tvector<int> Parent;\n\n\t//作るときはParentの値を全て-1にする\n\t//こうすると全てバラバラになる\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\n\t//Aがどのグループに属しているか調べる\n\tint root(int A) {\n\t\tif (Parent[A] < 0) return A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\t//自分のいるグループの頂点数を調べる\n\tint size(int A) {\n\t\treturn -Parent[root(A)];//親をとってきたい\n\t}\n\n\t//AとBをくっ付ける\n\tbool connect(int A, int B) {\n\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\t//すでにくっついてるからくっ付けない\n\t\t\treturn false;\n\t\t}\n\n\t\t//大きい方(A)に小さいほう(B)をくっ付けたい\n\t\t//大小が逆だったらひっくり返しちゃう。\n\t\tif (size(A) < size(B)) swap(A, B);\n\n\t\t//Aのサイズを更新する\n\t\tParent[A] += Parent[B];\n\t\t//Bの親をAに変更する\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n};\n\n//セグ木・0-indexed・非再帰・(大きさ・単位元・関数)で初期化\ntemplate<typename T>\nstruct SegTree {\n\t//比較関数の型\n\tusing F = function<T(T, T)>;\n\t//二分木を配列で表したもの\n\tvector<T>seg;\n\t//木の半分の大きさ\n\tint siz;\n\t//単位元\n\tconst T unit;\n\t//比較する関数\n\tconst F f;\n\n\t//大きさn、unit(単位元)、f(モノイド)でsegtreeを初期化する\n\tSegTree(int n, const T unit, const F f) : unit(unit), f(f) {\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t\tseg.assign(siz * 2 - 1, unit);\n\t\tsiz--;\n\t}\n\n\t//k番目にtを入力\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//fによって木を構築する\n\tvoid build() {\n\t\tfor (int i = siz - 1; 0 <= i; i--) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t}\n\t}\n\n\tT operator[](const int i) {\n\t\treturn seg[i + siz];\n\t}\n\n\t//k番目をxに更新する\n\tvoid update(int k, T x) {\n\t\tk += siz;\n\t\tseg[k] = x;\n\t\twhile (0 < k) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[a,b)について、fした結果を返す\n\t//半開区域のためa以上b未満の位置を指す\n\tT query(int a, int b) {\n\t\tT l = unit, r = unit;\n\t\tfor (a += siz, b += siz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(seg[a++], l);\n\t\t\tif (!(b & 1))r = f(seg[--b], r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n};\n\n//aとbの最大公約数を求めるよ\nlong long GCD(long long a, long long b) {\n\tif (b == 0) return a;\n\telse return GCD(b, a % b);\n}\n\n// 返り値: a と b の最大公約数\n// ax + by = gcd(a, b) を満たす (x, y) が格納される\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//nCrを1000000007で割った余りを求める\nllint nCr(llint n, llint r) {\n\tllint ans = 1;\n\tfor (llint i = 0; i < r; i++) {\n\t\tans *= n - i;\n\t\tans %= 1000000007;\n\t}\n\tfor (llint i = 1; i <= r; i++) {\n\t\tans *= modinv(i, 1000000007);\n\t\tans %= 1000000007;\n\t}\n\treturn ans;\n}\n\n//aのb乗をmodで割った余りを求める\nllint power(llint a, llint b) {\n\tif (b == 1)return a;\n\tif (b == 0)return 1;\n\tllint tmp = power(a, (llint)b / 2);\n\ttmp *= tmp;\n\ttmp %= mod;\n\tif (b % 2 == 1) {\n\t\ttmp *= a;\n\t\ttmp %= mod;\n\t}\n\treturn tmp;\n}\n\n//bitを表すsub,要素数を表すlength\nbool next_permutation(llint& sub, int length) {\n\tllint x = sub & -sub, y = sub + x;\n\tsub = (((sub & ~y) / x) >> 1) | y;\n\treturn sub < (llint)(1 << (llint)length);\n}\n\nint main() {\n\tint v, e;\n\tcin >> v >> e;\n\tvvint edges(v, vint(v, 200000));\n\trep(i, e) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedges[s][t] = d;\n\t}\n\tint ans = 200000;\n\trep(s, v) {\n\t\t//dp[S][last]…S(bit)が表す要素をlastが最後になるように並べたときの最小コスト\n\t\tvvint dp(1 << v, vint(v, 200000));\n\t\t//Sの要素数\n\t\trep(i, v + 1) {\n\t\t\tif (i == 0)continue;\n\t\t\tllint S = (1 << i) - 1;\n\t\t\tdo {\n\t\t\t\tif (i == 1 && log2(S & -S) == s) {\n\t\t\t\t\tdp[S][log2(S & -S)] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trep(j, v) {\n\t\t\t\t\t\tif (S & (1 << j)) {\n\t\t\t\t\t\t\trep(k, v) {\n\t\t\t\t\t\t\t\tdp[S][j] = min(dp[S][j], dp[S - (1 << j)][k] + edges[k][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (next_permutation(S, v));\n\t\t}\n\t\trep(i, v) {\n\t\t\tans = min(ans, dp[(1 << v) - 1][i] + edges[i][s]);\n\t\t}\n\t}\n\tif (ans == 200000)ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _sel(_1, _2, x, ...) x\n#define repn(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, a, b) for (ll i = (a); i < (b); i++)\n#define rep(i, ...) _sel(__VA_ARGS__, reps, repn)(i, __VA_ARGS__)\n#define reppn(i, n) for (ll i = 1; i <= (n); i++)\n#define repps(i, a, b) for (ll i = (a); i <= (b); i++)\n#define repp(i, ...) _sel(__VA_ARGS__, repps, reppn)(i, __VA_ARGS__)\n#define rrepn(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, a, b) for (ll i = (b) - 1; i >= (a); i--)\n#define rrep(i, ...) _sel(__VA_ARGS__, rreps, rrepn)(i, __VA_ARGS__)\n#define rreppn(i, n) for (ll i = (n); i >= 1; i--)\n#define rrepps(i, a, b) for (ll i = (b); i >= (a); i--)\n#define rrepp(i, ...) _sel(__VA_ARGS__, rrepps, rreppn)(i, __VA_ARGS__)\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define rng(v) (v).begin(), (v).end()\n#define rrng(v) (v).rbegin(), (v).rend()\n#define _shv(v) for (auto _t1 : v) cerr << _t1 << \" \"; cerr << endl;\n#define dg(x) cerr << #x << \": \" << (x) << endl;\n#define dgv(v) cerr << #v << \": \"; _shv(v);\n#define dgm(m) cerr << #m << \":\" << endl; for (auto _t2 : m) { _shv(_t2); }\n\nusing namespace std;\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vc = vector<char>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vvc = vector<vector<char>>;\nusing vvs = vector<vector<string>>;\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst int DX[4] = {1, 0, -1, 0};\nconst int DY[4] = {0, 1, 0, -1};\n\ntemplate<typename T> inline void pt(T x) { cout << x << endl; }\ntemplate<typename T> inline void inv(T& v) { for (auto& t : v) cin >> t; }\ntemplate<typename T> inline int siz(T& x) { return x.size(); }\ntemplate<typename T> inline ll pow2(T n) { return 1ll << n; }\ntemplate<typename T, typename U> inline int bit(T x, U n) { return x >> n & 1; }\ntemplate<typename T, typename U>\ninline bool umax(T& m, U x) { if (m < x) { m = x; return true; } return false; }\ntemplate<typename T, typename U>\ninline bool umin(T& m, U x) { if (m > x) { m = x; return true; } return false; }\n\n\nint calc(vvi& dp, vvi& g, int b, int e) {\n    if (dp[b][e] != -2) return dp[b][e];\n    int v = siz(g);\n    vi t;\n    rep(i, v) if (!bit(b, i)) t.pb(i);\n    if (siz(t) == 1) {\n        if (e == 0) return dp[b][e] = 0;\n        else return dp[b][e] = -1;\n    } else if (siz(t) < v) {\n        if (e == 0) return dp[b][e] = -1;\n    }\n    dp[b][e] = INF;\n    for (auto t1 : t) {\n        if (t1 == e) continue;\n        if (calc(dp, g, b | ((e != 0) << e), t1) >= 0 && g[t1][e] >= 0)\n            umin(dp[b][e], calc(dp, g, b | ((e != 0) << e), t1) + g[t1][e]);\n    }\n    if (dp[b][e] == INF) dp[b][e] = -1;\n    return dp[b][e];\n}\n\nint main() {\n    int v, e; cin >> v >> e;\n    vvi g(v, vi(v, -1));\n    rep(i, e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n    vvi dp(pow2(v), vi(v, -2));\n\n    pt(calc(dp, g, 0, 0));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\n\nconst int INF = 1e6;\n\nint v, e;\nint g[20][20];\nint dp[(1 << 20)][20];\n\nint rec(int s, int t) {\n\tif (dp[s][t] != 0) return dp[s][t];\n\tif (s == (1 << t)) return dp[s][t] = g[0][t];\n\tint ret = INF;\n\tint prev = s & ~(1 << t);\n\tfor (int u = 0; u < v; u++) {\n\t\tif (!(prev & (1 << u))) continue;\n\t\tret = min(ret, rec(prev, u) + g[u][t]);\n\t}\n\treturn dp[s][t] = ret;\n}\n\nint main() {\n\tcin >> v >> e;\n\trep(i, 20) rep(j, 20) g[i][j] = INF;\n\trep(i, e) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tg[s][t] = d;\n\t}\n\tint ans = rec((1 << v) - 1, 0);\n\tif (ans != INF) cout << ans << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint dp[(1 << 15)][15];\nint d[15][15];\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = INF;\n        }\n    }\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    rep(i,(1 << n)){\n        rep(j,n){\n            dp[i][j] = INF;\n        }\n    }\n    rep(i,n){\n        dp[0][i] = 0;\n    }\n    rep(i,1<<n){\n        rep(j,n){\n            rep(k,n){\n                if(!(i & (1 << k))){\n                    dp[i|(1<<k)][j] = min(dp[i|(1<<k)][j],dp[i][k] + d[k][j]);\n                }\n            }\n        }\n    }\n    int ans = INF;\n    rep(i,n){\n        ans = min(ans,dp[(1<<n)-1][i]);\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <map>\n\n#define fir first\n#define sec second\n#define sz(s) (s).size()\n#define pb push_back\n#define get(n) scanf(\"%d\",&n);\n#define gets(s) string s;cin >> (s);\n#define prfi(n) printf(\"%d\", &n);\n#define prfd(n) printf(\"%lf\", &n);\n#define All(s) (s).begin(), (s).end()\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n#define For(i,j,k) for(int (i)=(j);(i)<(k);(i)++)\n#define repd(i,j) for(int (i)=(j);(i)>=0;(i)--)\n#define Ford(i,j,k) for(int (i)=(j);i>=(k);i--)\n#define vfor(c,v) for(auto (c): v)\n#define mem(a,b) memset(a,b,sizeof(a));\n#define dump(x)  std::cout << #x << \" = \" << (x) << std::endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing ll = long long;\nusing ld = long double;\nusing pii = std::pair<int,int>;\nusing pll = std::pair<ll, ll>;\nusing vi = std::vector<int> ;\nusing vvi = std::vector<vi> ;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vd = std::vector<double> ;\nusing vvd = std::vector<vd> ;\nusing qi = std::queue<int> ;\nusing vpii = std::vector<std::pair<int, int> >;\nusing vpll = std::vector<pll>;\nusing namespace std;\n\nconst int Mod = (1e9) + 7;\nconst int INF = 1e9 + 19;\nconst ll INFL = 1e18 + 19;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n//_____________________________________Templates_________________________________________//\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\ntemplate<class T> inline void swap(T &a,T &b){T c = a;a = b;b = c;}\ntemplate<class T> inline void pri(T a){cout << a << endl;}\ntemplate<class Z> using vec = vector<Z>;\n//mainly use for dynamic prog\ntemplate<class T1, class T2>\nvoid update(T1 &a, T2 b){\n  a += b;\n  if(a > Mod) a %= Mod;\n}\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\nbool pairsort(pll pl, pll pr){\n  if(pl.first == pr.first)return pl.second > pr.second;\n  return pl.first < pr.first;\n}\n\nint cntbit(ll a,int n,int j){int res = 0;For(i,j,n){if(a>>i & 1){res++;}}return res;}\nll makebit(ll a,int n,int j){ll res = 0;For(i,j,n){if(a &(1 << i))res |= 1ll << (i - j);}return res;} \nbool stdbit(int a, int b){if(a&(1 << b))return true;else return false;}\nint GCD(int a, int b){if(b > a)return GCD(b,a);if(a%b == 0)return b;else return GCD(b, a%b);}\nint LCM(int a, int b){return a*b/GCD(a,b);}\n\n//_____________________　following sorce code_________________________//\nconst int max_n = 3 * (1e5) + 1;\nconst int max_m = 83 * (1e5) + 1;\n\nint n,m,k;\nint N;\nint e;\nstring S;\nint a,b,c;\nvi v;\nvvi graph;\nvvi dp;\n\nint rec(int bits, int v)\n{\n  if(dp[bits][v] >= 0)\n  {\n    return dp[bits][v];\n  }\n  if(bits == N-1 && v == 0)\n  {\n    dp[N-1][v] = 0;\n    //dump(N-1);\n    return 0;\n  }\n  int res = INF;\n  rep(i,n)\n  {\n    if(!(bits & (1 << i)))\n    {\n      chmin(res, rec(bits | (1 << i), i) + graph[v][i]);\n    }\n  }\n  //dump(res);\n  dp[bits][v] = res;\n  return res;\n}\n\nint main () \n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  IN(n,e);\n  graph = vvi(n,vi(n,INF));\n  rep(i,e){\n    IN(a,b,c);\n    graph[a][b] = c;\n    //graph[b][a] = c;\n  }\n  N = 1 << n;\n  int ans = INF;\n  dp = vvi(N,vi(n,-1));\n  chmin(ans,rec(0,0));\n  if(ans == INF){\n   cout << -1 << endl;\n    return 0;\n  }\n  cout << ans << endl;\n  //cout << ans << endl;\n  //for(auto c : ans){cout << c << endl;}\n  //cout << fixed << setprecision(15) << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define maxi 1000000000\nusing namespace std;\n\nvector < vector < int > > g, mas, reb;\n\nint getbit(int mask, int num){\n\treturn (mask >> num) & 1;\n}\nint addbit(int mask, int num){\n\treturn mask | (1 << num);\n}\n\nint main(){\n\tint n,m,a,b,c;\n\tcin >> n >> m;\n\tint nn = (1 << n);\n\n\treb.resize(n);\n\tfor(int i=0; i<n; i++)\n\t\treb[i].resize(n);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\treb[i][j] = -1;\n\t\t}\n\t}\n\n\tmas.resize(n);\n\tfor(int i=0; i<n; i++)\n\t\tmas[i].resize(nn);\n\n\tg.resize(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> a >> b >> c;\n\t\tg[a].push_back(b);\n\t\treb[a][b] = c;\n\t}\n\n\tmas[0][1] = 1;\n\tint nextvert, nextmask;\n\n\tfor(int mask = 1; mask < nn - 1; mask+=2){\n\t\tfor(int vert=0; vert<n; vert++){\n\t\t\tif(mas[vert][mask] != 0){\n\t\t\t\tfor(int e=0; e<g[vert].size(); e++){\n\t\t\t\t\tnextvert = g[vert][e];\n\t\t\t\t\tif(!getbit(mask,nextvert)){\n\t\t\t\t\t\tnextmask = addbit(mask,nextvert);\n\t\t\t\t\t\tif(mas[nextvert][nextmask] == 0 || mas[nextvert][nextmask] > mas[vert][mask] + reb[vert][nextvert]){\n\t\t\t\t\t\t\tmas[nextvert][nextmask] = mas[vert][mask] + reb[vert][nextvert];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*//\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<nn; j++){\n\t\t\tcout << mas[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t//*/\n\n\tint mask = nn - 1; int mi = maxi;\n\tfor(int vert=0; vert<n; vert++){\n\t\tif(reb[vert][0] != -1 && mas[vert][mask] != 0 && mi > mas[vert][mask] + reb[vert][0]){\n\t\t\tmi = mas[vert][mask] + reb[vert][0];\n\t\t}\n\t}\n\n\tif(mi != maxi){\n\t\tcout << mi - 1 << endl;\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconst ll MOD = 1e9+7;\n// const ll MOD = 998244353;\nconst ll INF = 1ll<<60;\n\n#define FOR(i,a,b) for (ll i=(a);i<(ll)(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll MAXV = 17;\n\nll dist[MAXV][MAXV]{};\nll dp[(1ll<<MAXV)][MAXV]{};\n\nint main(int argc, char **argv)\n{\n\tll V, E;\n\tcin >> V >> E;\n\tREP(i, V)REP(j, V) dist[i][j] = INF;\n\tREP(i, E)\n\t{\n\t\tll a, b, d; cin >> a >> b >> d;;\n\t\tdist[a][b] = d;\n\t}\n\n\tll SMAX = (1ll<<V);\n\tREP(bits, SMAX) REP(v, V) dp[bits][v] = INF;\n\tdp[0][0] = 0;\n\n\tREP(bits, SMAX)\n\t{\n\t\tREP(s, V)\n\t\t{\n\t\t\tREP(g, V)\n\t\t\t{\n\t\t\t\t// s to g\n\t\t\t\tif (!(bits & (1ll<<g)))\n\t\t\t\t{\n\t\t\t\t\tll tmp = bits|(1ll<<g);\n\t\t\t\t\tdp[tmp][g] = min(dp[tmp][g],\n\t\t\t\t\t\t\t\t\t dp[bits][s]+dist[s][g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll res = dp[SMAX-1][0];\n\tstd::cout << (res == INF ? -1 : res)<< std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int v,e;scanf(\"%d%d\",&v,&e);\n    vector<vector<int>> a(v,vector<int>(v,1e9));\n    for(int i=0;i<e;i++){\n        int s,t,d;scanf(\"%d%d%d\",&s,&t,&d);\n        a[s][t]=d;\n    }\n    vector<vector<int>> dist(1<<v,vector<int>(v,1e9));\n    dist[1][0]=0;\n    for(int i=2;i<(1<<v);i++){\n        for(int j=0;j<v;j++){\n            if((i>>j)&1==0)continue;\n            for(int k=0;k<v;k++){\n                if(j==k)continue;\n                int tmp=dist[i^(1<<j)][k]+a[k][j];\n                dist[i][j]=min(dist[i][j],tmp);\n            }\n        }\n    }\n    int ans=1e9;\n    for(int i=0;i<v;i++)ans=min(ans,dist[(1<<v)-1][i]+a[i][0]);\n    if(ans==1e9)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\nll n,e;\nll d[20][20];\n\nll dp[1 << 15][20];\n\nll rec(ll s, ll v){\n  //?????????????????????????????§?????????????????????\n  if(dp[s][v] >= 0){\n    return dp[s][v];\n  }\n  //??????????????????????¨?????????????\n  if(s == (1 << n) - 1 && v == 0){\n    return dp[s][v] = 0;\n  }\n  ll res = inf;\n  rep(u,n){\n    //???????§???????????????????????????????????????????\n    if( !(s >> u & 1) && d[v][u] != 0){\n      res = min(res,rec(s | 1 << u, u) + d[v][u]);\n    }\n  }\n  return dp[s][v] = res;\n}\n\nvoid solve(){\n  memset(dp,-1,sizeof(dp));\n  ll ans = rec(0,0);\n  if(ans == inf) ans = -1;\n  cout << ans<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> e;\n  ll s,t,dis;\n  rep(i,e){\n    cin >> s >> t >> dis;\n    d[s][t] = dis;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\nusing namespace std;\n\nconst int INF = 100000000; // 十分大きな値\n\n/* 入力 */\nint N;\nint dist[21][21];\n\n/* メモ再帰 */\nint dp[(1<<20) + 1][21]; // dpテーブルは余裕をもったサイズにする\nint rec(int bit, int v)\n{\n    // すでに探索済みだったらリターン\n    if (dp[bit][v] != -1) return dp[bit][v];\n\n    // 初期値\n    if (bit == (1<<v)) {\n        // std::cout << \"bit \"<< bit << std::endl;\n        // std::cout << \"init v with 0 \"<< v << std::endl;\n        // return dp[bit][v] = 0;\n        return dp[bit][v] = dist[0][v];\n    }\n\n    // 答えを格納する変数\n    int res = INF;\n\n    // bit の v を除いたもの\n    int prev_bit = bit & ~(1<<v);\n\n    // v の手前のノードとして u を全探索\n    int min_root = -1;\n    for (int u = 0; u < N; ++u) {\n        if (!(prev_bit & (1<<u))) continue; // u が prev_bit になかったらダメ\n        // if(dist[u][v]==INF) continue;\n        // std::cout << \"u \"<< u <<\" v \" << v<< std::endl;\n        // 再帰的に探索\n        // if (res > rec(bit ^ (1 << v), u) + dist[u][v]) {\n        //     res = rec(bit ^ (1 << v), u) + dist[u][v];\n        if (res > rec(prev_bit, u) + dist[u][v]) {\n            res = rec(prev_bit, u) + dist[u][v];\n            min_root = u;\n        }\n    }\n    // std::cout << \"min root \"<< min_root<< \" to \"<< v <<\" res \" << res<< std::endl;\n\n    return dp[bit][v] = res; // メモしながらリターン\n}\n\nint main()\n{\n    // 入力\n    cin >> N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dist[i][j] = INF;\n        }\n    }\n    int e;\n    std::cin >> e;\n    for (int i = 0; i < e; i++){\n        int s, t, d;\n        std::cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    // テーブルを全部 -1 にしておく (-1 でなかったところは探索済)\n    for (int bit = 0; bit < (1<<N); ++bit) for (int v = 0; v < N; ++v) dp[bit][v] = -1;\n\n    // 探索\n        int a = rec((1<<N)-1, 0);\n    // std::cout << \"res \"<< a << \" root \"<< 0  << std::endl;\n    if(a < INF){\n        std::cout << a << std::endl;\n    } else{\n      std::cout << -1 << std::endl;\n    }\n    // int res = INF;\n    // for (int v = 0; v < N; ++v) {\n    //     if (res > rec((1<<N)-1, v)) {\n    //         res = rec((1<<N)-1, v);\n    //     }\n    // }\n    // cout << res << endl;\n}\n\n\n// #include <bits/stdc++.h>\n// #define LOOP(n) for (int _i = 0; _i < (n); _i++)\n// #define REP(i, n) for (int i = 0; i < (n); ++i)\n// #define RREP(i, n) for (int i = (n); i >= 0; --i)\n// #define FOR(i, r, n) for (int i = (r); i < (n); ++i)\n// #define ALL(obj) begin(obj), end(obj)\n// using namespace std;\n// using ll = long long;\n// const int INF = 1000100100;\n// template <class T>\n// bool chmin(T &a, const T &b) {\n//     if (b < a) {\n//         a = b;\n//         return 1;\n//     }\n//     return 0;\n// }\n// int V, E;\n// int G[20][20];  // グラフ\n// int dp[50000][20];\n// // メモ化再帰\n// int rec(int bit, int v) {\n//     if (bit == 0) {\n//         if (v == 0) {\n//             return 0;\n//         } else {\n//             return INF;\n//         }\n//     }\n//     if ((bit & (1 << v)) == 0) {  // bitに{v}が含まれていない\n//         return INF;\n//     }\n//     int &ret = dp[bit][v];\n//     if (ret != 0) return ret;\n//     ret = INF;\n//     REP(u, V) { chmin(ret, rec(bit ^ (1 << v), u) + G[u][v]); }\n//     return ret;\n// }\n// int main() {\n//     cin >> V >> E;\n//     // グラフの初期化\n//     REP(i, 20) {\n//         REP(j, 20) { G[i][j] = INF; }\n//     }\n//     REP(i, E) {\n//         int s, t, d;\n//         cin >> s >> t >> d;\n//         G[s][t] = d;\n//     }\n//     // int ans = rec((1 << V) - 1, 0);\n//     int ans = rec((1 << V) - 1, 1);\n//     // int b = rec((1 << V) - 1, 2);\n//     // int c = rec((1 << V) - 1, 3);\n//     // std::cout << \"a \"<< a << std::endl;\n//     // std::cout << \"a \"<< a << \" b \"<< b <<\" c \"<<c<< std::endl;\n//     if (ans != INF) {\n//         cout << ans << endl;\n//     } else {\n//         cout << -1 << endl;\n//     }\n//     return 0;\n// }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define REPD(i,n) for(ll i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)\n#define FORD(i,a,b) for(ll i=a;i>=(ll)(b);i--)\n\n#define input(...) __VA_ARGS__; in(__VA_ARGS__)\n\ntemplate<class T>\nvoid print(vector<T> a) {\n  cout << \"[ \";\n  REP(i, a.size()) cout << a[i] << \" \";\n  cout << \"]\" << endl;\n}\n\nvoid print() {\n  std::cout << std::endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  std::cout << head << \" \";\n  print(std::forward<Tail>(tail)...);\n}\n\nvoid in() { }\n\ntemplate <class Head, class... Tail>\nvoid in(Head&& head, Tail&&... tail) {\n  cin >> head;\n  in(std::forward<Tail>(tail)...);\n}\n\nll v, e;\nvector<vector<pair<ll, ll>>> graph;\n\nll pos(ll node) {\n  return 1 << node;\n}\n\nvector<vector<ll>> table;\n#define DP table[node][visited]\nll dfs(ll node=0, ll visited=1) {\n  if (DP != -1) return DP;\n\n  if (__builtin_popcount(visited) == v) {\n    for (auto v: graph[node]) {\n      if (v.first == 0) return DP = v.second;\n    }\n    return DP = 1ll << 60;\n  }\n  ll minv = 1ll << 60;\n  for(auto v: graph[node]) {\n    if (!(visited & pos(v.first))) {\n      minv = min(minv, dfs(v.first, visited | pos(v.first)) + v.second);\n    }\n  }\n  return DP = minv;\n}\n\nint main() {\n  cin >> v >> e;\n\n  graph = vector<vector<pair<ll, ll>>>(v);\n  REP(i, e) {\n    ll input(s, t, d);\n    graph[s].push_back({t, d});\n  }\n\n  table = vector<vector<ll>>(v, vector<ll>(1 << v, -1));\n\n  ll cost = dfs();\n  if (cost < 1ll << 60) {\n    cout << cost << endl;\n  } else {\n    cout << -1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long MAX_V = 15;\nconst long long INF = 1LL<<60;\n\nvector<vector<long long>> G(MAX_V, vector<long long>(1<<MAX_V, INF));\nvector<vector<long long>> dist(MAX_V, vector<long long>(MAX_V, INF));\n\nint main(){\n    \n    int V, E;\n    cin >> V >> E;\n    \n    for (int i = 0; i < E; i++){\n        long long s, t, d;\n        cin >> s >> t >> d;\n        \n        dist[s][t] = d;\n    }\n    \n    G[0][1] = 0;\n    \n    //\n    for (int s = 0; s < (1<<V); s++){\n        \n        for (int from = 0; from < V; from++){\n            \n            for (int to = 0; to < V; to++){\n                \n                if (!(s & (1<<from))) continue;\n                if (s & (1<<to)) continue;\n                \n                G[to][s | (1<<to)] = min(G[to][s | (1<<to)], G[from][s] + dist[from][to]);\n            }\n        }\n    }\n    \n    long long ans = INF;\n    \n    for (int i = 1; i < V; i++){\n        ans = min(ans, G[i][(1<<V)-1] + dist[i][0]);\n    }\n    \n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n     \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1000000;\nint main(){\n  int V, E;\n  cin >> V >> E;\n  vector<vector<int>> dist(V, vector<int>(V, INF));\n  for (int i = 0; i < E; i++){\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n  vector<vector<int>> dp(1 << V, vector<int>(V, INF));\n  dp[0][0] = 0;\n  dp[1][0] = 0;\n  for (int i = 0; i < (1 << V); i++){\n    for (int j = 0; j < V; j++){\n      for (int k = 0; k < V; k++){\n        if ((i >> j) & 1){\n          dp[i][j] = min(dp[i][j], dp[i - (1 << j)][k] + dist[k][j]);\n        }\n      }\n    }\n  }\n  if (dp[(1 << V) - 1][0] == INF){\n    cout << -1 << endl;\n  } else {\n    cout << dp[(1 << V) - 1][0] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\n\nconst int inf = INT_MAX / 3;\nconst int max_v = 16;\n\nint d[max_v][max_v];\nint dp[(1 << max_v) - 1][max_v];  // S?????¢????????£????????????????????????v??????????????´???\n\n\nusing namespace std;\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\td[i][j] = (i == j) ? 0 : inf;\n\n\t\t}\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint ts,tt , td;\n\t\tcin >> ts >> tt >> td;\n\t\td[ts][tt] = td;\n\t}\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tdp[s][v] = inf;\n\t\t}\n\t}\n\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int s = (1 << V) - 1; s >= 0; s--) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tfor (int u = 0; u < V;u++) {\n\t\t\t\t//cout << \"s:\" << s << \" v:\" << v << \" u:\" << u << endl;\n\t\t\t\tif (!((s >> u) & 1)) {\n\t\t\t\t\tdp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[u][v]);\n\t\t\t\t//\tcout << \" dp:\" << dp[s][v] << endl;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[0][0] >= inf) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << dp[0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit ( int mask, int num )\n{\n\treturn ( mask >> num ) & 1;\n}\ninline int add_bit ( int mask, int num )\n{\n\treturn ( mask + ( 1 << num ) );\n}\n\n\nint main ()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph ( n );\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back ( make_pair ( destiny, len ) );\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow ( 2, n );\n\tvector < vector < int > > dp ( max_mask, vector < int > ( n, -1 ) );\n\tdp[1][0] = 0;\n\tfor ( int mask = 1; mask < max_mask; mask++ )\n\t{\n\t\tif ( mask == 23 )\n\t\t{\n\t\t\tint a = 0;\n\t\t}\n\t\tfor ( int vertex = 0; vertex < n; vertex++ )\n\t\t{\n\t\t\tfor ( i = 0; i < graph[vertex].size (); i++ )\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif ( !get_bit ( mask, next ) && (dp[mask][vertex] != -1) )\n\t\t\t\t{\n\t\t\t\t\tif ( ( dp[add_bit ( mask, next )][next] < ( dp[mask][vertex] + graph[vertex][i].second ) ) || ( -1 == dp[add_bit ( mask, next )][next] ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit ( mask, next )][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor ( i = 1; i < n; i++ )\n\t{\n\t\tfor ( j = 0; j < graph[i].size (); j++ )\n\t\t{\n\t\t\tif ( 0 == graph[i][j].first )\n\t\t\t{\n\t\t\t\tif ( dp[max_mask - 1][i] != -1 )\n\t\t\t\t{\n\t\t\t\t\tif ( ( result > ( dp[max_mask - 1][i] + graph[i][j].second ) ) || ( result == -1 ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \";} cout<<endl;\nll dp[16][1LL<<16];\nll s[200], t[200], d[200];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,M;\n    cin >> N >> M;\n    ll dist[20][20] = {};\n    rep(i,0,N){\n        rep(j,0,N){\n            if(i == j) dist[i][j] = 0;\n            else dist[i][j] = INF;\n        }\n    }\n    rep(i,0,M){\n        cin >> s[i] >> t[i] >> d[i];\n        dist[s[i]][t[i]] = d[i];\n    }\n    rep(i,0,N){\n        rep(j,0,(1LL<<N)){\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][1] = 0; //dp[i][j]: 今iにいて訪れたことのある頂点集合がjの時の最短距離\n    rep(bit,0,(1LL<<N)){\n        rep(i,0,N){\n            if(dp[i][bit] == INF) continue;\n            rep(j,0,N){\n                if((bit>>j) & 1) continue;\n                dp[j][bit | (1LL<<j)] = min(dp[j][bit | (1LL<<j)], dp[i][bit] + dist[i][j]);\n            }\n        }\n    }\n    ll ans = INF;\n    rep(i,0,N){\n        ans = min(ans, dp[i][(1LL<<N)-1] + dist[i][0]);\n    }\n    if(ans == INF){\n        print(-1);\n    }else{\n        print(ans);\n    }\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll;\nconst int INF = 10000000;\nint n, e;\nint d[15][15], dp[1 << 15][15];\nint main() {\n\tcin >> n >> e;\n\tfill(d[0], d[15], INF);\n\tfill(dp[0], dp[1 << 15], INF);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, dis; cin >> s >> t >> dis;\n\t\td[s][t] = dis;\n\t}\n\tdp[(1 << n) - 1][0] = 0;\n\tfor (int i = (1 << n) - 2; i >= 0; i--)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (!(i >> k & 1))\n\t\t\t\t\tdp[i][j] = min(dp[i][j], d[i | 1 << k][k] + dp[j][k]);\n\tif (dp[0][0] >= INF) cout << -1 << endl;\n\telse cout << dp[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Traveling Salesman Problem - ?????????????????????????????? ?????¢???*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n\n#define V_MAX 15\nconst int INF=1<<30;\nint DP[1<<V_MAX][V_MAX]; //[S][now] : now ?????? U\\S ????¨???????0????????????????????????\nint G[V_MAX][V_MAX];\n\nint V,E;\n\nint rec(int S,int now){\n  if(DP[S][now]>=0)return DP[S][now];\n  if(S==(1<<V)-1 and now==0)return DP[S][now]=0;\n  int ret=INF;\n  rep(v,V){\n    if( S & (1<<v) )continue;\n    if(G[now][v] == INF)continue;\n    \n    ret = min( ret , rec(S|(1<<v),v) ) + G[now][v];\n  }\n  return DP[S][now]=ret;\n}\n\nint main()\n{\n  cin>>V>>E;\n  rep(i,V)rep(j,V)G[i][j]=INF;\n  rep(i,1<<V)rep(j,V)DP[i][j]=-1;\n  rep(i,E){\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  int ans=rec(0,0);\n  cout<< (ans>=INF ? -1 : ans) <<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Traveling Salesman Problem - ?????????????????????????????? ?????¢???*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n\n#define V_MAX 15\nconst int INF=1<<30;\nint DP[1<<V_MAX][V_MAX]; //[S][now] : now ?????? U\\S ????¨???????0????????????????????????\nint G[V_MAX][V_MAX];\n\nint V,E;\n\nint rec(int S,int now){\n  if(DP[S][now]>=0)return DP[S][now];\n  if(S==(1<<V)-1 and now==0)return DP[S][now]=0;\n  int ret=INF;\n  rep(v,V){\n    if( S & (1<<v) )continue;\n    if(G[now][v] == INF)continue;\n    \n    ret = min( ret , rec(S|(1<<v),v) ) + G[now][v];\n  }\n  return DP[S][now]=ret;\n}\n\nint main()\n{\n  cin>>V>>E;\n  rep(i,V)rep(j,V)G[i][j]=INF;\n  rep(i,1<<V)rep(j,V)DP[i][j]=-1;\n  rep(i,E){\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  int ans=rec(0,0);\n  cout<< (ans>=INF ? -1 : ans) <<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconstexpr int INF = 1000000000;\nconstexpr int MAX_V = 15;\n\nint V, E;\nint memo[1 << MAX_V][MAX_V] = {-1}, dis[MAX_V][MAX_V] = {-1};\n\nint tsp(int s = 1, int v = 0);\n\nint main(){\n    scanf(\"%d%d\", &V, &E);\n    for(int i = 0; i < 1 << V; ++i){\n        for(int j = 0; j < V; ++j){\n            memo[i][j] = -1;\n        }\n    }\n    for(int i = 0; i < V; ++i){\n        for(int j = 0; j < V; ++j){\n            dis[i][j] = INF;\n        }\n    }\n    for(int i = 0; i < E; ++i){\n        int s, t, d;\n        scanf(\"%d%d%d\", &s, &t, &d);\n        dis[s][t] = d;\n    }\n    int tmp = tsp();\n    if(tmp >= INF){\n        puts(\"-1\");\n    }\n    else{\n        printf(\"%d\\n\", tmp);\n    }\n    return 0;\n}\n\nint tsp(int s, int v){\n    if(memo[s][v] != -1){\n        return memo[s][v];\n    }\n    if(s == ((1 << V) - 1)){\n        return dis[v][0];\n    }\n    \n    int res = INF;\n    for(int i = 0; i < V; ++i){\n        if(s & 1 << i){\n            continue;\n        }\n        res = std::min(res, tsp(s | (1 << i), i) + dis[v][i]);\n    }\n\n    return memo[s][v] = res;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// (to, cost)\nvector<pii> G[20];\nint dp[1 << 15][15];\n\nvoid solve() {\n    int V, E; cin >> V >> E;\n    rep(i,0,E) {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].push_back(pii(t, d));\n    }\n\n    rep(i,0,1<<V) rep(j,0,V) dp[i][j] = INF;\n    dp[0][0] = 0;\n    rep(bit,0,1<<V) rep(i,0,V) {\n        for(auto x : G[i]) {\n            if(bit >> x.first & 1) continue;\n            int nbit = bit | (1 << x.first);\n            chmin(dp[nbit][x.first], dp[bit][i] + x.second);\n        }\n    }\n    int ans = (dp[(1<<V)-1][0] == INF ? -1 : dp[(1<<V)-1][0]);\n    cout << ans << endl;\n}\n\nsigned main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint dp[1<<16][20];\nint d[20][20];\nint main(){\n\tint V,E;\n\tcin>>V>>E;\n\tfor(int i =0;i <(1<<20);i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i < V;i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor(int i =0;i < E;i++){\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\td[x][y] =c;\n\t}\n\tdp[1][0]=0;\n\tfor(int i =0;i <(1<<V);i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\tif((i>>j&1)==0)continue;\n\t\t\tfor(int k =0;k < V;k++){\n\t\t\t\tif((i>>k&1)==1)continue;\n\t\t\t\tdp[i|(1<<k)][k] =min(dp[i|(1<<k)][k],dp[i][j]+d[j][k]);\n\t\t\t\t//cout <<\"dp = \"<<dp[i|(1<<k)][k]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans =INF;\n\tfor(int i =0;i <V;i++){\n\t\tans =min(ans,dp[(1<<V)-1][i]+d[i][0]);\n\t}\n\tif(ans>=INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\n#define INF 1<<15\n\nint main(){\n\tint n,m;\n\tint s,t,d;\n\tint e[15][15];\n\tint dp[1<<15][15];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<15;i++) fill_n(e[i],15,INF);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\te[s][t]=d;\n\t}\n\t\n\tfor(int i=0;i<(1<<n);i++) fill_n(dp[i],n,INF);\n\tdp[(1<<n)-1][0]=0;\n\t\n\tfor(int i=(1<<n)-2;i>=0;i--){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(!((i>>k)&1))\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i|1<<k][k]+e[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(dp[0][0]==INF ? -1 : dp[0][0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dp[1<<16][16];//dp[i][j]=すでに訪れた頂点の集合をi現在jにいる状態から残りのすべての頂点をめぐって頂点０に帰るようなパスの重みの総和の最小値\nint d[16][16];\nconst int INF=100000000;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,m;cin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++)d[i][j]=INF;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\td[a][b]=c;\n\t}\n\n\n\tfor(int i=0;i<(1<<n);i++){\n\t\tfill(dp[i],dp[i]+n,INF);\n\t}\n\tdp[(1<<n)-1][0]=0;\n\n\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\tfor(int v=0;v<n;v++){\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v]=min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF)cout<<-1<<endl;\n\telse cout<<dp[0][0]<<endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define INF 1500000\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll d[16][16];\nll dp[1<<15][16];\nint main(void){\n    int n,e;\n    cin>>n>>e;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j]=INF;\n    for(int i=0;i<e;i++){\n        int s,t,c;\n        cin>>s>>t>>c;\n        d[s][t]=c;\n    }\n    for(int j=0;j<n;j++)for(int i=0;i<1<<n;i++)dp[i][j]=INF;\n    dp[(1<<n)-1][0]=0;\n    for(int i=(1<<n)-1;i>=0;i--){\n        for(int j=0;j<n;j++){\n            \n                for(int k=0;k<n;k++){\n                    if((i>>k&1)==0){\n                        dp[i][j]=min(dp[i|1<<k][k]+d[j][k],dp[i][j]);\n                    }\n                }\n            \n        }\n    }\n    if(dp[0][0]>=INF)cout<<-1<<endl;\n    else cout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1 << 15][15],d[15][15],a,b,c,n,p,INF=1<<30;\nint rec(int s,int v){\n\tif(dp[s][v]!=-1)return dp[s][v];\n\tif(s == (1<< n) -1 && v == 0)return dp[s][v] = 0;\n\tint res = INF;\n\tfor(int i = 0;i<n;i++)if(!(s>>i & 1) && d[v][i] != -1)res = min(res,rec(s|(1<<i),i)+d[v][i]);\n\treturn dp[s][v] = res;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(d,-1,sizeof(d));\n\tcin >> n >> p;\n\tfor(int u = 0; u < p;u++)cin>>a>>b>>c,d[a][b]=c;\n\tcout<<(INF == (a = rec(0,0))?-1:a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <vector>\n//#include <algorithm>\n\nusing namespace std;\n\n//vector < vector < int > > rebra;\n\nint getbit(int mask, int num)\n{\n    return (mask >> num) &1;\n}\n\nint main()\n{\n    int n, m, a, b, c, l = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        l *= 2;\n    l--;\n    int rebra[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            rebra[i][j] = -1;\n    for (int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            rebra[a][b] = c;\n        }\n    long long dp[l+1][n];\n    for (int i = 0; i <= l; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = -1;\n    dp[1][0] = 0;\n    long long f = 1;\n    for (long long mask = 1; mask <= l; mask++)\n        for (int j = 0; j < n; j++)\n            if ((getbit(mask, j) == 1) && (dp[mask][j] != -1))\n                for (int q = 0; q < n; q++)\n                    if ((rebra[j][q] != -1) && (getbit(mask, q) == 0)){\n                        f = 1;\n                        for (int y = 0; y < q; y++)\n                            f *= 2;\n                        f += mask;\n                        if ((dp[f][q] == -1) || (dp[mask][j] + rebra[j][q] < dp[f][q])){\n                            dp[f][q] = dp[mask][j] + rebra[j][q];\n                            f = 0;\n                            }\n\n                    }\n    int mm = -1;\n    for (int i = 1; i < n; i++)\n        if ((dp[l][i] != -1) && (rebra[i][0] != -1))\n            if (mm == -1){\n                mm = dp[l][i] + rebra[i][0];\n            } else {\n                if ((mm == -1) || (dp[l][i] + rebra[i][0] < mm))\n                    mm = dp[l][i] + rebra[i][0];\n            }\n    /*for (int i = 0; i < n; i++){\n        for (int j = 1; j <= l; j++)\n            cout << dp[j][i] << ' ';\n        cout << endl;\n    }*/\n    cout << mm;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\n \nusing namespace std;\n \n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n \nstruct Edge {\n  int dst,weight;\n};\n \nint TravelingSalesmanProblem(int V,int E,vector<int> s,vector<int> t,vector<int> d) {\n  vector<vector<Edge> > G(V);\n  vector<int> cost(V,INT_MAX);\n  cost[0] = 0;\n  for(int i=0;i<E;++i) {\n    G[s[i]].push_back((Edge){t[i],d[i]});\n    if( t[i] == 0 ) {\n      cost[s[i]] = min(cost[s[i]],d[i]);\n    }\n  }\n  vector<vector<int> > dp((1<<V),vector<int>(V,INT_MAX));\n  dp[1][0] = 0;\n  for(int state=0;state<(1<<V);++state) {\n    for(int cur=0;cur<V;++cur) if( dp[state][cur] != INT_MAX ) {\n        for(int i=0;i<(int)G[cur].size();++i) {\n          Edge &e = G[cur][i];\n          if( (state>>e.dst) & 1 ) continue;\n          dp[state|(1<<e.dst)][e.dst] = min(dp[state|(1<<e.dst)][e.dst],\n                                            dp[state][cur]+e.weight);\n        }\n      }\n  }\n \n  int mini = INT_MAX;\n  for(int i=0;i<V;++i) if( dp[(1<<V)-1][i] != INT_MAX && cost[i] != INT_MAX ) {\n    mini = min(mini,dp[(1<<V)-1][i]+cost[i]);\n  }\n  return (mini!=INT_MAX)?mini:-1;\n}\n \nint main() {\n  int V,E;\n  cin >> V >> E;\n  vector<int> s(E), t(E), d(E);\n  for(int i=0;i<E;++i) cin >> s[i] >> t[i] >> d[i];\n  cout << TravelingSalesmanProblem(V,E,s,t,d) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9+1\nint n,d[20][20];\nint dp[1<<20][20];\n\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if((s==(1<<n)-1)&&(v==0))return dp[s][v]=0;\n  int res=INF;\n  for(int i=0;i<n;i++){\n    if((!(s>>i&1))&&(d[v][i]>=0))\n      res=min(res,rec(s|1<<i,i)+d[v][i]);\n  }\n  return dp[s][v]=res;\n}\n\nint main(){\n  int e,s,t,l;\n  cin>>n>>e;\n  memset(dp,-1,sizeof(dp));\n  memset(d,-1,sizeof(d));\n  for(int i=0;i<e;i++){\n    cin>>s>>t>>l;\n    d[s][t]=l;\n  }\n  int ans=rec(0,0);\n  cout<<(ans==INF?-1:ans)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P>Vec;\n\nint v,e;\nVec Edge[15];\nint memo[1<<16][15];\nint solve(int bit,int now);\n\nint main(){\n  memset(memo,-1,sizeof(memo));\n  int s,t,d;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    cin>>s>>t>>d;\n    Edge[s].push_back(P(t,d));\n  }\n  int ans=solve(0,0);\n  if(ans==(1<<30))cout<<\"-1\"<<endl;\n  else cout<<ans<<endl;\n}\n\nint solve(int bit,int now){\n  int cost=1<<30;\n  if(memo[bit][now]!=-1)return memo[bit][now];\n  // ->goal\n  if(bit== (1<<v)-1)return 0;\n  else if(bit & 1)return cost;\n  // <-goal\n  \n  for(int i=0;i<Edge[now].size();i++){\nif((bit & 1 << Edge[now][i].first)==0){\n      cost=min(cost,solve(bit | 1 << Edge[now][i].first,Edge[now][i].first)+Edge[now][i].second);\n    }\n  } \n  return memo[bit][now]=cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    UL D[15][15];\n    UL dp[1 << 15][15];\n\n    void Solve() {\n        UL N, M; scanf(\"%d%d\", &N, &M);\n        rep(i, N) rep(j, N) D[i][j] = 1000000;\n        rep(i, M) {\n            UL u, v, d; scanf(\"%d%d%d\", &u, &v, &d);\n            D[u][v] = d;\n        }\n        rep(i, 1 << N) rep(j, N) dp[i][j] = 1000000;\n        dp[0][0] = 0;\n        rep(i, 1 << N) {\n            rep(j, N) {\n                rep(k, N) {\n                    if (i & 1 << k) continue;\n                    dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + D[j][k]);\n                }\n            }\n        }\n        if (dp[(1 << N) - 1][0] >= 1000000) printf(\"-1\\n\");\n        else printf(\"%d\\n\", dp[(1 << N) - 1][0]);\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <random>\n#include <chrono>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n//const int mod = 1e9+7;\nconst int N = 16;\nconst int max_states = (1 << N);\nint g[N][N];\nint dp[max_states][N];\nint n, m;\n\ninline void quickread() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n}\n\nint solve() {\n    int states = (1 << n);\n    memset(dp, 0x3f3f3f, sizeof dp);\n    dp[1][0] = 0; // start from vertex 0;\n    for(int state = 0; state < states; state ++) {\n        // ex: 110111\n        for(int bit = 0; bit < n; bit ++) {\n            if(((state >> bit) & 1) == 1) {\n                //ex: 110111, bit = 2 => former state: 110011\n                int mask = (1 << bit);\n                int prev_state = (state ^ mask);\n                for(int prev = 0; prev < n; prev ++) {\n                    if(((prev_state >> prev) & 1) == 1) {\n                        //prev state: 110011, prev: 4 => state: 110111, bit: 2\n                        dp[state][bit] = min(dp[state][bit], dp[prev_state][prev] + g[prev][bit]);\n\n                    }\n                }\n            }\n        }\n    }\n    int res = INT_MAX;\n    for(int final= 0; final < n; final ++) {\n        res = min(res, dp[states-1][final] + g[final][0]);\n    }\n    if(res >= 0x3f3f3f) return -1;\n    return res;\n}\n\nint main()\n{\n    quickread();\n    memset(g, 0x3f3f3f, sizeof g);\n    cin >> n >> m;\n    int u, v, w;//u->v, weight = w\n    for(int i = 0; i < m; i ++) {\n        cin >> u >> v >> w;\n        g[u][v] = w;\n    }\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nint min_cost_from(const int state, const int crrnt_nd, const int source,\n                  vector< vector<int> > &dpTable,\n                  const vector< vector< pair<int, int> > > &adjList)\n{\n  int n_nodes = adjList.size();\n  \n  // Already Visited\n  if (dpTable[state][crrnt_nd] >= 0) {\n    return dpTable[state][crrnt_nd];\n  }\n  \n  // Case: dp[V][src] = 0\n  if (state == (1 << n_nodes) - 1 && crrnt_nd == source) {    \n    return dpTable[state][crrnt_nd] = 0;\n  }\n\n  // Case: dp[S][v] = min{dp[S+{u}][u]+d[v, u]; u not in S}\n  int tmp_min = INF;\n  for (auto itr = adjList[crrnt_nd].begin(); itr != adjList[crrnt_nd].end(); ++itr) {\n    int next_nd, dist;\n    tie(next_nd, dist) = *itr;\n    // For \"next_nd\" not in \"state\"\n    if (!(state >> next_nd & 1)) {\n      int next_state = state | 1 << next_nd;\n      int cost_from_next = min_cost_from(next_state, next_nd, source, dpTable, adjList);\n      tmp_min = min(tmp_min, cost_from_next + dist);\n    }\n  }\n  return dpTable[state][crrnt_nd] = tmp_min;\n}\n\nint held_karp(const vector< vector< pair<int, int> > > &adjList, int source)\n{\n  int n_nodes = adjList.size();\n  vector< vector<int> > dpTable(1 << n_nodes, vector<int>(n_nodes, -1));\n  int empty_set = 0;\n  int cost =  min_cost_from(empty_set, source, source, dpTable, adjList);\n  return cost < INF ? cost: -1;\n}\n\nvoid print_adjacency_list(const vector< vector< pair<int, int> > > &adjList)\n{\n  for (int s = 0; s < adjList.size(); ++s) {\n    cout << s << \":\";\n    for (auto itr = adjList[s].begin(); itr != adjList[s].end(); ++itr) {\n      int t, d;\n      tie(t, d) = *itr;\n      cout << \" (\" << t << \", \" << d << \")\";\n    }\n    cout << endl;\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  int n_nodes;\n  int n_links;\n  cin >> n_nodes >> n_links;\n  vector< vector< pair<int, int> > > adjList(n_nodes);\n  for (int i = 0; i < n_links; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    adjList[s].push_back(make_pair(t, d));\n  }\n\n  // print_adjacency_list(adjList);\n  cout << held_karp(adjList, 0) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, start, end) for (long long i = start; i < end; ++i)\n#define repreverse(i, start, end) for (long long i = start; i >= end; --i)\n#define all(x) (x).begin(), (x).end()\n#define len(x) ((long long)(x).size())\n#define lcm(a, b) ((a) / __gcd((a), (b)) * (b))\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vllvll = vector<vll>;\nusing pll = pair<ll, ll>;\ntemplate<class T>void print1d(T x,ll n=-1){if(n==-1)n=x.size();rep(i,0,n){cout<<x[i]<<' ';}cout<<'\\n';}\ntemplate<class T>void print2d(T x,ll r=-1,ll c=-1){if(r==-1)r=x.size();if(c==-1)c=x[0].size();rep(i,0,r)print1d(x[i],c);}\ntemplate<class T, class U>bool haskey(T mp, U key) { return mp.find(key) != mp.end(); }\ntemplate<class T, class U>bool isin(T el, U container) { return find(all(container), el) != container.end(); }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<class T>ld deg2rad(T deg) { return M_PI * deg / 180.0; }\ntemplate<class T>ld rad2deg(T rad) { return 180.0 * rad / M_PI; }\nll intpow(ll a,ll n){ll p=1;while(n){if(n&1)p*=a;a*=a;n>>=1;}return p;}\nconst long double pi = M_PI;\nconst long long big = 1LL << 50;\nconst long long inf = 1LL << 60;\nconst long long mod = 1e9 + 7;\n\n\n\nint main()\n{\n        ll V, E;\n        cin >> V >> E;\n\n        vllvll dp(1<<V, vll(V, inf));\n        vllvll dist(V, vll(V, inf));\n\n        rep(i, 0, E) {\n            ll s, t, d;\n            cin >> s >> t >> d;\n            dist[s][t] = d;\n        }\n\n        dp[0][0] = 0;\n\n        rep(bit, 0, (1LL<<V)) {\n            rep(from, 0, V) {\n                if (dp[bit][from] == inf) continue;\n                rep(to, 0, V) {\n                    if (bit & (1LL<<to)) continue;\n                    chmin(dp[bit + (1LL<<to)][to], dp[bit][from] + dist[from][to]);\n                }\n            }\n        }\n\n        if (dp.back()[0] < big) {\n            cout << dp.back()[0] << endl;\n        } else {\n            cout << -1 << endl;\n        }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp(1 << V, vector<int>(V, INF));\n\tdp[(1 << V) - 1][0] = 0;\n\tfor(int bits=(1<<V)-1;bits>=0;bits--){\n\t\trep(i, 0, V)rep(j, 0, V) {\n\t\t\tif (!(bits&(1 << j)))\n\t\t\t\tchmin(dp[bits][i], dp[bits ^ (1 << j)][j] + G[i][j]);\n\t\t}\n\t}\n\tcout << (dp[0][0] == INF ? -1 : dp[0][0] )<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\nint n, m;\nauto d = make_vec<int>(20, 20);\nauto memo = make_vec<int>(1 << 16, 20);\nint dp(int bit, int now) {\n    if (memo[bit][now] != -1) return memo[bit][now];\n    if (bit == 1 && now == 0) return memo[bit][now] = 0;\n    int ret = INF;\n    int pbit = bit & ~(1 << now);\n    rep(pre, n) {\n        if (!(pbit & (1 << pre))) continue;\n        chmin(ret, dp(pbit, pre) + d[pre][now]);\n    }\n    return memo[bit][now] = ret;\n}\nint main() {\n    cin >> n >> m;\n    rep(i, n) rep(j, n) d[i][j] = INF;\n    rep(i, m) {\n        int s, t, x;\n        cin >> s >> t >> x;\n        d[s][t] = x;\n    }\n    rep(i, 1 << 16) rep(j, 20) memo[i][j] = -1;\n    int ans = INF;\n    rep(i, n) chmin(ans, dp((1 << n) - 1, i) + d[i][0]);\n    cout << (ans == INF ? -1 : ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nstruct edge {\n  ll from;\n  ll to;\n  ll cost;\n};\n\nll n, E;\nvector<vector<edge>> g;\n// dp[i][j] .. i is state bit, j is last element. Total number when start from (i,j).\nvector<vector<ll>> dp;\n\n// state .. bit representation, v .. last reached\nll rec(ll state, ll v) {\n  if (dp[state][v] < INF) { return dp[state][v]; }\n  if ((state == (1ll<<n)-1) && v == 0) { // returned to 0.\n    return dp[state][v] = 0;\n  }\n\n  bool found = false;\n  for (edge& e : g[v]) {\n    if ((state&(1ll<<e.to)) == 0) { // e.to is not reached yet\n      ll now = rec(state|(1ll<<e.to), e.to);\n      if (now >= 0) {\n        found = true;\n        chmin(dp[state][v], now + e.cost);\n      }\n    }\n  }\n  if (!found) { return dp[state][v] = -1; }\n  return dp[state][v];\n}\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  cin >> n >> E;\n  g.resize(n);\n  dp.assign(1ll<<n, vector<ll>(n, INF));\n\n  rep(i, E) {\n    ll s, t, d;\n    cin >> s >> t >> d;\n    g[s].push_back({ s, t, d });\n  }\n\n  ll ans = rec(0, 0); // start from 0.\n  if (ans >= 0) {\n    cout << ans << endl;\n  } else { // invalid\n    cout << -1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int INF = 1LL << 60;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int V,E; cin >> V >> E;\n  vector< vector<int> > G(V,vector<int> (V,INF));\n  for(int i = 0; i < E; i++){\n    int s,t,d; cin >> s >> t >> d;\n    G[s][t] = d;\n  }\n\n  vector< vector<int> > dp(1 << V,vector<int> (V,-1));\n  function< int(int,int) > rec =\n  [&](int S,int v){ //{すでに訪れた頂点,現在位置}\n    if(dp[S][v] >= 0) return dp[S][v];\n    if(S == (1 << V)-1 && v == 0){\n      //全ての頂点を訪れて戻ってきた\n      return dp[S][v] = 0;\n    }\n\n    int res = INF;\n    for(int u = 0; u < V; u++){\n      if(!(1 & S >> u)){\n        res = min(res,rec(S | 1 << u,u) + G[v][u]);\n      }\n    }\n    return dp[S][v] = res;\n  };\n\n  int ans = rec(0,0);\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define int long long\n#define P pair<int,int>\n\nconst int MAX_V = 18;\nconst int INF = 1e18;\n\nint V,E;\nint d[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\n\nint rec(int S, int v){\n    if(dp[S][v] >= 0){\n        return dp[S][v];\n    }\n\n    if(S == (1 << V) - 1 && v == 0){\n        return dp[S][v] = 0;\n    }\n\n    int res = INF;\n    for(int u = 0; u < V; u++){\n        if(!(S >> u & 1)){\n            res = min(res, rec(S | 1 << u, u) + d[v][u]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nsigned main() {\n    cin >> V >> E;\n    memset(dp,-1,sizeof(dp));\n\n    rep(i,MAX_V) rep(j,MAX_V) d[i][j] = INF;\n    for (int i = 0; i < E; i++) {\n        int a,b,c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    int ans = rec(0,0);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll;\nconst int INF = 10000000;\nint n, e;\nint d[15][15], dp[1 << 15][15];\nint rec(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) return dp[s][v] = 0;\n\telse if (dp[s][v] != -1) return dp[s][v];\n\telse {\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!(s >> i & 1)) res = min(res, d[v][i] + rec(s | 1 << i, i));\n\t\t}\n\t\treturn dp[s][v] = res;\n\t}\n}\nint main() {\n\tcin >> n >> e;\n\tfill(d[0], d[15], INF);\n\tfill(dp[0], dp[1 << 15], -1);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, dis; cin >> s >> t >> dis;\n\t\td[s][t] = dis;\n\t}\n\tif (rec(0, 0) > 10000000) cout << -1 << endl;\n\telse cout << rec(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint dp[1<<20][20];\nint d[20][20];\nint main(){\n\tint V,E;\n\tcin>>V>>E;\n\tfor(int i =0;i <(1<<20);i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i =0;i < V;i++){\n\t\tfor(int j =0;j < V;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor(int i =0;i < E;i++){\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\td[x][y] =c;\n\t}\n\tdp[1][0]=0;\n\tfor(int i =0;i <(1<<V);i++){\n\t\tfor(int j =0;j <V;j++){\n\t\t\tif((i>>j&1)==0)continue;\n\t\t\tfor(int k =0;k < V;k++){\n\t\t\t\tif((i>>k&1)==1)continue;\n\t\t\t\tdp[i|(1<<k)][k] =min(dp[i|(1<<k)][k],dp[i][j]+d[j][k]);\n\t\t\t\t//cout <<\"dp = \"<<dp[i|(1<<k)][k]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans =INF;\n\tfor(int i =0;i <V;i++){\n\t\tans =min(ans,dp[(1<<V)-1][i]+d[i][0]);\n\t}\n\tif(ans>=INF){\n\t\tcout <<-1<<endl;\n\t}else{\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define erep(i,a,b) for(int i=a;i<=(int)(b);++i)\n#define per(i,a,b) for(int i=(b);i>(a);--i)\n#define eper(i,a,b) for(int i=((int)(a));i>=b;--i)\n#define pb push_back\n#define mp make_pair\n#define INF (1<<28)-1\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a, b)*b;}\n\nint n, m, d[16][16], dp[(1<<16)][20], ans;\nint main() {\n ios::sync_with_stdio ( false );\n cin.tie ( 0 );\n    cin >> n >> m;\n    rep(i, 0, 16) rep(j, 0, 16) d[i][j] = INF;\n    rep(i, 0, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    rep(i, 0, (1 << n)) rep(j, 0, n) dp[i][j] = INF;\n    dp[0][0] = 0;\n    rep(i, 0, (1<<n)) {\n        rep(j, 0, n) {\n            if (!((1<<j) & i)) {\n                rep(k, 0, n) \n                    dp[i | (1<<j)][j] = min(dp[i | (1<<j)][j], dp[i][k] + d[k][j]);\n            }\n        }\n    }\n    if (dp[(1<<n)-1][0] == INF) ans = -1;\n    else ans = dp[(1<<n)-1][0];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma warning(disable: 4244) // 最悪をします\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream& operator<<(ostream& o, const vector<T>& v)\n{\n\to << \"{\"; for (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream& operator<<(ostream& o, const vector<T>& v)\n{\n\tfor (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0), cap(0), rev(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w), cap(0), rev(0) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nclass elem {\npublic:\n\tint dist;\n\tint num;\n\telem(int dist, int num) {\n\t\tthis->dist = dist;\n\t\tthis->num = num;\n\t}\n\telem() {\n\t\tdist = LL_HALFMAX;\n\t\tnum = 0;\n\t}\n};\n\nint dp[1 << 16][16];\nint G[16][16];\n\nsigned main() {\n\tint V, E;\n\tcin >> V >> E;\n\n\trep(i, 16) rep(j, 16) G[i][j] = LL_HALFMAX;\n\trep(i, (1LL << 16)) rep(j, 16) dp[i][j] = LL_HALFMAX;\n\n\trep(i, E) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\n\tdp[0][0] = 0;\n\n\trep(S, (1LL << V)) {\n\t\trep(i, V) {\n\t\t\tif (dp[S][i] == LL_HALFMAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(u, V) {\n\t\t\t\tif (G[i][u] == LL_HALFMAX) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (S & (1LL << u)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchmin(dp[S | (1LL << u)][u], dp[S][i] + G[i][u]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[(1 << V) - 1][0] == LL_HALFMAX) {\n\t\tcout << -1 << \"\\n\";\n\t}\n\telse {\n\t\tcout << dp[(1 << V) - 1][0] << \"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tint ans(INF);\n\tvector<vector<int>>dp((1 << V), vector<int>(V, INF));\n\trep(k, 0, 1) {\n\t\tdp[(1 << V) - 1][k] = 0;\n\n\n\t\tfor (int bits = (1 << V) - 1 - 1; bits >= 0; bits--) {\n\t\t\trep(i, 0, V) {\n\t\t\t\t// current point\n\t\t\t\trep(j, 0, V) {\n\t\t\t\t\tif (!(bits&(1 << j))) {// not yet\n\t\t\t\t\t\tchmin(dp[bits][i], dp[bits | (1 << j)][j] + G[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\tchmin(ans, dp[0][k]);\n\t}\n\tcout << (ans==INF?-1:ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 987654321\nint V, E, A[15][15], MEMO[15][32768], VISIT[15][32768];\nvoid input(void);\nvoid init_A(void);\nvoid init_MEMO(void);\nint DP(int dest, int VIA);\nint TSP(void);\nint main(void) {\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    printf(\"%d\\n\", TSP());\n    return 0;\n}\nint TSP(void){\n    int i, VIA_init, min = MAX;\n    for(i = 0; i < V; i++){\n        init_MEMO();\n        VIA_init = (1 << V) - 1 & ~(1 << i);\n        int cnd = DP(i, VIA_init);\n        if (cnd < min) min = cnd;\n    }\n    if (min >= MAX)\n        return -1;\n    else\n        return min;\n}\nint DP(int dest, int VIA){ // single source memoization\n    if(VIA == 0) return A[0][dest];\n    if(VISIT[dest][VIA] == 1) return MEMO[dest][VIA];\n    VISIT[dest][VIA] = 1;\n    int i, min = MAX;\n    for (i = 1; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    MEMO[dest][VIA] = min;\n    return min;\n}\n/*\nint DP(int dest, int VIA){ // single source backward tracking\n    if(VIA == 0) return A[0][dest];\n    int i, min = MAX;\n    for (i = 1; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    return min;\n}*/\nvoid input(void){\n    scanf(\"%d%d\", &V, &E);\n    init_A();\n    int i, s, t, d;\n    for(i = 0; i < E; i++){\n        scanf(\"%d%d%d\", &s, &t, &d);\n        A[s][t] = d;\n    }\n}\nvoid init_A(void){\n    int i, j;\n    for(i = 0; i < V; i++)\n        for(j = 0; j < V; j++) A[i][j] = -1;\n}\nvoid init_MEMO(void){\n    int i, j;\n    for(i = 0; i < V; i++){\n        for(j = 0; j < (1<<V); j++){\n            MEMO[i][j] = 0;\n            VISIT[i][j] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tlong long int V, E;\n\tcin >> V >> E;\n\t\n\tlong long int cost[V][V];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tcost[u][v] = c;\n\t}\n\t\n\tlong long int DP[V][(1 << V)];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < (1 << V); j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tDP[0][0] = 0;\n\t\n\tfor(int i = 0; i < (1 << V); i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tint hoge = i - (1 << j);\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tDP[j][i] = min(DP[j][i], DP[k][hoge] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = DP[0][(1 << V) - 1];\n\tif(ans == INF){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\nstruct edge{\n    int to,cost;\n    edge(int a,int b):to(a),cost(b){}\n};\n\nint dp[1<<16][15];\nint N,M;\nvector<edge>G[15];\n\nint solve(int s){\n    fill_n(*dp,(1<<16)*15,INF);\n    dp[0][s]=0;\n\n    for(int i=0;i<(1<<N);i++){\n        for(int j=0;j<N;j++){\n            if(dp[i][j]==INF)continue;\n            for(int k=0;k<G[j].size();k++){\n                edge &e=G[j][k];\n                if(i>>e.to&1)continue;\n                dp[i|(1<<e.to)][e.to]=min(dp[i|(1<<e.to)][e.to],dp[i][j]+e.cost);\n            }\n        }\n    }\n\n    return dp[(1<<N)-1][s];\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n\n    int mi=INF;\n\n    for(int i=0;i<N;i++)mi=min(mi,solve(i));\n    \n    if(mi==INF)cout<<-1<<endl;\n    else cout<<mi<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1<<15][15],d[15][15],a,b,c,n,p,INF=1<<30;\nint rec(int s,int v){\n\tif(dp[s][v]!=-1)return dp[s][v];\n\tif(s==(1<<n)-1&&v==0)return 0;\n\tint res=INF;\n\tfor(int i=0;i<n;i++)if(!(s>>i&1)&&d[v][i]!=-1)res=min(res,rec(s|(1<<i),i)+d[v][i]);\n\treturn dp[s][v]=res;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(d,-1,sizeof(d));\n\tcin>>n>>p;\n\tfor(int u=0;u<p;u++)cin>>a>>b>>c,d[a][b]=c;\n\tcout<<(INF==(a=rec(0,0))?-1:a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(n); ++i)\n#define repr(i, a, b) for (int i=a; i<(b); ++i)\n#define reprev(i, n) for (int i=n-1; i>=0; --i)\n#define reprrev(i, a, b) for (int i=b-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int MAX_N = 15;\n\nint n;\nint d[MAX_N][MAX_N];\n// 既に通った集合がSで、現在場所がvのとき、まだ通っていない全てを巡って、0に到達するときの最小コストがdp(S)(v)\nint dp[1<<MAX_N][MAX_N];\n\nconst ll INF = 100100100100100100;\nconst int iINF = 1000000000;\n\nint dfs(int S, int v) {\n    // cout << S << \" \" << v << endl;\n    \n    if (dp[S][v] >= 0) {\n        return dp[S][v];\n    }\n    if (S == (1 << n) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    int res = iINF;\n    rep(u, n) {\n        if (!(S >> u & 1) && d[v][u] != -1) {\n            // Sのu桁目が集合になければ\n            res = min(res, dfs(S | 1 << u, u) + d[v][u]);\n            // Sのu桁目に1を立てて、場所はu + vからuへの距離\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    cout << fixed << setprecision(10);\n\n    cin >> n;\n    int ne; cin >> ne;\n\n    // memset(dp, -1, sizeof(dp));\n    // memset(d, iINF, sizeof(d));\n    rep(i, MAX_N) {\n        rep(j, MAX_N) {\n            d[i][j] = -1;\n        }\n    }\n    rep(i, 1 << MAX_N) {\n        rep(j, MAX_N) {\n            dp[i][j] = -1;\n        }\n    }\n\n    rep(i, ne) {\n        int f, t, v; cin >> f >> t >> v;\n        d[f][t] = v;\n    }\n    /*\n    rep(i, n) {\n        rep(j, n) {\n            cout << d[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    int ans = dfs(0, 0);\n    if (ans == iINF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=(m); i<(int)(n); i++)\n#define RREP(i,m,n) for(int i=(int)(n-1); i>=m; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define fi first\n#define se second\n#define debug(...) {cerr<<\"[L\"<<__LINE__<<\"] \"; _debug(__VA_ARGS__);}\n\ntemplate<typename T>\nstring join(const vector<T>&v, string del=\", \"){ stringstream s;\n    for(auto x : v) s << del << x; return s.str().substr(del.size());\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<T>&v){\n    if(v.size()) o << \"[\" << join(v) << \"]\"; return o;\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<vector<T> >&vv){\n    int l = vv.size();\n    if(l){ o<<endl; rep(i,l) o << (i==0 ? \"[ \" : \",\\n  \" ) << vv[i] << (i==l-1 ? \" ]\" : \"\"); }\n    return o;\n}\ninline void _debug(){cerr<<endl;}\ntemplate<class First, class... Rest>\nvoid _debug(const First& first, const Rest&... rest){cerr<<first<<\" \";_debug(rest...);}\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst double PI = (1*acos(0.0));\nconst double EPS = 1e-9;\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst ll mod = 1e9 + 7;\n\ninline void finput(string filename) {\n    freopen(filename.c_str(), \"r\", stdin);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    // finput(\"./input\");\n    int V, E; cin >> V >> E;\n    int g[20][20];\n    rep(i,20) rep(j,20) g[i][j] = -1;\n    rep(i,E){\n        int s,t,d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    vvi dp(1<<V, vi(V, INF));\n    dp[0][0] = 0;\n    rep(bit,1<<V){\n        rep(i,V){\n            rep(j,V){\n                if(bit>>j & 1 || g[i][j] == -1) continue;\n                dp[bit|(1<<j)][j] = min(dp[bit|(1<<j)][j], dp[bit][i] + g[i][j]);\n            }\n        }\n    }\n    int ans = dp[(1<<V)-1][0] == INF ? -1 : dp[(1<<V)-1][0];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define VI vector<int>\n#define VB vector<bool>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nconst std::string YES = \"YES\";\nconst std::string Yes = \"Yes\";\nconst std::string NO = \"NO\";\nconst std::string No = \"No\";\n\nusing namespace std;\n\n#define INF (int)1e9\n\n\nint N;\nvector<vector<int>> graph;\nvector<vector<int>> dp; // dp[状態][今いるところ] = 総距離\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) {\n        return dp[S][v];\n    }\n\n    // すべて巡回して0に戻ってきた\n    if(S == (1 << N) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    int tmp = INF;\n    FOR(u, 0, N) {\n        // まだuにいってない\n        if(not (S >> u & 1)) {\n            tmp = min(tmp, rec(S | 1 << u, u) + graph[v][u]);\n        }\n    }\n    return dp[S][v]=tmp;\n}\n\nint main() {\n    int m;\n    cin >> N >> m;\n    graph.resize(N, vector<int>(N, INF));\n\n    FOR(i, 0, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a][b] = c;\n    }\n    dp.resize(1 << N, vector<int>(N, -1));\n    int ans = rec(0, 0);\n    if (ans == INF) {\n        ans = -1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nvector<edge> graph[16];\nint dp[16][1 << 16];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n\n    REP(i, E)\n    {\n        int s, t, d;\n\n        cin >> s >> t >> d;\n\n        graph[s].push_back(edge{t, d});\n    }\n\n    REP(i, V)\n    {\n        REP(j, 1 << V)\n        {\n            dp[i][j] = iINF;\n        }\n    }\n\n    REP(i, V)\n    {\n        dp[i][0] = 0;\n    }\n\n    REP(S, 1 << V)\n    {\n        REP(i, V)\n        {\n            if (dp[i][S] == iINF)\n                continue;\n\n            for (auto e : graph[i])\n            {\n\n                if ((S >> e.to) & 1)\n                    continue;\n\n                dp[e.to][S | 1 << e.to] = min(dp[e.to][S | 1 << e.to], dp[i][S] + e.cost);\n            }\n        }\n    }\n\n    cout << (dp[0][(1 << V) - 1] == iINF ? -1 : dp[0][(1 << V) - 1]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\n#define INF 1<<15\n\nint main(){\n\tint n,m;\n\tint s,t,d;\n\tint e[15][15];\n\tint dp[1<<15][15];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<15;i++) fill_n(e[i],15,INF);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d %d\",&s,&t,&d);\n\t\te[s][t]=d;\n\t}\n\t\n\tfor(int i=0;i<(1<<n);i++) fill_n(dp[i],n,INF);\n\tdp[(1<<n)-1][0]=0;\n\t\n\tfor(int i=(1<<n)-2;i>=0;i--){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(!(i>>k&1))\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i|1<<k][k]+e[j][k]);\n\t\t\t\tprintf(\"dp[%d][%d]=%d\\n\",i,j,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(dp[0][0]==INF ? -1 : dp[0][0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define INF (1 << 30)\n#define ll long long\n#define MAX_N 16\nusing namespace std;\n\nll V, E;\nll G[MAX_N][MAX_N];\nll dp[1 << MAX_N][MAX_N];\n\nll rec(int S, int v) {\n\tif (dp[S][v] >= 0) {\n\t\treturn dp[S][v];\n\t}\n\n\tif (S == (1 << V) - 1 && v == 0) {\n\t\treturn dp[S][v] = 0;\n\t}\n\n\tll res = INF;\n\tfor (int u = 0; u < V; u++) {\n\t\tif (!(S >> u & 1)) {\n\t\t\tres = min(res, rec(S | 1 << u, u) + G[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> V >> E;\n\tfor (int i = 0; i < MAX_N;i++) {\n\t\tfor (int j = 0; j < MAX_N;j++) {\n\t\t\tG[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define ALL(a) (a).begin(), (a).end()\n\ntemplate <class T>\ninline bool chmin(T &a, const T b){\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, const T b){\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing DoP = pair<double, double>;\nusing edge = struct { int to; double cost;}; // edge x = {to, cost}\n\nconst int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int INF = 1<<29;\nconst ll INF64 = 1ll << 45;\nconst int mod = 1000000007;\n\nstruct mint\n{\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint operator-() const { return mint(-x); }\n  mint &operator+=(const mint a)\n  {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a)\n  {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a)\n  {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const\n  {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const\n  {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const\n  {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const\n  {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const\n  {\n    return pow(mod - 2);\n  }\n  mint &operator/=(const mint a)\n  {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const\n  {\n    mint res(*this);\n    return res /= a;\n  }\n};\n// h(n, r) = c(n+r-1, r)\nstruct combination\n{\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1)\n  {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k)\n  {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nint V, E;\nvector<vector<int>> g(20, vector<int>(20, INF));\nvector<vector<int>> dp(50000, vector<int>(20, 0));\n\nint rec(int s = (1<<V)-1, int v = 0) {\n  if(s == 0 && v == 0) return 0;\n  if(s == 0 && v != 0) return INF;\n  if(!(s & 1<<v)) return INF;\n\n  if(dp[s][v] != 0) return dp[s][v];\n  dp[s][v] = INF;\n  rep(u, V) chmin(dp[s][v], rec(s^(1<<v), u) + g[u][v]);\n  return dp[s][v]; \n}\n\nint main(){\n  cin >> V >> E;\n\n  rep(i, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g[s][t] = d;\n  }\n  int ans = rec();\n  if(ans != INF) cout << ans << endl;\n  else cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <algorithm>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int inf=1<<30;\nconst double pi=acos(-1);\n\nint V,E;\nvector<vector<int> > G,dp;\n\nint func(int S,int v){\n\tif(dp[S][v]!=inf&&dp[S][v]>=0) return dp[S][v];\n\tif(S==(1<<V)-1&&v==0) return dp[S][v]=0;\n\tint tmp=inf;\n\tfor(int i=0;i<V;i++){\n\t\tif(G[v][i]==inf) continue;\n\t\tif(!(S>>i&1)) tmp=min(tmp,func(S|1<<i,i)+G[v][i]);\n\t}\n\treturn dp[S][v]=tmp;\n}\n\nint main(){\n\tcin>>V>>E;\n\tG=vector<vector<int> >(V,vector<int>(V,inf));\n\tfor(int i=0;i<E;i++){\n\t\tint s,t,d;\n\t\tcin>>s>>t>>d;\n\t\tG[s][t]=d;\n\t}\n\tdp=vector<vector<int> >(1<<V,vector<int>(V,inf));\n\tint ans=func(0,0);\n\tif(ans==inf) cout<<-1<<endl;\n\telse cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n        graph[i][i] = 0;\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(k == j || ((1 << k) & tmp) == 0 || result[tmp][k].first == mod || graph[k][j] == mod) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    for(int i = 0; i < v; i++){\n        if(result[(1 << v) - 1][i].first == mod) continue;\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}a\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (sum == -1 || sum < Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint v, n, dis[15][15];\nint dp[(1 << 15)][15];\nconst int INF = 100000000;\n\nint main() {\n\tcin >> v >> n;\n\tfor (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dis[i][j] = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdis[a][b] = c;\n\t}\n\tfor (int i = 0; i < (1 << v); i++)for (int j = 0; j < v; j++)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << v) - 1; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (i && !(i & (1 << j)))continue;\n\t\t\tfor (int k = 0; k < v; k++) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif (!(i & (1 << k))) {\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dis[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << v) - 1][0] == INF)cout << -1 << endl;\n\telse cout << dp[(1 << v) - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do { cout << x << endl; return 0; } while(0)\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nint main(void)\n{\n\tll V, E; cin >> V >> E;\n\tvvt<ll> mg; MakeVVT(V, V, mg, -1LL);\n\trep(i, 0, E)\n\t{\n\t\tll s, t, d; cin >> s >> t >> d;\n\t\tmg[s][t] = d;\n\t}\n\tvvt<ll> dp; MakeVVT(Pow2(V), V, dp, Pow10(5));\n\tdp[Pow2(V) - 1][0] = 0;\n\n\trepr(S, Pow2(V) - 2, -1) rep(m, 0, V) rep(t, 0, V)\n\t{\n\t\tif (!(S >> t & 1) && mg[m][t] != -1) dp[S][m] = min(dp[S][m], dp[S | Pow2(t)][t] + mg[m][t]);\n\t}\n\n\tif (dp[0][0] == Pow10(5)) output(-1);\n\tcout << dp[0][0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nconst int INF=10000000;\nbool checked(int chouten,int i){\n  if( ((1<<i)&chouten)){\n    return true;\n  }\n  else return false;\n}\nint pluscheck(int chouten,int i){\n  return (chouten|(1<<i));\n}\n\nint graph[16][16];\nint dynamic[((1<<16)-1)][16];\nint V,E;\n\n\nint roop(int chouten,int genzai){\n  //cout<<\"hehe\"<<chouten<<' '<<genzai<<' '<<len<<endl;;\n  if(dynamic[chouten][genzai]!=-1)\n    return dynamic[chouten][genzai];\n  if(chouten==(1<<(V))-1){\n    if(genzai==0)  \n      return 0;\n    else return INF;\n  }\n  else{\n    int newlen,out;\n    out=INF;\n    for(int i=0;i<16;i++){\n      if(checked(chouten,i)) continue;\n      if(graph[genzai][i]){\n\t//\tnewlen=len+graph[genzai][i];\n\tout=min(out,roop(pluscheck(chouten,i),i)+graph[genzai][i]);\n      }\n    }\n    return out;\n  }\n}\nint main(){\n  cin>>V>>E;\n  int s,t,d;\n  for(int i=0;i<16;i++){\n    for(int j=0;j<16;j++){\n      graph[i][j]=0;\n    }\n  }\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>d;\n    graph[s][t]=d;\n  }\n  for(int i=0;i<((1<<16)-1);i++){\n    for(int j=0;j<16;j++){\n      dynamic[i][j]=-1;\n    }\n  }\n  int rinzi=roop(0,0);\n  if (rinzi<INF)\n    cout<<rinzi<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint dp[(1 << 15)][15];\nint d[15][15];\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = INF;\n        }\n    }\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    int ans = INF;\n    rep(id,n){\n        rep(i,(1 << n)){\n            rep(j,n){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][id] = 0;\n        rep(i,1<<n){\n            rep(j,n){\n                rep(k,n){\n                    if(!(i & (1 << k)) && j != k){\n                        dp[i|(1<<k)][j] = min(dp[i|(1<<k)][j],dp[i][k] + d[k][j]);\n                    }\n                }\n            }\n        }\n        rep(i,n){\n            ans = min(ans,dp[(1<<n)-1][id]);\n        }\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nlong long int result[(1 << 15)][15][15];\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tlong long int graph[16][16];\n\tfor(int i = 0; i < v; i++){\n\t\tfor(int j = 0; j < v; j++){\n\t\t\tgraph[i][j] = mod;\n\t\t\tfor(int k = 0; k < (1 << v); k++){\n\t\t\t\tresult[k][i][j] = mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < e; i++){\n\t\tint s, t;\n\t\tlong long int d;\n\t\tcin >> s >> t >> d;\n\t\tgraph[s][t] = d;\n\t}\n\tfor(int i = 0; i < v; i++){\n\t\tresult[(1 << i)][i][i] = 0;\n\t}\n\tfor(int i = 1; i < (1 << v); i++){\n\t\tfor(int s = 0; s < v; s++){\n\t\t\tfor(int j = 0; j < v; j++){\n\t\t\t\tif(result[i][j][s] == mod) continue;\n\t\t\t\tfor(int k = 0; k < v; k++){\n\t\t\t\t\tif((i & (1 << k)) > 0) continue;\n\t\t\t\t\tresult[i | (1 << k)][k][s] = min(result[i | (1 << k)][k][s], result[i][j][s] + graph[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = mod;\n\tfor(int i = 0; i < v; i++){\n\t\tfor(int j = 0; j < v; j++){\n\t\t\tans = min(ans, result[(1 << v) - 1][i][j] + graph[i][j]);\n\t\t}\n\t}\n\tif(ans == mod) ans = -1;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_V = 17;\nconst int INF = 1e9;\n\nint traveling_salesman(int V, int G[MAX_V][MAX_V]){\n  int dp[(1 << V)][V];\n  REP(i, (1 << V)) REP(j, V) dp[i][j] = INF;\n  dp[0][0] = 0;\n  REP(i, (1 << V)){\n    REP(j, V){\n      REP(k, V){\n        int mask = (1 << k), cost = G[j][k];\n        if((i & mask) || cost < 0) continue;\n        dp[(i | mask)][k] = min(dp[(i | mask)][k], dp[i][j] + cost);\n      }\n    }\n  }\n  int ans = INF;\n  REP(i, V) ans = min(ans, dp[(1 << V) - 1][i]);\n  return ans;\n}\n\nint main() {\n  int G[MAX_V][MAX_V];\n  int V, E; cin >>V >>E;\n  memset(G, -1, sizeof(G));\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    G[f][t] = c;\n  }\n  int ans = traveling_salesman(V, G);\n  cout <<(ans == INF ? -1 : ans) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nint n,m,dp[(1 << 16)][15];\nvector<P> g[15];\n\nint solve(int s){\n\tREP(i, 0, (1 << 16)) REP(j, 0, 15) dp[i][j] = INF;\n\tdp[0][s] = 0;\n\t\n\tREP(i, 0, (1 << n)){\n\t\tREP(j, 0, n){\n\t\t\tif(dp[i][j] == INF) continue;\n\t\t\tfor(auto e:g[j]){\n\t\t\t\tif((i >> e.first) & 1) continue;\n\t\t\t\tdp[i | (1 << e.first)][e.first] = min(dp[i | (1 << e.first)][e.first], dp[i][j] + e.second);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[(1 << n) - 1][s];\n}\n\nint main(){\n\tcin >> n >> m;\n\tREP(i,0,m){\n\t\tint a,b,c; cin >> a >> b >> c;\n\t\tg[a].push_back({b, c});\n\t}\n\t\n\tint mi = INF;\n\tREP(i,0,n) mi = min(mi, solve(i));\n\tcout << (mi == INF ? -1 : mi) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n#include<bitset>\nusing namespace std;\n\n\nint v,es,st;\nint ans=1<<21;\nint t1,t2,t3;\nconst int inf = 1<<21;\nint G[21][21];\nint null=-1;\nlong long int dp[1<<15+1][21];\n\n\n\nint rec(long long int s,int i){\n    //cout << \"hikisuu is s,i \" << bitset<5>(s) << \" \" << i << endl;\n    //cout << bitset<5>(s) << endl;\n    if(s == (1<<v)-1 && i == st){\n        //cout << \"hekk\" << endl;\n        dp[s][i] = 0;\n        return 0;\n    }\n    if(dp[s][i] != null) return dp[s][i];\n\n    int res = inf;\n    for(int j=0;j<v;j++){//j is last pushed to s - {i}\n        \n        if((s & (1<<j))) continue;\n        if(res > rec(s|(1<<j),j)+G[i][j]){\n            res = rec(s|(1<<j),j)+G[i][j];\n            //cout << st << \" \" << bitset<6>(s) << \" \" << i << \"->\" << j << \" \" << res << endl; \n        }\n    }\n    dp[s][i] = res;\n    //cout << \"s and s_pre is \" << bitset<5>(s) << \" \" << bitset<5>(s_pre) << \" \" << res << endl;\n    //cout << j1 << \"->\" << i1 << \" cost = \" << G[j1][i1] << endl;\n    //cout << res << endl;\n    return res;\n}\n\nint main(){\n\n    for(int i=0;i<21;i++){\n        for(int j=0;j<21;j++){\n            G[i][j] = inf;\n        }\n    }\n\n    cin >> v >> es;\n    for(int i=0;i<es;i++){\n        cin >> t1 >> t2 >> t3;\n        G[t1][t2] = t3;\n    }\n\n    for(int i=0;i<(1<<15) + 1;i++){\n        for(int j=0;j<21;j++){\n            dp[i][j] = null;\n        }\n    }\n    for(int k=0;k<v;k++){\n        st = k;\n        ans = min(rec(0,k),ans);\n\n        for(int i=0;i<(1<<15) + 1;i++){\n            for(int j=0;j<21;j++){\n                dp[i][j] = null;\n            }\n        }\n    }\n\n    if(ans!=inf){\n        cout << ans << endl;\n    }\n    else cout << -1 << endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1145141919;\nvector <vector<int>> d(15,vector <int>(15,-1));\nvector <vector<int>> dp(1<<15,vector <int>(15,-1));\nint V,E;\nint rec(int S, int now){\n    if(dp[S][now]!=-1) return dp[S][now];\n    if(S==(1<<V)-1&&now==0) return 0;\n    int r=INF;\n    for(int next=0;next<V;next++){\n        if(d[now][next]!=-1 && !(S & (1<<next)))\n        r = min(r, rec(S|(1<<next), next)+d[now][next]);\n    }\n    dp[S][now]=r;\n    return r;\n}\nint main(void){\n    cin>>V>>E;\n    for(int i=0;i<E;i++){\n        int a,b; cin>>a>>b; cin>>d[a][b];\n    }\n    int ans = rec(0,0);\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nconst int INF=10000000;\nbool checked(int chouten,int i){\n  if( ((1<<i)&chouten)){\n    return true;\n  }\n  else return false;\n}\nint pluscheck(int chouten,int i){\n  return (chouten|(1<<i));\n}\n\nint graph[16][16];\nint dynamic[((1<<16)-1)][16];\nint V,E;\n\n\nint roop(int chouten,int genzai){\n  //cout<<\"hehe\"<<chouten<<' '<<genzai<<' '<<len<<endl;;\n  if(dynamic[chouten][genzai]!=-1)\n    return dynamic[chouten][genzai];\n  if(chouten==(1<<(V))-1){\n    if(genzai==0)  \n      return 0;\n    else return INF;\n  }\n  else{\n    int newlen,out;\n    out=INF;\n    for(int i=0;i<16;i++){\n      if(checked(chouten,i)) continue;\n      if(graph[genzai][i]!=INF){\n\t//\tnewlen=len+graph[genzai][i];\n\tout=min(out,roop(pluscheck(chouten,i),i)+graph[genzai][i]);\n      }\n    }\n    return out;\n  }\n}\nint main(){\n  cin>>V>>E;\n  int s,t,d;\n  for(int i=0;i<16;i++){\n    for(int j=0;j<16;j++){\n      graph[i][j]=INF;\n    }\n  }\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>d;\n    graph[s][t]=d;\n  }\n  for(int i=0;i<((1<<16)-1);i++){\n    for(int j=0;j<16;j++){\n      dynamic[i][j]=-1;\n    }\n  }\n  int rinzi=roop(0,0);\n  if (rinzi<INF)\n    cout<<rinzi<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define inf (pow(10,9))\ntypedef pair<int,int> pii ;\n\nint V = 0 ;\nint E = 0 ;\nvector<pii> graph[20] ; // from,{to,cost}\nint dp[ 1 << 15 ][15] = {0} ;\n\nint DP(int bit ,int v )\n{\n    if(dp[bit][v] != inf)return dp[bit][v];\n\n    if ( bit == (1 << V) - 1 && v == 0 )return  dp[bit][v] = 0 ;\n    if ( bit == (1 << V))return dp[bit][v] = inf;\n\n    int res = inf - 1;\n    for( int i = 0; i < graph[v].size(); i++)\n    {\n        pii cmp = graph[v][i] ;\n        if ( !( (bit >> cmp.first) & 1 ) )\n        {\n            res = min( res, DP( bit | ( 1 << cmp.first ), cmp.first ) + cmp.second ) ;\n        }\n    }\n\n    return dp[bit][v] = res ;\n}\n\nint solve()\n{\n    for ( int i = 0 ; i < (1 << V) ; i++ )\n    {\n        for ( int j = 0 ; j < V ; j++ )\n        {\n            dp[i][j] = inf ;\n        }\n    }\n    return DP( 0, 0 ) ;\n}\n\nint main()\n{\n    cin >> V >> E ;\n    for ( int i = 0 ; i < E ; i++ )\n    {\n        int s ,t ,d ;\n        cin >> s >> t >> d ;\n        graph[s].push_back(pii(t,d));\n    }\n    if(solve() != inf)printf(\"%d\\n\", solve()) ;\n    else puts(\"-1\");\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repd(i,a,b) for (int i=(a);i<(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntypedef long long ll;\nconst long long INF = 1LL << 60;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> dis(v, vector<int>(v, 1e9));\n    rep(i, e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dis[s][t] = d;\n    }\n\n    vector<vector<int>> dp((1 << v), vector<int>(v, 1e9));\n\n    rep(i, v) dp[0][0] = 0;\n    rep(s, 1 << v) {\n        rep(now, v) {\n            rep(to, v) {\n                if ((s >> to) & 1 || dis[now][to] == 1e9) continue;\n                chmin(dp[s|(1 << to)][to], dp[s][now] + dis[now][to]);\n            }\n        }\n    }\n\n    int ans = dp[(1 << v) - 1][0];\n    cout << (ans == 1e9 ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint INF = 1e9;\nint dp[(1 << 20) + 1][21];\nint cost[20][20];\nint V, E;\nint dfs(int bit, int v){//vに行く時の最小値を返す\n    if(bit == 0){//初期位置を0とする\n        if(v == 0) return 0;\n        else return INF;\n    }\n    //std::cout << dp[bit][v] << std::endl;\n    if(dp[bit][v] != 1000000000 - 1) return dp[bit][v];//探索済の場合\n    if(!(bit & (1 << v))) return INF;\n    int prebit = bit ^(1 << v);//vを除いた集合\n    int res = INF;//答えを格納\n    for(int u = 0; u < V; u++){//vの前に来る街を探索\n        res = std::min(res, dfs(prebit, u) + cost[u][v]);//値の更新\n    }\n    return dp[bit][v] = res;\n}\nint main(){\n    std::cin >> V >> E;\n    if(E == 0){\n        std::cout << -1 << std::endl;\n        return 0;\n    }\n    for(int i = 0; i < V; i++)for(int j = 0; j < V; j++) cost[i][j] = INF;\n    for(int i = 0; i < E; i++){\n        int s, t, d;\n        std::cin >> s >> t >> d;\n        cost[s][t] = d;\n    }\n    for(int bit = 0; bit < (1 << V); bit++)for(int i = 0; i < V; i++)dp[bit][i] = 1000000000 - 1;\n    int ans = dfs((1 << V) - 1, 0);\n    if(ans == INF) std::cout << -1 << std::endl;\n    else std::cout << ans << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <vector>\n//#include <algorithm>\n\nusing namespace std;\n\n//vector < vector < int > > rebra;\n\nint getbit(int mask, int num)\n{\n    return (mask >> num) &1;\n}\n\nint main()\n{\n    int n, m, a, b, c, l = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        l *= 2;\n    l--;\n    int rebra[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            rebra[i][j] = -1;\n    for (int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            rebra[a][b] = c;\n        }\n    long long dp[l+1][n];\n    for (int i = 0; i <= l; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = -1;\n    dp[1][0] = 0;\n    long long f = 1;\n    for (long long mask = 1; mask <= l; mask++)\n        for (int j = 0; j < n; j++)\n            if ((getbit(mask, j) == 1) && (dp[mask][j] != -1))\n                for (int q = 0; q < n; q++)\n                    if ((rebra[j][q] != -1) && (getbit(mask, q) == 0)){\n                        f = 1;\n                        for (int y = 0; y < q; y++)\n                            f *= 2;\n                        f += mask;\n                        if ((dp[f][q] == -1) || (dp[mask][j] + rebra[j][q] < dp[f][q])){\n                            dp[f][q] = dp[mask][j] + rebra[j][q];\n                            f = 0;\n                            }\n\n                    }\n    int mm = -1;\n    for (int i = 1; i < n; i++)\n        if ((dp[l][i] != -1) && (rebra[i][0] != -1))\n            if (mm == -1){\n                mm = dp[l][i] + rebra[i][0];\n            } else {\n                if ((mm == -1) || (dp[l][i] + rebra[i][0] < mm))\n                    mm = dp[l][i] + rebra[i][0];\n            }\n    /*for (int i = 0; i < n; i++){\n        for (int j = 1; j <= l; j++)\n            cout << dp[j][i] << ' ';\n        cout << endl;\n    }*/\n    cout << mm << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint v,e;\n\tint cost[15][15];\n\tint dp[1 << 15][15];\n\tcin >> v >> e;\n\tfor(int i = 0;i < v;i++){\n\t\tfor(int j = 0;j < v;j++) cost[i][j] = INF;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tcost[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << v);i++){\n\t\tfor(int j = 0;j < v;j++) dp[i][j] = INF;\n\t}\n\tdp[(1 << v) - 1][0] = 0;\n\tfor(int i = (1 << v) - 2;i >= 0;i--){\n\t\tfor(int j = 0;j < v;j++){\n\t\t\tfor(int k = 0;k < v;k++){\n\t\t\t\tif(!(i >> k & 1)){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i | 1 << k][k] + cost[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0] == INF) cout << -1 << endl;\n\telse cout << dp[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <numeric>\n#include<iostream>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<algorithm>\n#include <sstream>\n#include<string.h>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 1000000007\n#define int long long\n#define rep(i,j,n) for(int i=j;i<n;++i)\ntypedef pair<int,int>  P;\nstring alph(\"abcdefghijklmnopqrstuvwxyz\");\nstruct edge{int from,to,cost;};\nvector<edge> G;\ndouble pi = 3.141592653589793;\nP sg[10];\nint a[55],b[55];\nint n,m;\nint d[16][16];\nint dp[1<<16][16];\nint  solve(int s,int v){\n    if(dp[s][v]>=0)return dp[s][v];\n    if(s==(1<<n)-1&&v==0)return dp[s][v]=0;\n    int res=inf;\n    rep(u,0,n){\n        if(!(s>>u&1)){\n            res=min(res,solve(s|1<<u,u)+d[v][u]);\n        }\n    }\n    return dp[s][v]=res;\n}\n\nsigned main(){\ncin>>n>>m;\n    rep(i,0,n)rep(j,0,n)d[i][j]=inf;\n    rep(i,0,m){\n        int a,b,c;cin>>a>>b>>c;\n        d[a][b]=c;\n    }\n    memset(dp,-1,sizeof(dp));\n    cout<<solve(0,0)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define rrep(i, n) for (int i = n - 1; i >= 0; i--)\nusing namespace std;\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int MOD = 1000000007;\nconst int MOD2 = 998244353;\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint V, E;\nint g[20][20];\nint dp[50000][20];\n\nint rec(int S, int v) {  \n    if (S == 0) {\n        if (v == 0) {\n            return 0;\n        } else {\n            return INF;\n        }\n    }\n    if ((S & (1 << v)) == 0) { \n        return INF;\n    }\n \n    int &ret = dp[S][v];\n    if (ret != 0) return ret;\n \n    ret = INF;\n    rep(u, V) { chmin(ret, rec(S ^ (1 << v), u) + g[u][v]); }\n    return ret;\n}\n\nint main(){\n    cin >> V >> E;\n\n    rep(i, 20) {\n        rep(j, 20) { g[i][j] = INF; }\n    }\n    rep(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    int ans = rec((1 << V) - 1, 0);\n \n    if (ans != INF) {\n        cout << ans << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n// Acknowledgement: Special thanks to kyomukyomupurin, who developed this\n// template.\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\n  int n = 0;\n  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::set<T>& st) {\n  int n = 0;\n  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::map<T, U>& mp) {\n  int n = 0;\n  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& vec) {\n  for (T& e : vec) is >> e;\n  return is;\n}\n\n#ifdef LOCAL\n#define debug(...) \\\n  std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out() { std::cerr << '\\n'; }\n\ntemplate <class Head, class... Tail>\nvoid debug_out(Head&& head, Tail&&... tail) {\n  std::cerr << head;\n  if (sizeof...(Tail) != 0) std::cerr << \", \";\n  debug_out(std::forward<Tail>(tail)...);\n}\nusing namespace std;\nusing int64 = long long;\n\nint main() {\n  const int max_n = 15;\n  const int64 inf = 1e8;\n\n  int V, E;\n  cin >> V >> E;\n  int s, t, d;\n  // vector<int> s(E), t(E), d(E);\n  vector<vector<int>> D(V, vector<int>(V, inf));\n  for (int i = 0; i < E; i++) {\n    cin >> s >> t >> d;\n    D[s][t] = d;\n  }\n  // debug(D);\n\n  vector<vector<int64>> dp((1 << max_n), vector<int64>(max_n, inf));\n  // debug(dp);\n\n  dp[(1 << V) - 1][0] = 0;\n\n  for (int64 tmp = (1 << V) - 2; tmp >= 0; tmp--) {\n    bitset<max_n> S(tmp);\n    for (int v = 0; v < V; v++) {\n      if (!S.test(v) && v != 0) continue;\n      for (int u = 0; u < V; u++) {\n        if (!S.test(u)) {\n          dp[tmp][v] = min(dp[tmp][v], dp[tmp | (1 << u)][u] + D[v][u]);\n          // debug(dp[tmp][v]);\n        }\n      }\n    }\n  }\n  int64 ans = dp[0][0];\n  if (ans == inf) ans = -1;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <cstring> //memset(dp,0,sizeof(dp))\n#include <functional>\n#define ll long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back()\n#define ALL(a) (a).begin(),(a).end()\n#define int long long\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> Pll;\n\n//有向グラフ上巡回セールスマン問題\n//verified\nconst ll INF=1e18;\nsigned main(){\n    int n,m; cin >> n >> m;\n    map<P,ll> mp;\n    map<P,bool> ok;\n    rep(i,m){\n        int s,t; ll d;\n        cin >> s >> t >> d;\n        //from s to t\n        mp[{s,t}]=d;\n        ok[{s,t}]=1;\n    }\n    //dp[S][j]:=Sを通ってラストがjの時の、残りの経路の最短　ans:=dp[0][j] for j in [0,n)\n    ll dp[1<<n][n];\n    rep(i,1<<n){\n        rep(j,n){\n            dp[i][j]=INF;\n        }\n    }\n    dp[(1<<n)-1][0]=0;\n    rrep(i,(1<<n)){\n        rep(j,n){\n            rep(k,n){\n                if(!ok[{j,k}]) continue;\n                if(i&(1<<k)) continue;\n                chmin(dp[i][j],dp[i|(1<<k)][k]+mp[{j,k}]);\n            }\n        }\n    }\n    ll res=INF;\n    chmin(res,dp[0][0]);\n    cout << (res==INF ? -1 : res) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tf(v, v', k):- min f(v, v',k - 1) + e(v, v'), \n\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = (1 << 30) - 1;\nconst int mxv = 16;\nint V, E;\nint adj[mxv][mxv], dp[( 1 << mxv )][mxv], a, b, c;\n\n\nint tsp( int v, int bitmask ){\n\n\tif( bitmask == ( 1 << V ) - 1 )\n\t\treturn adj[v][0];\n\n\tif( dp[bitmask][v] < INF )\n\t\treturn dp[bitmask][v];\t\n\n\tfor( int i = 0; i < V; ++i )\n\t\tif( !(bitmask & ( 1 << i ) ) )\n\t\t\tdp[bitmask][v] = min( dp[bitmask][v], adj[v][i] + tsp( i, bitmask|( 1 << i ) ) );\n\treturn dp[bitmask][v];\n}\n\n\n\n\nint main( void ){\n\t\n\t//freopen(\"input.in\", \"r\", stdin);\n\tscanf(\"%d%d\", &V, &E);\n\n\tfor( int i = 0; i < V; ++i )\n\t\tfor( int j = 0; j < V; ++j )\n\t\t\tadj[i][j] = INF;\n\n\tfor( int i = 0; i < ( 1 << V ); ++i )\n\t\tfor( int j = 0; j < V; ++j )\n\t\t\tdp[i][j] = INF;\n\n\tfor( int i = 0; i < E; ++i )\n\t\tscanf(\"%d%d%d\", &a, &b, &c), adj[a][b] = c;\n\t\n\tdp[1][0] = 0;\n\tfor( int i = 1; i < ( 1 << V ); ++i )\n\t\tfor( int j = 0; j < V; ++j ){\n\t\t\tif( !(i & ( 1 << j )) )\n\t\t\t\tcontinue;\n\t\t\tfor( int k = 0; k < V; ++k ){\n\t\t\t\tif( i & ( 1 << k ) )\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i| ( 1 << k )][k] = min( dp[i| ( 1 << k )][k], dp[i][j] + adj[j][k]); \n\t\t\t}\n\t\t}\n\n\tint solve = INF;\n\tfor( int i = 1; i < V; ++i )\n\t\tsolve = min( solve, dp[( 1 << V ) - 1][i] + adj[i][0]);\n\t\n\tprintf(\"%d\\n\", ( solve == INF)?-1:solve);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>//sort,二分探索,など\n#include<bitset>//固定長bit集合\n#include<cmath>//pow,logなど\n#include<complex>//複素数\n#include<deque>//両端アクセスのキュー\n#include<functional>//sortのgreater\n#include<iomanip>//setprecision(浮動小数点の出力の誤差)\n#include<iostream>//入出力\n#include<map>//map(辞書)\n#include<numeric>//iota(整数列の生成),gcdとlcm(c++17)\n#include<queue>//キュー\n#include<set>//集合\n#include<stack>//スタック\n#include<string>//文字列\n#include<utility>//pair\n#include<list>\n#include<vector>//可変長配列\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define all(a) (a).begin(),(a).end()\n#define mp make_pair\n#define pb push_back\n#define ll __int64\n#define __int64 long long\n#define P pair<int,int>\n#define PP pair<P,int>\n#define F first\n#define S second\nint dx[8] = { 1,0,-1,0,1,-1,-1,1 };\nint dy[8] = { 0,1,0,-1,1,1,-1,-1 };\n\nll G[30][30];\nint limit[30][30];\nint n, m;\nll dp[18][1 << 18];\nconst ll INF = 1e18;\n\n\n\nint main() {\n\tcin >> n >> m;\n\n\trep(i, n)rep(j, n)if(i!=j)G[i][j] = INF;\n\trep(i, m) {\n\t\tint a, b, c, t;\n\t\tcin >> a >> b >> c;\n\t\t//a--; b--;\n\t\tG[a][b]= c;\n\t}\n\n\trep(i, n)rep(j, 1 << n)dp[i][j] = INF;\n\n\n\tdp[0][0] = 0;\n\n\trep(i,1<<n){\n\trep(from, n) {\n\t\trep(to, n){\n\t\t\tif (i & (1 << to))\n\t\t\t\tcontinue;\n\t\t\t\tdp[to][i | (1 << to)] = min(dp[to][i | (1 << to)], dp[from][i]+G[from][to]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (dp[0][(1 << n) - 1]==INF? -1:dp[0][(1<<n)-1]) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <utility>\n#include <cmath>\n#include <cstring>\n#include <random>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i<n; ++i)\n#define REP(i,n) for(int i = 1; i<=n; ++i)\n#define all(x) begin(x),end(x)\n#define show(obj) for(auto x:obj)cout<<x<<' ';cout<<endl;\n#define line \"----------\"\ntypedef long long ll;\ntypedef pair<int,int> ip;\ntypedef pair<ll,ll> lp;\nconst int inf = 1001001000;\nconst ll INF = 1LL<<60;\nconst int MOD = (int)1e9 + 7;\n\nint V,E; \nint path[17][17];\nint dp[1<<17][17];\n\n// int solve(int S, int v){\n// \tif(dp[S][v]>=0) return dp[S][v];\n// \tif(S == (1<<V)-1 && v == 0) return dp[S][v] = 0;\n// \tint res = inf;\n// \tfor(int u = 0; u<V; u++){\n// \t\tif(!(S>>u & 1)){ //まだ行っていないところがあったら，そこへ行ってみる\n// \t\t\tres = min(res, solve(S | 1<<u, u) + path[v][u]);\n// \t\t}\n// \t}\n// \treturn dp[S][v] = res;\n// }\n\n// int main(){\n// \tcin>>V>>E;\n// \trep(i,V)rep(j,V)path[i][j] = inf;\n// \trep(i,E){\n// \t\tint s,t,d; cin>>s>>t>>d;\n// \t\tpath[s][t] = d;\n// \t}\n// \tmemset(dp, -1, sizeof(dp));\n// \tint ans = solve(0,0);\n// \tif(ans == inf)ans = -1;\n// \tcout<<ans<<endl;\n// \treturn 0;\n// }\n\nint main(){\n\tcin>>V>>E;\n\trep(i,V)rep(j,V)path[i][j] = inf;\n\trep(i,E){\n\t\tint s,t,d; cin>>s>>t>>d;\n\t\tpath[s][t] = d;\n\t}\n\trep(i,1<<V)rep(j,V)dp[i][j] = inf;\n\tdp[(1<<V)-1][0] = 0;\n\tfor(int S = (1<<V)-2; S>=0; S--){\n\t\tfor(int v = 0; v<V; v++){\n\t\t\tfor(int u = 0; u<V; u++){\n\t\t\t\tif(!(S>>u & 1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S|(1<<u)][u] + path[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[0][0];\n\tif(ans == inf)ans = -1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 巡回セールスマン問題(traveling-salesman problem)を扱います\n *\n * @note  巡回セールスマン問題はハミルトン閉路問題に密接に関連した問題で、セールスマンはn個の都市を訪問しなければならない\n *        この問題をn個の頂点を持つ完全グラフとして定式化すると、各都市を正確に1回だけ訪れ、最初に出発した都市で終わる巡回路(tour)\n *        あるいはハミルトン閉路を構成することがセールスマンの目的であるが、都市iから都市jに移動するのに非負整数のコストc(i, j)が\n *        かかるので、全コストが最小になるようにしたいというのがセールスマンの希望である. ここで、全コストは巡回路の辺に\n *        割り当てられていたコストの総和である\n *\n * @note  巡回セールスマン問題はNP完全であり、多項式時間の効率的なアルゴリズムは知られていない. しかし、動的計画法を用いることで\n *        ある程度nが小さいサイズならば、厳密解を与えることができる\n *\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A\n * @date  2016/05/08\n */\n\n\n\n//********************************************************************************\n// 必要なヘッダファイルのインクルード\n//********************************************************************************\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n\n\n//********************************************************************************\n// オブジェクト形式マクロの定義\n//********************************************************************************\n\n#define GRAPH_BEGIN namespace graph {\n#define GRAPH_END   }\n\n\n\n//********************************************************************************\n// 名前空間の始端\n//********************************************************************************\n\nGRAPH_BEGIN\n\n\n\n//********************************************************************************\n// 型シノニム\n//********************************************************************************\n\nusing weight_t   = std::int32_t;  /**< 辺(u, v)への重みwを表す型 */\nusing index_t    = std::int32_t;  /**< 頂点vの添字を表す型       */\nusing capacity_t = weight_t;      /**< 辺(u, v)の容量を表す型    */\nusing bool_t     = std::int32_t;  /**< ブール値は整数型で、{ false 0 true それ以外 }とする */\n\n\n\n//********************************************************************************\n// 構造体の定義\n//********************************************************************************\n\n/**\n * @brief  頂点色列挙構造体(scoped enum)\n * @detail (u, v) ∈ Eで頂点uが黒ならば頂点vは灰か黒である\n *         すなわち、黒頂点に隣接する全ての頂点は発見済みである\n *         灰頂点は白頂点に隣接することがあり、これらの頂点が既発見頂点と未発見頂点の境界をなす\n */\nenum struct vcolor : std::int32_t {\n    white,  /**< 未発見頂点 */\n    black,  /**< 既発見頂点 */\n    gray,   /**< 既見済頂点 */\n};\n\n/**\n * @brief グラフ用ノード(頂点) \n */\nstruct vertex {\n    union {\n        weight_t d;       /**< 始点sからの距離  */\n        weight_t key;     /**< Primのアルゴリズムにおいて木に属するある頂点とを結ぶ重み */\n    };\n    index_t pi;           /**< 先行頂点(の添字) */\n    union {\n        vcolor color;     /**< 頂点の色        */\n        bool_t  visited;  /**< 発見済みか?     */\n    };\n    // weight_t f;           /**< 終了時刻印(DFSにおいて、黒色に彩色されたとき、刻まれる)     */\n    vertex() : d(0), pi(0), color(vcolor::white)/*, f(0)*/ {}\n};\n\n/**\n * @brief グラフ用エッジ(辺)\n * @note  G = (V, E)を重み関数wを持つ重み付きグラフとすると、\n *        辺(u, v) ∈ Eの重みはw(u, v)と表される\n */\nstruct edge {\n    index_t  src;   /**< 辺の始点u */\n    index_t  dst;   /**< 辺の終点v */\n    union {\n        weight_t w;     /**< 辺(u, v)への重み(コスト) */\n        capacity_t c;   /**< 辺(u, v)の容量 */\n    };\n    edge() = default;\n    edge(index_t src, index_t dst) : src(src), dst(dst), w(1) {}\n    edge(index_t src, index_t dst, weight_t w) : src(src), dst(dst), w(w) {}\n};\n\n\n\nnamespace limits {\n    enum {  // scopedではあるが強く型付けされたenum(strongly-typed enum)ではない\n        inf = std::numeric_limits<weight_t>::max() / 3,  /**< @brief 辺が存在しない場合に使用される値     */\n        nil = std::numeric_limits<index_t>::min() / 3,   /**< @brief 先行点が存在しない場合に使用される値 */\n    };\n}\n\n\n\n//********************************************************************************\n// 型シノニムその2\n//********************************************************************************\n\nusing edges_t    = std::vector<edge>;      /**< グラフG=(V, E)の辺集合E   */\nusing vertices_t = std::vector<vertex>;    /**< グラフG=(V, E)の頂点集合V */\nusing array_t    = std::vector<weight_t>;  /**< 重みwの配列  */\nusing indices_t  = std::vector<index_t>;   /**< 頂点の添字配列 */\nusing stamps_t   = std::vector<bool_t>;    /**< ブーリアンの集合 */\nusing matrix_t   = std::vector<array_t>;   /**< グラフGの隣接行列表現(および表行列表現) */\nusing graph_t    = std::vector<edges_t>;   /**< グラフGの隣接リスト表現(こちらを主に使用する) */\n\n\n\n//********************************************************************************\n// 型シノニムその3\n//********************************************************************************\n\nusing vset_t = std::int64_t;  // 頂点集合のビット表現\n\n\n\n//********************************************************************************\n// 関数の定義\n//********************************************************************************\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param vset_t  S    最小重みが決定された頂点集合S(ビット表現)\n * @param index_t u    現在探索している頂点u\n * @param const matrix_t& W  隣接行列W\n * @param matrix_t& D  uにいる状態から残りすべての頂点を辿って始点s(=0)に戻る閉路の重みの総和の最小値をD[S][u]に格納した行列D\n */\nweight_t lookup_tsp(vset_t S, index_t u, const matrix_t& W, matrix_t& D)\n{\n    // 訪問済みなら返ります\n    if (D[S][u] >= 0) { return D[S][u]; }\n\n    // すべての頂点を訪れて戻ってきた\n    index_t n = W.size();\n    if ((S == ((1 << n) - 1)) && u == 0) { return D[S][u] = 0; }\n\n    weight_t d = limits::inf;  // uにいる状態から残りすべての頂点を辿って始点に戻る閉路の重みの総和の最小値をdとする\n    \n    for (index_t v = 0; v < n; v++) {       // 次の状態vを探索\n        if ((S >> v) & 0x01) { continue; }  // 訪問済みならcontinue\n        d = std::min(d, (lookup_tsp((S | (1 << v)), v, W, D) + W[u][v]));  // dの更新\n    }\n    return D[S][u] = d;\n}\n\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param  index_t s    始点s\n * @param  const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t memoized_tsp(index_t s, const matrix_t& W)\n{\n    std::size_t n = W.size();            // n = W.rows\n    matrix_t D(1 << n, array_t(n, -1));  // Dを2^n x n型の新しい行列とする\n\n    return lookup_tsp(0, s, W, D);\n}\n\n\n/**\n * @brief 動的計画法により巡回セールスマン問題に厳密解を与える\n *\n * @param index_t s  始点s\n * @param const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t bottom_up_tsp(const matrix_t& W)\n{\n    index_t n = W.size();                         // n = W.rows\n    matrix_t D(1 << n, array_t(n, limits::inf));  // Dを2^n x n型の新しい行列とする\n\n    D[(1 << n) - 1][0] = 0;  // 始点s(=0)の初期化\n\n    for (vset_t S = (1 << n) - 2; S >= 0; S--) {\n        \n        for (index_t u = 0; u < n; u++) {\n            \n            for (index_t v = 0; v < n; v++) {    \n                if ((S >> v) & 0x01) { continue; }  // 訪問済みならば、continue\n                D[S][v] = std::min(D[S][v], D[(S | (1 << v))][u] + W[u][v]);  // Dの更新\n            }\n        }\n    }\n    return D[0][0];\n}\n\n\n\n//********************************************************************************\n// 名前空間の終端\n//********************************************************************************\n\nGRAPH_END\n\n\n\n//********************************************************************************\n// エントリポイント\n//********************************************************************************\n\nint main()\n{\n    using namespace std;\n\n    using namespace graph;\n\n    index_t V, E;\n    cin >> V >> E;\n\n    matrix_t W(V, array_t(V, limits::inf));\n    for (index_t i = 0; i < V; i++) { W[i][i] = 0; }\n\n    index_t s, t;\n    weight_t d;\n    for (index_t i = 0; i < E; i++) {\n        cin >> s >> t >> d;\n        W[s][t] = d;\n    }\n\n    d = bottom_up_tsp(W);\n    if (d >= limits::inf) { cout << -1 << endl; }\n    else { cout << d << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (sum > Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1<<29;\nconst int maxn = 20;\n\nint n;\nint dis[maxn+3][maxn+3] = {};\nint dp[(1<<maxn)+3][maxn+11] = {};\n\nint solve(int s, int last){\n    if (dp[s][last] == 0){\n        dp[s][last] = inf;\n\n        if (__builtin_popcount(s) == 1) dp[s][last] = dis[0][last];\n        else{\n            for(int i = 1;i < n;i++){\n                if (i == last) continue;\n                if (((1<<i)&s) == 0) continue;\n                dp[s][last] = min(dp[s][last], solve(s^(1<<last), i)+dis[i][last]);\n            }\n        }\n    }\n    return dp[s][last];\n}\n\nint main(){\n\n    cin>>n;\n    int e;cin>>e;\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < n;j++){\n            dis[i][j] = inf;\n        }\n    }\n\n    while(e--){\n        int a, b, d;cin>>a>>b>>d;\n        dis[a][b] = d;\n    }\n\n    int ans = solve((1<<n)-1, 0);\n    if (ans == inf) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n\n/* input\n    5\n    0 1 1 1 1\n    1 0 1 1 1\n    1 1 0 1 1\n    1 1 1 0 1\n    1 1 1 1 0\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint d[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint tsp(int start, int visited_flag, int city_num){\n    int rtn = MAX;\n    //??¨????????????????¨???????????????´???\n    if(visited_flag == (1 << city_num) - 1){\n        if (d[start][0] == -1) {\n            return rtn;\n        }else{\n            return d[start][0];\n        }\n    }\n    \n    for (int i = 0; i < city_num; i++) {\n        //??????????¨???????????????§????????´???\n        if (\n            !(visited_flag & (1 << i))\n            &&\n            d[start][i] != -1\n            )\n        {\n            rtn = min(\n                      rtn,\n                      d[start][i] + tsp(i, visited_flag | (1 << i), city_num)\n                      );\n        }\n    }\n    \n    return rtn;\n}\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(d, -1, sizeof(d));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        d[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1, V);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp((1 << V), vector<int>(V, INF));\n\tdp[(1 << V) - 1][0] = 0;\n\tfor (int bits = (1 << V) - 1 - 1; bits >= 0; bits--) {\n\t\trep(i, 0, V) {\n\t\t\trep(j, 0, V) {\n\t\t\t\tif (!(bits&(1 << j)))chmin(dp[bits][i], dp[bits | (1 << j)][j] + G[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[0][0] == INF ? -1 : dp[0][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, s, t, d;\n\n\tcin >> V >> E;\n\n\tvector<vector<int> > M(V, vector<int>(V, 1 << 27));\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> s >> t >> d;\n\n\t\tM[s][t] = d;\n\t}\n\n\tvector<vector<int> > dp(V, vector<int>(1 << V, 1 << 27));\n\n\tdp[0][0] = 0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < V; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < (1 << V); k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l < V; l++)\n\t\t\t\t{\n\t\t\t\t\tif ((k / (1 << j)) % 2 == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[j][k] = min(dp[j][k], dp[l][k - (1 << j)] + M[l][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][(1 << V) - 1] << endl;\n\n\treturn 0;\n}\n\n// Time : O ( V ^ 3 * 2 ^ V ) = 110,592,000"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tint table[15] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384};\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint** dp = new int*[N];\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i] = new int[limit];\n\t\tfor(int k = 0; k < limit; k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\n\ttmp = pow(2,0);\n\n\tdp[0][tmp] = 0;\n\n\tfor(int state = 0; state <= limit-1; state++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(dp[k][state] == BIG_NUM)continue;\n\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\tif(state == limit-1 && a == 0){\n\t\t\t\t\t\tif(cost[k][0] != BIG_NUM)dp[0][limit-1] = min(dp[0][limit-1],dp[k][state]+cost[k][0]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\ttmp = state + table[a];\n\t\t\t\t\t\tdp[a][tmp] = min(dp[a][tmp],dp[k][state]+cost[k][a]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tminimum = min(minimum,dp[0][limit-1]);\n\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 0x3fffffff\nusing namespace std;\n\nint v, e, edge[15][15], dp[15][1 << 15];\n\nint rec(int S/*ノード集合*/,int s/*スタート地点*/,int n/*現在地点*/){\n\tif(dp[s][S] != -1){\n\t\treturn dp[s][S];\n\t}\n\tif(S == ((1 << v) - 1) && edge[n][s] != -1){\n\t\treturn dp[s][S] = edge[n][s];\n\t}\n\tint res = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tif(((S >> i) & 1) == 0 && edge[n][i] != -1){\n\t\t\tres = min(rec(S | (1 << i),s,i) + edge[n][i],res);\n\t\t}\n\t}\n\treturn dp[s][S] = res;\n}\n\nint main() {\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < v;i++){\n\t\trec(1 << i,i,i);\n\t}\n\tint ans = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tans = dp[i][1 << i];\n\t}\n\tif(ans >= INF){\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp(1 << V, vector<int>(V, -1));\n\tfunction<int(int, int)> tsp = [&](int S, int v) {\n\t\tif (dp[S][v] >= 0)return dp[S][v];\n\t\tif (S == (1 << V) - 1 && v == 0)return dp[S][0] = 0;\n\n\t\tint ret = INF;\n\t\trep(i, 0, V) {\n\t\t\tif (!(S&(1 << i)))chmin(ret, tsp(S | (1 << i), i) + G[v][i]);\n\t\t}\n\t\treturn dp[S][v] = ret;\n\n\t};\n\tint ans = tsp(0, 0);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\nll n,e;\nvvl(d,20,20,inf);\nll dp[1 << 15][20];\n\nll rec(ll s, ll v){\n  //?????????????????????????????§?????????????????????\n  if(dp[s][v] >= 0){\n    return dp[s][v];\n  }\n  //??????????????????????¨?????????????\n  if(s == (1 << n) - 1 && v == 0){\n    return dp[s][v] = 0;\n  }\n  ll res = inf;\n  rep(u,n){\n    //???????§???????????????????????????????????????????\n    if( !(s >> u & 1) && d[v][u] != inf){\n      res = min(res,rec(s | 1 << u, u) + d[v][u]);\n    }\n  }\n  return dp[s][v] = res;\n}\n\nvoid solve(){\n  memset(dp,-1,sizeof(dp));\n  ll ans = rec(0,0);\n  if(ans == inf) ans = -1;\n  cout << ans<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> e;\n  ll s,t,dis;\n  rep(i,e){\n    cin >> s >> t >> dis;\n    d[s][t] = dis;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\nint dp[1 << 15][15] = {};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tMatrix g(V, Array(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tg[s][t] = d;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0][0] = 0;\n\tfor (int mask = 0; mask < (1 << V); mask++) {\n\t\trep(i, 0, V) {\n\t\t\trep(j, 0, V) {\n\t\t\t\tif (mask >> j & 1)continue;\n\t\t\t\tif (dp[mask][i] == INF || g[i][j] == INF)continue;\n\t\t\t\tchmin(dp[mask | (1 << j)][j], dp[mask][i] + g[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[(1 << V) - 1][0] == INF ? -1 : dp[(1 << V) - 1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 0x3fffffff\nusing namespace std;\n\nint v, e, edge[15][15], dp[15][1 << 15];\n\nint rec(int S/*ノード集合*/,int s/*スタート地点*/,int n/*現在地点*/){\n\tif(dp[s][S] != -1){\n\t\treturn dp[s][S];\n\t}\n\tif(S == ((1 << v) - 1) && edge[n][s] != -1){\n\t\treturn dp[s][S] = edge[n][s];\n\t}\n\tint res = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tif(((S >> i) & 1) == 0 && edge[n][i] != -1){\n\t\t\tres = min(rec(S | (1 << i),s,i) + edge[n][i],res);\n\t\t}\n\t}\n\treturn dp[s][S] = res;\n}\n\nint main() {\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < v;i++){\n\t\trec(1 << i,i,i);\n\t}\n\tint ans = dp[1][2];\n\tfor(int i = 1;i < v;i++){\n\t\tans = dp[i][1 << i];\n\t}\n\tif(ans >= INF){\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Graph = vector<vector<pair<int, int>>>;\n\nint\tmain()\n{\n\tint\tV, E;\n\tcin >> V >> E;\n\tGraph\tgraph(V);\n\tint\ts, t, d;\n\tfor (int i = 0; i < E; ++i) {\n\t\tcin >> s >> t >> d;\n\t\tgraph.at(s).push_back(make_pair(d, t));\n\t}\t\n\tint\tcost[(1<<15)][15] = {};\n\tfor (int i = 0; i < (1 << V); ++i) {\n\t\tfor (int j = 0; j < V; ++j)\n\t\t\tcost[i][j] = -1;\n\t}\n\tcost[1][0] = 0;\n\tfor (int i = 0; i < (1 << V); ++i) {\n\t\tbitset<15>\tbs(i);\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (!bs.test(j)) continue;\n\t\t\tif (cost[i][j] == -1) continue;\n\t\t\tfor (auto pr : graph.at(j)) {\n\t\t\t\td = pr.first;\n\t\t\t\tt = pr.second;\n\t\t\t\tif (bs.test(t)) continue;\n\t\t\t\tint\ttmp = cost[i][j] + d;\n\t\t\t\tif (cost[i | (1 << t)][t] == -1 ||\n\t\t\t\t\t\tcost[i | (1 << t)][t] > tmp)\n\t\t\t\t\tcost[i | (1 << t)][t] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tint\tmin_cost = cost[(1 << V) - 1][0];\n\tfor (int i = 1; i < V; ++i) {\n\t\tfor (auto pr : graph.at(i)) {\n\t\t\tif (pr.second != 0) continue;\n\t\t\tif (cost[(1 << V) - 1][i] == -1) continue;\n\t\t\tint\ttmp_cost = cost[(1 << V) - 1][i] + pr.first;\n\t\t\tif (min_cost == - 1 || min_cost > tmp_cost)\n\t\t\t\tmin_cost = tmp_cost;\n\t\t}\n\t}\n\tcout << min_cost << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\nconst int MAX_V = 15;\nconst int MAX_E = MAX_V * MAX_V / 2;\nint s, t;\nint d[MAX_E][MAX_E];\nint V, E;\nint dp[1 << MAX_V][MAX_V];\n\nint main()\n{\n  cin >> V >> E;\n  rep(i, V) rep(j, V) d[i][j] = -1;\n  rep(i, E){ cin >> s >>t; cin >> d[s][t]; }\n\n  rep(S, 1<<V) rep(v, V) dp[S][v] = INF;\n  dp[(1 << V) - 1][0] = 0;\n  rev(S, (1<<V)-1) rep(v, V) rep(u, V) if(d[v][u]>=0 && !(S & (1 << u)))\n    minup(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n\n  cout << ((dp[0][0] >= INF) ? -1 : dp[0][0]) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//解説AC\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define int long long\nconst int inf = 100100100100100;\nconst int mod = 1000000007;\n \nconst int maxn = 15;\nint n, m;\nint dist[maxn][maxn];\nint dp[1<<maxn][maxn];\n \nint dfs(int s, int v){\n \n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n \n    if(s == (1<<n)-1 && v == 0){\n        return dp[s][v] = 0;\n    }\n \n    int ans = inf;\n    rep(u,0,n){\n        if(!(s >> u & 1)){\n            ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n        }\n    }\n \n    dp[s][v] = ans;\n    return ans;\n \n \n}\n \nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n \n     \n    cin >> n >> m;\n \n    memset(dp,-1,sizeof(dp));\n    fill(dist[0],dist[0]+maxn*maxn,inf);\n \n     \n \n     \n    rep(i,0,m){\n        int f, t, c;\n        cin >> f >> t >> c;\n        dist[f][t] = c;\n    }\n    int ans = dfs(0,0);\n    cout << (ans == inf ? -1 : ans) << endl;\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint dp[(1 << 15)][15];\nint d[15][15];\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    rep(i,n){\n        rep(j,n){\n            d[i][j] = INF;\n        }\n    }\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        d[a][b] = c;\n    }\n    rep(i,(1 << n)){\n        rep(j,n){\n            dp[i][j] = INF;\n        }\n    }\n    rep(i,n){\n        dp[0][i] = 0;\n    }\n    rep(i,1<<n){\n        rep(j,n){\n            rep(k,n){\n                if(!(i & (1 << k))){\n                    dp[i|(1<<k)][j] = min(dp[i|(1<<k)][j],dp[i][j] + d[j][k]);\n                }\n            }\n        }\n    }\n    int ans = INF;\n    rep(i,n){\n        ans = min(ans,dp[(1<<n)-1][i]);\n    }\n    if(ans == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint V, E;\nint dp[1 << 15][20];\nsigned main() {\n    cin >> V >> E;\n    vector< vector<pii> > G(V);\n    rep(i,0,E) {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].pb(pii(t, d));\n    }\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,(1<<V)) rep(j,0,V) dp[i][j] = INF;\n    dp[0][0] = 0;\n\n    rep(bit,0,1<<V) {\n        rep(i,0,V) {\n            rep(j,0,G[i].size()) {\n                int to = G[i][j].fr, cost = G[i][j].sc;\n                if(bit >> to & 1) continue;\n                int nbit = bit | (1 << to);\n                dp[nbit][to] = min(dp[nbit][to], dp[bit][i] + cost);\n            }\n        }\n    }\n    int ans = dp[(1<<V)-1][0];\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nclass Route {\npublic:\n\tRoute(const int &n = 0) :state(n) {};\n\tbool filled() const { return state == ((1 << size) - 1); }\n\tRoute remove(const int &n) const { return Route(state & (-1 - (1 << n))); }\n\tRoute add(const int &n) const { return Route(state | (1 << n)); }\n\tbool include(const int &n) const { return (state & (1 << n)) != 0; }\n\tbool operator<(const Route &other) const { return state < other.state; }\n\tbool operator>(const Route &other) const { return other.state < state; }\n\tbool operator==(const Route &other) const { return state == other.state; }\n\tbool operator<=(const Route &other) const { return *this < (other) || *this == (other); }\n\tbool operator>=(const Route &other) const { return *this > (other) || *this == (other); }\n\tint to_i() const { return state; }\n\tvoid inspect() const;\n\tvoid inspect(int) const;\n\tstatic int size;\nprivate:\n\tint state;\n};\nvoid Route::inspect() const {\n\tinspect(state);\n\tstd::cout << std::endl;\n}\nvoid Route::inspect(int s) const {\n\tif (s > 1) {\n\t\tinspect(s / 2);\n\t\tstd::cout << s % 2;\n\t}\n\telse {\n\t\tstd::cout << s;\n\t}\n}\nclass Edge {\npublic:\n\tEdge(const int &f = 0, const int &t = 0, const int &w = 0) :from(f), to(t), weight(w) {};\n\tbool operator<(const Edge &other) const { return (to < other.to); }\n\tint from, to, weight;\n};\nint dp(std::vector<std::vector<int>> &memo, std::vector<std::vector<Edge>> &edge, const Route &route, const int &vertex) {\n\tif (memo.at(route.to_i()).at(vertex) != -1) {\n\t\treturn memo.at(route.to_i()).at(vertex);\n\t}\n\telse if (route.filled() && vertex == 0) {\n\t\treturn memo.at(route.to_i()).at(vertex) = 0;\n\t}\n\telse {\n\t\tint min = 15000;\n\t\tfor (auto &e : edge.at(vertex)) {\n\t\t\t//std::cout << \"from \" << e.from << \" to \" << e.to << std::endl;\n\t\t\tif (!route.include(e.to)) {\n\t\t\t\tauto temp = dp(memo, edge, route.add(e.to), e.to) + e.weight;\n\t\t\t\t//std::cout << vertex << \"->\" << e.to << \" == \";\n\t\t\t\t//std::cout << temp << \"---\";\n\t\t\t\t//route.inspect();\n\t\t\t\tif (min > temp) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t//std::cout << \"vertex = \" << vertex << \"min = \" << min << std::endl;\n\t\treturn memo.at(route.to_i()).at(vertex) = min;\n\t}\n}\nint Route::size = 30;\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tRoute::size = v;\n\tstd::vector<std::vector<int>> vector((1 << v), std::vector<int>(v, -1));\n\tstd::vector<std::vector<Edge>> edges(v, std::vector<Edge>(0));\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t, d;\n\t\tstd::cin >> s >> t >> d;\n\t\tedges.at(s).push_back(Edge(s, t, d));\n\t}\n\tif (dp(vector, edges, Route(0), 0) > 1500) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << dp(vector, edges, Route(0), 0) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint V;\nint adj[15 + 1][15 + 1];\nint dp[(1 << 15) - 1 + 1][15 + 1];\n\nint main()\n{\n    int V, E;\n    int ans = 1e9;\n\n    cin >> V >> E;\n\n    for(int i = 0; i <= 15; ++i)  for(int j = 0; j <= 15; ++j) adj[i][j] = 1e9;\n\n    for(int i = 0; i < E; ++i)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n        adj[s][t] = d;\n    }\n/*\n    for(int i = 0; i < V; ++i) //start\n    {\n    */\n        for(int j = 0; j < (1 << V); ++j) for(int k = 0; k < V; ++k) dp[j][k] = 1e9;\n        dp[1][0] = 0;\n//        dp[(1 << i)][i] = 0;\n        for(int j = 0; j < (1 << V); ++j)\n        {\n            for(int k = 0; k < V; ++k)\n            {\n                if(dp[j][k] == 1e9) continue;\n                for(int l = 0; l < V; ++l)\n                {\n                    if(j & (1 << l)) continue;\n                    if(adj[k][l] == 1e9) continue;\n                    dp[j | (1 << l)][l] = min(dp[j | (1 << l)][l], dp[j][k] + adj[k][l]);\n                }\n            }\n        }\n        for(int j = 0; j < V; ++j) ans = min(dp[(1 << V) - 1][j] + adj[j][0], ans);\n        //for(int j = 0; j < V; ++j) ans = min(dp[(1 << V) - 1][j] + adj[j][i], ans);\n//    }\n\n    if(ans == 1e9) cout << -1 << endl;\n    else cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst long long MOD = 1e9 + 7;\n\nsigned main(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<pair<int, int>>> G(v);\n    int s,t,d;\n    rep(i,e){\n        cin >> s >> t >> d;\n        G[s].emplace_back(t, d);\n    }\n    auto solve = [&](int s){\n        vector<vector<int>> dp(1 << v, vector<int>(v, INF));\n        dp[0][s] = 0;\n        for(int bit = 0; bit < 1 << v; bit++){\n            for(int i = 0; i < v; i++){\n                for(int j = 0; j < G[i].size(); j++){\n                    int to = G[i][j].first, dist = G[i][j].second;\n                    if(bit & 1 << to) continue;\n                    dp[bit | 1 << to][to] = min(dp[bit | 1 << to][to], dp[bit][i] + dist);\n                }\n            }\n        }\n        return dp[(1 << v) - 1][s];\n    };\n    /*\n    int ans = INF;\n    for(int i = 0; i < v; i++){\n        ans = min(ans, solve(i));\n    }*/\n    cout << (solve(0) != INF ? solve(0) : -1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n\tconst long long INF = 1ll << 60;\n\tint v, e;\n\tcin >> v >> e;\n\tvector<vector<long long>> G(v, vector<long long>(v, INF));\n\tint in1, in2, in3;\n\tfor (int i = 0; i < e; i++) {\n\t\tcin >> in1 >> in2 >> in3;\n\t\tG[in1][in2] = in3;\n\t}\n\n\tvector < vector <long long >> dp(1 << v, vector<long long>(v, INF));\n\n\tdp[0][0] = 0;\n\n\tfor (int s = 0; s < (1 << v); s++) {\n\n\t\tfor (int i = 0; i < v; i++) {\n\n\t\t\tfor (int j = 0; j < v; j++) {\n\n\t\t\t\tif ((s & (1 << i)) == 0) {\n\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tdp[s | (1 << i)][j] = min(dp[s | (1 << i)][j]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t, dp[s][i] + G[i][j]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\n\tif (dp[(1 << v) - 1][0] != INF) {\n\t\tcout << dp[(1 << v) - 1][0] << endl;\n\t}\n\telse { cout << -1 << endl; }\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//ループverです。移動後はvisitedが増えるので, visited昇順にループを回せば良いです。\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint INF = 1000000007;\nint n, m;\nbool canMove[15][15] = {false};\nint ecost[15][15];\nint dp[1 << 15][15];\t//dp[visited][pos] = これまでの最小コスト（visitedの下位i(>=0)ビット目が1⇔頂点iを訪問済み, pos…現在地.）\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tecost[s][t] = d;\n\t\tcanMove[s][t] = true;\n\t}\n\t\n\tfor (i = 0; i < (1 << n); i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n\tdp[1][0] = 0;\n\tfor (i = 1; i < (1 << n) - 1; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\t//if (dp[i][j] >= INF) continue;\t//この行は無くてもよい\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\tif (!canMove[j][k]) continue;\n\t\t\t\tif ((i >> k) & 1) continue;\n\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + ecost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (j = 0; j < n; j++) {\n\t\tif (dp[(1 << n) - 1][j] < INF && canMove[j][0]) {\n\t\t\tans = min(ans, dp[(1 << n) - 1][j] + ecost[j][0]);\n\t\t}\n\t}\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nstruct node{\n    ll cost;\n    ll where;\n    ll done;\n    \n    bool operator < (const node &n) const {\n        if(n.cost<this->cost){return true;}\n        return false;\n    }\n    \n    bool operator == (const node &n) const {\n        if(n.cost==cost){return true;}\n        return false;\n    }\n};\n\nnode err={MOD,-1,-1};\n\nint main(){\n    ll v,e;\n    cin>>v>>e;\n    vector<vector<pll>> E(v);\n    vector<pll> S;\n    for(int i=0;i<e;i++){\n        ll s,t,d;\n        cin>>s>>t>>d;\n        E[s].push_back({t,d});\n        if(t==0){S.push_back({s,d});}\n    }\n    vector<vector<node>> dp(v,vector<node>((1<<v),err));\n    priority_queue<node> q;\n    dp[0][0]=(node){0,0,1};\n    q.push((node){0,0,1});\n    while(!q.empty()){\n        node N=q.top(); q.pop();\n        if(N<dp[N.where][N.done]){continue;}\n        for(int i=0;i<E[N.where].size();i++){\n            pll &e=E[N.where][i];\n            if((N.done>>e.F)&1){continue;}\n            node New={N.cost+e.S,e.F,N.done|((ll)1<<e.F)};\n            if(dp[New.where][New.done]<New){dp[New.where][New.done]=New; q.push(New);}\n        }\n    }\n    ll ad=1; ad<<=v; ad--;\n    ll mi=MOD;\n    for(int i=0;i<S.size();i++){\n        pll &e=S[i];\n        if(dp[e.F][ad]==err){continue;}\n        mi=min(mi,dp[e.F][ad].cost+e.S);\n    }\n    if(mi==MOD){cout<<-1<<endl;}\n    else{cout<<mi<<endl;}\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\nint main(){\n    int v;\n    cin>>v;\n    vector<vector<int> > g(v,vector<int>(v,inf) );\n    int e;\n    cin>>e;\n    for(int i=0;i<e;i++){\n\tint s,t,d;\n\tcin>>s>>t>>d;\n\tg[s][t] = d;\n    }\n    vector<vector<int> > dp( 1<<v , vector<int>(v,inf) );\n    dp[ (1<<v) -1 ][0] = 0;\n    for( int i = (1<<v) -1 ; i >=  0 ; i-- ){\n\tfor( int j = 0 ; j < v ; j++ ){ // from\n\t    for( int k = 0 ; k < v ; k++ ){ // to\n\t\tif( ( (i>>k) & 1 ) == 0 ){\n\t\t    dp[i][j] = min(dp[i][j] , dp[ i | (1<<k) ] [k] + g[k][j] );\n\t\t}\n\t    }\n\t}\n    }\n    if( dp[0][0] == inf ){\n\tcout<<-1<<endl;\n    }else{\n\tcout<<dp[0][0]<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nint dp[1 << 15][15];\nint D[15][15];\nconst int INF = (int)1e7;\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  REP(state, 1 << V) REP(i, V) dp[state][i] = INF;\n  REP(i, V) REP(j, V) D[i][j] = INF;\n  REP(i, E) {\n    int s, t, d; cin >> s >> t >> d;\n    D[s][t] = d;\n  }\n\n  dp[(1 << V) - 1][0] = 0;\n  for (int state = (1 << V) - 2; state >= 0; state--) {\n    REP(i, V) REP(j, V) if (not (state >> j & 1)) dp[state][i] = min(dp[state][i], dp[state | (1 << j)][j] + D[i][j]);\n  }\n\n  cout << (dp[0][0] == INF ? -1 : dp[0][0]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 巡回セールスマン問題(traveling-salesman problem)を扱います\n *\n * @note  巡回セールスマン問題はハミルトン閉路問題に密接に関連した問題で、セールスマンはn個の都市を訪問しなければならない\n *        この問題をn個の頂点を持つ完全グラフとして定式化すると、各都市を正確に1回だけ訪れ、最初に出発した都市で終わる巡回路(tour)\n *        あるいはハミルトン閉路を構成することがセールスマンの目的であるが、都市iから都市jに移動するのに非負整数のコストc(i, j)が\n *        かかるので、全コストが最小になるようにしたいというのがセールスマンの希望である. ここで、全コストは巡回路の辺に\n *        割り当てられていたコストの総和である\n *\n * @note  巡回セールスマン問題はNP完全であり、多項式時間の効率的なアルゴリズムは知られていない. しかし、動的計画法を用いることで\n *        ある程度nが小さいサイズならば、厳密解を与えることができる\n *\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A\n * @date  2016/05/08\n */\n\n\n\n//********************************************************************************\n// 必要なヘッダファイルのインクルード\n//********************************************************************************\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n\n\n//********************************************************************************\n// オブジェクト形式マクロの定義\n//********************************************************************************\n\n#define GRAPH_BEGIN namespace graph {\n#define GRAPH_END   }\n\n\n\n//********************************************************************************\n// 名前空間の始端\n//********************************************************************************\n\nGRAPH_BEGIN\n\n\n\n//********************************************************************************\n// 型シノニム\n//********************************************************************************\n\nusing weight_t   = std::int32_t;  /**< 辺(u, v)への重みwを表す型 */\nusing index_t    = std::int32_t;  /**< 頂点vの添字を表す型       */\nusing capacity_t = weight_t;      /**< 辺(u, v)の容量を表す型    */\nusing bool_t     = std::int32_t;  /**< ブール値は整数型で、{ false 0 true それ以外 }とする */\n\n\n\n//********************************************************************************\n// 構造体の定義\n//********************************************************************************\n\n/**\n * @brief  頂点色列挙構造体(scoped enum)\n * @detail (u, v) ∈ Eで頂点uが黒ならば頂点vは灰か黒である\n *         すなわち、黒頂点に隣接する全ての頂点は発見済みである\n *         灰頂点は白頂点に隣接することがあり、これらの頂点が既発見頂点と未発見頂点の境界をなす\n */\nenum struct vcolor : std::int32_t {\n    white,  /**< 未発見頂点 */\n    black,  /**< 既発見頂点 */\n    gray,   /**< 既見済頂点 */\n};\n\n/**\n * @brief グラフ用ノード(頂点) \n */\nstruct vertex {\n    union {\n        weight_t d;       /**< 始点sからの距離  */\n        weight_t key;     /**< Primのアルゴリズムにおいて木に属するある頂点とを結ぶ重み */\n    };\n    index_t pi;           /**< 先行頂点(の添字) */\n    union {\n        vcolor color;     /**< 頂点の色        */\n        bool_t  visited;  /**< 発見済みか?     */\n    };\n    // weight_t f;           /**< 終了時刻印(DFSにおいて、黒色に彩色されたとき、刻まれる)     */\n    vertex() : d(0), pi(0), color(vcolor::white)/*, f(0)*/ {}\n};\n\n/**\n * @brief グラフ用エッジ(辺)\n * @note  G = (V, E)を重み関数wを持つ重み付きグラフとすると、\n *        辺(u, v) ∈ Eの重みはw(u, v)と表される\n */\nstruct edge {\n    index_t  src;   /**< 辺の始点u */\n    index_t  dst;   /**< 辺の終点v */\n    union {\n        weight_t w;     /**< 辺(u, v)への重み(コスト) */\n        capacity_t c;   /**< 辺(u, v)の容量 */\n    };\n    edge() = default;\n    edge(index_t src, index_t dst) : src(src), dst(dst), w(1) {}\n    edge(index_t src, index_t dst, weight_t w) : src(src), dst(dst), w(w) {}\n};\n\n\n\nnamespace limits {\n    enum {  // scopedではあるが強く型付けされたenum(strongly-typed enum)ではない\n        inf = std::numeric_limits<weight_t>::max() / 3,  /**< @brief 辺が存在しない場合に使用される値     */\n        nil = std::numeric_limits<index_t>::min() / 3,   /**< @brief 先行点が存在しない場合に使用される値 */\n    };\n}\n\n\n\n//********************************************************************************\n// 型シノニムその2\n//********************************************************************************\n\nusing edges_t    = std::vector<edge>;      /**< グラフG=(V, E)の辺集合E   */\nusing vertices_t = std::vector<vertex>;    /**< グラフG=(V, E)の頂点集合V */\nusing array_t    = std::vector<weight_t>;  /**< 重みwの配列  */\nusing indices_t  = std::vector<index_t>;   /**< 頂点の添字配列 */\nusing stamps_t   = std::vector<bool_t>;    /**< ブーリアンの集合 */\nusing matrix_t   = std::vector<array_t>;   /**< グラフGの隣接行列表現(および表行列表現) */\nusing graph_t    = std::vector<edges_t>;   /**< グラフGの隣接リスト表現(こちらを主に使用する) */\n\n\n\n//********************************************************************************\n// 型シノニムその3\n//********************************************************************************\n\nusing vset_t = std::int64_t;  // 頂点集合のビット表現\n\n\n\n//********************************************************************************\n// 関数の定義\n//********************************************************************************\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param vset_t  S    最小重みが決定された頂点集合S(ビット表現)\n * @param index_t u    現在探索している頂点u\n * @param const matrix_t& W  隣接行列W\n * @param matrix_t& D  uにいる状態から残りすべての頂点を辿って始点s(=0)に戻る閉路の重みの総和の最小値をD[S][u]に格納した行列D\n */\nweight_t lookup_tsp(vset_t S, index_t u, const matrix_t& W, matrix_t& D)\n{\n    // 訪問済みなら返ります\n    if (D[S][u] >= 0) { return D[S][u]; }\n\n    // すべての頂点を訪れて戻ってきた\n    index_t n = W.size();\n    if ((S == ((1 << n) - 1)) && u == 0) { return D[S][u] = 0; }\n\n    weight_t d = limits::inf;  // uにいる状態から残りすべての頂点を辿って始点に戻る閉路の重みの総和の最小値をdとする\n    \n    for (index_t v = 0; v < n; v++) {       // 次の状態vを探索\n        if ((S >> v) & 0x01) { continue; }  // 訪問済みならcontinue\n        d = std::min(d, (lookup_tsp((S | (1 << v)), v, W, D) + W[u][v]));  // dの更新\n    }\n    return D[S][u] = d;\n}\n\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param  index_t s    始点s\n * @param  const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t memoized_tsp(index_t s, const matrix_t& W)\n{\n    std::size_t n = W.size();            // n = W.rows\n    matrix_t D(1 << n, array_t(n, -1));  // Dを2^n x n型の新しい行列とする\n\n    return lookup_tsp(0, s, W, D);\n}\n\n\n/**\n * @brief トップダウン方式の動的計画法により巡回セールスマン問題に厳密解を与える\n *\n * @param index_t s  始点s\n * @param const matrix_t& W  隣接行列W\n * @return 最短ハミルトン閉路Hの最小重み\n */\nweight_t top_down_tsp(const matrix_t& W)\n{\n    index_t n = W.size();                         // n = W.rows\n    matrix_t D(1 << n, array_t(n, limits::inf));  // Dを2^n x n型の新しい行列とする\n\n    D[(1 << n) - 1][0] = 0;  // 始点s(=0)の初期化\n\n    for (vset_t S = (1 << n) - 2; S >= 0; S--) {\n        \n        for (index_t u = 0; u < n; u++) {\n            \n            for (index_t v = 0; v < n; v++) {    \n                if ((S >> v) & 0x01) { continue; }  // 訪問済みならば、continue\n                D[S][v] = std::min(D[S][v], D[(S | (1 << v))][u] + W[u][v]);  // Dの更新\n            }\n        }\n    }\n    return D[0][0];\n}\n\n\n\n//********************************************************************************\n// 名前空間の終端\n//********************************************************************************\n\nGRAPH_END\n\n\n\n//********************************************************************************\n// エントリポイント\n//********************************************************************************\n\nint main()\n{\n    using namespace std;\n\n    using namespace graph;\n\n    index_t V, E;\n    cin >> V >> E;\n\n    matrix_t W(V, array_t(V, limits::inf));\n    for (index_t i = 0; i < V; i++) { W[i][i] = 0; }\n\n    index_t s, t;\n    weight_t d;\n    for (index_t i = 0; i < E; i++) {\n        cin >> s >> t >> d;\n        W[s][t] = d;\n    }\n\n    d = top_down_tsp(W);\n    if (d >= limits::inf) { cout << -1 << endl; }\n    else { cout << d << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nll MOD = 1e9+7;\n\nvoid chmin(int& x, int y) {\n    if (x > y) x = y;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int v, e; cin >> v >> e;\n\n    vector<vector<pair<int, int>>> g(v);\n    REP(i, e) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s].eb(t, d);\n    }\n\n    vector<vi> dp(1 << v, vi(v, inf));\n    dp[0][0] = 0;\n\n    REP(i, 1 << v) {\n        REP(from, v) {\n            if (dp[i][from] == inf) continue;\n\n            for(auto &p: g[from]) {\n                int to = p.fi;\n                if(i >> to & 1) continue;\n                chmin(dp[i | 1 << to][to], dp[i][from] + p.se);\n            }\n        }\n    }\n\n    if (dp[(1 << v) - 1][0] == inf) dp[(1 << v) - 1][0] = -1;\n    print(dp[(1 << v) - 1][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define INF 0x1fffffff\n#define MAX_V 15\n\nint main(void){\n  int v, e, st[MAX_V][MAX_V], i, j, k, l, d[MAX_V][1 << MAX_V]/*スタート地点,今いる地点,通過した編の情報(bit)*/, ans = INF;\n  scanf(\"%d%d\",&v,&e);\n  memset(st,-1,sizeof(st));\n  for(i = 0;i < e;i++){\n    int s, t, dt;\n    scanf(\"%d%d%d\",&s,&t,&dt);\n    st[s][t] = dt;\n  }\n  for(i = 0;i < v;i++){ // スタート地点\n    for(j = 0;j < v;j++){\n      for(k = 0;k < 1 << v;k++){\n\td[j][k] = INF;\n      }\n    }\n    d[i][1 << i] = 0;\n    while(1){\n      int flag = 1;\n      for(j = 0;j < v;j++){ // 今いる地点\n\tfor(k = 0;k < 1 << v;k++){ // 通過辺の情報\n\t  for(l = 0;l < v;l++){ // 行き先\n\t    if(st[j][l] != -1 && d[l][k | (1 << l)] > d[j][k] + st[j][l]){\n\t      flag = 0;\n\t      d[l][k | (1 << l)] = d[j][k] + st[j][l];\n\t      \n\t    }\n\t  }\n\t}      \n    \n      }\n      if(flag){\n\tbreak;\n      }\n    }\n    if(d[i][(1 << v) - 1] < ans){\n      ans = d[i][(1 << v) - 1];\n    }\n\n  }\n  if(ans == INF){\n    ans = -1;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n\n///////////////////////////////////////////////////////////////\n// namespace\n///////////////////////////////////////////////////////////////\nusing namespace std;\n// namespace mp = boost::multiprecision;\n\n///////////////////////////////////////////////////////////////\n// types\n///////////////////////////////////////////////////////////////\nusing pii = pair<int, int>;\nusing ll = long long int;\nusing ld = long double;\n// using mpi = mp::cpp_int;\n// using mpf = mp::number<mp::cpp_dec_float<1024>>;\n\n///////////////////////////////////////////////////////////////\n// mod https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a\n///////////////////////////////////////////////////////////////\n// ll MOD = 1000000007;\n// ll mod(long long val) {\n//     long long res = val % MOD;\n//     if (res < 0) res += MOD;\n//     return res;\n// }\n// ll modinv(ll a) {\n//     ll b = MOD, u = 1, v = 0;\n//     while (b) {\n//         ll t = a / b;\n//         a -= t * b; swap(a, b);\n//         u -= t * v; swap(u, v);\n//     }\n//     u %= MOD;\n//     if (u < 0) u += MOD;\n//     return u;\n// }\nint num_verex, E, s, t, d;\nvector<vector<int>> dist;\nvector<vector<int>> dp;\n\n// v: current node\n// S: all visited nodes\n// dp[S][v]: Minimum total cost from current node v to node 0 given visited nodes\n// answer: dp[(1<<V)-1][0];\nconst int INF = 1e9;\nint tsp(int S, int v) {\n    if (S == (1 << num_verex) - 1) return v == 0 ? 0 : INF;\n    if (dp[S][v] >= 0) return dp[S][v];\n    int ret = INF;\n    for (int u = 0; u < num_verex; ++u) {\n        if (dist[u][v] == INF || (S>>u)&1) continue;\n        ret = min(ret, tsp(S | (1 << u), u) + dist[u][v]);\n    }\n    return dp[S][v] = ret;\n}\n\nint main() {\n    cin >> num_verex >> E;\n    dist = vector<vector<int>>(num_verex, vector<int>(num_verex,INF));\n    for (int i = 0; i < E; ++i) {\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    dp = vector<vector<int>>(1<<(num_verex+2), vector<int>(num_verex + 5, -1));\n    int ans = tsp(0, 0);\n    cout << ((ans != INF) ? ans : -1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nstruct edge {int to, cost;};\nint g[20][20];\nint dp[1<<15][15];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n)rep(j, n) g[i][j] = INT_MAX;\n    rep(i, m) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    rep(i, 1<<n)rep(j, n) dp[i][j] = INT_MAX / 2;\n    int start = 0;\n    dp[1<<start][start] = 0;\n\n    rep(i, 1<<n) {\n        rep(j, n) {\n            if (i>>j & 1) {\n                rep(k, n) {\n                    dp[i][j] = min(dp[i][j], dp[i^(1<<j)][k] + g[k][j]);\n                }\n            }\n        }\n    }\n    int ans = INT_MAX;\n    rep(j, n) ans = min(ans, dp[(1<<n) - 1][j] + g[j][start]);\n    cout << (ans == INT_MAX ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long int d[16][16];\n\nlong long int dp[1 << 15][15];\n\nconst long long int INF = 10000000000;\n\nlong long int rec(int s,int v){\n\n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n\n    if(s == (1 << n) -1 && v == 0){\n        return dp[s][v] = 0;\n    }\n\n    long long int res = INF;\n\n    for(int u=0; u<n; u++){\n        if(!(s >> u & 1)){\n            //?¬????u????§??????????\n            res = min(res, rec(s | 1 << u ,u) + d[v][u]);\n        }\n    }\n\n    return dp[s][v] = res;\n\n}\n\nint main() {\n\n    int e;\n\n    cin >> n >> e;\n\n    int s,t,dd;\n\n    for(int i=0;i<=15;i++){\n        for(int j=0;j<=15;j++){\n            d[i][j] = INF;\n        }\n    }\n\n    for(int i=0; i<e; i++){\n        scanf(\" %d %d %d\",&s,&t,&dd);\n        d[s][t] = dd;\n    }\n\n    for(int i=0;i < (1<<15) ; i++){\n        for(int j=0;j<15;j++){\n            dp[i][j] = -1;\n        }\n    }\n\n    long long int ans = rec(0,0);\n\n    if(ans==INF){\n        ans = -1;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\nstruct Edge {\n    ll to;     // 辺の行き先\n    ll weight; // 辺の重み\n    Edge(ll t, ll w) : to(t), weight(w) { }\n};\nusing Graph = vector<vector<Edge> >;\n\nll dp[MAX][20];\n// dp[i][j] は　集合iは通過済み、現在j にいる状態から後どれくらいで一周できるか\nll d[20][20];\n\nint main() {\n    // 頂点数と辺数\n    ll N, M; cin >> N >> M;\n\n    rep(i,20) rep(j,20) d[i][j] = INF;\n    rep(i,M) { ll a,b,c; cin >> a >> b >> c; d[a][b] = c; }\n\n\n    rep(i,MAX) rep(j,20) dp[i][j] = INF;\n    dp[(1 << N) - 1][0] = 0;\n    // 全て通過済みで0にいる、完了状態\n    for(ll S = (1 << N) - 2; S >= 0; S--){\n      // たくさんの点を通っている時から逆算する\n      rep(v,N){\n        // vからの最短経路を逆算する\n        rep(u,N){\n          if(!(S >> u & 1)){\n            // v から　uにいく時　もしかしたら最善 ?\n            dp[S][v] = min(dp[S][v] , dp[S | 1 << u][u] + d[v][u]);\n          }\n        }\n      }\n    }\n    /*\n    rep(i,1 << N){\n      rep(j,N){\n        cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n      }\n    }\n    */\n    if(dp[0][0] == INF) cout << -1 << endl;\n    else cout << dp[0][0] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <climits>\n#include <bitset>\n#define MOD 1000000007\n// INT_MAX\nusing namespace std;\n\n// struct Node\n// {\n// \tbitset<16> bit;\n// \t// vector<int> indeg;\n// \tint cur;\n// \tint path;\n// };\n\nclass Solver\n{\nprivate:\n\tint v;\n\tint e;\n\tvector<vector<int> > adj;\n\tvector<vector<int> > dp;\npublic:\n\tSolver(){\n\t\tcin >> v >> e;\n\t\tadj.resize(v);\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tadj[i].resize(v);\n\t\t\tfor (int j = 0; j < v; ++j)\n\t\t\t{\n\t\t\t\tadj[i][j] = INT_MAX/2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < e; ++i)\n\t\t{\n\t\t\tint s, t, d;\n\t\t\tcin >> s >> t >> d;\n\t\t\tadj[s][t] = d;\n\t\t}\n\t\tdp = vector<vector<int> >(1 << v, vector<int>(v, INT_MAX/2) );\n\t}\n\n\tint recursive(int bit, int cur){\n\t\tif(dp[bit][cur] != INT_MAX/2){\n\t\t\treturn dp[bit][cur];\n\t\t}\n\n\t\tif(bit == (1 << v) - 1 && cur == 0) return dp[bit][cur] = 0;\n\t\tint ans = INT_MAX/2;\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tif(!(bit >> i & 1) && adj[cur][i] != INT_MAX/2){\n\t\t\t\t// if(recursive(bit | 1 << i, i) == INT_MAX/2) continue; \n\t\t\t\tans = min(ans, recursive(bit | 1 << i, i) + adj[cur][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][cur] = ans; \n\t}\n\n\tvoid exec(){\n\t\tint ans = recursive(0, 0);\n\t\tif(ans == INT_MAX/2) ans = -1;\n\t\tcout << ans << endl;\n\t}\n};\n\n\nint main(){\n\tSolver s = Solver();\n\ts.exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<climits>\n#include<cstring>\n#include<algorithm>\n#define INF 99999999\nusing namespace std;\n\nint G[20][20];\nint d[1<<20][20];\nint dd[20][1<<20];\nint n,m;\n/*\nint dsearch(int cur,int sto)\n{\n    printf(\"%d %d %d\\n\",cur,sto,d[cur][sto]);\n    if(d[cur][sto] >= 0) return d[cur][sto];\n    if(sto == (1<<n) - 1 && cur == 0) return d[cur][sto] = 0;\n    int res = INF;\n    for(int i=0;i<n;i++)\n        if(!(sto >> i & 1))\n            res = min(res,dsearch(i,(sto|(1<<i))) + G[cur][i]);\n    return d[cur][sto] = res;\n}\n*/\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        for(int i=0;i<n;i++)\n            fill(G[i],G[i]+n,INF);\n\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            G[a][b] = c;\n        }\n\n        for(int i=0;i<(1<<n);i++)\n           fill(d[i],d[i]+n,INF);\n       /* for(int i=0;i<n;i++)\n            fill(d[i],d[i]+(1<<n),INF);*/\n\n\n        d[(1 << n) - 1][0] = 0;\n\n        for(int i = (1<<n) - 2; i >= 0; i--)\n            for(int j = 0; j < n; j++)\n                for(int k = 0; k < n; k++)\n                    if(!(i >> k & 1))\n                        d[i][j] = min(d[i][j],d[i | 1 << k][k] + G[k][j]);\n\n        printf(\"%d\\n\",d[0][0]==INF?-1:d[0][0]);\n        //printf(\"%d\\n\",dsearch(0,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/**\n *    author  : 𝒌𝒚𝒐𝒎𝒖𝒌𝒚𝒐𝒎𝒖𝒑𝒖𝒓𝒊𝒏\n *    created : 2019-12-10 21:17:03\n**/\n\n#include <iostream>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <numeric>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <functional>\n#include <iomanip>\n#include <random>\n#include <utility>\n\nusing namespace std;\n\nusing int64 = long long;\n#define debug(_) cerr << #_ << \": \" << (_) << '\\n'\ntemplate<class T> ostream& operator<<(ostream& os, vector<T>& _) { os << '{'; for (T& x : _) { os << x; if (&x != &_.back()) os << ','; } os << '}'; return os; }\ntemplate<class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { return os << '{' << p.first << \" \" << p.second << '}'; }\n\nconstexpr int INF = 1e9;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m; cin >> n >> m;\n  vector<vector<int>> dis(n, vector<int>(n, INF));\n\n  for (int i = 0; i < m; ++i) {\n    int s, t, d; cin >> s >> t >> d;\n    dis[s][t] = d;\n  }\n\n  int dp[1 << n][n];\n  fill(dp[0], dp[1 << n], INF);\n\n  dp[(1 << n) - 1][0] = 0;\n  for (int bit = (1 << n) - 2; bit >= 0; --bit) {\n    bitset<16> bs(bit);\n    for (int i = 0; i < n; ++i) {\n      if (i != 0 && !bs.test(i)) continue;\n      for (int j = 0; j < n; ++j) {\n        if (!bs.test(j)) {\n          dp[bit][i] = min(dp[bit][i], dp[bit | (1 << j)][j] + dis[i][j]);\n        }\n      }\n    }\n  }\n\n  if (dp[0][0] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[0][0] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint v, e;\nint cost[20][20];\nint memo[1 << 16][16][16];\nint dp(const int bit, const int now, const int goal)\n{\n\tif (__builtin_popcount(bit) == v)return cost[now][goal];\n\tif (memo[bit][now][goal] != -1)return memo[bit][now][goal];\n\tint ans = INF;\n\tFOR(i, v)\n\t{\n\t\tif (bit & 1 << i || cost[now][i] < 0)continue;\n\t\tans = min(ans, dp(bit | 1 << i, i, goal) + cost[now][i]);\n\t}\n\treturn memo[bit][now][goal] = ans;\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tFOR(i, 20)FOR(j, 20)cost[i][j] = INF;\n\tmemset(memo, -1, sizeof memo);\n\tFOR(i, e)\n\t{\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tcost[s][t] = d;\n\t}\n\tint ans = INF;\n\tFOR(i, v)\n\t{\n\t\tans = min(ans, dp(1 << i, i, i));\n\t}\n\tif(ans<=(v+1)*1000)cout << ans << endl;\n\telse cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\nint dp[1<<16][16];\nint dis[20][20];\nint V,E;\nconst int inf=1e9+5;\n\nint rec(int S,int v)\n{\n  if(dp[S][v]>=0)\n    {\n      return dp[S][v];\n    }\n  if(S==(1<<V)-1 && v==0)\n    {\n      return dp[S][v]=0;\n    }\n  int res=inf;\n  for(int u=0;u<V;u++)\n    {\n      if(!(S>>u & 1))\n\t{\n\t  res=min(res,rec(S | (1<<u),u)+dis[v][u]);\n\t}\n    }\n  return dp[S][v]=res;\n}\n\nint main(int argc,char const* argv[])\n{\n  memset(dp,-1,sizeof(dp));\n  memset(dis,inf,sizeof(dis));\n  cin >> V >> E;\n  for(int i=0;i<E;i++)\n    {\n      int s,t,d;\n      cin >> s >> t >> d;\n      dis[s][t]=d;\n    }\n  int ans=rec(0,0);\n  if(ans>150000)\n    {\n      cout << -1 << endl;\n    }\n  else\n    {\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 0x3fffffff\nusing namespace std;\n\nint v, e, edge[15][15], dp[15][1 << 15];\n\nint rec(int S/*ノード集合*/,int s/*スタート地点*/,int n/*現在地点*/){\n\tif(dp[s][S] != -1){\n\t\treturn dp[s][S];\n\t}\n\tif(S == ((1 << v) - 1) && edge[n][s] != -1){\n\t\treturn dp[s][S] = edge[n][s];\n\t}\n\tint res = INF;\n\tfor(int i = 0;i < v;i++){\n\t\tif(((S >> i) & 1) == 0 && edge[n][i] != -1){\n\t\t\tres = min(rec(S | (1 << i),s,i) + edge[n][i],res);\n\t\t}\n\t}\n\treturn dp[s][S] = res;\n}\n\nint main() {\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < v;i++){\n\t\trec(1 << i,i,i);\n\t}\n\tint ans = dp[1][2];\n\tfor(int i = 1;i < v;i++){\n\t\tans = dp[i][1 << i];\n\t}\n\tif(ans == INF){\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint v, e;\nint cost[20][20];\nint memo[1 << 16][15][15];\nint dp(const int bit, const int now, const int goal)\n{\n\tif (__builtin_popcount(bit) == v)return cost[now][goal];\n\tif (memo[bit][now][goal] != -1)return memo[bit][now][goal];\n\tint ans = INF;\n\tFOR(i, v)\n\t{\n\t\tif (bit & 1 << i || cost[now][i] < 0)continue;\n\t\tans = min(ans, dp(bit | 1 << i, i, goal) + cost[now][i]);\n\t}\n\treturn memo[bit][now][goal] = ans;\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tFOR(i, 20)FOR(j, 20)cost[i][j] = INF;\n\tmemset(memo, -1, sizeof memo);\n\tFOR(i, e)\n\t{\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tcost[s][t] = d;\n\t}\n\tint ans = INF;\n\tFOR(i, v)\n\t{\n\t\tans = min(ans, dp(1 << i, i, i));\n\t}\n\tif(ans<=(v+1)*1000)cout << ans << endl;\n\telse cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef std::pair<int, int> ipair;\nbool lessPair(const ipair& l, const ipair& r){return l.second < r.second;}\nbool morePair(const ipair& l, const ipair& r){return l.second > r.second;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst ll MOD = 1e9 + 7;\n// const long long INF = 1LL<<60;\nvoid add(long long &a, long long b) { a += b; if (a >= MOD) a -= MOD; }\nvoid sub(long long &a, long long b) { a -= b; if (a < 0) a += MOD; }\nvoid mul(long long &a, long long b) { a *= b; a %= MOD; }\nll llmin(ll a, ll b) { if (a < b) return a; else return b; }\nll llmax(ll a, ll b) { if (a < b) return b; else return a; }\nll llabs(ll a) { if (a >= 0) return a; else return - a; }\nll llmodpow(ll a, ll n) {\n   if (n == 0) return 1;\n   ll tmp = llmodpow(a, n / 2);\n   mul(tmp, tmp);\n   if (n & 1) mul(tmp, a);\n   return tmp;\n}\n\nint V, E;\nint cost[16][16];\nint dp[1<<15][16];\nint INF = 1000000;\n\nint main() {\n   cin >> V >> E;\n\n   int s, t, d;\n   fill(cost[0], cost[V], -1);\n   for (int i = 0; i < E; i++) {\n      cin >> s >> t >> d;\n      cost[s][t] = d;\n   }\n\n   fill(dp[0], dp[1<<V], INF);\n\n   dp[(1<<V) - 1][0] = 0;\n\n   for (int S = (1<<V) - 2; S >= 0; S--) {\n      for (int v = 0; v < V; v++) {\n         for (int u = 0; u < V; u++) {\n            if (cost[v][u] == -1) continue;\n            if (S & (1<<u)) continue;\n            // if (!(S>>u & 1)) {\n               dp[S][v] = min(dp[S][v], dp[S + (1<<u)][u] + cost[v][u]);\n            // }\n         }\n      }\n   }\n   int ans = dp[0][0];\n   if (ans == INF) cout << \"-1\" << endl;\n   else cout << ans << endl;\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 15\n\nint n,e;\nint edge[N][N];\nint py[N],px[N];\n\nint solve_dp(){\n    int (*dp)[N];\n    dp = (int(*)[N])malloc(sizeof(int)*(1<<n)*N);\n    int m = 1<<n;\n    int i,j,k,l,b;\n    for(i = 0;i < m;i++) for(j = 0;j < n;j++) dp[i][j] = -1;\n    dp[1][0] = 0;\n    for(i = 1;i < n;i++){\n        for(j = 0;j < m;j++){\n            if(i != __builtin_popcount(j)) continue;\n            for(k = 0;k < n;k++){\n                if(dp[j][k] < 0) continue;\n                for(l = 0;l < n;l++){\n                    b = 1<<l;\n                    if((b&j) || edge[k][l] == -1) continue;\n                    b = j|b;\n                    if(dp[b][l] < 0 || dp[b][l] > dp[j][k]+edge[k][l]) dp[b][l] = dp[j][k]+edge[k][l];\n                }\n            }\n        }\n    }\n    int res = -1;\n    for(i = 0;i < n;i++){\n        if(dp[(1<<n)-1][i] == -1 || edge[i][0] == -1) continue;\n        int a = dp[(1<<n)-1][i] + edge[i][0];\n        if(res == -1 || res > a) res = a;\n    }\n    free(dp);\n    return res;\n}\n\nint solve(){\n    int i,j;\n    int a,b,d;\n    scanf(\"%d %d\",&n,&e);\n    for(i = 0;i < n;i++){\n        for(j = 0;j < n;j++){\n            edge[i][j] = -1;\n        }\n    }\n    for(i = 0;i < e;i++){\n        scanf(\"%d %d %d\",&a,&b,&d);\n        edge[a][b] = d;\n    }\n    return solve_dp();\n}\n\nint main(){\n    printf(\"%d\\n\",solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint V, E;\nint memo[15][15][1 << 15];\nint getans(const int start,const int now, bitset<15>&used, const vector<vector<pair<int, int>>>&edges) {\n\tif (memo[start][now][used.to_ulong()]!=-1) {\n\t\treturn memo[start][now][used.to_ulong()];\n\t}\n\telse {\n\t\tif (used.count() == V) {\n\t\t\tif (start == now)return memo[start][now][used.to_ulong()] = 0;\n\t\t\telse return memo[start][now][used.to_ulong()] = 1e9;\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor (auto e : edges[now]) {\n\t\t\tconst int dst = e.first;\n\t\t\tconst int time = e.second;\n\t\t\tif (!used[dst]) {\n\t\t\t\tused[dst] = true;\n\t\t\t\tans = min(ans, time + getans(start, dst, used, edges));\n\t\t\t\tused[dst] = false;\n\t\t\t}\n\t\t}\n\t\treturn memo[start][now][used.to_ulong()] = ans;\n\t}\n}\nint main() {\n\tfor (int h = 0; h < 15; ++h) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 15); ++j) {\n\t\t\t\tmemo[h][i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tcin >> V >> E;\n\tvector < vector<pair<int, int>>>edges(V);\n\tfor(int i = 0; i < E; ++i) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tedges[s].push_back(make_pair(t, d));\n\t}\n\tint ans = 1e9;\n\tfor (int s = 0; s < V; ++s) {\n\t\tbitset<15>bs;\n\t\tans = min(ans, getans(s, s, bs, edges));\n\t}\n\tif (ans >= 1e9)ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O2\")\n#define all(c) c.begin(), c.end()\n#define pb push_back\n#define ll long long\nconst int MAXN = 1e5 + 5;\n\nusing namespace std;\n\nint dp[15][1<<15], n;\nvector<pair<int,int>> ve[15];\n\nint rec(int u, int mask) {\n  if (mask == (1<<n)-1) return 0;\n  int &ret = dp[u][mask];\n  if (ret != -1) return ret;\n  ret = 1e9;\n  for (auto v : ve[u])\n    if (!(mask&(1<<v.first)) && (v.first != 0 || mask == (1<<n)-2))\n      ret = min(ret, v.second+rec(v.first, mask|(1<<v.first)));\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int e; cin >> n >> e;\n  while (e--) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    ve[u].pb({v, w});\n  }\n  memset(dp, -1, sizeof dp);\n  int mini = rec(0, 0);\n  cout << (mini == 1e9? -1 : mini) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll;\nconst int INF = 10000000;\nint n, e;\nint d[15][15], dp[1 << 15][15];\nint main() {\n\tcin >> n >> e;\n\tfill(d[0], d[15], INF);\n\tfill(dp[0], dp[1 << 15], INF);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t, dis; cin >> s >> t >> dis;\n\t\td[s][t] = dis;\n\t}\n\tdp[(1 << n) - 1][0] = 0;\n\tfor (int i = (1 << n) - 2; i >= 0; i--)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (!(i >> k & 1))\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i | 1 << k][k] + d[j][k]);\n\tif (dp[0][0] >= INF) cout << -1 << endl;\n\telse cout << dp[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\nint n;\nint cost[15][15];\nint dp[1 << 15][15];\n\nint rec(int S,int v){\n\tif(dp[S][v] >= 0) return dp[S][v];\n\tif(S == (1 << n) - 1 && v == 0) return dp[S][v] = 0;\n\tint res = INF;\n\tfor(int i = 0;i < n;i++){\n\t\tif(!(S >> i & 1)){\n\t\t\tres = min(res,rec(S | 1 << i,i) + cost[v][i]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint main(){\n\tint e;\n\tcin >> n >> e;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) cost[i][j] = INF;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tcost[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << n);i++){\n\t\tfor(int j = 0;j < n;j++) dp[i][j] = -1;\n\t}\n\tint res = rec(0,0);\n\tif(res == INF) cout << -1 << endl;\n\telse cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\n\n\n\n\nint main(){\nint v,e;\ncin>>v>>e;\nvector<vector<mypair> >  g(v);\nfor(int i=0;i<e;i++){\nint s,t,d;\ncin>>s>>t>>d;\ng[s].push_back(mypair(t,d));\n}\n/*for(int i=0;i<v;i++){\n\tfor(int j=0;j<g[i].size();j++){\n\tcout<<g[i][j].first<<' ';\n\t}\n\tcout<<endl;\n}*/\nvector<vector<int> > dp((1<<v),vector<int> (v,(int)1e8));\ndp[0][0]=0;\nfor(int i=0;i<(1<<v);i++){\n\tfor(int j=0;j<v;j++){\n\t//\tif(!((1<<j)&i)){\n\t\tif(dp[i][j]!=(int)1e8){\t\n\n\t\t\tfor(int k=0;k<g[j].size();k++){\n\t\t\t\tif(!(i&(1<<g[j][k].first))){\n\t\t\t\t\tint tmp=i|(1<<g[j][k].first);\n\t\t\t\t\tdp[tmp][g[j][k].first] = min(dp[tmp][g[j][k].first],dp[i][j]+g[j][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t//\t}\n\t}\n}\nint ans = dp[(1<<v)-1][0];\ncout<< (ans==1e8 ? -1:ans)<<endl;\nreturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bits/stdc++.h>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(X, S, E) for (int(X) = (S); (X) < (E); ++(X))\n#define rrep(X, S, E) for (int(X) = (E)-1; (X) >= (S); --(X))\n#define arep(X, Y) for (auto(X) : Y)\n#define all(X) (X).begin(), (X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\n#define print(x) cout << x << endl\n#define printDouble(x) cout << fixed << setprecision(13) << x << endl\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing decendingQueue = priority_queue<ll, vl>;              //降順\nusing ascendingQueue = priority_queue<ll, vl, greater<ll>>; //昇順\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst int INT_INF = 1e9;\nconst ll LL_INF = 1e18;\nconst int mod = 1000000007;\n\ntemplate <class T> void mySort(vector<T> &X, bool isAscending) {\n  // 昇順\n  if (isAscending) {\n    sort(all(X));\n  } else {\n    // 降順\n    sort(all(X), greater<T>());\n  }\n}\n\nlong long gcd(long long m, long long n) {\n  if (m < n)\n    return gcd(n, m);\n  if (n == 0)\n    return m;\n  return gcd(n, m % n);\n}\n\nlong long lcm(long long m, long long n) {\n  // m * nでlong型のオーバフローを発生させないため、先に割り算から行う\n  return m * (n / gcd(m, n));\n}\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint &operator+=(const mint a) {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a) {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod - 2); }\n  mint &operator/=(const mint a) { return (*this) *= a.inv(); }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nvector<long long> SieveOfEratosthenes(int max) {\n  vector<long long> sieve;\n  vector<long long> primes;\n\n  for (int i = 1; i < max + 1; ++i) {\n    sieve.push_back(i);\n  }\n\n  sieve[0] = 0;\n  for (int i = 2; i < max + 1; ++i) {\n    if (sieve[i - 1] != 0) {\n      primes.push_back(sieve[i - 1]);\n      for (int j = 2 * sieve[i - 1]; j < max + 1; j += sieve[i - 1]) {\n        sieve[j - 1] = 0;\n      }\n    }\n  }\n  return primes;\n}\n\nclass UnionFindTree {\nprivate:\n  vector<int> par;\n  vector<int> rnk;\n  vector<int> siz;\n\npublic:\n  UnionFindTree(int n) {\n    par.assign(n, -1);\n    rnk.assign(n, -1);\n    siz.assign(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rnk[i] = 0;\n      siz[i] = 1;\n    }\n  }\n\n  int find(int x) {\n    if (par[x] == x)\n      return x;\n    else\n      return par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    if (rnk[x] < rnk[y]) {\n      par[x] = y;\n      siz[y] += siz[x];\n    } else {\n      par[y] = x;\n      siz[x] += siz[y];\n      if (rnk[x] == rnk[y])\n        ++rnk[x];\n    }\n  }\n\n  int size(int x) {\n    x = find(x);\n    return siz[x];\n  }\n};\n\nclass Edge {\npublic:\n  ll from;\n  ll to;\n  ll cost;\n\n  Edge() {}\n  Edge(ll from, ll to, ll cost) {\n    this->from = from;\n    this->to = to;\n    this->cost = cost;\n  }\n\n  bool operator<(const Edge &edge) const {\n    return cost < edge.cost; //昇順\n  }\n};\n\nclass Graph {\npublic:\n  ll nodes; // ノード数\n  vector<Edge> edges;\n\n  Graph() {}\n  Graph(ll nodes) { this->nodes = nodes; }\n  void addEdge(ll from, ll to, ll cost) {\n    this->edges.push_back(Edge(from, to, cost));\n  }\n};\n\n// クラスカル法\n// 連結グラフの最小全域木を求める\nclass Kruskal {\nprivate:\n  Graph graph;\n  vector<Edge> MinimumSpanningTree;\n  ll minimumCost;\n  void searchMinimumSpanningTree() {\n    UnionFindTree uf(graph.nodes);\n    sort(all(graph.edges));\n    for (auto edge : graph.edges) {\n      if (!uf.same(edge.from, edge.to)) {\n        uf.unite(edge.from, edge.to);\n        MinimumSpanningTree.push_back(edge);\n      }\n    }\n  }\n\npublic:\n  Kruskal(Graph graph) { this->graph = graph; }\n  ll getMinimumSpanningTreeCost() {\n    searchMinimumSpanningTree();\n    ll cost = 0;\n    for (auto tr : MinimumSpanningTree) {\n      cost += tr.cost;\n    }\n    return cost;\n  }\n};\n\n// ダイクストラ法 O((E+V)logV)\n// 最小経路問題を解くためのアルゴリズム。辺の重みに負数を含む場合は利用不可\n// 無向グラフの場合はコメントアウト箇所をコメントイン\nclass Dijkstra {\nprivate:\n  Graph graph;\n  map<ll, vector<Edge>> fromPaths;\n  vl distances;\n  vl srcs;\n\npublic:\n  Dijkstra(Graph graph) {\n    this->graph = graph;\n    for (auto edge : graph.edges) {\n      fromPaths[edge.from].push_back(edge);\n      // fromPaths[edge->to].push_back(Edge(edge->to, edge->from, edge->cost));\n    }\n  }\n  void searchMinimumPathFrom(ll src) {\n    // 複数回呼ばれる度に計算する\n    distances = vl(graph.nodes + 1, LL_INF);\n    srcs = vl(graph.nodes + 1, LL_INF);\n\n    // 距離が近い順番に捜査していく\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    distances[src] = 0;\n    srcs[src] = -1;\n\n    pq.push(mp(0ll, src));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      double uw = pq.top().first;\n      pq.pop();\n\n      if (distances[u] < uw) {\n        continue;\n      };\n\n      for (auto edge : fromPaths[u]) {\n        int v = edge.to;\n        ll w = edge.cost;\n        if (distances[v] > distances[u] + w) {\n          distances[v] = distances[u] + w;\n          srcs[v] = u;\n          pq.push(mp(distances[v], v));\n        }\n      }\n    }\n  };\n  ll getDistance(ll n) { return distances[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// ベルマンフォード O(|V||E|)\n// 負コストが含まれていても最短経路問題を解くためのアルゴリズム。閉路の検出も可能\n// 有向グラフ\nclass BellmanFord {\nprivate:\n  Graph graph;\n  // 閉路が含まれるかは個々のノードごとに管理する必要あり\n  vector<bool> hasNegativeCycles;\n  vector<ll> distances;\n  vl srcs;\n\npublic:\n  BellmanFord(Graph graph) {\n    ll nodes = graph.nodes + 1;\n\n    this->graph = graph;\n    distances = vector<ll>(nodes, LL_INF);\n    hasNegativeCycles = vector<bool>(nodes, false);\n  }\n  void searchMinimumPathFrom(ll src) {\n    distances[src] = 0;\n\n    for (ll i = 0; i < graph.nodes - 1; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] != LL_INF) {\n          chmin(distances[v], distances[u] + w);\n        }\n      }\n    }\n\n    for (auto edge : graph.edges) {\n      ll u = edge.from;\n      ll v = edge.to;\n      ll w = edge.cost;\n      if (distances[u] == LL_INF) {\n        continue;\n      }\n      if (distances[u] + w < distances[v]) {\n        hasNegativeCycles[v] = true;\n      }\n    }\n\n    for (ll i = 0; i < graph.nodes; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] == LL_INF) {\n          continue;\n        }\n        chmin(distances[v], distances[u] + w);\n        if (hasNegativeCycles[u] == true) {\n          hasNegativeCycles[v] = true;\n        }\n      }\n    }\n  }\n  ll getDistance(ll n) { return distances[n]; }\n  bool hasNegativeCycle(ll n) { return hasNegativeCycles[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// O(V^3) 有向グラフ\nclass WarshallFloyd {\nprivate:\n  Graph graph;\n  int nodes = this->graph.nodes + 1;\n  vector<vector<ll>> distances;\n\npublic:\n  WarshallFloyd(Graph graph) {\n    this->graph = graph;\n    nodes = this->graph.nodes + 1;\n    this->distances = vector<vector<ll>>(nodes, vector<ll>(nodes, LL_INF));\n    for (auto edge : graph.edges) {\n      int from = edge.from;\n      int to = edge.to;\n      int cost = edge.cost;\n      distances[from][to] = cost;\n    }\n  }\n  void searchMinimumPath() {\n    for (int k = 0; k < nodes; k++) {\n      for (int i = 0; i < nodes; i++) {\n        for (int j = 0; j < nodes; j++) {\n          if (distances[i][k] == LL_INF || distances[k][j] == LL_INF) {\n            continue;\n          }\n          if (distances[i][k] + distances[k][j] < distances[i][j]) {\n            distances[i][j] = distances[i][k] + distances[k][j];\n          }\n        }\n      }\n    }\n  }\n  ll getDistance(int from, int to) { return distances[from][to]; }\n};\n\ntemplate <typename T> class SegmentTree {\n  int n = 1; // 最下段のノード数. ただし、2の冪乗\n  vector<T> data;\n\n  T init;                      // 初期値\n  function<T(T, T)> mergeFunc; // 子ノードのmerge方法\n\npublic:\n  SegmentTree(int N, function<T(T, T)> _mergeFunc, T _init) {\n    mergeFunc = _mergeFunc;\n    init = _init;\n\n    while (n < N) {\n      n *= 2;\n    }\n\n    data = vector<T>(n * 2 - 1, _init); // 2の冪乗で確保が必要\n  }\n\n  // i番目の値(0-indexed)をxに変更\n  // O(logN)\n  void update(int i, T v) {\n    // 葉のノード\n    i += n - 1;\n    data[i] = v;\n\n    // 親も更新\n    while (i > 0) {\n      i = (i - 1) / 2; //親のindex\n      data[i] =\n          mergeFunc(data[i * 2 + 1], data[i * 2 + 2]); //親から見た子のindex\n    }\n  }\n\n  // i番目の値を返却\n  T get(int i) { return data[i + n - 1]; }\n\n  // [a, b)のmergeFuncを求めるクエリ\n  // ノードk（空間[l, r)が担当）が答える. ノード0の根から探索する\n  // 呼び出しはquery(a, b). その他の引数は再帰処理のため\n  // O(logN)\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    // 最初の呼び出し\n    if (r < 0) {\n      return query(a, b, k, l, n);\n    }\n\n    // 区間が被らない場合\n    if (r <= a || b <= l) {\n      return init;\n    }\n\n    // 完全に含む場合\n    if (a <= l && r <= b) {\n      return data[k];\n    }\n\n    // 部分的に含む場合. 子ノードに聞く\n    T left = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T right = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return mergeFunc(left, right);\n  }\n};\n\nint dfs(int S, int u, vector<vi> &dp, int V, vector<vector<pii>> &edges) {\n  if ((S == ((1 << V) - 1) && u == 0)) { // 全部行った\n    dp[S][u] = 0;\n    return 0;\n  }\n\n  if (dp[S][u] >= 0) {\n    return dp[S][u];\n  }\n\n  // 次に行くところ\n  int res = INT_INF;\n  for (auto ev : edges[u]) {\n    if (((S >> u) & 1) == 1) {\n      continue;\n    }\n\n    int i = ev.fi;\n    int d = ev.sc;\n\n    chmin(res, dfs((S | (1 << u)), i, dp, V, edges) + d);\n  }\n  dp[S][u] = res;\n  return dp[S][u];\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n\n  if (E == 0) {\n    print(-1);\n    return 0;\n  }\n\n  vector<vector<pii>> edges(V);\n  rep(i, 0, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n\n    edges[s].push_back(mp(t, d));\n  }\n\n  // Sの状態のときにEにいく最小コスト\n  vector<vi> dp(1 << V, vi(E, -1));\n  int res = dfs(0, 0, dp, V, edges);\n\n  if (res == INT_INF) {\n    print(-1);\n  } else {\n    print(res);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//どの頂点も一度ずつ通るので、頂点0を出発点と決めてしまって良い。\n//次に行ける頂点は、今までに通った頂点の集合visitedと現在地posから求まる。\n//また, (visited, pos)は次行く場所を決めると更新できる。\n//よって、これらを用いて探索を書けないか考える。すると「上手く書ける」。あとはメモ化すればよい。\n//visited = {1,2,4,5}みたいな集合を、visited = (110110)b = 2^5 + 2^4 + 2^2 + 2^1 = 54のように表現した漸化式・メモ化再帰を\n//「ビットDP」という。\n//\n//上手く書ける：\n//例えば、頂点1->2->…->1という経路Pを、[1->2] + [2->…->1]と分解したとき、\n//Pの長さを最小化したければ、[2->…->1]の長さも最小化したいという性質。\n//（難しいので, 分からなければ読み飛ばしてください＞＿＜）\n\n#include <iostream>\n#include <algorithm>\t//min()関数が入っている\nusing namespace std;\n\nint INF = 1000000007;\t//十分大きな整数. INF + INFがオーバーフローしないようにしておくと、ちょっと安心？（今回は関係ないけど）\nint n, m;\nbool canMove[15][15] = {false};\t//canMove[i][j] = 頂点i->jと移動できるか\nint ecost[15][15];\nint dp[1 << 15][15];\t//dp[visited][pos] = minCost.\n\n//pos     … 今いる頂点. posから移動したい.\n//visited … visitedの下位i(>=0)ビット目は, 頂点iを訪れたことがあれば1, なければ0.\n//戻り値  … これから進む距離の最小値\nint dfs(int pos, int visited) {\n\tif (visited == (1 << n) - 1) {\t//全ての頂点を訪れていたら, pos->頂点0と移動して終了\n\t\tif (!canMove[pos][0]) return INF;\t//移動不可能な場合\n\t\treturn ecost[pos][0];\n\t}\n\tif (dp[visited][pos] != -1) {\n\t\treturn dp[visited][pos];\n\t}\n\t\n\tint ret = INF;\n\tfor (int nPos = 0; nPos < n; nPos++) {\n\t\tif (!canMove[pos][nPos]) continue;\n\t\tif ((visited >> nPos) & 1) continue;\t//下位nPosビット目が1なら, 頂点nPosを既に訪れている.\n\t\tint res = ecost[pos][nPos] + dfs(nPos, visited + (1 << nPos));\n\t\tret = min(ret, res);\n\t}\n\treturn dp[visited][pos] = ret;\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tecost[s][t] = d;\n\t\tcanMove[s][t] = true;\n\t}\n\t\n\t//初期化. (1 << n)は1をnビット右シフトしたもの。2のn乗と同じ。\n\tfor (i = 0; i < (1 << n); i++) for (j = 0; j < n; j++) dp[i][j] = -1;\n\t\n\tint res = dfs(0, 1);\n\tif (res >= INF) cout << -1 << endl;\n\telse cout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author champon\n */\n\n#include <iostream>\n#include <fstream>\n#include <bits/stdc++.h>\n#define se cout << \"test ok\" << endl;\n#define sp << \" \" <<\n#define enl \"\\n\"\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing vlll = vector<vector<vector<ll>>>;\nusing vc = vector<char>;\nusing vcc = vector<vector<char>>;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nll mod = ll(1e9)+7;\nll inf = ll(1e18);\nvoid bl(bool b, ostream& out=cout){ out << (b ? \"Yes\" : \"No\") << endl; }\nvoid bl2(bool b, ostream& out=cout){ out << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<typename T> inline bool chmax(T &a, T b){ if(a<b){a=b; return true;} return false; }\ntemplate<typename T> inline bool chmin(T &a, T b){ if(a>b){a=b; return true;} return false; }\nint dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy[] = {0, 1, 0, -1, 1, -1, -1, 1};\n\n#ifndef INCLUDE_DEBUG_HPP\n#define INCLUDE_DEBUG_HPP\n\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nnamespace dbg {\n    using ll = long long;\n\n    class Debug {\n    public:\n        Debug(){}\n        template<typename T>\n        void vd(vector<T> vec);\n        template<typename T>\n        void vd2(vector<vector<T>> vec);\n        template<typename T>\n        void ad(T *arr, ll n);\n        template<typename T, size_t N>\n        void ad2(T (&arr)[N], ll n);\n        template<typename T>\n        void md(T mp);\n    };\n\n    template<typename T>\n    void Debug::vd(vector<T> vec) {\n        for (auto vv : vec) cout << vv << \" \";\n        cout << endl;\n    }\n\n    template<typename T>\n    void Debug::vd2(vector<vector<T>> vec) {\n        for (auto vv : vec) {\n            for (auto vvv : vv) cout << vvv << \" \";\n            cout << endl;\n        }\n    }\n\n    template<typename T>\n    void Debug::ad(T *arr, ll n) {\n        for (int i = 0; i <= n; i++) cout << arr[i] << \" \";\n        cout << endl;\n    }\n\n    template<typename T, size_t N>\n    void Debug::ad2(T (&arr)[N], ll n) {\n        for (int i = 0; i <= N; i++) for (int j = 0; j <= n; j++) cout << arr[i][j] << \" \";\n        cout << endl;\n    }\n\n    template<typename T>\n    void Debug::md(T mp) {\n        cout << \"key : value\" << endl;\n        for (auto const &m : mp) cout << m.first << \" : \" << m.second << endl;\n        cout << endl;\n    }\n\n}\n\n#endif //INCLUDE_DEBUG_HPP\n\nusing dbg::Debug;\nDebug debug;\n\nclass a {\npublic:\n    struct Edge {\n        ll to, cost;\n        Edge(ll to, ll cost):to(to), cost(cost){};\n    };\n\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t    int V, E;\n\t    in >> V >> E;\n\t    int s, t, d;\n\t    vll g(V, vl(V, -1));\n\t    for(int i=0; i<E; i++){\n            in >> s >> t >> d;\n            g[s][t] = d;\n\t    }\n\n        vll dp((1LL<<V), vl(V, inf));\n\t    dp[0][0] = 0;\n\t    for(ll bit=0; bit<(1LL<<V); bit++){\n\t        for(int v=0; v<V; v++){\n\t            for(int to=0; to<V; to++) {\n\t                if(!(bit & 1LL<<to) && g[v][to] != -1) {\n                        chmin(dp[bit | 1LL << to][to], dp[bit][v] + g[v][to]);\n                    }\n\t            }\n\t        }\n\t    }\n\n\t    if(dp[(1LL<<V)-1][0] == inf) out << -1 << enl;\n\t    else out << dp[(1LL<<V)-1][0] << enl;\n\t}\n};\n\n\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\ta solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\n#define now dp[st][pos][bits]\n\nconst int N = 16, INF = 0x3f3f3f3f;\n\nint n, m, end;\nint G[N + 5][N + 5];\nint dp[N][N][1 << N];\n//dp i,j,k ??¨??????i????????????????????¨j????????????????????¶??????k??¶????????°?????????????°???????\n//??¨??????????????¶??????????????¶????§???????0??????????????¶????????\\??¨???????????\\\n\ninline int nextInt(void) {\n\tint res;\n\tscanf(\"%d\", &res);\n\treturn res;\n}\n\ninline void addEdge(int x, int y, int w) {\n\tG[x][y] = w;\n}\n\ninline void makeEnd(void) {\n\tend = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tend |= (1 << i);\n}\n\nint DP(int st, int pos, int bits) {\n\t//cout << \"Searching for DP \" << st << \" \" << pos << \" \" << bits << endl;\n\tif (~now)\t//??°??????????´¢\n\t\treturn now;\n\tif (st == pos&&bits == end)\t//???????????°??????????????????????????????\n\t\treturn now = 0;\n\tnow = INF;\n\tfor (int i = 0; i < n; i++)\t//????????????\n\t\tif (i != pos &&!( (bits >> i) & 1))\t//?????????????\\??????????\n\t\t\tnow = min(now, DP(st, i, bits | (1 << i)) + G[pos][i]);\n\t//cout << \"Found DP \" << st << \" \" << pos << \" \" << bits << \" = \" << now << endl;\n\treturn now;\n}\n\nsigned main(void) {\n\tmemset(G, 0x3f, sizeof(G));\n\tmemset(dp, -1, sizeof(dp));\n\tn = nextInt();\n\tm = nextInt();\n\tfor (int i = 0; i < m; i++) {\n\t\tint x = nextInt();\n\t\tint y = nextInt();\n\t\tint w = nextInt();\n\t\taddEdge(x, y, w);\n\t}\n\tmakeEnd();\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++)\n\t\tans = min(ans, DP(i, i, 0));\n\tprintf(\"%d\\n\", ans < INF ? ans : -1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint** dp = new int*[N];\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i] = new int[limit];\n\t\tfor(int k = 0; k < limit; k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\n\ttmp = pow(2,0);\n\n\tdp[0][tmp] = 0;\n\n\tfor(int state = 0; state <= limit-1; state++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(dp[k][state] == BIG_NUM)continue;\n\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\tif(state == limit-1 && a == 0){\n\t\t\t\t\t\tif(cost[k][0] != BIG_NUM)dp[0][limit-1] = min(dp[0][limit-1],dp[k][state]+cost[k][0]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\ttmp = state + pow(2,a);\n\t\t\t\t\t\tdp[a][tmp] = min(dp[a][tmp],dp[k][state]+cost[k][a]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tminimum = min(minimum,dp[0][limit-1]);\n\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[1 << i][i] = 0;\n    }\n    for(int s = 1; s < (1 << v); s++){\n        rep(i, v){\n            if((s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n            cout << ans << endl;\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp((1 << V), vector<int>(V, INF));\n\tdp[(1 << V) - 1][0] = 0;\n\tfor (int bits = (1 << V) - 1 - 1; bits >= 0; bits--) {\n\t\trep(i, 0, V)rep(j, 0, V)\n\t\t\tif (!(bits&(1 << j)))\n\t\t\t\tchmin(dp[bits][i], dp[bits | (1 << j)][j] + G[i][j]);\n\n\t}\n\tcout << (dp[0][0]==INF?-1:dp[0][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ninline int getbit(int mask, int v) {\n    return (mask >> v) & 1;\n}\n\ninline int newmask(int mask, int v) {\n    return mask | (1 << v);\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int cost[n][n];\n    vector <int> g[n];\n    int x, y, c;\n    for (int i = 0; i < m; i++) {\n        cin >> x >> y >> c;\n        g[x].push_back(y);\n       // g[y].push_back(x);\n        cost[x][y] = c;\n       // cost[y][x] = c;\n    }\n    int P = pow(2, n);\n    int d[P][n];\n    for (int i = 1; i < P; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = -1;\n        }\n    }\n    d[1][0] = 0;\n    const int INF = 1e9;\n    int ans = INF;\n    for (int mask = 1; mask < P; mask++) {\n        for (int v = 0; v < n; v++) {\n            if (d[mask][v] != -1) {\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    int u = g[v][i];\n                    if (mask < P - 1) {\n                        if (!getbit(mask, u)) {\n                            d[newmask(mask, u)][u] = d[mask][v] + cost[v][u];\n                        }\n                    } else {\n                        if (u == 0) {\n                            ans = min(ans, d[mask][v] + cost[v][0]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (ans == INF) {\n        cout << -1;\n    } else {\n        cout << ans;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int value;\n};\n\nstruct Node {\n    int value;\n    vector<Edge> edge;\n};\n\nint v, e;\nint s, t, d;\nNode node[15];\n\nint solve(int pos, int stat){\n\n    int cost = 1 << 24;\n\n    if(stat == (1 << v) - 1) return 0;\n    else if(stat & 1) return cost;\n\n    for(int i = 0; i < node[pos].edge.size(); ++i) {\n        if(!(stat & 1 << node[pos].edge[i].to)) {\n            cost = min(cost, solve(node[pos].edge[i].to, stat | 1 << node[pos].edge[i].to) + node[pos].edge[i].value);\n        }\n    }\n\n    return cost;\n\n}\n\nint main() {\n\n    cin >> v >> e;\n\n    for(int i = 0; i < e; ++i) {\n        cin >> s >> t >> d;\n        node[s].edge.push_back((Edge){t, d});\n    }\n\n    int dst = solve(0, 0);\n\n    if(dst == 1 << 24) {\n        cout << -1 << endl;\n    } else {\n        cout << dst << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_N 15\n#define INF 100000\n\nint n;\nint t[MAX_N][MAX_N];\n\nint dp[1 << MAX_N][MAX_N];\n\nint rec(int s, int v) {\n\tif (dp[s][v] >= 0) {\n\t\treturn dp[s][v];\n\t}\n\n\tif (s == (1 << n) - 1 && v == 0) return dp[s][v] = 0;\n\n\tint res = INF;\n\tfor (int u = 0; u < n; u++) {\n\t\tif (t[v][u] != INF && !(s >> u & 1)) {\n\t\t\tres = min(res, rec(s | 1 << u, u) + t[v][u]);\n\t\t}\n\t}\n\treturn dp[s][v] = res;\n}\n\nint main() {\n\tint m;\n\n\tcin >> n;\n\tcin >> m;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tt[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tt[a][b] = c;\n\t}\n\n\t/*for (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << t[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;*/\n\tif (rec(0, 0) == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << rec(0, 0) << endl;\n\t}\n\n\t/*for (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1ll << 60;\n\nint n;\nvector<vector<ll>> dist;\nvector<vector<ll>> dp;\n\nll solve(int s, int v){\n    if(dp[s][v] >= 0) return dp[s][v];\n    if(s==(1<<n)-1 && v==0) return dp[s][v] = 0;\n\n    ll ret = INF;\n    rep(nv, n){\n        if(!(s & (1<<nv))) ret = min(ret, solve(s|(1<<nv), nv) + dist[v][nv]);\n    }\n\n    dp[s][v] = ret;\n    return ret;\n}\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int m;\n    cin >> n >> m;\n\n    dist.assign(n, vector<ll>(n, INF));\n    rep(i, m){\n        int s, t;\n        ll d;\n        cin >> s >> t >> d;\n\n        dist[s][t] = d;\n    }\n\n    dp.assign(1<<n, vector<ll>(n, -1));\n    ll res = solve(0, 0);\n\n    if(res == INF) cout << -1 << endl;\n    else cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nint n;\nint d[15][15];\nint dp[1<<15][15];\n\nvoid solve()\n{\n  REP(i,(1<<n)) fill_n(dp[i],n,INF);\n  dp[(1<<n)-1][0] = 0;\n  DOWN(i,(1<<n)-2,0) REP(v,n) REP(u,n) if(!(i>>u&1))\n    dp[i][v] = min(dp[i][v],dp[i|1<<u][u]+d[v][u]);\n}\n\nint main()\n{\n  int m; cin >> n >> m;\n  REP(i,15) fill_n(d[i],15,INF);\n  REP(i,m)\n  {\n    int s,t,c; cin >> s >> t >> c;\n    d[s][t] = c;\n  }\n  solve();\n  cout << (dp[0][0]==INF?-1:dp[0][0]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <time.h>\n#include <random>\n#include <functional>\nusing namespace std;\n\nint dp[16][16];\nint V, E;\nint v[16][16] = { 0 };\nlist<int> li;\nlist<int>::iterator lp;\nint Max = -1;\n\nint same(int x) {\n\tfor (auto i = li.begin(); i != li.end();) {\n\t\tif (*i == x) return 0;\n\t\t++i;\n\t}\n\treturn 1;\n}\nvoid addsum(void) {\n\tint sum = 0;\n\tauto i = li.begin();\n\tauto j = i;\n\t++j;\n\tdo {\n\t\tsum += v[*i][*j];\n\t\t++i; ++j;\n\t} while (j != li.end());\n\tsum += v[*i][0];\n\tif (sum > Max) {\n\t\tMax = sum;\n\t}\n}\nvoid tansaku(list<int>::iterator p) {\n\tif (li.size() < V) {\n\t\tfor (int i = 1; i < V; ++i) {\n\t\t\tif (*p != i && v[*p][i] != -1) {\n\t\t\t\tif (same(i)) {\n\t\t\t\t\tli.push_back(i);\n\t\t\t\t\ttansaku(++p);\n\t\t\t\t\t--p;\n\t\t\t\t\tli.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (v[*p][0] != -1) {\n\t\t\taddsum();\n\t\t}\n\t}\n}\nint main() {\n\tfill(v[0], v[16], -1);\n\tint s, t, d;\n\tscanf_s(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tscanf_s(\"%d %d %d\", &s, &t, &d);\n\t\tv[s][t] = d;\n\t}\n\tli.push_back(0);\n\ttansaku(li.begin());\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1e9;\n\nint main(){\n  int v,e;\n  cin>>v>>e;\n  \n  int G[15][15];\n  rep(i,v){\n    rep(j,v) G[i][j]=INF;\n  }\n  \n  int s,t,d;\n  rep(i,e){\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  \n  int dp[1<<v][v];\n  rep(i,(1<<v)){\n    rep(j,v) dp[i][j]=INF;\n  }\n  dp[0][0]=0;\n  \n  for(int s=0;s<(1<<v);s++){\n    for(int i=0;i<v;i++){\n      for(int j=0;j<v;j++){\n        if((s&(1<<j))==0) continue;\n        if(G[i][j]==INF) continue;\n        dp[s][j]=min(dp[s][j],dp[s-(1<<j)][i]+G[i][j]);\n      }\n    }\n  }\n  \n  if(dp[(1<<v)-1][0]==INF) cout<<-1<<endl;\n  else cout<<dp[(1<<v)-1][0]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <time.h>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <limits>\n#include <type_traits>\n\nusing namespace std;\n#define SAY_YES cout << \"YES\" << endl;\n#define SAY_Yes cout << \"Yes\" << endl;\n#define SAY_NO cout << \"NO\" << endl;\n#define SAY_No cout << \"No\" << endl;\n#define IFYES(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"YES\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"NO\" << endl;  \\\n    }\n#define IFYes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"Yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"No\" << endl;  \\\n    }\n#define IFyes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"no\" << endl;  \\\n    }\n#define DEBUG_OUTPUT_ARRAY(XXX, ONE)                            \\\n    for (int i = 0; i < (ONE); i++)                             \\\n    {                                                           \\\n        cout << \"DEBUG: i = \" << i << \" -> \" << XXX[i] << endl; \\\n    }\n#define DEBUG_OUTPUT_ARRAY2(XXX, ONE, TWO)                             \\\n    for (int i = 0; i < (ONE); i++)                                    \\\n    {                                                                  \\\n        cout << \"<<< i = \" << i << \" >>>\" << endl;                     \\\n        for (int j = 0; j < (TWO); j++)                                \\\n        {                                                              \\\n            cout << \"DEBUG: j = \" << j << \" -> \" << XXX[i][j] << endl; \\\n        }                                                              \\\n    }\n#define DEBUG_OUTPUT_ARRAY2_BOX(XXX, ONE, TWO) \\\n    for (int i = 0; i < (ONE); i++)            \\\n    {                                          \\\n        cout << i << \"  \";                     \\\n        for (int j = 0; j < (TWO); j++)        \\\n        {                                      \\\n            cout << XXX[i][j] << \" \";          \\\n        }                                      \\\n        cout << endl;                          \\\n    }\n\ntypedef pair<long long int, long long int> pll;\n\n\nconst long long int mod = 1000000007;\nconst long long int INF = 1e18;\nlong long int V,E,s[2000],t[2000],d[2000];\nlong long int dp[100000][16]={},edge[30][30]={};\n\nvoid dfs(long long int now){\n\n}\n\nint main()\n{\n    cout << fixed << setprecision(18);\n    cin>>V>>E;\n    for(long long int i = 0; i < 20; i++){\n        for(long long int j = 0; j < 20; j++){\n            edge[i][j]=INF;\n        }\n    }\n    for(long long int i = 0; i < E; i++){\n        cin>>s[i]>>t[i]>>d[i];\n        edge[s[i]][t[i]]=d[i];\n        //edge[t[i]][s[i]]=d[i];\n    }\n\n    for(long long int i = 0; i < (1<<V); i++){\n        for(long long int j = 0; j < V; j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][0]=0;\n    \n    for(long long int i = 0; i < (1<<V); i++){\n        for(long long int j = 0; j < V; j++){\n            for(long long int k = 0; k < V; k++){\n                if((i&(1<<k))==0)dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k],dp[i][j]+edge[j][k]);\n            }\n        }\n    }\n    long long int res=dp[(1<<V)-1][0];\n    if(res==INF){res=-1;}\n    cout<<res<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 18\n\nconst int INF = 1001001001;\n\nint n;\nint cost[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\n\nint dfs(int x, int k){\n    if(dp[x][k] != -1) return dp[x][k];\n\n    if(x == (1<<n) - 1){\n        dp[x][k] = cost[k][0];\n        return dp[x][k];\n    }\n\n    dp[x][k] = INF;\n    bitset<MAX_N> f(x);\n\n    rep(i,n){\n        if(f[i] == 0){\n            dp[x][k] = min(dp[x][k], dfs(x|(1<<i), i) + cost[k][i]);\n        }\n    }\n\n    return dp[x][k];\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    rep(i,n)rep(j,n)cost[i][j] = INF;\n\n    rep(i,m){\n        int s, t, d;\n        cin >> s >> t >> d;\n        cost[s][t] = d;\n        // cost[t][s] = d;\n    }\n\n    rep(i,1<<n)rep(j,n)dp[i][j] = -1;\n\n    int ans = dfs(1,0);\n\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\nusing namespace std;\nconst int INF=INT_MAX/2;\n\nstruct edge { int to, weight;};\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n\nint  DP[1 << 15][15];\n\nint rec(int S, int v, int V, Graph &G){\n\tif(DP[S][v]>=0){\n\t\treturn DP[S][v];\n\t}\n\tif (S==(1 << V)-1 && v==0) \n\t{\n\t\treturn DP[S][v]=0;\n\t}\n\n\tint r = INF;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge f = G[v][i];\n\t\tif((S >> f.to)%2==0){\n\t\t\tr=min(r,rec((S | (1 << f.to)) ,f.to,V,G)+f.weight);\n\t\t}\n\t}\n\treturn DP[S][v]=r;\n}\n\nint main(){\n\tint V,E,d,s;\n\tedge e;\n\tcin >> V >> E ;\n\n\tGraph G(V);\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> e.to >> e.weight;\n\t\tG[s].push_back(e);\n\t}\n\n\tmemset(DP,-1,sizeof(DP));\n\tcout << rec(0,0,V,G) <<endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P>Vec;\n\nint v,e;\nVec Edge[15];\n\nint solve(int bit,int now);\n\nint main(){\n  int s,t,d;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    cin>>s>>t>>d;\n    Edge[s].push_back(P(t,d));\n  }\n  int ans=solve(0,0);\n  if(ans==(1<<30))cout<<\"-1\"<<endl;\n  else cout<<ans<<endl;\n}\n\nint solve(int bit,int now){\n  int cost=1<<30;\n  \n  // ->goal\n  if(bit== (1<<v)-1)return 0;\n  // <-goal\n  \n  for(int i=0;i<Edge[now].size();i++){\nif((bit & 1 << Edge[now][i].first)==0){\n      cost=min(cost,solve(bit | 1 << Edge[now][i].first,Edge[now][i].first)+Edge[now][i].second);\n    }\n  } \n  return cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconst int MAX_N = 15;\nconst int INF = (int)1e8;\n\nint V;\nint dp[MAX_N][1 << MAX_N];\nvector<pair<int, int>> G[MAX_N];\n\nint start;\n\nint tsp(unsigned S, int v) {\n  if(dp[v][S] != -1) return dp[v][S];\n  if(S == 0 && v == start) return 0;\n  int res = INF;\n  for(int i = 0; i < (int)G[v].size(); i++) {\n    int next = G[v][i].first;\n    int d = G[v][i].second;\n    if(S >> next & 1) {\n      res = min(res, d + tsp(S & ~(1 << next), next));\n    }\n  }\n  return dp[v][S] = res;\n}\n\nint main() {\n  int E; cin >> V >> E;\n  while(E--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    G[s].push_back(make_pair(t, d));\n  }\n  int res = INF;\n  for(int i = 0; i < V; i++) {\n    start = i;\n    memset(dp, -1, sizeof(dp));\n    res = min(res, tsp((1 << V) - 1, i));\n  }\n  if(res == INF) cout << \"-1\" << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<map>\n#include<set>\n#include<queue>\n#include<functional>\n#include<math.h>\nusing namespace std;\n#define N (1000000000+7)\n#define INF 1e16\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \n\nll dp[(1LL<<16)-1][16];\nll n,e;\nll d[20][20];\n\nll rec(ll S,ll v){\n    if(dp[S][v]>=0)return dp[S][v];\n    if((S==(1<<n)-1)&& v==0){\n        return dp[S][v]=0;\n    }\n    ll ans = (ll)INF;\n    for(ll u=0;u<n;u++){\n        if(!((S>>u)&1)){\n            ans = min(ans,rec(S|(1<<u),u)+d[v][u]);\n        }\n    }\n    return dp[S][v]=ans;\n}\n\nint main(void){\n    for(ll i=0;i<20;i++){\n        for(ll j=0;j<20;j++){\n            d[i][j]=(ll)INF;\n        }\n    }\n    cin>>n>>e;\n    for(ll i=0;i<(1<<n);i++){\n        for(ll j=0;j<=n;j++){\n            dp[i][j]=-1;\n        }\n    }\n    for(ll i=0;i<e;i++){\n        ll s,t,di;\n        cin>>s>>t>>di;\n        d[s][t]=di;\n    }\n    dp[0][0] = rec(0,0);\n    if(dp[0][0]==(ll)INF)cout<<-1<<endl;\n    else cout<<dp[0][0]<<endl;;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nclass edge{\n    public:\n    int t,d,lim;\n    edge(int it,int id,int ilim){\n        t=it;   d=id;   lim=ilim;\n    }\n    bool operator>(edge a){\n        return lim>a.lim;\n    }\n    bool operator<(edge a){\n        return lim<a.lim;\n    }\n    bool operator>=(edge a){\n        return lim>=a.lim;\n    }\n    bool operator<=(edge a){\n        return lim<=a.lim;\n    }\n    bool operator==(edge a){\n        return lim==a.lim;\n    }\n};\nvector<edge> e[20];\nll dp[16][1<<16];\nint main(){\n    int n,m;    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int s,t,d,ti;   cin>>s>>t>>d>>ti;\n        e[s-1].push_back(edge(t-1,d,ti));\n        e[t-1].push_back(edge(s-1,d,ti));\n    }\n    for(int i=0;i<n;i++){\n        for(int j=(1<<n)-1;j>=0;j--){\n            dp[i][j]=2e14;\n        }\n    }\n    dp[0][0]=0;\n    for(int i=0;i<(1<<n)-1;i++){\n        for(int j=0;j<n;j++){\n            if(dp[j][i]==2e14)  continue;\n            for(int k=0;k<(int)e[j].size();k++){\n                if(dp[j][i]+e[j][k].d<=e[j][k].lim){\n                    int next=i|(1<<e[j][k].t);\n                    if(next==i) continue;\n                    if(dp[e[j][k].t][next]>dp[j][i]+e[j][k].d){\n                        dp[e[j][k].t][next]=dp[j][i]+e[j][k].d;\n                    }\n                }\n            }\n        }\n    }\n    if(dp[0][(1<<n)-1]==2e14){\n        cout<<-1<<endl;\n        return 0;\n    }\n    cout<<dp[0][(1<<n)-1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Contents   : DPL 2 A\n * Author     : Kitaura Hiromi\n * LastUpdate : 20180626\n * Since      : 20180626\n */\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 15\n#define INF 1<<20\nint n;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\n\nint main(void){\n    fill((int*)dp, (int*)(dp+MAX_N), INF);\n    dp[(1<<n) - 1][0] = 0;\n\n    for(int S=(1<<n)-2; S>=0; S--){\n        for(int v=0; v<n; v++){\n            for(int u=0; u<n; u++){\n                if(!(S>>u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + dp[v][u]);\n                }\n            }\n        }\n    }\n    cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit ( int mask, int num )\n{\n\treturn ( mask >> num ) & 1;\n}\ninline int add_bit ( int mask, int num )\n{\n\treturn ( mask + ( 1 << num ) );\n}\n\n\nint main ()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph ( n );\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back ( make_pair ( destiny, len ) );\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow ( 2, n );\n\tvector < vector < int > > dp ( max_mask, vector < int > ( n, -1 ) );\n\tdp[1][0] = 0;\n\tfor ( int mask = 1; mask < max_mask; mask++ )\n\t{\n\t\tif ( mask == 23 )\n\t\t{\n\t\t\tint a = 0;\n\t\t}\n\t\tfor ( int vertex = 0; vertex < n; vertex++ )\n\t\t{\n\t\t\tfor ( i = 0; i < graph[vertex].size (); i++ )\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif ( !get_bit ( mask, next ) && (dp[mask][vertex] != -1) )\n\t\t\t\t{\n\t\t\t\t\tif ( ( dp[add_bit ( mask, next )][next] < ( dp[mask][vertex] + graph[vertex][i].second ) ) || ( -1 == dp[add_bit ( mask, next )][next] ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[add_bit ( mask, next )][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor ( i = 1; i < n; i++ )\n\t{\n\t\tfor ( j = 0; j < graph[i].size (); j++ )\n\t\t{\n\t\t\tif ( 0 == graph[i][j].first )\n\t\t\t{\n\t\t\t\tif ( ( result > dp[max_mask - 1][i] + graph[i][j].second ) || ( result == -1 ) )\n\t\t\t\t{\n\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,Q,K,A,B;\nstring S;\nconst ll MOD = 998244353;\n//const ll MOD = (1e+9) + 7;\ntypedef pair<ll, ll> P;\nconst ll INF = (1LL<<50);\n\ntemplate<class T> bool chmin(T &a, const T &b){\n    if(a > b) {a = b; return true;}\n    else return false;\n}\n\nstruct edge{\n    int to, cost;\n    edge(){}\n    edge(int a, int b){\n        to = a;\n        cost = b;\n    }\n};\ntypedef vector<edge> ve;\nll dfs(vector<ve> &G, mat &dp, int s, int v){\n    if(dp[s][v] != -1) {\n        return dp[s][v];\n    }else if(s == (1<<N) - 1){\n        return INF;\n    }\n    dp[s][v] = INF;\n    for(edge e : G[v]){\n        if(!((s>>e.to)&1)){\n            chmin(dp[s][v], dfs(G, dp, s | (1<<e.to), e.to) + e.cost);\n        }\n    }\n    return dp[s][v];\n}\n\nint main() {\n    cin>>N>>M;\n    vector<ve> G(N, ve(0));\n    rep(i,M){\n        int s, t, d;\n        cin>>s>>t>>d;\n        G[s].emplace_back(t, d);\n    }\n    mat dp((1<<N), vec(N, -1));\n    dp[(1<<N) - 1][0] = 0;\n    cout<<(dfs(G, dp, 0, 0) == INF ? -1 : dp[0][0])<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nll dis[20][20];\nll dp[1<<15][15];\n\nint main(int argc, char const* argv[])\n{\n  int n, m; cin >> n >> m;\n  rep(i, n)rep(j, n)dis[i][j] = inf;\n  rep(i, m){\n    int s, t, d; cin >> s >> t >> d;\n    dis[s][t] = d;\n  }\n  rep(i, 1 << n){\n    rep(j, n)dp[i][j] = linf;\n  }\n  dp[1][0] = 0;\n  rep(i, 1 << n){\n    if(__builtin_popcount(i) <= 1 || i % 2 == 0)continue;\n    rep(j, n){\n      if(!((i >> j) & 1))continue;\n      int st = i ^ (1 << j);\n      rep(k, n){\n        if((st >> k) & 1){\n          chmin(dp[i][j], dp[st][k] + dis[k][j]);\n        }\n      }\n    }\n  }\n\n  ll res = linf;\n  rep(i, n){\n    if(dp[(1<<n)-1][i] != linf)chmin(res, dp[(1<<n)-1][i] + dis[i][0]);\n  }\n  cout << (res >= inf ? -1: res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(ll)(b);i>=(ll)(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\nll v,e;\nvector< vector< edge< ll > > > g;\nll dp[15][1<<15];\nll f(ll x,ll mask){\n    if(x==0&&mask==(1<<v)-1)return 0;\n    if(dp[x][mask]!=-1)return dp[x][mask];\n    ll ret=LINF;\n    rep(i,g[x].size()){\n        if((mask>>g[x][i].to&1)==0){\n            chmin(ret,f(g[x][i].to,mask|1<<g[x][i].to)+g[x][i].cost);\n        }\n    }\n    return dp[x][mask]=ret;\n}\nvoid solve(){\n    cin>>v>>e;\n    g=vector< vector< edge< ll > > >(v);\n    rep(i,e){\n        ll s,t,d;cin>>s>>t>>d;\n        g[s].push_back(edge<ll>(t,d));\n    }\n    memset(dp,-1,sizeof(dp));\n    ll ans=f(0,0);\n    cout<<(ans==LINF?-1:ans)<<endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever while(true)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing pii   = std::pair<int, int>;\nusing vi    = std::vector<int>;\nusing vd    = std::vector<double>;\nusing vc    = std::vector<char>;\nusing vb    = std::vector<bool>;\nusing vs    = std::vector<std::string>;\nusing vpii  = std::vector<pii>;\nusing vvi   = std::vector<vi>;\nusing vvb   = std::vector<vb>;\nusing vvpii = std::vector<vpii>;\ntemplate<typename A> using fn = std::function<A>;\nconstexpr int INF   = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD   = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0)\n    : src(s), dst(d), weight(w) {\n  }\n};\n\nusing Edges  = std::vector<Edge>;\nusing Array  = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  // clang-format off\n  Graph(const int &size = 0) : g(size) { }\n\n  void addArc(const int &src, const int &dst, const Weight &w = 1) {\n    g[src].emplace_back(src, dst, w);\n  }\n\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n\n  Graph toRootedTree(int r);\n  std::vector<Weight> dijkstra(const int &src, const int &inf);\n  Matrix warshallFloyd(const int &inf);\n  std::pair<Weight, Edges> prim(const int &r);\n  template<typename UnionFind> std::pair<Weight, Edges> kruskal();\n  Weight solveTSP(const int &inf);\n  // clang-format on\n};\n\nWeight Graph::solveTSP(const int &inf = std::numeric_limits<Weight>::max() / 8) {\n  int n = g.size();\n  Matrix dp(1 << n, Array(n, inf));\n  dp[0][0] = 0;\n  rep(s, 1 << n) {\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (~s >> e.dst & 1) cmin(dp[s | 1 << e.dst][e.dst], dp[s][e.src] + e.weight);\n      }\n    }\n  }\n  return dp.back().front();\n}\n\nmain {\n  int v, e;\n  cin >> v >> e;\n  Graph g(v);\n  while (e--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g.addArc(s, t, d);\n  }\n  Weight x = g.solveTSP(INF);\n  cout << (x == INF ? -1 : x) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define ll long long\nusing namespace std;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> LP;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n//template<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    vector<vector<ll>> G(N,vector<ll>(N, LINF));\n    REP(i,M){\n        int a, b;\n        ll d;\n        cin >> a >> b >> d;\n        G[a][b] = d;\n    }\n    vector<vector<ll>> dp(N, vector<ll>(1<<N,LINF));\n    dp[0][0] = 0;\n    for(int i=1;i<(1<<N);i++){\n        REP(j,N) if(i >> j & 1){\n            REP(k,N) if(G[j][k] != LINF){\n                ll cost = dp[j][i-(1<<j)] + G[j][k];\n                chmin(dp[k][i],cost);\n            }\n        }\n    }\n    if(dp[0][(1<<N) - 1] == LINF) cout << -1 << endl;\n    else cout << dp[0][(1<<N)-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint n, m;\nV< V<int> > d;\nV< V<int> > dp;\n\nint rec(int state, int v) {\n    if (state == (1 << n) - 1 && v == 0) return dp[state][v] = 0;\n    if (dp[state][v] >= 0) return dp[state][v];\n\n    int ans = INF;\n    for (int to = 0; to < n; to++) {\n        if ((state >> to) & 1) continue;\n        chmin(ans, rec(state | (1 << to), to) + d[v][to]);\n    }\n\n    return dp[state][v] = ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    d.resize(n, V<int>(n, INF));\n    for (int i = 0; i < m; i++) {\n        int s, t, tmpd; cin >> s >> t >> tmpd;\n        d[s][t] = tmpd;\n    }\n\n    dp.resize(1 << n, V<int>(n, -1));\n    int ans = rec(0, 0);\n    if (ans == INF) ans = -1;\n    cout << ans << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 10000000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//priority_queue<int,vector<int>, greater<int> > q2;\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M; cin >> N >> M;\n\tvector<VI>dp(1 << N, VI(N, INF));\n\tvector<VI>d(N, VI(N, INF));\n\n\tREP(i, M) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\td[a][b] = c;\n\t}\n\n\tdp[(1 << N) - 1][0] = 0;\n\n\tfor (int S = (1 << N) - 2; S >= 0; S--) {\n\t\t//cout << S << endl;\n\t\tREP(v, N) {\n\t\t\tREP(u, N) {\n\t\t\t\tif (!(S >> u & 1)) {\n\t\t\t\t\tchmin(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[0][0] != INF ? dp[0][0] : -1) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint d[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint tsp(int v, int b, int city_num){\n    int rtn = MAX;\n    //??¨????????????????¨???????????????´???\n    if(b == (1 << city_num) - 1){\n        if (d[v][0] == -1) {\n            return rtn;\n        }else{\n            return d[v][0];\n        }\n    }\n    \n    for (int i = 0; i < city_num; i++) {\n        //??????????¨???????????????§????????´???\n        if (\n            !(b & (1 << i))\n            &&\n            d[v][i] != -1\n            )\n        {\n            rtn = min(\n                      rtn,\n                      d[v][i] + tsp(i, b | (1 << i), city_num)\n                      );\n        }\n    }\n    \n    return rtn;\n}\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(d, -1, sizeof(d));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        d[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1, V);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nstruct edge {\n\tll u;\n\tll v;\n\tll cost;\n\tedge() {}\n\tedge(ll u, ll v, ll c) :u(u), v(v), cost(c) {}\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll V, E; cin >> V >> E;\n\tvector<vector<edge>> G(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tll s, t, d; cin >> s >> t >> d;\n\t\tG[s].emplace_back(edge(s, t, d));\n\t}\n\t/* dp[i][j] := ?????????j???????????¨???, bit???i??????????????°????????§???????????????????????¢ */\n\tvector<vector<ll>> dp(1 << V, vector<ll>(V, INF));\n\tdp[0][0] = 0; // ??????0???????§???????\n\t for (int j = 0; j < V;j++){\n\tfor (int i = 0; i < (1 << V);i++) {\n\t\t\tfor (auto e : G[j]) {\n\t\t\t\tif (!((i >> e.v) & 1)) {\n\t\t\t\t\tdp[i | (1 << e.v)][e.v] = min(dp[i | (1 << e.v)][e.v], dp[i][e.u] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ret = dp[(1 << V) - 1][0]; // ??¨?????????????????????, 0????????£?????????\n\tif (ret == INF)ret = -1;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <math.h>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vb = vector<bool>;\nusing qi = queue<int>;\nusing Graph = vector<vector<int>>;\n\n#define FOR(i, a, b) for (int i = a; i < (b); i++)\n#define REP(i,n) for(int i=0;i<n;i++)\n\nconst int inf = 100000000;\nconst int maxn = 15;\nint dist[maxn][maxn];\nint dp[1<<maxn][maxn];\nint n, m;\n\nint dfs(int s, int v) {\n    if (dp[s][v] >= 0) {\n        return dp[s][v];\n    }\n\n    if (s == (1 << n)-1 && v == 0) {\n        dp[s][v] = 0;\n        return 0;\n    }\n\n    int ans = inf;\n    REP(u, n) {\n        if (!(s >> u & 1) && dist[v][u] < inf) {\n            ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n        }\n    }\n\n    dp[s][v] = ans;\n    return ans;\n}\n\nint main () {\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\n    REP(i, maxn) {\n        REP(j, maxn) {\n            dist[i][j] = inf;\n        }\n    }\n    REP(i, 1 << maxn) {\n        REP(j, maxn) {\n            dp[i][j] = -1;\n        }\n    }\n\n    cin >> n >> m;\n    REP(i, m) {\n        int s, t, d; cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    \n    int ans = dfs(0, 0);\n    cout << (ans == inf ? -1 : ans) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nll dp[1 << 16][16];\nll d[16][16];\n\nvoid solve() {\n    int V, E; cin >> V >> E;\n    rep(i, 16)rep(j, 16) d[i][j] = INF;\n    rep(i, E){\n        int v, u, dd; cin >> v >> u >> dd;\n        d[v][u] = dd;\n    }\n    ll res = INF;\n    rep(i, V){\n        rep(j, 1 << 16)rep(k, 16) dp[j][k] = INF;\n        dp[(1 << V) - 1][i] = 0;\n        per(S, (1<<V)-1){\n            rep(v, V){\n                rep(u, V){\n                    if((S >> u) & 1) continue;\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n                }\n            }\n        }\n        res = min(res, dp[0][i]);\n    }\n    if(res == INF) cout << -1 << endl;\n    else cout << res << endl;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint V, E;\nint dp[1 << 15][20];\nsigned main() {\n    cin >> V >> E;\n    vector< vector<pii> > G(V);\n    rep(i,0,E) {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].pb(pii(t, d));\n    }\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,(1<<V)) rep(j,0,20) dp[i][j] = INF;\n    dp[(1<<V)-1][0] = 0;\n    \n    repr(bit,(1<<V)-2,0) {\n        rep(i,0,V) {\n            rep(j,0,G[i].size()) {\n                int to = G[i][j].fr, cost = G[i][j].sc;\n                if(bit >> to & 1) continue;\n                int nbit = bit | (1 << to);\n                dp[bit][i] = min(dp[bit][i], dp[nbit][to] + cost);\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,0,V) ans = min(ans, dp[0][i]);\n    if(ans != INF) cout << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint a, b, c, d;\n\tcin << a << b << c\n\tfor( int i = a; i <= b; i++){\n\tif( c&i == 0 ){ ++d }\n\t}\n\tcout >> d >> endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int V_MAX = 15;\nconst int INF = 10000000;\n\nint n, e;\nint g[V_MAX][V_MAX];\nint dp[1 << V_MAX][V_MAX];\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1 && v == 0)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u))) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &e);\n    fill(&g[0][0], &g[n][0], INF);\n    for (int i = 0; i < e; ++i) {\n        int s, t, d;\n        scanf(\"%d %d %d\", &s, &t, &d);\n        g[s][t] = d;\n    }\n\n    fill(&dp[0][0], &dp[1 << V_MAX][0], -1);\n    int d = tsp(0, 0);\n    if (d == INF)\n        printf(\"-1\\n\");\n    else\n        printf(\"%d\\n\", d);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(((1 << k) & tmp) == 0 || result[tmp][k].first == mod || graph[k][j] == 0) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    for(int i = 0; i < v; i++){\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 巡回セールスマン問題(traveling-salesman problem)を扱います\n *\n * @note  巡回セールスマン問題はハミルトン閉路問題に密接に関連した問題で、セールスマンはn個の都市を訪問しなければならない\n *        この問題をn個の頂点を持つ完全グラフとして定式化すると、各都市を正確に1回だけ訪れ、最初に出発した都市で終わる巡回路(tour)\n *        あるいはハミルトン閉路を構成することがセールスマンの目的であるが、都市iから都市jに移動するのに非負整数のコストc(i, j)が\n *        かかるので、全コストが最小になるようにしたいというのがセールスマンの希望である. ここで、全コストは巡回路の辺に\n *        割り当てられていたコストの総和である\n *\n * @note  巡回セールスマン問題はNP完全であり、多項式時間の効率的なアルゴリズムは知られていない. しかし、動的計画法を用いることで\n *        ある程度nが小さいサイズならば、厳密解を与えることができる\n *\n * @date  2016/05/08\n */\n\n\n\n//********************************************************************************\n// 必要なヘッダファイルのインクルード\n//********************************************************************************\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n\n\n//********************************************************************************\n// オブジェクト形式マクロの定義\n//********************************************************************************\n\n#define GRAPH_BEGIN namespace graph {\n#define GRAPH_END   }\n\n\n\n//********************************************************************************\n// 名前空間の始端\n//********************************************************************************\n\nGRAPH_BEGIN\n\n\n\n//********************************************************************************\n// 型シノニム\n//********************************************************************************\n\nusing weight_t   = std::int32_t;  /**< 辺(u, v)への重みwを表す型 */\nusing index_t    = std::int32_t;  /**< 頂点vの添字を表す型       */\nusing capacity_t = weight_t;      /**< 辺(u, v)の容量を表す型    */\nusing bool_t     = std::int32_t;  /**< ブール値は整数型で、{ false 0 true それ以外 }とする */\n\n\n\n//********************************************************************************\n// 構造体の定義\n//********************************************************************************\n\n/**\n * @brief  頂点色列挙構造体(scoped enum)\n * @detail (u, v) ∈ Eで頂点uが黒ならば頂点vは灰か黒である\n *         すなわち、黒頂点に隣接する全ての頂点は発見済みである\n *         灰頂点は白頂点に隣接することがあり、これらの頂点が既発見頂点と未発見頂点の境界をなす\n */\nenum struct vcolor : std::int32_t {\n    white,  /**< 未発見頂点 */\n    black,  /**< 既発見頂点 */\n    gray,   /**< 既見済頂点 */\n};\n\n/**\n * @brief グラフ用ノード(頂点) \n */\nstruct vertex {\n    union {\n        weight_t d;       /**< 始点sからの距離  */\n        weight_t key;     /**< Primのアルゴリズムにおいて木に属するある頂点とを結ぶ重み */\n    };\n    index_t pi;           /**< 先行頂点(の添字) */\n    union {\n        vcolor color;     /**< 頂点の色        */\n        bool_t  visited;  /**< 発見済みか?     */\n    };\n    // weight_t f;           /**< 終了時刻印(DFSにおいて、黒色に彩色されたとき、刻まれる)     */\n    vertex() : d(0), pi(0), color(vcolor::white)/*, f(0)*/ {}\n};\n\n/**\n * @brief グラフ用エッジ(辺)\n * @note  G = (V, E)を重み関数wを持つ重み付きグラフとすると、\n *        辺(u, v) ∈ Eの重みはw(u, v)と表される\n */\nstruct edge {\n    index_t  src;   /**< 辺の始点u */\n    index_t  dst;   /**< 辺の終点v */\n    union {\n        weight_t w;     /**< 辺(u, v)への重み(コスト) */\n        capacity_t c;   /**< 辺(u, v)の容量 */\n    };\n    edge() = default;\n    edge(index_t src, index_t dst) : src(src), dst(dst), w(1) {}\n    edge(index_t src, index_t dst, weight_t w) : src(src), dst(dst), w(w) {}\n};\n\n\n\nnamespace limits {\n    enum {  // scopedではあるが強く型付けされたenum(strongly-typed enum)ではない\n        inf = std::numeric_limits<weight_t>::max() / 3,  /**< @brief 辺が存在しない場合に使用される値     */\n        nil = std::numeric_limits<index_t>::min() / 3,   /**< @brief 先行点が存在しない場合に使用される値 */\n    };\n}\n\n\n\n//********************************************************************************\n// 型シノニムその2\n//********************************************************************************\n\nusing edges_t    = std::vector<edge>;      /**< グラフG=(V, E)の辺集合E   */\nusing vertices_t = std::vector<vertex>;    /**< グラフG=(V, E)の頂点集合V */\nusing array_t    = std::vector<weight_t>;  /**< 重みwの配列  */\nusing indices_t  = std::vector<index_t>;   /**< 頂点の添字配列 */\nusing stamps_t   = std::vector<bool_t>;    /**< ブーリアンの集合 */\nusing matrix_t   = std::vector<array_t>;   /**< グラフGの隣接行列表現(および表行列表現) */\nusing graph_t    = std::vector<edges_t>;   /**< グラフGの隣接リスト表現(こちらを主に使用する) */\n\n\n\n//********************************************************************************\n// 型シノニムその3\n//********************************************************************************\n\nusing vset_t = std::size_t;  // 頂点集合のビット表現\n\n\n\n//********************************************************************************\n// 関数の定義\n//********************************************************************************\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param vset_t  S    最小重みが決定された頂点集合S(ビット表現)\n * @param index_t u    現在探索している頂点u\n * @param const matrix_t& W  隣接行列W\n * @param matrix_t& D  uにいる状態から残りすべての頂点を辿って始点s(=0)に戻る閉路の重みの総和の最小値をD[S][u]に格納した行列D\n */\nweight_t lookup_tsp(vset_t S, index_t u, const matrix_t& W, matrix_t& D)\n{\n    // 訪問済みなら返ります\n    if (D[S][u] >= 0) { return D[S][u]; }\n\n    // すべての頂点を訪れて戻ってきた\n    index_t n = W.size();\n    if ((S == ((1 << n) - 1)) && u == 0) { return D[S][u] = 0; }\n\n    weight_t d = limits::inf;  // uにいる状態から残りすべての頂点を辿って始点に戻る閉路の重みの総和の最小値をdとする\n    \n    for (index_t v = 0; v < n; v++) {       // 次の状態vを探索\n        if ((S >> v) & 0x01) { continue; }  // 訪問済みならcontinue\n        d = std::min(d, (lookup_tsp(S | 1 << v, v, W, D) + W[u][v]));  // dの更新\n    }\n    return D[S][u] = d;\n}\n\n\n/**\n * @brief 履歴管理法によって巡回セールスマン問題に厳密解を与えます\n *\n * @param  index_t s    始点s\n * @param  const matrix_t& W  隣接行列W\n * @return ハミルトン閉路Hの最小重み\n */\nweight_t memoized_tsp(index_t s, const matrix_t& W)\n{\n    std::size_t n = W.size();            // n = W.rows\n    matrix_t D(1 << n, array_t(n, -1));  // Dを2^n x n型の新しい行列とする\n\n    return lookup_tsp(0, s, W, D);\n}\n\n\n\n//********************************************************************************\n// 名前空間の終端\n//********************************************************************************\n\nGRAPH_END\n\n\n\n//********************************************************************************\n// エントリポイント\n//********************************************************************************\n\nint main()\n{\n    using namespace std;\n\n    using namespace graph;\n\n    index_t V, E;\n    cin >> V >> E;\n\n    matrix_t W(V, array_t(V, limits::inf));\n    for (index_t i = 0; i < V; i++) { W[i][i] = 0; }\n\n    index_t s, t;\n    weight_t d;\n    for (index_t i = 0; i < E; i++) {\n        cin >> s >> t >> d;\n        W[s][t] = d;\n    }\n\n    d = memoized_tsp(0, W);\n    if (d >= limits::inf) { cout << -1 << endl; }\n    else { cout << d << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n#include<tuple>\n\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\ntypedef tuple<int, int, int> tpl;\nint dx[4] = { 1,0,0,-1 };\nint dy[4] = { 0,1,-1,0 };\n\n#define ARRAY_MAX 10005 \n\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\nint V, E;\nint dp[1 << 15][15];//dp[i][j]:=今まで訪れた頂点の情報がiで現在頂点jに入る時に出発点に戻る最小コスト\n//0ならまだ訪れていない、1なら訪れた\nint mp[15][15];//辺の重みの情報\n\nvoid solve() {\n\n\tfor (int i = 0; i < (1 << 15); i++)\n\t{\n\t\tfor (int j = 0; j < 15; j++)\n\t\t{\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\n\tfor (int S = 0; S < (1 << V); S++)\n\t{\n\t\tfor (int from = 0; from < V; from++)\n\t\t{\n\t\t\tif (dp[S][from] == INF)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tfor (int to = 0; to < V; to++)\n\t\t\t{\n\t\t\t\t//移動先\n\t\t\t\tif ((S >> to) & 1)\n\t\t\t\t{\n\t\t\t\t\t//既に訪れている\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mp[from][to] == INF)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//toに移動できる場合\n\t\t\t\tdp[S | (1 << to)][to] = min(dp[S | (1 << to)][to], dp[S][from] + mp[from][to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\tcin >> V >> E;\n\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tfor (int j = 0; j < 15; j++)\n\t\t{\n\t\t\tmp[i][j] = INF;\n\t\t}\n\t}\n\n\t//辺の情報を受け取る\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;//0-indexで入力が来る\n\t\tmp[s][t] = d;//s→tのコストがdである\n\t}\n\n\tsolve();\n\n\tif (dp[(1 << V) - 1][0] == INF)\n\t{\n\t\t//経路が存在しなかった\n\t\tcout << \"-1\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << dp[(1 << V) - 1][0] << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nconst int MAX_V = 15;\n\nint V, E;\nint dist[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\nint s;\nconst int INF = 1000000;\n\nint rec (int S, int v){\n    if(dp[S][v] != -1) return dp[S][v];\n\n    if(S == (1<<V)-1 && v == s) return dp[S][v] = 0;\n\n    int res = INF;\n    for(int u = 0; u < V; u++){\n        if(!(S>>u & 1)){\n            res = min(res, rec(S | (1<<u),u) + dist[v][u]);\n        }\n    }\n\n    return dp[S][v] = res;\n}\n\nint main(){\n    rep(i, MAX_V) rep(j, MAX_V) dist[i][j] = INF;\n    cin >> V >> E;\n    rep(i, E){\n        int from, to, cost;\n        cin >> from >> to >> cost;\n        dist[from][to] = cost;\n    }\n\n    int res = INF;\n    rep(i,V){\n        memset (dp, -1, sizeof(dp));\n        s = i;\n        res = min(res, rec(0, i));\n    }\n    cout << (res == INF ? -1 : res) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconstexpr int INF = 1e9;\nint V, E;\nvector<vector<int>> dp, dist;\n\nint dfs(int vis, int v) {\n    if (vis == ((1<<V)-1)) return v ? INF : 0;\n    int& res = dp[vis][v];\n    if (res > 0) return res;\n    res = INF;\n    for (int i = 0; i < V; i++) {\n        if ((vis>>i)&1) continue;\n        res = min(res, dist[v][i]+dfs(vis|(1<<i), i));\n    }\n    return res;\n}\n\nint main() {\n   cin >> V >> E;\n   dist = vector<vector<int>>(V, vector<int>(V, INF));\n   for (int i = 0; i < E; i++) {\n       int s, t, d;\n       cin >> s >> t >> d;\n       dist[s][t] = d;\n   }\n   dp = vector<vector<int>>(1<<V, vector<int>(V, -1));\n   int res = dfs(0, 0);\n   cout << (res < INF ? res : -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define lper(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define at(x,i) get<i>(x);\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\nll modfac(ll a){\n    ll ans=1;\n    while(a>1){\n        ans*=a;\n        ans%=1000000007;\n        a--;\n    }\n    return ans;\n}\nll modinv(ll a,ll m) {\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m; \n    if (u < 0) u += m;\n    return u;\n}\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) {}\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    ll n,m;cin >> n >>m;\n    vvl dist(n,vl(n,inf));\n    rep(i,m){\n        ll a,b,c;cin >> a >>b >>c;\n        dist[a][b]=c;\n    }\n    ll ans=INF;\n    vvl dp(1<<n,vl(n,inf));\n    dp[1][0]=0;\n    rep(bit,1<<n){\n        rep(i,n){\n            if(bit&1<<i){\n                rep(j,n){\n                    if(i==j)continue;\n                    if(bit&1<<j){\n                        chmin(dp[bit][i],dp[bit-(1<<i)][j]+dist[j][i]);\n                    }\n                }\n            }\n        }\n    }\n    ll all=(1<<n)-1;\n    rep(i,n){\n        chmin(ans,dp[all][i]+dist[i][0]);\n    }\n    if(ans>inf/10)cout << -1 << endl;\n    else cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint V,E,G[15][15],dp[1<<15][15];\nconst int INF = 1000000;\n\nint solve() {\n  for (int s=(1<<V)-1;s>=0;--s) {\n    for (int t=0;t<V;++t) {\n      dp[s][t] = INF;\n    }\n  }\n  dp[(1<<V)-1][0] = 0;\n  for (int s=(1<<V)-2;s>=0;--s) {\n    for (int t=0;t<V;++t) {\n      for (int u=0;u<V;++u) {\n        if (!(s>>u&1)) {\n          dp[s][t] = min(dp[s][t],dp[s|(1<<u)][u]+G[t][u]);\n        }\n      }\n    }\n  }\n  return (dp[0][0] != INF)?dp[0][0]:-1;\n}\n\nint main() {\n  for (int i=0;i<15;++i) {\n    for (int j=0;j<15;++j) {\n      G[i][j] = INF;\n    }\n  }\n  cin>>V>>E;\n  for (int i=0;i<E;++i) {\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t] = d;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\ntypedef long long ll;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nvector<edge> to[20];\nint dp[40000][20];\nconst int INF = 1001001001;\n\nint main(){\n\tint v,e;\n\tcin >> v >> e;\n\t\n\trep(i,e){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tto[s].push_back(edge{t,d});\n\t}\n\t\n\tint ans = INF;\n\n\trep(i,v){\n\t\trep(i,1<<v){\n\t\t\trep(j,v){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[1<<i][i] = 0;\n\t\trep(s, 1<<v){\n\t\t\trep(j, v){\n\t\t\t\tif(!(s & (1<<j))) continue;\n\t\t\t\tfor(auto nextv: to[j]){\n\t\t\t\t\tif(s == (1<<v)-1 && nextv.to == i){\n\t\t\t\t\t\tans = min(ans, dp[s][j] + nextv.cost);\n\t\t\t\t\t}\n\t\t\t\t\tif(s & (1<<nextv.to)) continue;\n\t\t\t\t\tdp[s | (1<<nextv.to)][nextv.to] = min(dp[s | (1<<nextv.to)][nextv.to], dp[s][j] + nextv.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>; using pcc = pair<char, char>; using pbb = pair<bool, bool>; using pil = pair<int, ll>; using pli = pair<ll, int>;\nusing ti3 = tuple<int, int, int>; using tl3 = tuple<ll, ll, ll>; using td3 = tuple<double, double, double>; using ts3 = tuple<string, string, string>; using tc3 = tuple<char, char, char>; using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>; using tl4 = tuple<ll, ll, ll, ll>; using td4 = tuple<double, double, double, double>; using ts4 = tuple<string, string, string, string>; using tc4 = tuple<char, char, char, char>; using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>; using vl = vector<ll>; using vd = vector<double>; using vs = vector<string>; using vc = vector<char>; using vb = vector<bool>;\nusing vvi = vector<vi>; using vvl = vector<vl>; using vvd = vector<vd>; using vvs = vector<vs>; using vvc = vector<vc>; using vvb = vector<vb>;\nusing vvvi = vector<vvi>; using vvvl = vector<vvl>; using vvvd = vector<vvd>; using vvvs = vector<vvs>; using vvvc = vector<vvc>; using vvvb = vector<vvb>;\nusing vpii = vector<pii>; using vpll = vector<pll>; using vpdd = vector<pdd>; using vpss = vector<pss>; using vpcc = vector<pcc>; using vpbb = vector<pbb>; using vpil = vector<pil>; using vpli = vector<pli>;\nusing vti3 = vector<ti3>; using vtl3 = vector<tl3>; using vtd3 = vector<td3>; using vts3 = vector<ts3>; using vtc3 = vector<tc3>; using vtb3 = vector<tb3>;\nusing vti4 = vector<ti4>; using vtl4 = vector<tl4>; using vtd4 = vector<td4>; using vts4 = vector<ts4>; using vtc4 = vector<tc4>; using vtb4 = vector<tb4>;\nusing mii = map<int, int>; using mll = map<ll, ll>; using msi = map<string, int>; using mci = map<char, int>; using mil = map<int, ll>; using mli = map<ll, int>;\nusing si = set<int>; using sl = set<ll>; using sd = set<double>; using ss = set<string>; using sc = set<char>; using sb = set<bool>;\nusing spii = set<pii>; using spll = set<pll>; using spdd = set<pdd>; using spss = set<pss>; using spcc = set<pcc>; using spbb = set<pbb>; using spil = set<pil>; using spli = set<pli>;\nusing sti3 = set<ti3>; using stl3 = set<tl3>; using std3 = set<td3>; using sts3 = set<ts3>; using stc3 = set<tc3>; using stb3 = set<tb3>;\n#define rep0(TMS) for (int CNT = 0; CNT < (int)(TMS); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(FLG) cout << (FLG ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(FLG) cout << (FLG ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(FLG) cout << (FLG ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst int INF = 1e9 + 7;\n// db\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvvi g(V, vi()), dis(V, vi(V, INF));\n\trep0(E) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].push_back(t);\n\t\tint d; cin >> d;\n\t\tdis[s][t] = d;\n\t}\n\tvvi dp(1 << V, vi(V, INF));\n\tdp[1 << 0][0] = 0;\n\trep(bit, 1 << V) {\n\t\trep(u, V) {\n\t\t\tif (!(bit & (1 << u))) continue;\n\t\t\trep(v, V) {\n\t\t\t\tif (bit & (1 << v) or dis[u][v] == INF) continue;\n\t\t\t\tchmin(dp[bit | (1 << v)][v], dp[bit][u] + dis[u][v]);\n\t\t\t}\n\t\t}\n\t}\n\t// dbvv(g); dbvv(dis);\tdbvv(dp);\n\tint ans = INF;\n\trep2(v, 1, V) if (dis[v][0] != INF) chmin(ans, dp[(1 << V) - 1][v] + dis[v][0]);\n\tif (ans != INF) print(ans);\n\telse (print(-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, N) for (int i = 0; i < (int)N; i++)\n\n#define V_MAX 15\nint d[V_MAX][V_MAX];\nint INF = 10000;\nint dp[1<<V_MAX][V_MAX];\nint V, E;\n\nint solve(int T, int u) {\n  if(dp[T][u] != -1) return dp[T][u];\n  int res = INF;\n  for(int v = 1; v < V; v++) {\n    if((T & (1 << v)) && u != v) res = min(res, solve(T & ~(1 << u), v) + d[v][u]);\n  }\n  dp[T][u] = res;\n  return res;\n}\n\nint main () {\n  REP(i, 1<<V_MAX)REP(j,V_MAX) dp[i][j] = -1;\n  REP(i,V_MAX)REP(j,V_MAX) d[i][j] = INF;\n  int s, t, w, res;\n  cin >> V >> E;\n  REP(i, E) {\n    cin >> s >> t >> w;\n    d[s][t] = w;\n  }\n\n  dp[1][0] = 0;\n  for(int i = 1; i < V; i++) dp[1 | (1<<i)][i] = d[0][i];\n\n  res = INF;\n  for(int v = 1; v < V; v++) {\n    res = min(res, solve((1<<V) - 1, v) + d[v][0]);\n  }\n  if(res == INF) res = -1;\n\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\nusing namespace std;\n\nint n;\nint dp[1<<16][16];\n\nint main(){\nint e,s,t,wa;\ncin>>n>>e;\nint w[20][20];\nfor(int i=0;i<n+1;i++){\nfor(int j=0;j<n+1;j++){\nw[i][j]=inf;\n}\n}\nfor(int i=0;i<e;i++){\ncin>>s>>t>>wa;\nw[s][t]=wa;\n}\nfor(int i=0;i<(1>>n);i++){\nfor(int j=0;j<n+1;j++) dp[i][j]=inf;\n}\n\n\n\nint mini=inf;\ndp[0][0]=0;\nfor(int k=2;k< (1<<n);k=k+2){ //a\nfor(int u=1;u<n;u++){ //b\nmini=inf;\n\nif(1 & (k>>u)){\t\t\t //c\n//cout<<k<<endl;\n\nif(k-(1<<u)==0) {\t //d\ndp[k][u]=w[0][u];\n//cout<<\" w0u\"<<w[0][u]<<endl;\n//cout<<\"dp[\"<<k<<\" \"<<u<<\"]\" <<dp[k][u]<<endl;\n}\t\t\t //d\nelse if(k-(1<<u)!=0){\t\t//e\nfor(int v=1;v<n;v++){\t\t//f\n//cout<<k<<\" \"<<v<<\" \"<<u<<\" \"<<w[v][u]<<endl;\nif((1 & (k>>v)) && u != v && w[v][u]!=inf){\t//g\n//printf(\"k= %d v= %d u= %d\\n\",k,v,u);\nmini=min(mini,dp[k-(1<<u)][v]+w[v][u]);\n\t}\t//g\n\t}\t//f\ndp[k][u]=mini;\n//cout<<\"dp[\"<<k<<\" \"<<u<<\"]\" <<dp[k][u]<<endl;\n\t}\t//e\n}\t//c\n\n} \t//b\n}\t//a\nmini=inf;\nfor(int i=1;i<n;i++){\nmini=min(mini,dp[(1<<n)-2][i]+w[i][0]);\n\n}\n\nif(mini<inf) cout<<mini<<endl;\nelse cout<<\"-1\"<<endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\nconst int MAX_N = 20;\nvector<pair<int, int> > G[MAX_N]; /* G[u][v] := u->v's weight */\nint dp[(1 << MAX_N)][MAX_N];\n// int prev[MAX_N];\nvoid Traveling_Salesman(int n){ /* n := Number of vertices */\n\trep(i, (1 << n))rep(j, n)dp[i][j] = INF; /* Initialization */\n\tdp[0][0] = 0;\n\tfor (int mask = 0; mask < (1 << n); ++mask){\n\t\tfor (int u = 0; u < n; ++u){ /* Current vertex */\n\t\t\tfor(auto p : G[u]){ /* Next vertex */\n\t\t\t\tint v = p.first, w = p.second;\n\t\t\t\tif((mask & (1 << v)) == 0){\n\t\t\t\t\tif(dp[mask | (1 << v)][v] > dp[mask][u] + w){\n\t\t\t\t\t\tdp[mask | (1 << v)][v] = dp[mask][u] + w;\n\t\t\t\t\t\t// prev[v] = (int)u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\trep(i, e){\n\t\tint s, t, d; scanf(\"%d %d %d\", &s, &t, &d);\n\t\tG[s].pb(mp(t, d));\n\t}\n\tTraveling_Salesman(v);\n\tint ret = dp[(1 << v) - 1][0];\n\tif(ret == INF){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nconst int INF = 1e9;\n\n\nint main()\n{\n    int n, m; cin >> n >> m;\n    vector<vector<int>> dist(n, vector<int>(n, INF));\n    for(int i = 0; i < m; i++) {\n        int a, b, c; cin >> a >> b >> c;\n        dist[a][b] = c;\n    }\n\n    vector<vector<vector<int>>> dp(1<<n, vector<vector<int>>(n, vector<int>(n, INF))); //dp[i][j][k] := 集合iを見ていて、今jにいて、kスタート\n    for(int i = 0; i < n; i++)dp[(1<<i)][i][i] = 0;\n\n\n    {// -- bitDP --\n        for(int bit = 1; bit < (1<<n); bit++) {\n            for(int i = 0; i < n; i++) {\n                for(int j = 0; j < n; j++) {\n                    for(int k = 0; k < n; k++) {\n\n                        // i -> j / start = k;\n                        if(bit & (1<<j) || (bit & (1<<i)) == 0 || i == j)continue;\n                        dp[bit | (1<<j)][j][k] = min(dp[bit | (1<<j)][j][k], dp[bit][i][k] + dist[i][j]);\n\n                    }\n                }\n            }\n        }\n    }\n\n\n    int ans = INF;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == j)continue;\n            int bit = (1<<n) - 1;\n            ans = min(ans, dp[bit][j][i] + dist[j][i]);\n        }\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<vector<ll>> dp((1 << 15),vector<ll>(15,-1));\nvector<vector<pair<ll, ll>>> graph(15);\nll n;\n\nll solve(ll bit, ll v)\n{\n    if(dp.at(bit).at(v) != -1){\n        return dp.at(bit).at(v);\n    }\n    if(bit == (1 << n) -1 && v == 0){\n        return dp.at(bit).at(v) = 0;\n    }\n    ll ans = 1e9+7;\n    ll i,j;\n    for(i = 0;i < graph.at(v).size();++i){\n        ll s = graph.at(v).at(i).first;\n        if(bit & (1 << s)) continue;\n        ll d = graph.at(v).at(i).second;\n        ans = min(ans, solve(bit | 1 << s, s) + d);\n    }\n    return dp.at(bit).at(v) = ans;\n}\n\nint main()\n{\n    ll i,j;\n    ll e;\n    cin >> n >> e;\n    for(i = 0;i < e;++i){\n        ll s,t,d;\n        cin >> s >> t >> d;\n        graph.at(s).emplace_back(t, d);\n    }\n    ll ans = min((ll)1e9+7, solve(0LL, 0LL));\n    if(ans == 1e9+7){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint edge[15][15], v, e, dp[15][1 << 15];\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < v;i++){\n\t\tdp[i][0] = 0;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << v);i++){\n\t\tfor(int j = 0;j < v;j++){ // now place\n\t\t\tif(dp[j][i] != -1){\n\t\t\t\tfor(int k = 0;k < v;k++){ // next place\n\t\t\t\t\tif((i >> k & 1) == 0 && edge[j][k] != -1 && (dp[k][i | (1 << k)] == -1 || dp[k][i | (1 << k)] < dp[j][i] + edge[j][k])){\n\t\t\t\t\t\tdp[k][i | (1 << k)] = dp[j][i] + edge[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = -1;\n\tfor(int i = 0;i < v;i++){\n\t\tif(dp[i][(1 << v) - 1] != -1 && (ans == -1 || dp[i][(1 << v) - 1] < ans){\n\t\t\tans = dp[i][(1 << v) - 1];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Traveling Salesman Problem - ?????????????????????????????? ?????¢???*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n\n#define V_MAX 15\nconst int INF=1<<30;\n\nint DP[1<<V_MAX][V_MAX]; //[S][now] : now ?????? U\\S ????¨???????0????????????????????????\nint G[V_MAX][V_MAX];\nint V,E;\nint rec(int S,int now){\n  if( DP[S][now] >= 0 ) return DP[S][now];\n  if( S == (1<<V)-1 ) return DP[S][now]=0;\n  int ret=INF;\n  rep(v,V){\n    if( S & (1<<v) || G[now][v] == INF)continue;\n    ret = min( ret , rec(S | 1<<v,v)+G[now][v] );\n  }\n  return DP[S][now]=ret;\n}\n\nint main()\n{\n  cin>>V>>E;\n  rep(i,V)rep(j,V)G[i][j]=INF;\n  rep(i,1<<V)rep(j,V)DP[i][j]=-1;\n  rep(i,E){\n    int s,t,d;\n    cin>>s>>t>>d;\n    G[s][t]=d;\n  }\n  int ans=rec(0,0);\n  cout<< (ans>=INF ? -1 : ans) <<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n#include <math.h>\n//#include <unistd.h>\n//#include <stdio.h>\n#define rep(i,x) for(ll i = 0;i<x;i++)\n#define all(a) (a).begin(),(a).end()\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nusing dou = double;\nconst ll INF = 1LL << 60;\nconst ll mod = 1000000007;\ntypedef pair<ll,ll> P;\nusing graph = vector<vector<ll>>;\ntemplate<class T> inline bool chmax(T& a, T b){if(a < b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmin(T& a, T b){if(a > b){a = b; return true;}return false;}\nll gcd(ll a,ll b){\n    if(a < b)swap(a,b);\n    if(a % b == 0)return b;\n    else return gcd(b,a%b);\n}\n//素数判定O(sqrt(N))\nbool isp(ll n){\n    bool res = true;\n    if(n == 1)return false;\n    else{\n        for(ll i = 2;i * i <= n;i++){\n            if(n % i == 0){\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}\n\nll fac[510000], finv[510000], inv[510000];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < 510000; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n//nのm乗をMODで割ったあまりO(logN)\nll modpow(ll n,ll m,ll MOD){\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n) % MOD;\n        m >>= 1;\n        n *= n;\n        n %= MOD;\n    }\n    return res;\n}\n\n//printf(\"%.10f\\n\", N);\n/*  vector<ll> vec = {1,2,5,6,8,9,10};\n    cout << binary_search(all(vec),5) << endl; -> true*/\n/*\n    vector<ll> vec = {1,2,5,6,8,9,10};\n    auto n = upper_bound(all(vec),4);\n    cout << *n << endl; -> 5*/\n/*\n    cout << fixed << setprecision(15);\n*/\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    vector<vector<ll>> cost(16,vector<ll>(16,INF));\n    vector<vector<ll>> memo(1 << 16,vector<ll>(16,INF));\n    ll a,b,c;\n    rep(i,M){\n        cin >> a >> b >> c;\n        cost[a][b] = c;\n    }\n    memo[(1 << N) - 1][0] = 0;\n    for(ll i = (1 << N) - 2;i >= 0;i--){\n        rep(v,N){\n            rep(u,N){\n                if(!(i >> u&1)){\n                    memo[i][v] = min(memo[i][v],memo[i | 1 << u][u] + cost[u][v]);\n                }\n            }\n        }\n    }\n    if(memo[0][0] != INF)cout << memo[0][0] << endl;\n    else cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\n// require gcc >= 7.1.0\ntemplate < class ... Keys >\nclass fmt_t {\n    using storage_t = std::tuple< Keys ... >;\n    storage_t storage;\n    static constexpr std::size_t N = sizeof ... (Keys);\n\n    // is_exact_match_impl\n    template < std::size_t I, class Value >\n      auto is_exact_match_impl(long, Value) const\n        { return false; }\n\n    template < std::size_t I, class Value,\n      std::enable_if_t<\n        std::is_same< std::decay_t< Value > , char >::value\n        == std::is_same< std::tuple_element_t< I, storage_t >, char >::value,\n      std::nullptr_t > = nullptr,\n      class = decltype(std::declval< Value >() == std::get< I >(std::declval< storage_t >())) >\n      auto is_exact_match_impl(int, Value x) const\n        { return x == std::get< I >(storage); }\n\n    template < class Value, std::size_t ... Is >\n      auto find_exact_match_impl(Value x, std::integer_sequence< std::size_t, Is ... >) const {\n        auto ret = false;\n        (void)std::initializer_list< std::nullptr_t >\n          { (ret |= is_exact_match_impl< Is >(int{}, x), nullptr) ...  };\n        return ret;\n      }\n\n    template < class Value >\n      auto exists_exact_match(Value x) const\n      {  return find_exact_match_impl(x, std::make_index_sequence< N >()); }\n\n    // tuple_format_impl\n    template < class Tuple,  std::size_t ... Is >\n    std::string tuple_format_impl(const Tuple& tuple, std::integer_sequence< std::size_t, Is ... >) const {\n      std::string ret = \"(\";\n      (void)std::initializer_list< std::nullptr_t >\n        { (ret = ret + (Is == 0 ? \"\" : \",\") + format(std::get< Is >(tuple)), nullptr) ... };\n      return ret + \")\";\n    }\n\n    // usual_format\n    template < class Value >\n    std::string usual_format(long, Value x) const\n      { return std::to_string(x); }\n\n    template < class Value, std::enable_if_t< std::is_same< std::decay_t< Value >, char >::value, std::nullptr_t > = nullptr >\n    std::string usual_format(int, Value c) const\n      { return std::string{'\\''} + std::string{c} + std::string{'\\''}; }\n\n    std::string usual_format(int, char const* s) const\n      { return \"\\\"\" + std::string(s) + \"\\\"\"; }\n\n    std::string usual_format(int, std::string const s) const\n      { return \"\\\"\" + s + \"\\\"\"; }\n\n    template < class Container, class = typename Container::value_type >\n    std::string usual_format(int, Container const & v) const {\n      return \"{\" + std::accumulate(v.begin(), v .end(), std::string{},\n        [this](auto const& s, auto const x) { return s + (s.empty() ? \"\" : \",\") + this->format(x); })\n        + \"}\";\n    }\n\n    template < class Tuple, std::size_t N = std::tuple_size< Tuple >::value >\n    std::string usual_format(int, Tuple const& tuple) const\n      { return tuple_format_impl(tuple, std::make_index_sequence< N >()); }\n\n    // format\n    template < class Value > std::string format(Value&& x) const\n      { return exists_exact_match(x) ? std::string{'_'} : usual_format(int{}, x); }\n\n  public:\n    fmt_t()=default;\n    template < Keys ... > fmt_t(Keys&& ... keys ) : storage(keys ... ){}\n\n    template < class Value > std::string operator()(Value&& x) const\n      { return format(x); }\n};\ntemplate < class ... Keys > auto fmt(Keys&& ... keys)\n  { return fmt_t< Keys ... >(std::forward< Keys >(keys) ... ); }\n\ntemplate < class Value >\nbool bat(Value x, std::size_t pos) { return (x >> pos) & Value{1}; }\n\n/*\n0からスタートします。訪問済みの頂点集合と、そのうち現在いる頂点を管理します。\n配る DP で、その頂点から出ている辺の数だけ更新していきます。\ndp{bs | 1<<j][j] <- dp[bs][i] + adj[i][j], where i->j\nすると、dp[N-1][i] + adj[i][0] for i = 1,2,... の min が答えです。\n*/\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  int inf = std::numeric_limits<int>::max();\n  auto adj = make_vector<2,int>(n,n,inf);\n  int q; std::cin >> q;\n  loop(q) {\n    int u, v, d;\n    std::cin >> u >> v >> d;\n    at(adj,u,v) = d;\n  }\n  debug(fmt(inf)(adj));\n\n  int s = 0;\n  int N = 1 << n;\n  auto dp = make_vector<2,int>(N,n,inf);\n  at(dp,1<<s,s) = 0;\n  rep(bs,0,N) {\n    rep(i,0,n) {\n      if (!bat(bs,i)) continue;\n      int crr = at(dp,bs,i);\n      if (crr == inf) continue;\n      rep(j,0,n) {\n        if (bat(bs,j)) continue;\n        int d = at(adj,i,j);\n        if (d == inf) continue;\n        cmn(at(dp, bs | 1<<j, j), crr + d);\n      }\n    }\n  }\n  rep(bs,0,N) {\n    auto x = std::bitset<16>(bs);\n    auto y = fmt(inf)(dp.at(bs));\n    debug(x,y);\n  }\n\n  int ans = inf;\n  rep(i,1,n) {\n    int x = at(dp,N-1,i);\n    int y = at(adj,i,0);\n    if (x==inf || y==inf) continue;\n    cmn(ans,x+y);\n  }\n  if (ans == inf) ans = -1;\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> Pi;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define fi first\n#define se second\n#define endl \"\\n\"\n\ntemplate<typename T> inline bool chmax(T &a, T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T> ostream& operator<<(ostream& s,const complex<T>& d) {return s<<\"(\"<<d.real()<<\", \"<<d.imag()<< \")\";}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const pair<T1,T2>& d) {return s<<\"(\"<<d.first<<\", \"<<d.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d){int len=d.size();rep(i,len){s<<d[i];if(i<len-1) s<<\" \";}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const vector<vector<T>>& d){int len=d.size();rep(i,len){s<<d[i]<<endl;}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const set<T>& v){s<<\"{ \";for(auto itr=v.begin();itr!=v.end();++itr) {if (itr!=v.begin()) {s<< \", \";}s<<(*itr);}s<<\" }\";return s;}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const map<T1,T2>& m){s<<\"{\"<<endl;for(auto itr=m.begin();itr!=m.end();++itr){s<<\" \"<<(*itr).first<<\" : \"<<(*itr).second<<endl;}s<<\"}\"<<endl;return s;}\n\nconst ll mod=1e9+7;\nconst ll inf=1e17;\nconst int INF=1e9;\nconst double PI=acos(-1);\nconst double EPS=1e-10;\n\nint main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint n,m;\n\tcin>>n>>m;\n\tvector<vector<int>> dist(n,vector<int>(n,INF));\n\trep(i,m){\n\t\tint s,t,d;\n\t\tcin>>s>>t>>d;\n\t\tdist[s][t]=d;\n\t}\n\trep(i,n) dist[i][i]=0;\n\tint ans=INF;\n\trep(st,n){\n\t\tvector<vector<int>> dp(1<<n,vector<int>(n,INF));\n\t\tdp[1<<st][st]=0;\n\t\trep(S,1<<n){\n\t\t\trep(i,n){\n\t\t\t\tif(dp[S][i]==INF) continue;\n\t\t\t\trep(j,n){\n\t\t\t\t\tif(S & 1<<j) continue;\n\t\t\t\t\tchmin(dp[S|1<<j][j],dp[S][i]+dist[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(en,n){\n\t\t\tif(dp[(1<<n)-1][en]!=INF){\n\t\t\t\tchmin(ans,dp[(1<<n)-1][en]+dist[en][st]);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans!=INF) cout<<ans<<endl;\n\telse cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever while(true)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing pii   = std::pair<int, int>;\nusing vi    = std::vector<int>;\nusing vd    = std::vector<double>;\nusing vc    = std::vector<char>;\nusing vb    = std::vector<bool>;\nusing vs    = std::vector<std::string>;\nusing vpii  = std::vector<pii>;\nusing vvi   = std::vector<vi>;\nusing vvb   = std::vector<vb>;\nusing vvpii = std::vector<vpii>;\ntemplate<typename A> using fn = std::function<A>;\nconstexpr int INF   = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD   = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0)\n    : src(s), dst(d), weight(w) {\n  }\n};\n\nusing Edges  = std::vector<Edge>;\nusing Array  = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  // clang-format off\n  Graph(const int &size = 0) : g(size) { }\n\n  void addArc(const int &src, const int &dst, const Weight &w = 1) {\n    g[src].emplace_back(src, dst, w);\n  }\n\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n\n  Graph toRootedTree(int r);\n  std::vector<Weight> dijkstra(const int &src, const int &inf);\n  Matrix warshallFloyd(const int &inf);\n  std::pair<Weight, Edges> prim(const int &r);\n  template<typename UnionFind> std::pair<Weight, Edges> kruskal();\n  Weight solveTSP(const int &inf);\n  // clang-format on\n};\n\nWeight Graph::solveTSP(const int &inf = std::numeric_limits<Weight>::max() / 8) {\n  int n = g.size();\n  Matrix dp(1 << n, Array(n, inf));\n  dp[0][0] = 0;\n  rep(s, 1 << n) {\n    for (auto &es : g) {\n      for (auto &e : es) {\n        if (~s >> e.dst & 1) cmin(dp[s | 1 << e.dst][e.dst], dp[s][e.src] + e.weight);\n      }\n    }\n  }\n  return dp.back().front();\n}\n\nmain {\n  int v, e;\n  cin >> v >> e;\n  Graph g(v);\n  while (e--) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g.addArc(s, t, d);\n  }\n  Weight x = g.solveTSP(INF);\n  cout << (x == INF ? -1 : x) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int s,t,d;\n    cin>>s>>t>>d;\n    G[s].emplace_back(t,d);\n  }\n  const Int INF = 1e15;\n  Int ans=INF;\n  \n  for(Int p=0;p<n;p++){\n    auto dp=make_v<Int>(n,1<<n);\n    fill_v(dp,INF);\n    dp[p][1<<p]=0;\n    for(Int b=0;b<(1<<n);b++){\n      for(Int v=0;v<n;v++){\n\tif((~b>>v)&1) continue;\n\tfor(auto e:G[v]){\n\t  Int u,d;\n\t  tie(u,d)=e;\n\t  if(u==p&&b==(1<<n)-1) chmin(ans,dp[v][b]+d);\n\t  if((b>>u)&1) continue;   \n\t  chmin(dp[u][b|(1<<u)],dp[v][b]+d);\n\t}\n      }\n    }\n  }\n  \n  if(ans==INF) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define sz(x) int(x.size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1 << 30;\nconst double PI = acos(-1.0);\n#define MOD 1000000007LL\n#define endl \"\\n\"\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  srand((unsigned)time(NULL));\n  ll N, M;\n  cin >> N >> M;\n  vvll dist(N, vll(N, INF));\n  if(M==0){cout << -1 << endl; return 0;}\n  for(int i = 0; i < M; i++){\n    ll s, t, d;\n    cin >> s >> t >> d;\n    dist.at(s).at(t) = d;\n  }\n  vvll dp((1<<15), vll(N, INF));\n  function<ll(ll, ll)> dfs = [&](ll bit, ll v){\n    if(bit == (1<<v)) return dp.at(bit).at(v) = dist.at(0).at(v);\n    if(dp.at(bit).at(v) != INF) return dp.at(bit).at(v);\n    ll prebit = bit & ~(1<<v);\n    ll res = INF;\n    for(int i = 0; i < N; i++){\n      if(prebit & (1<<i)){\n        if(dist.at(i).at(v) == INF) continue;\n        chmin(res, dfs(prebit, i) + dist.at(i).at(v));\n      }\n    }\n    return dp.at(bit).at(v) = res;\n  };\n  ll ans =  dfs((1<<N)-1, 0);\n  if(ans >= INF) ans = -1;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n#include <cstring>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <stack>\n\n/* ---------- Namespace ---------- */\nusing namespace std;\n\n/* ---------- Type ---------- */\nusing ll = long long;\n#define int ll\n#define P pair<ll, ll>\n\n/* ---------- Constants  */\nconst double PI = 3.141592653589793238462643383279;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1LL << 55;\n\nconst int MAX_V = 15;\nint V;\nint dp[1 << MAX_V][MAX_V];\nvector<P> table[MAX_V];\n\nint rec(int mask, int k, int start) {\n    if (dp[mask][k] >= 0) return dp[mask][k];\n    if (mask == (1 << V) - 1 && k == start) return dp[mask][k] = 0;\n\n    int ret = INF;\n    for (P next : table[k]) {\n        if (mask & (1 << next.first)) continue;\n        ret = min(ret, next.second + rec(mask | (1 << next.first), next.first, start));\n    }\n    return dp[mask][k] = ret;\n}\n\nsigned main() {\n    int E;\n    cin >> V >> E;\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        table[s].push_back(P(t, d));\n    }\n\n    int ret = INF;\n    for (int start = 0; start < V; start++) {\n        memset(dp, -1, sizeof(dp));\n        ret = min(ret, rec(0, start, start));\n    }\n\n    if (ret == INF) ret = -1;\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define lint long long\n#define P pair<int, int>\n#define LLP pair<long long, long long>\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define repr(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n\nconst int IINF = 1e9 + 100;\nconst long long LLINF = 2e18 + 129;\nconst long long MOD = 1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint v, e;\nint cost[15][15];\nint dp[15][1 << 15];\n\ntemplate<typename T>\nbool chmin(T &a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint solve(int now, int S){\n    if(dp[now][S] >= 0){\n        return dp[now][S];\n    }\n    if(S == (1 << v) - 1){\n        if(now == 0){\n            return dp[now][S] = 0;\n        }else{\n            return dp[now][S] = IINF;\n        }\n    }\n\n    int res = IINF;\n    rep(i, v){\n        if(S >> i & 1){\n            continue;\n        }\n        chmin(res, solve(i, S | (1 << i)) + cost[now][i]);\n    }\n\n    return dp[now][S] = res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> v >> e;\n\n    rep(i, v){\n        rep(j, v){\n            cost[i][j] = IINF;\n        }\n        cost[i][i] = 0;\n    }\n\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        chmin(cost[s][t], d);\n    }\n\n    rep(i, v){\n        rep(j, 1 << v){\n            dp[i][j] = -1;\n        }\n    }\n\n    int ans = solve(0, 0);\n\n    if(ans < IINF){\n        cout << ans << endl;\n    }else{\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<limits>\n#include<cstdio>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_V = 15, INF = std::numeric_limits<int>::max()>>2;\n\nint V, E;\nstd::vector<std::vector<int> > d( MAX_V, std::vector<int>( MAX_V, INF ) ),\n                               dp( 1<<MAX_V+1, std::vector<int>( MAX_V, -1 ) );\n\nint s;\n\nint rec( int S, int v )\n{\n    if( S == (1<<V)-1 && v == s )\n        return dp[S][v] = 0;\n\n    if( ~dp[S][v] )\n        return dp[S][v];\n\n    int ret = INF;\n\n    rep( u, V ) if( !(S>>u&1) )\n        ret = std::min( ret, rec( S|1<<u, u )+d[v][u] );\n\n    return dp[S][v] = ret;\n}\n\nint main()\n{\n    scanf( \"%d%d\", &V, &E );\n    rep( i, E )\n    {\n        int s, t;\n        scanf( \"%d%d\", &s, &t );\n        scanf( \"%d\", &d[s][t] );\n    }\n\n    int ans = INF;\n    rep( v, V )\n    {\n        s = v;\n        ans = std::min( ans, rec( 0, v ) );\n    }\n\n    printf( \"%d\\n\", ans==INF?-1:ans );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nll n,e;\nll inf=1e15;\nvector<vector<ll>> E(15,vector<ll>(15,inf));\nvector<vector<ll>> dp(1<<15+1,vector<ll>(15,-1));\n\nll rec(ll s,ll bit, ll v) {\n  if(dp[bit][v]!=-1) return dp[bit][v];\n  if(bit==(1<<v)) return dp[bit][v]=E[s][v];\n  ll res=inf;\n  ll prev_bit=bit-(1<<v);\n  for(ll i=0;i<n;i++) {\n    if(prev_bit&(1<<i)) {\n      res=min(res,rec(s,prev_bit,i)+E[i][v]);\n    }\n  }\n  return dp[bit][v]=res;\n}\n\nint main() {\n  cin >> n >> e;\n  for(ll i=0;i<e;i++) {\n    ll f,t,w;\n    cin >> f >> t >> w;\n    E[f][t]=w;\n  }\n  ll ans=inf;\n  for(ll i=0;i<n;i++) {\n    ans=min(ans,rec(i,(1<<n)-1,i));\n    for(ll j=0;j<n;j++) {\n      for(ll k=0;k<(1<<n);k++) {\n        dp[k][j]=-1;\n      }\n    }\n  }\n  if(ans==inf) {\n    ans=-1;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\nint memo[100000];\nvector<vector<pair<int,int> > > graph;\n\nint dp(int n,int c,int bit){\n\n  if(bit == (pow(2,v)-1)){\n    for(int i = 0;i < graph[n].size();i++){\n      if(graph[n][i].first == 0){\n        return memo[bit] = graph[n][i].second;\n      }\n    }\n    return 1000000;\n  }\n\n  if(memo[bit] != 0){\n    return memo[bit];\n  }\n\n  if(graph[n].size() == 0){\n    return 1000000;\n  }\n\n\n  int a = 20000;\n\n  for(int i = 0;i < graph[n].size();i++){\n    if((bit & (1 << graph[n][i].first)) == 0){\n      a = min(a,dp(graph[n][i].first,c+1,(bit | (1 << graph[n][i].first)))+graph[n][i].second);\n    }\n  }\n\n  return memo[bit] = a;\n}\n\n\n\nint main(){\n  cin >> v >> e;\n  graph.resize(v);\n  for(int i = 0;i < e;i++){\n    int s,t,d;\n    cin >> s >> t >> d;\n    pair<int,int> p = make_pair(t,d);\n    graph[s].push_back(p);\n  }\n\n  int ans = dp(0,0,1);\n\n  if(ans >= 20000){\n    cout << -1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 15\n#define INF 1e9\n\nint V,E;\nint d[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\n\nint rec(int S,int v){\n  if(dp[S][v] >= 0){\n    return dp[S][v];\n  }\n  if(S == (1<<V)-1 && v == 0){\n    return dp[S][v] = 0;\n  }\n  int res = INF;\n  for(int u = 0 ; u < V ; u++){\n    if(!(S >> u & 1)){\n      res = min(res,rec(S|1<<u,u) + d[v][u]);\n    }\n  }\n  return dp[S][v] = res;\n}\n\nvoid init(){\n  memset(dp,-1,sizeof(dp));\n  fill(d[0],d[0]+MAX_V*MAX_V,INF);\n}\n\nint main(){\n  init();\n  cin >> V >> E;\n  for(int i = 0 ; i < E ; i++){\n    int a,b,c;\n    cin >> a >> b >> c;\n    d[a][b] = c;\n  }\n  int res = rec(0,0);\n  cout << (res == INF ? -1 : res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint dp[1 << 15][15];\nint n;\nint m[15][15];\n\nint rec(int s,int v){\n  if(dp[s][v]>=0){\n    return dp[s][v];\n  }\n\n  if(s ==((1 << n)-1) && v==0){\n    //printf(\"v=0\\n\");\n\n    return dp[s][v]=0;\n  }\n\n  int res = 1000*15+1;\n\n  for(int u=0;u<n;u++){\n    if((!(s >> u & 1)) && m[v][u]>=0){\n      //printf(\"m:%d\",m[v][u]);\n      res = min(res,rec(s | (1 << u),u)+m[v][u]);\n    } \n  }\n  //printf(\"res=%d\\n\",res);\n  return dp[s][v]=res;\n}\n\nint main(){\n  int v,e;\n  cin >> v >> e;\n  n=v;\n  \n    memset(m,-1,sizeof(m));\n\n\n  int s,t,d;\n  for(int i=0;i<e;i++){\n    cin >> s >> t >> d;\n    m[s][t]=d;\n  }\n  \n  memset(dp,-1,sizeof(dp));\n  int ans=rec(0,0);\n  if(ans==15001){\n    printf(\"%d\\n\",-1);\n  }\n  else{\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    using ii = pair<int, i64>;\n    vector<vector<ii>> adj(v);\n    for (int i = 0; i < e; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        adj[s].push_back(ii(t, d));\n    }\n\n    vvi dp(1 << v, vi(v, 1e18));\n    // dp[i][j]: すでにiを回って今jにいる\n    dp[0][0] = 0;\n    for (int i = 0; i < 1 << v; i++) {\n        for (int j = 0; j < v; j++) {\n            for (auto &p: adj[j]) {\n                if ((i >> p.first) & 1) continue;\n                dp[i | (1 << p.first)][p.first] = min(dp[i | (1 << p.first)][p.first], dp[i][j] + p.second);\n            }   \n        }\n    }\n    cout << (dp[(1 << v) - 1][0] == 1e18 ? -1 : dp[(1 << v) - 1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint v, n, dis[15][15];\nint dp[(1 << 15)][15];\nconst int INF = 100000000;\n\nint main() {\n\tcin >> v >> n;\n\tfor (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dis[i][j] = INF;\n\tfor (int i = 0; i < (1 << v); i++)for (int j = 0; j < v; j++)dp[i][j] = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdis[a][b] = c;\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << v) - 1; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (i && !(i & (1 << j)))continue;\n\t\t\tfor (int k = 0; k < v; k++) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif (!(i & (1 << k))) {\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dis[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << v) - 1][0] == INF)cout << -1 << endl;\n\telse cout << dp[(1 << v) - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nconst int MAX_V = 15;\nconst int INF = 1e9;\n \nint V,E;\nint d[MAX_V][MAX_V];\nint dp[MAX_V][1<<MAX_V];\n\nint dfs(int v, int mask){\n    if(mask==(1<<V)-1) return d[v][0];\n    if(dp[v][mask]!=-1) return dp[v][mask];\n    int res = INF;\n    rep(u,V){\n        if(v==u || d[v][u]==INF || (mask&(1<<u))) continue;\n        res = min(res, dfs(u, mask|(1<<u))+d[v][u]);\n    }\n    return dp[v][mask] = res;\n}\n\nint main() {\n    cin>>V>>E;\n    rep(i,V)rep(j,V) d[i][j]=INF;\n    rep(i,V) d[i][i]=0;\n    rep(i,E){\n        int s,t;\n        cin>>s>>t;\n        cin>>d[s][t];\n    }\n    memset(dp, -1, sizeof(dp));\n    int res=dfs(0,1);\n    cout<<(res==INF ? -1 : res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//----***やべーやつら***----\nusing namespace std;\n#define int long long\n\n//----***型定義***----\nusing ll = long long;\nusing P = pair<int,int>;\n\n//----***Like a Pythonista***----\n#define REP(ii,jj,nn) for (ll ii=jj;ii<(nn);ii++)\n#define RREP(ii,nn,jj) for (ll ii = nn; jj<ii;ii--)\n#define each(i,...) for (auto&& i:__VA_ARGS__)\n#define ALL(vec) (vec).begin(),(vec).end()\n#define sum(...) accumulate(ALL(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(ALL(__VA_ARGS__),0.0)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\ntemplate<class T> inline auto max(const T& a){ return *max_element(ALL(a)); }\ntemplate<class T> inline auto min(const T& a){ return *min_element(ALL(a)); }\ninline ll gcd(ll a,ll b){if(b == 0) return a;return  gcd(b,a%b);}\ninline ll lcm(ll a,ll b){ll g = gcd(a,b);return a / g * b;}\n\n//----***定数***----\n#define MOD 1000000007\n#define INF 100000000000000000\n#define EPS 1e-9\nconst vector<vector<int>> DXY={{-1,0},{1,0},{0,-1},{0,1}};\n\n//----***パーツ***----\n#define fr first\n#define se second\n#define pb push_back\n\n//----***入出力***---\n#define print(out) cout<< out  << \"\\n\";\n#define debug(var)  do{std::cerr << #var << \" ↓ \"<<\"\\n\";view(var);}while(0);\n#define dbg cerr<<\"🥺🥺🥺🥺🥺🥺\"<<endl;\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ view(v); } }\n\n//----***初期時読み込み***----\nstruct initial{initial(){cin.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}initial_;\n\nsigned main(){\n  int V,E,a,b,c;cin>>V>>E;\n  vector<vector<int>> dp(1<<V,vector<int>(V,INF)),dist(V,vector<int>(V,INF));\n  REP(i,0,E){\n    cin>>a>>b>>c;\n    dist[a][b]=c;\n  }\n  dp[0][0]=0;\n  REP(s,1,(1<<V))REP(v,0,V){\n    if(s&(1<<v)){\n      REP(j,0,V){\n        dp[s][v]=min(dp[s][v],dp[s&~(1<<v)][j]+dist[j][v]);\n      }\n    }\n  }\n  // debug(dp)\n  int ans=(dp[(1<<V)-1][0]==INF?-1:dp[(1<<V)-1][0]);\n  print(ans)\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DBG\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream> \n#include <fstream>\nusing namespace std;\ninline bool ChekBit(int mask, int index) {\n\treturn (bool)((mask >> index) & 1);\n}\ninline int UpDateMask(int mask, int index) {\n\treturn mask | (1 << index);\n}\ninline unsigned int Min(unsigned int a, unsigned int b) {\n\tif (a < b&&a != 0)return a;\n\telse\n\t{\n\t\treturn b;\n\t}\n}\nint main()\n{\n\tint n;\n\tint m;\n\tifstream file(\"input.txt\");\n#ifdef DBG\n\tcin >> n;\n\tcin >> m;\n#else\n\n\tfile >> n;\n\tfile >> m;\n#endif\nvector<vector<pair<int, int>>> map(n);\nvector<int> weightToEnd(n,-1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint vertuxStart;\n\t\tint vertuxEnd;\n\t\tint weight;\n#ifdef DBG\n\t\tcin >> vertuxStart;\n\t\tcin >> vertuxEnd;\n\t\tcin >> weight;\n#else\n\n\t\tfile >> vertuxStart;\n\t\tfile >> vertuxEnd;\n\t\tfile >> weight;\n#endif\n\t\tmap[vertuxStart].push_back(make_pair(vertuxEnd, weight));\n\t\tif (vertuxEnd == 0) {\n\t\t\tweightToEnd[vertuxStart] = weight;\n\t\t}\n\t}\n\tfile.close();\n\tint exp = (int)pow(2, n);\n\t\nvector<vector<unsigned int>> dState= vector<vector<unsigned int>>(exp, vector<unsigned int>(n,(unsigned int)-1));\n\tdState[1][0] = 0;\n\tfor (int mask = 1; mask < exp; mask++)\n\t{\n\t\tfor (int vertexCurrent = 0; vertexCurrent < n; ++vertexCurrent)\n\t\t{\n\t\t\tif (!ChekBit(mask,vertexCurrent))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dState[mask][vertexCurrent]==(unsigned int)-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < map[vertexCurrent].size(); ++i)\n\t\t\t{\n\t\t\t\tint vertexEnd = map[vertexCurrent][i].first;\n\t\t\t\tint weight = map[vertexCurrent][i].second;\n\t\t\t\tif (!ChekBit(mask, vertexEnd)) {\n\t\t\t\t\tint tmpMask = UpDateMask(mask, vertexEnd);\n\t\t\t\t\tdState[tmpMask][vertexEnd] = Min(dState[tmpMask][vertexEnd], dState[mask][vertexCurrent] + weight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t unsigned int answer = (unsigned int)-1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (weightToEnd[i]==-1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (dState[exp-1][i]==(unsigned int)-1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tanswer = Min(answer, dState[exp - 1][i] + weightToEnd[i]);\n\t\t\n\t}\n\tcout << (int)answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,o,n) for(long long i = o;i<n;i++)\n#define oneforall ios::sync_with_stdio(false);cin.tie(0);\n#define all(v) (v).begin(),(v).end()\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n//#define int long long \n#define inf 1000000000\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef long long ll;\ntypedef vector<pair<long, long > > vpll;\ntypedef vector<pair<int, int > > vpii;\n#define FORR(x,arr) for(auto& x:arr)\n#define ZERO(a) memset(a,0,sizeof(a))\n\n\n\n\n\n//3111111111111111111111111111111\n\t\n\tint dp[31][1<<20];\n\tint x[31][31];\n\t\n\tvoid solve(){\n\n\t\tFOR(i,0,31)FOR(i1,0,1<<20)dp[i][i1] = inf;\n\t\tFOR(i,0,31)FOR(i1,0,31)x[i][i1] = inf;\n\t\tini(n);\n\t\tini(n1);\n\t\tFOR(i,0,n1){\n\t\t\tini(x1,tmp1,tmp);\n\t\t\tx[x1][tmp1] = tmp;\n\t\t}\n\t\tdp[0][1] = 0;\n\t\tFOR(i,0,1<<n){\n\t\t\tFOR(i1,0,n){\n\t\t\t\tif(dp[i1][i]!=inf){\n\t\t\t\t\t//out(\"start:\",i1,\"to\",i);\n\t\t\t\t\tFOR(i2,0,n){\n\t\t\t\t\t\tif(!((1<<i2)&i)){\n\t\t\t\t\t\t\tdp[i2][i+(1<<i2)] = min(dp[i2][i+(1<<i2)],dp[i1][i]+x[i1][i2]);\n\t\t\t\t\t\t\t//out(\"in: \",i1,\"i2: \",i2,\"kore\",dp[i2][i+(1<<i2)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//out(\"end:\",i1,\"to\",i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rick  = inf;\n\t\tFOR(i,0,n){\n\t\t\trick  = min(rick,dp[i][(1<<n)-1]+x[i][0]);\n\t\t}\n\t\tif(rick == inf)rick = -1;\n\t\tout(rick);\n\t\n\t\t\n\t\t\n\n\t\t\n\n\n\t\t\n\t\t\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint32_t main() {\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall \n\toneforall\n\n\tsolve();\n\t\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=ja\n//DPL_2_A\n//巡回セールスマン問題,Traveling Salesman Problem\n#include <bits/stdc++.h>\n#if LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\nusing namespace std;\nusing ll=long long;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\ntemplate<class T>bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1; } return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1; } return 0;}\n\ntemplate< typename T >\nstruct edge {\n\tint src, to;\n\tT cost;\n\tedge(int _to, T _cost) : src(-1), to(_to), cost(_cost) {}\n\tedge(int _src, int _to, T _cost) : src(_src), to(_to), cost(_cost) {}\n\tedge &operator=(const int &x) {\n\t\tto = x;\n\t\treturn *this;\n\t}\n\toperator int() const { return to; }\n};\n\ntemplate< typename T>\nstruct node {\n\tvector<edge<T>> edges;\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< node< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nint main() {\n#if LOCAL&01\n  std::ifstream in(\"./test/sample-1.in\");\n  //std::ifstream in(\"./input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n#else\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n#endif\n  ll V,E; cin>>V>>E;\n  WeightedGraph<ll> graph(V);\n  REP(i,E){\n    ll s,t,d; cin>>s>>t>>d;\n    graph.at(s).edges.emplace_back(t,d);\n  }\n  ll bit_max=1LL<<V;\n  ll INF=2LL<<60;\n  vector<vector<ll>> dp(V,vector<ll>(bit_max,INF));\n  dp[0][0]=0;//0からスタート\n  // FOR(i,0,V){\n  //   dp.at(i).at(0)=0;\n  // }\n  FOR(m,0,bit_max){\n    FOR(i,0,V){\n      for(const auto&e:graph.at(i).edges){\n        ll next_m = m|(1LL<<e.to);\n        if(next_m==m) continue;\n        chmin(dp[e.to][next_m], dp[i][m]+e.cost);\n      }\n    }\n  }\n  dump(dp);\n  // ll ans=INF;\n  // REP(i,V){\n  //   chmin(ans,dp[i][bit_max-1]);\n  // }\n  ll ans=dp[0][bit_max-1]; //0ゴールの値\n  if (ans>=INF) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <climits>\n#include <bitset>\n#define MOD 1000000007\n// INT_MAX\nusing namespace std;\n\n// struct Node\n// {\n// \tbitset<16> bit;\n// \t// vector<int> indeg;\n// \tint cur;\n// \tint path;\n// };\n\nclass Solver\n{\nprivate:\n\tint v;\n\tint e;\n\tvector<vector<int> > adj;\n\tvector<vector<int> > dp;\npublic:\n\tSolver(){\n\t\tcin >> v >> e;\n\t\tadj.resize(v);\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tadj[i].resize(v);\n\t\t\tfor (int j = 0; j < v; ++j)\n\t\t\t{\n\t\t\t\tadj[i][j] = INT_MAX/2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < e; ++i)\n\t\t{\n\t\t\tint s, t, d;\n\t\t\tcin >> s >> t >> d;\n\t\t\tadj[s][t] = d;\n\t\t}\n\t\tdp = vector<vector<int> >(1 << v, vector<int>(v, INT_MAX/2) );\n\t}\n\n\tint recursive(int bit, int cur){\n\t\tif(dp[bit][cur] != INT_MAX/2){\n\t\t\treturn dp[bit][cur];\n\t\t}\n\n\t\tif(bit == (1 << v) - 1 && cur == 0) return dp[bit][cur] = 0;\n\t\tint ans = INT_MAX/2;\n\t\tfor (int i = 0; i < v; ++i)\n\t\t{\n\t\t\tif(!(bit >> i & 1) && adj[cur][i] != INT_MAX/2){\n\t\t\t\tif(recursive(bit | 1 << i, i) == INT_MAX/2) continue; \n\t\t\t\tans = min(ans, recursive(bit | 1 << i, i) + adj[cur][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][cur] = ans; \n\t}\n\n\tvoid exec(){\n\t\tint ans = recursive(0, 0);\n\t\tif(ans == INT_MAX/2) ans = -1;\n\t\tcout << ans << endl;\n\t}\n};\n\n\nint main(){\n\tSolver s = Solver();\n\ts.exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ull = unsigned long long;\nusing ll = long long;\n#define endl \"\\n\"\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\n#define even(x) (x) % 2 == 0\n#define odd(x) (x) % 2 != 0\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define inp(t, x) t x;cin>>x;\n#define ithBit(n, i) ((n)>>(i) & 1)\n#define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n// these functions return the position of result of Binary Search.\n#define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n#define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\nnamespace {\n    #define M_PI 3.14159265358979323846\n    const ll MOD_CONST = (ll)(1e9 + 7);\n    const ll CFM = (ll)(998244353);\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline tuple<ll, ll> rotate45(tuple<ll, ll> point)\n    {\n        ll x = get<0>(point), y = get<1>(point);\n        return tuple<ll, ll>(x + y, x - y);\n    }\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n// lambda expression\n// auto f = [](int arg1, double arg2) { return ret; };\n// lambda recursion\n// auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n//\t   rec(pos, v);\n// })(0, 1);\n// auto func = makeFixPoint([]() -> int {});\n// int ret = func();\n\n// tuple binding\n// auto [x, y] = make_tuple(0, 0);\n\n// for pair\n// auto [a, b] = pair<int, int>({v1, v2});\n\n// bitset<N> bs(ini_val); // N must be constant\n// bs.reset(); // reset all\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M);\n    auto g = make_v<ll>(N, N);\n    fill_v(g, -1);\n    REP(i, M) {\n        int f, t, w; cin >> f >> t >> w;\n        g[f][t] = w;\n    }\n\n    /*\n        TSP problem bitDP solution\n        s : vertices already reached\n        v : current vertice\n        dp[s][v] : minimum cost to visit all other vertices and return to first(0) vertex from vertex v.\n    */\n    ll snum = 1 << N;\n    auto dp = make_v<ll>(snum, N);\n    fill_v(dp, INT64_MAX);\n\n    dp[snum-1][0] = 0; // cost to reach vertex 0\n    REPR(s, snum-2) {\n        REP(v, N) {\n            REP(u, N) {\n                if (g[v][u] == -1) continue; // not connected\n                if (ithBit(s, u)) continue; // already reached\n                if (dp[s ^ (1<<u)][u] == INT64_MAX) continue;\n                chmin(dp[s][v], dp[s ^ (1<<u)][u] + g[v][u]);\n            }\n        }\n    }\n    ll ans = dp[0][0];\n    if (ans == INT64_MAX) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n//*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n\nusing namespace std;\n\n\nconst int MAX_V=16;\nconst int MAX_E=(1<<MAX_V);\nconst int INF=1<<28;\n\nint V,E;\nint G[MAX_V][MAX_V];\nint dp[MAX_E][MAX_V];\n\nint dfs(int v,int visit){\n\tif(dp[visit][v] != INF) return dp[visit][v];\n\tif(visit == (1<<V)-1) return G[v][0];\n\n\trep(i,V){\n\t\tif(visit & (1<<i))continue;//??¢????¨????????????????\n\t\tdp[visit][v] = min(dfs(i,(visit | (1<<i)))+G[v][i],dp[visit][v]);\n\t}\n\n\treturn dp[visit][v];\n}\n\nint main(){\n\tcin >> V >> E;\n\tfill_n((int *)dp,sizeof(dp)/sizeof(int),INF);\n\tfill_n((int *)G,sizeof(G)/sizeof(int),INF);\n\trep(i,E){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tG[s][t]=d;\n\t}\n\tint visit=0;\n\tint ans=dfs(0,(visit|1));\n\n\tif(ans==INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint n, m;\nstruct edge\n{\n    int to, cost;\n    edge(int to, int cost) : to(to), cost(cost) {}\n};\nvector<edge> G[18];\nint dp[1<<18][18];\nint dfs(int now, int bit, const int start)\n{\n    if(__builtin_popcount(bit) == n)\n    {\n        for(int u = 0; u < G[now].size(); u++) if(G[now][u].to == start) return G[now][u].cost;\n        return INF;\n    }\n    if(dp[bit][now]) return dp[bit][now];\n    int res = INF;\n    for(int u = 0; u < G[now].size(); u++)\n    {\n        edge e = G[now][u];\n        if(bit & (1<<e.to)) continue;\n        res = min(res, dfs(e.to, bit | (1<<e.to), start) + e.cost);\n    }\n    return dp[bit][now] = res;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    memset(dp, 0, sizeof(dp));\n    cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].push_back(edge(t, d));\n    }\n    int ans = INF;\n    for(int i = 0; i < n; i++) ans = min(ans, dfs(i, 0 | (1<<i), i));\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V, vector<int>(V, -1));\n    for(int i = 0; i < E; ++i){\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    // dp[mask][i][j]\n    // := 訪問済み頂点集合が mask, (終点, 始点) = (i, j) であるときの最短経路\n    // 始点は最初の訪問時に mask に入れる (遷移時に始点に戻るのを防ぐために)\n    vector<vector<vector<int>>> dp(1 << V, vector<vector<int>>(V, vector<int>(V, INF)));\n    for(int i = 0; i < V; ++i)  dp[1 << i][i][i] = 0;\n    for(int mask = 1; mask < (1 << V); ++mask){\n        for(int i = 0; i < V; ++i){\n            for(int j = 0; j < V; ++j){\n                if(dp[mask][j][i] == INF)   continue;\n                for(int k = 0; k < V; ++k){\n                    if(G[j][k] < 0 || mask >> k & 1)   continue;\n                    chmin(dp[mask ^ (1 << k)][k][i], dp[mask][j][i] + G[j][k]);\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for(int i = 0; i < V; ++i){\n        for(int j = 0; j < V; ++j){\n            if(G[i][j] >= 0)    chmin(ans, dp[(1 << V) - 1][i][j] + G[i][j]);\n        }\n    }\n    if(ans == INF)  ans = -1;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int IINF = INT_MAX;\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nint V, E, d[20][20], dp[15][1<<15];\n\nint main() {\n    cin >> V >> E;\n    REP(i,V) fill(d[i], d[i]+V, IINF/3);\n    REP(i,E){\n        int s, t;\n        cin >> s >> t;\n        cin >> d[s][t];\n    }\n    REP(i,V) fill(dp[i], dp[i]+(1<<V), IINF/3);\n    dp[0][0] = 0;\n    REP(S,(1<<V)){\n        REP(i,V){\n            REP(j,V){\n                if(((S>>j)&1)==0){\n                    dp[j][S|(1<<j)] = min(dp[j][S|(1<<j)], dp[i][S]+d[i][j]);\n                }\n            }\n        }\n    }\n    cout << (dp[0][(1<<V)-1]<IINF/3?dp[0][(1<<V)-1]:-1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<class T> inline void chmin(T &a,T b){if(a > b) a = b;}\n#define REP(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\nusing ll = long long;\nconstexpr int INF = 1e9;\n\nint dp[1 << 16][16];\nint V,E,s,t,d;\n\nstruct Edge {\n    int to,cost;\n    Edge(int to,int cost) : to(to), cost(cost){}\n};\n\nusing Graph = vector<vector<Edge> >;\n\nint main(){\n    cin >> V >> E;\n    Graph g(V);\n    REP(i,E){\n        cin >> s >> t >> d;\n        g[s].emplace_back(t,d);\n    }\n    REP(i,1<<V) REP(j,V) dp[i][j] = INF;\n    dp[(1<<V)-1][0] = 0; // start is 0\n    for(int i = (1<<V)-2; i >= 0; --i){\n        // x to somewhere\n        for(int v = 0; v < V; ++v){\n            for(Edge e : g[v]){\n                int nv = e.to;\n                int nc = e.cost;\n                if(!(i & (1<<nv))){\n                    chmin(dp[i][nv],dp[i | (1<<nv)][v] + nc);\n                }\n            }\n        }\n    }\n    cout << (dp[0][0]==INF ? -1 : dp[0][0]) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"DPL_2_A.cpp\"\n#include <cstdio>\n#include <algorithm>\n#include <tuple>\n#include <utility>\n\n#line 1 \"~/git/library/utility/literals.cpp\"\n\n\n\n/**\n * @brief ユーザ定義リテラル\n * @author えびちゃん\n */\n\n#include <cstddef>\n#include <cstdint>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\nconstexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\n\n#line 1 \"~/git/library/utility/make/pre17/vector.cpp\"\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\n\n#ifndef H_make_vector\n#define H_make_vector\n\n#line 10 \"~/git/library/utility/make/pre17/vector.cpp\"\n#include <type_traits>\n#include <vector>\n\nnamespace detail {\n  template <typename Tp, size_t N>\n  std::vector<Tp> make_vector(\n      std::vector<size_t>& sizes,\n      typename std::enable_if<(N == 1), Tp const&>::type x\n  ) {\n    return std::vector<Tp>(sizes[0], x);\n  }\n  template <typename Tp, size_t N>\n  auto make_vector(\n      std::vector<size_t>& sizes,\n      typename std::enable_if<(N > 1), Tp const&>::type x\n  ) {\n    size_t size = sizes[N-1];\n    sizes.pop_back();\n    return std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n        size, make_vector<Tp, N-1>(sizes, x)\n    );\n  }\n}  // detail::\n\ntemplate <typename Tp, size_t N>\nauto make_vector(size_t const(&sizes)[N], Tp const& x = Tp()) {\n  std::vector<size_t> s(N);\n  for (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n  return detail::make_vector<Tp, N>(s, x);\n}\n\n#endif  /* !defined(H_make_vector) */\n#line 8 \"DPL_2_A.cpp\"\n\nint main() {\n  size_t v, e;\n  scanf(\"%zu %zu\", &v, &e);\n\n  std::vector<std::vector<std::pair<size_t, int>>> g(v);\n  for (size_t i = 0; i < e; ++i) {\n    size_t s, t;\n    int d;\n    scanf(\"%zu %zu %d\", &s, &t, &d);\n    g[s].emplace_back(t, d);\n  }\n\n  int const inf = 1e9;\n  auto dp = make_vector({1_zu << v, v}, inf);\n  dp[0][0] = 0;\n  for (size_t i = 0; i < (1_zu << v); ++i) {\n    for (size_t jl = 0; jl < v; ++jl) {\n      if (dp[i][jl] == inf) continue;\n      for (auto const& e: g[jl]) {\n        size_t jr;\n        int d;\n        std::tie(jr, d) = e;\n        if (i >> jr & 1) continue;\n        size_t ni = i | 1_zu << jr;\n        dp[ni][jr] = std::min(dp[ni][jr], dp[i][jl] + d);\n      }\n    }\n  }\n\n  int res = dp.back()[0];\n  if (res == inf) return puts(\"-1\"), 0;\n  printf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define REP2(i,x,n) for(int i=x; i<(n); i++)\n#define PRINT(x) cout<<(x)<<endl\n#define INF 1000000007 // 10^12\n#define MOD 1000000007 // 10^9+7\n#define PB push_back\n#define MP make_pair\n\nconst int MAX_V = 15;\n\nint V, E;\nint s, t, d;\n\nint G[MAX_V][MAX_V];\nint dp[MAX_V][1<<MAX_V][MAX_V];\n\nint rec(int, int, int);\n\nint main() {\n    cin >> V >> E;\n    REP(i, V) {\n        REP(j, V) {\n            G[i][j] = INF;\n        }\n    }\n    REP(i, E) {\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    REP(i, V) {\n        REP(bit, 1<<V) {\n            REP(j, V) dp[i][bit][j] = -1;\n        }\n    }\n\n    int ans = INF;\n    REP(i, V) {\n        ans = min(ans, rec(i, (1<<V)-1, i));\n    }\n    if (ans == INF) ans = -1;\n    PRINT(ans);\n    \n}\n\nint rec(int s, int bit, int v) {\n    if (dp[s][bit][v] != -1) return dp[s][bit][v];\n    if (bit == 1<<v) return dp[s][bit][v] = G[s][v];\n    int res = INF;\n    int prev_bit = bit & ~(1<<v);\n    REP(u, V) {\n        if (!(prev_bit & (1<<u))) continue;\n        if (G[u][v] == INF) continue;\n        res = min(res, rec(s, prev_bit, u) + G[u][v]);\n    }   \n    return dp[s][bit][v] = res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<ll> > Adj_Mat;\n\n\nbool contain(int mask, int pos){\n\t  return ( mask & (1<<pos) ) != 0;\n}\n\nint main(){\n\n\t  // Input Graph\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_Mat G(V,vector<ll>(V,INT_MAX));\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t,d; cin >> s >> t >> d;\n\t\t\tG[s][t] = d;\n\t  }\n\n\t  ll ans = INT_MAX;\n\t  // Dynamic Programming for TSP\n\t  for(int st=0; st<V; st++){\n\n\t\t\tll dp[ (1<<V) ][ V ];\n\t\t\tfor(int i=0; i<(1<<V); i++) for(int j=0; j<V; j++) dp[i][j] = INT_MAX;\n\t\t\tdp[ 0 ][ st ] = 0;\n\n\t\t\tfor(int S=1; S<(1<<V); S++)\n\t\t\t\t  for(int v=0; v<V; v++)\n\t\t\t\t\t\tif( contain(S,v) )\n\t\t\t\t\t\t\t  for(int j=0; j<V; j++)\n\t\t\t\t\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S-(1<<v)][j] + G[j][v]);\n\t  }\n\t  if( ans >= 1e+9 ) ans = -1;\n\t  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint recursive(int pattern,int node,int v,vector<vector<pair<int,int>>> &g,vector<vector<int>> &dp);\n\nint main()\n{\n\tint v,e;\n\tcin >> v >> e;\n\tvector<vector<pair<int,int>>> g(v);\n\n\tfor (int i=0;i<e;++i)\n\t{\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tg[s].push_back(make_pair(t,d));\n\t\t//g[t].push_back(make_pair(s,d));\n\t}\n\n\tint max_pattern=1<<v;\n\tvector<vector<int>> dp(max_pattern,vector<int>(v));\n\tconst int infinity=32768*32767;\n\tfor (int i=0;i<v;++i)\n\t{\n\t\tdp[0][i]=infinity;\n\t}\n\n\tfor (int i=1;i<max_pattern;++i)\n\t{\n\t\tfor (int j=0;j<v;++j)\n\t\t{\n\t\t\tdp[i][j]=-1;\n\t\t}\n\t}\n\n\tdp[1<<0][0]=0;\n\tfor (int i=1;i<v;++i)\n\t{\n\t\trecursive(max_pattern-1,i,v,g,dp);\n\t}\n\n\tint min_d=infinity;\n\tfor (int i=0;i<g[0].size();++i)\n\t{\n\t\tint dd=dp[max_pattern-1][g[0][i].first];\n\t\tif ( (dd>=0) && (dd!=infinity) )\n\t\t{\n\t\t\tmin_d=min(min_d,dd+g[0][i].second);\n\t\t}\n\t}\n\n\tif (min_d!=infinity)\n\t{\n\t\tcout << min_d << endl;\n\t}\n\telse\n\t{\n\t\tcout << -1 << endl;\n\t}\n}\n\nint recursive(int pattern,int node,int v,vector<vector<pair<int,int>>> &g,vector<vector<int>> &dp)\n{\n\tconst int infinity=32768*32767;\n\tint min_d=infinity;\n\n\tpattern^=(1<<node); // clear bit\n\tfor (int i=0;i<g[node].size();++i)\n\t{\n\t\tint d;\n\t\tint nn=g[node][i].first;\n\t\tif ((pattern&(1<<nn))!=0)\n\t\t{\n\t\t\tif (dp[pattern][nn]<0)\n\t\t\t{\n\t\t\t\trecursive(pattern,nn,v,g,dp);\n\t\t\t}\n\t\t\tmin_d=min(min_d,dp[pattern][nn]+g[node][i].second);\n\t\t}\n\t}\n\tdp[pattern^(1<<node)][node]=min_d;\n\t//fprintf(stderr,\"recursive: %d %d = %d\\n\",pattern^(1<<node),node,min_d);\n\treturn 0;\n}\n\n\n\t\t\t\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e8;\n\nint rec(int bit, int v, vector<vector<int>> &dp, vector<vector<int>> &g){\n\tint n = dp.at(0).size();\n\tif(dp.at(bit).at(v)!=-1) return dp.at(bit).at(v);\n\tif(bit==(1<<v)) return dp.at(bit).at(v)=0;\n\t\n\tint dist = INF;\n\tint pbit = bit & ~(1<<v);\n\tfor(int i=0; i<n; i++){\n\t\tif(!(pbit&(1<<i))) continue;\n\t\tif(dist > rec(pbit, i, dp, g)+g.at(i).at(v)) {\n\t\t\tdist = rec(pbit, i, dp, g)+g.at(i).at(v);\n\t\t}\n\t}\n\treturn dp.at(bit).at(v) = dist;\n}\nint main() {\n\t\n\tint n,m;\n\tcin >> n >> m;\n\tvector<vector<int>> g(n+1,vector<int>(n+1,INF));\n\tfor(int i=0; i<m; i++){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tg.at(s).at(t) = d; \n\t}\n\tvector<vector<int>> dp(1<<(n+1),vector<int>(n+1,-1));\n\tint ans{INF},cnt;\n\tfor(int i=0; i<n; i++){\n\t\tauto dp1 = dp;\n\t\tauto g1 = g;\n\t\tfor(int j=0; j<n+1; j++){\n\t\t\tfor(int k=0; k<n+1; k++){\n\t\t\t\tif(j!=n&&k==n) g1.at(j).at(k) = INF;\n\t\t\t\tif(j==n) g1.at(j).at(k) = g.at(i).at(k); \n\t\t\t}\n\t\t}\n\t\tans = min(ans, rec((1<<(n+1))-1, i, dp1, g1));\n\t\t\n\t}\n\tcout << (ans==INF?-1:ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ループverです。移動後はvisitedが増えるので, visited昇順にループを回せば良いです。\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint INF = 1000000007;\nint n, m;\nbool canMove[15][15] = {false};\nint ecost[15][15];\nint dp[1 << 15][15];\t//dp[visited][pos] = これまでの最小コスト（visitedの下位i(>=0)ビット目が1⇔頂点iを訪問済み, pos…現在地.）\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tecost[s][t] = d;\n\t\tcanMove[s][t] = true;\n\t}\n\t\n\tfor (i = 0; i < (1 << n); i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n\tdp[1][0] = 0;\n\tfor (i = 1; i < (1 << n) - 1; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (dp[i][j] >= INF) continue;\t//この行は無くてもよい\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\tif (!canMove[j][k]) continue;\n\t\t\t\tif ((i >> k) & 1) continue;\n\t\t\t\tdp[i + (1 << k)][k] = min(dp[i + (1 << k)][k], dp[i][j] + ecost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (j = 0; j < n; j++) {\n\t\tif (dp[(1 << n) - 1][j] < INF && canMove[j][0]) {\n\t\t\tans = min(ans, dp[(1 << n) - 1][j] + ecost[j][0]);\n\t\t}\n\t}\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1<<28;\n\nint G[MAX_V][MAX_V];\n\nint V, E;\nint memo[MAX_V][1 << MAX_V];\nvoid init() {\n    memset(memo, -1, sizeof(memo));\n}\nint dfs(int v, int used) {\n    if (used == (1 << V) - 1) return G[v][0];\n    if (memo[v][used] >= 0) return memo[v][used];\n    int ret = INF;\n    for (int u = 0; u < V; u++) {\n        if (v == u || G[v][u] == INF || (used & (1 << u))) continue;\n        ret = min(ret, dfs(u, used | (1 << u)) + G[v][u]);\n    }\n    return memo[v][used] = ret;\n}\nint TSP() {\n    init();\n    return dfs(0, 0);\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) G[i][j] = INF;\n        G[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n    int Ans = TSP();\n    cout << (Ans >= INF ? -1 : Ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif __GNUC__\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\nclass DGraph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n\n    DGraph(size_t n = 1) :n(n), vertex_to(n), vertex_from(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[(size_t)from].emplace_back(to);\n        vertex_from[(size_t)to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n        vertex_from.resize(_n);\n    }\n};\n\n\nclass GraphE {\npublic:\n    typedef int W_T;\n    struct Edge {\n        int u, v;\n        W_T value;\n        Edge(int from = 0, int to = 0, W_T value = 0) :u(from), v(to), value(value) {}\n        inline int to(int _v) const { return _v == v ? u : v; }\n    };\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<Edge> edges;\n\n    GraphE(int n = 1) :n(n), vertex_to(n) { }\n\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n    void connect(int from, int to, W_T val = 0) {\n        vertex_to[(size_t)from].push_back((int)edges.size());\n        vertex_to[(size_t)to].push_back((int)edges.size());\n        edges.emplace_back(from, to, val);\n    }\n};\n\nclass Graph2d {\npublic:\n    typedef ll W_T;\n    size_t n;\n    vector<W_T> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline W_T& at(int y, int x) { return matrix[y*n + x]; }\n    inline W_T& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline W_T at(int y, int x) const { return matrix[y*n + x]; }\n    inline W_T operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, W_T dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, W_T dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\n\n\nvector<int> tsProblem(int n, const Graph2d& graph) {\n    typedef ll dist_T;\n    typedef unsigned long long ull;\n\n    if (n <= 1)\n        return { 0 };\n    if (n == 2)\n        return { 0, 1 };\n\n    vector<vector<dist_T>> dp;\n    ull bit;\n\n    // initialize\n    dp.resize(n);\n    for (auto &v : dp)\n        v.resize(1 << n),\n        fill(ALL(v), (dist_T)5e15);\n\n    // bitdp\n    dp[0][1] = 0;\n    iterate(bit_i, 1, (1 << n) - 1) {\n        bit = bit_i;\n\n        repeat(from, n) {\n            if (!(bool)(bit&(1ull << from))) continue;\n            dist_T pt = dp[from][bit_i];\n\n            repeat(to, n) {\n                if ((bool)(bit&(1ull << to))) continue;\n                dp[to][bit_i | (1ull << to)] = min(dp[to][bit_i | (1 << to)], pt + graph(from, to));\n            }\n        }\n    }\n    // ????°??????¢???\n    dist_T best = 5e15;\n    int tail = 0;\n    repeat(i, n)\n        if (dp[i][(1 << n) - 1] + graph(i, 0) < best)\n            best = dp[i][(1 << n) - 1] + graph(i, 0), tail = i;\n\n    // ??????\n    vector<int> tourist; tourist.reserve(n);\n    bit = (1ull << n) - 1ull;\n    repeat(z, n - 1) {\n        ull b = bit;\n        tourist.push_back(tail);\n        bit ^= bit & (1ull << tail);\n        ull c = bit;\n\n        repeat(nxt, n) {\n            if ((bit&(1ull << (ull)nxt)) && abs(dp[tail][b] - dp[nxt][c] - graph(nxt, tail)) == 0) {\n                tail = nxt;\n                break;\n            }\n        }\n    }\n    tourist.push_back(0);\n    reverse(ALL(tourist));\n    return tourist;\n}\n\nint main() {\n\n    int n, m;\n    scanner >> n >> m;\n\n    Graph2d dist(n);\n\n    repeat(i, n)\n        repeat(j, n)\n            dist(i, j) = ll(1e7);\n\n\n    repeat(i, m) {\n        int s, t, d;\n        scanner >> s >> t >> d;\n        minset(dist(s, t), ll(d));\n    }\n\n    auto ans = tsProblem(n, dist);\n\n    ll len = 0;\n    {\n        int p = ans.back();\n        for (int t : ans)\n            len += dist(p,t),\n            p = t;\n    }\n\n    if (len >= ll(1e7))\n        cout << -1 << endl;\n    else\n        cout << len << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\nint main()\n{\n    int V,E;cin >> V>> E;\n    vector<vector<int>> graph(V,vector<int> (V,-1));\n    int u,v;\n    for (int i=0;i<E;i++)\n    {\n        cin >> u >> v;\n        cin >> graph[u][v];\n    }\n    vector<vector<int>> dp(1<<(V-1),vector<int> (V,INF)); //dp[s][v] sは今まで訪れた点集合、vは今いる点\n    dp[0][0]=0;\n    for (int i=0;i<1<<(V-1);i++) //iだけ1indexed\n    {\n        for (int u=0;u<V;u++)\n        {\n            for (int v=1;v<V;v++)\n            {\n                if (((i>>(v-1))&1)==0)\n                {\n                    if (graph[u][v]>=0)\n                    {\n                        //cout << (1<<(v-1)) << endl;\n                        //cout << \"i\"<<i<< endl;\n                        dp[i+(1<<(v-1))][v]=min(dp[i+(1<<(v-1))][v],dp[i][u]+graph[u][v]);\n                    }\n                }\n            }\n        }\n    }\n    int ans=INF;\n    for (int i=1;i<V;i++)\n    {\n        if (graph[i][0]>=0) ans=min(ans,dp[(1<<(V-1))-1][i]+graph[i][0]);\n    }\n    if (ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(int)(n); i<i##_len; i++)\n#define reps(i,n) for(int i=1 , i##_len=(int)(n);i<=i##_len;i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;i--)\n#define rreps(i,n) for(int i=((int)(n));i>0;i--)\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define solve(a) ((a)?\"Yes\":\"No\")\ntypedef vector<long long> V;\ntypedef vector<V> VV;\ntypedef pair<long long , long long> P;\ntypedef vector<P> VP;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1;} return 0;}\nconst long long INFLL = 1LL<<62;\nconst int INF = 1<<30;\nconst double PI=acos(-1);\nint func(int last,int state,vector<vector<int>>& dp,vector<vector<pair<int,int>>>&path){\n//\tclog << last << \" \" << bitset<16>(state) <<endl;\n\tif (dp[last][state] == -1)\n\t{\n\t\tdp[last][state]=INF;\n\t\tfor(auto itr=path[last].begin();itr!=path[last].end();itr++){\n\t\t\tif(state&(1<<(last))){\n\t\t\t\tchmin(dp[last][state],func(itr->F,state&~(1<<last),dp,path)+(itr->S));\n\t\t\t}\n\t\t}\n\t}\n//\tclog <<last<<\" \"<< bitset<16>(state)<<\" -> \"<<dp[last][state] << endl;\n\treturn dp[last][state];\n}\nint main(){\n\tint v,e;\n\tint ans=INF;\n\tcin >>v>>e;\n\tvector<vector<pair<int,int>>>path(v);\n\tint s,t,d;\n\trep(i,e){\n\t\tcin>>s>>t>>d;\n\t\tpath[s].emplace_back(t,d);\n\t}\n\tvector<vector<int>>dp(v,vector<int>(1<<v,-1));\n\trep(i,v){\n\t\tdp[i][0]=0;\n\t\tfunc(i,(1<<v)-1,dp,path);\n\t\tchmin(ans,dp[i][(1<<v)-1]);\n\t//\tclog<<endl;\n\t\trep(I,v){\n\t\t\trep(J,1<<v){\n\t\t\t\tdp[I][J]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans==INF?-1:ans)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define INF (1 << 30) - 1\n#define LLINF (1LL << 61) - 1\n// #define int ll\nusing namespace std;\nconst int MOD = 1000000007;\nconst int MAX = 510000;\n \nll n,e;\nll d[16][16];\nll dp[1<<16][16];\n \n// すでに訪れた頂点の集合がS、現在頂点がv\nll rec(ll S,ll v){\n    if(dp[S][v]>=0){\n        return dp[S][v];\n    }\n    if(S==(1<<n)-1 && v==0){\n        // 全ての頂点を訪れて戻ってきた\n        return dp[S][v]=0;\n    }\n \n    ll res=INF;\n    for(ll u=0;u<n;u++){\n        if(!(S>>u & 1)){\n            // 次に頂点uに移動する\n            res=min(res,rec(S | 1<<u ,u) +d[v][u]);\n        }\n    }\n    return dp[S][v] =res;\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    rep(i,1<<16)rep(j,16){\n        dp[i][j]=-1;\n    }\n    rep(i,20)rep(j,20){\n        d[i][j]=INF;\n    }\n    ll ans=INF;\n    cin>>n>>e;\n    rep(i,e){\n        ll a,b,c;\n        cin>>a>>b>>c;\n        d[a][b]=c;\n    }\n    if(rec(0,0)==INF){\n        cout<<-1<<endl;\n    }\n    else{\n        cout<<rec(0,0)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  VV<> d; assign(d, n, n, (int) 1e9);\n  for (int i = 0; i < n; ++i) d[i][i] = 0;\n  for (int i = 0; i < m; ++i) {\n    int s, t, _d; cin >> s >> t >> _d;\n    d[s][t] = _d;\n  }\n  VV<> dp; assign(dp, 1 << n, n, (int) 1e9);\n  dp[0][0] = 0;\n  for (int bit = 0; bit < 1 << n; ++bit) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    dp[bit][i] = min(dp[bit][i], dp[bit ^ 1 << i][j] + d[j][i]);\n  }\n  int res = dp.back()[0] != 1e9 ? dp.back()[0] : -1;\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// (to, cost)\nvector<pii> G[20];\nint dp[1 << 15][15];\n\nvoid solve() {\n    int V, E; cin >> V >> E;\n    rep(i,0,E) {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].push_back(pii(t, d));\n    }\n\n    int ans = INF;\n    rep(i,0,1<<V) rep(j,0,V) dp[i][j] = INF;\n    dp[0][0] = 0;\n    rep(bit,0,1<<V) rep(i,0,V) {\n        for(auto x : G[i]) {\n            if(bit >> x.first & 1) continue;\n            int nbit = bit | (1 << x.first);\n            chmin(dp[nbit][x.first], dp[bit][i] + x.second);\n        }\n    }\n    rep(i,0,V) chmin(ans, dp[(1<<V) - 1][i]);\n    cout << (ans == INF ? -1 : ans) << endl;\n}\n\nsigned main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_V 16\n#define INF 100000000\nusing namespace std;\nint n,s,t,l,m;\nint dp[1<<MAX_V][MAX_V];\nint d[MAX_V][MAX_V];\nint solve(int S,int v){\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n  if(S==(1<<n)-1 && v==0){\n    return dp[S][v]=0;\n  }\n  int res = INF;\n  for(int u=0;u<n;u++){\n    if(!(S>>u&1)){\n      res = min(res,solve(S | 1<<u, u)+d[v][u]);\n    }\n  }\n  return dp[S][v] = res;\n}\nint main(){\n  cin >> n>>m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      d[i][j]=INF;\n    }\n  }\n  for(int i=0;i<1<<n;i++){\n    for(int j=0;j<n;j++){\n      dp[i][j]=-1;\n    }\n  }\n  for(int i=0;i<m;i++){\n    cin >> s >> t;\n    cin >>d[s][t];\n  }\n  int tmp=solve(0,0);\n  if(tmp==INF){\n    cout << \"-1\\n\";\n  }else{\n    cout << tmp<<endl;\n  }\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 15\n\nint n,e;\nint edge[N][N];\nint py[N],px[N];\n\nint solve_dp(){\n    int (*dp)[N];\n    dp = (int(*)[N])malloc(sizeof(int)*(1<<n)*N);\n    int m = 1<<n;\n    int i,j,k,l,b;\n    for(i = 0;i < m;i++) for(j = 0;j < n;j++) dp[i][j] = -1;\n    dp[1][0] = 0;\n    for(i = 1;i < n;i++){\n        for(j = 0;j < m;j++){\n            if(i != __builtin_popcount(j)) continue;\n            for(k = 0;k < n;k++){\n                if(dp[j][k] < 0) continue;\n                for(l = 0;l < n;l++){\n                    b = 1<<l;\n                    if((b&j) || edge[k][l] == -1) continue;\n                    b = j|b;\n                    if(dp[b][l] < 0 || dp[b][l] > dp[j][k]+edge[k][l]) dp[b][l] = dp[j][k]+edge[k][l];\n                }\n            }\n        }\n    }\n    int res = -1;\n    for(i = 0;i < n;i++){\n        if(dp[(1<<n)-1][i] == -1 || edge[i][0] == -1) continue;\n        int a = dp[(1<<n)-1][i] + edge[i][0];\n        if(res == -1 || res > a) res = a;\n    }\n    free(dp);\n    return res;\n}\n\nint solve(){\n    int i,j;\n    int a,b,d;\n    scanf(\"%d %d\",&n,&e);\n    for(i = 0;i < n;i++){\n        for(j = 0;j < n;j++){\n            edge[i][j] = -1;\n        }\n    }\n    for(i = 0;i < e;i++){\n        scanf(\"%d %d %d\",&a,&b,&d);\n        edge[a][b] = d;\n    }\n    return solve_dp();\n}\n\nint main(){\n    printf(\"%d\\n\",solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <vector>\n//#include <algorithm>\n\nusing namespace std;\n\n//vector < vector < int > > rebra;\n\nint getbit(int mask, int num)\n{\n    return (mask >> num) &1;\n}\n\nint main()\n{\n    int n, m, a, b, c, l = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        l *= 2;\n    l--;\n    int rebra[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            rebra[i][j] = -1;\n    for (int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            rebra[a][b] = c;\n        }\n    long long dp[l+1][n];\n    for (int i = 0; i <= l; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = -1;\n    dp[1][0] = 0;\n    long long f = 1;\n    for (long long mask = 1; mask <= l; mask++)\n        for (int j = 0; j < n; j++)\n            if ((getbit(mask, j) == 1) && (dp[mask][j] != -1))\n                for (int q = 0; q < n; q++)\n                    if ((rebra[j][q] != -1) && (getbit(mask, q) == 0)){\n                        f = 1;\n                        for (int y = 0; y < q; y++)\n                            f *= 2;\n                        f += mask;\n                        if ((dp[f][q] == -1) || (dp[mask][j] + rebra[j][q] < dp[f][q])){\n                            dp[f][q] = dp[mask][j] + rebra[j][q];\n                            f = 0;\n                            }\n\n                    }\n    int mm = -1;\n    for (int i = 1; i < n; i++)\n        if ((dp[l][i] != -1) && (rebra[i][0] != -1))\n            if (mm == -1){\n                mm = dp[l][i] + rebra[i][0];\n            } else {\n                if ((mm == -1) || (dp[l][i] + rebra[i][0] < mm))\n                    mm = dp[l][i] + rebra[i][0];\n            }\n    /*for (int i = 0; i < n; i++){\n        for (int j = 1; j <= l; j++)\n            cout << dp[j][i] << ' ';\n        cout << endl;\n    }*/\n    if (mm == -1)\n        cout << \"No solution\";\n    else\n        cout << mm;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <vector>\n//#include <algorithm>\n\nusing namespace std;\n\n//vector < vector < int > > rebra;\n\nint getbit(int mask, int num)\n{\n    return (mask >> num) &1;\n}\n\nint main()\n{\n    int n, m, a, b, c, l = 1;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        l *= 2;\n    l--;\n    int rebra[n][n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            rebra[i][j] = -1;\n    for (int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            rebra[a][b] = c;\n        }\n    long long dp[l+1][n];\n    for (int i = 0; i <= l; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = -1;\n    dp[1][0] = 0;\n    long long f = 1;\n    for (long long mask = 1; mask <= l; mask++)\n        for (int j = 0; j < n; j++)\n            if ((getbit(mask, j) == 1) && (dp[mask][j] != -1))\n                for (int q = 0; q < n; q++)\n                    if ((rebra[j][q] != -1) && (getbit(mask, q) == 0)){\n                        f = 1;\n                        for (int y = 0; y < q; y++)\n                            f *= 2;\n                        f += mask;\n                        if ((dp[f][q] == -1) || (dp[mask][j] + rebra[j][q] < dp[f][q])){\n                            dp[f][q] = dp[mask][j] + rebra[j][q];\n                            f = 0;\n                            }\n\n                    }\n    int mm = -1;\n    for (int i = 1; i < n; i++)\n        if ((dp[l][i] != -1) && (rebra[i][0] != -1))\n            if (mm == -1){\n                mm = dp[l][i] + rebra[i][0];\n            } else {\n                if ((mm == -1) || (dp[l][i] + rebra[i][0] < mm))\n                    mm = dp[l][i] + rebra[i][0];\n            }\n    /*for (int i = 0; i < n; i++){\n        for (int j = 1; j <= l; j++)\n            cout << dp[j][i] << ' ';\n        cout << endl;\n    }*/\n    cout << mm;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n \n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n \n//typedef\n//------------------------------------------\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF=INT_MAX/10;\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n\n#define MAX_N 16\nint n;\nint d[MAX_N][MAX_N];\n\nint dp[1<<MAX_N][MAX_N];\n\nint rec(int S,int v){//??¢????????£??????????????????S??¨???????????????v\n\t\n\tif(dp[S][v]>=0){//??¢?????????S????????????v??????????????????????????????\n\t\treturn dp[S][v];\n\t}\n\tif(S==(1<<n)-1&&v==0){//S?????¨??????????????????????????¶?????§???????????????????????£?????????\n\t\tdp[S][v]=0;\n\t\treturn 0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<n;u++){\n\t\tif(!(S>>u & 1)){//??????u??????????????£??????????????¨???\n\t\t\tres=min(res,rec(S|1<<u, u)+d[v][u]);//??????u???S???????????????u->v????????????????????????????????´?????¨????????¨???res????????????\n\t\t}\n\t}\n\tdp[S][v]=res;\n\t//cout<<res<<endl;\n\treturn res;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\t\n\tint V,E;\n\tcin>>V>>E;\n\tn=V;\n\tREP(i,n)REP(j,n)d[i][j]=INF;\n\tREP(i,E){\n\t\tint s,t,cost;\n\t\tcin>>s>>t>>cost;\n\t\td[s][t]=cost;\t\t\n\t}\n\tint res=rec(0,0);\n\tif(res<INF)cout<<res<<endl;\n\telse cout<<-1<<endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    using ii = pair<int, i64>;\n    vector<vector<ii>> adj(v);\n    for (int i = 0; i < e; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        adj[s].push_back(ii(t, d));\n    }\n\n    vvi dp(1 << v, vi(v, 1e18));\n    // dp[i][j]: すでにiを回って今jにいる\n    dp[0][0] = 0;\n    for (int i = 0; i < 1 << v; i++) {\n        for (int j = 0; j < v; j++) {\n            for (auto &p: adj[j]) {\n                dp[i | (1 << p.first)][p.first] = min(dp[i | (1 << p.first)][p.first], dp[i][j] + p.second);\n            }   \n        }\n    }\n    cout << (dp[(1 << v) - 1][0] == 1e18 ? -1 : dp[(1 << v) - 1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 15\nusing namespace std;\ntypedef pair<int,int> P;\nint n,G[N][N];\nint Min(int &a,int b){return a=min(a,b);}\n\nint mem[N][1<<N],used[N][1<<N];\nint dfs(int pos,int bit,int start){\n  if(bit == (1<<n)-1) return 0;\n  if(bit!=0 && pos == start) return 1e9;\n  if(used[pos][bit]++) return mem[pos][bit];\n  int res = 1e9;\n  for(int i=0;i<n;i++){\n    if(bit>>i&1)continue;\n    int nbit = bit | 1<<i;\n    Min(res,G[pos][i]+dfs(i,nbit,start));\n  }\n  return mem[pos][bit] = res;\n}\n\nint main(){\n  int m;\n  cin>>n>>m;\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)G[i][j] = 1e9;\n  \n  for(int i=0,a,b,d;i<m;i++){\n    cin>>a>>b>>d;\n    Min(G[a][b],d);\n  }\n\n  int ans = 1e9;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    Min(ans,dfs(i,0,i));\n  }\n  if(ans == 1e9)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<long long>;\nusing pll = pair<long long, long long>;\n#define rep(i,n) for(long long i(0);(i)<(n);(i)++)\n#define REP(i,n) for(long long i(0);(i)<(n);(i)++)\nll INF = 1LL << 60;\n\nll TSP(vector<vll> &d, ll N){\n    vector<vll> dp(1<<N, vll(N, INF));\n    dp[(1<< N)-1][0] = 0;\n\n    for(ll S = (1LL<< N) -2; S >= 0; S--){\n        REP(v, N){\n            REP(u, N){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min( dp[S][v], dp[S| 1LL<< u][u]+ d[v][u]);\n                }\n            }\n        }\n    }\n    return dp[0][0];\n}\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    vector<vll> d(N, vll(N, INF));\n    REP(i, M){\n        ll s, t, cost;\n        cin >> s >> t >> cost;\n        d[s][t] = cost;\n    }\n    ll res = TSP(d, N);\n    if(res < INF)\n        cout << res << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PP pair<P,P>\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int v,e;\n  cin>>v>>e;\n  int es[20][20]={};\n  rep(i,20){\n    rep(j,20){\n      if(i==j) continue;\n      es[i][j]=inf;\n    }\n  }\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s][t]=d;\n  }\n\n  int dp[1<<v][v];\n  rep(i,1<<v){\n    rep(j,v){\n      dp[i][j]=inf;\n    }\n  }\n  dp[0][0]=0;\n\n  rep(i,1<<v){\n    rep(j,v){\n      if(i&(1<<j)) continue;\n      rep(k,v){\n        if(j==k) continue;\n        dp[i|(1<<j)][j]=min(dp[i|(1<<j)][j],dp[i][k]+es[k][j]);\n      }\n    }\n  }\n\n\n  cout<<(dp[(1<<v)-1][0]==inf?-1:dp[(1<<v)-1][0])<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dp[1 << 15][15];\nint d[15][15];\nint V, E;\nvector<vector<edge>> es(15);\n\nint bitDP(int s, int v)\n{\n\tif (dp[s][v] >= 0) return dp[s][v];\n\tif (s == (1 << V) - 1 && v == 0)\n\t{\n\t\treturn dp[s][v] = 0;\n\t}\n\tint res = INF;\n\tREP(i, V)\n\t{\n\t\tif (!(s >> i & 1))\n\t\t{\n\t\t\tres = min(res, bitDP(s | 1 << i, i) + d[v][i]);\n\t\t}\n\t}\n\treturn dp[s][v] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\tREP(i, V)REP(j, V)\n\t{\n\t\td[i][j] = (i == j ? 0 : INF);\n\t}\n\tREP(i, E)\n\t{\n\t\tint s, t, c;\n\t\tcin >> s >> t >> c;\n\t\td[s][t] = c;\n\t}\n\tMS(dp, -1);\n\tcout << (bitDP(0, 0) >= INF ? -1 : bitDP(0, 0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint n, d[16][16], dp[1<<15][16];\nsigned main(void)\n{\n  int m;\n  cin >> n >> m;\n  REP(i, n) REP(j, n) d[i][j] = INF;\n  REP(i, m) {\n    int s, t, dd;\n    cin >> s >> t >> dd;\n    d[s][t] = dd;\n  }\n  REP(i, 1<<n) fill(dp[i], dp[i]+n, INF);\n  dp[(1<<n)-1][0] = 0;\n\n  for(int s=(1<<n)-2; s>=0; --s) {\n    REP(v, n) REP(u, n) {\n      if(!(s>>u&1)) dp[s][v] = min(dp[s][v], dp[s|1<<u][u] + d[v][u]);\n    }\n  }\n  if(dp[0][0] >= INF) cout << -1 << endl;\n  else cout << dp[0][0] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing edge = struct\n{\n    int to;\n    int cost;\n};\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dist[15][15];\n\nint dp[1 << 15][15];\n\nint main()\n{\n\n    int V, E;\n    cin >> V >> E;\n\n    rep(i, V) rep(j, V) dist[i][j] = iINF;\n    rep(i, V) dist[i][i] = 0;\n\n    rep(i, E)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    rep(S, (1 << V))\n    {\n        fill(dp[S], dp[S] + V, iINF);\n    }\n\n    dp[(1 << V) - 1][0] = 0;\n\n    for (int S = (1 << V) - 2; S >= 0; S--)\n    {\n        rep(v, V)\n        {\n            rep(u, V)\n            {\n                if (!(S >> u & 1))\n                {\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dist[v][u]);\n                }\n            }\n        }\n    }\n\n    cout << (dp[0][0] != iINF ? dp[0][0] : -1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> g(V, vector<int>(V, INF));\n    for(int i=0; i<E; ++i) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n    vector<vector<int>> dp(V, vector<int>(1 << V, INF));\n    dp[0][0] = 0;\n    for(int i=0; i<1<<V; ++i) {\n        for(int j=0; j<V; ++j) {\n            if(i >> j & 1) {\n                continue;\n            }\n            for(int k=0; k<V; ++k) {\n                dp[j][i | (1 << j)] = min(dp[j][i | (1 << j)], dp[k][i] + g[k][j]);\n            }\n        }\n    }\n    if(dp[0][(1 << V) - 1] == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << dp[0][(1 << V) - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 987654321\nint V, E, A[15][15], MEMO[15][32768], VISIT[15][32768];\nvoid input(void);\nvoid init_A(void);\nvoid init_MEMO(void);\nint DP(int origin, int dest, int VIA);\nint TSP(void);\nint main(void) {\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    printf(\"%d\\n\", TSP());\n    return 0;\n}\nint TSP(void){\n    int i, VIA_init, min = MAX;\n    for(i = 0; i < V; i++){\n        init_MEMO();\n        VIA_init = (1 << V) - 1 & ~(1 << i);\n        int cnd = DP(i, i, VIA_init);\n        if (cnd < min) min = cnd;\n    }\n    if (min >= MAX)\n        return -1;\n    else\n        return min;\n}\nint DP(int origin, int dest, int VIA){ // single source memoization\n    if(VIA == 0){\n        if (A[origin][dest] != -1) return A[origin][dest];\n        else return MAX;\n    }\n    if(VISIT[dest][VIA] == 1) return MEMO[dest][VIA];\n    VISIT[dest][VIA] = 1;\n    int i, min = MAX;\n    for (i = 0; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(origin, i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    MEMO[dest][VIA] = min;\n    return min;\n}\n/*\nint DP(int dest, int VIA){ // single source backward tracking\n    if(VIA == 0) return A[0][dest];\n    int i, min = MAX;\n    for (i = 1; i < V; i++){\n        if (A[i][dest] != -1 && (VIA & (1 << i)) != 0){\n            int cnd = A[i][dest] + DP(i, VIA & ~(1 << i));\n            if (cnd < min) min = cnd;\n        }\n    }\n    return min;\n}*/\nvoid input(void){\n    scanf(\"%d%d\", &V, &E);\n    init_A();\n    int i, s, t, d;\n    for(i = 0; i < E; i++){\n        scanf(\"%d%d%d\", &s, &t, &d);\n        A[s][t] = d;\n    }\n}\nvoid init_A(void){\n    int i, j;\n    for(i = 0; i < V; i++)\n        for(j = 0; j < V; j++) A[i][j] = -1;\n}\nvoid init_MEMO(void){\n    int i, j;\n    for(i = 0; i < V; i++){\n        for(j = 0; j < (1<<V); j++){\n            MEMO[i][j] = 0;\n            VISIT[i][j] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \nint main(){\n  int V,E;\n  cin>>V>>E;\n  int d[15][15];\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      d[i][j]=-1;\n    }\n  }\n  while(E--){\n    int s,t,d_;\n    cin>>s>>t>>d_;\n    d[s][t]=d_;\n  }\n  int dp[1<<15][15];\n  for(int i=0;i<V-1;i++){\n    if(d[V-1][i]>=0){\n      dp[1<<i][i]=d[V-1][i];\n    }else{\n      dp[1<<i][i]=1e9;\n    }\n  }\n  for(int i=0;i<1<<V-1;i++){\n    if(!(i&i-1))continue;\n    for(int j=0;j<V-1;j++){\n      if(!(i>>j&1))continue;\n      dp[i][j]=1e9;\n      int p=i^1<<j;\n      for(int k=0;k<V-1;k++){\n    if(!(p>>k&1)||d[k][j]<0)continue;\n    dp[i][j]=min(dp[i][j],dp[p][k]+d[k][j]);\n      }\n    }\n  }\n  int b=1e9;\n  for(int i=0;i<V-1;i++){\n    if(d[i][V-1]<0)continue;\n    b=min(b,dp[(1<<V-1)-1][i]+d[i][V-1]);\n  }\n  cout<<(b>1e8?-1:b)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint dp[1<<15][15];\nvector<pair<int,int>> ls[15];\nint main(){\n\tint v,e;\tcin>>v>>e;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,d;\tcin>>s>>t>>d;\n\t\tls[s].push_back(make_pair(t,d));\n\t}\n\tfor(int i=0;i<15;i++){\n\t\tfor(int j=0;j<1<<15;j++)\tdp[j][i]=inf;\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<(int)ls[0].size();i++){\n\t\tint to=ls[0][i].first,cost=ls[0][i].second;\n\t\tdp[1<<to][to]=cost;\n\t}\n\tfor(int i=1;i<(1<<v);i++){\n\t\tfor(int j=0;j<v;j++){\n\t\t\tif(dp[i][j]==inf)\tcontinue;\n\t\t\tfor(int k=0;k<(int)ls[j].size();k++){\n\t\t\t\tint to=ls[j][k].first,cost=ls[j][k].second;\n\t\t\t\tif(i&(1<<to))\tcontinue;\n\t\t\t\tdp[i|(1<<to)][to]=min(dp[i|(1<<to)][to],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[(1<<v)-1][0]==inf)\tcout<<-1<<endl;\n\telse \tcout<<dp[(1<<v)-1][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<stdio.h>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n\nusing namespace std;\n\n\nconst int MAX_V=16;\nconst int MAX_E=(1<<MAX_V);\nconst int INF=1<<28;\n\nint V,E;\nint G[MAX_V][MAX_V];\nint dp[MAX_E][MAX_V];\n\nint dfs(int v,int visit){\n\tif(dp[visit][v] != -1) return dp[visit][v];\n\tif(visit == (1<<V)-1) return G[v][0];\n\tdp[visit][v]=INF;\n\trep(i,V){\n\t\tif(visit & (1<<i))continue;//??¢????¨????????????????\n\t\tdp[visit][v] = min(dfs(i,(visit | (1<<i)))+G[v][i],dp[visit][v]);\n\t}\n\n\treturn dp[visit][v];\n}\n\nint main(){\n\tcin >> V >> E;\n\tfill_n((int *)dp,sizeof(dp)/sizeof(int),-1);\n\tfill_n((int *)G,sizeof(G)/sizeof(int),INF);\n\trep(i,E){\n\t\tint s,t,d;\n\t\tcin >> s >> t >> d;\n\t\tG[s][t]=d;\n\t}\n\tint visit=0;\n\tint ans=dfs(0,(visit|1));\n\n\tif(ans==INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"DataStructure.h\"\n#include <map>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <math.h>\n#include <string.h>\nusing namespace std;\nconst int num = 15, num1 = 10000000;\ntypedef long long int ll;\ntypedef pair<int, int> p;\nconst int INF = 20000000;\nint dp[1 << num][num], m[num][num];\nint n, e;\nint solve(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) {\n\t\treturn dp[s][v] = 0;\n\t}\n\tif (dp[s][v] != INF)\n\t\treturn dp[s][v];\n\tint res = INF;\n\tfor (int t = 0; t < n; t++)\n\t\tif (!(s >> t & 1))\n\t\t\tres = min(res, m[v][t] + solve(s | 1 << t, t));\n\treturn dp[s][v] = res;\n}\nint main() {\n\tcin >> n >> e;\n\tfill(m[0], m[num], INF);\n\tfill(dp[0], dp[1 << num], INF);\n\tfor (int i = 0; i < e; i++) {\n\t\tint  s, t, u;\n\t\tcin >> s >> t >> u;\n\t\tm[s][t] = u;\n\t}\n\tif (solve(0, 0) >= INF)\n\t\tcout << -1 << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define inf (pow(10,9))\ntypedef pair<int,int> pii ;\n\nint V = 0 ;\nint E = 0 ;\nvector<pii> graph[20] ; // from,{to,cost}\nint dp[ 1 << 15 ][15] = {0} ;\n\nint DP(int bit ,int v )\n{\n    if(dp[bit][v] != inf)return dp[bit][v];\n\n    if ( bit == (1 << V) - 1 && v == 0 ) return 0 ;\n\n    int res = inf;\n    for( int i = 0; i < graph[v].size(); i++)\n    {\n        pii cmp = graph[v][i] ;\n        if ( !( (bit >> cmp.first) & 1 ) )\n        {\n            res = min( res, DP( bit | ( 1 << cmp.first ), cmp.first ) + cmp.second ) ;\n        }\n    }\n\n    return dp[bit][v] = res ;\n}\n\nint solve()\n{\n    for ( int i = 0 ; i < (1 << V) ; i++ )\n    {\n        for ( int j = 0 ; j < V ; j++ )\n        {\n            dp[i][j] = inf ;\n        }\n    }\n    return DP( 0, 0 ) ;\n}\n\nint main()\n{\n    cin >> V >> E ;\n    for ( int i = 0 ; i < E ; i++ )\n    {\n        int s ,t ,d ;\n        cin >> s >> t >> d ;\n        graph[s].push_back(pii(t,d));\n    }\n    if(solve() != inf)printf(\"%d\\n\", solve()) ;\n    else puts(\"-1\");\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int t,d;\n\t  Edge(int to, int dis){\n\t\t\tt = to; d = dis;\n\t  }\n};\ntypedef long long ll;\ntypedef vector<vector<ll> > Adj_Mat;\n\n\nbool contain(int mask, int pos){\n\t  return ( mask & (1<<pos) ) != 0;\n}\n\nint main(){\n\n\t  // Input Graph\n\t  int V,E;\n\t  cin >> V >> E;\n\n\t  Adj_Mat G(V,vector<ll>(V,INT_MAX));\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t,d; cin >> s >> t >> d;\n\t\t\tG[s][t] = d;\n\t  }\n\n\t  ll ans = INT_MAX;\n\t  // Dynamic Programming for TSP\n\t  for(int st=0; st<V; st++){\n\n\t\t\tll dp[ (1<<V) ][ V ];\n\t\t\tfor(int i=0; i<(1<<V); i++)\n\t\t\t\t  for(int j=0; j<V; j++)\n\t\t\t\t\t\tdp[i][j] = INT_MAX;\n\t\t\tdp[ 0 ][ st ] = 0;\n\n\t\t\tfor(int S=1; S<(1<<V); S++)\n\t\t\t\t  for(int v=0; v<V; v++)\n\t\t\t\t\t\tif( contain(S,v) )\n\t\t\t\t\t\t\t  for(int j=0; j<V; j++)\n\t\t\t\t\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S-(1<<v)][j] + G[j][v]);\n\t\t\tans = min(ans,dp[ (1<<V)-1 ][st]);\n\t  }\n\t  if( ans >= 1e+9 ) ans = -1;\n\t  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint dp[1 << 15][15];\nint n;\nint m[15][15];\n\nint rec(int s,int v){\n  if(dp[s][v]>=0){\n    return dp[s][v];\n  }\n\n  if(s ==((1 << n)-1) && v==0){\n    //printf(\"v=0\\n\");\n\n    return dp[s][v]=0;\n  }\n\n  int res = 1000*15+1;\n\n  for(int u=0;u<n;u++){\n    if((!(s >> u & 1)) && m[v][u]>=0){\n      //printf(\"m:%d\",m[v][u]);\n      res = min(res,rec(s | (1 << u),u)+m[v][u]);\n    } \n  }\n  //printf(\"res=%d\\n\",res);\n  return dp[s][v]=res;\n}\n\nint main(){\n  int v,e;\n  cin >> v >> e;\n  n=v;\n  \n    memset(m,-1,sizeof(m));\n\n\n  int s,t,d;\n  for(int i=0;i<e;i++){\n    cin >> s >> t >> d;\n    m[s][t]=d;\n  }\n  \n  memset(dp,-1,sizeof(dp));\n  int ans=rec(0,0);\n  if(ans==15001){\n    printf(\"%d\\n\",-1);\n  }\n  else{\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string.h>\nusing namespace std;\n\nint V,E;\nint d[15][15] = {0};\nint dp[1 << 15][15] = {0};\nint inf = 1e8;\n\nint rec(int S, int v){\n\tif(dp[S][v]>=0) return dp[S][v];\n\tif(S == (1<<V) -1 && v==0) return (dp[S][v] = 0);\n\tint res = inf;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u & 1)){\n\t\t\tres = min(res, rec(S | 1<<u, u) + d[v][u]);\n\t\t}\n\t}\n\treturn (dp[S][v] = res);\n}\n\nint main(){\n\tcin >> V >> E;\n\tfor(int i=0;i<V;i++){\n\t\tfor(int j=0;j<V;j++){\n\t\t\td[i][j] = inf;\n\t\t}\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\td[a][b] = w;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tint ans = rec(0,0);\n\tif(ans!=inf) cout << ans << endl;\n\telse cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao in 2020.\n//  Copyright © 2020 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao Twitter/QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 10e17\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\nint n;\nint d[20][20];\nint dp[1<<20][20];\nint st[20][20];\nint rec(int S,int v){\n    if(dp[S][v]>=0)return dp[S][v];\n    \n    if(S==(1<<n)-1&&v==0){\n        return dp[S][v]=0;\n    }\n    \n    int res=IINF;\n    for(int u=0;u<n;u++){\n        if(!(S>>u&1)){\n            if(st[v][u]!=IINF)\n                res=mmin(res,rec(S|1<<u,u)+st[v][u]);\n        }\n    }\n    return dp[S][v]=res;\n}\n//---------------------------------------------------------------------------\nint main(){//問題をちゃんと見ろ! llか? 统一类型 memset()! ペナを減らせ!!!!!!!!!!!!!\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    memset(dp,-1,sizeof(dp));\n    cin>>n;\n    int m;cin>>m;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            st[i][j]=IINF;\n        }\n    }\n    for(int i=0;i<m;i++){\n        int s,t,d;cin>>s>>t>>d;\n        //s--;t--;\n        st[s][t]=d;\n        //st[t][s]=d;\n    }\n    int ans=rec(0,0);\n    if(ans==IINF)ans=-1;\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 18\n#define INF 1000000000\nint N, M, a, b, c, x[MAX_N][MAX_N];\nint dp[MAX_N][1 << MAX_N];\n\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) { x[i][j] = INF; }\n\t\tfor (int j = 0; j < (1 << MAX_N); j++) { dp[i][j] = INF; }\n\t\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b >> c;\n\t\tx[a][b] = c;\n\t\tx[b][a] = c;\n\t}\n\tdp[0][1] = 0;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (dp[j][i] < INF) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint dist1 = dp[j][i] + x[j][k];\n\t\t\t\t\t\tint pos = i + (1 << k);\n\t\t\t\t\t\tif (dp[k][pos] > dist1) {\n\t\t\t\t\t\t\tdp[k][pos] = dist1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tmaxn = min(dp[i][(1 << N) - 1] + x[0][i], maxn);\n\t}\n\tif (maxn == INF) { maxn = -1; }\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst double EPS = 1e-8;\n\ntemplate<typename T> T chmax(T& a, const T& b){return a = (a > b ? a : b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = (a < b ? a : b);}\n\nll dp[1<<15][15][15];\n\nvector<vector<pii>> es;\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    es.resize(n);\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        es[a].pb({b, c});\n    }\n    rep(i, 1<<n) rep(j, n) rep(k, n) dp[i][j][k] = INF;\n    rep(i, n) dp[1<<i][i][i] = 0; \n    rep(mask, 1<< n) rep(i, n) rep(j, n) if(dp[mask][i][j] != INF) {\n        for(auto&& k: es[j]) if(!(mask&(1<<k.fi))) {\n            chmin(dp[mask|(1<<k.fi)][i][k.fi], dp[mask][i][j]+k.se);\n        }\n    }\n    ll ans = INF;\n    rep(mask, 1<<n) rep(cur, n) for(auto&& s : es[cur]) chmin(ans, dp[(1<<n)-1][s.fi][cur] + s.se);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = max(res, v);\n    }\n    return res;\n}\nint min(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = min(res, v);\n    }\n    return res;\n}\nint N, M, H, W;\nvi A, B, C;\n//21:40\n\nsigned main() {\n    in(N, M);\n    vvi(g, N);\n    vvi(c, N);\n    rep(i, M) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        g[u] += v;\n        c[u] += d;\n    }\n    int mi = linf;\n    //0スタート\n    vvi (dp, bit(16), N, linf);\n    dp[bit(0)][0] = 0;\n    rep(mas, bit(N)) {\n        rep(i, N) {\n            rep(gi, sz(g[i])) {\n                int t = g[i][gi];\n                int co = c[i][gi];\n                int sco = dp[mas][i] + co;\n                //goal\n                if (mas == bit(N) - 1 && t == 0) {\n                    chmi(mi, sco);\n                } else if ((mas & bit(t)) == 0) {\n                    chmi(dp[mas | bit(t)][t], sco);\n                }\n            }\n        }\n    }\n//    deb(dp);\n    if (mi == linf) {\n        mi = -1;\n    }\n    cout << mi << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    int s,t,d;\n    int inf = 1<<30;\n    int mat[17][17]={};\n    REP(i,17)REP(j,17)mat[i][j]=-1;\n    REP(i,e){\n        cin>>s>>t>>d;\n        mat[s][t]=d;\n    }\n    int dp[1<<18][17]={};\n    REP(i,1<<18)REP(j,17)dp[i][j]=inf;\n    dp[0][0]=0;\n    for(int i=0; i< (1<<v); i++){\n        for(int from=0; from<v; from++){\n            for(int to=0; to<v; to++){\n                if((i & 1<<to)==0 && mat[from][to]!=-1){\n                    dp[i | 1<<to][to] = min(dp[i | 1<<to][to], dp[i][from]+mat[from][to]);\n                }\n            }\n        }\n    }\n    if(dp[(1<<v)-1][0] == inf)cout<<\"-1\"<<endl;\n    else cout<<dp[(1<<v)-1][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <ctime>\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXISTch(s,c) ((((s).find_first_of(c)) != std::string::npos)? 1 : 0)//cがあれば1 if(1)\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define loop(n) FOR(i,0,n)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = (int)1000000007;\nconst LL MOD = (LL)1000000007;//10^9+7\nconst LL INF2 = (LL)100000000000000000;//10^18\n\nint main() {\n\tint V, E; cin >> V >> E;\n\n\tvector<vector<int>> adj(V, vector<int>(V));\n\n\tfor (int e = 0; e < E; e++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\n\t\tadj[s][t] = d;\n\t}\n\t\t\t\n\t\n\t//dp[既に訪れた部分集合][最後に訪れた頂点]のときの最短距離\n\t//dp[S][v]\n\tvector<vector<int>> dp(1 << V, vector<int>(V));\n\t\n\t//dp初期化\n\tfor (int i = 0; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\t//頂点0から出発。\n\t//部分集合としては0…0001\n\t//最後に訪れたのは頂点0で頂点0からの距離は0\n\tdp[1][0] = 0;\n\n\tfor (int s = 0; s < (1 << V); s++) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (dp[s][v] == INF)continue;\n\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (s >> k & 1)continue;\n\t\t\t\tint nexts = s | (1<<k);\n\n\t\t\t\tif (adj[v][k] != 0) {\n\t\t\t\t\tdp[nexts][k] = min(dp[nexts][k], dp[s][v] + adj[v][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tint all = (1 << V) - 1;\n\tint ans = INF;\n\tfor (int v = 0; v < V; v++) {\n\t\tif (dp[all][v] == INF)continue;\n\t\tif (adj[v][0] == 0)continue;\n\n\t\tans = min(ans, dp[all][v] + adj[v][0]);\n\t}\n\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n#include <limits.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INF = INT_MAX / 4;\n\n// vector<vector<struct Edge>> edges;\nvector<vector<int>> edges;\nvector<vector<int>> dp;\n\nint solve(const int bits, const int g, const int V, const int E) {\n    if (dp[bits][g] < INF) {\n        return dp[bits][g];\n    }\n    // printf(\"bits: 0x%x, g: %d\\n\", bits, g);\n\n    assert(bits & 1);\n    assert(bits & (1 << g));\n\n    for (int i = 1; i < V; i++) {\n        if (i == g) continue;\n        if ((bits & (1 << i)) == 0) continue;\n        if (edges[i][g] == INF) continue;\n        int new_bits = bits & (~(1 << g));\n        int res = solve(new_bits, i, V, E) + edges[i][g];\n        // printf(\"bits: 0x%x, g: %d, i: %d, res: %d\\n\", bits, g, i, res);\n        chmin(dp[bits][g], res);\n    }\n\n    return dp[bits][g];\n}\n\nint main(void) {\n    int V, E;\n    cin >> V >> E;\n\n    edges.resize(V, vector<int>(V, INF));\n    for (int i = 0; i < E; i++) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        edges[s][t] = d;\n    }\n    for (int i = 0; i < V; i++) {\n        edges[i][i] = 0;\n    }\n\n    // assume that start vertex is 0.\n    dp.resize(1 << V, vector<int>(V, INF));\n    for (int i = 0; i < V; i++) {\n        dp[1 | (1 << i)][i] = edges[0][i];\n    }\n\n    int ans = INF;\n    for (int i = 1; i < V; i++) {\n        int res = solve(((1 << V) - 1), i, V, E);\n        chmin(ans, res + edges[i][0]);\n    }\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_V 15\n#define INF INT_MAX / 2\n\nint V;\nint d[MAX_V][MAX_V];\n\nint dp[1 << MAX_V][MAX_V];\n\nint rec(int S, int v) {\n\tif (dp[S][v] >= 0) {\n\t\treturn dp[S][v];\n\t}\n\n\tif (S == (1 << V) - 1 && v == 0) {\n\t\treturn dp[S][v] = 0;\n\t}\n\n\tint res = INF;\n\tfor (int u = 0; u < V; u++) {\n\t\tif (!(S >> u & 1)) {\n\t\t\tres = min(res, rec(S | 1 << u, u) + d[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nvoid solve() {\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = rec(0, 0);\n\tif (ans == INF)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << ans << endl;\n}\n\nvoid solve2() {\n\tfor (int S = 0; S < 1 << V; S++)\n\t\tfill_n(dp[S], V, INF);\n\tdp[(1 << V) - 1][0] = 0;\n\n\tfor (int S = (1 << V) - 2; S >= 0; S--) {\n\t\tfor (int v = 0; v < V; v++)\n\t\t\tfor (int u = 0; u < V; u++)\n\t\t\t\tif (!(S >> u & 1))\n\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n\t}\n\tcout << dp[0][0] << endl;\n}\n\nint main() {\n\tint E;\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; i++)\n\t\tfor (int j = 0; j < V; j++)\n\t\t\td[i][j] = d[j][i] = INF;\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, dd;\n\t\tcin >> s >> t >> dd;\n\t\td[s][t] = dd;\n\t}\n\tsolve();\n//\tsolve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = ((B)-1); I >= (A); --I)\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;else return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n,m;\n\tcin >> n >> m;\n\tll dp[(1<<n)][n];\n\tll d[n][n];\n\tFOR(i,0,n)FOR(j,0,n)d[i][j]=INF;\n\tFOR(i,0,m){\n\t\tll a,b,c;\n\t\tcin >> a >> b >> c;\n\t\td[a][b]  = c;\n\t}\n\tFOR(i,0,(1<<n))\n\t\tFOR(j,0,n)\n\t\t\tdp[i][j]=INF;\n\tdp[(1<<n)-1][0] = 0;\n\tFORR(S,0,(1<<n)-1){\n\t\tFOR(v,0,n){\n\t\t\tFOR(u,0,n){\n\t\t\t\tif(!(S>>u&1))\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[u][v]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]<INF)cout << dp[0][0] << endl;\n\telse cout << \"-1\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <vector>\n\nint dfs(int visited, int v,\n        const std::vector<std::vector<std::pair<int, int>>> &redges,\n        std::map<std::pair<int, int>, int> &dp,\n        int ans, int acc) {\n  auto it = dp.find(std::make_pair(visited, v));\n  if (it != dp.end()) {\n    return it->second;\n  }\n  int cost = -1;\n  for (auto edge : redges[v]) {\n    if (!(visited & (1 << edge.first))) {\n      continue;\n    }\n    int tmp = dfs(visited - (1 << v),\n                  edge.first,\n                  redges, dp, ans, acc + edge.second);\n    if (tmp == -1) {\n      continue;\n    }\n    tmp += edge.second;\n    if (cost == -1 || cost > tmp) {\n      cost = tmp;\n    }\n  }\n  dp[std::make_pair(visited, v)] = cost;\n  return cost;\n}\n\nint main() {\n  int V, E;\n  std::cin >> V >> E;\n  std::vector<std::vector<std::pair<int, int>>> redges(V);\n  for (int i = 0; i < E; i++) {\n    int fr, to, weight;\n    std::cin >> fr >> to >> weight;\n    redges[to].push_back(std::make_pair(fr, weight));\n  }\n  int all_visited = (1<<V) - 1;\n\n  int ans = -1;\n  for (int start = 0; start < 1; start++) {\n    std::map<std::pair<int, int>, int> dp;\n    dp[std::make_pair(1<<start, start)] = 0;\n    for (auto edge : redges[start]) {\n      int cost = dfs(all_visited, edge.first, redges, dp, ans, edge.second);\n      if (cost == -1) {\n        continue;\n      }\n      cost += edge.second;\n      if (ans == -1 || ans > cost) {\n        ans = cost;\n      }\n    }\n  }\n  std::cout << ans << std::endl;                                                                                                                                                                                                              \n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define FORR(i, a, b) for (int i = b - 1; i >= a; --i)\n#define SORT(v) sort(v.begin(), v.end())\n#define SORTR(v) sort(v.rbegin(), v.rend())\n#define REV(v) reverse(v.begin(), v.end())\n#define ITER(itr, v) for (auto itr = v.begin(); itr != v.end(); ++itr)\n#define LB(v, x) (lower_bound(v.begin(), v.end(), x) - v.begin())\n#define UB(v, x) (upper_bound(v.begin(), v.end(), x) - v.begin())\n#define SZ(v) (int)v.size()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int INF = 100000;\nclass Graph {\n\tint N;\n\tvector<vector<P>> edge;\n\tvector<vector<int>> dp;\n\npublic:\n\tGraph(int N) : N(N), edge(N), dp(1 << N, vector<int>(N, -1)) {}\n\tvoid add(int s, int t, int d) {\n\t\tedge[s].emplace_back(t, d);\n\t}\n\tint ans(int st = 0, int now = 0) {\n\t\tif (dp[st][now] >= 0) {\n\t\t\treturn dp[st][now];\n\t\t}\n\t\tif (st == (1 << N) - 1 && now == 0) {\n\t\t\treturn dp[st][now] = 0;\n\t\t}\n\t\tint res = INF;\n\t\tfor (auto &p : edge[now]) {\n\t\t\tint to, d;\n\t\t\ttie(to, d) = p;\n\t\t\tif (!(st >> to & 1)) {\n\t\t\t\tres = min(res, ans(st | (1 << to), to) + d);\n\t\t\t}\n\t\t}\n\t\treturn dp[st][now] = res;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E;\n\tcin >> V >> E;\n\tGraph graph(V);\n\tREP(i, E) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tgraph.add(s, t, d);\n\t}\n\tint res = graph.ans();\n\tif (res == INF) res = -1;\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <windows.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\ntypedef vector<vector<pair<int, int> > > vvp;\ntypedef vector<pair<int, int> > vp;\ntypedef vector<vector<int> > vvi;\ntypedef vector<int> vi;\ntypedef vector<vector<ll> > vvl;\ntypedef vector<ll> vl;\ntypedef vector<vector<double> > vvd;\ntypedef vector<double> vd;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef pair<string, int> psi;\ntypedef pair<int, int> pii;\n//#define unix ((unsigned int)time(NULL))\n#define rep(i,s,n) for(int i = (s); i < (n); i++)\n#define inputv(v) for(int i = 0; i < (v.size()); i++)cin>>v[i];\n#define inputvv(v) for(int i = 0; i < (v.size()); i++)for(int j=0;j<(v[0].size());j++)cin>>v[i][j];\n#define all(x) (x).begin(), (x).end()\n#define yn(f) (f?\"yes\":\"no\")\n#define YN(f) (f?\"YES\":\"NO\")\n#define Yn(f) (f?\"Yes\":\"No\")\n#define inf (100000007)\n#define ll_inf (1000000000000000000)\n#define nil -1\n\nvoid puts() {\n\tcout << endl;\n}\ntemplate <class T>\nvoid puts(T a) {\n\tcout<<(a)<<endl;\n}\n/*\ntemplate <class Head, class... Tail>\nvoid puts(Head&& head, Tail&& ... tail) {\n\tcout << head;\n\tif (sizeof...(tail) == 0) {\n\t\tputs();\n\t}\n\telse {\n\t\tcout << \" \";\n\t\tputs(forward<Tail>(tail)...);\n\t}\n\n}\n*/\nvoid puts(pair<int, int> A) {\n\tcout << \"(\" << A.first << \",\" << A.second << \")\" << endl;;\n}\nvoid puts(vector<pair<int,int> >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tcout <<\"(\"<< A[i].first<<\",\"<<A[i].second<<\")\";\n\t\tif (A.size() - 1 == i) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\nvoid puts(vector<vector<pair<int,int> > >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tputs(A[i]);\n\t}\n}\ntemplate <class T>\nvoid puts(vector<T>& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tcout << A[i];\n\t\tif (A.size() - 1 == i) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n}\ntemplate<class T>\nvoid puts(vector<vector<T> >& A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t{\n\t\tputs(A[i]);\n\t}\n}\nclass disjoint_set {\npublic:\n\tvi p, rank;\n\tdisjoint_set(int size) {\n\t\tp.resize(size, 0);\n\t\trank.resize(size, 0);\n\t\tfor (int i = 0; i < size; i++)makeSet(i);\n\t}\n\tvoid makeSet(int x) {\n\t\tp[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y) {\n\t\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tlink(findSet(x), findSet(y));\n\t}\n\tvoid link(int x, int y) {\n\t\tif (rank[x] < rank[y]) {\n\t\t\tp[x] = y;\n\t\t}\n\t\telse {\n\t\t\tp[y] = x;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tint findSet(int x) {\n\t\tif (x != p[x]) {\n\t\t\tp[x] = findSet(p[x]);\n\t\t}\n\t\treturn p[x];\n\t}\n};\nclass rmq {\npublic:\n\tint n,inf_,max_n;\n\tvi A;\n\trmq(int n_) {\n\t\tn = 1;\n\t\tinf_ = INT_MAX;\n\t\tmax_n = (1 << 18);\n\t\twhile (n < n_)n *= 2;\n\t\tA.resize(max_n*2-1);\n\t\tfor (int i = 0; i < n * 2 - 1; i++)A[i] = inf_;\n\t}\n\tvoid update(int i,int x) {\n\t\ti += n - 1;\n\t\tA[i] = x;\n\t\twhile (i>0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tA[i] = min(A[i*2+1],A[i*2+2]);\n\t\t}\n\t}\n\tint query(int left, int right, int i = 0, int left2 = 0, int right2 = -1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tif (right2 <= left || right <= left2) {\n\t\t\treturn inf_;\n\t\t}\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\treturn A[i];\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2 + right2) / 2;\n\t\t\treturn min(query(left, right, i * 2 + 1, left2, mid), query(left, right, i * 2 + 2, mid, right2));\n\t\t}\n\t}\n};\nclass rsq {//遅延セグ木\npublic:\n\tint n, max_n;\n\tvl A,Lazy;\n\trsq(int n_) {\n\t\tn = 1;\n\t\tmax_n = (1<<18);\n\t\twhile (n < n_)n *= 2;\n\t\tA.resize(max_n * 2 - 1);\n\t\tLazy.resize(max_n * 2 - 1);\n\t}\n\tvoid propagate(int i,int left,int right) {\n\t\tif (Lazy[i] != 0) {\n\t\t\tA[i] += Lazy[i];\n\t\t\tif (right-left>1) {\n\t\t\t\tLazy[i * 2 + 1] += Lazy[i] / 2;\n\t\t\t\tLazy[i * 2 + 2] += Lazy[i] / 2;\n\t\t\t}\n\t\t\tLazy[i] = 0;\n\t\t}\n\t}\n\tvoid add(int left, int right, int x, int i = 0,int left2=0,int right2=-1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tpropagate(i,left2,right2);\n\t\tif (right <= left2 || right2 <= left) return;\n\t\t\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\tLazy[i] += (right2-left2) * x;\n\t\t\tpropagate(i,left2,right2);\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2+right2) / 2;\n\t\t\tadd(left,right,x,i*2+1,left2,mid);\n\t\t\tadd(left,right,x,i*2+2,mid,right2);\n\t\t\tA[i]=A[i*2+1]+A[i*2+2];\n\t\t}\n\t\t\n\t}\n\tll sum(int left, int right, int i=0, int left2=0, int right2=-1) {\n\t\tif (right2 == -1)right2 = n;\n\t\tif (right2 <= left || right <= left2) return 0;\n\t\tpropagate(i, left2, right2);\n\t\tif (left <= left2 && right2 <= right) {\n\t\t\treturn A[i];\n\t\t}\n\t\telse {\n\t\t\tint mid = (left2 + right2) / 2;\n\t\t\tll res = 0;\n\t\t\tres += sum(left, right, i * 2 + 1, left2, mid);\n\t\t\tres+=sum(left, right, i * 2 + 2, mid, right2);\n\t\t\treturn res;\n\t\t}\n\t}\n};\nclass binary_indexed_tree {//1-indexed\npublic:\n\tint n;\n\tvl A;\n\tbinary_indexed_tree(int n_) {\n\t\tn = n_;\n\t\tA.resize(n +1);//1-indexed\n\t}\n\tll sum(int i) {//[0,i]の和を返す\n\t\tll res = 0;\n\t\twhile (i>0) {\n\t\t\tres += A[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn res;\n\t}\n\tvoid add(int i,int x) {\n\t\twhile (0<i&&i<=n) {\n\t\t\tA[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\nvoid dedupe(vi& A) {\n\tsort(A.begin(),A.end());\n\tA.erase(unique(A.begin(),A.end()),A.end());\n}\nint gcd(int a, int b) {//log N\n\treturn (b == 0) ? a : gcd(b, a % b);\n}\nll gcd(ll a, ll b) {//log N\n\treturn (b == 0) ? a : gcd(b, a % b);\n}\nint lcm(int a, int b) {//log N\n\treturn (a * b) / gcd(a, b);\n}\nll lcm(ll a, ll b) {//log N\n\treturn (a * b) / gcd(a, b);\n}\nint extgcd(int a, int b, int& x, int& y) {// log N\n\tint d = a;\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\telse {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n\treturn d;\n}\nvi get_primes(int limit) {//N log N\n\tvb A(limit + 1, true);\n\tfor (int i = 2; i < A.size(); i++) {\n\t\tif (!A[i])continue;\n\t\tfor (int j = i * 2; j < A.size(); j += i)A[j] = false;\n\t}\n\tvi B;\n\tfor (int i = 2; i < A.size(); i++)\n\t{\n\t\tif (A[i])B.push_back(i);\n\t}\n\treturn B;\n}\ntemplate <class T>\nbool is_prime(T num) {// sqrt(N)\n\tif (num < 2)return false;\n\tfor (ll i = 2; i <= sqrt(num); i++)\n\t{\n\t\tif (num % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nll merge_count(vi & A) {//N log N\n\tint n = A.size();\n\tif (n <= 1)return 0;\n\tlong long count = 0;\n\tint mid = n / 2;\n\tvector<int> B(A.begin(), A.begin() + mid);\n\tvector<int> C(A.begin() + mid, A.end());\n\tcount += merge_count(B);\n\tcount += merge_count(C);\n\tB.push_back(inf);\n\tC.push_back(inf);\n\tint B_i = 0;\n\tint C_i = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (B[B_i] <= C[C_i]) {\n\t\t\tA[i] = B[B_i++];\n\t\t}\n\t\telse {\n\t\t\tcount += (n / 2) - B_i;\n\t\t\tA[i] = C[C_i++];\n\t\t}\n\t}\n\treturn count;\n}\nvi bit(int size,int num) {\n\tvi A;\n\tfor (int j = 0; j < size; j++)\n\t{\n\t\tif ((num & (1 << (size - j - 1))) > 0) {\n\t\t\tA.push_back(1);\n\t\t}\n\t\telse {\n\t\t\tA.push_back(0);\n\t\t}\n\t}\n\treturn A;\n}\nvvi bit_z(int size) {//2**N\n\tvvi A;\n\tfor (int i = 0; i < (1<<size); i++)\n\t{\n\t\tvi temp = bit(size,i);\n\t\tA.push_back(temp);\n\t}\n\treturn A;\n}\nvvi bit_z(int size, int n) {\n\tvvi A;\n\tint s = (1<<n)-1;\n\tA.push_back(bit(size,s));\n\twhile (true) {\n\t\tint x = s & (-s);\n\t\tint y = s + x;\n\t\tint z = s & (~y);\n\t\t\n\t\tz /= x;\n\t\tz = z >> 1;\n\t\ts = (y | z);\n\t\tif (s >= (1 << size))break;\n\t\tA.push_back(bit(size,s));\n\t}\n\treturn A;\n}\nvvi bit_z(int size,int min,int max) {\n\tvvi A;\n\tfor (int i = min; i <=max; i++)\n\t{\n\t\tvvi B = bit_z(size,i);\n\t\tA.insert(A.end(),B.begin(),B.end());\n\t}\n\treturn A;\n}\nint random(int min,int max) {\n\tint r = rand() % (max+1-min)+min;\n\treturn r;\n}\nvector< pair < ll, int > > factorize(ll n) {\n\tll count = 0;\n\tvector< pair< ll , int > > res;\n\tfor (ll i  = 2; i*i <= n; i++)\n\t{\n\t\tif (n % i )continue;\n\t\tres.push_back(make_pair(i,0));\n\t\twhile (n%i==0) {\n\t\t\tn /= i;\n\t\t\tres.back().second++;\n\t\t}\n\t}\n\tif (n != 1)res.push_back(make_pair(n,1));\n\treturn res;\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tint e; cin >> e;\n\tvvi G(n, vi(n, inf));\n\trep(i, 0, e) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvvi dp(1<<n, vi(n, inf));\n\tint ans = inf;\n\tfor (int goal = 0; goal < n; goal++)//ゴール n\n\t{\n\t\trep(i, 0, 1<<n) {\n\t\t\trep(j, 0, n) {\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[(1 << n) - 1][goal] = 0;\n\t\tfor (int s = (1<<n)-2; s>=0;s--)//集合 2**n\n\t\t{\n\t\t\tfor (int start = 0; start < n; start++)//n\n\t\t\t{\n\t\t\t\tfor (int u = 0; u < n; u++)//n\n\t\t\t\t{\n\t\t\t\t\tif (s>>u&1)continue;\n\t\t\t\t\tdp[s][start] = min(dp[s][start],dp[s|(1<<u)][u]+G[start][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(dp[0][goal],ans);\n\t\t//break;\n\t}\n\tputs(ans==inf?-1:ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint v, n, dis[15][15];\nint dp[(1 << 15)][15];\nconst int INF = 100000000;\n\nint main() {\n\tcin >> v >> n;\n\tfor (int i = 0; i < v; i++)for (int j = 0; j < v; j++)dis[i][j] = INF;\n\tfor (int i = 0; i < (1 << v); i++)for (int j = 0; j < v; j++)dp[i][j] = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdis[a][b] = c;\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << v) - 1; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (i && !(i & (1 << j)))continue;\n\t\t\tfor (int k = 0; k < v; k++) {\n\t\t\t\tif (j == k)continue;\n\t\t\t\tif (!(i & (1 << k))) {\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dis[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << v) - 1][0] == INF)cout << -1 << endl;\n\telse cout << dp[(1 << v) - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nclass edge{\n\tpublic:\n\tint t,d;\n\tedge(int it,int id){\n\t\tt=it;\td=id;\n\t}\n};\nvector<edge> e[20];\nll dp[16][1<<16];\nint main(){\n\tint n,m;\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint s,t,d;\tcin>>s>>t>>d;\n\t\te[s].push_back(edge(t,d));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=(1<<n)-1;j>=0;j--){\n\t\t\tdp[i][j]=2e14;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<(1<<n)-1;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(dp[j][i]==2e14)\tcontinue;\n\t\t\tfor(int k=0;k<(int)e[j].size();k++){\n\t\t\t\tint next=i|(1<<e[j][k].t);\n\t\t\t\tif(next==i)\tcontinue;\n\t\t\t\tif(dp[e[j][k].t][next]>dp[j][i]+e[j][k].d){\n\t\t\t\t\tdp[e[j][k].t][next]=dp[j][i]+e[j][k].d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][(1<<n)-1]==2e14){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tcout<<dp[0][(1<<n)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef _DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...)\n#endif\n#define REP(i, m, n) for(int (i) = (int)(m); (i) < (int)(n); ++(i))\n#define rep(i, n) REP(i, 0, n)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1e9 + 7;\nconst ll LINF = 1LL << 60;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if(a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if(a > b) { a = b; return true; } return false; }\n\nint dp[1<<15][15];\nvector<vector<int>> g;\nint V, E;\n\nint dst(int s) {\n  int res = INF;\n  rep(S,1<<15) rep(i,15) dp[S][i] = INF;\n  dp[1<<s][s] = 0;\n  rep(S,1<<V) rep(i,V) {\n    if(dp[S][i] == INF) continue;\n    rep(j,V) {\n      if(S>>j&1) continue;\n      int nS = S | 1<<j;\n      int nd = dp[S][i]+g[i][j];\n      chmin(dp[nS][j], nd);\n    }\n  }\n  rep(i,V) {\n    if(dp[(1<<V)-1][i] == INF) continue;\n    chmin(res, dp[(1<<V)-1][i]+g[i][s]);\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  cin >> V >> E;\n  g.assign(V, vector<int>(V, INF));\n  rep(i,E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g[s][t] = d;\n  }\n\n  int ans = INF;\n  rep(i,V) {\n    chmin(ans, dst(i));\n  }\n  if(ans == INF) ans = -1;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct ed{\n    short t;\n    short pos;\n    vector<bool>exp;\n};\n\nint main(){\n\n    short V,E;\n    bool flag = false,tflag=false;\n    queue< struct ed > st;\n    vector<short> ex;\n    cin >> V >> E;\n    vector< vector<short> > v(V,vector<short>(V));\n    vector<short> temp(V);\n    fill(temp.begin(),temp.end(),-1);\n    fill(v.begin(),v.end(),temp);\n    short s,t;\n    for(short i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(short i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    short pre,res = 1<<13;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\ttflag = false;\n\te = st.front();\n\tst.pop();\n\tfor(short i=0;i<V;i++){\n\t    if(v[e.pos][i] != -1 && !e.exp[i]){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = true;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    tflag = true;\n\t\t    for(short j=0;j<V;j++){\n\t\t\t//cout <<\"exp = \"<<e.exp[j]<<endl;\n\t\t\tif(e.exp[j] == 0){\n\t\t\t    tflag = false;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif(tflag){\n\t\t    res = min(res,e.t);\n\t\t    flag = true;\n\t\t}else{\n\t\t    st.push(e);\n\t\t}\n\t\te.pos = pre;\n\t\te.exp[i] = false;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n    }\n\n    if(!flag) res = -1;\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nconst int INF = (int)1e7;\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  vector<vector<int>> dp(1 << V, vector<int>(V, INF)), D(V, vector<int>(V, INF));\n\n  REP(i, E) {\n    int s, t, d; cin >> s >> t >> d;\n    D[s][t] = d;\n  }\n\n  dp[0][0] = 0;\n  for (int state = 0; state < (1 << V); state++) {\n    REP(i, V) REP(j, V) if (not (state >> j & 1) and dp[state | (1 << j)][j] > dp[state][i] + D[i][j]) {\n      dp[state | (1 << j)][j] = dp[state][i] + D[i][j];\n    }\n  }\n\n  cout << (dp[(1 << V) - 1][0] == INF ? -1 : dp[(1 << V) - 1][0]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tadd_arc(g, a, b, w);\n\tadd_arc(g, b, a, w);\n}\n\n//??????????????????????????????\n//???????????????????????????????????????????????????1???????????????????????????????????????\nvoid traveling_salesman_problem() {\n\tstatic const int MAX_V = 15;\n\tstatic int dp[1 << MAX_V][MAX_V];\n\tstatic int g[MAX_V][MAX_V]; //Matrix g(V, Array(V, INF));\n\tmemset(dp, 0x3f, sizeof(dp));\n\tmemset(g, 0x3f, sizeof(dp));\n\tint V, E; cin >> V >> E;\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tg[s][t] = d;\n\t}\n\tdp[0][0] = 0;\n\tfor (int mask = 0; mask < (1 << V); mask++) {\n\t\trep(i, 0, V) {\n\t\t\trep(j, 0, V) {\n\t\t\t\tif (mask >> j & 1)continue;\n\t\t\t\tif (dp[mask][i] == INF || g[i][j] == INF)continue;\n\t\t\t\tchmin(dp[mask | (1 << j)][j], dp[mask][i] + g[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[(1 << V) - 1][0] == INF ? -1 : dp[(1 << V) - 1][0]) << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\ttraveling_salesman_problem();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define ALL(x) x.begin(),x.end()\nint MOD=1000000007;\nint inf=1e9+7;\nsigned main(){\n    int n,m;cin>>n>>m;\n    vector<vector<int>> a(n,vector<int>(n+1,inf));\n    rep(i,m){\n        int s,t,d;cin>>s>>t>>d;\n        a[s][t]=d;\n        //a[t][s]=d;\n    }\n    int res=inf;\n    rep(x,n){\n        vector<vector<int>> dp(n,vector<int>((1<<n),inf));\n        dp[x][(1<<x)]=0;\n        rep(j,(1<<n)){\n            rep(i,n){\n                if(j&(1<<i)){\n                    rep(k,n){\n                        if(j&(1<<k))continue;\n                        dp[k][j+(1<<k)]=min(dp[k][j+(1<<k)],dp[i][j]+a[k][i]);\n                    }\n                }\n            }\n        }\n        int buf=inf;\n        rep(y,n){\n            if(y==x)continue;\n            buf=min(dp[y][(1<<n)-1]+a[x][y],buf);\n        }\n        res=min(buf,res);\n    }\n    if(res==inf)res=-1;\n    cout<<res<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nmain(){\n  int v,e;\n  cin>>v>>e;\n  WG<int> es(v);\n  vector<vector<int>> dp((1<<v),vector<int>(v,INF));\n  vector<int> cost(v,INF);\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s].PB(edge<int>(t,d));\n    if(t==0){\n      cost[s]=min(cost[t],d);\n    }\n  }\n  dp[1][0]=0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==inf) continue;\n      for(auto et:es[j]){\n        if(i&(1<<et.to)) continue;\n        dp[i|(1<<et.to)][et.to]=min(dp[i|(1<<et.to)][et.to],dp[i][j]+et.cost);\n      }\n    }\n  }\n\n  int ans=INF;\n  rep(i,v){\n    if(dp[(1<<v)-1][i]!=INF&&cost[i]!=INF)\n      ans=min(ans,dp[(1<<v)-1][i]+cost[i]);\n    }\n\n  cout<<((ans==INF)?-1:ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)     (a).begin(),(a).end()\n#define VI         vector<int>\n#define MOD 1000000007\n\nusing ll = long long int;\nusing P = pair<int,int>;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n//const ll INF=(ll)1e19;\nconst int INF=(1<<30);\n\nint n,m;\nint edge[15][15];\nint dp[(1<<15)][15];\n\nint dfs(int S, int v){\n//  printf(\"%d %d\\n\", S, v);\n  if(dp[S][v]>=0)return dp[S][v];\n\n  if(S==((1<<n)-1) && v == 0)return dp[S][v] = 0;\n\n  int tmp = INF;\n  REP(i,n){\n    if(edge[v][i]==INF)continue;\n\n    if(!((S>>i) & 1)){\n      chmin(tmp, dfs(S | (1<<i), i) + edge[v][i]);\n    }\n\n  }\n//  cout << tmp << endl;\n  return dp[S][v] = tmp;\n}\n\nint main(){\n  cin >> n >> m;\n  REP(i,15)REP(j,15)edge[i][j]=INF;\n  REP(i,(1<<n))REP(j,n)dp[i][j]=-1;\n\n  REP(i,m){\n    int s,t,d;\n    cin >> s >> t >> d;\n    edge[s][t] = d;\n  }\n\n  int ans = dfs(0,0);\n  cout << (ans == INF ? -1 : ans) << endl;\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define LD long double\n#define ST string\n#define BS bitset\n#define PA pair<LL,LL>\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define BPL __builtin_popcountll\n#define FOR(i,a,n) for(i=a;i<n;++i)\n#define FORR(i,a,n) for(i=n-1;i>=a;--i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) FORR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define UBn(a,n) upper_bound(ALL(a),n)-a.begin()\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define LBn(a,n) lower_bound(ALL(a),n)-a.begin()\n#define INF 1145141919810364364LL\n#define PI 3.14159265358979\n#define MOD 1000000007\n//#define MOD 998244353\n#define ERR 0.00000001\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL dig(LL n){LL ret=0;while(n)n/=10,ret++;return ret;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nint lcmp(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return 1;if(*(LL*)a<*(LL*)b)return -1;return 0;}\nint lcmpr(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return -1;if(*(LL*)a<*(LL*)b)return 1;return 0;}\nint ccmp(const void* a,const void* b){return *(char*)a-*(char*)b;}\nint ccmpr(const void* a,const void* b){return *(char*)b-*(char*)a;}\nint scmp(const void* a,const void* b){return strcmp((char*)a,(char*)b);}\nint scmpr(const void* a,const void* b){return strcmp((char*)b,(char*)a);}\nLL cmod(LL a,LL m){if(a%m<0)return a%m+abs(m);else return a%m;}\nLL DIV(LL a,LL d,LL m){LL l=m,x=1,y=0,k;while(l){k=d/l;d-=k*l;swap(l,d);x-=k*y;swap(x,y);}return cmod(a*cmod(x,m),m);}\nLL POW(LL a,LL n,LL m){LL ans=1;while(n>0){if(n&1)ans=ans*a%m;a=a*a%m;n>>=1;}return ans;}\nVL fact,finv,inv;\nvoid comi(LL n){LL i;fact.resize(max(2LL,n+1));finv.resize(max(2LL,n+1));inv.resize(max(2LL,n+1));fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,n+1){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\ntemplate<typename T>bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\nstruct TSP{\n\tLL inf=100000000000;VVL dp,g;\n\tTSP(LL n){LL i;g.resize(n);rep(i,n)g[i].resize(n,inf);}\n\tvoid add(LL s,LL e,LL c){g[s][e]=c;}\n\tLL cost(){LL i,n=g.size(),k=1LL<<n,ret;dp.resize(k);rep(i,k)dp[i].resize(n,-1);rep(i,n)dp[0][i]=inf;dp[0][0]=0;ret=rec(k-1,0);if(ret<inf)return ret;return -1;}\n\tLL rec(LL b,LL n){LL i,k=b^(1LL<<n);if(dp[b][n]>=0)return dp[b][n];if((b&(1LL<<n))==0)return inf;dp[b][n]=inf;rep(i,g.size())chmin(dp[b][n],rec(k,i)+g[i][n]);return dp[b][n];}\n};\n\nint main(){\n  FAST;\n  LL i,V,E,s,e,c;\n\tcin>>V>>E;\n\tTSP t(V);\n\trep(i,E){\n\t\tcin>>s>>e>>c;\n\t\tt.add(s,e,c);\n\t}\n\tcout<<t.cost()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 巡回セールスマン問題\n// 蟻本p173と同じ。\n// 訪問済状態をビットで表すとbitDPで解ける\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\n\nll INF = 1e9; // オーバーフローに注意\n\n// S: これまでたどった頂点  v: 今いる頂点\nint rec(int S, int v, int V, int E, vector<vector<ll>>& dp, vector<vector<ll>>& dist) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << V) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    ll res = INF;\n    REP(u, V) {  // 次に行く頂点をuとする\n        if (!(S >> u & 1)) {\n            auto d = dist[v][u];\n            if (d != INF) {\n                res = min(res, rec(S | 1 << u, u, V, E, dp, dist) + d);\n            }\n        }\n    }\n    return dp[S][v] = res;\n}\n\nll travelling_salesman(int V, int E, vector<vector<ll>>& dist) {\n    vector<vector<ll>> dp(1<<V, vector<ll>(V, -INF));\n    return rec(0, 0, V, E, dp, dist);\n}\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<ll>> dist(V, vector<ll>(V, INF));\n    REP(e, E) {\n        int s, t;\n        ll d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    auto ret = travelling_salesman(V, E, dist);\n    cout << (ret == INF ? -1 : ret) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntypedef long long ll;\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define REP(i,num,n) for(int i=num, i##_len=(n); i<i##_len; ++i)\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define print(x) (cout << (x) << endl)\n#define pb push_back\n#define mp make_pair\n#define sz(x) int(x.size())\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\n#define fs first\n#define sc second\n\nconst int INF = 1e9;\nconst ll LLINF = 1e16;\nconst ll MOD = 1e9+7;\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n \ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n \ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n \n\n// 指定した文字cが文字列に何文字入ってるか\nll stringcount(string s, char c) {\n    return count(s.cbegin(), s.cend(), c);\n}\n\n\n// 割り算の切り上げ処理\ntemplate<typename T>\nT rp(T a, T b) {\n  return (a + b - 1) / b;\n}\n\n// 桁和\ntemplate<typename T>\nT digsum(T n) {\n    T res = 0;\n    while(n > 0) {\n        res += n%10;\n        n /= 10;\n    }\n    return res;\n}\n\n// 回文判定\nbool kai (string s) {\n    string t{s};\n    reverse(begin(t), end(t));\n    return s == t;\n}\n\nusing pint = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n\nint g[20][20];\nint dp[1 << 15][20];\n\nint main(void)\n{\n    cout.tie(0);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int v,e;\n    cin >> v >> e;\n    rep(i, 1 << v){\n      fill(dp[i], dp[i] + v, INF);\n    }\n    \n    rep(i, v){\n      fill(g[i], g[i] + v, -1);\n    }\n\n    rep(i, e){\n      int s,t,d;\n      cin >> s >> t >> d;\n      g[s][t] = d;\n    }\n\n    dp[0][0] = 0;\n\n    rep(bit, 1 << v){\n      rep(now, v){\n        rep(to, v){\n          if((bit >> to & 1) == 0 && g[now][to] != -1){\n            chmin(dp[bit | 1 << to][to], dp[bit][now] + g[now][to]);\n          }\n        }\n      }\n    }\n    print(dp[(1<<v)-1][0] == INF ? -1 : dp[(1<<v)-1][0]);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1e9;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V,E; cin >> V >> E;\n    struct edge{int to,cost;};\n    vector<vector<edge>> G(V);\n    for (int i=0;i<E;++i){\n        int s,t,d; cin >> s >> t >> d;\n        G[s].emplace_back(edge{t,d});\n    }\n    vector<vector<int>> dp(1<<V,vector<int>(V,INF));\n    dp[0][0]=0;\n    for (int bit=0;bit<(1<<V);++bit){\n        for (int i=0;i<V;++i){\n            for (auto e:G[i]){\n                int j=e.to;\n                if (!(bit&1<<j)){\n                    dp[bit|1<<j][j]=min(dp[bit|1<<j][j],dp[bit][i]+e.cost);\n                }\n            }\n        }\n    }\n    cout << (dp[(1<<V)-1][0]==INF?-1:dp[(1<<V)-1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define inf 1000000007\nint dp[16][1<<16];\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    int dst[16][16]={};\n    for(int i=0;i<16;i++){\n        for(int j=0;j<16;j++){\n            dst[i][j] = inf;\n        }\n    }\n    for(int i=0;i<16;i++){\n        for(int j=0;j<(1<<16);j++){\n            dp[i][j] = inf;\n        }\n    }\n    dp[0][0] = 0;\n    for(int i=0;i<m;i++){\n        int s,t,d;\n        cin >> s >> t >> d;\n        dst[s][t] = d;\n    }\n    for(int j=0;j<(1<<n);j++){\n        for(int s=0;s<n;s++){\n            for(int t=0;t<n;t++){\n                if(s==t)continue;\n                if((j&(1<<t))==0)dp[t][j+(1<<t)] = min(dp[t][j+(1<<t)],dp[s][j]+dst[s][t]);\n            }\n        }       \n    }\n    int ans = dp[0][(1<<n)-1];\n    if(ans!=inf)cout << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <stdlib.h>\n#include <string.h>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <tuple>\n#include <bitset>\n#include <cfloat>\n#include <fstream>\n#include <limits.h>\n#include <list>\n#include <math.h>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <cassert>\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nusing namespace std;\n#define int long long\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define P pair<ll, ll>\n#define sz(x) (ll)x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define VE vector<ll>\n#define COUT(x) cout<<(x)<<endl\n#define MA map<ll,ll>\n#define SE set<ll>\n#define PQ priority_queue<ll>\n#define PQR priority_queue<ll,VE,greater<ll>>\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define EPS (1e-14)\n#define pb push_back\nlong long MOD = 1000000007;\n//const long long MOD = 998244353;\nconst long long INF = 1LL << 60;\nconst double PI = acos(-1.0);\nusing Graph = vector<VE>;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%MOD + MOD) % MOD) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nstruct combination {\n\tvector<mint> fact, ifact;\n\tcombination(int n) :fact(n + 1), ifact(n + 1) {\n\t\tassert(n < MOD);\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n\t\tifact[n] = fact[n].inv();\n\t\tfor (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n\t}\n\tmint operator()(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn fact[n] * ifact[k] * ifact[n - k];\n\t}\n}com(10);\nstruct Sieve {\n\tint n;\n\tvector<int> f, primes;\n\t\n\tSieve(int n = 1) :n(n), f(n + 1) {\n\t\tf[0] = f[1] = -1;\n\t\tfor (ll i = 2; i <= n; ++i) {\n\t\t\tif (f[i]) continue;\n\t\t\tprimes.push_back(i);\n\t\t\tf[i] = i;\n\t\t\tfor (ll j = i * i; j <= n; j += i) {\n\t\t\t\tif (!f[j]) f[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool isPrime(int x) { return f[x] == x; }\n\t\n\tvector<int> factorList(int x) {\n\t\tvector<int> res;\n\t\twhile (x != 1) {\n\t\t\tres.push_back(f[x]);\n\t\t\tx /= f[x];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<P> factor(int x) {\n\t\tvector<int> fl = factorList(x);\n\t\tif (fl.size() == 0) return {};\n\t\tvector<P> res(1, P(fl[0], 0));\n\t\tfor (int p : fl) {\n\t\t\tif (res.back().first == p) {\n\t\t\t\tres.back().second++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.emplace_back(p, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nclass UnionFind {\npublic:\n\tvector <ll> par; \n\tvector <ll> siz; \n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1) {\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.resize(sz_, 1);\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { \n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; \n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\t\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\tbool issame(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) {\n\t\treturn siz[root(x)];\n\t}\n};\ntemplate<class t> t gcd(t a, t b) { return b != 0 ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) {\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool prime(ll n) {\n\tfor (ll i = 2; i <= sqrt(n); i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn n != 1;\n}\nmap<ll, ll> prime_factor(ll n) {\n\tmap<ll, ll> ret;\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tret[i]++;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n != 1) ret[n] = 1;\n\treturn ret;\n}\nll modinv(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvector<pair<char, int>> RunLength(string s) {\n\tif (s.size() == 0)return {};\n\tvector<pair<char, int>>res(1, pair<char, int>(s[0], 0));\n\tfor (char p : s) {\n\t\tif (res.back().first == p) {\n\t\t\tres.back().second++;\n\t\t}\n\t\telse {\n\t\t\tres.emplace_back(p, 1);\n\t\t}\n\t}\n\treturn res;\n}\n// Digit Count\nint GetDigit(int num) {\n\treturn log10(num) + 1;\n}\n// bit calculation[how many \"1\"] (= __builtin_popcount())\nint bit_count(int n) {\n\tint cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1)cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\n\nconst ll dx[4] = { 1,0,-1,0 };\nconst ll dy[4] = { 0,1,0,-1 };\nstruct edge { ll to, cost; };\ntypedef long double ld;\n\nint V, E;\nint G[20][20];\nint dp[1 << 20][20];\nint rec(int S, int v) {\n\tif (S == 0) {\n\t\tif (v == 0)return 0;\n\t\telse return INF;\n\t}\n\tif ((S & (1 << v)) == 0)return INF;\n\tif (dp[S][v] != 0)return dp[S][v];\n\tdp[S][v] = INF;\n\trep(u, V) {\n\t\tchmin(dp[S][v], rec(S ^ (1 << v), u) + G[u][v]);\n\t}\n\treturn dp[S][v];\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//cout << fixed << setprecision(15);\n\tcin >> V >> E;\n\trep(i, 20)rep(j, 20)G[i][j] = INF;\n\trep(i, E) {\n\t\tint s, t, d; cin >> s >> t >> d; G[s][t] = d;\n\t}\n\tint ans = rec((1 << V) - 1, 0);\n\tif (ans != INF)cout << ans << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint TSP(const vector<vector<int>>& edge) {\n  const int INF = 1e9;\n  vector<vector<int>> dp(1 << edge.size(), vector<int>(edge.size(), INF));\n  dp[1][0] = 0;\n  for(int bit = 1; bit < (1 << edge.size()); ++bit)\n    for(int last = 0; last < edge.size(); ++last)\n      if((bit >> last) & 1) for(int next = 0; next < edge.size(); ++next)\n        if(!((bit >> next) & 1)) dp[bit | (1 << next)][next] = min(dp[bit | (1 << next)][next], dp[bit][last] + edge[last][next]);\n  int result = INF;\n  for(int last = 0; last < edge.size(); ++last) result = min(result, dp[(1 << edge.size()) - 1][last] + edge[last][0]);\n  return result;\n}\nint main() {\n  int V, E;\n  cin >> V >> E;\n  vector<vector<int>> edge(V, vector<int>(V, 1e9));\n  for(int i = 0; i < E; ++i) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    edge[s][t] = d;\n  }\n  auto result = TSP(edge);\n  cout << (result == 1e9 ? -1 : result) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#define REP(i,n) for (int i=0;i<(n);++i)\nusing namespace std;\nusing ll = long long;\n\nstruct Edge {\n  int to, cost;\n};\n\nint v, e, s, t, d;\nvector<Edge> g[16];\nvector<vector<int>> dp(1 << 16, vector<int>(16, -1));\n\nint rec(int bit, int from) {\n  if (dp[bit][from] >= 0) return dp[bit][from];\n  if (bit == (1 << v) - 1 && from == 0) return dp[bit][from] = 0;\n\n  int res = 1 << 30;\n  for(Edge e : g[from]) {\n    if (bit >> e.to & 1) continue;\n    res = min(res, rec(bit | (1 << e.to), e.to) + e.cost);\n  }\n  return dp[bit][from] = res;\n}\n\nint main() {\n  cin >> v >> e;\n  REP(i, e) {\n    cin >> s >> t >> d;\n    g[s].push_back(Edge{t, d});\n  }\n  rec(0, 0);\n  cout << (dp[0][0] != (1 << 30) ? dp[0][0] : -1) << endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// 巡回セールスマン問題\n// 蟻本p173と同じ。\n// 訪問済状態をビットで表すとbitDPで解ける\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\n\nll INF = 1e18;\n\n// S: これまでたどった頂点  v: 今いる頂点\nll rec(int S, int v,\n        const int V,\n        vector<vector<ll>>& dp, const vector<vector<ll>>& dist) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << V) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    ll res = INF;\n    REP(u, V) {  // vの次に行く頂点をuとする\n        if (!(S & (1 << u))) { // uに未訪問の場合\n            auto d = dist[v][u];\n            if (d != INF) { // v -> uにエッジが\n                res = min(res, rec(S | 1 << u, u, V, dp, dist) + d);\n            }\n        }\n    }\n    return dp[S][v] = res;\n}\n\nll travelling_salesman(int V, vector<vector<ll>>& dist) {\n    vector<vector<ll>> dp(1<<V, vector<ll>(V, -INF));\n    return rec(0, 0, V, dp, dist);\n}\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<ll>> dist(V, vector<ll>(V, INF));\n    REP(e, E) {\n        int s, t;\n        ll d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    auto ret = travelling_salesman(V, dist);\n    cout << (ret == INF ? -1 : ret) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint main(void){\n    int N,M; cin >> N >> M;\n    int dp[1<<N][N], dist[N][N];\n    REP(i,N)REP(j,N) dist[i][j] = 1e6;\n    REP(i,N) dist[i][i] = 0;\n    REP(i,M){\n        int s,t,d; cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    REP(i,1<<N)REP(j,N)REP(k,N) dp[i][j] = 1e6;\n\n    dp[0][0] = 0;\n    REP(i,1<<N)REP(j,N){\n        REP(k,N){\n            if((i & 1<<k) == 0) chmin(dp[i | 1<<k][k], dp[i][j] + dist[j][k]);\n        }\n    }\n    int ans = dp[(1<<N)-1][0];\n    cout << (ans<1e6 ? ans : -1) << en;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\nconstexpr int INF = 1e9;\nint main(){\n  int n, e;\n  cin >> n >> e;\n  vector<vector<int>> d(n,vector<int>(n,INF));\n  rep(i,e) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    d[u][v] = c;\n  }\n  vector<vector<int>> dp(1<<n, vector<int>(n,-1));\n\n  auto rec = [&](auto &&f, int s, int v)->int {\n    if (dp[s][v] >= 0) return dp[s][v];\n    else if (s == (1<<n)-1 && v == 0) return dp[s][v] = 0;\n\n    int res = INF;\n    for (int u = 0; u < n; u++) {\n      if (!(s & (1<<u))) res = min(res, f(f, s | (1<<u), u) + d[v][u]);\n    }\n    return dp[s][v] = res;\n  };\n  int ans = rec(rec,0,0);\n  cout << (ans == INF ? -1 : ans) << endl;\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1<<30\n#define LINF (ll)1<<62\n#define MAX 510000\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll, ll> P;\ntypedef vector<pair<ll, ll>> vpl;\n\nll G[20][20];\nll n;\nvvl dp(1<<15, vl(20,-1));\n\nll rec(ll S, ll v){\n    if(dp[S][v] != -1) return dp[S][v];\n    if(S==(1<<n)-1 && v==0) return dp[S][v] = 0;\n    ll res = INF;\n    rep(i,n){\n        if(S & (1<<i)) continue; \n        res = min(res, rec(S | (1<<i), i) + G[v][i]);\n    }\n    return dp[S][v] = res;\n}\n\nint main(){\n    ll m; cin >> n >> m;\n    rep(i,n) rep(j,n) G[i][j] = i==j ? 0 : INF;\n    rep(i,m){\n        ll a,b,c; cin >> a >> b >> c;\n        G[a][b] = c;\n    }\n    ll ans = rec(0,0);\n    if(ans != INF) cout << ans << endl;\n    else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\ntypedef long long ll;\ntypedef long double ld;\nlong long dx[] = {1,0,-1,0};\nlong long dy[] = {0,1,0,-1};\nlong long dx8[] = {1,1,0,-1,-1,-1,0,1};\nlong long dy8[] = {0,1,1,1,0,-1,-1,-1};\nlong long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\n\nmap<int,map<int,int>> m;\nmap<int,map<int,bool>> is_edge;\n\nint adj(int s,int t){\n    if(is_edge[s][t])return m[s][t];\n    else return -1;\n}\n\nsigned main(){\n    ll V,E;\n    cin >> V >> E;\n    ll s,t,d;\n    FOR(i,0,E){\n        cin >> s >> t >> d;\n        m[s][t] = d;\n        is_edge[s][t] = true;\n    }\n    ll DP[(1<<V)][V];\n    FOR(i,1,(1<<V))FOR(j,0,V){\n        DP[i][j] = 1000000;\n        if((1<<j)&i){\n            int last = i^(1<<j);\n            if(last){\n                FOR(k,0,V){\n                    if((1<<k)&last && adj(k,j) != -1){\n                        DP[i][j] = min(DP[i][j],DP[last][k]+adj(k,j));\n                    }\n                }\n            }\n            else if(i == 1)DP[i][j] = 0;\n        }\n    }\n    ll ans = 20000;\n    FOR(i,0,V)if(adj(i,0) != -1)ans = min(ans,DP[(1<<V)-1][i]+adj(i,0));\n    if(ans == 20000)cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n#include <numeric>\n#include <unordered_map>\n#include <sstream>\n#include<limits.h>\n#include<float.h>\n#include<list>\n#include <array>\n#include <complex>\n#include<stdio.h>\n#include<string.h>\n#include <bitset>\n// #include<assert.h>\n#include<random>\nusing namespace std;\n#define int long long\n\n#define I32_MAX 2147483647\n#define I64_MAX 9223372036854775807LL\n#define I64_MAX2 1223372036854775807LL\n#define INF I64_MAX2\n// #define MOD 1000000007\n#define MOD 998244353 \n#define MEM_SIZE 100010\n#define DEBUG_OUT true\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> void DEBUG(T e){if(DEBUG_OUT == false)return; std::cout << e <<\" \";}\ntemplate<typename T> void DEBUG(const std::vector<T>& v){if(DEBUG_OUT == false)return;for(const auto& e : v){std::cout<< e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void DEBUG(const std::vector<std::vector<T> >& vv){if(DEBUG_OUT == false)return;for(const auto& v : vv){ DEBUG(v); } }\ntemplate<class T,class... Ts> void DEBUG(T d, Ts... e){if(DEBUG_OUT == false)return;DEBUG(d);DEBUG(e...);}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; abort();}}\ntemplate< typename T1, typename T2 > inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate< typename T1, typename T2 > inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint bitDP(int s,int v, vector<vector<int> > & GRAPH,  vector<vector<int> > & DP)\n{\n  if(s == 0)\n  {\n    if(v == 0){\n      return 0;\n    }\n    else\n    {return INF;\n    }\n  }\n\n  if((s&(1<<v)) == 0)\n  {\n    return INF;\n  }\n\n  int &ret = DP[s][v];\n  if(ret != 0) return ret;\n\n  ret = INF;\n  for (int u = 0; u < GRAPH.size(); u++)\n  {\n    chmin(ret,bitDP(s^(1<<v),u,GRAPH,DP) + GRAPH[u][v]);\n  }\n  return ret;\n  \n}\nvoid solve(void)\n{\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int> > GRAPH (v,vector<int>(v,INF)); \n  for (int i = 0; i < e; i++)\n  {\n    int s,t,d;\n    cin>>s>>t>>d;\n    GRAPH[s][t] = d;\n  }\n  vector<vector<int> > dp (1<<v,vector<int>(v,0));\n  dp[0][0] = 0;\n\n  int res = bitDP((1<<v) -1,0,GRAPH,dp);\n\n  if(res!= INF)\n  {\n    cout<<res<<endl;\n  }\n  else\n  {\n    cout<<-1<<endl;\n  }\n  \n  \n\n  return;\n}\n\nint32_t main(int32_t argc, const char *argv[])\n{\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  std::cout << std::fixed;\n  std::cout << std::setprecision(11);\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1 || dis[s][i] == 1000000) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (!dis[s][t])\n\t\t\t{\n\t\t\t\tdis[s][t] = 1000000;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 21\n\nint g[maxn][maxn];\nint v, e;\nint start;\nint dp[100010][21];\n\nint solve(int visited, int cur) {\n    if (dp[visited][cur] != -1)\n        return dp[visited][cur];\n    if (__builtin_popcount(visited) == v) {\n        if (g[cur][start] != -1)\n            return dp[visited][cur] = g[cur][start];\n        return dp[visited][cur] = 1e14;\n    }\n\n    int ans = 1e14;\n    for (int i = 0; i < v; i++) {\n        if (g[cur][i] != -1 and !(visited & (1 << i)))\n            ans = min(ans, g[cur][i] + solve(visited | (1 << i), i));\n    }\n    return dp[visited][cur] = ans;\n}\n\nvoid solve() {\n    cin >> v >> e;\n\n    memset(dp, -1, sizeof dp);\n    memset(g, -1, sizeof g);\n\n    for (int i = 0; i < e; i++) {\n        int a, b, d;\n        cin >> a >> b >> d;\n\n        g[a][b] = d;\n    }\n    int ans = solve(1 << 0, 0);\n    if (ans >= 1e14)\n        ans = -1;\n    cout << ans << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nconst int INF = 1e9;\nconst long long INFL = 1LL<<60;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> d(n, vector<int>(n, INF));\n  rep(i, m) {\n    int s, t, c;\n    cin >> s >> t >> c;\n    d[s][t] = c;\n  }\n\n  vector<vector<int>> dp(1<<n, vector<int>(n, INF));\n  dp[(1<<n) - 1][0] = 0;\n\n  for (int s = (1<<n) - 2; s >= 0; s--) {\n    for (int v = 0; v < n; v++) {\n      for (int u = 0; u < n; u++) {\n        if (!(s >> u & 1)) {\n          dp[s][v] = min(dp[s][v], dp[s | 1 << u][u] + d[v][u]);\n        }\n      }\n    }\n  }\n\n  if (dp[0][0] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[0][0] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi cost(n,vi(n,inf));\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcost[a][b]=c;\n\t}\n\tvvi dp(1<<n,vi(n,inf));\n\tdp[(1<<n)-1][0]=0;\n\tfor(int i=(1<<n)-2;i>=0;i--)rep(j,n){\n\t\trep(k,n)if((i&1<<k)==0){\n\t\t\tdp[i][j]=min(dp[i][j],dp[i|1<<k][k]+cost[j][k]);\n\t\t}\n\t}\n\tif(dp[0][0]!=inf)cout<<dp[0][0]<<endl;\n\telse cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define IOS ios::sync_with_stdio(false), cin.tie(0)\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define ALL(x) (x).begin(), (x).end()\n#define dump(x) cout << (x) << endl\n#define LMAX 9223372036854775807LL\n#define LMIN -9223372036854775807LL\nusing ll = int64_t;\ntemplate<typename T>\nusing vec = vector<T>;\nusing P = pair<ll, ll>;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n\tfill((T *)array, (T *)(array + N), val);\n}\n\nconst ll INF = 1e7;\nconst ll MOD = 1e9 + 7;\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//ll pas[5001][5002];\n\n\nll v, e;\nll d[15][15];\nll dp[1ll << 15][15];\n\nll rec(ll s, ll u, ll k){\n    if(dp[s][u] >= 0)return dp[s][u];\n    if(s == (1ll << v) - 1 && u == k)return dp[s][u] = 0;\n    ll res = INF;\n    for(int i = 0;i < v;i++){\n        if(!(s >> i & 1)){\n            res = min(res, rec(s | 1 << i, i, k) + d[u][i]); \n        }\n    }\n    return dp[s][u] = res;\n}\n\nint main(){\n\tcin >> v >> e;\n    for(int i = 0;i < v;++i){\n        for(int j = 0;j < v;j++)d[i][j] = INF;\n    }\n    for(int i = 0;i < e;++i){\n        ll s, t, x;\n        cin >> s >> t >> x;\n        d[s][t] = x;\n    }\n\tll ans = INF;\n    for(int i = 0;i < v;++i){\n        memset(dp, -1 ,sizeof(dp));\n\t\tll tmp = rec(0,i,i);\n        if(tmp < 1e5)ans = tmp;\n    }\n\tif(ans == INF)dump(-1);\n\telse dump(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include<numeric>\n#include<cmath>\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define INF 2e9\n#define ALL(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\nconst int maxv = 16;\nint V,E;\n\nstruct Edge{\n    int to;\n    int cost;\n    Edge(int a, int b){\n        to = a;\n        cost = b;\n    }\n};\nvector<vector<ll> > G;\n\nvector<vector<ll> > dp(1LL<<maxv, vector<ll>(maxv, -1));\n\nll rec(ll S, int v){\n    if(S == 0){\n        if(v == 0){\n            dp[S][v] = 0;\n            return 0;\n        }\n        else{\n            dp[S][v] = INF;\n            return INF;\n        }\n    }\n\n    if((S & (1<<v)) == 0) return INF; //Sにvが含まれなくなってしまった場合の終了処理\n\n    ll &ret = dp[S][v];\n    if(ret != -1) return ret; //0の理由:\n    if((S & (1<<v)) != 0){\n        ret = INF;\n        for(int u = 0; u < V; u++){\n            if(G[u][v] != INF){\n                ret = min(ret, rec(S^(1<<v), u) + G[u][v]);\n            }\n        }\n        return ret;\n    }\n}\n\n\nint main(){\n    //cin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\n    cin >>V>>E; //Vは頂点数,Eは辺\n    G.resize(V,vector<ll>(V,INF));\n    REP(i,E){\n        ll s,t,d; cin>>s>>t>>d;\n        G[s][t] = d;\n    }\n    \n    cout << (rec((1<<V)-1,0) != INF ? rec((1<<V)-1,0) : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = (0); i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define show2(x,y) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl\n#define show3(x,y,z) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) <<  \", \" << #z << \" = \" << (z) << endl\n#define showv(v) rep(i,v.size()) printf(\"%d%c\", v[i], i==v.size()-1?'\\n':' ')\n#define showv2(v) rep(j,v.size()) showv(v[j])\n#define showt(t,n) rep(i,n) printf(\"%d%c\", t[i], i==n-1?'\\n':' ')\n#define showt2(t,r,c) rep(j,r) showt(t[j],c)\n#define showvp(p) rep(i,p.size()) printf(\"%d %d\\n\", p[i].first, p[i].second)\n#define printv(v) rep(i,v.size()) printf(\"%d\\n\", v[i])\n#define printt(t,n) rep(i,n) printf(\"%d\\n\", t[i])\n#define incl(v,x) (find(all(v),x)!=v.end())\n#define incls(s,c) (s.find(c)!=string::npos)\n#define lb(a,x) distance((a).begin(),lower_bound(all(a),(x)))\n#define ub(a,x) distance((a).begin(),upper_bound(all(a),(x)))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define bit(n,k) ((n>>k)&1) // nのk bit目\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define SP << \" \" <<\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing vp = vector<P>;\nusing vt = vector<T>;\nconst int mod = 1000000007;\nconst double EPS = 1e-9;\n//const long double EPS = 1e-14;\nconst int INF = (1<<30)-1;\nconst ll LINF = (1LL<<62)-1;\n#define dame { puts(\"No\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\ninline int in() { int x; cin >> x; return x;}\ninline ll lin() { ll x; cin >> x; return x;}\ninline char chin() { char x; cin >> x; return x;}\ninline string stin() { string x; cin >> x; return x;}\ninline double din() { double x; cin >> x; return x;}\n//template<class T = int> inline T in() { T x; cin >> x; return (x);}\ntemplate<typename T>inline ll suma(const vector<T>& a) { ll res(0); for (auto&& x : a) res += x; return res;}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nchar itoa(int n) { return n + '0';}\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0, 1, 0,-1};\n\nint main () {\n  int n, m;\n  cin >> n >> m;\n  vvi d(n,vi(n,INF));\n  rep(i,n) d[i][i] = 0;\n  rep(i,m) {\n    int s, t, w;\n    cin >> s >> t >> w;\n    d[s][t] = w;\n  }\n\n  vvi dp(1<<n,vi(n,INF));\n  dp[0][0] = 0;\n  rep(S,1<<n)rep(v,n) {\n    rep(u,n) {\n      if (bit(S,u)) continue;\n      chmin(dp[S|1<<u][u], dp[S][v] + d[v][u]);\n    }\n  }\n\n  int ans = dp[(1<<n)-1][0];\n  if (ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <fstream>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nchar ToUpper(char cX) { return toupper(cX); }\nchar Tolower(char cX) { return tolower(cX); }\n\n\nconst long long INF = 1LL << 60;\nconst long long MOD = 1000000007LL;\nconst long long MAX = 500000LL;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef  long long ll;\nusing T = tuple<ll, ll, ll>;\n\nll V, E;\nvector<vector<pair<ll,ll>>> a;\nvector<vector<ll>> dp;\n\nll dfs(ll S, ll v) {\n\n\tif (dp[S][v] != -1) {\n\t\treturn dp[S][v];\n\t}\n\tif ((S == (1 << V) - 1) && (v == 0)) {\n\t\treturn dp[S][v] = 0;\n\t}\n\n\tll res = INF;\n\tfor (ll i = 0; i < a[v].size(); i++) {\n\t\tif ((S >> a[v][i].first) & 1)\n\t\t\tcontinue;\n\t\tchmin(res, dfs(S | (1 << a[v][i].first), a[v][i].first) + a[v][i].second);\n\t}\n\treturn dp[S][v] = res;\n}\nint main()\n{\n\tcin >> V >> E;\n\ta.resize(V);\n\tdp = vector<vector<ll>>(1 << V, vector<ll>(V, -1));\n\tfor (ll i = 0; i < E; i++) {\n\t\tll s, t, z;\n\t\tcin >> s >> t >> z;\n\t\ta[s].push_back(make_pair(t, z));\n\t}\n\tll res = INF;\n\t//cout << dfs(0, 2, 0, 2) << endl;\n\tchmin(res, dfs(0, 0));\n\tif (res == INF) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include<vector>\n#include<algorithm>\n#include<map>\n#include<iomanip>\n#include<set>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<sstream>\n#include<cmath>\n#include<tuple>\n#include<bitset>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define req(i,n) for(int i = 1;i <=  n; i++)\n#define rrep(i,n) for(int i = n -1;i >= 0;i--)\n#define ALL(obj) begin(obj), end(obj)\ntypedef long long int ll;\ntypedef long double ld;\nconst ll INF = (1LL << 60);\nint n,m,a,b,d; ll ans = 0; string s;\nconst ld PI = acos(-1);\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}ll dp[1 << 16][16],G[16][16];\nll rec(ll S, int v) {\n    if (dp[S][v] > -1) return dp[S][v];\n    if (S == (1 << n) - 1 && v == 0)return dp[S][v] = 0;\n    ll res = INF;\n    rep(u, n) if (!(S >> u & 1)) res = min(res, rec(S | 1 << u, u) + G[v][u]);\n    return dp[S][v] = res;\n}\nint main() {\n    cin >> n >> m;\n    Fill(G, INF), Fill(dp, -1);\n    rep(i, m) {\n        cin >> a >> b >> d;\n        G[a][b] = d;\n    }ans = rec(0, 0);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Contents   : DPL 2 A\n * Author     : Kitaura Hiromi\n * LastUpdate : 20180626\n * Since      : 20180626\n */\n#include <bits/stdlib.h>\nusing namespace std;\n#define MAX_N 15\n#define INF 1<<20\nint n;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\n\nint main(void){\n    fill((int*)dp, (int*)(dp+MAX_N), INF);\n    dp[(1<<n) - 1][0] = 0;\n\n    for(int S=(1<<n)-2; S>=0; S--){\n        for(int v=0; v<n; v++){\n            for(int u=0; u<n; u++){\n                if(!(S>>u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + dp[v][u]);\n                }\n            }\n        }\n    }\n    cout << dp[0][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\tmemset(dis, -1, sizeof(dis));\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (dis[s][t] == -1)\n\t\t\t{\n\t\t\t\tdis[s][t] = 1000000;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin>>n>>m;\n    int s,t,d,maki=(1<<n);\n    int dis[n][n];\n    for(int i=0;i<n;i++){\n    \tfor(int j=0;j<n;j++){\n    \t\tif(i==j)dis[i][j]=0;\n    \t\telse dis[i][j]=mod;\n    \t}\n    }\n    for(int i=0;i<m;i++){\n    \tcin>>s>>t>>d;\n    \tdis[s][t]=d;\n    }\n    int dp[maki][n];\n    for(int i=0;i<maki;i++){\n    \tfor(int j=0;j<n;j++){\n    \t\tdp[i][j]=mod;\n    \t}\n    }\n    dp[maki-1][0]=0;\n    for(int bit=maki-2;bit>=0;bit--){\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tif(!((1<<j)&bit)){\n    \t\t\t\tdp[bit][i]=min(dp[bit][i],dp[bit|(1<<j)][j]+dis[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    if(dp[0][0]==mod)cout << -1<<endl;\n    else cout << dp[0][0] <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\nll dp[16][16][(1<<16)+1];\nvector<pair<int,int> > edge[16];\nint v,e;\n\nll rec(int from, int s, int l){\n    if(dp[s][from][l] != -1) return dp[s][from][l];\n    int prev = l & ~(1<<from);\n    if(l == (1<<v)-1 && from == s) prev = l;\n    if(prev == 0){\n        if(from == s) return 0;\n        else return INF;\n    }\n    ll ans = INF;\n    for(int i = 0; i < edge[from].size(); i++){\n        if(((prev>>edge[from][i].first) & 1) == 0) continue;\n        if(prev != (1<<s) && edge[from][i].first == s) continue;\n        ans = min(ans,rec(edge[from][i].first,s,prev)+edge[from][i].second);\n    }\n    dp[s][from][l] = ans;\n    return ans;\n}\n\nint main(){\n    cin >> v >> e;\n    for(int i = 0; i < e; i++){\n        int s,t,d;\n        cin >> s >> t >> d;\n        edge[t].push_back(make_pair(s,d));\n    }\n\n\n    for(int i = 0; i <= v; i++){\n        for(int j = 0; j <= v; j++){\n            for(int k = 0; k <= 1<<v; k++){\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n\n    ll ans = INF;\n    for(int i = 0; i < v; i++){\n        ans = min(ans,rec(i,i,(1<<v)-1));\n    }\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ループverです。移動後はvisitedが増えるので, visited昇順にループを回せば良いです。\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint INF = 1000000007;\nint n, m;\nbool canMove[15][15] = {false};\nint ecost[15][15];\nint dp[1 << 15][15];\t//dp[visited][pos] = これまでの最小コスト（visitedの下位i(>=0)ビット目が1⇔頂点iを訪問済み, pos…現在地.）\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tecost[s][t] = d;\n\t\tcanMove[s][t] = true;\n\t}\n\t\n\tfor (i = 0; i < (1 << n); i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n\tdp[1][0] = 0;\n\tfor (i = 1; i < (1 << n) - 1; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\tif (!canMove[j][k]) continue;\n\t\t\t\tif (dp[i][j] >= INF) continue;\t//この行は無くてもよい\n\t\t\t\tdp[i + (1 << k)][k] = min(dp[i + (1 << k)][k], dp[i][j] + ecost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (j = 0; j < n; j++) {\n\t\tif (dp[(1 << n) - 1][j] < INF && canMove[j][0]) {\n\t\t\tans = min(ans, dp[(1 << n) - 1][j] + ecost[j][0]);\n\t\t}\n\t}\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<typename T> using V = std::vector<T>;\nusing Vi = V<int>;\nusing VVi = V<V<int>>;\nusing Vl = V<ll>;\nusing VVl = V<V<ll>>;\nusing Vs = V<string>;\n\ntemplate<typename T1, typename T2> using P = std::pair<T1, T2>;\nusing Pii = P<int, int>;\nusing Pll = P<ll, ll>;\nusing Pdd = P<double, double>;\n\ntemplate<typename T1, typename T2> using M = std::map<T1, T2>;\nusing Mii = M<int, int>;\nusing Msi = M<string, int>;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i)\n#define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double PI = acos(-1);\nconst ll MOD = 1e9+7;\n\nint n, m;\nstring s;\n\nint main() {\n    cin >> n >> m;\n    VVi edges(n, Vi(n, -1));\n    REP(i, m) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        edges[s][t] = d;\n    }\n\n    VVi dp(1 << n, Vi(n, 1e9));\n    dp[0][0] = 0;\n    REP(bit, 1 << n) {\n        REP(from, n) {\n            REP(to, n) {\n                if (bit & (1 << to)) continue;\n                if (edges[from][to] == -1) continue;\n                dp[bit | (1 << to)][to] = min(\n                    dp[bit | (1 << to)][to],\n                    dp[bit][from] + edges[from][to]\n                );\n            }\n        }\n    }\n    if (dp[(1 << n) - 1][0] == 1e9) {\n        std::cout << -1 << '\\n';\n    } else {\n        std::cout << dp[(1 << n) - 1][0] << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int V_MAX = 15;\nconst int INF = 10000000;\n\nint n, e;\nint g[V_MAX][V_MAX];\nint dp[1 << V_MAX][V_MAX];\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1 && v == 0)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u)) && g[v][u] != INF) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &e);\n    fill(&g[0][0], &g[n][0], INF);\n    for (int i = 0; i < e; ++i) {\n        int s, t, d;\n        scanf(\"%d %d %d\", &s, &t, &d);\n        g[s][t] = d;\n    }\n\n    fill(&dp[0][0], &dp[1 << V_MAX][0], -1);\n    int d = tsp(0, 0);\n    if (d == INF)\n        printf(\"-1\\n\");\n    else\n        printf(\"%d\\n\", d);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    long long int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n        graph[i][i] = 0;\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<long long int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                if(k == j || ((1 << k) & tmp) == 0 || result[tmp][k].first == mod || graph[k][j] == mod) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    long long int ans = mod;\n    for(int i = 0; i < v; i++){\n        if(result[(1 << v) - 1][i].first == mod) continue;\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nconst int MAX_V = 15;\nconst int INF = 1e9;\n \nint V,E;\nint d[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\n\n//bitDP\n//????????????v????????????????????????????????????????????£???v????????£??????????????????????????????\n// = ??????0?????????????????????????????£????????????????????????0????????£?????????\n\nint dfs(int mask,int v){\n    if(mask==(1<<V)-1) return d[v][0];\n    if(dp[mask][v]!=-1) return dp[mask][v];\n    int res = INF;\n    rep(u,V){\n        if(d[v][u]==INF || (mask&(1<<u))) continue;\n        res = min(res, dfs(mask|(1<<u),u)+d[v][u]);\n    }\n    return dp[mask][v] = res;\n}\n\nint main() {\n    cin>>V>>E;\n    rep(i,V)rep(j,V) d[i][j]=INF;\n    rep(i,V) d[i][i]=0;\n    rep(i,E){\n        int s,t;\n        cin>>s>>t;\n        cin>>d[s][t];\n    }\n    memset(dp, -1, sizeof(dp));\n    int res=dfs(1,0);\n    cout<<(res==INF ? -1 : res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int s, t;\n  vector< vector<int> >edge(v, vector<int>(v, INF));\n  for(int i=0; i<e; i++){\n    cin >> s >> t;\n    cin >> edge[s][t];\n  }\n  \n  vector< vector<int> >dp((1 << v), vector<int>(v, INF));\n  dp[0][0] = 0;\n\n  int cost;\n  for(int i=0; i<(1<<v); i++)\n    for(int j=0; j<v; j++)\n      for(int k=0; k<v; k++){\n\tif((i&(1<<k)) != 0)\n\t  continue;\n\tcost = dp[i][j] + edge[j][k];\n\tif(cost < dp[i|(1<<k)][k])\n\t  dp[i|(1<<k)][k] = cost;\n      }\n  \n  if(dp[(1<<v)-1][0] == INF)\n    cout << -1 << endl;\n  else\n    cout << dp[(1<<v)-1][0] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int INF=1<<25;\n\nint n;\nint m[15][15];\nint dp[15][1<<15];\n\nint rec(int s,int v)\n{\n\tif(dp[v][s]>=0)return dp[v][s];\n\telse if(s==(1<<n)-1&&v==0)return dp[v][s]=0;\n\t\n\tint res=INF;\n\tfor(int u=0;u<n;u++)\n\t{\n\t\tif(!(s>>u&1)&&m[v][u]!=INF)res=min(res,rec(s|1<<u,u)+m[v][u]);\n\t}\n\treturn dp[v][s]=res;\n}\n\nint main()\n{\n\tint e,s,t,d;cin>>n>>e;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)m[i][j]=INF;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>s>>t>>d;\n\t\tm[s][t]=d;\n\t}\n\t\n\tmemset(dp,-1,sizeof(dp));\n\tint ans=rec(0,0);\n\tif(ans!=INF)cout<<rec(0,0)<<endl;\n\telse cout<<-1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint V, E, o;\nint dis[16][16], dp[16][1<<16];\n\nint solve(int s, int state)\n{\n\tif (~dp[s][state])\n\t{\n\t\treturn dp[s][state];\n\t}\n\tif (state == (1<<V)-1)\n\t{\n\t\treturn dp[s][state] = dis[s][o];\n\t}\n\tint res = INT_MAX;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (state >> i & 1) continue;\n\t\tres = min(res, solve(i, state | 1 << i) + dis[s][i]);\n\t}\n\treturn dp[s][state] = res;\n}\n\nint main()\n{\n\tcin >> V >> E;\n\twhile(E--)\n\t{\n\t\tint s, t, w;\n\t\tcin >> s >> t >> w;\n\t\tdis[s][t] = w;\n\t}\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\tfor (int t = 0; t < V; t++)\n\t\t{\n\t\t\tif (!dis[s][t])\n\t\t\t{\n\t\t\t\tdis[s][t] = 1000000;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INT_MAX;\n\tfor (int s = 0; s < V; s++)\n\t{\n\t\to = s;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tans = min(ans, solve(s, 1<<s));\n\t}\n\tif (ans > 1000000)\n\t{\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string.h>\n#include <cmath>\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define max3(A,B,C) max((A),max((B),(C)))\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nconst int INF = 0x3f3f3f3f;\nconst long long int INFL = 0x3f3f3f3f3f3f3f3f;\nconst double pi = atan(1.0)*4.0;\nconst int N = 15;\n\nint pd[1 << N][N];\n\nint main(void) {\n   int n, m, adj[N][N], a, b, c;\n\n   scanf(\"%d %d\", &n, &m);\n\n   for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n         adj[i][j] = INF;\n      }\n   }\n\n   for(int i = 0; i < m; i++) {\n      scanf(\"%d %d %d\", &a, &b, &c);\n      adj[a][b] = c;\n   }\n\n   for(int i = 0; i < 1 << n; i++) {\n      for(int j = 0; j < n; j++) {\n         pd[i][j] = INF;\n      }\n   }\n   pd[1][0] = 0;\n\n   for(int i = 0; i < 1 << n; i++) {\n      for(int j = 0; j < n; j++) {\n         if(i & (1 << j)) {\n            for(int k = 0; k < n; k++) {\n               if(i & (1 << k)) {\n                  pd[i][j] = min(pd[i][j], pd[i^(1 << j)][k] + adj[k][j]);\n               }\n            }\n         }\n      }\n   }\n\n   int ans = INF;\n   for(int i = 0; i < n; i++) ans = min(ans, pd[(1 << n)-1][i] + adj[i][0]);\n   printf(\"%d\\n\", ans == INF ? -1 : ans);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define INF 0x33433433\n\nstruct Edge {\n    int len;\n    int to;\n};\n\nint n;\nint m;\nint state;\nint ans;\nint dp[1 << 16][15];\nint adj[15][15];\n\nvoid calc(int s) {\n    int state = 1 << n;\n    int start = 1 << s;\n\n    for (int i=0; i<state; i++) {\n        for (int j=0; j<n; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    dp[start][s] = 0;\n    for (int i=start+1; i<state; i++) {\n        for (int j=0; j<n; j++) {\n            for (int k=0; k<n; k++) {\n                bool s1 = ((i >> j) & 1);\n                bool s2 = ((i >> k) & 1);\n\n                if (j == k) continue;\n                if (adj[k][j] == -1) continue;\n                if (s1 && s2) {\n                    dp[i][j] = min(dp[i][j], dp[i & ~(1 << j)][k] + adj[k][j]);\n                }\n            }\n        }\n    }\n\n    for (int i=0; i<n; i++) {\n        if (adj[i][s] == -1) continue;\n        ans = min(ans, dp[state-1][i] + adj[i][s]);\n    }\n}\n\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n            adj[i][j] = -1;\n        }\n    }\n    \n    for (int i=0; i<m; i++) {\n        int s, t, l;\n\n        scanf(\"%d%d%d\", &s, &t, &l);\n        adj[s][t] = l;\n        adj[t][s] = l;\n    }\n\n    ans = INF;\n    for (int i=0; i<n; i++) {\n        calc(i);\n    }\n\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<long double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n#define INF 1LL<<60\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector< vector<int> > dist(N, vector<int>(N, 1e9));\n    REP(i, M) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    // cerr << \"debug : \" << (1<<0) << \" \" << (1<<1) << endl;\n    int ans = 1e9;\n\n    REP(s, N) {\n        vector< vector<int> > dp((1<<N), vector<int>(N, 1e9));\n        // REP(i, N)\n        //     dp[0][i] = 0;\n        dp[0][s] = 0;\n\n        for(int bit = 0; bit < (1<<N); ++bit) {\n            for(int v = 0; v < N; ++v)\n                for(int u = 0; u < N; ++u)\n                    if( (u != v) && (bit & (1<<v)) ) {\n                        dp[bit][v] = min(dp[bit][v], dp[bit&~(1<<v)][u] + dist[u][v]);\n                    }\n        }\n        ans = min(ans, dp[(1<<N)-1][s]);\n    }\n\n    if(ans == 1e9)\n        ans = -1;\n    \n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (1 << 29);\n\nint V, E;\nvector<vector<int>> dist;\nvector<vector<int>> dp;\n\nint rec(int bit, int v)\n{\n  // 計算済みのとき\n  if (~dp.at(bit).at(v))\n  {\n    return dp.at(bit).at(v);\n  }\n  // 初期条件\n  if (bit == 0)\n  {\n    if (v == 0)\n    {\n      return dp.at(bit).at(v) = 0;\n    }\n    else\n    {\n      return dp.at(bit).at(v) = INF;\n    }\n  }\n  // 再帰ステップ\n  int res = INF;\n  // 最短経路における、ひとつ前の頂点がu\n  for (int u = 0; u < V; u++)\n  {\n    if (!(bit & (1 << u)))\n    {\n      continue;\n    }\n    if (dist.at(u).at(v) == INF)\n    {\n      continue;\n    }\n    int prev_bit = bit & ~(1 << u);\n    res = min(res, rec(prev_bit, u) + dist.at(u).at(v));\n  }\n  return dp.at(bit).at(v) = res;\n}\n\nint main()\n{\n  cin >> V >> E;\n  dist.resize(V, vector<int>(V, INF));\n  for (int i = 0; i < E; i++)\n  {\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist.at(s).at(t) = d;\n  }\n  dp.resize((1 << V), vector<int>(V, -1));\n  int res = rec((1 << V) - 1, 0);\n  if (res == INF)\n  {\n    res = -1;\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct ed{\n    int t;\n    int pos;\n    vector<int>exp;\n};\n\nint main(){\n\n    int V,E;\n    bool flag = false;\n    queue< struct ed > st;\n    vector<int> ex;\n    cin >> V >> E;\n    vector< vector<int> > v(V,vector<int>(V));\n    int s,t;\n    for(int i=0;i<E;i++){\n\tcin >> s >> t;\n\tcin >> v[s][t];\n    }\n    struct ed e;\n    for(int i=0;i<V;i++){\n\te.exp.push_back(0);\n    }\n    int pre;\n    e.t = 0;\n    e.pos = 0;\n    st.push(e);\n    while(!st.empty()){\n\te = st.front();\n\tst.pop();\n\tfor(int i=0;i<V;i++){\n\t    if(v[e.pos][i] != 0 && e.exp[i] == 0 ){\n\t\te.t += v[e.pos][i];\n\t\te.exp[i] = 1;\n\t\tpre = e.pos;\n\t\te.pos = i;\n\t\tif(i == 0){\n\t\t    for(int j=0;j<V;j++){\n\t\t\tflag = true;\n\t\t\tif(e.exp[j] == 0) flag = false;\n\t\t    }\n\t\t}\n\t\tif(flag) break;\n\t\tst.push(e);\n\t\te.pos = pre;\n\t\te.exp[i] = 0;\n\t\te.t -= v[e.pos][i];\n\t    }\n\t}\n\tif(flag) break;\n    }\n\n    if(!flag) e.t = -1;\n    cout << e.t << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nstatic const long long INFL = 0x3f3f3f3f;\n\nlong long TSP(int n, const vector<vector<long long>> &d) {\n        vector<vector<long long>> dp(n, vector<long long> (1 << n, -1));\n        function<long long (int, int)> dfs = [&](int u, int remain) {\n                if (dp[u][remain] != -1) return dp[u][remain];\n                if (!remain && u == 0) return dp[u][remain] = 0;\n                long long &ret = dp[u][remain];\n                ret = INFL;\n                for (int v = 0; v < n; v ++) {\n                        if (remain & (1 << v)) {\n                                ret = min(ret, dfs(v, remain & ~(1 << v)) + d[u][v]);\n                        }\n                }\n                return ret;\n        };\n        dfs(0, (1 << n) - 1);\n        return dp[0][(1 << n) - 1] == INFL ? -1 : dp[0][(1 << n) - 1];\n}\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<vector<long long>> d(n, vector<long long> (n, INFL));\n        for (int i = 0; i < m; i ++) {\n                int a, b;\n                long long c;\n                scanf(\"%d%d%lld\", &a, &b, &c);\n                d[a][b] = c;\n        }\n        printf(\"%lld\\n\", TSP(n, d));\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> g(V, vector<int>(V, -1));\n    for (int i = 0; i < E; ++i) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n    const int INF = 1 << 30;\n    vector<vector<int>> dp(1 << V, vector<int>(V, INF));\n    dp[0][0] = 0;\n    for (int bit = 0; bit < 1 << V; ++bit) for (int i = 0; i < V; ++i) if (dp[bit][i] != INF) {\n        for (int j = 0; j < V; ++j) if (!(bit >> j & 1) && g[i][j] >= 0) {\n            dp[bit | (1 << j)][j] = min(dp[bit | (1 << j)][j], dp[bit][i] + g[i][j]);\n        }\n    }\n    cout << (dp[(1 << V) - 1][0] == INF ? -1 : dp[(1 << V) - 1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define INFI 1e9\n\nusing namespace std;\n\nint main() {\n\tint v, e;\n\tcin >> v >> e;\n\tint t1, t2, t3;\n\tint** dist = new int* [v];\n\tfor (int i = 0;i < v;i++) {\n\t\tdist[i] = new int[v];\n\t\tfor (int j = 0;j < v;j++) {\n\t\t\tdist[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 0;i < e;i++) {\n\t\tcin >> t1 >> t2 >> t3;\n\t\tdist[t1][t2] = t3;\n\t}\n\n\n\n\tvector<pair<int,int> >* dp = new vector<pair<int,int> >[1 << (v-1)];\n\tdp[0];\n\tfor (int i = 0;i < 1<<(v-1);i++) {\n\t\tfor (int j = 1;j <= v - 1;j++) {\n\t\t\tif (i & 1 << (j - 1)) {\n\t\t\t\tint index = i - (1 << (j - 1));\n\t\t\t\tif (index == 0) {\n\t\t\t\t\tif (dist[0][j] >= 0) {\n\t\t\t\t\t\tdp[i].push_back(make_pair(j, dist[0][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint m = INFI;\n\t\t\t\t\tfor (int k = 0;k < dp[index].size();k++) {\n\t\t\t\t\t\tif (dist[dp[index][k].first][j] >= 0) {\n\t\t\t\t\t\t\tm = min(dp[index][k].second + dist[dp[index][k].first][j],m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INFI) {\n\t\t\t\t\t\tdp[i].push_back(make_pair(j, m));\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint m = -1;\n\tfor (int i = 0;i < dp[(1 << (v - 1)) - 1].size() ;i++) {\n\t\tif (dist[dp[(1 << (v - 1)) - 1][i].first][0] >= 0) {\n\t\t\tif (m == -1) {\n\t\t\t\tm = dp[(1 << (v - 1)) - 1][i].second + dist[dp[(1 << (v - 1)) - 1][i].first][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm = min(m, dp[(1 << (v - 1)) - 1][i].second + dist[dp[(1 << (v - 1)) - 1][i].first][0]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tcout << m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint*** dp = new int**[N+1];\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[i] = new int*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new int[limit];\n\t\t\tfor(int p = 0; p < limit; p++)dp[i][k][p] = BIG_NUM;\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\tfor(int start = 0; start <= 0; start++){\n\n\t\ttmp = pow(2,start);\n\n\t\tdp[0][start][tmp] = 0;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int p = 0; p < limit; p++){\n\t\t\t\t\tif(dp[i-1][k][p] != BIG_NUM){\n\t\t\t\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\t\t\t\tif(p & (1 << a)){\n\t\t\t\t\t\t\t\tif(i == N && a == start){\n\t\t\t\t\t\t\t\t\tif(cost[k][start] != BIG_NUM)dp[i][start][limit-1] = min(dp[i][start][limit-1],dp[i-1][k][p]+cost[k][start]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\t\t\t\ttmp = p + pow(2,a);\n\t\t\t\t\t\t\t\t\tdp[i][a][tmp] = min(dp[i][a][tmp],dp[i-1][k][p]+cost[k][a]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminimum = min(minimum,dp[N][start][limit-1]);\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\nint N;\nvector<vector<int>> graph;\nvector<vector<int>> dp;\nint func(int node, int state) {\n    if (dp[state][node] >= 0) {\n        return dp[state][node];\n    }\n\n    if ((state == (1 << N) - 1) and node == 0) {\n        return dp[state][node] = 0;\n    }\n\n    int cost = INF;\n    for (int u = 0; u < N; ++u) {\n        if (graph[node][u] == INF) { continue; }\n        if (!(state >> u & 1)) {\n            cost = min(cost, func(u, state | 1 << u) + graph[node][u]);\n        }\n    }\n\n    return dp[state][node] = cost;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int E;\n    cin >> N >> E;\n\n    graph.resize(N, vector<int>(N, INF));\n    FOR(i, 0, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n\n    dp.resize(1 << N, vector<int>(N, -1));\n    int ans = func(0, 0);\n\n    if (ans == INF) {\n        print(-1);\n    }\n    else {\n        print(ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <sstream>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n#define print(s) cout << (s) << endl\n\nconst int INF = 2e9;\n\nint rec(int S, int v, vector<vector<int>> dp, vector<vector<int>> dist, int n) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1<<n)-1 && v == 0) return dp[S][v] = 0;\n    \n    int res = INF;\n    REP(i,n) {\n        if (!(S>>i & 1) && dist[v][i] >= 0) {\n            // ith vertex is not in S\n            // move from v to i\n            res = min(res, rec(S | 1<<i, i, dp, dist, n) + dist[v][i]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> dist(V,vector<int>(V,-1));\n    REP(i,E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    \n    vector<vector<int>> dp(1<<V,vector<int>(V+1,-1));\n    // dp[S][j] denotes the minimum distance from jth vertex to 0th vertex passing all unpassed vertices\n    \n    int ans = rec(0,0,dp,dist,V);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\nint main() {\n    init();\n    ll V, E;\n    cin >> V >> E;\n    vvc<ll> G(V, vl(V, INF)), dp(1 << V, vl(V, INF));\n    rep(i,E){\n        ll s, t, d;\n        cin >> s >> t >> d;\n        G[s][t] = d;\n    }\n\n    dp[0][0] = 0;\n\n    rep(bit, 1<<V){\n        rep(u, V){\n            if(!(1<<u & bit))rep(v, V){\n                if(v!=u) chmin(dp[bit | 1 << u][u], dp[bit][v] + G[v][u]);\n            }\n        }\n    }\n\n    ll ans = dp[(1 << V) - 1][0];\n    cout << (ans == INF ? -1 : ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 18\n#define INF 1000000000\nint N, M, a, b, c, x[MAX_N][MAX_N];\nint dp[MAX_N][1 << MAX_N];\n\nint main() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) { x[i][j] = INF; }\n\t\tfor (int j = 0; j < (1 << MAX_N); j++) { dp[i][j] = INF; }\n\t\n\t}\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a >> b >> c;\n\t\tx[a][b] = c;\n\t\tx[b][a] = c;\n\t}\n\tdp[0][1] = 0;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (dp[j][i] < INF) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i / (1 << k)) % 2 == 0) {\n\t\t\t\t\t\tint dist1 = dp[j][i] + x[j][k];\n\t\t\t\t\t\tint pos = i + (1 << k);\n\t\t\t\t\t\tif (dp[k][pos] > dist1) {\n\t\t\t\t\t\t\tdp[k][pos] = dist1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tmaxn = min(dp[i][(1 << N) - 1] + x[0][i], maxn);\n\t}\n\tif (maxn == INF) { maxn = -1; }\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nmain(){\n  int v,e;\n  cin>>v>>e;\n  WG<int> es(v);\n  vector<vector<int>> dp((1<<v),vector<int>(v,INF));\n  vector<int> cost(v,INF);\n\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    es[s].PB(edge<int>(t,d));\n    es[t].PB(edge<int>(s,d));\n    if(t==0){\n      cost[s]=min(cost[t],d);\n    }\n  }\n  dp[1][0]=0;\n  rep(i,(1<<v)){\n    rep(j,v){\n      if(dp[i][j]==inf) continue;\n      for(auto et:es[j]){\n        if(i&(1<<et.to)) continue;\n        dp[i|(1<<et.to)][et.to]=min(dp[i|(1<<et.to)][et.to],dp[i][j]+et.cost);\n      }\n    }\n  }\n\n  int ans=INF;\n  rep(i,v){\n    ans=min(ans,dp[(1<<v)-1][i]+cost[i]);\n  }\n\n  cout<<((ans==INF)?-1:ans)<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvvi cost(v,vi(v,inf));\n\twhile(e--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcost[a][b]=c;\n\t}\n\tvvi dp(1<<v,vi(v,inf));\n\tdp[(1<<v)-1][0]=0;\n\tfor(int i=(1<<v)-2;i>=0;i--){\n\t\trep(j,v){\n\t\t\trep(k,v){\n\t\t\t\tif(!(i>>k&1))\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i|(1<<k)][k]+cost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]==inf)cout<<-1<<endl;\n\telse cout<<dp[0][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint d[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint tsp(int start, int visited_flag, int city_num){\n    int rtn = MAX;\n    //??¨????????????????¨???????????????´???\n    if(visited_flag == (1 << city_num) - 1){\n        if (d[start][0] == -1) {\n            return rtn;\n        }else{\n            return d[start][0];\n        }\n    }\n    \n    for (int i = 0; i < city_num; i++) {\n        //??????????¨???????????????§????????´???\n        if (\n            !(visited_flag & (1 << i))\n            &&\n            d[start][i] != -1\n            )\n        {\n            rtn = min(\n                      rtn,\n                      d[start][i] + tsp(i, visited_flag | (1 << i), city_num)\n                      );\n        }\n    }\n    \n    return rtn;\n}\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(d, -1, sizeof(d));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        d[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1, V);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int MAX_N = 15;\nint dist[MAX_N][MAX_N];  // dist[i][j] i から j への距離\n\n// dp[i][j]: 状態iでjにいるときの最短経路\n// 状態iはビットで管理: 00011->点0と点1は通貨済\nint dp[1 << MAX_N][MAX_N];\nint n, m;\nconst int inf = 1001001;\n\n// 巡回セールスマン問題\nint dfs(int s, int v) {\n  if (dp[s][v] >= 0) return dp[s][v];\n  if (s == (1 << n) - 1 && v == 0) return dp[s][v] = 0;\n\n  int ans = inf;\n  rep(u, n) {\n    // uに行ったことがない場合\n    if (!(s >> u & 1)) ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n  }\n\n  return dp[s][v] = ans;\n}\n\nint main() {\n  cin >> n >> m;\n  memset(dp, -1, sizeof(dp));\n  // パスがない場合は距離がinfになる\n  fill(dist[0], dist[0] + MAX_N * MAX_N, inf);\n\n  rep(i, m) {\n    int f, t, c;\n    cin >> f >> t >> c;\n    dist[f][t] = c;\n  }\n  int ans = dfs(0, 0);\n  ans = ans == inf ? -1 : ans;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define MAX_N 15\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint V,E;\nll K;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint color[MAX_N];\n\nvoid solve(){\n\tfor(int S=0;S<1<<V;S++){\n\t\tfill(dp[S],dp[S]+V,INF);\n\t}\n\tdp[(1<<V)-1][0] = 0;\n\tfor(int S=(1<<V)-2;S>=0;S--){\n\t\tfor(int v=0;v<V;v++){\n\t\t\tfor(int u=0;u<V;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",dp[0][0]);\n}\n\n//dfsで塗る\nint dfs(int v,int a){\n\tcolor[v] = 1;\n\ta++;\n\tfor(int i=0;i<V;i++){\n\t\tif(d[v][i]!=INF && color[i]==0){\n\t\t\ta = dfs(i,a);\n\t\t}\n\t}\n\treturn a;\n}\n\n\nint main()\n{\n\tint s,t,dd;\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<=V;i++){\n\t\tfill(d[i],d[i]+V+1,INF);\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&dd);\n\t\td[s][t] = dd;\n\t}\n\t//printf(\"%d\\n\",dfs(0,0));\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <algorithm>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int inf=1<<30;\nconst double pi=acos(-1);\n\nint V,E;\nvector<vector<int> > G,dp;\n\nint func(int S,int v){\n\tif(dp[S][v]!=inf) return dp[S][v];\n\tif(S==(1<<V)-1&&v==0) return dp[S][v]=0;\n\tint tmp=inf-1;\n\tfor(int i=0;i<V;i++){\n\t\tif(G[v][i]==inf) continue;\n\t\tif(!(S>>i&1)) tmp=min(tmp,func(S|1<<i,i)+G[v][i]);\n\t}\n\treturn dp[S][v]=tmp;\n}\n\nint main(){\n\tcin>>V>>E;\n\tG=vector<vector<int> >(V,vector<int>(V,inf));\n\tfor(int i=0;i<E;i++){\n\t\tint s,t,d;\n\t\tcin>>s>>t>>d;\n\t\tG[s][t]=d;\n\t}\n\tdp=vector<vector<int> >(1<<V,vector<int>(V,inf));\n\tint ans=func(0,0);\n\tif(ans==inf-1) cout<<-1<<endl;\n\telse cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<int>> edge(v, vector<int>(v, INF));\n    rep(i, e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        edge[s][t] = d;\n    }\n\n    vector<vector<int>> cost(1 << v, vector<int>(v, INF));\n    vector<vector<int>> path(1 << v, vector<int>(v));\n    rep(i, v){\n        cost[0][i] = 0;\n    }\n    for(int s = 0; s < (1 << v); s++){\n        rep(i, v){\n            if(s != 0 && (s >> i) % 2 == 0){\n                continue;\n            }\n            rep(j, v){\n                if((s >> j) % 2 == 1 || edge[i][j] == INF){\n                    continue;\n                }\n                if(cost[s | (1 << j)][j] > cost[s][i] + edge[i][j]){\n                    cost[s | (1 << j)][j] = cost[s][i] + edge[i][j];\n                    path[s | (1 << j)][j] = i;\n                }\n            }\n        }\n    }\n\n    /*\n    rep(i, (1 << v)){\n        cout << bitset<7>(i) << \" \";\n        rep(j, v){\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    /*\n    int ans = INF;\n    rep(i, v){\n        int last;\n        if(ans > cost[(1 << v)-1][i] && cost[(1 << v)-1][i] != INF){\n            last = i;\n        }\n\n        if(cost[(1 << v)-1][i] == INF){\n            continue;\n        }\n        int s = (1 << v) - 1;\n        int first = i;\n        for(int j = 0; j < v - 1; j++){\n            int from = path[s][first];\n            s ^= 1 << first;\n            first = from;\n        }\n        if(ans > cost[(1 << v)-1][i] + edge[last][first]){\n            ans = cost[(1 << v)-1][i] + edge[last][first];\n        }\n    }\n    if(ans == INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    */\n    int ans = 0;\n    rep(i, v){\n        if(ans < cost[(1 << v) - 1][i]){\n            ans = cost[(1 << v) - 1][i];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<ll> > Adj_Mat;\n\n\nbool contain(int mask, int pos){\n\t  return ( mask & (1<<pos) ) != 0;\n}\n\nint main(){\n\n\t  // Input Graph\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_Mat G(V,vector<ll>(V,INT_MAX));\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t,d; cin >> s >> t >> d;\n\t\t\tG[s][t] = d;\n\t  }\n\n\t  ll ans = INT_MAX;\n\t  // Dynamic Programming for TSP\n\t  for(int st=0; st<V; st++){\n\n\t\t\tll dp[ (1<<V) ][ V ];\n\t\t\tfor(int i=0; i<(1<<V); i++) for(int j=0; j<V; j++) dp[i][j] = INT_MAX;\n\t\t\tdp[ 0 ][ st ] = 0;\n\n\t\t\tfor(int S=1; S<(1<<V); S++)\n\t\t\t\t  for(int v=0; v<V; v++)\n\t\t\t\t\t\tif( contain(S,v) )\n\t\t\t\t\t\t\t  for(int j=0; j<V; j++)\n\t\t\t\t\t\t\t\t\tif( contain(S,j) and v!=j)\n\t\t\t\t\t\t\t\t\t\t  dp[S][v] = min(dp[S][v], dp[S-(1<<v)][j] + G[j][v]);\n\t\t\tans = min(ans,dp[ (1<<V)-1 ][st]);\n\t  }\n\t  if( ans >= 1e+9 ) ans = -1;\n\t  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nint g[20][20];\nint dp[1<<15][15];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n)rep(j, n) g[i][j] = INT_MAX;\n    rep(i, m) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    rep(i, 1<<n)rep(j, n) dp[i][j] = INT_MAX;\n    int start = 0;\n    dp[1<<start][start] = 0;\n\n    rep(i, 1<<n) {\n        rep(j, n) {\n            if (i>>j & 1) {\n                rep(k, n) {\n                    dp[i][j] = min(dp[i][j], dp[i^(1<<j)][k] + g[k][j]);\n                }\n            }\n        }\n    }\n    int ans = INT_MAX;\n    rep(j, n) ans = min(ans, dp[(1<<n) - 1][j] + g[j][start]);\n    cout << (ans == INT_MAX ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000001\n#define ll long long\nusing namespace std;\n\nint main()\n{\n  ll V, E;\n  cin >> V >> E;\n  vector<vector<pair<ll, ll>>> edge(V);// to, cost\n  ll s, t, d;\n  for (ll i = 0; i < E; ++i)\n  {\n    cin >> s >> t >> d;\n    edge.at(s).push_back({t, d});\n  }\n  ll p2v = pow(2, V);\n  vector<vector<ll>> dp(p2v, vector<ll>(V, INF));// went, last\n  dp.at(1).at(0) = 0;\n  for (ll i = 1; i < p2v; ++i)\n  {\n    bitset<15> bs(i);\n    for (ll j = 0; j < V; ++j)\n    {\n      if (bs[j])\n      {\n        for (ll k = 0; k < edge.at(j).size(); ++k)\n        {\n          pair<ll, ll> next = edge.at(j).at(k);\n          if (bs[next.first])\n          {\n            continue;\n          }\n          ll ipow = i + pow(2, next.first);\n          dp.at(ipow).at(next.first) = min(dp.at(ipow).at(next.first), dp.at(i).at(j) + next.second);\n        }\n      }\n    }\n  }\n\n  ll ans = INF;\n  for (ll i = 0; i < V; ++i)\n  {\n    for (ll j = 0; j < edge.at(i).size(); ++j)\n    {\n      if (edge.at(i).at(j).first == 0)\n      {\n        ans = min(ans, dp.at(p2v - 1).at(i) + edge.at(i).at(j).second);\n      }\n    }\n  }\n  if (ans == INF)\n  {\n    cout << -1 << endl;\n  }\n  else\n  {\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint V, E;\nvector<vector<int>> dist(1001, vector<int>(1001, MOD));\nvector<vector<int>> dp((1<<16), vector<int>(16, MOD));\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tcin >> V >> E;\n\trep(i, E) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tdist[s][t] = d;\n\t}\n\n\tdp[0][0] = 0;\n\tfor(int S = 0; S < (1 << V); S++) {\n\t\trep(prev, V) {\n\t\t\trep(now, V) {\n\t\t\t\tif((S & (1 << now)) == 0) {\n\t\t\t\t\tchmin(dp[S|(1<<now)][now], dp[S][prev] + dist[prev][now]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[(1<<V)-1][0];\n\tif(ans == MOD) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"../lib/set.hpp\"\n\n#ifndef COMPRO_SET\n#define COMPRO_SET\n\nclass Set {\nprivate:\n  int val;\n\npublic:\n  Set(const int S) : val(S) {}\n\n  bool operator==(const Set rhs) const { return val == rhs.val; }\n\n  Set complement() const { return Set(~val); }\n\n  Set intersection(const Set T) const { return Set(val & T.val); }\n\n  Set unionSet(const Set T) const { return Set(val | T.val); }\n\n  Set differenceSet(const Set T) const { return intersection(T.complement()); }\n\n  bool has(const int i) const { return unionSet(toSet(i)) == *this; }\n\n  int count() const { return __builtin_popcount(val); }\n\n  int toInt() const { return val; }\n\n  static Set toSet(int i) { return Set(1 << i); }\n};\n\n#endif\n#line 1 \"../lib/template.hpp\"\n\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n\nusing namespace std;\n\n#line 3 \"tmp.cpp\"\n\nstruct edge {\n  int to;\n  int cost;\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int v, e;\n  cin >> v >> e;\n\n  vector<vector<edge>> g(v);\n\n  REP(i, e) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g[s].push_back({t, d});\n  }\n\n  int INF = 1e9;\n  vector<vi> dp((1 << v), vi(v, INF));\n\n  dp[(1 << v) - 1][0] = 0;\n  for (int s = (1 << v) - 2; s >= 0; s--) {\n    REP(i, v) {\n      for (const auto u : g[i]) {\n        Set S(s);\n        if (!S.has(u.to)) {\n          Set nS = S.unionSet(Set::toSet(u.to));\n          dp[s][i] = min(dp[s][i], dp[nS.toInt()][u.to] + u.cost);\n        }\n      }\n    }\n  }\n\n  cout << (dp[0][0] == INF ? -1 : dp[0][0]) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX_V = 16;\nconst int MAX_E = (1<<MAX_V); \nconst int INF = INT_MAX / 3; \nconst int NONE = -1; \n\nint V, E;\nint dist[MAX_V][MAX_V];\nint dp[MAX_E][MAX_V]; //?????£?????????????????????is_visit??§????????¨???????????????v?????§???????????????\n\n// v: ?????¨????????????is_visit: ?????£??????????????????\nint dfs(int v, int is_visit) {\n\tif(dp[is_visit][v] != NONE) return dp[is_visit][v];\t\n\tif(is_visit == (1<<V)-1) return dist[v][0];\t\n\tdp[is_visit][v] = INF;\n\n\trep(i, V) {\n\t\tif(is_visit & (1<<i)) continue;\n\t\tdp[is_visit][v] = min(dfs(i, (is_visit | (1<<i))) + dist[v][i], dp[is_visit][v]);\n\t}\n\treturn dp[is_visit][v];\n}\n\nint main() {\n\tcin >> V >> E;\t\t\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INF);\n\tfill_n((int *)dp, sizeof(dp) / sizeof(int), NONE);\n\tint s, t, d;\n\trep(i, E) {\n\t\tcin >> s >> t >> d;\n\t\tdist[s][t] = d;\n\t}\n\n\tint is_visit = 0;\n\tint ans = dfs(0, (is_visit | 1));\n\n\tcout << ((ans == INF) ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 9999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst int M = 20;\nWeight best[1<<M][M];\nint    prev[1<<M][M];\nvoid buildPath(int S, int i, vector<int> &path) {\n  if (!S) return;\n  buildPath(S^(1<<i), prev[S][i], path);\n  path.push_back(i);\n}\nWeight shortestHamiltonCycle(Matrix w, vector<int> &path) {\n  int n=w.size();\n  int N = 1 << n;\n  REP(S,N) REP(i,n) best[S][i] = INF;\n  best[0][0] = 0;\n  REP(S,N) REP(i,n) REP(j,n) if (!(S&(1<<j)))\n    if (best[S|(1<<j)][j] > best[S][i] + w[i][j])\n      best[S|(1<<j)][j] = best[S][i] + w[i][j],\n      prev[S|(1<<j)][j] = i;\n  //int t = min_element(best[N-1], best[N-1]+n) - best[N-1];\n  //path.clear(); buildPath(N-1, t, path);\n  return best[N-1][0]==INF ? -1 : best[N-1][0];\n}\n\nint main(){\n\tint V,E,s,t,d;\n\tscanf(\"%d%d\",&V,&E);\n\tMatrix m(V,Array(V));\n\tfor(s=0;s<V;s++)for(t=0;t<V;t++)if(s!=t)m[s][t]=INF;\n\tvector<int>path;\n\tfor(;E--;)scanf(\"%d%d%d\",&s,&t,&d),m[s][t]=d;\n\tprintf(\"%d\\n\",shortestHamiltonCycle(m,path));\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"DataStructure.h\"\n#include <map>\n#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <math.h>\n#include <string.h>\nusing namespace std;\nconst int num = 15, num1 = 10000000;\ntypedef long long int ll;\ntypedef pair<int, int> p;\nconst int INF = 20000000;\nint dp[1 << num][num], m[num][num];\nint n, e;\nint solve(int s, int v) {\n\tif (s == (1 << n) - 1 && v == 0) {\n\t\treturn dp[s][v] = 0;\n\t}\n\tif (dp[s][v] >= 0)\n\t\treturn dp[s][v];\n\tint res = INF;\n\tfor (int t = 0; t < n; t++)\n\t\tif (!(s >> t & 1))\n\t\t\tres = min(res, m[v][t] + solve(s | 1 << t, t));\n\treturn dp[s][v] = res;\n}\nint main() {\n\tcin >> n >> e;\n\tfill(m[0], m[num], INF);\n\tfill(dp[0], dp[1 << num], -1);\n\tfor (int i = 0; i < e; i++) {\n\t\tint  s, t, u;\n\t\tcin >> s >> t >> u;\n\t\tm[s][t] = u;\n\t}\n\tif (solve(0, 0) >= INF)\n\t\tcout << -1 << endl;\n\telse cout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#pragma region Debug\ntemplate <typename T>\nvoid view(const std::vector<T> &v)\n{\n    for (const auto &e : v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv)\n{\n    for (const auto &v : vv)\n    {\n        view(v);\n    }\n}\n#pragma endregion\n#pragma region chminmax\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#pragma endregion\n\nint main()\n{\n    // 出発点に戻らなきゃいけない！\n    // 気づかず時間を溶かした\n\n    int INF = 1 << 25;\n\n    int v, e;\n    cin >> v >> e;\n    vector<vector<int>> g(v, vector<int>(v, INF));\n    rep(i, e)\n    {\n        int f, t, c;\n        cin >> f >> t >> c;\n        g[f][t] = c;\n    }\n    vector<vector<int>> dp(1LL << v, vector<int>(v, INF));\n    // dp[0][0] = 0;\n    dp[1][0] = 0;\n\n    rep(i, 1LL << v)\n    {\n        rep(j, v)\n        {\n            // Is node j contained in current set i?\n            bool in = (i & (1LL << j)) != 0LL;\n\n            if (!in)\n                continue;\n\n            // generate set without j\n            ll prev = i ^ (1LL << j);\n\n            rep(f, v)\n            {\n                // is f in prev?\n                bool inPrev = ((1LL << f) & prev) != 0LL;\n\n                if (!inPrev)\n                    continue;\n\n                if (g[f][j] == -1)\n                    continue;\n\n                chmin(dp[i][j], dp[prev][f] + g[f][j]);\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, v)\n    {\n        chmin(ans, dp[(1LL << v) - 1][i] + g[i][0]);\n    }\n\n    if (ans == INF)\n        ans = -1;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\nusing namespace std;\nusing ll = long long;\nusing Graph = vector<vector<int>>;\nconst ll MOD = 1000000007;\nconst ll INF = 10000000000000000;\nvector<int> x4 = {0, 1, 0, -1}, x8 = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> y4 = {1, 0, -1, 0}, y8 = {1, 1, 0, -1, -1, -1, 0, 1};\ntemplate<class T> struct edge { int from, to; T cost;};\ntemplate<class T> inline bool chmin(T& a, T b){if (a>b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b){if (a<b){a = b; return true;}return false;}\ntemplate<class T> inline T powerM(T a,T b){if (b==0) return 1;\nT tmp = powerM(a,b/2); if (b%2==0) return tmp*tmp%MOD; else return tmp*tmp%MOD*a%MOD; }\ntemplate<class T> inline T power(T a,T b,T m){ if (b==0) return 1;\n  T tmp = power(a,b/2,m); if (b%2==0) return tmp*tmp%m; else return tmp*tmp%m*a%m; }\ntemplate<class T> inline T gcd(T a, T b){if (b==0) return a; return gcd(b, a%b);}\ntemplate<class T> inline T lcm(T a, T b){return a / gcd(a,b) * b;}\n// ax+by=gcd(a,b)を解く\ntemplate<class T> inline T extgcd(T a,T b,T &x,T &y){if (b==0){x=1; y=0; return a;} T d=extgcd(b,a%b,y,x); y -= a/b*x; return d;}\nvoid hey(){ cout <<\"hey\" <<endl; }\n\n\nint N,M;\nvector<vector<ll>> dist(15, vector<ll>(15, INF));\n// dist[i][j] := 辺 i -> j の距離\nvector<vector<ll>> dp(1<<15, vector<ll>(15, INF));\n// dp[S][v] := 今までに訪れた頂点集合 S と今いる v に対して、それ以降の最短距離。dp[0][0]\n////  := それまでの最短距離。dp[(1<<M)-1][0]\n\nvoid input(){\n  cin >>N >>M;\n  rep(i, M){\n    int s,t,d; cin >>s >>t >>d;\n    dist[s][t] = d;\n  }\n}\n\nint main() {\n  input();\n  // dp[0][0]を求めたい\n  dp[(1<<N)-1][0] = 0;\n  \n  for (int S=(1<<N)-1; S>=0; S--){\n    for (int nv=0; nv<N; nv++){\n      if (S & (1<<nv)) continue;\n      for (int v=0; v<N; v++){\n        // if (S & (1<<v)){\n          chmin(dp[S][v], dp[S | (1<<nv)][nv] + dist[v][nv]);\n        // }\n      }\n    }\n  }\n\n  ll res = dp[0][0];\n  cout <<(res == INF ? -1 : res) <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 99999999\n#define INF_M 2147483647\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint dist[20][20];\nint dp[1 << 20][20];\nint V,E;\nint s,t,d;\n\nint rec(int S, int v) {\n    if(dp[S][v] >= 0) return dp[S][v];\n    if(S == (1 << V) - 1 && v == 0) return dp[S][v] = 0;\n\n    int res = INF;\n    for(int r = 0; r < V; r++) {\n        if(!(S & 1 << r)) {\n            res = min(res, rec(S | 1 << r, r) + dist[v][r]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    cin >> V >> E;\n    rep(i,0,20) rep(j,0,20) dist[i][j] = INF;\n\n    rep(i,0,E) {\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    memset(dp, -1, sizeof(dp));\n\n    int ans = rec(0,0);\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : dpl_2a.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint edge[15][15], v, e, dp[15][1 << 15];\n\tcin >> v >> e;\n\tmemset(edge,-1,sizeof(edge));\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i = 0;i < v;i++){\n\t\tdp[i][0] = 0;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tfor(int i = 0;i < (1 << v);i++){\n\t\tfor(int j = 0;j < v;j++){ // now place\n\t\t\tif(dp[j][i] != -1){\n\t\t\t\tfor(int k = 0;k < v;k++){ // next place\n\t\t\t\t\tif((i >> k & 1) == 0 && edge[j][k] != -1 && (dp[k][i | (1 << k)] == -1 || dp[k][i | (1 << k)] < dp[j][i] + edge[j][k])){\n\t\t\t\t\t\tdp[k][i | (1 << k)] = dp[j][i] + edge[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = -1;\n\tfor(int i = 1;i < v;i++){\n\t\tif(ans == -1 || dp[i][(1 << v) - 1] < ans){\n\t\t\tans = dp[i][(1 << v) - 1];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\nstruct Edge {ll s,t,d;};\ntypedef vector<vector<Edge>> Graph;\n\nint main(){\n  ll V,E; cin>>V>>E;\n  Graph G(V);\n  REP(i,E) {Edge e; cin>>e.s>>e.t>>e.d; G[e.t].PB(e);}\n  vvi dist((1ll<<V),vi(V,INF));\n  dist[1][0]=0;\n\n  FOR(i,2,(1ll<<V)) REP(j,V) {\n    if((1ll<<j)&i) for(Edge e:G[j]) dist[i][j]=min(dist[i][j],dist[(1ll<<j)^i][e.s]+e.d);\n  }\n\n  ll ans=INF;\n  for(Edge e:G[0]) ans=min(ans,dist[(1ll<<V)-1][e.s]+e.d);\n  if(ans==INF) ans=-1;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\ntypedef long long LL;\nconst int Max_Num=16;\nconst int INF=1000000;\n\nint V, E;\nint dist[Max_Num][Max_Num];\nint dp[1<<Max_Num][Max_Num];\n\nint bitDP(int start, int bit, int v){\n  if(bit==((1<<V)-1)&&dist[v][start]==INF) return dp[bit][v]=INF;\n  if(dp[bit][v]!=-1) return dp[bit][v];\n  if(bit==(1<<start)) return dp[bit][start]=0;\n  int bitprev=bit-(1<<v);\n  int res=INF;\n  rep(u,V){\n    if(!(bitprev&(1<<u))||dist[u][v]==INF) continue;\n    res=min(res,bitDP(start, bitprev, u)+dist[u][v]);\n  }\n  if(bit==((1<<V)-1)) return dp[bit][v]=res+dist[v][start];\n  else return dp[bit][v]=res;\n}\n\nint main(){\n  cin >> V >> E;\n  rep(i,V){\n    rep(j,V) dist[i][j]=INF;\n  }\n  rep(i,E){\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t]=d;\n  }\n  int ans=INF;\n  rep(start,V){\n    rep(i,1<<V){\n      rep(j,V) dp[i][j]=-1;\n    }\n    rep(v,V) ans=min(ans,bitDP(start,((1<<V)-1),v));\n  }\n  if(ans==INF) cout << -1 << endl;\n  else cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {int to,cost;};\n\nconst int INF = 1001001001;\n\nvector<edge> g[16];\nint dp[1<<15][16][16];\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    for(int i=0;i<e;i++){\n        int s,t,d;\n        cin>>s>>t>>d;\n        g[t].push_back((edge){s,d});\n    }\n    for(int bit=0;bit<1<<15;bit++)for(int i=0;i<16;i++)for(int j=0;j<16;j++){\n        dp[bit][i][j]=INF;\n        if(bit==0&&i==j)dp[bit][i][j]=0;\n    }\n    for(int bit=1;bit<1<<v;bit++){\n        for(int u=0;u<v;u++){\n            if(!(bit>>u&1))continue;\n            for(int a=0;a<v;a++){\n                if(bit!=(1<<v)-1&&(u==a||bit>>a&1))continue;\n                for(auto x:g[u]){\n                    dp[bit][u][a]=min(dp[bit][u][a],dp[bit&~(1<<u)][x.to][a]+x.cost);\n                }\n            }\n        }\n    }\n    int ans=INF;\n    for(int u=0;u<v;u++){\n        ans=min(ans,dp[(1<<v)-1][u][u]);\n    }\n    if(ans==INF)ans=-1;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ntemplate<typename T = long long>inline T rand_i(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\n\n// ??¨?????????????????????????????????????????????????±??????????\nvector<int> tsProblem(int n, const vector<vector<ll>>& dist) {\n    typedef ll dist_T;\n    typedef unsigned long long ull;\n\n    if (n <= 1)\n        return { 0 };\n    if (n == 2)\n        return { 0, 1 };\n\n    vector<vector<dist_T>> dp;\n    ull bit;\n\n    // initialize\n    dp.resize(n);\n    for (auto &v : dp)\n        v.resize(1 << n),\n        fill(ALL(v), (dist_T)5e15);\n\n    // bitdp\n    dp[0][1] = 0;\n    iterate(bit_i, 1, (1 << n) - 1) {\n        bit = bit_i;\n\n        repeat(from, n) {\n            if (!(bool)(bit&(1ull << from))) continue;\n            dist_T pt = dp[from][bit_i];\n\n            repeat(to, n) {\n                if ((bool)(bit&(1ull << to))) continue;\n                dp[to][bit_i | (1ull << to)] = min(dp[to][bit_i | (1 << to)], pt + dist[from][to]);\n            }\n        }\n    }\n    // ????°??????¢???\n    dist_T best = 5e15;\n    int tail = 0;\n    repeat(i, n)\n        if (dp[i][(1 << n) - 1] + dist[i][0] < best)\n            best = dp[i][(1 << n) - 1] + dist[i][0], tail = i;\n\n    // ??????\n    vector<int> tourist; tourist.reserve(n);\n    bit = (1ull << n) - 1ull;\n    repeat(z, n - 1) {\n        ull b = bit;\n        tourist.push_back(tail);\n        bit ^= bit & (1ull << tail);\n        ull c = bit;\n\n        repeat(nxt, n) {\n            if ((bit&(1ull << (ull)nxt)) && abs(dp[tail][b] - dp[nxt][c] - dist[nxt][tail]) == 0) {\n                tail = nxt;\n                break;\n            }\n        }\n    }\n    tourist.push_back(0);\n    reverse(ALL(tourist));\n    return tourist;\n}\n\nint main() {\n\n    int n, m;\n    scanner >> n >> m;\n\n    vector<vector<ll>> dist;\n    repeat(i, n)\n        dist.emplace_back(n);\n\n    repeat(i, n) {\n        repeat(j, n) {\n            dist[i][j] = int(1e7);\n        }\n    }\n\n    repeat(i, m) {\n        int s, t, d;\n        scanner >> s >> t >> d;\n        minset(dist[s][t], ll(d));\n    }\n\n    auto ans = tsProblem(n, dist);\n\n    ll len = 0;\n    {\n        int p = ans.back();\n        for (int t : ans)\n            len += dist[p][t],\n            p = t;\n    }\n\n    if (len >= ll(1e7))\n        cout << -1 << endl;\n    else\n        cout << len << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nstatic const ll INF = 1e15;\n\nconst ll mod = 1000000007;\n\nint v, e;\nvector<vector<ll>> g;\nvector<vector<ll>> dp;\n\nll dfs(ll state, ll current, ll start) {\n\tstate |= (1LL << current);\n\tif (dp[state][current] != -1) {\n\t\treturn dp[state][current];\n\t}\n\tif (state == (1LL << v) - 1) {\n\t\tdp[state][current] = g[current][start];\n\t\treturn g[current][start];\n\t}\n\tll dist = INF;\t\n\tfor (int i = 0; i < v; i++) {\n\t\tif (g[current][i] == INF) continue;\n\t\tif (state & (1LL << i)) continue;\n\t\tll d = g[current][i] + dfs(state, i, start);\n\t\tdist = min(dist, d);\n\t}\n\tdp[state][current] = dist;\n\treturn dist;\n}\n\nint main(void)\n{\n\tcin >> v >> e;\n\tg.resize(v, vector<ll>(v, INF));\n\trep(i, e) {\n\t\tint s, t, d;\n\t\tcin >> s >> t >> d;\n\t\tg[s][t] = d;\n\t}\t\n\tll dist = INF;\n\tfor (int i = 0; i < v; i++) {\n\t\tdp.assign(1LL << v, vector<ll>(v, -1));\n\t\tll d = dfs((1LL << i), i, i);\n\t\tdist = min(d, dist);\n\t}\n\tif (dist == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << dist << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int V_MAX = 15;\n\nint V, E;\nint dp[1 << V_MAX][V_MAX];\nint dist[V_MAX][V_MAX];\n\nint main() {\n    fill(dp[0], dp[(1<<V_MAX)-1]+V_MAX, INF);\n    fill(dist[0], dist[V_MAX-1]+V_MAX, INF);\n\n    cin >> V >> E;\n    int from, to, cost;\n    for(int i=0;i<E;++i) {\n        cin >> from >> to >> cost;\n        dist[from][to] = cost;\n    }\n\n    dp[0][0] = 0;\n    for(int bit=0;bit<(1<<V);++bit) {\n        for(int i=0;i<V;++i) {\n            if(dp[bit][i] == INF || (bit && !(bit & (1<<i)))) continue;\n            for(int j=0;j<V;++j) {\n                if((bit & (1<<j)) || dist[i][j] == INF) continue;\n                if(dp[bit | (1<<j)][j] > dp[bit][i] + dist[i][j]) {\n                    dp[bit | (1<<j)][j] = dp[bit][i] + dist[i][j];\n                }\n            }\n        }\n    }\n    cout << (dp[(1<<V)-1][0] == INF ? -1 : dp[(1<<V)-1][0]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <climits>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\n#define MAX_V 16\nint adjMat[MAX_V][MAX_V];\nbool visited[MAX_V][1<<MAX_V];//visited存的並非節點是否有訪問過,而是這個?態是否有出現過\nint dp[MAX_V][1<<MAX_V];//DP表格,第一個中括號代表目前所在的點\n//第二個中括號代表目前節點的?態(ex:0101011,表示1,3,5節點還沒走過,可以直接用bitwise操作來判斷?態)\n//因為DP表格是N*2^N次方,所以時間複雜度就是O(N*2^N)\nint v,e;\n\nconst char *byte_to_binary(int x)\n{\n    static char b[9];\n    b[0] = '\\0';\n\n    int z;\n    for (z = 128; z > 0; z >>= 1)\n    {\n        strcat(b, ((x & z) == z) ? \"1\" : \"0\");\n    }\n\n    return b;\n}\nint TSP(int at,int state)\n{\n    // printf(\"at=%d,state=%s\\n\",at, byte_to_binary(state));\n    if(state == (1<<v)-1){ //全部的?態都走完惹\n        visited[at][state]=true;\n        return dp[at][state];\n    }\n    if(visited[at][state]) //出現過的?態,直接回傳結果\n        return dp[at][state];\n    visited[at][state]=true;\n    int ans = INT_MAX>>1;\n    int cost;\n    for(int i=0;i<v;i++){\n        //state&(1<<i)==0表示判斷右邊數過來第i個bit是否為0,用來判斷該節點是否有走過\n        //state|(1<<i)表示將該節點設成走過\n        if(adjMat[at][i]!=-1 && (state & (1<<i))==0){\n            // printf(\"at=%d,i=%d\\n\",at,i);\n            cost = TSP(i,state|(1<<i)) + adjMat[at][i];//往?種可以走的路線都走下去\n            // printf(\"at=%d,i=%d,cost=%d\\n\",at,i,cost);\n            ans = min(ans,cost);//求出最小?\n        }\n    }\n    return dp[at][state] = ans;\n}\nbool vis[16];\nint vcnt;\nvoid DFS(int u)\n{\n    vis[u]=true;\n    vcnt++;\n    for(int j=0;j<v;j++){\n        if(!vis[j]&&adjMat[u][j])\n            DFS(j);\n    }\n    return ;\n}\n\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d %d\",&v,&e)){\n        memset(adjMat,-1,sizeof(adjMat));\n        for(int i=0;i<e;i++){\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            adjMat[u][v]=w;\n        }\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        int ans = TSP(0,0);\n        memset(vis,0,sizeof(vis));\n        vcnt = 0;\n        DFS(0);\n        if(vcnt!=v||ans==INT_MAX>>1)\n            puts(\"-1\");\n        else\n            printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\n#include<list>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\nconst int MAX_N = 16;\nint n;\nint dp[1 << MAX_N][MAX_N];\nint d[MAX_N][MAX_N];\nvoid solve() {\n    rep(S, (1 << n)) {\n        fill(dp[S], dp[S] + n, inf);\n    }\n    dp[(1 << n) - 1][0] = 0;\n    for (int S = (1 << n) - 2; S >= 0; --S) {\n        rep(v, n) {\n            //if (!(S >> v & 1)) continue;\n            rep(u, n) {\n                if (!(S >> u & 1)) {\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + d[v][u]);\n                }\n            }\n        }\n    }\n    if (dp[0][0] != inf) cout << dp[0][0] << endl;\n    else cout << -1 << endl;\n}\nint main() {\n    int m;\n    cin >> n >> m;\n    rep(i, n) rep(j, n) d[i][j] = inf;\n    rep(i, m) {\n        int s, t, dd;\n        cin >> s >> t >> dd;\n        d[s][t] = dd;\n    }\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define print(x)cout<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\n\n//dp[S][v]:= 頂点集合Sを訪れて現在位置がvのときの、後に通る最短経路長\nll dp[1<<16][16];\nll dist[16][16];\nint n,e;\nconst ll INF = 100100100;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nll rec(int S, int v){\n  if(dp[S][v] != -1) return dp[S][v];\n\n  //全て訪れている場合\n  if(S == (1<<n)-1 && v == 0){\n    return dp[S][v] = 0;\n  }\n\n  ll res = INF;\n  //頂点集合からvを抜く\n  rep(u,n){\n    if(!(S >> u & 1)){\n    //最後にvを辿るとしたときに、コストが最小となる頂点uを探索\n    mins(res,rec(S|1<<u,u)+dist[v][u]);\n    }\n  }\n\n  return dp[S][v] = res;\n}\n\n\nint main() {\n  //rep(i,n)rep(j,n)cin >> dist[i][j];\n  cin >> n >> e;\n  Fill(dp,-1);\n  Fill(dist,INF);\n\n  rep(i,e){\n    int s,t,d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n  ll res = INF;\n  res = rec(0,0);\n  if(res == INF)res = -1;\n  print(res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif __GNUC__\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\nclass DGraph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n\n    DGraph(size_t n = 1) :n(n), vertex_to(n), vertex_from(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[(size_t)from].emplace_back(to);\n        vertex_from[(size_t)to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n        vertex_from.resize(_n);\n    }\n};\n\n\nclass GraphE {\npublic:\n    typedef int W_T;\n    struct Edge {\n        int u, v;\n        W_T value;\n        Edge(int from = 0, int to = 0, W_T value = 0) :u(from), v(to), value(value) {}\n        inline int to(int _v) const { return _v == v ? u : v; }\n    };\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<Edge> edges;\n\n    GraphE(int n = 1) :n(n), vertex_to(n) { }\n\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n    void connect(int from, int to, W_T val = 0) {\n        vertex_to[(size_t)from].push_back((int)edges.size());\n        vertex_to[(size_t)to].push_back((int)edges.size());\n        edges.emplace_back(from, to, val);\n    }\n};\n\nclass Graph2d {\npublic:\n    typedef ll W_T;\n    size_t n;\n    vector<W_T> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline W_T& at(int y, int x) { return matrix[y*n + x]; }\n    inline W_T& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline W_T at(int y, int x) const { return matrix[y*n + x]; }\n    inline W_T operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, W_T dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, W_T dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\n\n\nvector<int> tsProblem(int n, const Graph2d& graph) {\n    typedef ll dist_T;\n    typedef unsigned long long ull;\n\n    if (n <= 1)\n        return { 0 };\n    if (n == 2)\n        return { 0, 1 };\n\n    vector<vector<dist_T>> dp;\n    ull bit;\n\n    // initialize\n    dp.resize(n);\n    for (auto &v : dp)\n        v.resize(1 << n),\n        fill(ALL(v), (dist_T)5e15);\n\n    // bitdp\n    dp[0][1] = 0;\n    iterate(bit_i, 1, (1 << n) - 1) {\n        bit = bit_i;\n\n        repeat(from, n) {\n            if (!(bool)(bit&(1ull << from))) continue;\n            dist_T pt = dp[from][bit_i];\n\n            repeat(to, n) {\n                if ((bool)(bit&(1ull << to))) continue;\n                dp[to][bit_i | (1ull << to)] = min(dp[to][bit_i | (1 << to)], pt + graph(from, to));\n            }\n        }\n    }\n    // ????°??????¢???\n    dist_T best = 5e15;\n    int tail = 0;\n    repeat(i, n)\n        if (dp[i][(1 << n) - 1] + graph(i, 0) < best)\n            best = dp[i][(1 << n) - 1] + graph(i, 0), tail = i;\n\n    // ??????\n    vector<int> tourist; tourist.reserve(n);\n    bit = (1ull << n) - 1ull;\n    repeat(z, n - 1) {\n        ull b = bit;\n        tourist.push_back(tail);\n        bit ^= bit & (1ull << tail);\n        ull c = bit;\n\n        repeat(nxt, n) {\n            if ((bit&(1ull << (ull)nxt)) && abs(dp[tail][b] - dp[nxt][c] - graph(nxt, tail)) == 0) {\n                tail = nxt;\n                break;\n            }\n        }\n    }\n    tourist.push_back(0);\n    reverse(ALL(tourist));\n    return tourist;\n}\n\nint main() {\n\n    int n, m;\n    scanner >> n >> m;\n\n    Graph2d dist(n);\n\n    repeat(i, n)\n        repeat(j, n)\n            dist(i, j) = ll(1e7);\n\n\n    repeat(i, m) {\n        int s, t, d;\n        scanner >> s >> t >> d;\n        minset(dist(s, t), ll(d));\n    }\n\n    auto ans = tsProblem(n, dist);\n\n    ll len = 0;\n    {\n        int p = ans.back();\n        for (int t : ans)\n            len += dist(p,t)\n            p = t;\n    }\n\n    if (len >= ll(1e7))\n        cout << -1 << endl;\n    else\n        cout << len << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<vector<ll> > Adj_Mat;\n\n\nbool contain(int mask, int pos){\n\t  return ( mask & (1<<pos) ) != 0;\n}\n\nint main(){\n\n\t  // Input Graph\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_Mat G(V,vector<ll>(V,INT_MAX));\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t,d; cin >> s >> t >> d;\n\t\t\tG[s][t] = d;\n\t  }\n\n\t  ll ans = INT_MAX;\n\t  // Dynamic Programming for TSP\n\t  for(int st=0; st<V; st++){\n\n\t\t\tll dp[ (1<<V) ][ V ];\n\t\t\tfor(int i=0; i<(1<<V); i++) for(int j=0; j<V; j++) dp[i][j] = INT_MAX;\n\t\t\tdp[ 0 ][ st ] = 0;\n\n\t\t\tfor(int S=1; S<(1<<V); S++)\n\t\t\t\t  for(int v=0; v<V; v++)\n\t\t\t\t\t\tif( contain(S,v) )\n\t\t\t\t\t\t\t  for(int j=0; j<V; j++)\n\t\t\t\t\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S-(1<<v)][j] + G[j][v]);\n\t\t\tans = min(ans,dp[(1<<V)-1][st]);\n\t  }\n\t  if( ans >= 1e+9 ) ans = -1;\n\t  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define ld long double\n#define pb push_back\n#define eb emplace_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n#define Decimal(x) printf(\"%.10f\\n\", x) // 小数点を10桁まで表示\n// debug用\n#define PrintVec(x) for (auto elementPrintVec: x) { cout << elementPrintVec << \" \"; } cout << endl;\n#define debug(x) cerr << #x << \": \" << (x) << \"\\n\";\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<vector<int>>> vvvl;\ntypedef vector<PI> vpi;\ntypedef vector<vector<PI>> vvpi;\ntypedef vector<vector<vector<PI>>> vvvpi;\ntypedef vector<PLL> vpl;\ntypedef vector<vector<PLL>> vvpl;\ntypedef vector<vector<vector<PLL>>> vvvpl;\n\nint POWINT(int x, int n) {\n  int ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\nll POWLL(ll x, int n) {\n  ll ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\n// AOJ DPL_2_A\n// TSP\n\nconst int MAX_N = 15;\nconst int INF = 1e9+7;\nvvi dist(MAX_N, vi(MAX_N, INF));\nvvi dp(1 << MAX_N, vi (MAX_N, INF));\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int V, E;\n  cin >> V >> E;\n  int s, t, d;\n  rep(i, 0, E) {\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n\n  // どの点から初めても同じ\n  dp[(1 << V) - 1][0] = 0;\n\n  for (int S = (1 << V) - 2; S >= 0; S--) {\n    rep(v, 0, V) {\n      rep(u, 0, V) {\n        if (!((S >> u) & 1)) { // まだ訪れてない点\n          dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dist[v][u]);\n        }\n      }\n    }\n  }\n\n\n  if (dp[0][0] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[0][0] << endl;\n  }\n\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\n#define int long long\n#define double long double\n\n#define REP(i, b) for(int i = 0; i < (b); i++)\n#define REPS(i, b) for(int i = 1; i <= (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vpi = vector<pi>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint V, E;\nvvi d;\nvvi dp;\n\nint calc(int S, int v)\n{\n    int ret = INF;\n    if(dp[S][v] != -1) return dp[S][v];\n    REP(i, V) if(d[v][i] != INF && !(S & (1 << i))) chmin(ret, calc(S | (1 << i), i) + d[v][i]);\n    return dp[S][v] = ret;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    cin >> V >> E;\n    d.resize(V, vi(V, INF));\n    REP(i, E)\n    {\n        int s, t, dist; cin >> s >> t >> dist;\n        d[s][t] = dist;\n    }\n\n    dp.resize(1 << V, vi(V, -1));\n    dp[(1 << V)-1][0] = 0;\n    int ans = calc(0, 0);\n    cout << ((ans != INF) ? ans : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define inf (pow(10,9))\ntypedef pair<int,int> pii ;\n\nint V = 0 ;\nint E = 0 ;\nvector<pii> graph[20] ; // from,{to,cost}\nint dp[ 1 << 15 ][15] = {0} ;\n\nint DP(int bit ,int v )\n{\n    if(dp[bit][v] != inf)return dp[bit][v];\n\n    if ( bit == (1 << V) - 1 && v == 0 )return  dp[bit][v] = 0 ;\n    if ( bit == (1 << V))return dp[bit][v] = inf;\n\n    int res = inf - 1;\n    for( int i = 0; i < graph[v].size(); i++)\n    {\n        pii cmp = graph[v][i] ;\n        if ( !( (bit >> cmp.first) & 1 ) )\n        {\n            res = min( res, DP( bit | ( 1 << cmp.first ), cmp.first ) + cmp.second ) ;\n        }\n    }\n\n    return dp[bit][v] = res ;\n}\n\nint solve()\n{\n    for ( int i = 0 ; i < (1 << V) ; i++ )\n    {\n        for ( int j = 0 ; j < V ; j++ )\n        {\n            dp[i][j] = inf ;\n        }\n    }\n    return DP( 0, 0 ) ;\n}\n\nint main()\n{\n    cin >> V >> E ;\n    for ( int i = 0 ; i < E ; i++ )\n    {\n        int s ,t ,d ;\n        cin >> s >> t >> d ;\n        graph[s].push_back(pii(t,d));\n    }\n    if(solve() < (inf-1))printf(\"%d\\n\", solve()) ;\n    else puts(\"-1\");\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nWeight travel_salesman(const Graph &g) {\n    size_t V=g.size();\n    vector<vector<Weight>> dp(1<<V, vector<Weight>(V, INF));\n    dp[(1<<V)-1][0] = 0;\n\n    for (size_t s=(1<<V)-2; ~s; --s)\n        for (size_t v=0; v<V; ++v)\n            for (const Edge &e: g[v]) {\n                size_t u=e.dst;\n                if (!(1<<u & s))\n                    dp[s][v] = min(dp[s][v], dp[1<<u|s][u]+e.weight);\n            }\n\n    return dp[0][0]<INF? dp[0][0]:-1;\n}\n\nint main() {\n    size_t V, E;\n    scanf(\"%zu %zu\", &V, &E);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        Weight d;\n        scanf(\"%zu %zu %lld\", &s, &t, &d);\n\n        connect(g, s, t, d);\n    }\n\n    printf(\"%lld\\n\", travel_salesman(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\ntemplate<class T=ll> vector<vector<pair<ll, T>>> in_GraphWeighted(\n\tll nodeNum, ll edgeNum, bool isDirected){\n\tvector<vector<pair<ll, T>>> to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u;\n\t\tT c;\n\t\tcin >> v >> u >> c;\n\t\t//v--; u--;\n\t\tto[v].emplace_back(u, c);\n\t\tif (!isDirected) to[u].emplace_back(v, c);\n\t}\n\treturn std::move(to);\n}\n\n\nvoid solve()\n{\n\tll V, E;  cin >> V >> E;\n\tauto to = in_GraphWeighted(V, E, true);\n\n\tll M = 1LL<<V;\n\tvvvll dp(V, vvll(M, vll(V,INF)));\n\tauto Dp = [&](ll i, ll s, ll j)->ll&{\n\t\treturn dp[i][s][j];\n\t};\n\n\trep(s, 1, M-2){\n\t\tif (BitNum(s) == 1){\n\t\t\tll v = MSB(s);\n\t\t\tDp(v, s, v) = 0;\n\t\t}\n\t\t\n\t\tvll idxs = Bit2Idx(s);\n\t\tEACH(v, idxs){\n\t\t\tEACH(e, to[v]){\n\t\t\t\tll u; ll d;  tie(u, d) = e;\n\t\t\t\tif (Bit(s, u) == 1) continue;\n\n\t\t\t\tEACH(st, idxs){\n\t\t\t\t\tll ss = BitOn(s, u);\n\t\t\t\t\tchmin(Dp(st, ss, u), Dp(st, s, v)+d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = INF;\n\trep(v, 0, V-1){\n\t\tEACH(e, to[v]){\n\t\t\tll u = e.first;\n\t\t\tll c = e.second;\n\t\t\tll val = Dp(u, M-1, v) + c;\n\t\t\tchmin(ans, val);\n\t\t}\n\t}\n\tif (ans == INF) cout << -1 << '\\n';\n\telse cout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(ll i=0;i<(num);++i)\n#define FOR(i,c,num) for(ll (i)=(c);(i)<(num);++(i))\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=ll>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=ll,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return x;}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nbool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>\nbool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tauto V=in(),E=in();\n\tConnectNodeInfo connect(V);\n\tREP(i,E){\n\t\tint u=in(),v=in(),d=in();\n\t\tconnect.AddDirectionalConnection(u,v,d);\n\t}\n\n\tll minD = 1ll<<60;\n\tREP(n,V){\n\t\tint L=1<<V;\n\t\tvvll dp(L,vll(V,1ll<<60));\n\t\tdp[0][n] = 0;\n\n\t\tREP(i,L){\n\t\t\tREP(j,V){\n\t\t\t\tfor(auto& x:connect[j]){\n\t\t\t\t\t// 今jにいて次x.firstに行く\n\t\t\t\t\tif((i|1<<x.first)!=i) chmin(dp[i | 1<<x.first][x.first],dp[i][j]+x.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminD = min(minD,dp[L-1][n]);\n\t}\n\n\tout(minD>=1ll<<60 ? -1 : minD);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Traveling Salesman Problem\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1000000000\nint V, E;\nint d[15][15]; //g[i][j] : i??????j??????????????¢?????????????????????-1\nint dp[15][1<<15]; //dp[i][j] : i??????????????????0?????????????°??????¢(j?????¢????????£???????????±)\n\nint tsp(int v, int b){\n  //  cout<<v<<endl;\n  if(dp[v][b]>0)return dp[v][b]; //?????¢????????¨????????????\n  if(b==(1<<V)-1 && v==0)return dp[v][b]=0; //??¨?????????????????£?????????0????????£?????????\n  int ret=INF;\n  for(int i=0; i<V; i++){\n    if((b>>i)&1)continue; //??¢????????£???\n    if(d[v][i]==-1)continue; //????????????\n    ret = min(ret, tsp(i, b|(1<<i))+d[v][i]);\n  }\n  return dp[v][b]=ret;\n}\n\nint main(){\n  memset(d, -1, sizeof(d));\n  memset(dp, -1, sizeof(dp));\n  cin>>V>>E;\n  for(int i=0; i<E; i++){\n    int s, t, p;\n    cin>>s>>t>>p;\n    d[s][t]=p;\n  }\n  int min_d = tsp(0, 0);\n  if(min_d==INF)cout<<-1<<endl;\n  else cout<<min_d<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ll = long long;\n//https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#bit-dp\nconst int INF = 100000000;\nint V, E;\nint dp[(1<<15)+1][15][15];\nint dist[15][15];\n\n//int res = INF;\nint rec(int bit, int v,int start) {\n\tif (dp[bit][v][start] != -1) {\n\t\treturn dp[bit][v][start];\n\t}\n\t\n\tif (bit == 1<<v) {\n\t\tif (dist[start][v] == -1)return  INF;\n\t\treturn dp[bit][v][v] = dist[start][v];\n\t}\n\tint res = INF;\n\tint prev_bit = bit & ~(1 << v);\n\tfor (int u = 0; u < V; u++) {\n\t\tif (!(prev_bit&(1 << u)))continue;\n\t\tif ( (dist[u][v] != -1)&&res > rec(prev_bit, u,start) + dist[u][v]) {\n\t\t\t//cout << res << endl;\n\t\t\tres = rec(prev_bit, u,start) + dist[u][v];\n\t\t}\n\t}\n\treturn dp[bit][v][start] = res;\n}\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tmemset(dist, -1, sizeof(dist));\n\tmemset(dp, -1, sizeof(dp));\t\t\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, d;\n\t\tscanf(\"%d%d%d\", &s, &t, &d);\n\t\tdist[s][t] = d;\n\t}\n\tint result = INF;\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (result > rec((1 << V) - 1, v,v)) {\n\t\t\tresult = rec((1 << V) - 1, v,v);\n\t\t}\n\t}\n\tif (result == INF)printf(\"%d\\n\", -1);\n\telse //cout << result << endl;\n\t printf(\"%d\\n\", result);\n}\n//dp[1000][v]=0\n//dp[111][v]\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define ASC(vec) vec.begin(), vec.end()\t\t// 昇順ソート 例：sort(ASC(vec));\n#define DESC(vec) vec.rbegin(), vec.rend()\t// 降順ソート 例:sort(DESC(vec));\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define Rep(i, n) for(int i = 1; i < n; i++)\n\nconst int mod = 1000000007;\nconst int inf = (1 << 21);\nconst long long INF = 1LL << 60;\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vii = vector<pair<int, int>>;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nll LCM(ll a, ll b) { return (a * b) / GCD(a, b); }\nint round_int(int a, int b) { return (a + (b - 1)) / b; }\n\nconstexpr array<int, 9> dx = { 0, 1, 0, -1, -1, 1, 1, -1, 0 };\nconstexpr array<int, 9> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0 };\n\n// ──────────────────────────────────────────────────────────────────\n\nint main() {\n\tint v, e; cin >> v >> e;\n\n\tvvi dist(v, vi(v, -1));\n\trep(i, e) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\tdist[a][b] = c;\n\t}\n\n\tvvi dp(1 << v, vi(v, inf));\n\tdp[0][0] = 0;\n\n\trep(s, 1 << v) {\n\t\trep(now, v) {\n\t\t\trep(to, v) if(dist[now][to] != -1 && (s >> to & 1) == 0) {\n\t\t\t\tchmin(dp[s | 1 << to][to], dp[s][now] + dist[now][to]);\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << v) - 1][0] == inf) cout << -1 << endl;\n\telse cout << dp[(1 << v) - 1][0] << endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3 3\n0 1 1\n1 2 1\n0 2 1\n*/\n\n\n#include <bits/stdc++.h>\n#define MAX 20\n#define INF LLONG_MAX\nusing namespace std;\n\ntypedef long long int ll;\n\nll wt[MAX][MAX];\n\n// O based indexing is being used for ease\n// Node 1 will be represented at the Lowest Significant bit of the number\n// Simply subtract one from each Node number incase the nodes are one based\n// n is the number of cities\n\n// Logic in short:\n// Suppose we have some elements in the Set A (i)\n// We see all the cities (in set A only) at which ending is possible\n// Let the possible ending be j\n// Since we have already calculated all these values for the present set i.e dp[i][j]\n// We see other cities which have not been included in the set A\n// Let these non included cities be k\n// Let a new set B = set A U {k} \n// Let set B be called p\n// dp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\n\n\nll dp[(1 << MAX) + 5][MAX];\nll n, m;\nll u,v,w;\nll p;\n\nvoid initialize(){\n\n\tfor(ll i = 0; i < n; i++)\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\twt[i][j] = INF;\n\t\t}\n\tfor(ll i = 0; i < ( 1 << n); i++)\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tdp[i][j] = -1;\n\tdp[1][0] = 0;\n}\n\nvoid floyd_warshall(){\n\t\tfor (ll k=0; k < n; k++) {\n            for (ll i=0; i < n; i++) {\n                for (ll j=0; j < n; j++) {\n                \tif(wt[i][k] != INF && wt[k][j] != INF) \n                \t\twt[i][j] = min(wt[i][j], wt[i][k] + wt[k][j]);\n                \t}\n                }\n            }\n\t\t}\t\n\nvoid tsp()\n{\n\tfor(ll i = 1; i < (1 << n); i++){ \n\t\t// This loop represents the current state, i.e the contents of the set\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\t// j variable tells the ending city\n\t\t\t// during the current state, the last station is j\n\t\t\tif(dp[i][j] == -1)\n\t\t\t{\n\t\t\t\tcontinue;// Incase its impossible to start at 0 and end at j, for eg dp[anyNumber][0], \n\t\t\t\t//Since you cant start at 0 and end at 0\n\t\t\t} \n\t\t\tfor(ll k = 1; k < n; k++){\n\t\t\t\t//cout<<k<<endl;\n\t\t\t\t// This indicates the new city which is going to be included\n\t\t\t\tif(((i & (1 << k)) != 0) || wt[j][k] == INF) // Note that relational op > bitwise op\n\t\t\t\t{\n\t\t\t\t\tcontinue; // i.e. the city was already in the set\n\t\t\t\t}\n\t\t\t\tp = i | (1 << k); // the new state(join k)\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\tif(dp[p][k] == -1)\n\t\t\t\t\tdp[p][k] = dp[i][j] + wt[j][k];\n\t\t\t\telse\n\t\t\t\t\tdp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nll minimum_cost()\n{\n\tll ans = INF;\n\tfor(ll i = 1; i < n; i++)\n\t{\n\t\tif(dp[(1 << n) - 1][i] == -1 || wt[i][0] == INF) continue;\n\t\tans = min(ans, dp[(1 << n) - 1][i] + wt[i][0]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n; // number of cities\n\tcin>>m; // number of edges\n\tinitialize();\n\tfor(ll i = 0; i < m; i++)\n\t{\n\t\tcin>>u>>v>>w;\n\t\twt[u][v] = w;\n\t\t//wt[v][u] = w;\n\t}\n\tfloyd_warshall();\n\ttsp();\n\tll ans = minimum_cost();\n\tif(ans != INF) \n\t\tcout<<ans<<endl;\n\telse cout<<-1<<endl;\n\t/*for(ll i = 0; i < n; i++)\n\t{\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tcout<<wt[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<n<<endl;\n\tfor(ll i = 0; i < (1 << n); i++)\n\t{\n\t\tfor(ll j = 0 ; j < n; j++)\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\ntemplate <typename F>\nvoid forComb(int n, int k, F f)\n{\n    int comb = (1 << k) - 1;\n    while (comb < (1 << n)) {\n        f(comb);\n\n        int x = comb & -comb;\n        int y = comb + x;\n        comb = ((comb & ~y) / x >> 1) | y;\n    }\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    using E = tuple<int, int>;\n    vector<vector<E>> redge(n);\n    rep(i, m)\n    {\n        int s, t, d;\n        cin >> s >> t >> d;\n\n        redge[t].push_back(E(s, d));\n    }\n\n    const int DMAX = 15 * 1'001;\n    vector<vector<int>> dp(1 << n, vector<int>(n));\n    int result = DMAX;\n    rep(s, n)\n    {\n        irep(i, n)\n        {\n            if (i == 0) {\n                rep(j, n)\n                {\n                    dp[i][j] = j == s ? 0 : DMAX;\n                }\n            } else {\n                forComb(n, i, [&](int comb) {\n                    rep(j, n)\n                    {\n                        dp[comb][j] = DMAX;\n                        for (const E v : redge[j]) {\n                            int k, d;\n                            tie(k, d) = v;\n                            if ((comb & (1 << k)) != 0) {\n                                dp[comb][j] = min(dp[comb][j], dp[comb ^ (1 << k)][k] + d);\n                            }\n                        }\n                    }\n                });\n            }\n        }\n        result = min(result, dp[(1 << n) - 1][s]);\n    }\n    if (result == DMAX) {\n        cout << -1 << endl;\n    } else {\n        cout << result << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//巡回セールスマン\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct{\n  int cost,to;\n}Edge;\n\nint v,e;\nvector<Edge>G[16];\nint ans=-1;\nint starts;\n\nvoid bitdp(int bit,int cnt,int now);\n\n\nint main(){\n  cin>>v>>e;\n  for(int i=0,a,b,c;i<e;i++){\n    cin>>a>>b>>c;\n    G[a].push_back((Edge){c,b});\n    //  G[b].push_back((Edge){c,a});\n  }\n  for(int i=0;i<v;i++){\n    for(int j=0;j<G[i].size();j++){\n      int a=0;\n      starts=i;\n      bitdp(0,G[i][j].cost,G[i][j].to);\n      a=0;\n    }\n    //    cout<<\"OUOU\"<<endl;\n  }\n  cout<<ans<<endl;\n}\n\nvoid bitdp(int bit,int cnt,int now){\n  int temp;\n  int co=0;\n  if(bit & 1<<now)return; \n  bit=bit | 1<<now;\n    bitset<5>bs((long)bit);\n    //  cout<<cnt<<\" \"<<now<<\" \" <<bs<<endl;\n\n  //カウント\n  for(int i=0;i<v;i++){\n    if(bit & 1<<i)co++;\n    else break;\n  }\n  if(co==v && now==starts){\n    // cout<<cnt<<endl;\n    if(ans==-1)ans=cnt;\n    else ans=min(ans,cnt);\n    return;\n  }\n  \n  //そのエッジからの道\n  for(int i=0;i<G[now].size();i++){  \n    temp=bit;\n    bitdp(bit,cnt+G[now][i].cost,G[now][i].to);\n    bit=temp;\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nint MAX_N=16;\nint n;\nvvin d(MAX_N,vin(MAX_N,inf));\nvvin dp((1<<MAX_N),vin(MAX_N,-1));\n\nint rec(int S,int v){\n    if(dp[S][v]>=0)return dp[S][v];\n    if(S==(1<<n)-1&&v==0)return dp[S][v]=0;\n    int res=inf;\n    rep(u,n)if(!(S&1<<u))res=min(res,rec(S|1<<u,u)+d[v][u]);\n    return dp[S][v]=res;\n}\n\nint main(){\n    int m;cin>>n>>m;\n    int s,t,D;\n    rep(i,m){\n        cin>>s>>t>>D;\n        d[s][t]=D;\n    }\n    int ans=rec(0,0);\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<limits>\n#include<cstdio>\n#include<cstring>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define clr(a,v) memset((a),(v),sizeof(a))\n\nconst int MAX_V = 15, INF = std::numeric_limits<int>::max()>>2;\n\nint V, E;\nstd::vector<std::vector<int> > d( MAX_V, std::vector<int>( MAX_V, INF ) );\nint dp[1<<MAX_V+1][MAX_V];\n\nint sv;\n\nint rec( int S, int v )\n{\n    if( S == (1<<V)-1 && v == sv )\n        return dp[S][v] = 0;\n\n    if( ~dp[S][v] )\n        return dp[S][v];\n\n    int ret = INF;\n\n    rep( u, V ) if( !(S>>u&1) )\n        ret = std::min( ret, rec( S|1<<u, u )+d[v][u] );\n\n    return dp[S][v] = ret;\n}\n\nint main()\n{\n    scanf( \"%d%d\", &V, &E );\n    rep( i, E )\n    {\n        int s, t;\n        scanf( \"%d%d\", &s, &t );\n        scanf( \"%d\", &d[s][t] );\n    }\n\n    int ans = INF;\n    rep( v, V )\n    {\n        clr( dp, -1 );\n        sv = v;\n        ans = std::min( ans, rec( 0, v ) );\n    }\n\n    printf( \"%d\\n\", ans==INF?-1:ans );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint dp[1 << 15][15];\nint G[15][15];\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E, s, t, d;\n\tcin >> V >> E;\n\trep(i, 0, V)rep(j, 0, V)G[i][j] = INF;\n\trep(i, 0, E)\n\t{\n\t\tcin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\trep(i, 0, 1 << V)fill(dp[i], dp[i] + V, INF);\n\tdp[(1 << V) - 1][0] = 0;\n\n\trrep(i, 0, (1 << V) - 1)rep(u, 0, V)rep(v, 0, V)\n\t{\n\t\tif (((i >> v) & 1) == 0)\n\t\t{\n\t\t\tchmin(dp[i][u], dp[i | (1 << v)][v] + G[u][v]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", dp[0][0] == INF ? -1 : dp[0][0]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define rrep(i, n) for(int i=n-1; i>=0; i--)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint V, E;\nint g[20][20];\nint dp[1<<20][20];\n\nint main() {\n    cin >> V >> E;\n    rep(i, V) rep(j, V) g[i][j] = -1;\n    rep(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        g[s][t] = d;\n    }\n\n    rep(i, 1<<V) rep(j, 20) dp[i][j] = INF;\n    dp[(1<<V) - 1][0] = 0;\n    for (int S = (1<<V) - 2; S >= 0; S--) {\n        for (int v = 0; v < V; v++) {\n            for (int u = 0; u < V; u++) {\n                if (!(S & 1<<u) && g[v][u] != -1) {\n                    dp[S][v] = min(dp[S][v], dp[S|1<<u][u] + g[v][u]);\n                }\n            }\n        }\n    }\n\n    cout << (dp[0][0] != INF ? dp[0][0] : -1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <sstream>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n#define print(s) cout << (s) << endl\n\nconst int INF = 2e9;\n\nint rec(int S, int v, vector<vector<int>> dp, vector<vector<int>> dist, int n) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1<<n)-1 && v == 0) return dp[S][v] = 0;\n    \n    int res = INF;\n    REP(i,n) {\n        if (!(S>>i & 1) && dist[v][i]) {\n            // ith vertex is not in S\n            // move from v to i\n            res = min(res, rec(S | 1<<i, i, dp, dist, n) + dist[v][i]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> dist(V,vector<int>(V,0));\n    REP(i,E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    \n    vector<vector<int>> dp(1<<V,vector<int>(V+1,-1));\n    // dp[S][j] denotes the minimum distance from jth vertex to 0th vertex passing all unpassed vertices\n    \n    int ans = rec(0,0,dp,dist,V);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint V, E;\nvector< pair< int, int > > g[15];\nint dp[1 << 15][15];\n\nint main()\n{\n  cin >> V >> E;\n  for(int i = 0; i < E; i++) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    g[s].emplace_back(t, d);\n  }\n\n  fill_n(*dp, (1 << 15) * 15, INF);\n  dp[0][0] = 0;\n  auto chmin = [](int &a, int b) { a = min(a, b); };\n\n  for(int i = 0; i < (1 << V); i++) {\n    for(int j = 0; j < V; j++) {\n      if(dp[i][j] == INF) continue;\n      for(auto &p : g[j]) {\n        if((i >> p.first) & 1) continue;\n        chmin(dp[i | (1 << p.first)][p.first], dp[i][j] + p.second);\n      }\n    }\n  }\n\n  if(dp[(1 << V) - 1][0] == INF) cout << -1 << endl;\n  else cout << dp[(1 << V) - 1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>;\n#include <vector>;\n#include <math.h>;\nusing namespace std;\n\ninline int get_bit ( int mask, int num )\n{\n\treturn ( mask >> num ) & 1;\n}\ninline int add_bit ( int mask, int num )\n{\n\treturn ( mask + ( 1 << num ) );\n}\n\n\nint main ()\n{\n\tint n = 0, m = 0;\n\tint i = 0, j = 0;\n\tcin >> n >> m;\n\tvector < vector < pair < int, int> > > graph ( n );\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\tint source, destiny, len;\n\t\tcin >> source >> destiny >> len;\n\t\tgraph[source].push_back ( make_pair ( destiny, len ) );\n\t\t//graph[destiny].push_back(make_pair(source, len));\n\t}\n\n\tint max_mask = pow ( 2, n );\n\tvector < vector < int > > dp ( max_mask, vector < int > ( n, -1 ) );\n\tdp[1][0] = 0;\n\tfor ( int mask = 1; mask < max_mask; mask++ )\n\t{\n\t\tfor ( int vertex = 0; vertex < n; vertex++ )\n\t\t{\n\t\t\tfor ( i = 0; i < graph[vertex].size (); i++ )\n\t\t\t{\n\t\t\t\tint next = graph[vertex][i].first;\n\t\t\t\tif ( !get_bit ( mask, next ) && (dp[mask][vertex] != -1) )\n\t\t\t\t{\n\t\t\t\t\tif ( ( dp[add_bit ( mask, next )][next] > ( dp[mask][vertex] + graph[vertex][i].second ) ) || ( -1 == dp[add_bit ( mask, next )][next] ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( add_bit( mask, next ) == 63 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint a = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[add_bit ( mask, next )][next] = dp[mask][vertex] + graph[vertex][i].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tint result = -1;\n\tfor ( i = 1; i < n; i++ )\n\t{\n\t\tfor ( j = 0; j < graph[i].size (); j++ )\n\t\t{\n\t\t\tif ( 0 == graph[i][j].first )\n\t\t\t{\n\t\t\t\tif ( dp[max_mask - 1][i] != -1 )\n\t\t\t\t{\n\t\t\t\t\tif ( ( result > ( dp[max_mask - 1][i] + graph[i][j].second ) ) || ( result == -1 ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = dp[max_mask - 1][i] + graph[i][j].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nusing VL=vector<ll>;\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\nconst int INF =  999999999;\n\nint dp[(1<<15)+10][16],n,m;\nint d[17][17];\n\nint rec(int S,int v){\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n\n  if(S==(1<<n)-1 && v==0){\n    return dp[S][v]=0;\n  }\n\n  int res=INF;\n  REP(u,n){\n    if(!((S>>u)&1)){\n      //uに移動する。\n      res=min(res,rec(S | (1<<u),u)+d[v][u]);\n    }\n  }\n  return dp[S][v]=res;\n}\n\nint main(){\n  cin>>n>>m;\n  REP(i,n){\n    REP(j,n){\n      d[i][j]=INF;\n    }\n  }\n  int s,t,r;\n  REP(i,m){\n    cin >>s>>t>> r;\n    d[s][t]=r;\n  }\n  memset(dp,-1,sizeof(dp));\n  int ans=rec(0,0);\n  if(ans>=INF){\n    cout <<\"-1\"<<endl;\n  }\n  else cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1 << 30;\n\nstruct edge{\n    int to;\n    int cost;\n    edge(int t, int c){\n        to = t;\n        cost = c;\n    }\n};\n\nll G[15][15];\nll dp[(1 << 15)][15];\nint states;\nint V,E;\n\nvoid init(){\n    rep(i, 15) rep(j, 15) G[i][j] = INF;\n}\n\nll dfs(int S, int v){\n    //S -> S | to への遷移\n    if(dp[S][v] >= 0) return dp[S][v];\n    if(S == states-1 && v == 0) return dp[S][v] = 0;\n\n    ll ans = INF;\n    for(int to = 0; to < V; to++){\n        //まだtoに行っていない\n        if(!((S >> to) & 1)) ans = min(ans, dfs(S|(1 << to), to) + G[v][to]);\n    }\n    dp[S][v] = ans;\n    return ans;\n}\n\nint main(void){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    init();\n    cin >> V >> E;\n    states = (1 << V);\n    memset(dp, -1, sizeof(dp));\n    rep(i, E){\n        int f, t, c; cin >> f >> t >> c;\n        G[f][t] = c;\n    }\n\n    ll ans = min(INF, dfs(0, 0));\n    if(ans != INF) cout << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_V 15\n\nint main(void){\n  int v, e, st[MAX_V][MAX_V], i, j, k, l, d[MAX_V][1 << MAX_V]/*スタート地点,今いる地点,通過した編の情報(bit)*/, ans = -1;\n  scanf(\"%d%d\",&v,&e);\n  memset(st,-1,sizeof(st));\n  for(i = 0;i < e;i++){\n    int s, t, dt;\n    scanf(\"%d%d%d\",&s,&t,&dt);\n    st[s][t] = dt;\n  }\n  for(i = 0;i < v;i++){ // スタート地点\n    memset(d,-1,sizeof(d));\n    d[i][1 << i] = 0;\n    while(1){\n      int flag = 1;\n      for(j = 0;j < v;j++){ // 今いる地点\n\tfor(k = 0;k < 1 << v;k++){ // 通過辺の情報\n\t  for(l = 0;l < v;l++){ // 行き先\n\t    if(d[j][k] != -1 && st[j][l] != -1 && (d[l][k | (1 << l)] == -1 || d[l][k | (1 << l)] > d[j][k] + st[j][l])){\n\t      flag = 0;\n\t      d[l][k | (1 << l)] = d[j][k] + st[j][l];\n\t      \n\t    }\n\t  }\n\t}      \n    \n      }\n      if(flag){\n\tbreak;\n      }\n    }\n    if(d[i][(1 << v) - 1] != -1 && (ans == -1 || d[i][(1 << v) - 1] < ans)){\n      ans = d[i][(1 << v) - 1];\n    }\n\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\n#define reps(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, N) reps(i, 0, N-1)\n#define deps(i, E, S) for (ll i = (E); i >= (S); i--)\n#define dep(i, N) deps(i, N-1, 0)\nconst ll INF = 1LL << 60;\nconst int INF_INT = 1 << 30;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\nstruct mll {\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val = (val + b.val) % MOD; return *this; }\n\tmll &operator -= (const mll &b) { val = (val + MOD - b.val) % MOD; return *this; }\n\tmll &operator *= (const mll &b) { val = (val*b.val) % MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c = b.val, d = MOD, u = 1, v = 0;\n\t\twhile (d) {\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b) {\n\t\tchmin(b, a - b);\n\t\tif (b < 0) return mll(0);\n\t\tmll c = 1;\n\t\trep(i, b) c *= a - i;\n\t\trep(i, b) c /= i + 1;\n\t\treturn c;\n\t}\n};\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nstruct Fast {\n\tFast() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast; //cin,cout高速化のおまじない＋桁数指定\n\nll mll::MOD = (ll)(1e9 + 7);// 998244353ll;\n\n\n//重み付きグラフ表現(Nノードのうちノードindexから別のノード番号へ接続)\nstruct Node {\n\tll next;\n\tll cost;\n\tNode(ll next, ll cost) {\n\t\tthis->next = next;\n\t\tthis->cost = cost;\n\t}\n\tNode() {}\n};\nvector<vector<Node>> g;\nll V;\nll E;\nvvll dp;\n\nll solve(ll S, ll v) { //訪問済みフラグS 今いる場所v\n\tif (dp[S][v] >= 0) {\n\t\treturn dp[S][v];\n\t}\n\n\tif (S == ((1 << V) - 1) && v == 0) {\n\t\tdp[S][v] = 0;\n\t\treturn 0; //目的達成の状態のため残コストは0\n\t}\n\n\tll minCost = INF;\n\n\tfor (auto item : g[v]) {\n\t\tif ((S & (1ll << item.next)) == 0) {\n\t\t\t//iにはvから行けて、かつ未訪問\n\t\t\tll cost = solve(S | (1ll << item.next), item.next) + item.cost;\n\t\t\tchmin(minCost, cost);\n\t\t}\n\t}\n\n\tdp[S][v] = minCost;\n\t\n\treturn minCost;\n}\n\nint main() {\n\tcin >> V;\n\tcin >> E;\n\tg.resize(V);\n\trep(i, E) {\n\t\tll A;\n\t\tcin >> A;\n\t\tll B;\n\t\tcin >> B;\n\t\tll C;\n\t\tcin >> C;\n\t\tg[A].push_back(Node(B, C));\n\t}\n\n\tdp.resize((1ll << V)); //訪問済みのノードの集合\n\trep(i, (1ll << V)) {\n\t\tdp[i].resize(V, -1); //今、ノードVにいる状態：　目的達成までの最小コスト\n\t}\n\n\tll result = solve(0, 0);\n\n\tcout << (result == INF ? -1 : result) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<deque>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#include<iomanip>\n#include<cassert>\n#include<regex>\n#include<bitset>\n#include<complex>\n#include<chrono>\n#include<random>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\ntypedef std::vector<int> vi;\ntypedef std::vector<std::vector<int>> vvi;\ntypedef std::vector<long long> vl;\ntypedef std::vector<std::vector<long long>> vvl;\n#define out(x) cout<<x<<\"\\n\";\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\nll gcd(ll n, ll m) {\n\tll tmp;\n\twhile (m!=0) {\n\t\ttmp = n % m;\n\t\tn = m;\n\t\tm = tmp;\n\t}\n\treturn n;\n}\n\nll lcm(ll n, ll m) {\n\treturn abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \nusing namespace std;\n\n\nvoid solve(){\n  int v,e;\n  cin>>v>>e;\n  vvi cost(v,vi(v,1e7));\n  rep(i,e){\n    int s,t,d;\n    cin>>s>>t>>d;\n    cost[s][t]=d;\n  }\n  int ans=1e7;\n  rep(V,v){\n    vvi dp(1<<v,vi(v,1e7));//dp[S][i]:訪問済み頂点が集合Sで表され,最後に訪れた頂点がiとなるときの最小コスト\n    dp[0][V]=0;\n    rep(bit,1<<v){\n      rep(i,v){\n        rep(j,v){\n          if(bit&(1<<j))continue;\n          chmin(dp[bit|1<<j][j],dp[bit][i]+cost[i][j]);\n        }\n      }\n    }\n    chmin(ans,dp[(1<<v)-1][V]);\n  }\n  if(ans!=1e7) cout<<ans<<\"\\n\";\n  else out(-1);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n  cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n  solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_V = 15;\nconst int INF = 1e9;\nint V, E, D[MAX_V][MAX_V], dp[1 << MAX_V][MAX_V];\n\nint rec(int S, int v, int T){\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << V) - 1 && v == T) return dp[S][v] = 0;\n    \n    int res = INF;\n    for (int u = 0; u < V; ++u){\n        if (!(S >> u & 1)) res = min(res, rec(S | 1 << u, u, T) + D[v][u]);\n    }\n    return dp[S][v] = res;\n}\n\nint main(){\n    cin >> V >> E;\n    for (int i = 0; i < V; ++i){\n        for (int j = 0; j < V; ++j){\n            D[i][j] = INF;\n        }\n    }\n\n    for (int i = 0; i < E; ++i){\n        int v, u, c;\n        cin >> v >> u >> c;\n        D[v][u] = c;\n    }\n    \n\n    \n    int ans = INF;\n    for (int i = 0; i < V; ++i){\n        for (int i = 0; i < (1 << V); ++i){\n            for (int j = 0; j < V; ++j){\n                dp[i][j] = -1;\n            }\n        }\n        ans = min(ans, rec(0, i, i));\n    }\n    if (ans >= INF){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000\nusing namespace std;\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> dp(1 << V, vector<int>(V, INF)), edge(V,vector<int>(V, INF));\n\tfor (int i = 0, s, t, d; i < E; i++) {\n\t\tcin >> s >> t >> d;\n\t\tedge[s][t] = d;\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 1; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - (1 << j)][k] + edge[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[(1 << V) - 1][0] == INF)\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << dp[(1 << V) - 1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define INF 100\n\nint main(){\n\n  int v, e; cin >> v >> e;\n  int n = v;\n  vector<vector<int> > dis(v, vector<int> (v, INF));\n  for(int i = 0; i < e; i++){\n    int a, b, c; cin >> a >> b >> c;\n    dis[a][b] = c;\n  }\n\n  vector<vector<int> > dp((1 << n), vector<int> (n, INF));\n  dp[0][0] = 0;\n  for(int i = 0; i < (1 << n); i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < v; k++){\n        if((i & (1 << k)) != 0) continue;\n\n        int cost = dp[i][j] + dis[j][k];\n\n        chmin(dp[i | (1 << k)][k], cost);\n      }\n    }\n  }  \n\n  if(dp[(1 << v) - 1][0] == INF) cout << -1 << endl;\n  else cout << dp[(1 << v) - 1][0] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_V = 17;\nconst int INF = 1e9;\n\nint traveling_salesman(int V, int G[MAX_V][MAX_V]){\n  int dp[(1 << V)][V];\n  REP(i, (1 << V)) REP(j, V) dp[i][j] = INF;\n  dp[0][0] = 0;\n  REP(i, (1 << V)){\n    REP(j, V){\n      REP(k, V){\n        int mask = (1 << k), cost = G[j][k];\n        if((i & mask) || cost < 0) continue;\n        dp[(i | mask)][k] = min(dp[(i | mask)][k], dp[i][j] + cost);\n      }\n    }\n  }\n  return (dp[(1 << V) - 1][0] == INF ? -1 : dp[(1 << V) - 1][0]);\n}\n\nint main() {\n  int G[MAX_V][MAX_V];\n  int V, E; cin >>V >>E;\n  memset(G, -1, sizeof(G));\n  REP(i, E){\n    int f, t, c; cin >>f >>t >>c;\n    G[f][t] = c;\n  }\n  cout <<traveling_salesman(V, G) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<stack>\n#include<tuple>\n#include<cassert>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\nusing P = pair<int, int>;\n\nint dp[1<<15][15] = {0};\nint V, E;\nvector<int> v[15];\nint w[15][15];\nconst int INF = 1000000000;\n\nint main() {\n  cin >> V >> E;\n  rep(i, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    v[s].push_back(t);\n    w[s][t] = d;\n  }\n\n  for(int bit = 0; bit < (1<<V); bit++) {\n    for(int i = 0; i < V; i++) {\n      dp[bit][i] = INF;\n    }\n  }\n  dp[0][0] = 0;\n\n  for(int bit = 0; bit < (1<<V); bit++) {\n    for(int i = 0; i < V; i++) {\n      if((bit & (1<<i)) || (bit == 0 && i == 0)) {\n        for(int j = 0; j < v[i].size(); j++) {\n          int nx = v[i][j];\n          if(!(bit & (1<<nx))) {\n            int nbit = bit + (1<<nx);\n            dp[nbit][nx] = min(dp[bit][i] + w[i][nx], dp[nbit][nx]);\n          }\n        }\n      }\n    }\n  }\n\n  // cout << dp[2][1] << endl;\n  if(dp[(1<<V)-1][0] == INF) cout << -1 << endl;\n  else cout << dp[(1<<V)-1][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\n\ntemplate<class T>\nvector<vector<T>> TSP(const vector<vector<T>>& dist) {\n    int n = dist.size();\n    vector<vector<T>> dp(1 << n, vector<T>(n, INF));\n    dp[0][0] = 0;\n    for (int s = 0; s < 1 << n; s++) {\n        for (int cur = 0; cur < n; cur++) {\n            if (dp[s][cur] == INF) continue;\n            for (int to = 0; to < n; to++) {\n                if (s & (1 << to)) continue;\n                if (dist[cur][to] < 0) continue;\n                T& res = dp[s | 1 << to][to];\n                res = min(res, dp[s][cur] + dist[cur][to]);\n            }\n        }\n    }\n    return dp;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> dist(n, vector<int>(n, -1));\n    for (int i = 0; i < m; i++) {\n        int s, t, d; cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    vector<vector<int>> dp = TSP(dist);\n    int ans = dp[(1 << n) - 1][0];\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define MAX_N 16\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint V,E;\nll K;\nint d[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nint color[MAX_N];\n\nvoid solve(){\n\tfor(int S=0;S<1<<V;S++){\n\t\tfill(dp[S],dp[S]+V,INF);\n\t}\n\tdp[(1<<V)-1][0] = 0;\n\tfor(int S=(1<<V)-2;S>=0;S--){\n\t\tfor(int v=0;v<V;v++){\n\t\t\tfor(int u=0;u<V;u++){\n\t\t\t\tif(!(S>>u&1)){\n\t\t\t\t\tdp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[0][0]>=INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",dp[0][0]);\n}\n\n//dfsで塗る\nint dfs(int v,int a){\n\tcolor[v] = 1;\n\ta++;\n\tfor(int i=0;i<V;i++){\n\t\tif(d[v][i]!=INF && color[i]==0){\n\t\t\ta = dfs(i,a);\n\t\t}\n\t}\n\treturn a;\n}\n\n\nint main()\n{\n\tint s,t,dd;\n\tscanf(\"%d %d\",&V,&E);\n\tif(E==0){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=V;i++){\n\t\tfill(d[i],d[i]+V+1,INF);\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&dd);\n\t\td[s][t] = dd;\n\t}\n\t//printf(\"%d\\n\",dfs(0,0));\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    int graph[15][15];\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < v; j++){\n            graph[i][j] = mod;\n        }\n    }\n    for(int i = 0; i < e; i++){\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n    pair<int, int> result[(1 << 15)][15];\n    for(int i = 0; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            result[i][j] = make_pair(mod, -1);\n        }\n    }\n    for(int i = 0; i < v; i++){\n        result[(1 << i)][i] = make_pair(0, i);\n    }\n    for(int i = 1; i < (1 << v); i++){\n        for(int j = 0; j < v; j++){\n            // ????????????????????????j????????????????????¨??????\n            if(((1 << j) & i) == 0) continue;\n            // cout << i << \" \" << j << endl;\n            int tmp = (i ^ (1 << j));\n            for(int k = 0; k < v; k++){\n                // ?????????k?????????j??????????????£?????¶???i???????????¨??????\n                // if(((1 << k) & tmp) == 0) continue;\n                if(result[i][j].first > result[tmp][k].first + graph[k][j]){\n                    result[i][j].first = result[tmp][k].first + graph[k][j];\n                    result[i][j].second = result[tmp][k].second;\n                }\n            }\n            // cout << i << \" \" << j << \" \" << result[i][j].first << \" \" << result[i][j].second << endl;\n        }\n    }\n    int ans = mod;\n    for(int i = 0; i < v; i++){\n        ans = min(ans, result[(1 << v) - 1][i].first + graph[i][result[(1 << v) - 1][i].second]);\n    }\n    if(ans == mod) cout << -1 << endl;\n    else cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\n\nusing namespace std;\n\nconst ll mod=1000000007;\nconst ll inf=1e18;\nvector<vector<ll>> dp;\n//G[i][j]は、iからjへの有向線分があればその長さ、なければ-1。i=jの場合は0。\nvector<vector<ll>> G;\n\nll v;\n//rec(b,u)は、bの元(bはbit)を全部通ってかつ最初が0で最後がuの場合の最小距離\nll rec(ll b,ll u){\n  //探索済みなら良い\n  if(dp[b][u]!=-1)return dp[b][u];\n\n  //移動する必要はない\n  if(b == (1<<u) )return dp[b][u]=0;\n\n  ll res = inf;\n\n  if(b==(1<<v)-1 && u==0){\n    for(int i=1;i<v;i++){\n      if(G[i][u]==-1){\n        continue;  //iからuに向けて道がなければスキップ\n      }\n      res=min(res,rec(b,i)+G[i][u]);\n    }\n  }\n  else if(u==0){\n    ;\n  }\n  else{\n    //bからuを除く\n    ll pb = b & ~(1<<u);\n    for(int i=0;i<v;i++){\n      if(!(pb & ( 1<< i))){\n        continue;  //pbにiが属さなければスキップ\n      } \n      if(G[i][u]==-1){\n        continue;  //iからuに向けて道がなければスキップ\n      }\n      res=min(res,rec(pb,i)+G[i][u]);\n    }\n  }\n\n  return dp[b][u]=res;\n}\n\nint main(){\n\n  ll e;\n  cin >> v >> e;\n\n  //Gの大きさを整える\n  G.resize(v);\n  for(int i=0;i<v;i++){\n    G[i].resize(v);\n  }\n\n  //Gに数字を入れていく\n  for(int i=0;i<v;i++){\n    for(int j=0;j<v;j++){\n      if(i!=j)G[i][j]=-1;\n      else G[i][j]=0;\n    }\n  }\n\n  //入力。\n  for(int i=0;i<e;i++){\n    ll s,t,d;\n    cin >> s >> t >> d;\n    G[s][t]=d;\n  }\n  \n  //dpのサイズ\n  dp.resize((1<<v) +1);\n  for(int i=0;i<(1<<v) +1;i++){\n    dp[i].resize(v+1);\n  }\n\n  //初期化\n  for(int i=0;i<(1<<v) +1;i++){\n    for(int j=0;j<v+1;j++){\n      dp[i][j]=-1;\n    }\n  }\n\n  dp[1<<0][0]=0;\n\n  ll re = inf;\n\n  //for(int i=0;i<v;i++){\n    //if(G[i][0])\n    re = min(re,rec((1<<v)-1,0));\n  //}\n\n  if(re==inf)re=-1;\n  cout << re << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nclass Route {\npublic:\n\tRoute(const int &n = 0) :state(n) {};\n\tbool filled() const { return state == ((1 << size) - 1); }\n\tRoute remove(const int &n) const { return Route(state & (-1 - (1 << n))); }\n\tRoute add(const int &n) const { return Route(state | (1 << n)); }\n\tbool include(const int &n) const { return (state & (1 << n)) != 0; }\n\tbool operator<(const Route &other) const { return state < other.state; }\n\tbool operator>(const Route &other) const { return other.state < state; }\n\tbool operator==(const Route &other) const { return state == other.state; }\n\tbool operator<=(const Route &other) const { return *this < (other) || *this == (other); }\n\tbool operator>=(const Route &other) const { return *this > (other) || *this == (other); }\n\tint to_i() const { return state; }\n\tvoid inspect() const;\n\tvoid inspect(int) const;\n\tstatic int size;\nprivate:\n\tint state;\n};\nvoid Route::inspect() const {\n\tinspect(state);\n\tstd::cout << std::endl;\n}\nvoid Route::inspect(int s) const {\n\tif (s > 1) {\n\t\tinspect(s / 2);\n\t\tstd::cout << s % 2;\n\t}\n\telse {\n\t\tstd::cout << s;\n\t}\n}\nclass Edge {\npublic:\n\tEdge(const int &f = 0, const int &t = 0, const int &w = 0) :from(f), to(t), weight(w) {};\n\tbool operator<(const Edge &other) const { return (to < other.to); }\n\tint from, to, weight;\n};\nint dp(std::vector<std::vector<int>> &memo, std::vector<std::vector<Edge>> &edge, const Route &route, const int &vertex) {\n\tif (memo.at(route.to_i()).at(vertex) != -1) {\n\t\treturn memo.at(route.to_i()).at(vertex);\n\t}\n\telse if (route.filled() && vertex == 0) {\n\t\treturn memo.at(route.to_i()).at(vertex) = 0;\n\t}\n\telse {\n\t\tint min = 15000;\n\t\tfor (auto &e : edge.at(vertex)) {\n\t\t\t//std::cout << \"from \" << e.from << \" to \" << e.to << std::endl;\n\t\t\tif (!route.include(e.to)) {\n\t\t\t\tauto temp = dp(memo, edge, route.add(e.to), e.to) + e.weight;\n\t\t\t\t//std::cout << vertex << \"->\" << e.to << \" == \";\n\t\t\t\t//std::cout << temp << \"---\";\n\t\t\t\t//route.inspect();\n\t\t\t\tif (min > temp) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t//std::cout << \"vertex = \" << vertex << \"min = \" << min << std::endl;\n\t\treturn memo.at(route.to_i()).at(vertex) = min;\n\t}\n}\nint Route::size = 30;\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tRoute::size = v;\n\tstd::vector<std::vector<int>> vector((1 << v), std::vector<int>(v, -1));\n\tstd::vector<std::vector<Edge>> edges(v, std::vector<Edge>(0));\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t, d;\n\t\tstd::cin >> s >> t >> d;\n\t\tedges.at(s).push_back(Edge(s, t, d));\n\t}\n\tif (dp(vector, edges, Route(0), 0) > 15000) {\n\t\tstd::cout << -1 << std::endl;\n\t}\n\telse {\n\t\tstd::cout << dp(vector, edges, Route(0), 0) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 10000000;\n\nint solve(vector<vector<int>> &dists)\n{\n    const int v = dists.size();\n\n    vector<vector<int>> dp(1 << v, vector<int>(v, INF));\n    dp[1][0] = 0;\n\n    const int all = (1 << v) - 1;\n\n    for (int S = 1; S <= all; S++)\n    {\n        for (int s = 0; s < v; s++) {\n            if ((S & (1 << s)) != 0) {\n                for (int e = 0; e < v; e++) {\n                    if (dists[s][e] != INF && (~S & (1 << e)) != 0) {\n                        const int nS = S | (1 << e);\n                        if (nS == all) {\n                            dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e] + dists[e][0]);\n                        } else {\n                            dp[nS][e] = min(dp[nS][e], dp[S][s] + dists[s][e]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < v; i++) {\n        ans = min(ans, dp[all][i]);\n    }\n    return ans == INF ? -1 : ans;\n}\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    \n    vector<vector<int>> dists(v, vector<int>(v, INF));\n    for (int i = 0; i < e; i++) {\n        int s, e, d;\n        cin >> s >> e >> d;\n        dists[s][e] = d;\n    }\n\n    cout << solve(dists) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nconst int INF=10000000;\nbool checked(int chouten,int i){\n  if( ((1<<i)&chouten)){\n    return true;\n  }\n  else return false;\n}\nint pluscheck(int chouten,int i){\n  return (chouten|(1<<i));\n}\n\nint graph[16][16];\nint dynamic[((1<<16)-1)][16];\nint V,E;\n\n\nint roop(int chouten,int genzai){\n  //cout<<\"hehe\"<<chouten<<' '<<genzai<<' '<<len<<endl;;\n  if(dynamic[chouten][genzai]!=-1)\n    return dynamic[chouten][genzai];\n  if(chouten==(1<<(V))-1){\n    if(genzai==0)  \n      return 0;\n    else return INF;\n  }\n  else{\n    int newlen,out;\n    out=INF;\n    for(int i=0;i<16;i++){\n      if(checked(chouten,i)) continue;\n      if(graph[genzai][i]!=INF){\n\t//\tnewlen=len+graph[genzai][i];\n\tout=min(out,roop(pluscheck(chouten,i),i)+graph[genzai][i]);\n      }\n    }\n    return dynamic[chouten][genzai]=out;\n  }\n}\nint main(){\n  cin>>V>>E;\n  int s,t,d;\n  for(int i=0;i<16;i++){\n    for(int j=0;j<16;j++){\n      graph[i][j]=INF;\n    }\n  }\n  for(int i=0;i<E;i++){\n    cin>>s>>t>>d;\n    graph[s][t]=d;\n  }\n  for(int i=0;i<((1<<16)-1);i++){\n    for(int j=0;j<16;j++){\n      dynamic[i][j]=-1;\n    }\n  }\n  int rinzi=roop(0,0);\n  if (rinzi<INF)\n    cout<<rinzi<<endl;\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\nusing   namespace   std;\n\n#define INF (1<<30)\n//1,073,741,824\n//= 536,870,912 *2\n\n#define Rep0(i, n)  for (int i=0; i<n; i++)\n\nstruct  Node {\n    vector<vector<int>> T;\n    bool fixed=false;\n};\n\nvector<vector<int>> Memo(65536, vector<int> (16, -1));\n\nint F(const int &f, const int &fix, const int &t, vector<Node> &N, const int Step) {\n    if (f==t) {\n        if (Step==N.size())\n            return 0;\n        else\n            return INF;\n    }\n    if (Memo.at(fix).at(f)>=0)\n        return Memo.at(fix).at(f);\n    N.at(f).fixed=true;\n    int S=INF;\n    Rep0(i, N.at(f).T.size()) {\n        int tt=N.at(f).T.at(i).at(0);\n        int dd=N.at(f).T.at(i).at(1);\n        if (N.at(tt).fixed)\n            continue;\n        S=min(S, F(tt, fix|(1<<tt), 0, N, Step+1)+dd);\n    }\n    N.at(f).fixed=false;\n    Memo.at(fix).at(f)=S;\n    return S;\n}\n\nint main() {\n    int V, E;\n    cin >>V >>E;\n    vector<Node> N(V);\n    Rep0(i, E) {\n        int s, t, d;\n        cin >>s >>t >>d;\n        N.at(s).T.push_back({t, d});\n    }\n    int S=INF;\n    Rep0(i, N.at(0).T.size()) {\n        int tt=N.at(0).T.at(i).at(0);\n        int dd=N.at(0).T.at(i).at(1);\n        int fix=1|(1<<tt);\n        S=min(S, F(tt, fix, 0, N, 1)+dd);\n    }\n    if (S<INF)\n        cout <<S <<endl;\n    else\n        cout <<-1 <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=\n*$* WRITER:kakitamasziru/OxOmisosiru *$*\n~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/\n#ifdef LOCAL_JUDGE\n#define _GLIBCXX_DEBUG //FOR THE DEBUG! COMMENT OUT THIS WHEN SUBMITTING!\n#endif\n#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <iomanip>\n#include <limits>//setprecision\n//#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n//#include <unordered_set> //unordered_set\n#include <stack> // stack\n#include <deque> // deque\n#include <math.h>//pow,,,\n#include <cmath>//abs,,,\n#include <bitset> // bitset\n#define endl \"\\n\";\n//It is so troublesome that I include bits/stdc++.h !\nusing namespace std;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\nconst int INF = 100100100;\nconst long long MOD = 1000000007;\ntypedef pair<int,int> P;\n\n//Solve N^M. This, mod_pow use Iterative Square Method.\nlong long mod_pow(long long N, long long M) {\n    if (M == 0) return 1;\n    long long res = mod_pow((N * N) % MOD, M / 2);\n    //最下位ビット(*N)が1の時は単独でNをかける\n    if (M & 1) res = (res * N) % MOD;\n\n    return res %= MOD;\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    else return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b ;\n}\n//Edge.at(i).at(j) = D : ij間の距離がDである辺が張られている。\nvector<vector<int>> Edge(20,vector<int>(20));\n//dp[S][V] : 既に訪れた頂点集合Sと現在Vから全頂点を通って0に戻る最短経路\nint dp[(1 << 15)][15];\n\n//Sは訪問した頂点を表すbit列として考える\n//S = {0,0,1,1,0}だと1番目,2番目の頂点を訪れた後である。\nint TSP(int S,int now,int Size){\n    //既にSの状態でnowが探索済み\n    if(dp[S][now] != -1) {\n        return dp[S][now];\n    }\n    //Sが全頂点をカバーしていて、向かう頂点が0 = ゴール\n    if(S == (1 << Size)-1 && now == 0){\n        return dp[S][now] = 0;\n    }\n    int nowMiniByNow = INF;\n    //nowからuへと進む\n    for(int u = 0;u<Size;u++){\n        //今まで通った頂点集合Sのなかにuが含まれていたらダメ\n        if((S >> u) & 1 == 1) continue;\n        nowMiniByNow = min(nowMiniByNow,TSP(S | (1 << u),u,Size)+Edge.at(now).at(u));\n    }\n    return dp[S][now] = nowMiniByNow;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int N,E;cin >> N >> E;\n    for(int i = 0;i<20;i++)for(int j = 0;j<20;j++) Edge.at(i).at(j) = INF;\n    for(int i = 0;i<E;i++){\n        int from,to,dist;cin >> from >> to >> dist;\n        Edge.at(from).at(to) = dist;\n    }\n    for(int i = 0;i<(1 << 15);i++)for(int j = 0;j<15;j++) dp[i][j] = -1;\n\n    int OUTPUT = INF;\n    /*始点全探索\n    for(int i = 0;i<N;i++){\n        OUTPUT = min(OUTPUT,TSP(0,i,N));\n    }*/\n\n    OUTPUT = TSP(0,0,N);\n    if(OUTPUT == INF) OUTPUT = -1;\n\n    cout << OUTPUT << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define int long long\nconst int inf = 100100100100100;\nconst int mod = 1000000007;\n\nconst int maxn = 15;\nint n, m;\nint dist[maxn][maxn];\nint dp[1<<maxn][maxn];\n\nint dfs(int s, int v){\n\n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n\n    if(s == (1<<n)-1 && v == 0){\n        return dp[s][v] = 0;\n    }\n\n    int ans = inf;\n    rep(u,0,n){\n        if(!(s >> u & 1)){\n            ans = min(ans, dfs(s | 1 << u, u) + dist[v][u]);\n        }\n    }\n\n    dp[s][v] = ans;\n    return ans;\n\n\n}\n\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    \n    cin >> n >> m;\n\n    memset(dp,-1,sizeof(dp));\n    fill(dist[0],dist[0]+maxn*maxn,inf);\n\n    \n\n    \n    rep(i,0,m){\n        int f, t, c;\n        cin >> f >> t >> c;\n        dist[f][t] = c;\n    }\n    int ans = dfs(0,0);\n    cout << (ans == inf ? -1 : ans) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 1e9;\nstatic const int MAX_V = 15;\nint V;\nint d[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\n\n\nint rec(int S, int v)\n{\n\tif (dp[S][v] >= 0)\n\t{\n\t\treturn(dp[S][v]);\n\t}\n\tif (S == (1 << V) - 1 && v == 0)\n\t{\n\t\treturn(0);\n\t}\n\tint res = INF;\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tif (!(S >> u & 1))\n\t\t{\n\t\t\tres = min(res, rec(S | 1 << u, u) + d[v][u]);\n\t\t}\n\t}\n\treturn(dp[S][v] = res);\n}\n\nvoid solve()\n{\n\tint E;\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tfor (int j = 0; j < V; ++j)\n\t\t{\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t, cost;\n\t\tcin >> s >> t >> cost;\n\t\td[s][t] = cost;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = rec(0, 0);\n\tif (ans == INF)\n\t{\n\t\tcout << -1 << endl;\n\t}\n\telse\n\t{\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "// \n// Traveling Salesman Problem (Little et al's Branch-and-Bound)\n//\n// Description:\n//   It solves TSP exactly by branch-and-bound algorithm that\n//   employs a lower bound from the reduced cost matrix,\n//   which is similar to the Kuhn-Munkres reduction.\n//\n//   In practice, it scales to networks with |V| <= 40.\n//\n//    \n// References:\n//   J. D. C. Little, K. G. Murty, D. W. Sweeney, and C. Karel (1963):\n//   An algorithm for traveling salesman problem. \n//   Operations Research, vol. 11, pp. 972--989.\n//\n// Verified:\n//   AOJ DPL_2_A: Traveling Salesman Problem\n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\nconst double INF = 1.0 / 0.0;\nstruct traveling_salesman_problem {\n  int n;\n  vector<vector<double>> w; // set solver.w[i][j] = infty, etc\n  traveling_salesman_problem(int n) : n(n), w(n, vector<double>(n, INF)) { }\n\n  double dynamic_programming() {\n    vector<vector<double>> c(n, vector<double>(1<<n, INF));\n    vector<vector<int>> p(n, vector<int>(1<<n,-1));\n    c[0][1] = 0; // 0 start\n    for (size_t S = 0; S < (1<<n); ++S) {\n      for (int i = 0; i < n; ++i) {\n        if (!(S & (1 << i))) continue;\n        for (int j = 0; j < n; ++j) {\n          if (S & (1 << j)) continue;\n          if (c[j][S|(1<<j)] > c[i][S] + w[i][j]) {\n            c[j][S|(1<<j)] = c[i][S] + w[i][j];\n            p[j][S|(1<<j)] = i;\n          }\n        }\n      }\n    }\n    int last;\n    double ans = INF;\n    for (int i = 0; i < n; ++i) {\n      if (ans > c[i][(1<<n)-1] + w[i][0]) {\n        ans = c[i][(1<<n)-1] + w[i][0];\n        last = i;\n      }\n    }\n    vector<int> path(n);\n    int S = (1 << n) - 1;\n    path[n-1] = last;\n    for (int i = n-1; i >= 1; --i) {\n      path[i-1] = p[path[i]][S];\n      S ^= (1 << path[i]);\n    }\n    return ans;\n  }\n  double brute_force() {\n    vector<int> tour;\n    for (int i = 0; i < n; ++i)\n      tour.push_back(i);\n    double ans = INF;\n    do {\n      double cost = 0;\n      for (int i = 0; i < tour.size(); ++i) {\n        cost += w[tour[i]][tour[(i+1)%n]];\n      }\n      ans = min(ans, cost);\n    } while (next_permutation(tour.begin()+1, tour.end()));\n    return ans;\n  }\n\n  vector<int> next, prev, best;\n  double upper_bound;\n  void explore(int edges, double cost, vector<int> row, vector<int> col) {\n    int size = row.size();\n    vector<double> rowred(size, INF), colred(size, INF);\n    for (int i = 0; i < size; ++i) {\n      for (int j = 0; j < size; ++j) \n        rowred[i] = min(rowred[i], w[row[i]][col[j]]);\n      for (int j = 0; j < size; ++j) \n        if (w[row[i]][col[j]] < INF) \n          w[row[i]][col[j]] -= rowred[i];\n      cost += rowred[i];\n    }\n    for (int j = 0; j < size; ++j) {\n      for (int i = 0; i < size; ++i) \n        colred[j] = min(colred[j], w[row[i]][col[j]]);\n      for (int i = 0; i < size; ++i) \n        if (w[row[i]][col[j]] < INF) \n          w[row[i]][col[j]] -= colred[j];\n      cost += colred[j];\n    }\n    if (cost < upper_bound) {\n      if (edges == n - 2) {\n        upper_bound = cost;\n        best = next;\n        best[row[0]] = col[0];\n        best[row[1]] = col[1];\n        if (w[row[0]][col[0]] >= INF) \n          swap(best[row[0]], best[row[1]]);\n      } else {\n        int r, c;\n        double most = -INF; \n        for (int i = 0; i < size; ++i) {\n          for (int j = 0; j < size; ++j) {\n            if (w[row[i]][col[j]] != 0) continue;\n            double minrow = INF, mincol = INF;\n            for (int k = 0; k < size; ++k) {\n              if (i != k) minrow = min(minrow, w[row[k]][col[j]]);\n              if (j != k) mincol = min(mincol, w[row[i]][col[k]]);\n            }\n            if (most < minrow + mincol) {\n              most = minrow + mincol;\n              r = i;\n              c = j;\n            }\n          }\n        }\n        next[row[r]] = col[c];\n        prev[col[c]] = row[r];\n\n        int last = col[c], first = row[r];\n        while (next[last] >= 0) last = next[last];\n        while (prev[first] >= 0) first = prev[first];\n        double colrowval = w[last][first];\n        w[last][first] = INF;\n        vector<int> newrow = row, newcol = col;\n        newrow.erase(newrow.begin() + r);\n        newcol.erase(newcol.begin() + c);\n        explore(edges + 1, cost, newrow, newcol);\n        w[last][first] = colrowval;\n\n        prev[col[c]] = -1;\n        next[row[r]] = -1;\n\n        if (cost + most < upper_bound) {\n          w[row[r]][col[c]] = INF;\n          explore(edges, cost, row, col);\n          w[row[r]][col[c]] = 0;\n        }\n      }\n    }\n    for (int i = 0; i < size; ++i)\n      for (int j = 0; j < size; ++j)\n        w[row[i]][col[j]] += rowred[i] + colred[j];\n  }\n\n  double solve() {\n    vector<int> row(n), col(n);\n    for (int i = 0; i < n; ++i) row[i] = col[i] = i;\n    upper_bound = INF;\n    prev = next = vector<int>(n, -1);\n    explore(0, 0, row, col);\n\n    if (upper_bound < INF) {\n      vector<int> path(n); // solution\n      path[0] = 0;\n      for (int i = 1; i < n; ++i) \n        path[i] = best[path[i-1]];\n    }\n    return upper_bound;\n  }\n};\n\n\n// === tick a time ===\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\n\n/*\nint main() {\n  for (int iter = 0; iter < 1000; ++iter) {\n    srand(iter);\n    int n = 40;\n    traveling_salesman_problem tsp(n);\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i != j) tsp.w[i][j] = rand() % 1000 + 1;\n    tick();\n    double a = 0;// tsp.brute_force();\n    double ta = tick();\n    double b = 0;// tsp.dynamic_programming();\n    double tb = tick();\n    double c = tsp.solve();\n    double tc = tick();\n    a = b =c;\n    printf(\"%f %f\\n%f %f\\n%f %f\\n\\n\", a, ta, b, tb, c, tc);\n    if (a != b || b != c) {\n      printf(\"seed = %d\\n\", iter);\n      exit(-1);\n    }\n  }\n}\n*/\n\n// AOJ: DPL_2_A\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  traveling_salesman_problem tsp(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    tsp.w[u][v] = w;\n  }\n  double ans = tsp.solve();\n  if (ans < INF) printf(\"%.0f\\n\", ans);\n  else           printf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <limits>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <string>\n#include <functional>\nusing namespace std;\n\nusing i64 = long long int;\nusing ui64 = unsigned long long int;\n\nusing P = pair<int, int>;\n\nconstexpr int INF = (1 << 30);\nconstexpr i64 INF64 = (1LL << 60);\nconstexpr int MOD = 1000000000 + 7;\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\ntemplate <typename T, typename U>\nstatic inline std::vector<U> makeNdVector(T n, U val) noexcept {\n   static_assert(std::is_integral<T>::value, \"[makeNdVector] 1st argument must be an integer type\");\n   return std::vector<U>(std::forward<T>(n), std::forward<U>(val));\n}\n\ntemplate <typename T, typename ...Args>\nstatic inline decltype(auto) makeNdVector(T n, Args... args) noexcept {\n   static_assert(std::is_integral<T>::value, \"[makeNdVector] 1st argument must be an integer type\");\n   return std::vector<decltype(makeNdVector(std::forward<Args>(args)...))>(std::forward<T>(n), makeNdVector(std::forward<Args>(args)...));\n}\n\ntemplate <typename T>\nvoid print(vector<T> vec)\n{\n   for (auto &e : vec)\n      cout << e << \" \";\n   cout << endl;\n}\n\ntemplate <typename T>\nT gcd(T x, T y) {\n   if (x == 0 || y == 0) return 0;\n   T r;\n   while ((r = x % y) != 0) {\n      x = y;\n      y = r;\n   }\n   return y;\n}\n\ntemplate <typename T>\nT lcm(T x, T y) {\n   if (x == 0 || y == 0) return 0;\n   return (x / gcd(x, y) * y);\n}\n\nint next_combination(int sub)\n{\n   int x = sub & -sub, y = sub + x;\n   return (((sub & ~y) / x) >> 1) | y;\n}\n\nstd::uint64_t combination(int n, int r) {\n   if (n < 0 || r < 0) return 0;\n   if (n < r) return 0;\n   std::uint64_t k = 1;\n   for (std::uint64_t d = 1; d <= r; ++d) {\n      k *= n--;\n      k /= d;\n   }\n   return k;\n}\n\nbool check(string str) {\n\tfor (int i = 0; i < str.length() / 2; ++i) {\n\t\tif (str[i] != str[str.length() - 1 - i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing P = pair<i64, i64>;\n\n\tint V, E; cin >> V >> E;\n\tauto G = makeNdVector(V, V, INF64);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\n\tauto dp = makeNdVector((1 << V), V, (i64)INF64);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < (1 << V); ++i) {\n\t\tfor (int j = 0; j < V; ++j) {\n\t\t\tif (((1 << j)&i) == 0) {\n\t\t\t\tfor (int k = 0; k < V; ++k) {\n\t\t\t\t\tdp[i | (1 << j)][j] = min(dp[i | (1 << j)][j], dp[i][k] + G[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[(1 << V) - 1][0] == INF64) cout << -1 << endl;\n\telse cout << dp[(1 << V) - 1][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tlong long int V, E;\n\tcin >> V >> E;\n\t\n\tlong long int cost[V][V];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tcost[u][v] = c;\n\t}\n\t\n\tlong long int DP[V][(1 << V)];\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < (1 << V); j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tDP[0][0] = 0;\n\t\n\tfor(int i = 0; i < (1 << V); i++){\n\t\tfor(int j = 0; j < V; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tDP[j][i] = min(DP[j][i], DP[k][i - (1 << j)] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = DP[0][(1 << V) - 1];\n\t\n\tif(ans == INF){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,E,limit,tmp,minimum;\n\tscanf(\"%d %d\",&N,&E);\n\n\tlimit = pow(2,N);\n\n\tint cost[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)cost[i][k] = BIG_NUM;\n\t}\n\n\tint from,to,value;\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&value);\n\t\tcost[from][to] = value;\n\t}\n\n\tint*** dp = new int**[N+1];\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[i] = new int*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new int[limit];\n\t\t}\n\t}\n\n\tminimum = BIG_NUM;\n\tfor(int start = 0; start <= N-1; start++){\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int p = 0; p < limit; p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\ttmp = pow(2,start);\n\n\t\tdp[0][start][tmp] = 0;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tfor(int p = 0; p < limit; p++){\n\t\t\t\t\tif(dp[i-1][k][p] != BIG_NUM){\n\t\t\t\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\t\t\t\tif(p & (1 << a)){\n\t\t\t\t\t\t\t\tif(i == N && a == start){\n\t\t\t\t\t\t\t\t\tif(cost[k][start] != BIG_NUM)dp[i][start][limit-1] = min(dp[i][start][limit-1],dp[i-1][k][p]+cost[k][start]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(cost[k][a] != BIG_NUM){\n\t\t\t\t\t\t\t\t\ttmp = p + pow(2,a);\n\t\t\t\t\t\t\t\t\tdp[i][a][tmp] = min(dp[i][a][tmp],dp[i-1][k][p]+cost[k][a]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminimum = min(minimum,dp[N][start][limit-1]);\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>G(V, vector<int>(V, INF));\n\trep(i, 0, E) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tvector<vector<int>>dp((1 << V), vector<int>(V, INF));\n\tdp[(1 << V) - 1][0] = 0;\n\tfor (int bits = (1 << V) - 1 - 1; bits >= 0; bits--) {\n\t\trep(i, 0, V) {\n\t\t\trep(j, 0, V) {\n\t\t\t\tif (!(bits&(1 << j)))\n\t\t\t\t\tchmin(dp[bits][i], dp[bits | (1 << j)][j] + G[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[0][0]==INF?-1:dp[0][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int V_MAX = 15;\nconst int INF = 10000000;\n\nint n, e;\nint g[V_MAX][V_MAX];\nint dp[1 << V_MAX][V_MAX];\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1 && v == 0)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u)) && g[v][u] != INF) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return dp[visited][v] = res;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &e);\n    fill(&g[0][0], &g[n][0], INF);\n    for (int i = 0; i < e; ++i) {\n        int s, t, d;\n        scanf(\"%d %d %d\", &s, &t, &d);\n        g[s][t] = d;\n    }\n\n    fill(&dp[0][0], &dp[1 << V_MAX][0], -1);\n    int d = tsp(0, 0);\n    if (d == INF)\n        printf(\"-1\\n\");\n    else\n        printf(\"%d\\n\", d);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\nint V, E, start;\nint dp[1 << 20][20];\nint graph[20][20];\n\nint rec(int ss, int now) {\n    if (dp[ss][now] != -1) {\n        return dp[ss][now];\n    }\n\n    if (ss == (1 << V) - 1 && now == 0) {\n        return dp[ss][now] = 0;\n    }\n\n    int res = iINF;\n\n    REP(next, V) {\n        if ((ss >> next) & 1) {\n            continue;\n        }\n        if (graph[now][next] == -1) {\n            continue;\n        }\n\n        res = min(res, rec(ss | (1 << next), next) + graph[now][next]);\n    }\n\n    return dp[ss][now] = res;\n}\n\n\nint main() { \n    cin >> V >> E;\n    memset(graph, -1, sizeof(graph));\n\n    REP(i, E) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        graph[s][t] = d;\n    }\n\n    memset(dp, -1, sizeof(dp));\n\n    int ans = rec(0, 0);\n\n    cout << (ans == iINF ? -1 : ans) << endl;\n\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "// 巡回セールスマン問題\n// 蟻本p173と同じ。\n// 訪問済状態をビットで表すとbitDPで解ける\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\n\nll INF = 1e18;\n\n// S: これまでたどった頂点  v: 今いる頂点\nll rec(int S, int v,\n        const int V,\n        vector<vector<ll>>& dp, const vector<vector<ll>>& dist) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << V) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    ll res = INF;\n    REP(u, V) {  // vの次に行く頂点をuとする\n        if (!(S | 1 << u)) { // uに未訪問の場合\n            auto d = dist[v][u];\n            if (d != INF) { // v -> uにエッジがある場合\n                res = min(res, rec(S | 1 << u, u, V, dp, dist) + d);\n            }\n        }\n    }\n    return dp[S][v] = res;\n}\n\nll travelling_salesman(int V, vector<vector<ll>>& dist) {\n    vector<vector<ll>> dp(1<<V, vector<ll>(V, -INF));\n    return rec(0, 0, V, dp, dist);\n}\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<ll>> dist(V, vector<ll>(V, INF));\n    REP(e, E) {\n        int s, t;\n        ll d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n    auto ret = travelling_salesman(V, dist);\n    cout << (ret == INF ? -1 : ret) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define veci vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\n\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\n//template<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\n//template<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x:vec) is >> x;\n    return is;\n}\nconst ll INF=1e9+7;\n\nll d[20][20];\nll dp[1<<20][20];\n\nint main()\n{\n    ll v,e;\n    cin >> v >> e;\n    rep(i,20){\n        rep(j,20){\n            d[i][j]=INF;\n        }\n    }\n    rep(i,e){\n        ll s,t,p;\n        cin >> s >> t >> p;\n        d[s][t]=p;\n    }\n    for(ll s=0;s<(1<<v);s++){\n        rep(i,v){\n            dp[s][i]=INF;\n        }\n    }\n    dp[(1<<v)-1][0]=0;\n    for(ll s=(1<<v)-2;s>=0;s--){\n        rep(i,v){\n            rep(j,v){\n                if(!(s>>j&1)){\n                    //cout << dp[s][i] << endl;\n                    dp[s][i]=min(dp[s][i],dp[s|(1<<j)][j]+d[i][j]);\n                    \n                }\n            }\n        }\n    }\n    \n    \n    cout << (dp[0][0]>=INF?-1:dp[0][0]) << endl;\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_CITY_NUM 15\n#define MAX 100000000\n\nint D[MAX_CITY_NUM][MAX_CITY_NUM];\n\nint dp[MAX_CITY_NUM][1 << MAX_CITY_NUM];\n\nint tsp(int v, int b, int city_num){\n    int rtn = MAX;\n    //??¨????????????????¨??????????\n    if(b == (1 << city_num) - 1){\n        if (D[v][0] == -1) {\n            return rtn;\n        }else{\n            return D[v][0];\n        }\n    }\n    \n    for (int i = 0; i < city_num; i++) {\n        //????¨?????????????????¨??????????\n        if (\n            !(b & (1 << i))\n            &&\n            D[v][i] != -1\n            )\n        {\n            int cost = dp[i][b | (1 << i)] != 0 ? dp[i][b | (1 << i)] : tsp(i, b | (1 << i), city_num);\n            dp[i][b | (1 << i)] = cost;\n            rtn = min( rtn, D[v][i] + cost);\n        }\n    }\n    \n    return rtn;\n}\n\n\n\nint main(){\n    \n    int V, E, frm, to, cost, ans;\n    \n    cin >> V >> E;\n    \n    //-1??§?????????\n    memset(D, -1, sizeof(D));\n    for (int i = 0; i < E; i++){\n        cin >> frm >> to >> cost;\n        D[frm][to] = cost;\n    }\n    \n    ans = tsp(0, 1, V);\n    \n    if (ans >= MAX) {\n        cout << -1 << endl;\n    }\n    else{\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000007;\n\nint G[15][15];\nint dp[1 << 15][15][15];\n\nint main(){\n    int V, E;\n    scanf(\"%d%d\", &V, &E);\n    for(int i = 0; i < V; i++){\n        fill(G[i], G[i] + V, INF);\n        G[i][i] = 0;\n    }\n    for(int i = 0; i < E; i++){\n        int s, t, d;\n        scanf(\"%d%d%d\", &s, &t, &d);\n        G[s][t] = d;\n    }\n    for(int i = 0; i < (1 << 15); i++){\n        for(int j = 0; j < 15; j++){\n            for(int k = 0; k < 15; k++){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    for(int i = 0; i < 15; i++){\n        dp[0][i][i] = 0;\n    }\n    for(int b = 0; b < (1 << V); b++){\n        for(int i = 0; i < 15; i++){\n            for(int j = 0; j < 15; j++){\n                for(int k = 0; k < 15; k++){\n                    if(((b >> k) & 1) == 0 && G[j][k] < INF){\n                        int next_b = b | (1 << k);\n                        dp[next_b][i][k] = min(dp[next_b][i][k],\n                                               dp[b][i][j] + G[j][k]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 0; i < V; i++){\n        ans = min(ans, dp[(1 << V) - 1][i][i]);\n    }\n    if(ans < INF){\n        printf(\"%d\\n\", ans);\n    }else{\n        puts(\"-1\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 10000000\nint V, E;\nint dp[1 << 16][20] = { 0 }, d[20][20] = { 0 };\nint main() {\n\tfor (int i = 0; i < (1 << 16); i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < 20; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tcin >> V >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, c;\n\t\tcin >> s >> t >> c;\n\t\td[s][t] = c;\n\t}\n\tdp[1][0] = 0;\n\tfor (int i = 0; i < (1 << V); i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\t\tif ((i >> k) & 1) continue;\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + d[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 0; i < V; i++) {\n\t\tres = min(res, dp[(1 << V) - 1][i] + d[i][0]);\n\t}\n\tif (res == INF) res = -1;\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const int INTINF = (2147483647 >> 1);\nstatic const ll LLINF = (9223372036854775807 >> 1);\nstatic const int MAX = 1e5+1;\nstatic const ll MOD = 1e9+7;\n\nnamespace Printer{\n    template<class T>\n    void print(T x){\n        cout << x << endl;\n    }\n\n    template<class T>\n    void print(T x, T y){\n        cout << x << \",\" << y << endl;\n    }\n\n    template<class T>\n    void print(vector<T> v){\n        rep(i, v.size()){\n            if(i) cout << \" \";\n            cout<< v[i];\n        }\n        cout << endl;\n    }\n\n    template<class T>\n    void print(vector<vector<T> > vv){\n        rep(i, vv.size()){\n            rep(j, vv[i].size()){\n                if(j) cout << \" \";\n                cout << vv[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    void print(pair<int, int> p){\n        cout << \"(\" << p.first << \", \" << p.second << \")\" << endl;\n    }\n};\nusing namespace Printer;\n\n//--global--//\n\nconst int maxN = 15;\nint size_v, size_e;\nvector<vector<int> > vv;\nvector<vector<int> > g;\nint dp[1 << maxN][maxN];\n\n//----------//\n\nint solve(int s, int v){\n    if(dp[s][v] >= 0){\n        return dp[s][v];\n    }\n\n    if(s == (1 << (size_v))-1 && v == 0){\n        return dp[s][v] = 0;\n    }\n\n\n    int new_cost = INTINF;\n    for(int u : vv[v]){\n        if(!(s >> u & 1)){\n            int tmp = solve(s | (1 << u), u) + g[v][u];\n            if(tmp < new_cost){\n                new_cost = tmp;\n            }\n        }\n    }\n\n    return dp[s][v] = new_cost;\n}\n\nint main(int argc, const char * argv[]) {\n    //提出時、消す----//\n\n    cin >> size_v >> size_e;\n    vv.resize(size_v);\n    g.resize(size_v);\n    rep(i, size_v){\n        g[i].resize(size_v);\n    }\n\n    rep(i, size_e){\n        int s, t, d;\n        cin >> s >> t >> d;\n        vv[s].push_back(t);\n        g[s][t] = d;\n    }\n\n    memset(dp, -1, sizeof(dp));\n    int ans = solve(0, 0);\n    if(ans == INTINF) cout << -1 << endl;\n    else cout << ans << endl;\n\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nconst int VMAX = 16, INF = VMAX * 1000;\nint dist[VMAX][VMAX];\n\nint dp[1 << VMAX][VMAX];\n\nvoid init(int V) {\n  REP(i, V) {\n    REP(j, V) {\n      dist[i][j] = INF;\n    }\n  }\n  REP(i, 1 << V) {\n    REP(j, V) {\n      dp[i][j] = INF;\n    }\n  }\n}\n\nvoid solve(int V) {\n  dp[(1 << V) - 1][0] = 0;\n  for (int S = (1 << V) - 1; S >= 0; S--) {\n    for (int v = 0; v < V; v++) {\n      for (int u = 0; u < V; u++) {\n        if (!((S >> u) & 1)) {\n          dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dist[u][v]);\n        }\n      }\n    }\n  }\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  init(V);\n  REP(i, E) {\n    int s, t, d;\n    cin >> s >> t >> d;\n    dist[s][t] = d;\n  }\n\n  solve(V);\n\n  cout << (dp[0][0] == INF ? -1 : dp[0][0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint inf = 1000*16;\nvector<vector<int>> dist(15, vector<int>(15, inf));  // グラフ構造\nvector<vector<int>> dp(pow(2, 15), vector<int>(15, 0));\n\nint rec(long long S, int v)\n{\n    if (S==0 && v==0) return 0;\n    if (!(S & (1<<v))) return inf;\n\n    if (dp[S][v]) return dp[S][v];\n    int &ret = dp[S][v];\n    ret = inf;\n    for (int i=0; i<15; i++)\n    {\n        ret = min(ret, rec(S^(1<<v), i) + dist[i][v]);\n    }\n    return ret;\n}\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n\n    // グラフの初期化\n    for (int i=0; i<15; i++)\n    {\n        for (int j=0; j<15; j++) dist[i][j] = inf;\n    }\n    \n    for (int i=0; i<E; i++)\n    {\n        int s,t,d;\n        cin >> s >> t >> d;\n        dist[s][t]=d;\n    }\n\n    int ans = rec((1<<V)-1, 0);\n    if (ans >= inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <climits>\n#include <functional>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__)\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\n\nstruct E {\n\tint t, d;\n};\n\nint main() {\n\tint n {in}, e {in};\n\tV<V<E>> G(n);\n\ttimes (i, e) {\n\t\tint s {in};\n\t\tG[s].push_back({in, in});\n\t}\n\tV<V<int>> d(1 << n, V<int>(n, -1));\n\tint inf {INT_MAX / 2};\n\tfunction<int(int, int)> rec = [&] (int S, int v) {\n\t\tif (d[S][v] >= 0)\n\t\t\treturn d[S][v];\n\t\tif (S == (1 << n) - 1 && !v)\n\t\t\treturn d[S][v] = 0;\n\t\tint r {inf};\n\t\tfor (E u: G[v])\n\t\t\tif (!(S >> u.t & 1))\n\t\t\t\tr = min(r, rec(S | 1 << u.t, u.t) + u.d);\n\t\treturn d[S][v] = r;\n\t};\n\tint r {rec(0, 0)};\n\toutl(r > inf / 2 ? -1 : r);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n#include <string.h>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define max3(A,B,C) max((A),max((B),(C)))\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n\nconst int N = 15;\nconst int INF = 0x3f3f3f3f;\n\nint pd[1 << N][N][N];\n\nint main(void) {\n   int n, m;\n   int adj[N][N];\n\n   for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n         adj[i][j] = (i == j ? 0 : INF);\n      }\n   }\n   for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) pd[0][i][j] = 0;\n   for(int i = 1; i < 1 << N; i++) {\n      for(int j = 0; j < N; j++) {\n         for(int k = 0; k < N; k++) {\n            pd[i][j][k] = INF;\n         }\n      }\n   }\n\n   scanf(\"%d %d\", &n, &m);\n   for(int i = 0; i < m; i++) {\n      int a, b, c;\n      scanf(\"%d %d %d\", &a, &b, &c);\n      adj[a][b] = c;\n   }\n\n   for(int i = 1; i < 1 << n; i++) {\n      for(int j = 0; j < n; j++) {\n         if( (i & (1 << j)) == 0) continue;\n         for(int w = 0; w < n; w++) {\n            if( (i & (1 << w)) == 0) continue;\n            for(int k = 0; k < n; k++) {\n               if(i & (1 << k)) {\n                  if(i - k != 0 || k == w) {\n                     pd[i][j][w] = min(pd[i][j][w], pd[i^(1<<j)][k][w] + adj[k][j]);\n                  }\n               }\n            }\n         }\n      }\n   }\n\n   int minn = INF;\n   int idx = (1 << n) - 1;\n   for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n         minn = min(minn, pd[idx][i][j] + adj[i][j]);\n      }\n   }\n\n   if(minn == INF) puts(\"-1\");\n   else printf(\"%d\\n\", minn);\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define INF (1 << 30)\n#define ll long long\n#define MAX_N 16\nusing namespace std;\n\nll V, E;\nll G[MAX_N][MAX_N];\nll dp[1 << MAX_N][MAX_N];\n\nll rec(int S, int v) {\n\tif (dp[S][v] >= 0) {\n\t\treturn dp[S][v];\n\t}\n\n\tif (S == (1 << V) - 1 && v == 0) {\n\t\treturn dp[S][v] = 0;\n\t}\n\n\tll res = INF;\n\tfor (int u = 0; u < V; u++) {\n\t\tif (!(S >> u & 1)) {\n\t\t\tres = min(res, rec(S | 1 << u, u) + G[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> V >> E;\n\tfor (int i = 0; i < MAX_N;i++) {\n\t\tfor (int j = 0; j < MAX_N;j++) {\n\t\t\tG[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\tG[s][t] = d;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tll Ans = rec(0, 0);\n\tif (Ans == INF)cout << -1 << endl;\n\telse cout << Ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\n\nint dp [1 << 16 ][16];\nint d[16][16]={inf};\nint main(){\n\tint V,E;\n\tcin >> V >> E;\n\trep(i,16){\n\t\trep(j,16){\n\t\t\td[i][j]=inf;\n\t\t}\n\t}\n\trep(i,1 << 16){\n\t\trep(j,16){\n\t\t\tdp[i][j]=inf;\n\t\t}\n\t}\n\trep(i,E){\n\t\tint s,t,di;\n\t\tcin >> s >> t >> di;\n\t\td[s][t]=di;\n\t}\n\tdp[(1 << V) -1][0]=0;\n\tfor(int S=(1 << V)-2;S >= 0;S--){\n\t\tfor(int s=0;s<V;s++){\n\t\t\tfor(int t=0;t<V;t++){\n\t\t\t\tif(!(S >> t & 1)){\n\t\t\t\t\tdp[S][s]=min(dp[S][s],dp[S | 1 << t][t]+d[s][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ((dp[0][0] == inf ) ? -1 : dp[0][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = 1e9;\n\nint V, E;\nvector< vector<int> > dist(22, vector<int>(22, -1));\nint dp[(1<<20)+1][22];\n\nint main() {\n    cin >> V >> E;\n    for(int i = 0; i < E; ++i) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist[s][t] = d;\n    }\n\n    for(int bit = 0; bit < (1<<V); ++bit) {\n        for(int v = 0; v < V; ++v) {\n            dp[bit][v] = INF;\n        }\n    }\n\n    dp[0][0] = 0;\n    for(int bit = 0; bit < (1<<V); ++bit) {\n        for(int now = 0; now < V; ++now) {\n            for(int to = 0; to < V; ++to) {\n                if((bit & (1<<to)) == 0 && dist[now][to] != -1) {\n                    chmin(dp[bit|1<<to][to], dp[bit][now]+dist[now][to]);\n                }\n            }\n        }\n    }\n\n    if(dp[(1<<V)-1][0] == INF) {\n        cout << -1 << endl;\n    }else {\n        cout << dp[(1<<V)-1][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 15001\n\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n\n\t巡回セールスマン問題。\n\n\tdp[V][0] = 0\n\tdp[S][v] = min {dp[S ∪ [u]][u] + d(v,u)| u ? S}\n\n\t参考：蟻本 p 174\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MAX_V = 15;\n\nint V, E;\nint d[MAX_V][MAX_V];\nint dp[1<<MAX_V][MAX_V];\t// メモ化テーブル\nint s;\t\t\t\t// スタート位置\n\n// すでに訪れた頂点がS、現在位置が v\nint dfs (int S, int v ){\n\tif (dp[S][v] >= 0 ) return dp[S][v];\n\n\tif (S == (1<<V)-1 && v == s ){\n\t// すべての頂点を訪れて戻って来た\n\t\treturn dp[S][v] = 0;\n\t} // end if\n\n\tint res = INF;\n\tfor (int u = 0; u < V; u++ ){\n\t\tif (!(S>>u & 1 ) ){\n\t\t\t// 次に u に移動する\n\t\t\tres = min (res, dfs (S | (1<<u), u ) + d[v][u] );\n\t\t} // end if\n\t} // end for\n\n\treturn dp[S][v] = res;\n}\n\nint main()\n{\n\trep (i, MAX_V ) rep (j, MAX_V ) d[i][j] = INF;\n\n\tios_base::sync_with_stdio(0);\n\tcin >> V >> E;\n\trep (i, E ){\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\td[from][to] = cost;\n\t} // end rep\n\n\tint res = INF;\n\trep (i, V ){\n\t\tmemset (dp, -1, sizeof (dp ) );\n\t\tres = min (res, dfs (0, i ) );\n\t} // end rep\n\tcout << (res == INF ? -1 : res ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint n, m;\nint start;\nstruct edge\n{\n    int to, cost;\n    edge(int to, int cost) : to(to), cost(cost) {}\n};\nvector<edge> G[18];\nint dp[1<<18][18];\nint dfs(int bit, int now)\n{\n    if(dp[bit][now] >= 0) return dp[bit][now];\n    if(now == 0 and __builtin_popcount(bit) == n) return dp[bit][now] = 0;\n    int res = INF;\n    for(int u = 0; u < G[now].size(); u++)\n    {\n        edge e = G[now][u];\n        if(bit & (1<<e.to)) continue;\n        res = min(res, dfs(bit | (1<<e.to), e.to) + e.cost);\n    }\n    return dp[bit][now] = res;\n}\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    memset(dp, -1, sizeof(dp));\n    cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int s, t, d; cin >> s >> t >> d;\n        G[s].push_back(edge(t, d));\n    }\n    int ans = dfs(0, 0);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconst int INF = 1e9;\n\nint V, E;\nvector<vector<int> > dist;\nvector<vector<int> > dp;\n\nint rec(int S = (1 << V) - 1, int to = 0) {\n    if (S == 0) {\n        return (to) ? INF : 0;\n    }\n    if (!(S & (1 << to))) {\n        return INF;\n    }\n    int &ret = dp.at(S).at(to);\n    if (ret != -1) {\n        return ret;\n    }\n    ret = INF;\n    for (int from = 0; from < V; ++from) {\n        ret = min(ret, rec(S ^ (1 << to), from) + dist.at(from).at(to));\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> V >> E;\n    dist.assign(V, vector<int>(V, INF));\n    for (int i = 0; i < E; ++i) {\n        int s, t, d;\n        cin >> s >> t >> d;\n        dist.at(s).at(t) = d;\n    }\n\n    dp.resize(1 << V, vector<int>(V, -1));\n    int ans = rec();\n\n    cout << ((ans == INF) ? -1 : ans) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// \n// Traveling Salesman Problem (Branch-and-Bound)\n//\n// Description:\n//   It finds TSP by branch-and-bound algorithm that computes\n//   a lower bound from the reduced cost matrix.\n//   This procedure is similar to the Kuhn-Munkres algorithm.\n//\n//   In practice, it scales to networks with |V| <= 40.\n//\n//   \n// References:\n//   J. D. C. Little, K. G. Murty, D. W. Sweeney, and C. Karel (1963):\n//   An algorithm for traveling salesman problem. \n//   Operations Research, vol. 11, pp. 972--989.\n//\n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\nconst double INF = 1.0 / 0.0;\nstruct traveling_salesman_problem {\n  int n;\n  vector<vector<double>> w; // set solver.w[i][j] = infty, etc\n  traveling_salesman_problem(int n) : n(n), w(n, vector<double>(n, INF)) { }\n\n  double dynamic_programming() {\n    vector<vector<double>> c(n, vector<double>(1<<n, INF));\n    vector<vector<int>> p(n, vector<int>(1<<n,-1));\n    c[0][1] = 0; // 0 start\n    for (size_t S = 0; S < (1<<n); ++S) {\n      for (int i = 0; i < n; ++i) {\n        if (!(S & (1 << i))) continue;\n        for (int j = 0; j < n; ++j) {\n          if (S & (1 << j)) continue;\n          if (c[j][S|(1<<j)] > c[i][S] + w[i][j]) {\n            c[j][S|(1<<j)] = c[i][S] + w[i][j];\n            p[j][S|(1<<j)] = i;\n          }\n        }\n      }\n    }\n    int last;\n    double ans = INF;\n    for (int i = 0; i < n; ++i) {\n      if (ans > c[i][(1<<n)-1] + w[i][0]) {\n        ans = c[i][(1<<n)-1] + w[i][0];\n        last = i;\n      }\n    }\n    vector<int> path(n);\n    int S = (1 << n) - 1;\n    path[n-1] = last;\n    for (int i = n-1; i >= 1; --i) {\n      path[i-1] = p[path[i]][S];\n      S ^= (1 << path[i]);\n    }\n    return ans;\n  }\n  double brute_force() {\n    vector<int> tour;\n    for (int i = 0; i < n; ++i)\n      tour.push_back(i);\n    double ans = INF;\n    do {\n      double cost = 0;\n      for (int i = 0; i < tour.size(); ++i) {\n        cost += w[tour[i]][tour[(i+1)%n]];\n      }\n      ans = min(ans, cost);\n    } while (next_permutation(tour.begin()+1, tour.end()));\n    return ans;\n  }\n\n  vector<int> next, prev, best;\n  double upper_bound;\n  void explore(int edges, double cost, vector<int> row, vector<int> col) {\n    int size = row.size();\n    vector<double> rowred(size, INF), colred(size, INF);\n    for (int i = 0; i < size; ++i) {\n      for (int j = 0; j < size; ++j) \n        rowred[i] = min(rowred[i], w[row[i]][col[j]]);\n      for (int j = 0; j < size; ++j) \n        if (w[row[i]][col[j]] < INF) \n          w[row[i]][col[j]] -= rowred[i];\n      cost += rowred[i];\n    }\n    for (int j = 0; j < size; ++j) {\n      for (int i = 0; i < size; ++i) \n        colred[j] = min(colred[j], w[row[i]][col[j]]);\n      for (int i = 0; i < size; ++i) \n        if (w[row[i]][col[j]] < INF) \n          w[row[i]][col[j]] -= colred[j];\n      cost += colred[j];\n    }\n    if (cost < upper_bound) {\n      if (edges == n - 2) {\n        upper_bound = cost;\n        best = next;\n        best[row[0]] = col[0];\n        best[row[1]] = col[1];\n        if (w[row[0]][col[0]] >= INF) \n          swap(best[row[0]], best[row[1]]);\n      } else {\n        int r, c;\n        double most = -INF; \n        for (int i = 0; i < size; ++i) {\n          for (int j = 0; j < size; ++j) {\n            if (w[row[i]][col[j]] != 0) continue;\n            double minrow = INF, mincol = INF;\n            for (int k = 0; k < size; ++k) {\n              if (i != k) minrow = min(minrow, w[row[k]][col[j]]);\n              if (j != k) mincol = min(mincol, w[row[i]][col[k]]);\n            }\n            if (most < minrow + mincol) {\n              most = minrow + mincol;\n              r = i;\n              c = j;\n            }\n          }\n        }\n        next[row[r]] = col[c];\n        prev[col[c]] = row[r];\n\n        int last = col[c], first = row[r];\n        while (next[last] >= 0) last = next[last];\n        while (prev[first] >= 0) first = prev[first];\n        double colrowval = w[last][first];\n        w[last][first] = INF;\n        vector<int> newrow = row, newcol = col;\n        newrow.erase(newrow.begin() + r);\n        newcol.erase(newcol.begin() + c);\n        explore(edges + 1, cost, newrow, newcol);\n        w[last][first] = colrowval;\n\n        prev[col[c]] = -1;\n        next[row[r]] = -1;\n\n        if (cost + most < upper_bound) {\n          w[row[r]][col[c]] = INF;\n          explore(edges, cost, row, col);\n          w[row[r]][col[c]] = 0;\n        }\n      }\n    }\n    for (int i = 0; i < size; ++i)\n      for (int j = 0; j < size; ++j)\n        w[row[i]][col[j]] += rowred[i] + colred[j];\n  }\n\n  double solve() {\n    vector<int> row(n), col(n);\n    for (int i = 0; i < n; ++i) row[i] = col[i] = i;\n    upper_bound = INF;\n    prev = next = vector<int>(n, -1);\n    explore(0, 0, row, col);\n\n    if (upper_bound < INF) {\n      vector<int> path(n); // solution\n      path[0] = 0;\n      for (int i = 1; i < n; ++i) \n        path[i] = best[path[i-1]];\n    }\n    return upper_bound;\n  }\n};\n\n\n// === tick a time ===\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\n\n/*\nint main() {\n  for (int iter = 0; iter < 1000; ++iter) {\n    srand(iter);\n    int n = 40;\n    traveling_salesman_problem tsp(n);\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if (i != j) tsp.w[i][j] = rand() % 1000 + 1;\n\n    tick();\n    double a = 0;// tsp.brute_force();\n    double ta = tick();\n    double b = 0;// tsp.dynamic_programming();\n    double tb = tick();\n    double c = tsp.solve();\n    double tc = tick();\n\n    a = b =c;\n    printf(\"%f %f\\n%f %f\\n%f %f\\n\\n\", a, ta, b, tb, c, tc);\n    if (a != b || b != c) {\n      printf(\"seed = %d\\n\", iter);\n      exit(-1);\n    }\n  }\n}\n*/\n\n// AOJ: DPL_2_A\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  traveling_salesman_problem tsp(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    tsp.w[u][v] = w;\n  }\n  double ans = tsp.solve();\n  if (ans < INF) printf(\"%.0f\\n\", ans);\n  else           printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nusing P = pair<ll, ll>;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, pair<T,T> &P){\n    os << P.first;\n    os << \" \";\n    os << P.second;\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n     os<<endl;\n    return os;\n}\nbool is_one(int bit){\n    while(bit%2==0){\n        bit>>=1;\n    }\n    return bit==1;\n}\n//fixed<<setprecision(10)<<ans<<endl;\nll TravelingSalesmanProblem(vector<vector<P>> &edge, int N,int start=0){\n    ll max_bit = 1<<N; //MAX_BIT\n    vector<vector<ll>> dp(max_bit,vector<ll>(N,INF)); //dp[bit][i]:=bitのすべてをまわり、iにいるときの最短路\n    dp[1][0] = 0; //始点は0\n\n    //配るDP\n    ll from,to,dist;\n    for(ll bit_mask=1;bit_mask<max_bit;bit_mask++){\n        REP(from,N){\n            if(dp[bit_mask][from]>=INF) continue; //未実現の状態\n            for(auto e: edge[from]){\n                tie(to,dist) = e; //行き先、距離\n                if( (1<<to) & bit_mask ) continue;\n                ll next_bit = 1<<to | bit_mask;\n                chmin(dp[next_bit][to], dp[bit_mask][from]+dist);\n            }\n        }\n    }\n\n    ll ans = INF;\n    REP(from,N){\n        for(auto e:edge[from]){\n            tie(to,dist) = e;\n            if(to==start)\n                chmin(ans,dp[max_bit-1][from]+dist);    \n        }\n    }\n\n    return ans;\n}\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,M;\n    cin >> N >> M;\n    \n    //辺入力\n    vector<vector<pair<ll,ll>>> edge(N);\n    vector<P> edge_to_zero;\n    REP(i,M){\n        ll a,b,c;\n        cin  >> a >> b >> c;\n        edge[a].push_back(mp(b,c));\n        if(b==0) edge_to_zero.push_back(mp(a,c));\n    }\n\n    ll ans = TravelingSalesmanProblem(edge,N);\n    if(ans>=INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n4 6\n0 1 2\n1 2 3\n1 3 9\n2 0 1\n2 3 6\n3 2 4\n*/\n\n\n#include <bits/stdc++.h>\n#define MAX 20\n#define INF LLONG_MAX\nusing namespace std;\n\ntypedef long long int ll;\n\nll wt[MAX][MAX];\n\n// O based indexing is being used for ease\n// Node 1 will be represented at the Lowest Significant bit of the number\n// Simply subtract one from each Node number incase the nodes are one based\n// n is the number of cities\n\n// Logic in short:\n// Suppose we have some elements in the Set A (i)\n// We see all the cities (in set A only) at which ending is possible\n// Let the possible ending be j\n// Since we have already calculated all these values for the present set i.e dp[i][j]\n// We see other cities which have not been included in the set A\n// Let these non included cities be k\n// Let a new set B = set A U {k} \n// Let set B be called p\n// dp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\n\n\nll dp[(1 << MAX) + 5][MAX];\nll n, m;\nll u,v,w;\nll p;\n\nvoid initialize(){\n\n\tfor(ll i = 0; i < n; i++)\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\twt[i][j] = INF;\n\t\t}\n\tfor(ll i = 0; i < ( 1 << n); i++)\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tdp[i][j] = -1;\n\tdp[1][0] = 0;\n}\n\nvoid tsp()\n{\n\tfor(ll i = 1; i < (1 << n); i++){ \n\t\t// This loop represents the current state, i.e the contents of the set\n\t\tfor(ll j = 0; j < n; j++){\n\t\t\t// j variable tells the ending city\n\t\t\t// during the current state, the last station is j\n\t\t\tif(dp[i][j] == -1)\n\t\t\t{\n\t\t\t\tcontinue;// Incase its impossible to start at 0 and end at j, for eg dp[anyNumber][0], \n\t\t\t\t//Since you cant start at 0 and end at 0\n\t\t\t} \n\t\t\tfor(ll k = 1; k < n; k++){\n\t\t\t\t//cout<<k<<endl;\n\t\t\t\t// This indicates the new city which is going to be included\n\t\t\t\tif(((i & (1 << k)) != 0) || wt[j][k] == INF) // Note that relational op > bitwise op\n\t\t\t\t{\n\t\t\t\t\tcontinue; // i.e. the city was already in the set\n\t\t\t\t}\n\t\t\t\tp = i | (1 << k); // the new state(join k)\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\tif(dp[p][k] == -1)\n\t\t\t\t\tdp[p][k] = dp[i][j] + wt[j][k];\n\t\t\t\telse\n\t\t\t\t\tdp[p][k] = min(dp[p][k], dp[i][j] + wt[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nll minimum_cost()\n{\n\tll ans = INF;\n\tfor(ll i = 1; i < n; i++)\n\t{\n\t\tif(dp[(1 << n) - 1][i] == -1 || wt[i][0] == INF) continue;\n\t\tans = min(ans, dp[(1 << n) - 1][i] + wt[i][0]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n; // number of cities\n\tcin>>m; // number of edges\n\tinitialize();\n\tfor(ll i = 0; i < m; i++)\n\t{\n\t\tcin>>u>>v>>w;\n\t\twt[u][v] = w;\n\t\t//wt[v][u] = w;\n\t}\n\t//floyd_warshall();\n\ttsp();\n\tll ans = minimum_cost();\n\tif(ans != INF) \n\t\tcout<<ans<<endl;\n\telse cout<<-1<<endl;\n\t/*for(ll i = 0; i < n; i++)\n\t{\n\t\tfor(ll j = 0; j < n; j++)\n\t\t\tcout<<wt[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<n<<endl;\n\tfor(ll i = 0; i < (1 << n); i++)\n\t{\n\t\tfor(ll j = 0 ; j < n; j++)\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 15\n#define INF 1<<28\nint n;\nint d[MAX][MAX];\nint dp[1<<MAX][MAX];\n//s=?¨??????????,v=?????¨??????\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v==0)return dp[s][v]=0;\n  int res=INF;\n  for(int u=0;u<n;u++)\n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nint main(){\n  memset(dp,-1,sizeof(dp));\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  int m;\n  cin>>n>>m;\n  while(m--){\n    int s,t,dd;\n    cin>>s>>t>>dd;\n    d[s][t]=dd;\n  }\n  cout<<rec(0,0)<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP=NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask) * n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) /*&& 1 == GetBit(mask, vertex)*/ && 0 != pointRib[vertex*n + i] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n + i] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n]){\n\t\t\tif (0 == min || (min>(dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\tif (x != y && 0 == weight){\n\t\t\tweight = -1;\n\t\t}\n\t\trib[x*n + y] = weight;\n\t}\n\tint j;\n\tint k;\n\tfor (i = 0; i < n; i++){\n\t\tfor (j = 0; j < n; j++){\n\t\t\tif (-1 == rib[i*n + j]){\n\t\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\t\tif (0 != rib[i*n + k])\n\t\t\t\t\trib[j*n + k] = rib[i*n + k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\n#define MAX_V 15\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nstatic const int INF = 1000000000;\n\nint d[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\nint V;\n\nint\nrec(int S, int v)\n{\n\tint u;\n\n\tif (dp[S][v] >= 0)\n\t\treturn dp[S][v];\n\n\tif (S == (1 << V) - 1 && v == 0)\n\t\treturn dp[S][v] = 0;\n\n\tint res = INF;\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tif (!(S >> u & 1))\n\t\t{\n\t\t\tint t = rec(S | 1 << u, u) + d[v][u];\n\t\t\tres = min(res, t);\n\t\t}\n\t}\n\n\treturn dp[S][v] = res;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t, c;\n\tint i, j;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tfor (j = 0; j < V; ++j)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\td[i][j] = 0;\n\t\t\telse\n\t\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\td[s][t] = c;\n\t}\n\n\tfor (i = 0; i < 1 << V; ++i)\n\t{\n\t\tfor (j = 0; j < V; ++j)\n\t\t\tdp[i][j] = -1;\n\t}\n\n\tint res = rec(0, 0);\n\tif (res == INF)\n\t\tres = -1;\n\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 2000\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {  // last ?\n                if (r->unvisited == 0) {\n                    cost = r->cost + dist;\n                    goto route_found;\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    route_found:;\n\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 300\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {  // last ?\n                if (r->unvisited == 0) {\n                    cost = r->cost + dist;\n                    goto route_found;\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    route_found:;\n\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define INF 100000\nint V,E;\nint G[15][15];\nint dp[1<<15][15];\nint min(int a,int b){\n  if(a<b)return a;\n  else return b;\n}\nvoid print(){\n  int i,j;\n  for(i=0;i<V;i++){\n    for(j=0;j<V;j++){\n      printf(\"%d \",dp[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\nint rec(int S,int v){\n  if(dp[S][v]>=0)\n    return dp[S][v];\n\n  if(S==(1<<V)-1 && v==0)\n    return dp[S][v]=0;\n  int u,res=INF;\n  for(u=0;u<V;u++){\n    if(!(S>>u & 1)){\n      res=min(res,rec(S|1<<u,u)+G[v][u]);\n    }\n  }\n  return dp[S][v]=res;\n}\n\nint main(){\n  int i,j;\n  int s,t,d;\n  int min=100000;\n  int ans;\n  scanf(\"%d %d\",&V,&E);\n  memset(dp,-1,sizeof(dp));\n  for(i=0;i<1<<V;i++){\n    for(j=0;j<V;j++){\n      G[i][j]=INF;\n    }\n  }\n  for(i=0;i<E;i++){\n   scanf(\"%d %d %d\",&s,&t,&d);\n   G[s][t]=d;\n  }\n \n  for(i=0;i<V;i++){\n    ans=rec(0,i);\n    if(min>ans)min=ans;\n  }\n  if(min==INF)min=-1;\n  printf(\"%d\\n\",min); \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 100000\n\nint V, E, dist[15][15];\nunsigned short *dist_memo;\n\ninline int unvisited(int flag, int vertex) {\n    return flag & (1 << vertex);\n}\n\ninline int visit(int flag, int vertex) {\n    return flag & ~(1 << vertex);\n}\n\nint travel(int vertex, int unvisited_vertex) {\n    int v, d, idx, min_dist = INF;\n    idx = (vertex * (1<<V)) + unvisited_vertex;\n    d = dist_memo[idx];\n    if (d != 0) return d;\n\n    for (v = 0; v < V; v++) {\n        if (dist[vertex][v] <= 0) {\n            continue;\n        }\n        if (unvisited(unvisited_vertex, v)) {\n            if (v == 0) {\n                if (visit(unvisited_vertex, 0) == 0) {\n                    min_dist = dist[vertex][v];\n                }\n            }\n            else {\n                d = travel(v, visit(unvisited_vertex, v))\n                    + dist[vertex][v];\n                if (d < min_dist) {\n                    min_dist = d;\n                }\n            }\n        }\n    }\n    dist_memo[idx] = min_dist;\n    return min_dist;\n}\n\nint main() {\n    int i, j, s, t, d, distance, unvisited_vertex;\n\n\n    scanf(\"%d %d\", &V, &E);\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            dist[i][j] = 0;\n        }\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        dist[s][t] = d;\n    }\n\n    dist_memo = (unsigned short *)calloc(V * (1<<V), sizeof(unsigned short));\n\n    unvisited_vertex = 0;\n    for (i = 0; i < V; i++) {\n        unvisited_vertex |= 1 << i;\n    }\n    distance = travel(0, unvisited_vertex);\n    if (distance >= INF) {\n        distance = -1;\n    }\n    printf(\"%d\\n\", distance);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\n#define MAX_V 15\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nstatic const int INF = 1000000000;\n\nint d[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\nint V;\n\nint\nsolve()\n{\n\tint S, u, v;\n\tint e;\n\n\te = 1 << V;\n\tfor (S = 0; S < e; ++S)\n\t{\n\t\tfor (v = 0; v < V; ++v)\n\t\t\tdp[S][v] = INF;\n\t}\n\n\tdp[e - 1][0] = 0;\n\tfor (S = e - 2; S >= 0; --S)\n\t{\n\t\tfor (v = 0; v < V; ++v)\n\t\t{\n\t\t\tfor (u = 0; u < V; ++u)\n\t\t\t{\n\t\t\t\tif (!(S >> u & 1))\n\t\t\t\t{\n\t\t\t\t\tint t = dp[S | (1 << u)][u] + d[v][u];\n\t\t\t\t\tdp[S][v] = min(dp[S][v], t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[0][0];\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t, c;\n\tint i, j;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tfor (j = 0; j < V; ++j)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\td[i][j] = 0;\n\t\t\telse\n\t\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\td[s][t] = c;\n\t}\n\n\n\tint res = solve();\n\tif (res == INF)\n\t\tres = -1;\n\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_A Traveling Salesman Problem\n// 2018.5.5 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 0x03030303\n\n#define MAX_V  16\nint dp[1<<MAX_V][MAX_V];\nint d[MAX_V][MAX_V];\n\nint traveling_salesman(int V)\n{\n\tint s, u, v, x;\n\n\tmemset(dp, INF, sizeof(dp));\n\tdp[(1<<V)-1][0] = 0;\n\tfor (s = (1<<V)-2; s >= 0; s--) {\n\t\tfor (v = 0; v < V; v++) {\n\t\t\tfor (u = 0; u < V; u++) {\n\t\t\t\tif ((s>>u) & 1) continue;\n\t\t\t\tx = dp[s | (1<<u)][u] + d[v][u];\n\t\t\t\tif (x < dp[s][v]) dp[s][v] = x;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tint V, E, ans;\n\n\tmemset(d, INF, sizeof(d));\n\tV = in(), E = in();\n\twhile (E--) {\n\t\tint s = in(), t = in();\n\t\td[s][t] = in();\n\t}\n\tans = traveling_salesman(V);\n\tif (ans >= INF) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Find_short(a,b) ((a>>b)&1)\n#define minimum(a,b) ((a<b)?a:b)\n\nlong long int distance[50][50];\nlong long int dp[1<<16][16];\nint Vtx,Edge;\n\nvoid set()\n{\n\tfor(int i=0;i<Vtx;i++)\n\t{\n\t\tfor(int j=0;j<Vtx;j++)\n\t\t{\n\t\t\tdistance[i][j]=1e6;\n\t\t}\n    }\t\n\t\n}\n\nvoid calculate_short_distance()\n{\n\t\n\tfor(int i=1;i<1<<Vtx;i++)\n\t{\n\t   for(int k=0;k<Vtx;k++)\n\t\t  if(Find_short(i,k))\n\t\t  {\n\t\t\tfor(int j=0;j<Vtx;j++)\n\t\t\tif(!Find_short(i,j))\n\t\t\t{\n\t\t\t\tdp[i|1<<j][j]=minimum(dp[i|1<<j][j],dp[i][k] + distance[k][j]);\n\t\t\t}\n\t\t  }\n\t}\n}\n\nint main ()\n{\n\tlong long int answer =1e6;\n\t\n\tlong int source,target,c;\n\t\n\tscanf(\"%d %d\",&Vtx,&Edge); getchar();\n\tset();\n\t\n\tfor(int i=0;i<Edge;i++)\n\t{\t\n\t\tscanf(\"%ld %ld %ld\",&source,&target,&c); getchar();\n\t\tdistance[source][target]= c;\n\t}\n\t\n\tfor(int i=1;i<1<<Vtx;i++)\n\t{\n\t    for(int k=0;k <Vtx;k++)\n\t    {\n\t\t     dp[i][k]=1e6;\n\t\t\t dp[1][0]=0;\n\t\t}\n    }\n    \n    // Calculate the shortest path in graph\n\tcalculate_short_distance();\t\n\t\n\tfor(int j=0;j<Vtx;j++)\n\t\tanswer = minimum(answer,dp[(1<<Vtx)-1][j] + distance[j][0]);\n\t\tprintf(\"%lld\\n\",answer==1e6?-1:answer);\n    \n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP=NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask) * n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 0 != pointRib[vertex*n + i] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n + i] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n]){\n\t\t\tif (0 == min || (min>(dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n + y] = weight;\n\t}\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP=NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask) * n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 1 == pointRib[vertex*n * 2 + i * 2] && (1 == mask || (1<mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n * 2]){\n\t\t\tif (0 == min || (min>(dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n * 2 + 1]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n * 2 + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n * 2, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n*2 + y * 2] = 1;\n\t\trib[x*n*2 + y * 2 + 1] = weight;\n\t}\n\tprintf(\"%d\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n\n#define POS(i,j) ((i)*v+(j))\n#define POSDP(now,state) ((now)*(1<<v)+(state))\n\nint calc(const int now,const int state,const int *d,int *dp,const int v){\n  const int index=POSDP(now,state);\n  if(dp[index]!=-1) return dp[index];//計算済み\n  if(state==(1<<v)-1){//全ての頂点回った-> 0に向かう\n    dp[index]=d[POS(now,0)]>=0?d[POS(now,0)]:-2;\n    return dp[index];\n  }\n  int local=1<<30;\n  int i;\n  for(i=0;i<v;i++){\n    if((state>>i)&0x01) continue;//すでに行った頂点\n    if(d[POS(now,i)]==-1) continue;//辺無し\n    int t=calc(i,state|(1<<i),d,dp,v);\n    if(t>=0){\n      local=MIN(local,d[POS(now,i)]+t);\n    }\n  }\n  dp[index]=(local==(1<<30)?-2:local);\n  return dp[index];\n}\n\nvoid run(void){\n  int v,e;\n  scanf(\"%d%d\",&v,&e);\n  int d[225];\n  int i;\n  for(i=0;i<v*v;i++) d[i]=-1;\n  for(i=0;i<v;i++) d[POS(i,i)]=0;\n  for(i=0;i<e;i++){\n    int s,t,w;\n    scanf(\"%d%d%d\",&s,&t,&w);\n    d[POS(s,t)]=w;\n  }\n  int *dp=(int *)malloc(sizeof(int)*(1<<v)*v);\n  memset(dp,-1,sizeof(int)*v*(1<<v));\n  int ans=calc(0,1,d,dp,v);\n  printf(\"%d\\n\",ans>=0?ans:-1);\n  return;\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define BUF_SIZE 30\n\n// size: specify sizeof(str)\nint get_str(char *str, int size) {\n    if(!fgets(str, size, stdin)) return -1;\n    return 0;\n}\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\nint get_int2(int *a1, int *a2) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d\", a1, a2);\n#else\n#error\n#endif\n  return 0;\n}\n\nint get_int3(int *a1, int *a2, int *a3) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d %d\", a1, a2, a3);\n#else\n#error\n#endif\n  return 0;\n}\n\n#define VERTEX_MAX 15\n#define PAT_MAX (1<<15)\n// 15*1000 <= INF\n#define INF 0x01010101\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint main(void) {\n    int vs, es;\n    get_int2(&vs, &es);\n    int i, j;\n    int mat[VERTEX_MAX][VERTEX_MAX] = {0};\n    memset(mat, 0x01, sizeof(int)*VERTEX_MAX*VERTEX_MAX);\n    for(i = 0; i < es; i++) {\n        int src, dst, dist;\n        get_int3(&src, &dst, &dist);\n        mat[src][dst] = dist;\n    }\n    if(vs==2) {\n        int res = mat[0][1] + mat[1][0];\n        printf(\"%d\\n\", res >= INF ? -1 : res);\n        return 0;\n    }\n\n\n    // dp[pat][last]\n    static int dp[PAT_MAX][VERTEX_MAX] = {0};\n\n    // size = 2\n    for(i = 0; i < vs; i++) {\n        int pat = (1<<i);\n        dp[pat][i] = mat[0][i];\n    }\n\n    // size=>=3\n    int pat;\n    // exclude idx: 0\n    for(pat = 2; pat < (1<<vs); pat+=2) {\n        if(__builtin_popcount(pat) <= 1) continue;\n        int last;\n        for(last = 1; last < vs; last++) {\n            if(!(pat & (1<<last))) continue;\n            int prev_pat = pat & (~(1<<last));\n            int res = INF;\n            int prev_last;\n            for(prev_last = 1; prev_last < vs; prev_last++) {\n                if(!(prev_pat & (1<<prev_last))) continue;\n                if(last == prev_last) continue;\n                res = min(\n                    res, dp[prev_pat][prev_last] + mat[prev_last][last]\n                );\n            }\n#ifdef DEBUG\n            printf(\"dp[pat: %d][last: %d] -> %d\\n\", pat, last, res);\n#endif\n            dp[pat][last] = res;\n        }\n    }\n\n    pat = (1<<vs)-2; // 1111..110\n    int ans = INF;\n    for(i = 1; i < vs; i++) {\n        // circuit\n        ans = min(ans, dp[pat][i] + mat[i][0]);\n    }\n    printf(\"%d\\n\", ans >= INF ? -1 : ans);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n#define Size 15\nlong int dist[Size][Size], dp[1 << Size][Size];\nint rec(int S, int v, int size);\nint main(void)\n{\n  int i, j, n, e, s, t, d;\n  scanf(\"%d%d\\n\", &n, &e);\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      dist[i][j] = INT_MAX;\n    }\n  }\n  memset(dp, -1, sizeof(dp));\n  for (i = 0; i < e; i++) {\n    scanf(\"%d%d%d\", &s, &t, &d);\n    dist[s][t] = d;\n  }\n  d = rec(0, 0, n);\n  if (d == INT_MAX) printf(\"-1\\n\");\n  else printf(\"%d\\n\", d);\n}\nint rec(int S, int v, int size)\n{\n  long int u, res = INT_MAX;\n  if (dp[S][v] >= 0) return dp[S][v];\n  if (S == (1 << size) - 2) return dp[S][v] = dist[v][0];\n  for (u = 1; u < size; u++) {\n    if (!(S >> u & 1)) {\n      long int tmp = rec(S | 1 << u, u, size) + dist[v][u];\n      if (res > tmp) res = tmp;\n    }\n  }\n  return dp[S][v] = res;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 300\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        if (r->vertex_id == 0 && r->unvisited == 0) {\n            cost = r->cost;\n            break;\n        }\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {\n                if (r->unvisited == 0) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(a,b) (a<b?a:b)\n#define INF 10000000\nint g[16][16],n,i,j,k,v,e,f,t,c;\nint dp[1<<17][16];\nint main()\n{\n\tscanf(\"%d%d\",&v,&e);\n\tfor(i=0;i<(1<<16);i++)\n\t\tfor(j=0;j<v;j++)\n\t\t\ti<v?(g[i][j]=dp[i][j]=INF):(dp[i][j]=INF);\n\tdp[0][0]=0;\n\tfor(i=0;i<e;g[f][t]=c,i++)\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\tfor(i=0;i<(1<<v);i++)\n\t\tfor(j=0;j<v;j++)\n\t\t\tfor(k=0;k<v;k++)\n\t\t\t\tif(!(i>>k&1))\n\t\t\t\t\tdp[i|(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+g[j][k]);\n\tprintf(\"%d\\n\",dp[(1<<v)-1][0]==INF?-1:dp[(1<<v)-1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\n#define MAX_V 15\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nstatic const int INF = 1000000000;\n\nint d[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\nint V;\n\nint\nsolve()\n{\n\tint S, u, v;\n\n\tfor (S = 0; S < (1 << V); ++S)\n\t{\n\t\tfor (v = 0; v < V; ++v)\n\t\t\tdp[S][v] = INF;\n\t}\n\n\tdp[(1 << V) - 1][0] = 0;\n\tfor (S = (1 << V) - 2; S >= 0; --S)\n\t{\n\t\tfor (v = 0; v < V; ++v)\n\t\t{\n\t\t\tfor (u = 0; u < V; ++u)\n\t\t\t{\n\t\t\t\tif (!(S >> u & 1))\n\t\t\t\t{\n\t\t\t\t\tint t = dp[S | (1 << u)][u] + d[v][u];\n\t\t\t\t\tdp[S][v] = min(dp[S][v], t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[0][0];\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t, c;\n\tint i, j;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tfor (j = 0; j < V; ++j)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\td[i][j] = 0;\n\t\t\telse\n\t\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\td[s][t] = c;\n\t}\n\n\n\tint res = solve();\n\tif (res == INF)\n\t\tres = -1;\n\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint StrenghtBit(int mask, int v){\n\treturn mask + (1 << v);\n}\n\nint Min(int a, int b){\n\treturn a < b ? a : b;\n}\n\nint Task(int* pointRib, int n){\n\tint* dP = NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask)* n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\t/*if (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 0 != pointRib[vertex*n * 2 + i * 2] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}*/\n\t\t\t\tif (1 != GetBit(mask, i)){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = Min(pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex], dP[StrenghtBit(mask, i)*n + i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n * 2]){\n\t\t\tif (0 == min || (min > (dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n*2, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n * 2 + y * 2] = 1;\n\t\trib[x*n * 2 + y * 2 + 1] = weight;\n\t}\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define INF 100000\nint V,E;\nint G[15][15];\nint dp[1<<15][15];\nint min(int a,int b){\n  if(a<b)return a;\n  else return b;\n}\nvoid print(){\n  int i,j;\n  for(i=0;i<V;i++){\n    for(j=0;j<V;j++){\n      printf(\"%d \",dp[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\nint rec(int S,int v){\n  if(dp[S][v]>=0)\n    return dp[S][v];\n\n  if(S==(1<<V)-1 && v==0)\n    return dp[S][v]=0;\n  int u,res=INF;\n  for(u=0;u<V;u++){\n    if(!(S>>u & 1)){\n      res=min(res,rec(S|1<<u,u)+G[v][u]);\n    }\n  }\n  return dp[S][v]=res;\n}\nvoid init(){\n  int i,j;\n   for(i=0;i<1<<V;i++){\n    for(j=0;j<V;j++){\n      G[i][j]=INF;\n    }\n   }\n}\nint main(){\n  int i,j;\n  int s,t,d;\n  int min=100000;\n  int ans;\n  scanf(\"%d %d\",&V,&E);\n  memset(dp,-1,sizeof(dp));\n  init();\n  for(i=0;i<E;i++){\n   scanf(\"%d %d %d\",&s,&t,&d);\n   G[s][t]=d;\n  }\n \n  for(i=0;i<V;i++){\n    ans=rec(0,i);\n    if(min>ans)min=ans;\n    init();\n  }\n  if(min==INF)min=-1;\n  printf(\"%d\\n\",min); \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 100000\n\nvoid print_table(unsigned short *tbl, int row, int col) {\n    int i, j;\n    for (i = 0; i < row; i++) {\n        for (j = 0; j < col; j++) {\n            printf(\"%u \", tbl[i*col + j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    unsigned short *memo, *m;\n    int dist[15][15];\n    int i, j, s, t, d, V, E, state, before_state, before_dist, min_dist;\n\n    scanf(\"%d %d\", &V, &E);\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            dist[i][j] = 0;\n        }\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        dist[s][t] = d;\n    }\n\n    memo = (unsigned short *)calloc((1<<(V-1)) * (V-1), sizeof(unsigned short));\n\n    state = (1 << (V-1)) - 1;\n    for (i = 1; i < V; i++) {\n        memo[state * (V-1) + i-1] = dist[0][i];\n    }\n\n    while (--state >= 0) {\n        for (i = 0; i < V-1; i++) {  // before vertex ..\n            if (!(state & (1 << i))) {\n                before_state = state | (1 << i);\n                before_dist = memo[before_state * (V-1) + i];\n                if (before_dist == 0) continue;\n                for (j = 0; j < V-1; j++) {\n                    if ((state & (1 << j)) && dist[i+1][j+1] > 0) {\n                        d = before_dist + dist[i+1][j+1];\n                        m = &memo[state * (V-1) + j];\n                        if (*m == 0 || d < *m) {\n                            *m = d;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    min_dist = INF;\n    for (i = 0; i < V-1; i++) {\n        m = &memo[(1<<i)*(V-1)+i];\n        if (!dist[i+1][0] || !(*m)) continue;\n        d = *m + dist[i+1][0];\n        if (d < min_dist) {\n            min_dist = d;\n        }\n    }\n\n    printf(\"%d\\n\", min_dist<INF ? min_dist: -1);\n\n    free(memo);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 100000\n\nvoid print_table(unsigned short *tbl, int row, int col) {\n    int i, j;\n    for (i = 0; i < row; i++) {\n        for (j = 0; j < col; j++) {\n            printf(\"%u \", tbl[i*col + j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    unsigned short *memo;\n    int dist[15][15];\n    int i, j, s, t, d, V, E, state, before_state, before_dist, min_dist;\n    unsigned short *score;\n\n    scanf(\"%d %d\", &V, &E);\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            dist[i][j] = 0;\n        }\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        dist[s][t] = d;\n    }\n\n    memo = (unsigned short *)calloc((1<<(V-1)) * (V-1), sizeof(unsigned short));\n\n    state = (1 << (V-1)) - 1;\n    for (i = 1; i < V; i++) {\n        memo[state * (V-1) + i-1] = dist[0][i];\n    }\n\n    while (--state >= 0) {\n        for (i = 0; i < V-1; i++) {\n            if (!(state & (1 << i))) {\n                before_state = state | (1 << i);\n                before_dist = memo[before_state * (V-1) + i];\n                if (before_dist == 0) continue;\n                for (j = 0; j < V-1; j++) {\n                    if (dist[i+1][j+1] > 0) {\n                        d = before_dist + dist[i+1][j+1];\n                        score = &memo[state * (V-1) + j];\n                        if (*score == 0) {\n                            *score = d;\n                        }\n                        else if (d < *score) {\n                            *score = d;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    min_dist = INF;\n    for (i = 0; i < V-1; i++) {\n        if (!dist[i+1][0] || !memo[i]) continue;\n        d = memo[i] + dist[i+1][0];\n        if (d < min_dist) {\n            min_dist = d;\n        }\n    }\n\n    printf(\"%d\\n\", min_dist<INF ? min_dist: -1);\n\n    free(memo);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(a,b) (a<b?a:b)\n#define INF 10000000\nint g[16][16],n,i,j,k,v,e,f,t,c;\nint dp[1<<17][16];\nint main()\n{\n\tscanf(\"%d%d\",&v,&e);\n\tfor(i=0;i<v;i++)\n\t\tfor(j=0;j<v;j++)\n\t\t\tg[i][j]=INF;\n\tfor(i=1;i<(1<<16);i++)\n\t\tfor(j=0;j<v;j++)\n\t\t\tdp[i][j]=INF;\n\tfor(i=0;i<e;g[f][t]=c,i++)\n\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\tfor(i=0;i<(1<<v);i++)\n\t\tfor(j=0;j<v;j++)\n\t\t\tfor(k=0;k<v;k++)\n\t\t\t\tif(g[j][k]<INF&&!(i&(1<<k)))\n\t\t\t\t\tdp[i+(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+g[j][k]);\n\tprintf(\"%d\\n\",dp[(1<<v)-1][0]==INF?-1:dp[(1<<v)-1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 10000\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {  // last ?\n                if (r->unvisited == 0) {\n                    cost = r->cost + dist;\n                    goto route_found;\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    route_found:;\n\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 10000\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        if (r->vertex_id == 0 && r->unvisited == 0) {\n            cost = r->cost;\n            break;\n        }\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {\n                if (r->unvisited == 0) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP = NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask)* n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) /*&& 1 == GetBit(mask, vertex)*/ && 0 != pointRib[vertex*n * 2 + i * 2] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n * 2]){\n\t\t\tif (0 == min || (min > (dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n*2, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n * 2 + y * 2] = 1;\n\t\trib[x*n * 2 + y * 2 + 1] = weight;\n\t}\n\t/*int j;\n\tint k;\n\tfor (i = 0; i < n; i++){\n\t\tfor (j = 0; j < n; j++){\n\t\t\tif (-1 == rib[i*n + j]){\n\t\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\t\tif (0 != rib[i*n + k]){\n\t\t\t\t\t\trib[j*n + k] = rib[i*n + k];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 != rib[j*n + k]){\n\t\t\t\t\t\trib[i*n + k] = rib[j*n + k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 2000\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {  // last ?\n                if (r->unvisited == 0) {\n                    cost = r->cost + dist;\n                    goto route_found;\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    route_found:;\n\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP=NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask) * n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 0 != pointRib[vertex*n + i] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n + i] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n]){\n\t\t\tif (0 == min || (min>(dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n + y] = weight;\n\t}\n\tprintf(\"%d\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP = NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask)* n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\t/*if (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 0 != pointRib[vertex*n * 2 + i * 2] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}*/\n\t\t\t\tif (1 != GetBit(mask, i)){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n * 2]){\n\t\t\tif (0 == min || (min > (dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n*2, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n * 2 + y * 2] = 1;\n\t\trib[x*n * 2 + y * 2 + 1] = weight;\n\t}\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)((n>>m)&1)\n\nint d[20][20];\nint dp[1<<15][15];\nint main(){\n\tint v,e;\n\tscanf(\"%d%d\",&v,&e);\n\tfor(int i=0;i<v;i++)for(int j=0;j<v;j++)d[i][j]=1e6;\n\tfor(int i=0;i<e;i++){\n\t\tint s,t,c;\n\t\tscanf(\"%d%d%d\",&s,&t,&c);\n\t\td[s][t]=c;\n\t}\n\tfor(int i=1;i<1<<v;i++)for(int k=0;k<v;k++)dp[i][k]=1e6;\n\tdp[1][0]=0;\n\tfor(int i=1;i<1<<v;i++){\n\t\tfor(int k=0;k<v;k++)if(bit(i,k)){\n\t\t\tfor(int j=0;j<v;j++)if(!bit(i,j)){\n\t\t\t\tdp[i|1<<j][j]=min(dp[i|1<<j][j],dp[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1e6;\n\tfor(int i=0;i<v;i++)ans=min(ans,dp[(1<<v)-1][i]+d[i][0]);\n\tprintf(\"%d\\n\",ans==1e6?-1:ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n#define Size 15\nlong int dist[Size][Size], dp[1 << Size][Size];\nint rec(int S, int v, int size);\nint main(void)\n{\n  int i, j, n, e, s, t, d;\n  scanf(\"%d%d\\n\", &n, &e);\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      dist[i][j] = INT_MAX;\n    }\n  }\n  memset(dp, -1, sizeof(dp));\n  for (i = 0; i < e; i++) {\n    scanf(\"%d%d%d\", &s, &t, &d);\n    dist[s][t] = d;\n  }\n  d = rec(0, 0, n);\n  if (d == INT_MAX) printf(\"-1\\n\");\n  else printf(\"%d\\n\", d);\n}\nint rec(int S, int v, int size)\n{\n  long int u, res = INT_MAX;\n  if (dp[S][v] >= 0) return dp[S][v];\n  if (S == (1 << size) - 1 && v == 0) return dp[S][v] = 0;\n  for (u = 0; u < size; u++) {\n    if (!(S >> u & 1)) {\n      long int tmp = rec(S | 1 << u, u, size) + dist[v][u];\n      if (res > tmp) res = tmp;\n    }\n  }\n  return dp[S][v] = res;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_A Traveling Salesman Problem\n// 2018.5.5 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 0x03030303\n\n#define MAX_V  16\nint dp[1<<MAX_V][MAX_V];\nint d[MAX_V][MAX_V];\n\nint traveling_salesman(int V)\n{\n\tint s, u, v, x;\n\n\tmemset(dp, INF, sizeof(dp));\n\tdp[(1<<V)-1][0] = 0;\n\tfor (s = (1<<V)-2; s >= 0; s--) {\n\t\tfor (v = 0; v < V; v++) {\n\t\t\tfor (u = 0; u < V; u++) if (d[v][u] < INF) {\n\t\t\t\tif ((s>>u) & 1) continue;\n\t\t\t\tx = dp[s | (1<<u)][u] + d[v][u];\n\t\t\t\tif (x < dp[s][v]) dp[s][v] = x;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][0];\n}\n\nint main()\n{\n\tint V, E, ans;\n\n\tmemset(d, INF, sizeof(d));\n\tV = in(), E = in();\n\tif (!E) { puts(\"-1\"); return 0; }\n\n\twhile (E--) {\n\t\tint s = in(), t = in();\n\t\td[s][t] = in();\n\t}\n\tans = traveling_salesman(V);\n\tif (ans >= INF) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TRUE 1;\n#define FALSE 0;\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\nint GetBit(int mask, int v){\n\treturn (mask >> v) & 1;\n}\n\nint AddBit(int mask, int v){\n\treturn mask | (1 << v);\n}\n\nint Task(int* pointRib, int n){\n\tint* dP = NULL;\n\tint maxMask = pow((double)2, (double)n);\n\tdP = (int*)calloc((maxMask)* n, sizeof(int));\n\tint mask = 0;\n\tint vertex = 0;\n\tshort IO = TRUE;\n\tint i;\n\tfor (mask = 1; mask < maxMask; mask++){\n\t\tfor (vertex = 0; vertex < n; vertex++){\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (1 != GetBit(mask, i) && 1 == GetBit(mask, vertex) && 0 != pointRib[vertex*n * 2 + i * 2] && (1 == mask || (1 < mask && 0 != dP[mask*n + vertex]))){\n\t\t\t\t\tdP[AddBit(mask, i)*n + i] = pointRib[vertex*n * 2 + i * 2 + 1] + dP[mask*n + vertex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint min = 0;\n\tfor (vertex = 0; vertex < n; vertex++){\n\t\tif (0 != dP[(maxMask - 1)*n + vertex] && 0 != pointRib[vertex*n * 2]){\n\t\t\tif (0 == min || (min > (dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1]))){\n\t\t\t\tmin = dP[(maxMask - 1)*n + vertex] + pointRib[vertex*n*2 + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn (0 != min) ? min : -1;\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tint i;\n\tint* rib = NULL;\n\trib = calloc(n * n*2, sizeof(int));\n\tint x, y, weight;\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d\", &x, &y, &weight);\n\t\trib[x*n * 2 + y * 2] = 1;\n\t\trib[x*n * 2 + y * 2 + 1] = weight;\n\t}\n\t/*int j;\n\tint k;\n\tfor (i = 0; i < n; i++){\n\t\tfor (j = 0; j < n; j++){\n\t\t\tif (-1 == rib[i*n + j]){\n\t\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\t\tif (0 != rib[i*n + k]){\n\t\t\t\t\t\trib[j*n + k] = rib[i*n + k];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 != rib[j*n + k]){\n\t\t\t\t\t\trib[i*n + k] = rib[j*n + k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\tprintf(\"%d\\n\", Task(rib, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _route route_t;\n\nstruct _route {\n    int vertex_id;\n    int unvisited;\n    unsigned int cost;\n};\n\nroute_t *_r;\nint visited_mask;\nint route_index;\n\nvoid route_init(int vertex_count, int route_count) {\n    int i;\n    visited_mask = 0;\n    for (i = 0; i < vertex_count; i++) {\n        visited_mask |= 1 << i;\n    }\n\n    route_index = 0;\n    _r = (route_t*)malloc(sizeof(route_t) * route_count);\n}\n\nvoid route_delete() {\n    free(_r);\n}\n\nvoid route_visit(route_t *r, int id) {\n    r->unvisited &= ~(1 << id);\n}\n\nint route_unvisited(route_t *r, int id) {\n    return r->unvisited & (1 << id);\n}\n\nroute_t* route_next() {\n    route_t *r;\n    r = &_r[route_index++];\n    return r;\n}\n\ntypedef struct _binheap binheap_t;\n\nstruct _binheap {\n    route_t **e;\n    int count;\n};\n\n\nbinheap_t *bh_new(int size) {\n    binheap_t *bh;\n    bh = (binheap_t*)malloc(sizeof(binheap_t));\n    bh->e = (route_t**)malloc(sizeof(route_t*) * size);\n    bh->count = 0;\n    return bh;\n}\n\nvoid bh_delete(binheap_t *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_percup(binheap_t *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (vc->cost < vp->cost) { // parent is larger\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_push(binheap_t *bh, route_t *v) {\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nint bh_minchild(binheap_t *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (vl->cost < vr->cost)\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percdown(binheap_t *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_minchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (vp->cost > vc->cost) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nroute_t *bh_pop(binheap_t *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\nvoid print_bh(binheap_t *bh) {\n    int i;\n    route_t *v;\n    printf(\"bh[%d]:\", bh->count);\n    for (i=1; i <= bh->count; i++) {\n        v = bh->e[i];\n        printf(\" %d\", v->cost);\n    }\n    printf(\"\\n\");\n}\n\ntypedef struct _edge edge_t;\n\nstruct _edge {\n    int dest;\n    int distance;\n    edge_t *next;\n};\n\ntypedef struct _vertex vertex_t;\nstruct _vertex {\n    int id;\n    edge_t *edge;\n};\n\n#define ROUTE_COUNT 1000000\n\nint main() {\n    vertex_t *vertex, *v;\n    edge_t *edge, *e;\n    binheap_t *bh;\n    route_t *route, *r, *nr;\n    int V, E, i, j, s, t, d, cost, next_v, dist;\n\n    scanf(\"%d %d\", &V, &E);\n    vertex = (vertex_t*)malloc(sizeof(vertex_t) * V);\n    edge = (edge_t*)malloc(sizeof(edge_t) * E);\n    for (i = 0; i < V; i++) {\n        v = &vertex[i];\n        v->id = i;\n        v->edge = NULL;\n    }\n    for (i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &s, &t, &d);\n        e = &edge[i];\n        e->dest = t;\n        e->distance = d;\n        e->next = vertex[s].edge;\n        vertex[s].edge = e;\n    }\n\n    route_init(V, ROUTE_COUNT);\n\n    bh = bh_new(ROUTE_COUNT);\n    r = route_next();\n    r->unvisited = visited_mask;\n    route_visit(r, 0);\n    r->vertex_id = 0;\n    r->cost = 0;\n    bh_push(bh, r);\n\n    cost = -1;\n    while (bh->count) {\n        r = bh_pop(bh);\n        if (r->vertex_id == 0 && r->unvisited == 0) {\n            cost = r->cost;\n            break;\n        }\n        v = &vertex[r->vertex_id];\n        e = v->edge;\n        while (e != NULL) {\n            next_v = e->dest;\n            dist = e->distance;\n            if (next_v == 0) {\n                if (r->unvisited == 0) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            else {\n                if (route_unvisited(r, next_v)) {\n                    nr = route_next();\n                    nr->vertex_id = next_v;\n                    nr->unvisited = r->unvisited;\n                    route_visit(nr, next_v);\n                    nr->cost = r->cost + dist;\n                    bh_push(bh, nr);\n                }\n            }\n            e = e->next;\n        }\n    }\n    printf(\"%d\\n\", cost);\n\n    bh_delete(bh);\n    route_delete();\n\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(0, 1);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int v, int mask) {\n\t\tif (memo[v][mask] != -1)  return memo[v][mask];\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((mask & (1 << i)) != 0) continue;\n\t\t\tres = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));\n\t\t}\n\t\treturn memo[v][mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n// aoj DPL_2_A Traveling Salesman Problem\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint v = sc.nextInt();\n\t\tint e = sc.nextInt();\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Edge>[] edges = new List[v];\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tedges[i] = new ArrayList<Edge>();\n\t\t}\n\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tedges[s].add(new Edge(s, t, d));\n\t\t}\n\n\t\tfinal int INF = Integer.MAX_VALUE;\n\t\tint min = INF;\n\t\tfor (int s = 0; s < v; s++) {\n\t\t\tint[][] dp = new int[v][1 << v];\n\t\t\tfor (int[] tmp : dp) {\n\t\t\t\tArrays.fill(tmp, INF);\n\t\t\t}\n\t\t\tdp[s][1 << s] = 0;\n\t\t\t\n\t\t\tfor (int S = 1; S < 1 << v; S++) {\n\t\t\t\tfor (int j = 0; j < v; j++) {\n\t\t\t\t\tif ((S & (1 << j)) == 0 || dp[j][S] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (Edge i : edges[j]) {\n\t\t\t\t\t\tif ((S & (1 << i.v)) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i.v][S | (1 << i.v)] = Math.min(dp[i.v][S | (1 << i.v)], dp[j][S] + i.w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tfor (Edge j : edges[i]) {\n\t\t\t\t\tif (j.v != s || j.w == INF || dp[i][(1 << v) - 1] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tmin = Math.min(min, dp[i][(1 << v) - 1] + j.w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (min != INF) {\n\t\t\tSystem.out.println(min);\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\n\t\tsc.close();\n\t}\n\n\tprivate static class Edge {\n//\t\tint u; // from\n\t\tint v; // to\n\t\tint w; // cost\n\t\t\n\t\tEdge(int u, int v, int w) {\n//\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int E = sc.nextInt();\n        int INF = 1_500_000_000;\n        int[][] e = new int[N][N];\n        for (int i=0;i<N;i++) {\n            for (int j=0;j<N;j++) {\n                e[i][j] = INF;\n            }\n        }\n        for (int i=0;i<E;i++) {\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            int d = sc.nextInt();\n            e[s][t] = d;\n        }\n\n        long[][] dp = new long[(1<<N)][N];\n        long ans = INF;\n        for (int s=0;s<N;s++) {\n            for (int i=0;i<(1<<N);i++) {\n                for (int j=0;j<N;j++) {\n                    dp[i][j] = INF;\n                }\n            }\n            dp[(1<<s)][s] = 0;\n            for (int i=0;i<(1<<N);i++) {\n                for (int j=0;j<N;j++) {\n                    for (int k=0;k<N;k++) {\n                        if (e[j][k]==INF) continue;\n                        if (((i>>k)&1)==1) continue;\n                        dp[i+(1<<k)][k] = Math.min(dp[i+(1<<k)][k], dp[i][j]+e[j][k]);\n                        if (i+(1<<k)==(1<<N)-1) ans = Math.min(ans, dp[i][j]+e[j][k]+e[k][s]);\n                    }\n                }\n            }\n        }\n        System.out.println(ans==INF?-1:ans);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\n\t\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint vn=sc.nextInt();\n\t\tint en=sc.nextInt();\n\t\t\n\t\tint[][] ds = new int[vn][vn];\n\t\tfill2(ds,INF);\n\t\tint s1=0, g1=0,d1=0;\n\t   \tfor(int i=0; i<en; i++){\n\t   \t    s1=sc.nextInt();\n\t   \t    g1=sc.nextInt();\n\t   \t    d1=sc.nextInt();\n\t   \t    ds[s1][g1] = d1;\n\t   \t}\n\t\t\n\t\tint[][][] dp = new int[1<<vn][vn][vn];    //flag(i)の中でj始まりk終りのルートのmin(cost)\n\t\tfill3(dp, INF);\n\t\t\n\t   \tfor(int i=0; i<vn; i++){\n\t   \t    dp[1<<i][i][i]=0;\n\t   \t}\n\t\t\n\t\tfor(int bit=0; bit < (1<<vn); bit++){\n\t\t\tfor(int i=0; i<vn; i++){\n\t\t\t    if(isFlaged(bit,i)){\n\t\t\t        for(int j=0; j<vn; j++){\n\t\t\t            if(isFlaged(bit,j)){\n\t\t\t                int without = deflag(bit, j);\n\t\t\t\t            for(int k=0; k<vn; k++){\n\t\t\t\t                if(isFlaged(without,k)){\n        \t\t\t                dp[bit][i][j] = min(dp[bit][i][j], dp[without][i][k]+ds[k][j]);\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint min_route=INF, tmp=0;;\n\t   \tfor(int i=0; i<vn; i++){\n\t\t\tfor(int j=0; j<vn; j++){\n\t\t\t    tmp=(dp[(1<<vn)-1][i][j]+ds[j][i]);\n\t\t\t    if(tmp < min_route) min_route=tmp;\n\t\t\t}\n\t   \t}\n        if(isINF(min_route)) out.println(-1);\n        else out.println(min_route);\n\t\t\n\t\tout.flush();\n\t}\n\n\n\tprivate static int INF = (int)1e7;\n\tprivate static long INFL = (long)1e17;\n\tprivate static int e97 = (int)1e9 + 7;\n\t\n\t\n\tprivate static int abs(int a){\n\t    return (a>=0) ? a: -a;\n\t}\n\tprivate static long absL(long a){\n\t    return (a>=0) ? a: -a;\n\t}\n\t\n\tprivate static int min(int a, int b){\n\t    return (a>b) ? b : a;\n\t}\n\tprivate static long minL(long a, long b){\n\t    return (a>b) ? b : a;\n\t}\n\t\n\tprivate static int max(int a, int b){\n\t\treturn (a>b) ? a : b;\n\t}\n\tprivate static long maxL(long a, long b){\n\t\treturn (a>b) ? a : b;\n\t}\n\t\n\tprivate static int minN(int... ins){\n\t\tint min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){\n\t\t\tif(ins[i] < min) min = ins[i];\n\t\t}\n\t\treturn min;\n\t}\n\tprivate static int maxN(int... ins){\n\t\tint max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){\n\t\t\tif(ins[i] > max) max = ins[i];\n\t\t}\n\t\treturn max;\n\t}\n\tprivate static long minNL(long... ins){\n\t\tlong min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){\n\t\t\tif(ins[i] < min) min = ins[i];\n\t\t}\n\t\treturn min;\n\t}\n\tprivate static long maxNL(long... ins){\n\t\tlong max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){\n\t\t\tif(ins[i] > max) max = ins[i];\n\t\t}\n\t\treturn max;\n\t}\n\t\n\tprivate static int minExAd(int[] dt, int ad){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tif((i != ad) && (dt[i] < min)) min = dt[i];\n\t\t}\n\t\treturn min;\n\t}\n\tprivate static int minExVal(int[] dt, int ex_val){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tif((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n\t\t}\n\t\treturn min;\n\t}\n\tprivate static long minExAdL(long[] dt, int ad){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tif((i != ad) && (dt[i] < min)) min = dt[i];\n\t\t}\n\t\treturn min;\n\t}\n\tprivate static long minExValL(long[] dt, long ex_val){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tif((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n\t\t}\n\t\treturn min;\n\t}\n\t\n\tprivate static boolean same3(long a, long b, long c){\n\t    if(a!=b) return false;\n\t    if(b!=c) return false;\n\t    if(c!=a) return false;\n\t    return true;\n\t}\n\tprivate static boolean dif3(long a, long b, long c){\n\t    if(a==b) return false;\n\t    if(b==c) return false;\n\t    if(c==a) return false;\n\t    return true;\n\t}\n\t\n\tprivate static int factorial(int n) {\n\t\tint ans=1;\n\t\tfor(int i=n; i>0; i--){\n\t\t\tans*=i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tprivate static long gcd(long m, long n) {\n\t\tif(m < n) return gcd(n, m);\n\t\tif(n == 0) return m;\n\t\treturn gcd(n, m % n);\n\t}\n\t\n\tprivate static int pow2(int in){\n\t\treturn in*in;\n\t}\n\tprivate static long pow2L(long in){\n\t\treturn in*in;\n\t}\n\t\n\tprivate static int getDigit2L(long num){\n\t\tlong cf = 1;\n\t\tint d=0;\n\t\twhile(num >= cf){\n\t\t\td++;\n\t\t\tcf = 1<<d;\n\t\t}\n\t\treturn d;   //numはd桁の数で、2^dより小さい\n\t}\n\t\n\tprivate static int getDigit10L(long num){\n\t\tlong cf = 1;\n\t\tint d=0;\n\t\twhile(num >= cf){\n\t\t\td++;\n\t\t\tcf*=10;\n\t\t}\n\t\treturn d; //numはd桁の数で、10^dより小さい\n\t}\n\t\n\tprivate static boolean isINF(int in){\n\t    if((in*20)>INF) return true;\n\t    else return false;\n\t}\n\t\n\tprivate static long pow10E97(long ob, int soeji){\n\t\tif(soeji==2) return (ob*ob)%e97;\n\t\t\n\t\tint d = getDigit2L(soeji);\n\t\tlong[] ob_pow_2pow = new long[d];\n\t\t\n\t\tob_pow_2pow[0] = ob;\n\t   \tfor(int i=1; i<d; i++){\n\t   \t\tob_pow_2pow[i] = (ob_pow_2pow[i-1]*ob_pow_2pow[i-1])%e97;\n\t   \t}\n\t   \t\n\t   \tlong ans=1;\n\t\tfor(int i=d-1; i>=0; i--){\n\t\t\tif(soeji >= (1<<i)){\n\t\t\t\tsoeji -= (1<<i);\n\t\t\t\tans = (ans*ob_pow_2pow[i])%e97;\n\t\t\t}\n   \t\t}\n\t   \t\n\t\treturn ans;\n\t}\n\t\n\tprivate static boolean isFlaged(int bit, int pos){\n\t    if((bit&(1<<pos)) > 0) return true;\n\t    else return false;\n\t}\n\tprivate static int deflag(int bit, int pos){\n\t    return bit&~(1<<pos);\n\t}\n\t\n\tprivate static void fill(int[] ob, int res){\n\t   \tfor(int i=0; i<ob.length; i++){\n\t   \t\tob[i] = res;\n\t   \t}\n\t   \treturn;\n\t}\n\tprivate static void fillL(long[] ob, long res){\n\t   \tfor(int i=0; i<ob.length; i++){\n\t   \t\tob[i] = res;\n\t   \t}\n\t   \treturn;\n\t}\n\tprivate static void fill2(int[][] ob, int res){\n\t   \tfor(int i=0; i<ob.length; i++){\n\t\t\tfor(int j=0; j<ob[0].length; j++){\n\t   \t\t\tob[i][j] = res;\n\t\t\t}\n\t   \t}\n\t   \treturn;\n\t}\n\tprivate static void fill2L(long[][] ob, long res){\n\t   \tfor(int i=0; i<ob.length; i++){\n\t\t\tfor(int j=0; j<ob[0].length; j++){\n\t   \t\t\tob[i][j] = res;\n\t\t\t}\n\t   \t}\n\t   \treturn;\n\t}\n\tprivate static void fill3(int[][][] ob, int res){\n\t   \tfor(int i=0; i<ob.length; i++){\n\t\t\tfor(int j=0; j<ob[0].length; j++){\n\t\t\t\tfor(int k=0; k<ob[0][0].length; k++){\n    \t\t\t    ob[i][j][k] = res;\n\t\t\t\t}\n\t\t\t}\n\t   \t}\n\t   \treturn;\n\t}\n\t\n\tstatic void show_b2d_array(boolean[][] dt, int lit_x, int lit_y){\n\t\tfor(int i=0; i<dt[0].length; i++){\n\t\t\tfor(int j=0; j<dt.length; j++){\n\t\t\t\tif((i==lit_y) && (j==lit_x)) System.out.print(\"X\");\n\t\t\t\telse if(dt[j][i]) System.out.print(\"O\");\n\t\t\t\telse System.out.print(\".\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void show_L2(long[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt[0].length; i++){\n\t\t\tfor(int j=0; j<dt.length; j++){\n\t\t\t\tout.print(dt[j][i]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void disp_que(ArrayDeque<Integer> dt){\t\t//上手くいかなかった時用\n\t\tint a=0;\n\t\twhile(dt.size()>0){\n\t\t\ta=dt.removeLast();\n\t\t\tSystem.out.print(a);\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\t\n\t\n\tprivate static void nextPerm(ArrayList<Integer> former){\n\t\tint pivot=-1;\n\t\tint ln = former.size();\n\t\tfor(int i = ln; i>1; i--){\n\t\t\tif(former.get(i-2) < former.get(i-1)){\n\t\t\t\tpivot = i-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pivot==-1){\n\t\t    former = null;\n\t\t    return;\n\t\t}\n\t\tint pivot_fig = former.get(pivot);\n\t\t\n\t\tint min_pos=pivot+1;\n\t\tint min=former.get(min_pos);\n\t\tfor(int i=ln-1; i > pivot+1; i--){\n\t\t\tif((former.get(i) < min)&&(former.get(i) > pivot_fig)){\n\t\t\t\tmin_pos=i;\n\t\t\t\tmin=former.get(min_pos);\n\t\t\t}\n\t\t}\n\t\tCollections.swap(former, pivot, min_pos);\n\t\tCollections.sort(former.subList(pivot+1, ln));\n\t\treturn;\n\t}\n\t\n\tpublic static int binarySearch(int[] dt, int target){\n\t\tint left=0, right=dt.length-1;\n\t\tint mid=-1;\n\t\twhile(left<=right){\n\t\t\tmid = (right+left)/2;\n\t\t\tif(dt[mid] == target) return mid;\n\t\t\tif(dt[mid] < target) left=mid+1;\n\t\t\telse right=mid-1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int binarySearchMax(int[] dt, int target){\n\t\tint left=-1, right=dt.length;\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt[mid] <= target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;  //target以下の最大のaddress\n\t}\n\t\n\t\n\tstatic int dfs2(boolean[][] state, int x, int y, int depth){\t\t//薄氷渡り\n\t\tint[] tmpltX = {1,-1,0,0};\n\t\tint[] tmpltY = {0,0,1,-1};\n\t\tint newX = -1, newY = -1;\n\t\t\n\t\tstate[x][y] = false;\n\t\tdepth++;\n\t\t\n\t\tint maxDunder_this_brunch = depth, tmpD=0;\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tnewX = x+tmpltX[i];\n\t\t\tnewY = y+tmpltY[i];\n\t\t\tif((newX >= 0) && (newY >= 0) && (newX < state.length) && (newY < state[0].length) && state[newX][newY]) tmpD = dfs2(state, newX, newY, depth);\n\t\t\tif(tmpD > maxDunder_this_brunch) maxDunder_this_brunch=tmpD;\n\t\t}\n\t\tstate[x][y] = true;\n\t\treturn maxDunder_this_brunch;\n\t}\n}\n \nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(0, 1);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int v, int mask) {\n\t\tif (memo[v][mask] != -1)  return memo[v][mask];\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((mask & (1 << i)) != 0) continue;\n\t\t\tres = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));\n\t\t}\n\t\treturn memo[v][mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int[] a;\n  static int infi = 2000000;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int v, e, i, j, k;\n    int[][] d, dp;\n\n    v = sc.nextInt(); e = sc.nextInt();\n    d = new int[v][v]; a = new int[v + 1];\n    for(i = 0;i < v;i++)for(j = 0;j < v;j++)d[i][j] = infi;\n    for(;e-- > 0;)d[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n    a[0] = 1;\n    for(i = 0;i < v;i++)a[i + 1] = a[i] * 2;\n    dp = new int[a[v]][v];\n    for(i = 0;i < a[v];i++)for(j = 0;j < v;j++)dp[i][j] = infi;\n    dp[a[v] - 1][0] = 0;\n\n    for(i = a[v] - 1;i >= 0;i--)\n      for(j = 0;j < v;j++)if(dp[i][j] != infi)\n        for(k = 0;k < v;k++)if(j != k && isin(i, k) && d[k][j] < infi){\n          if(dp[i][j] + d[k][j] < dp[i - a[j]][k])\n            dp[i - a[j]][k] = dp[i][j] + d[k][j];\n        }\n    if(dp[0][0] != infi)out.println(dp[0][0]);\n    else out.println(\"-1\");\n\n    sc.close();\n  }\n  private static boolean isin(int s, int v){\n    return (v == 0 || ((s % a[v + 1]) / a[v]) == 1);\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.*;\npublic class Main {\n\tstatic final long MOD=1000000007;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\tlong[][] edge=new long[V][V];\n\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\tfor (int j = 0; j < edge.length; j++) {\n\t\t\t\tedge[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\tlong w=sc.nextLong();\n\t\t\tedge[a][b]=w;\n\t\t}\n\t\tlong[][] dp=new long[V][1<<V];\n\t\tfor (int j = 0; j < dp.length; j++) {\n\t\t\tArrays.fill(dp[j], Long.MAX_VALUE/2);\n\t\t}\n\t\tdp[0][0]=0;\n\t\tfor (int j2 = 0; j2 < 1<<V; j2++) {\n\t\t\tfor (int j = 0; j < dp.length; j++) {\n\t\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\t\tif (edge[j][i]==-1||((j2>>i)&1)==1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j2|(1<<i)]=Math.min(dp[i][j2|(1<<i)], dp[j][j2]+edge[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[0][(1<<V)-1]==Long.MAX_VALUE/2) {\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\tSystem.out.println(dp[0][(1<<V)-1]);\n\t\t}\n\t}\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.util.HashMap;\n\npublic class Main {\n\tpublic static ArrayList<HashMap<Integer, Integer>> path = new ArrayList<HashMap<Integer, Integer>>();\n\tpublic static void bitDP(int v) {\n\t\tint[][] dist = new int[(int)Math.pow(2, v)][v];\n\t\tfor(int i=0; i<dist.length; i++) {\n\t\t\tArrays.fill(dist[i], Integer.MAX_VALUE);\n\t\t}\n\t\tdist[1][0] = 0;\n\t\t// O(2^v * v^2)\n\t\tfor(int i=1; i<(int)Math.pow(2, v); i++) {\n\t\t\tfor(int j=0; j<v; j++) {\n\t\t\t\tif((i & (1<<j)) != 0) {\n\t\t\t\t\tfor(int k=0; k<v; k++) {\n\t\t\t\t\t\tif((i & (1<<k)) != 0 && j != k && path.get(k).containsKey(j) && dist[i-(1<<j)][k] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i-(1<<j)][k] + path.get(k).get(j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minDist = Integer.MAX_VALUE;\n\t\tfor(int i=1; i<v; i++) {\n\t\t\tif(path.get(i).containsKey(0) && dist[dist.length-1][i] != Integer.MAX_VALUE) {\n\t\t\t\tminDist = Math.min(minDist, dist[dist.length-1][i] + path.get(i).get(0));\n\t\t\t}\n\t\t}\n\t\tif(minDist == Integer.MAX_VALUE) minDist = -1;\n\t\tSystem.out.println(minDist);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint v = r.nextInt();\n\t\tint e = r.nextInt();\n\t\tfor(int i=0; i<v; i++) {\n\t\t\tpath.add(new HashMap<Integer, Integer>());\n\t\t}\n\t\tfor(int i=0; i<e; i++) {\n\t\t\tint s = r.nextInt();\n\t\t\tint t = r.nextInt();\n\t\t\tint d = r.nextInt();\n\t\t\tpath.get(s).put(t, d);\n\t\t}\n\t\tbitDP(v);\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte())\n            return buffer[ptr++];\n        else\n            return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n            ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n            throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // public static class Mas {\n    // int x;\n    // int y;\n    // int step;\n\n    // Mas(int x, int y, int step) {\n    // this.x = x;\n    // this.y = y;\n    // this.step = step;\n    // }\n    // }\n\n    static long pow(long l, long i) {\n        if (i == 0)\n            return 1;\n        else {\n            if (i % 2 == 0) {\n                long val = pow(l, i / 2);\n                return val * val % 2019;\n            } else {\n                return pow(l, i - 1) * l % 2019;\n            }\n        }\n    }\n\n    private static final int[] vX = { 1, 0, 0, -1 };\n    private static final int[] vY = { 0, 1, -1, 0 };\n    static int V, E;\n    static int[][] G = new int[20][20]; // グラフ\n    static int[][] dp = new int[50000][20];\n\n    static int rec(int S, int v) {\n        if (S == 0) {\n            if (v == 0) {\n                return 0;\n            } else {\n                return 100000000;\n            }\n        }\n        if ((S & (1 << v)) == 0) { // Sに{v}が含まれていない\n            return 100000000;\n        }\n\n        int ret = dp[S][v];\n        if (ret != 0)\n            return ret;\n\n        ret = 100000000;\n        for (int i = 0; i < V; i++) {\n            ret = Math.min(ret, rec(S ^ (1 << v), i)) + G[i][v];\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n\n        V = fs.nextInt();\n        E = fs.nextInt();\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 20; j++) {\n                G[i][j] = 100000000;\n            }\n        }\n        for (int i = 0; i < E; i++) {\n            int s = fs.nextInt();\n            int t = fs.nextInt();\n            int d = fs.nextInt();\n            G[s][t] = d;\n        }\n        for (int i = 0; i < 50000; i++) {\n            for (int j = 0; j < 20; j++) {\n                dp[i][j] = 100000000;\n            }\n        }\n        dp[0][0] = 0;\n        for (int i = 0; i < (1 << V); i++) {\n            for (int j = 0; j < V; j++) {\n                for (int k = 0; k < V; k++) {\n                    if ((i & (1 << j)) == 0) {\n                        if (j != k)\n                            dp[i | (1 << j)][j] = Math.min(dp[i | (1 << j)][j], dp[i][k] + G[k][j]);\n                    }\n                }\n            }\n        }\n        if (dp[(1 << V) - 1][0] != 100000000) {\n            System.out.println(dp[(1 << V) - 1][0]);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint V=sc.nextInt();//頂点数\n\t\t\tint E=sc.nextInt();//辺の数\n\t\t\tint s;//頂点\n\t\t\tint t;//頂点\n\t\t\tdouble[][] dist=new double[V+1][V+1];//辺の長さ(st距離)\n\t\t\tdouble[][] dp=new double[1<<V][V];\n\t\t\tdouble INF=1e100;\n\t\t\t\n\t\t\tfor(int i=0; i<V; i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\t\tdist[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<E; i++) {\n\t\t\t\ts=sc.nextInt();\n\t\t\t\tt=sc.nextInt();\n\t\t\t\tdist[s][t]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[1][0]=0;//頂点0からスタートだから\n\t\t\t\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {//現在いる頂点j\n\t\t\t\t\tif(dp[i][j]==INF) continue;\n\t\t\t\t\tfor(int k=0; k<V; k++) {//次の行き先頂点k\n\t\t\t\t\t\tif((1&i>>k)==1) continue;//すでに訪れてるとき\n\t\t\t\t\t\telse if(dist[j][k]==INF) continue;//辺がないとき\n\t\t\t\t\t\tint nexti = i| (1<<k);//bitごとのOR演算(今まで通ってきた頂点に次の頂点を足せる) \n\t\t\t\t\t\t//System.out.printf(\"nexti=%d\\n\", nexti);\n\t\t\t\t\t\tdouble nextd=dp[i][j]+dist[j][k];\n\t\t\t\t\t\tdp[nexti][k]=Math.min(dp[nexti][k], nextd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0; i<(1<<V); i++) {\n//\t\t\t\tfor(int j=0; j<V; j++) {\n//\t\t\t\t\tSystem.out.printf(\"dp[%d][%d]=%f\\n\", i, j, dp[i][j]);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint all=(1<<V)-1;//最後の全部bitたっている状態\n\t\t\tdouble ret=INF;\n\t\t\tfor(int i=0; i<V; i++) {//最後頂点0に戻る分の距離を足す\n\t\t\t\tif(dp[all][i]==INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(dist[i][0]==INF) continue;//頂点0にもどれないとき\n\t\t\t\tdouble temp = dp[all][i]+dist[i][0];\n\t\t\t\tret=Math.min(ret, temp);\n\t\t\t}\n\t\t\tif(ret==INF) {\n\t\t\t\tret=-1;\n\t\t\t}//bitが全部たたない\n\t\t\tSystem.out.println((int)ret);\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM = 2000000000;\n\tpublic static final int MOD = 1000000007;\n\tpublic static final long HUGE_NUM = 99999999999999999L;\n\tpublic static final double EPS = 0.000000001;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint V = scanner.nextInt();\n\t\tint E = scanner.nextInt();\n\n\t\tint POW[] = new int[V+1];\n\t\tPOW[0] = 1;\n\t\tfor(int i = 1; i <= V; i++){\n\n\t\t\tPOW[i] = POW[i-1]*2;\n\t\t}\n\n\t\tArrayList<Edge> G[] = new ArrayList[V];\n\t\tfor(int i = 0; i < V; i++){\n\n\t\t\tG[i] = new ArrayList<Edge>();\n\t\t}\n\n\t\tfor(int loop = 0; loop < E; loop++){\n\n\t\t\tint from = scanner.nextInt();\n\t\t\tint to = scanner.nextInt();\n\t\t\tint weight = scanner.nextInt();\n\n\t\t\tG[from].add(new Edge(to,weight));\n\t\t}\n\n\t\tint dp[][] = new int[POW[V]][V];\n\n\t\tfor(int state = 0; state < POW[V]; state++){\n\t\t\tfor(int last_node = 0; last_node < V; last_node++){\n\t\t\t\tdp[state][last_node] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\t//頂点0スタート0戻り\n\t\tint base = 0;\n\n\t\tdp[POW[0]][0] = 0;\n\n\t\tfor(int state = 1; state < POW[V]-1; state++){\n\t\t\tfor(int last_node = 0; last_node < V; last_node++){\n\t\t\t\tif(dp[state][last_node] == BIG_NUM)continue;\n\n\t\t\t\tfor(int i = 0; i < G[last_node].size(); i++){\n\n\t\t\t\t\tint next_node = G[last_node].get(i).to;\n\t\t\t\t\tif((state & POW[next_node]) != 0)continue;\n\n\t\t\t\t\tint next_state = state+POW[next_node];\n\n\t\t\t\t\tdp[next_state][next_node] = Math.min(dp[next_state][next_node], dp[state][last_node]+G[last_node].get(i).weight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = BIG_NUM;\n\t\tfor(int last_node = 1; last_node < V; last_node++){\n\t\t\tfor(int i = 0; i < G[last_node].size(); i++){\n\t\t\t\tif(G[last_node].get(i).to != base)continue;\n\n\t\t\t\tans = Math.min(ans,dp[POW[V]-1][last_node]+G[last_node].get(i).weight);\n\t\t\t}\n\t\t}\n\n\t\tif(ans == BIG_NUM){\n\n\t\t\tSystem.out.println(\"-1\");\n\n\t\t}else{\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass Edge{\n\tEdge(int arg_to,int arg_weight){\n\t\tto = arg_to;\n\t\tweight = arg_weight;\n\t}\n\tint to,weight;\n}\n\nclass UTIL{\n\n\t//最大公約数\n\tpublic static long gcd(long x,long y){\n\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\n\t\tif(x < y){\n\n\t\t\tlong tmp = y;\n\t\t\ty = x;\n\t\t\tx = tmp;\n\t\t}\n\n\t\tif(y == 0){\n\n\t\t\treturn x;\n\t\t}else{\n\n\t\t\treturn gcd(y,x%y);\n\t\t}\n\t}\n\n\t//最小公倍数\n\tpublic static long lcm(long x,long y){\n\n\t\treturn (x*y)/gcd(x,y);\n\t}\n\n\t//String→intへ変換\n    public static int getNUM(String tmp_str){\n\n        return Integer.parseInt(tmp_str);\n    }\n\n    //文字が半角数字か判定する関数\n    public static boolean isNumber(String tmp_str){\n\n        if(tmp_str == null || tmp_str.length() == 0){\n\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\A[0-9]+\\\\z\");\n        Matcher matcher = pattern.matcher(tmp_str);\n        return matcher.matches();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif dp.contains(mask) && dp.get(mask).contains(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if(mask & (1 << i) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.contains(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    int N;\n    ArrayList<ArrayList<Pair>> G = new ArrayList<>();\n    int[][] dp = new int[1 << 15][15];\n\n    int INF = 1 << 20;\n\n    void solve() throws IOException {\n        N = ni();\n        int M = ni();\n\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int s = ni();\n            int t = ni();\n            int d = ni();\n\n            G.get(s).add(new Pair(t, d));\n        }\n\n        for (int[] a : dp) Arrays.fill(a, -1);\n        int ans = rec(0, 0);\n        out.println(ans >= INF ? -1 : ans);\n    }\n\n    int rec(int S, int v) {\n        if (dp[S][v] >= 0) return dp[S][v];\n\n        if (S == (1 << N) - 1 && v == 0) {\n            return 0;\n        }\n\n        int ans = INF;\n        for (Pair p : G.get(v)) {\n            if (((S >> p.x) & 1) == 0) {\n                ans = Math.min(ans, rec(S | (1 << p.x), p.x) + p.y);\n            }\n        }\n        return ans;\n    }\n\n    public class Pair {\n        int x, y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.contains(mask) && dp.get(mask).contains(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if(mask & (1 << i) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.contains(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int[] a;\n  static int infi = 2000000;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int v, e, i, j, k;\n    int[][] d, dp;\n\n    v = sc.nextInt(); e = sc.nextInt();\n    d = new int[v][v]; a = new int[v + 1];\n    for(i = 0;i < v;i++)for(j = 0;j < v;j++)d[i][j] = infi;\n    for(;e-- > 0;)d[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n    a[0] = 1;\n    for(i = 0;i < v;i++)a[i + 1] = a[i] * 2;\n    dp = new int[a[v]][v];\n    for(i = 0;i < a[v];i++)for(j = 0;j < v;j++)dp[i][j] = infi;\n    dp[a[v] - 1][0] = 0;\n\n    for(i = a[v] - 1;i >= 0;i--)\n      for(j = 0;j < v;j++)if(dp[i][j] != infi && isin(i, j))\n        for(k = 0;k < v;k++)if(j != k && isin(i, k) && d[k][j] < infi){\n          if(dp[i][j] + d[k][j] < dp[i - a[j]][k])\n            dp[i - a[j]][k] = dp[i][j] + d[k][j];\n        }\n    if(dp[0][0] != infi)out.println(dp[0][0]);\n    else out.println(\"-1\");\n\n    sc.close();\n  }\n  private static boolean isin(int s, int v){\n    return (v == 0 || ((s % a[v + 1]) / a[v]) == 1);\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t    return tsp(1, 0);\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.containsKey(mask) && dp.get(mask).containsKey(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if((mask & (1 << i)) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.containsKey(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tint VISITED_ALL = ((1<<n) -1);\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint vn = scan.nextInt();\n\t\tint en = scan.nextInt();\n\n\t\tTravel t = new Travel(vn, en);\n\n\t\tfor (int i = 0; i < en; i++)\n\t\t\tt.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\n\t\tpwriter.println(t.getDistance());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Travel {\n\tint[][] dist;\n\tint goal;\n\tint[] ix;\n\tint[][] hist;\n\n\tpublic Travel(int vn, int en) {\n\t\tdist = new int[vn][vn];\n\t\tfor (int st = 0; st < vn; st++)\n\t\t\tfor (int ed = 0; ed < vn; ed++)\n\t\t\t\tdist[st][ed] = -1;\n\n\t\t// index number for each vertices\n\t\tix = new int[vn];\n\t\tix[1] = 1;\n\t\tfor (int i = 2; i < vn; i++)\n\t\t\tix[i] = ix[i - 1] << 1;\n\t\t// all vertices is reached\n\t\tgoal = (ix[vn - 1] << 1) - 1;\n\n\t\thist = new int[vn][goal + 1];\n\t\tfor (int i = 0; i < vn; i++)\n\t\t\tfor (int j = 0; j < goal + 1; j++)\n\t\t\t\thist[i][j] = Integer.MAX_VALUE;\n\t}\n\n\tpublic int getDistance() {\n\t\treturn minDist(0, 0);\n\t}\n\n\tprivate int minDist(int st, int passed) {\n\t\t// st is start vertices, passed is sum of reached vertices index\n\t\tif (passed == goal)\n\t\t\tif (dist[st][0] >= 0)\n\t\t\t\treturn dist[st][0];\n\t\t\telse\n\t\t\t\treturn -1;\n\n\t\tif (hist[st][passed] < Integer.MAX_VALUE)\n\t\t\treturn hist[st][passed];\n\n\t\tint min = -1;\n\t\tfor (int i = 1; i < ix.length; i++) {\n\t\t\tif ((passed & ix[i]) != 0 || dist[st][i] == -1)\n\t\t\t\tcontinue;\n\t\t\tint d = minDist(i, (passed | ix[i]));\n\t\t\tif (d < 0)\n\t\t\t\tcontinue;\n\t\t\td += dist[st][i];\n\t\t\tif (d >= 0 && (d < min || min == -1))\n\t\t\t\tmin = d;\n\t\t}\n\t\n\t\thist[st][passed] = min;\n\t\treturn min;\n\t}\n\n\tpublic void addRoot(int s, int t, int d) {\n\t\tdist[s][t] = d;\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 20;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic int n, e;\n\tstatic int[][] dest, dp;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tn = in.nextInt(); e = in.nextInt();\n\t\t\tdest = new int[n][n];\n\t\t\tdp = new int[1 << n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dest[i], INF);\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tdest[s][t] = d;\n\t\t\t}\n\n\t\t\tint ans = rec(0, 0);\n\t\t\tout.println(ans == INF ? -1 : ans);\n\t\t}\n\n\t\tint rec(int S, int v) {\n\n\t\t\tif (dp[S][v] >= 0) {\n\t\t\t\treturn dp[S][v];\n\t\t\t}\n\n\t\t\tif (S == (1 << n) -1 && v == 0) {\n\t\t\t\treturn dp[S][v] = 0;\n\t\t\t}\n\n\t\t\tint res = INF;\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((S >> u) & 1) == 0) {\n\t\t\t\t\tres = Math.min(res, rec(S | (1 << u), u) + dest[v][u]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dp[S][v] = res;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n\tstatic void print(int[][] dp) {\n\t\tint n = dp.length;\n\t\tint m = dp[0].length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\tSystem.out.print(\"\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.contains(mask) && dp.get(mask).contains(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if(mask & (1 << i) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.contains(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\tpublic char nextchar() {\n\t\treturn next().charAt(0);\n\t}\n}\n\nclass UnionFind {\n\tint Parent[];\n\tUnionFind(int n) {// Initialize by -1\n\t\tParent = new int[n];\n\t\tArrays.fill(Parent, -1);\n\t}\n\tint root(int A) {// In which tree is A?\n\t\tif (Parent[A] < 0)\n\t\t\treturn A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\tint size(int A) {// size of tree which is include A\n\t\treturn -Parent[root(A)];\n\t}\n\tboolean connect(int A, int B) {// Connect A and B\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B)\n\t\t\treturn false;\n\t\tif (size(A) < size(B)) {\n\t\t\tint C = 0;\n\t\t\tC = B;\n\t\t\tB = A;\n\t\t\tA = C;\n\t\t} // SWAP\n\t\tParent[A] += Parent[B];\n\t\tParent[B] = A;\n\t\treturn true;\n\t}\n}\n\nclass Pair<T, E> {\n\tpublic T first;\n\tpublic E second;\n\tvoid set(T x, E y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n}\n\nclass Pint {\n\tpublic int first;\n\tpublic int second;\n\tPint(int x, int y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n\tvoid set(int x, int y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n}\n\nclass Tpair {\n\tpublic int first;\n\tpublic int second;\n\tpublic long third;\n\tTpair(int x, int y, long z) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t\tthird = z;\n\t}\n\tvoid set(int x, int y, long z) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t\tthird = z;\n\t}\n}\n\npublic class Main {\n\tstatic FastScanner scan = new FastScanner();\n\tstatic Scanner scanner = new Scanner(System.in);\n\tstatic Random rand = new Random();\n\tstatic long mod = 1000000007;\n\tstatic double eps = 1.0E-14;\n\tstatic int big = Integer.MAX_VALUE;\n\tstatic double PI = 3.141592653589793;\n\tstatic long modlcm(long a, long b) {\n\t\treturn a * b * modinv(GCD(a, b), mod);\n\t}\n\tstatic long GCD(long a, long b) {\n\t\treturn b > 0 ? GCD(b, a % b) : a;\n\t}\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / GCD(a, b);\n\t}\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\tstatic long factorial(int i) {\n\t\treturn i == 1 ? 1 : i * factorial(i - 1);\n\t}\n\tstatic int max(int... i) {\n\t\tint x = i[0];\n\t\tfor (int e : i)\n\t\t\tx = Math.max(x, e);\n\t\treturn x;\n\t}\n\tstatic int min(int... i) {\n\t\tint x = i[0];\n\t\tfor (int e : i)\n\t\t\tx = Math.min(x, e);\n\t\treturn x;\n\t}\n\tstatic long gcd(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = GCD(x, e);\n\t\treturn x;\n\t}\n\tstatic long lmax(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = Math.max(x, e);\n\t\treturn x;\n\t}\n\tstatic long lmin(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = Math.min(x, e);\n\t\treturn x;\n\t}\n\tstatic long nCr(long n, long r, long m) {\n\t\tlong ans = 1;\n\t\tfor (long i = 0; i < r; i++) {\n\t\t\tans *= (n - i);\n\t\t\tans %= m;\n\t\t}\n\t\tfor (long i = 0; i <= r; i++) {\n\t\t\tans *= modinv(i, m);\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic int lower_bound(int a[], int key) {\n\t\tint ok = a.length;\n\t\tint ng = -1;\n\t\twhile (Math.abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (a[mid] >= key)\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic int upper_bound(int a[], int key) {\n\t\tint ok = a.length;\n\t\tint ng = -1;\n\t\twhile (Math.abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (a[mid] > key)\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic boolean isPrime(long n) {\n\t\tif (n == 2)\n\t\t\treturn true;\n\t\tif (n < 2 || n % 2 == 0)\n\t\t\treturn false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i = 3; i <= d; i += 2)\n\t\t\tif (n % i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a, int b) {\n\t\tif (a % b == 0) {\n\t\t\treturn a / b;\n\t\t} else {\n\t\t\treturn a / b + 1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a, long b) {\n\t\tif (a % b == 0) {\n\t\t\treturn a / b;\n\t\t} else {\n\t\t\treturn a / b + 1;\n\t\t}\n\t}\n\tstatic int[] setArray(int a) {\n\t\tint b[] = new int[a];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tb[i] = scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[] = new long[a];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tb[i] = scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverse(String str) {\n\t\tchar ch[] = new char[str.length()];\n\t\tchar chch[] = str.toCharArray();\n\t\tint a = str.length();\n\t\tfor (int i = 0; i < upper_division(a, 2); i++) {\n\t\t\tch[i] = chch[ch.length - i - 1];\n\t\t\tch[ch.length - 1 - i] = chch[i];\n\t\t}\n\t\treturn String.valueOf(ch);\n\t}\n\tpublic static void printArray(int[] que) {\n\t\tfor (int i = 0; i < que.length - 1; i++) {\n\t\t\tSystem.out.print(que[i] + \" \");\n\t\t}\n\t\tSystem.out.println(que[que.length - 1]);\n\t}\n\tpublic static void lprintArray(long[] que) {\n\t\tfor (int i = 0; i < que.length - 1; i++) {\n\t\t\tSystem.out.print(que[i] + \" \");\n\t\t}\n\t\tSystem.out.println(que[que.length - 1]);\n\t}\n\tpublic static int[][] doublesort(int[][] a) {\n\t\tArrays.sort(a, (x, y) -> Integer.compare(x[0], y[0]));\n\t\treturn a;\n\t}\n\tpublic static long[][] ldoublesort(long[][] a) {\n\t\tArrays.sort(a, (x, y) -> Long.compare(x[0], y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x, long n, long mo) {\n\t\tlong sum = 1;\n\t\twhile (n > 0) {\n\t\t\tif ((n & 1) == 1) {\n\t\t\t\tsum = sum * x % mo;\n\t\t\t}\n\t\t\tx = x * x % mo;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[] = new char[ch.length];\n\t\tfor (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n\t\t\tret[j] = ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[] = new int[ch.length];\n\t\tfor (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n\t\t\tret[j] = ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[][] warshall_floyd(int v[][], int n) {\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\treturn v;\n\t}\n\tpublic static long modinv(long a, long m) {\n\t\tlong b = m, u = 1, v = 0;\n\t\twhile (b != 0) {\n\t\t\tlong t = a / b;\n\t\t\ta -= t * b;\n\t\t\tlong x = a;\n\t\t\ta = b;\n\t\t\tb = x;\n\t\t\tu -= t * v;\n\t\t\tx = u;\n\t\t\tu = v;\n\t\t\tv = x;\n\t\t}\n\t\tu %= m;\n\t\tif (u < 0)\n\t\t\tu += m;\n\t\treturn u;\n\t}\n\tpublic static void main(String[] $) throws IOException{\n\t\tint v=scan.nextInt();\n\t\tint e=scan.nextInt();\n\t\tint es[][]=new int[v][v];\n\t\tfor(int i=0;i<v;i++)Arrays.fill(es[i], -1);\n\t\tfor(int i=0;i<e;i++) {\n\t\t\tes[scan.nextInt()][scan.nextInt()]=scan.nextInt();\n\t\t}\n\t\tint ans=big;\n\t\tfor(int x=0;x<v;x++) {\n\t\t\tint dp[][]=new int[1<<v][v];\n\t\t\tfor(int i=0;i<(1<<v);i++) {\n\t\t\t\tArrays.fill(dp[i], big/2);\n\t\t\t}\n\t\t\tdp[0][x]=0;\n\t\t\tfor(int S=1;S<(1<<v);S++) {\n\t\t\t\tfor(int V=0;V<v;V++) {\n\t\t\t\t\tif((S&(1<<V))>0) {\n\t\t\t\t\t\tfor(int i=0;i<v;i++) {\n\t\t\t\t\t\t\tif(es[i][V]!=-1){\n\t\t\t\t\t\t\t\tdp[S][V]=min(dp[S][V],dp[S-(1<<V)][i]+es[i][V]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,dp[(1<<v)-1][x]);\n\t\t}\n\t\tSystem.out.println(ans>=big/2?\"-1\":ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 26;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint v = in.nextInt(), e = in.nextInt();\n\t\t\tint[][] mat = new int[v][v];\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tArrays.fill(mat[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tmat[s][t] = d;\n\t\t\t}\n\n\t\t\tint ans = INF;\n\n\t\t\tint[][] dp = new int[1 << v][v];\n\t\t\tfor (int k = 0; k < v; k++) {\n\n\t\t\t\tdp = new int[1 << v][v];\n\t\t\t\tfor (int i = 0; i < 1 << v; i++) {\n\t\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t\t}\n\t\t\t\tdp[0][k] = 0;\n\n\t\t\t\tfor (int s = 0; s < 1<<v; s++) {\n\t\t\t\t\tfor (int now = 0; now < v; now++) {\n\t\t\t\t\t\tfor (int to = 0; to < v; to++) {\n\t\t\t\t\t\t\tif ((s >> to & 1) == 0 && mat[now][to] != -1) {\n\t\t\t\t\t\t\t\tdp[s|1<<to][to] = Math.min(dp[s|1<<to][to], dp[s][now] + mat[now][to]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = Math.min(ans, dp[(1<<v)-1][k]);\n\n\t\t\t}\n\n\n\t\t\tout.println(ans == INF ? -1 : ans);\n\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic int mod = (int) 1e9 + 7;\n\tstatic int DX[] = { -1, 0, 1, 0 }, DY[] = { 0, -1, 0, 1 };\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\tstatic final long LINF = Long.MAX_VALUE / 3;\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner(System.in);\n\t\tint v = fs.nextInt(), e = fs.nextInt();\n\t\tint graph[][] = new int[v][v];\n\t\tfor(int i=0;i<v;i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor(int i=0;i<e;i++) {\n\t\t\tint s = fs.nextInt(), t = fs.nextInt(), d = fs.nextInt();\n\t\t\tgraph[s][t] = d;\n\t\t}\n\t\t\n\t\tint dp[][] = new int[1<<v][v];\n\t\tfor(int i=0;i<1<<v;i++) {\n\t\t\tArrays.fill(dp[i],INF);\n\t\t}\n\t\tdp[(1<<v)-1][0] = 0;\n\t\tfor(int i=(1<<v)-2;i>=0;i--) {\n\t\t\t//今いる町\n\t\t\tfor(int j=0;j<v;j++) {\n\t\t\t\t//次にたどり着く町\n\t\t\t\tfor(int k=0;k<v;k++) {\n\t\t\t\t\t//次にたどり着く町が、訪問済でない場合\n\t\t\t\t\tif((i>>k&1)==0) {\n\t\t\t\t\t\t//今の町からゴールは、次の町からゴールまでの距離に、今の町から次の町の距離の和\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i|1<<k][k] + graph[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[0][0] == INF)System.out.println(-1);\n\t\telse System.out.println(dp[0][0]);\n\t\t\n\t}\n\n\t//MOD culculations\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n}\n\n//高速なScanner\nclass FastScanner {\n\tprivate BufferedReader reader = null;\n\tprivate StringTokenizer tokenizer = null;\n\n\tpublic FastScanner(InputStream in) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nextLine() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken(\"\\n\");\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.*;\npublic class Main {\n\tstatic final int INF = (int)1e9 + 7;\n\tint V,E;\n\tint[][] cost;\n\tint[][][] dp;\n\tpublic int dfs(int s,int n,int v){\n\t\tif(n == V){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[s][n][v] != -1)return dp[s][n][v];\n\t\tint ret = INF;\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tif(cost[s][i] == -1)continue;\n\t\t\tif(((v >> i)&1)==1)continue;\n\t\t\tret = Math.min(ret,dfs(i,n + 1,(v | (1 << i))) + cost[s][i]);\n\t\t}\n\t\treturn dp[s][n][v] = ret;\n\t}\n\t\n    public void solve() {\n\t\tV = nextInt();\n\t\tE = nextInt();\n\t\t\n\t\tcost = new int[V][V];\n\t\tdp = new int[V + 1][V + 1][1 << V];\n\t\tfor(int i = 0;i < V + 1;i++){\n\t\t\tfor(int j = 0;j < V + 1;j++){\n\t\t\t\tArrays.fill(dp[i][j],-1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < V;i++)Arrays.fill(cost[i],-1);\n\t\tfor(int i = 0;i < E;i++){\n\t\t\t\n\t\t\tint s = nextInt();\n\t\t\tint t = nextInt();\n\t\t\tint d = nextInt();\n\t\t\tcost[s][t] = d;\n\t\t}\n\t\tint ans = dfs(0,0,0);\n\t\tout.println(ans == INF ? - 1 : ans);\n    }\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\t\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tint VISITED_ALL = (1<<n) -1;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tstatic int[][] dp;\n\tstatic int[][] d;\n\tstatic int v,e;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString line = br.readLine();\n\t\tv = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\te = Integer.parseInt(line.substring(line.indexOf(' ')+1));\n\t\td = new int[v][v];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\tline = br.readLine();\n\t\t\tString[] str = line.split(\" \");\n\t\t\tint si = Integer.parseInt(str[0]);\n\t\t\tint ti = Integer.parseInt(str[1]);\n\t\t\tint di = Integer.parseInt(str[2]);\n\t\t\td[si][ti] = di;\n\t\t}\n\n\t\tdp = new int[1<<v][v];\n\t\tfor (int i=0; i<1<<v; i++)\n\t\t\tArrays.fill(dp[i],-1);\n\t\tdp[(1<<v)-1][0] = 0;\n\t\t\n\t\tint ans = rec(0,0);\n\t\tSystem.out.println(ans>=INF?-1:ans);\n\n\t\tbr.close();\n\t}\n\n\tstatic int rec(int i,int j) {\n\t\tif (dp[i][j] >= 0)\n\t\t\treturn dp[i][j];\n\t\tif ((i == (1<<v)-1) && (j == 0))\n\t\t\treturn dp[i][j] = 0;\n\t\tint res = INF;\n\t\tfor (int k=0; k<v; k++) {\n\t\t\tif (((i>>k)&1) == 0 && d[j][k] != 0)\n\t\t\t\tres = Math.min(res,rec(i|1<<k,k)+d[j][k]);\n\t\t}\n\t\treturn dp[i][j] = res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tint visitedAll = ((1<<n) -1);\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 26;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint v = in.nextInt(), e = in.nextInt();\n\t\t\tint[][] mat = new int[v][v];\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tArrays.fill(mat[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tmat[s][t] = d;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[1 << v][v];\n\t\t\tfor (int i = 0; i < 1 << v; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\n\t\t\tfor (int s = 0; s < 1<<v; s++) {\n\t\t\t\tfor (int now = 0; now < v; now++) {\n\t\t\t\t\tfor (int to = 0; to < v; to++) {\n\t\t\t\t\t\tif ((s >> to & 1) == 0 && mat[now][to] != -1) {\n\t\t\t\t\t\t\tdp[s|1<<to][to] = Math.min(dp[s|1<<to][to], dp[s][now] + mat[now][to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[(1<<v)-1][0] == INF ? -1 : dp[(1<<v)-1][0]);\n\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 20;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic int n, e;\n\tstatic int[][] dest, dp;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tn = in.nextInt(); e = in.nextInt();\n\t\t\tdest = new int[n][n];\n\t\t\tdp = new int[1 << n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dest[i], INF);\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tdest[s][t] = d;\n\t\t\t}\n\n\t\t\tint ans = rec(0, 0);\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tint rec(int S, int v) {\n\n\t\t\tif (dp[S][v] >= 0) {\n\t\t\t\treturn dp[S][v];\n\t\t\t}\n\n\t\t\tif (S == (1 << n) -1 && v == 0) {\n\t\t\t\treturn dp[S][v] = 0;\n\t\t\t}\n\n\t\t\tint res = INF;\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((S >> u) & 1) == 0) {\n\t\t\t\t\tres = Math.min(res, rec(S | (1 << u), u) + dest[v][u]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dp[S][v] = res;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n\tstatic void print(int[][] dp) {\n\t\tint n = dp.length;\n\t\tint m = dp[0].length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\tSystem.out.print(\"\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.containsKey(mask) && dp.get(mask).containsKey(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if((mask & (1 << i)) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.containsKey(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint v = in.nextInt(), e = in.nextInt();\n\t\t\tint[][] mat = new int[v][v];\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tArrays.fill(mat[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tmat[s][t] = d;\n\t\t\t}\n\n\t\t\tint[][] dp = new int[1 << v][v];\n\t\t\tfor (int i = 0; i < 1 << v; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[(1<<v)-1][0] = 0;\n\n\t\t\tfor (int s = (1<<v)-2; s >= 0; s--) {\n\t\t\t\tfor (int now = 0; now < v; now++) {\n\t\t\t\t\tfor (int to = 0; to < v; to++) {\n\t\t\t\t\t\tif ((s >> to & 1) == 0 && mat[now][to] != -1) {\n\t\t\t\t\t\t\tdp[s][to] = Math.min(dp[s][to], dp[s | 1<<to][now] + mat[now][to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[0][0] == INF ? -1 : dp[0][0]);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\n\t\tint v = sc.nextInt();\n\t\tint e = sc.nextInt();\n\t\t\n\t\tWDGraph g = new WDGraph(v);\n\t\t\n\t\tfor(int i=0;i<e;i++){\n\t\t\tg.addEdge(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t}\n\t\t\n\t\tint ans = travelingSales(g);\n\t\t\n\t\tif(ans == Integer.MAX_VALUE/2){\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tstatic int travelingSales(WDGraph g){\n\t\tint n = g.vnum();\n\t\tint[][] dp = new int[1<<n][n];\n\t\tfor(int i=0;i<dp.length;i++){\n\t\t\tArrays.fill(dp[i],Integer.MAX_VALUE/2);\n\t\t}\n\t\tdp[(1<<n)-1][0] = 0;\n\t\t\n\t\tfor(int S=(1<<n)-2;S>=0;S--){\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tfor(WDGraph.WEdge e:g.elist[v]){\n\t\t\t\t\tif(!(((S>>e.to)&1) == 1)){ //Sがe.toを含んでいなければ\n\t\t\t\t\t\tdp[S][v] = Math.min(dp[S][v], dp[S|1<<e.to][e.to] + e.w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dp[0][0];\n\t}\n\t\n}\n\nclass WDGraph {\n\tpublic WEdgeList[] elist;\n\t\n\tpublic WDGraph(int vnum){\n\t\tthis.elist = new WEdgeList[vnum];\n\t\tfor(int i=0;i<vnum;i++){\n\t\t\telist[i] = new WEdgeList();\n\t\t}\n\t}\n\t\n\t//同じ辺を複数回追加すると多重辺が生まれてしまう\n\tpublic void addEdge(int from, int to, int w){\n\t\telist[from].add(new WEdge(to,w));\n\t}\n\t\n\t//頂点数を返す\n\tpublic int vnum(){\n\t\treturn elist.length;\n\t}\n\t\n\tpublic class WEdgeList extends ArrayList<WEdge>{\n\t\tprivate static final long serialVersionUID = -3222721656143220018L;\n\t}\n\tpublic class WEdge{\n\t\tpublic int to;\n\t\tpublic int w;\n\t\t\n\t\tpublic WEdge(int to, int w){\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n}\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tint V=sc.nextInt();\t//Vertex->頂点数\n\t\tint E=sc.nextInt();//Edge->辺の数\n\t\tint[][] rinsetu=new int[V][V];\n\t\tint INF=1000000007;\n\t\tint[][] bitDP=new int[1<<V][V];\n\t\t//最初だからねしょうがないね\n\t\t//巡回セールスマン問題は、最初の地点は決まっておらず、任意の頂点からスタートできるので、\n\t\t//かならずしもスタートを頂点0からできないのでは？と思うが、それは偽で、\n\t\t//巡回セールスマン問題でもとめる最短経路は閉路（サイクル）なので、そのサイクルを構成する任意の点から始めても、\n\t\t//同じ答えを出すことができるので、スタートを頂点0だと決め打ちしても問題ない。\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tArrays.fill(rinsetu[i], INF);\n\t\t}\n\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\tbitDP[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<E; i++) {\n\t\t\tint from=sc.nextInt();\n\t\t\tint to=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\trinsetu[from][to]=cost;\n\t\t}\n\t\tbitDP[1][0]=0;\n\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\tif(bitDP[i][j]==INF) {\n\t\t\t\t\tcontinue;\t\t//経路を確立していないなら\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int k=0; k<V; k++) {\n\t\t\t\t\t\tif((1&i>>k)==1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(rinsetu[j][k]==INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint nexti=i|(1<<k);\n\t\t\t\t\t\t\tbitDP[nexti][k]=Math.min(bitDP[nexti][k], bitDP[i][j]+rinsetu[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint all=(1<<V)-1;\n\t\tint min=INF;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tif(bitDP[all][i]==INF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(rinsetu[i][0]==INF) {//さいしょにもどれないとき\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint allcost=bitDP[all][i]+rinsetu[i][0];\n\t\t\t\tmin=Math.min(min, allcost);\n\t\t\t}\n\t\t}\n\t\tif(min==INF) {\n\t\t\tpl(-1);\n\t\t}\n\t\telse {\n\t\t\tpl(min);\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tint VISITED_ALL;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tVISITED_ALL = ((1 << M) -1);\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n/**\n * @author baito\n */\n\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 12345678;\n    static long LINF = 123456789123456789L;\n    static long MINF = -123456789123456789L;\n    static long MOD = 1000000007;\n    static int[] y4 = {0, 1, 0, -1};\n    static int[] x4 = {1, 0, -1, 0};\n    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};\n    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};\n    static long[] F;//factorial\n    static boolean[] isPrime;\n    static int[] primes;\n    static char[][] map;\n\n    static int V, E;\n    static long[][] dp; //通った物のbit  現在地点\n    static Node[] nodes;\n\n\n    public static void main(String[] args)\n    {\n        V = sc.nextInt();\n        E = sc.nextInt();\n        dp = new long[1 << V][V];\n        initNodes(V);\n        for (int i = 0; i < E; i++)\n        {\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            long d = sc.nextLong();\n            addEdge(s, t, d);\n        }\n        fill(dp, -1);\n        long res = rec(0, 0);\n        System.out.println(res >= INF ? -1 : res);\n\n    }\n\n    static long rec(int s, int v)\n    {\n        //メモ済み\n        if (dp[s][v] >= 0) return dp[s][v];\n        //ゴール\n        if ((1 << V) - 1 == s && v == 0) return 0;\n        long res = INF;\n        for (Edge edge : nodes[v].edges)\n        {\n            int to = edge.toId;\n            long cost = edge.toCost;\n            if (((s >> to) & 1) == 1) continue;//探索済み\n            res = Main.min(res, rec(s | (1 << to), to) + cost);\n        }\n        return dp[s][v] = res;\n    }\n\n    public static void initNodes(int n)\n    {\n        nodes = new Node[n];\n        for (int i = 0; i < n; i++)\n            nodes[i] = new Node(i);\n    }\n\n    public static void addEdge(int f, int t, long c)\n    {\n        nodes[f].edges.add(new Edge(t, c));\n\n    }\n\n    static class Node\n    {\n        int id;\n        List<Edge> edges;\n\n        Node(int id)\n        {\n            edges = new ArrayList<>();\n            this.id = id;\n        }\n    }\n\n    static class Edge\n    {\n        int toId;\n        long toCost;\n\n        Edge(int id, long cost)\n        {\n            toId = id;\n            toCost = cost;\n        }\n\n    }\n\n    public static Integer[] toIntegerArray(int[] ar)\n    {\n        Integer[] res = new Integer[ar.length];\n        for (int i = 0; i < ar.length; i++)\n        {\n            res[i] = ar[i];\n        }\n        return res;\n    }\n\n    //k個の次の組み合わせをビットで返す 大きさに上限はない 110110 -> 111001\n    public static int nextCombSizeK(int comb, int k)\n    {\n        int x = comb & -comb; //最下位の1\n        int y = comb + x; //連続した下の1を繰り上がらせる\n        return ((comb & ~y) / x >> 1) | y;\n    }\n\n    public static int keta(long num)\n    {\n        int res = 0;\n        while (num > 0)\n        {\n            num /= 10;\n            res++;\n        }\n        return res;\n    }\n\n    public static long getHashKey(int a, int b)\n    {\n        return (long) a << 32 | b;\n    }\n\n    public static boolean isOutofIndex(int x, int y)\n    {\n        if (x < 0 || y < 0) return true;\n        if (map[0].length <= x || map.length <= y) return true;\n        return false;\n    }\n\n    public static void setPrimes()\n    {\n        int n = 100001;\n        isPrime = new boolean[n];\n        List<Integer> prs = new ArrayList<>();\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= n; i++)\n        {\n            if (!isPrime[i]) continue;\n            prs.add(i);\n            for (int j = i * 2; j < n; j += i)\n            {\n                isPrime[j] = false;\n            }\n        }\n        primes = new int[prs.size()];\n        for (int i = 0; i < prs.size(); i++)\n            primes[i] = prs.get(i);\n    }\n\n    public static void revSort(int[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static void revSort(long[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int[][] copy(int[][] ar)\n    {\n        int[][] nr = new int[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            for (int j = 0; j < ar[0].length; j++)\n                nr[i][j] = ar[i][j];\n        return nr;\n    }\n\n    /**\n     * <h1>指定した値以上の先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス\n     * 値が無ければ、挿入できる最小のインデックス\n     */\n    public static int lowerBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値より大きい先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス\n     * 値が無ければ、挿入できる最小のインデックス\n     */\n    public static int upperBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値以上の先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス\n     * 値がなければ挿入できる最小のインデックス\n     */\n    public static long lowerBound(final long[] arr, final long value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>指定した値より大きい先頭のインデクスを返す</h1>\n     * <p>配列要素が０のときは、０が返る。</p>\n     *\n     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス\n     * 値がなければ挿入できる最小のインデックス\n     */\n    public static long upperBound(final long[] arr, final long value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //次の順列に書き換える、最大値ならfalseを返す\n    public static boolean nextPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] < A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //posより大きい最小の数を二分探索\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] > A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //次の順列に書き換える、最小値ならfalseを返す\n    public static boolean prevPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] > A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //posより小さい最大の数を二分探索\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] < A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //↓nCrをmod計算するために必要。　***factorial(N)を呼ぶ必要がある***\n    static long ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        else if (r == 0) return 1;\n\n        factorial(n);\n        return F[n] / (F[n - r] * F[r]);\n    }\n\n    static long ncr2(int a, int b)\n    {\n        if (b == 0) return 1;\n        else if (a < b) return 0;\n        long res = 1;\n        for (int i = 0; i < b; i++)\n        {\n            res *= a - i;\n            res /= i + 1;\n        }\n        return res;\n    }\n\n    static long ncrdp(int n, int r)\n    {\n        if (n < r) return 0;\n        long[][] dp = new long[n + 1][r + 1];\n        for (int ni = 0; ni < n + 1; ni++)\n        {\n            dp[ni][0] = dp[ni][ni] = 1;\n            for (int ri = 1; ri < ni; ri++)\n            {\n                dp[ni][ri] = dp[ni - 1][ri - 1] + dp[ni - 1][ri];\n            }\n        }\n        return dp[n][r];\n    }\n\n    static long modNcr(int n, int r)\n    {\n        if (n < r) return 0;\n        long result = F[n];\n        result = result * modInv(F[n - r]) % MOD;\n        result = result * modInv(F[r]) % MOD;\n        return result;\n    }\n\n    public static long modSum(long... lar)\n    {\n        long res = 0;\n        for (long l : lar)\n            res = (res + l % MOD) % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modDiff(long a, long b)\n    {\n        long res = a % MOD - b % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modMul(long... lar)\n    {\n        long res = 1;\n        for (long l : lar)\n            res = (res * l % MOD) % MOD;\n        if (res < 0) res += MOD;\n        res %= MOD;\n        return res;\n    }\n\n    public static long modDiv(long a, long b)\n    {\n        long x = a % MOD;\n        long y = b % MOD;\n        long res = (x * modInv(y)) % MOD;\n        return res;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        F = new long[n + 1];\n        F[0] = F[1] = 1;\n//        for (int i = 2; i <= n; i++)\n//        {\n//            F[i] = (F[i - 1] * i) % MOD;\n//        }\n        //\n        for (int i = 2; i <= 100000; i++)\n        {\n            F[i] = (F[i - 1] * i) % MOD;\n        }\n        for (int i = 100001; i <= n; i++)\n        {\n            F[i] = (F[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //↑nCrをmod計算するために必要\n\n    static int gcd(int n, int r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static long gcd(long n, long r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static <T> void swap(T[] x, int i, int j)\n    {\n        T t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(int[] x, int i, int j)\n    {\n        int t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(long[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            long temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(int[] x, int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    static int length(int a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int length(long a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int cou(boolean[] a)\n    {\n        int res = 0;\n        for (boolean b : a)\n        {\n            if (b) res++;\n        }\n        return res;\n    }\n\n    static int cou(String s, char c)\n    {\n        int res = 0;\n        for (char ci : s.toCharArray())\n        {\n            if (ci == c) res++;\n        }\n        return res;\n    }\n\n    static int countC2(char[][] a, char c)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == c) co++;\n        return co;\n    }\n\n    static int countI(int[] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int countI(int[][] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == key) co++;\n        return co;\n    }\n\n    static void fill(int[][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n\n    static void fill(long[][] a, long v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n    static void fill(int[][][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                for (int k = 0; k < a[0][0].length; k++)\n                    a[i][j][k] = v;\n    }\n\n    static int max(int... a)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i : a)\n        {\n            res = Math.max(res, i);\n        }\n        return res;\n    }\n\n    static long min(long... a)\n    {\n        long res = Long.MAX_VALUE;\n        for (long i : a)\n        {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n    static int max(int[][] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i[] : ar)\n            res = Math.max(res, max(i));\n        return res;\n    }\n\n    static int min(int... a)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i : a)\n        {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n\n    static int min(int[][] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i[] : ar)\n            res = Math.min(res, min(i));\n        return res;\n    }\n\n    static int sum(int[] a)\n    {\n        int cou = 0;\n        for (int i : a)\n            cou += i;\n        return cou;\n    }\n\n    static int abs(int a)\n    {\n        return Math.abs(a);\n    }\n\n    static class FastScanner\n    {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in)\n        {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    return reader.readLine();\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int[] nextIntArrayDec(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt() - 1;\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2Dec(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt() - 1;\n                }\n            }\n            return a;\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays2ar(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n            }\n        }\n\n        public void nextIntArrays2arDec(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n            }\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays3ar(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n            }\n        }\n\n        //複数の配列を受け取る\n        public void nextIntArrays3arDecLeft2(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n                c[i] = sc.nextInt();\n            }\n        }\n\n        public Integer[] nextIntegerArray(int n)\n        {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public char[] nextCharArray(int n)\n        {\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n\n        public char[][] nextCharArray2(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n\n        //スペースが入っている場合\n        public char[][] nextCharArray2s(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = nextLine().replace(\" \", \"\").toCharArray();\n            }\n            return a;\n        }\n\n        public char[][] nextWrapCharArray2(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        //スペースが入ってる時用\n        public char[][] nextWrapCharArray2s(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + nextLine().replace(\" \", \"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        public long[][] nextLongArray2(int h, int w)\n        {\n            long[][] a = new long[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(0, 1);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int v, int mask) {\n\t\tif (memo[v][mask] != -1)  return memo[v][mask];\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((mask & (1 << i)) != 0) continue;\n\t\t\tres = Math.min(res, graph[i][v] + tsp(i, mask | (1 << i)));\n\t\t}\n\t\treturn memo[v][mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static class Graph {\n        public final int V_NUM;\n        public final int[][] edges;\n\n        public Graph(int V_NUM) {\n            this.V_NUM = V_NUM;\n            this.edges = new int[V_NUM][V_NUM];\n            for (int i = 0; i < V_NUM; i++) {\n                Arrays.fill(this.edges[i], Integer.MAX_VALUE);\n            }\n        }\n\n        public void setDist(int src, int dest, int dist) {\n            this.edges[src][dest] = dist;\n        }\n\n    }\n\n    public static class TSP {\n        public final Graph g;\n        long[][] dp;\n\n        public TSP(Graph g) {\n            this.g = g;\n        }\n\n        public long solve() {\n            int N = g.V_NUM;\n            dp = new long[1 << N][N];\n            // init dp[][] with MAX\n            for (int i = 0; i < dp.length; i++) {\n                Arrays.fill(dp[i], -1);\n            }\n\n            long ret = recurse(0, 0);\n            return ret == Integer.MAX_VALUE ? -1 : ret;\n        }\n\n        private long recurse(int state, int v) {\n            int ALL = (1 << g.V_NUM) - 1;\n            if (dp[state][v] >= 0) {\n                return dp[state][v];\n            }\n            if (state == ALL && v == 0) {\n                dp[state][v] = 0;\n                return 0;\n            }\n            long res = Integer.MAX_VALUE;\n            for (int u = 0; u < g.V_NUM; u++) {\n                if ((state & (1 << u)) == 0) {\n                    res = Math.min(res, recurse(state | 1 << u, u) + g.edges[v][u]);\n                }\n            }\n            dp[state][v] = res;\n            return res;\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        int V = in.nextInt();\n        int E = in.nextInt();\n        Graph g = new Graph(V);\n        while (E > 0) {\n            int src = in.nextInt();\n            int dest = in.nextInt();\n            int dist = in.nextInt();\n            g.setDist(src, dest, dist);\n            E--;\n        }\n        System.out.println(new TSP(g).solve());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint V=sc.nextInt();//頂点数\n\t\t\tint E=sc.nextInt();//辺の数\n\t\t\tint s;//頂点\n\t\t\tint t;//頂点\n\t\t\tdouble[][] dist=new double[V+1][V+1];//辺の長さ(st距離)\n\t\t\tdouble[][] dp=new double[1<<V][V];\n\t\t\tdouble INF=1e100;\n\t\t\t\n\t\t\tfor(int i=0; i<V; i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\t\tdist[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<E; i++) {\n\t\t\t\ts=sc.nextInt();\n\t\t\t\tt=sc.nextInt();\n\t\t\t\tdist[s][t]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[1][0]=0;//頂点0からスタートだから\n\t\t\t\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {//現在いる頂点j\n\t\t\t\t\tif(dp[i][j]==INF) continue;\n\t\t\t\t\tfor(int k=0; k<V; k++) {//次の行き先頂点k\n\t\t\t\t\t\tif((1&i>>k)==1) continue;//すでに訪れてるとき\n\t\t\t\t\t\telse if(dist[j][k]==INF) continue;//辺がないとき\n\t\t\t\t\t\tint nexti = i| (1<<k);//bitごとのOR演算(今まで通ってきた頂点に次の頂点を足せる) \n\t\t\t\t\t\t//System.out.printf(\"nexti=%d\\n\", nexti);\n\t\t\t\t\t\tdouble nextd=dp[i][j]+dist[j][k];\n\t\t\t\t\t\tdp[nexti][k]=Math.min(dp[nexti][k], nextd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0; i<(1<<V); i++) {\n//\t\t\t\tfor(int j=0; j<V; j++) {\n//\t\t\t\t\tSystem.out.printf(\"dp[%d][%d]=%f\\n\", i, j, dp[i][j]);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint all=(1<<V)-1;//最後の全部bitたっている状態\n\t\t\tdouble ret=INF;\n\t\t\tfor(int i=0; i<V; i++) {//最後頂点0に戻る分の距離を足す\n\t\t\t\tif(dp[all][i]==INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(dist[i][0]==INF) continue;//頂点0にもどれないとき\n\t\t\t\tdouble temp = dp[all][i]+dist[i][0];\n\t\t\t\tret=Math.min(ret, temp);\n\t\t\t}\n\t\t\tif(ret==INF) {\n\t\t\t\tret=-1;\n\t\t\t}//bitが全部たたない\n\t\t\tSystem.out.println((int)ret);\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString line = br.readLine();\n\t\tint v = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tint e = Integer.parseInt(line.substring(line.indexOf(' ')+1));\n\n\t\tint[][] d = new int[v][v];\n\t\tfor (int i=0; i<v; i++) {\n\t\t\tArrays.fill(d[i],-1);\n\t\t}\n\n\t\tfor (int i=0; i<e; i++) {\n\t\t\tline = br.readLine();\n\t\t\tString[] str = line.split(\" \");\n\t\t\tint si = Integer.parseInt(str[0]);\n\t\t\tint ti = Integer.parseInt(str[1]);\n\t\t\tint di = Integer.parseInt(str[2]);\n\t\t\td[si][ti] = di;\n\t\t}\n\n\t\tint[][] dp = new int[1<<v][v];\n\t\tfor (int i=0; i<1<<v; i++)\n\t\t\tArrays.fill(dp[i],INF);\n\t\tdp[(1<<v)-1][0] = 0;\n\n\t\tfor (int i=(1<<v)-2; i>=0; i--) {\n\t\t\tfor (int j=0; j<v; j++) {\n\t\t\t\tfor (int k=0; k<v; k++) {\n\t\t\t\t\tif ((i>>k&1) == 0 && d[j][k] != -1)\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j],dp[i|1<<k][k]+d[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[0][0]>=INF?-1:dp[0][0]);\n\n\t\tbr.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Map.Entry;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tstatic int[][] dp;\n\tstatic int N;\n\tstatic int[][] graph;\n\tstatic int INF = 16000;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\t\n\t\tN = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\tfor(int i = 0; i < N; i++) Arrays.fill(graph[i], INF);\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tgraph[s][t] = d;\n\t\t}\n\t\t\n\t\tdp = new int[1 << N][N];\n\t\tfor(int i = 0; i < 1 << N; i++) Arrays.fill(dp[i], -1);\n\t\t//どこからスタートしても1周分のコストは変わらない\n\t\tdp[(1 << N) - 1][0] = 0;\n\t\t\n\t\tint ans = solve(0, 0);\n\t\tif(ans == INF)\n\t\t\tSystem.out.println(-1);\n\t\telse\n\t\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static int solve(int S, int v){\n\t\tif(dp[S][v] != -1) return dp[S][v];\n\t\t\n\t\tint d = INF;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(((S >> i) & 1) == 0 && graph[v][i] != INF){\n\t\t\t\td = Math.min(d, solve((S | 1 << i), i) + graph[v][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[S][v] = d;\n\t\t\n\t\treturn dp[S][v];\n\t}\n}\n\nclass Pair{\n\tint to;\n\tint dist;\n\tpublic Pair(int t, int d){\n\t\tto = t;\n\t\tdist = d;\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString line = br.readLine();\n\t\tint v = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tint e = Integer.parseInt(line.substring(line.indexOf(' ')+1));\n\t\tint[][] d = new int[v][v];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\tline = br.readLine();\n\t\t\tString[] str = line.split(\" \");\n\t\t\tint si = Integer.parseInt(str[0]);\n\t\t\tint ti = Integer.parseInt(str[1]);\n\t\t\tint di = Integer.parseInt(str[2]);\n\t\t\td[si][ti] = di;\n\t\t}\n\n\t\tint[][] dp = new int[1<<v][v];\n\t\tfor (int i=0; i<1<<v; i++)\n\t\t\tArrays.fill(dp[i],INF);\n\t\tdp[(1<<v)-1][0] = 0;\n\n\t\tfor (int i=(1<<v)-2; i>=0; i--) {\n\t\t\tfor (int j=0; j<v; j++) {\n\t\t\t\tfor (int k=0; k<v; k++) {\n\t\t\t\t\tif ((i>>k&1) == 0 && d[j][k] != 0)\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j],dp[i|1<<k][k]+d[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[0][0]>=INF?-1:dp[0][0]);\n\n\t\tbr.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(0, 1);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int v, int mask) {\n\t\tif (memo[v][mask] != -1)  return memo[v][mask];\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((mask & (1 << i)) != 0) continue;\n\t\t\tres = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));\n\t\t}\n\t\treturn memo[v][mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    int N;\n    ArrayList<ArrayList<Pair>> G = new ArrayList<>();\n    int[][] dp = new int[1 << 15][15];\n\n    int INF = 1 << 20;\n\n    void solve() throws IOException {\n        N = ni();\n        int M = ni();\n\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int s = ni();\n            int t = ni();\n            int d = ni();\n\n            G.get(s).add(new Pair(t, d));\n        }\n\n        for (int[] a : dp) Arrays.fill(a, -1);\n        int ans = rec(0, 0);\n        out.println(ans >= INF ? -1 : ans);\n    }\n\n    int rec(int S, int v) {\n        if (dp[S][v] >= 0) return dp[S][v];\n\n        if (S == (1 << N) - 1 && v == 0) {\n            return 0;\n        }\n\n        int ans = INF;\n        for (Pair p : G.get(v)) {\n            if (((S >> p.x) & 1) == 0) {\n                ans = Math.min(ans, rec(S | (1 << p.x), p.x) + p.y);\n            }\n        }\n        return dp[S][v] = ans;\n    }\n\n    public class Pair {\n        int x, y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    static int inf = Integer.MAX_VALUE;\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int v = Integer.parseInt(scan.next());\n        int e = Integer.parseInt(scan.next());\n        int[][] dist = new int[v][v];\n        for (int i = 0; i < v; i++) {\n            for (int j = 0; j < v; j++) {\n                dist[i][j] = inf;\n            }\n        }\n        for (int i = 0; i < e; i++) {\n            int s = Integer.parseInt(scan.next());\n            int t = Integer.parseInt(scan.next());\n            int d = Integer.parseInt(scan.next());\n            dist[s][t] = d;\n        }\n        scan.close();\n\n        int[][] dp = new int[1 << v][v];\n        for (int i = 0; i < (1 << v); i++) {\n            for (int j = 0; j < v; j++) {\n                dp[i][j] = inf;\n            }\n        }\n        dp[1][0] = 0;\n\n        for (int i = 0; i < (1 << v); i++) {\n            for (int j = 0; j < v; j++) {\n                if (dp[i][j] == inf) {\n                    continue;\n                }\n\n                for (int k = 0; k < v; k++) {\n                    if ((i & (1 << k)) != 0) {\n                        continue;\n                    }\n\n                    if (dist[j][k] == inf) {\n                        continue;\n                    }\n                    int nextI = i | (1 << k);\n                    dp[nextI][k] = Math.min(dp[nextI][k], dp[i][j] + dist[j][k]);\n                }\n            }\n        }\n\n        int ans = inf;\n        for (int i = 0; i < v; i++) {\n            if (dp[(1 << v) - 1][i] == inf) {\n                continue;\n            }\n            if (dist[i][0] == inf) {\n                continue;\n            }\n            int result = dp[(1 << v) - 1][i] + dist[i][0];\n            ans = Math.min(ans, result);\n        }\n\n        if (ans == inf) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tpublic static class Point {\n\t\tint i,h;\n\t\tpublic Point(int i, int h) {\n\t\t\tthis.i = i;\n\t\t\tthis.h = h;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint H = r.nextInt();\n\t\tint W = r.nextInt();\n\t\tboolean[][] map = new boolean[H][W];\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tmap[i][j] = (r.nextInt() == 0);\n\t\t\t}\n\t\t}\n\t\tint[][] height = new int[H][W];\n\t\tfor(int i=0; i<W; i++) {\n\t\t\tif(map[0][i]) height[0][i] = 1;\n\t\t\telse height[0][i] = 0;\n\t\t}\n\t\tfor(int i=1; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tif(!map[i][j]) height[i][j] = 0;\n\t\t\t\telse height[i][j] = height[i-1][j]+1;\n\t\t\t}\n\t\t}\n\t\tint maxRect = 0;\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tDeque<Point> q = new ArrayDeque<Point>();\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tif(q.isEmpty() || q.getLast().h < height[i][j]) {\n\t\t\t\t\tq.addLast(new Point(j, height[i][j]));\n\t\t\t\t} else if(q.getLast().h == height[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tPoint p = q.pollLast();\n\t\t\t\t\t\tmaxRect = Math.max(maxRect, p.h * (j - p.i));\n\t\t\t\t\t\tif(q.isEmpty()) {\n\t\t\t\t\t\t\tq.addLast(new Point(p.i, height[i][j]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(q.getLast().h == height[i][j]) break;\n\t\t\t\t\t\tif(q.getLast().h < height[i][j]) {\n\t\t\t\t\t\t\tq.addLast(new Point(p.i, height[i][j]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tPoint p = q.pollLast();\n\t\t\t\tmaxRect = Math.max(maxRect, p.h * (W - p.i));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxRect);\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tint VISITED_ALL;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tVISITED_ALL = ((1<<n) -1);\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t    int res =  tsp(1, 0);\n\t    System.out.println(res == INF ? -1 : res);\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.containsKey(mask) && dp.get(mask).containsKey(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if((mask & (1 << i)) != 0) continue;\n\t\t    int tmp = graph[v][i] + tsp(mask | (1 << i), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.containsKey(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\t\n\tstatic int VISITED_ALL = (1<<n) -1;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int[] a;\n  static int infi = 2000000;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int v, e, i, j, k;\n    int[][] d, dp;\n\n    v = sc.nextInt(); e = sc.nextInt();\n    d = new int[v][v]; a = new int[v + 1];\n    for(i = 0;i < v;i++)for(j = 0;j < v;j++)d[i][j] = infi;\n    for(;e-- > 0;)d[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n    a[0] = 1;\n    for(i = 0;i < v;i++)a[i + 1] = a[i] * 2;\n    dp = new int[a[v]][v];\n    for(i = 0;i < a[v];i++)for(j = 0;j < v;j++)dp[i][j] = infi;\n    dp[a[v] - 1][0] = 0;\n\n    for(i = a[v] - 1;i >= 0;i--)\n      for(j = 0;j < v;j++)if(dp[i][j] != infi)\n        for(k = 0;k < v;k++)if(j != k && isin(i, k) && d[k][j] < infi){\n          if(dp[i][j] + d[k][j] < dp[i - a[j]][k])\n            dp[i - a[j]][k] = dp[i][j] + d[k][j];\n        }\n    out.println(dp[0][0]);\n    \n    sc.close();\n  }\n  private static boolean isin(int s, int v){\n    return (v == 0 || ((s % a[v + 1]) / a[v]) == 1);\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.*;\npublic class Main {\n\tstatic final int INF = (int)1e9 + 7;\n\tint V,E;\n\tint[][] cost;\n\tint[][] dp;\n\tint start;\n\tpublic int dfs(int v,int now){\n\t\tif(v == (1 << V) - 1){\n\t\t\tif(cost[now][start] == -1)return INF;\n\t\t\treturn cost[now][start];\n\t\t}\n\t\tif(dp[v][now] != -1)return dp[v][now];\n\t\tint ret = INF;\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tif(((v >> i) & 1) == 1)continue;\n\t\t\tif(cost[now][i] == -1)continue;\n\t\t\tret = Math.min(ret,dfs(v | (1 << i),i) + cost[now][i]);\n\t\t}\n\t\treturn dp[v][now] = ret;\n\t}\n\t\n    public void solve() {\n\t\tV = nextInt();\n\t\tE = nextInt();\n\t\t\n\t\tcost = new int[V][V];\n\t\tdp = new int[1 << V][V + 1];\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tArrays.fill(cost[i],-1);\n\t\t}\n\t\tfor(int i = 0;i < E;i++){\n\t\t\tint s = nextInt();\n\t\t\tint t = nextInt();\n\t\t\tint d = nextInt();\n\t\t\tcost[s][t] = d;\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int k = 0;k < V;k++){\n\t\t\tfor(int i = 0;i < 1 << V;i++){\n\t\t\t\tfor(int j = 0;j < V + 1;j++){\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = k;\n\t\t\tans = Math.min(ans,dfs(1 << k,k));\n\t\t}\n\t\tout.println(ans == INF ? - 1 : ans);\n    }\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\t\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.containsKey(mask) && dp.get(mask).containsKey(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if(mask & (1 << i) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.containsKey(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph, memo;\n\n\tvoid run() {\n\t\tN = sc.nextInt(); // edge number\n\t\tM = sc.nextInt(); // vertex number\n\t\tgraph = new int[N][N];\n\t\tmemo = new int[N][1 << N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t\tArrays.fill(memo[i], -1);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\tint res = tsp(1, 0);\n\t\tSystem.out.println(res == INF ? -1 : res);\n\t}\n\n\tint tsp(int mask, int pos) {\n\t   if(mask==VISITED_ALL){\n\t\treturn dist[pos][0];\n\t}\n\tif(dp[mask][pos]!=-1){\n\t   return dp[mask][pos];\n\t}\n\n\t//Now from current node, we will try to go to every other node and take the min ans\n\tint ans = INT_MAX;\n\n\t//Visit all the unvisited cities and take the best route\n\tfor(int city=0;city<n;city++){\n\n\t\tif((mask&(1<<city))==0){\n\n\t\t\tint newAns = dist[pos][city] + tsp( mask|(1<<city), city);\n\t\t\tans = min(ans, newAns);\n\t\t}\n\n\t}\n\t\n\treturn dp[mask][pos] = ans;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint vn = scan.nextInt();\n\t\tint en = scan.nextInt();\n\n\t\tTravel t = new Travel(vn, en);\n\n\t\tfor (int i = 0; i < en; i++)\n\t\t\tt.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\n\t\tpwriter.println(t.getDistance());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Travel {\n\tint[][] dist;\n\tint goal;\n\tint[] ix;\n\tint[][] hist;\n\n\tpublic Travel(int vn, int en) {\n\t\tdist = new int[vn][vn];\n\t\tfor (int st = 0; st < vn; st++)\n\t\t\tfor (int ed = 0; ed < vn; ed++)\n\t\t\t\tdist[st][ed] = -1;\n\n\t\t// index number for each vertices\n\t\tix = new int[vn];\n\t\tix[1] = 1;\n\t\tfor (int i = 2; i < vn; i++)\n\t\t\tix[i] = ix[i - 1] << 1;\n\t\t// all vertices is reached\n\t\tgoal = (ix[vn - 1] << 1) - 1;\n\n\t\thist = new int[vn][goal + 1];\n\t\tfor (int i = 0; i < vn; i++)\n\t\t\tfor (int j = 0; j < goal + 1; j++)\n\t\t\t\thist[i][j] = Integer.MAX_VALUE;\n\t}\n\n\tpublic int getDistance() {\n\t\treturn minDist(0, 0);\n\t}\n\n\tprivate int minDist(int st, int passed) {\n\t\t// st is start vertices, passed is sum of reached vertices index\n\t\tif (passed == goal)\n\t\t\tif (dist[st][0] >= 0)\n\t\t\t\treturn dist[st][0];\n\t\t\telse\n\t\t\t\treturn -1;\n\n\t\tif (hist[st][passed] < Integer.MAX_VALUE)\n\t\t\treturn hist[st][passed];\n\n\t\tint min = -1;\n\t\tfor (int i = 1; i < ix.length; i++) {\n\t\t\tif ((passed & ix[i]) != 0 || dist[st][i] == -1)\n\t\t\t\tcontinue;\n\t\t\tint d = minDist(i, (passed | ix[i]));\n\t\t\tif (d <= 0)\n\t\t\t\tcontinue;\n\t\t\td += dist[st][i];\n\t\t\tif (d >= 0 && (d < min || min == -1))\n\t\t\t\tmin = d;\n\t\t}\n\t\n\t\thist[st][passed] = min;\n\t\treturn min;\n\t}\n\n\tpublic void addRoot(int s, int t, int d) {\n\t\tdist[s][t] = d;\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint V=sc.nextInt();//頂点数\n\t\t\tint E=sc.nextInt();//辺の数\n\t\t\tint s;//頂点\n\t\t\tint t;//頂点\n\t\t\tdouble[][] dist=new double[V+1][V+1];//辺の長さ(st距離)\n\t\t\tdouble[][] dp=new double[1<<V][V];\n\t\t\t\n\t\t\tfor(int i=0; i<E; i++) {\n\t\t\t\ts=sc.nextInt();\n\t\t\t\tt=sc.nextInt();\n\t\t\t\tdist[s][t]=sc.nextInt();\n\t\t\t}\n\t\t\tdouble INF=1e100;\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[1][0]=0;//頂点0からスタートだから\n\t\t\t\n\t\t\tfor(int i=0; i<(1<<V); i++) {\n\t\t\t\tfor(int j=0; j<V; j++) {//現在いる頂点j\n\t\t\t\t\tif(dp[i][j]==INF) continue;\n\t\t\t\t\tfor(int k=0; k<V; k++) {//次の行き先頂点k\n\t\t\t\t\t\tif((1&i>>k)==1) continue;//すでに訪れてるとき\n\t\t\t\t\t\telse if(dist[j][k]==0) continue;//辺がないとき\n\t\t\t\t\t\tint nexti = i| (1<<k);//bitごとのOR演算(今まで通ってきた頂点に次の頂点を足せる) \n\t\t\t\t\t\t//System.out.printf(\"nexti=%d\\n\", nexti);\n\t\t\t\t\t\tdouble nextd=dp[i][j]+dist[j][k];\n\t\t\t\t\t\tdp[nexti][k]=Math.min(dp[nexti][k], nextd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0; i<(1<<V); i++) {\n//\t\t\t\tfor(int j=0; j<V; j++) {\n//\t\t\t\t\tSystem.out.printf(\"dp[%d][%d]=%f\\n\", i, j, dp[i][j]);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint all=(1<<V)-1;//最後の全部bitたっている状態\n\t\t\tdouble ret=INF;\n\t\t\tfor(int i=0; i<V; i++) {//最後頂点0に戻る分の距離を足す\n\t\t\t\tif(dp[all][i]==INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(dist[i][0]==0) continue;//頂点0にもどれないとき\n\t\t\t\tdouble temp = dp[all][i]+dist[i][0];\n\t\t\t\tret=Math.min(ret, temp);\n\t\t\t}\n\t\t\tif(ret==INF) {\n\t\t\t\tret=-1;\n\t\t\t}//bitが全部たたない\n\t\t\tSystem.out.println((int)ret);\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint N, M;\n\tint INF = Integer.MAX_VALUE / 2;\n\tint[][] graph;\n\tMap<Integer, Map<Integer, Integer>> dp = new HashMap<>();\n\n\tvoid run() {\n\t\tN = sc.nextInt(); \n\t\tM = sc.nextInt();\n\t\tgraph = new int[N][N];\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tArrays.fill(graph[i], INF);\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\t\t\tgraph[s][t] = cost;\n\t\t}\n\t\t\n\t    int res =  tsp(1, 0);\n\t    System.out.println(res == INF ? -1 : res);\n\t}\n\t\n\t\n\n\tint tsp(int mask, int v) {\n\t\tif (dp.containsKey(mask) && dp.get(mask).containsKey(v))  return dp.get(mask).get(v);\n\t\t\n\t\tif (mask == (1 << N) - 1) return graph[v][0];\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t    if((mask & (1 << i)) != 0) continue;\n\t\t    int tmp = graph[v][0] + tsp(mask | (1 << N), i);\n\t\t    if(tmp < res) res = tmp;\n\t\t}\n\t\t\n\t\tif(!dp.containsKey(mask)){\n\t\t   dp.put(mask, new HashMap<>());\n\t\t}\n\t\t\n\t\tdp.get(mask).put(v,res);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 20;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic int n, e;\n\tstatic int[][] dest, dp;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tn = in.nextInt(); e = in.nextInt();\n\t\t\tdest = new int[n][n];\n\t\t\tdp = new int[1 << n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dest[i], INF);\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt(), d = in.nextInt();\n\t\t\t\tdest[s][t] = d;\n\t\t\t}\n\n\t\t\tint ans = rec(0, 0);\n\t\t\tout.println(ans == INF ? -1 : ans);\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param S:すでに訪問した頂点の集合\n\t\t * @param v:現在の頂点\n\t\t *\n\t\t * */\n\t\tint rec(int S, int v) {\n\n\t\t\t// すでに同じ状態になったことがある場合\n\t\t\tif (dp[S][v] >= 0) {\n\t\t\t\treturn dp[S][v];\n\t\t\t}\n\n\t\t\t// すべての頂点を訪問して、最初の位置0に戻ってきた場合\n\t\t\tif (S == (1 << n) -1 && v == 0) {\n\t\t\t\treturn dp[S][v] = 0;\n\t\t\t}\n\n\t\t\t// すべての頂点を訪問したが、最初の位置0にいない場合はINFになる\n\t\t\tint res = INF;\n\n\t\t\t// 次に訪問する頂点 u\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((S >> u) & 1) == 0 && dest[v][u] != INF) {\n\t\t\t\t\tres = Math.min(res, rec(S | (1 << u), u) + dest[v][u]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dp[S][v] = res;\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n\tstatic void print(int[][] dp) {\n\t\tint n = dp.length;\n\t\tint m = dp[0].length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\tSystem.out.print(\"\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.*;\npublic class Main {\n\tstatic final int INF = (int)1e9 + 7;\n\tint V,E;\n\tint[][] cost;\n\tint[][] dp;\n\t\n\tpublic int dfs(int v,int now){\n\t\t\n\t\tif(v == (1 << V) - 1){\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0;i < V;i++){\n\t\t\t\tif(cost[now][i] == -1)continue;\n\t\t\t\tmin = Math.min(cost[now][i],min);\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\t\tif(dp[v][now] != -1)return dp[v][now];\n\t\tint ret = INF;\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tif(((v >> i) & 1) == 1)continue;\n\t\t\tif(cost[now][i] == -1)continue;\n\t\t\tret = Math.min(ret,dfs(v | (1 << i),i) + cost[now][i]);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn dp[v][now] = ret;\n\t\t\n\t}\n\t\n    public void solve() {\n\t\tV = nextInt();\n\t\tE = nextInt();\n\t\t\n\t\tcost = new int[V][V];\n\t\tdp = new int[1 << V][V + 1];\n\t\tfor(int i = 0;i < 1 << V;i++){\n\t\t\tfor(int j = 0;j < V + 1;j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tArrays.fill(cost[i],-1);\n\t\t}\n\t\tfor(int i = 0;i < E;i++){\n\t\t\tint s = nextInt();\n\t\t\tint t = nextInt();\n\t\t\tint d = nextInt();\n\t\t\tcost[s][t] = d;\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tans = Math.min(ans,dfs(0,i));\n\t\t}\n\t\tout.println(ans == INF ? - 1 : ans);\n    }\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\t\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PriorityQueue<T> where T : IComparable<T> {\n    private List<T> _buf = new List<T>();\n    private IComparer<T> _comp;\n\n    private void Swap(int a, int b) {\n        T t = _buf[a];\n        _buf[a] = _buf[b];\n        _buf[b] = t;\n    }\n\n    private int Compare(T a, T b) {\n        if (_comp == null) return a.CompareTo(b);\n        return _comp.Compare(a, b);\n    }\n\n    public int Count { get { return _buf.Count; } }\n\n    public PriorityQueue() {\n    }\n\n    public PriorityQueue(IComparer<T> comp) {\n        _comp = comp;\n    }\n\n    public void Enqueue(T x) {\n        _buf.Add(x);\n\n        // shiftup\n        int p = Count-1;\n        while (p > 0) {\n            int parent = (p - 1) / 2;\n            if (Compare(_buf[parent], _buf[p]) <= 0)\n                break;\n            Swap(parent, p);\n            p = parent;\n        }\n    }\n\n    public T Dequeue() {\n        if (Count == 0)\n            throw new IndexOutOfRangeException();\n\n        T ret = _buf[0];\n        _buf[0] = _buf[Count-1];\n        _buf.RemoveAt(Count-1);\n\n        // shiftdown\n        int p = 0;\n        while (p < Count) {\n            int c = p * 2 + 1; // ?????????\n            if (c >= Count) break;\n\n            if (c+1 < Count) { // c+1 ????????????\n                if (Compare(_buf[c+1], _buf[c]) < 0) { // ??????????????????????°???????\n                    c++;\n                }\n            }\n\n            if (Compare(_buf[p], _buf[c]) <= 0)\n                break;\n            Swap(p, c);\n            p = c;\n        }\n\n        return ret;\n    }\n}\n\nclass Program {\n    static string ReadLine() { return Console.ReadLine(); }\n    static int ReadInt() { return int.Parse(ReadLine()); }\n    static int[] ReadInts() { return ReadLine().Split().Select(int.Parse).ToArray(); }\n    static string[] ReadStrings() { return ReadLine().Split(); }\n\n    struct D : IComparable<D> {\n        public int node;\n        public int visited;\n        public int cost;\n        public bool finished; // ??¨??????note????¨??????????\n\n        public int CompareTo(D o) { return cost - o.cost; }\n    }\n\n    static int Calc_1(int start, int v, int[,] adj) {\n        var q = new PriorityQueue<D>();\n        q.Enqueue(new D { node = start, visited = (1 << start), cost = 0, finished = false });\n\n        var memo = new int[v, (1 << v)];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < (1 << v); j++)\n                memo[i, j] = int.MaxValue;\n\n        while (q.Count > 0) {\n            D d = q.Dequeue();\n\n            if (d.finished) return d.cost;\n\n            if (d.visited == (1 << v)-1) {\n                // ??¨???????????????????¨???????????????§???start ?????????\n                if (adj[d.node, start] != -1) {\n                    int cost = d.cost + adj[d.node, start];\n                    q.Enqueue(new D { node = start, visited = d.visited, cost = cost, finished = true });\n                }\n                continue;\n            }\n\n            if (memo[d.node, d.visited] < d.cost) continue;\n            memo[d.node, d.visited] = d.cost;\n\n            for (int i = 0; i < v; i++) {\n                if (adj[d.node, i] == -1) continue; // ????????????\n\n                if ((d.visited & (1 << i)) > 0) continue; // ?¨??????????\n\n                int vv = d.visited | (1 << i);\n                int cost = d.cost + adj[d.node, i];\n                q.Enqueue(new D { node = i, visited = vv, cost = cost, finished = d.finished });\n            }\n        }\n        return int.MaxValue;\n    }\n\n    static int Calc(int v, int[,] adj) {\n        for (int i = 0; i < v; i++) {\n            int ret = Calc_1(i, v, adj);\n            if (ret != int.MaxValue)\n                return ret;\n        }\n        return -1;\n    }\n\n    static void Main() {\n        var ve = ReadInts();\n        int v = ve[0], e = ve[1];\n\n        var adj = new int[v, v];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < v; j++)\n                adj[i, j] = -1;\n\n        for (int i = 0; i < e; i++) {\n            var std = ReadInts();\n            adj[std[0], std[1]] = std[2];\n        }\n        Console.WriteLine(Calc(v, adj));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly int INFTY = int.MaxValue / 2;\n        static int n, all;\n        static int[,] map, dp;\n        static int[] bitIdx;\n\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int V = input[0];\n            int E = input[1];\n\n            n = V;\n            map = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    map[i, j] = INFTY;\n                }\n            }\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                map[input[0], input[1]] = input[2];\n            }\n\n            bitIdx = new int[n];\n            bitIdx[1] = 1;\n            for (int i = 2; i < n; i++) bitIdx[i] = bitIdx[i - 1] << 1;\n\n            all = (bitIdx[n - 1] << 1) - 1;\n\n            dp = new int[n, all + 1];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j <= all; j++)\n                {\n                    dp[i, j] = INFTY;\n                }\n            }\n\n            int res = TSP(0, 0);\n            Console.WriteLine(res != INFTY ? res : -1);\n        }\n\n        static int TSP(int s, int mask)\n        {\n            if (mask == all) return map[s, 0];\n            if (dp[s, mask] < INFTY) return dp[s, mask];\n\n            int min = INFTY;\n            for (int i = 1; i < n; i++)\n            {\n                if ((mask & bitIdx[i]) != 0 || map[s, i] == INFTY) continue;\n\n                int d = TSP(i, (mask | bitIdx[i]));\n\n                if (d == INFTY) continue;\n\n                min = Math.Min(min, d + map[s, i]);\n            }\n            dp[s, mask] = min;\n            return min;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Aizu\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar firstLine = ReadLine().Split(' ').Select(value => int.Parse(value)).ToArray();\n\t\t\tvar v = firstLine[0];\n\t\t\tvar e = firstLine[1];\n\n\t\t\tvar pathes = new Dictionary<int, Dictionary<int, int>>();\n\n\t\t\tfor(var i = 0; i < e; i++)\n\t\t\t{\n\t\t\t\tvar line = ReadLine().Split(' ').Select(value => int.Parse(value)).ToArray();\n\n\t\t\t\tif(!pathes.ContainsKey(line[0]))\n\t\t\t\t{\n\t\t\t\t\tpathes.Add(line[0], new Dictionary<int, int>());\n\t\t\t\t}\n\t\t\t\tpathes[line[0]].Add(line[1], line[2]);\n\t\t\t}\n\n\t\t\tvar costs = new long[(1 << v) + 1, v + 1];\n\t\t\tfor(var i = 0; i <= (1 << v); i++)\n\t\t\t{\n\t\t\t\tfor(var j = 0; j <= v; j++)\n\t\t\t\t{\n\t\t\t\t\tcosts[i, j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong min = Dp(costs, pathes, (1 << v) - 1, 0, 0, v);\n\n\t\t\tWriteLine(min < int.MaxValue ? min : -1);\n\t\t}\n\n\t\tprivate static long Dp(long[,] costs, Dictionary<int, Dictionary<int, int>> pathes, int bit, int node, int goal, int v)\n\t\t{\n\t\t\tif(costs[bit, node] != -1)\n\t\t\t{\n\t\t\t\treturn costs[bit, node];\n\t\t\t}\n\n\t\t\tif(bit == (1 << node))\n\t\t\t{\n\t\t\t\treturn costs[bit, node] = 0;\n\t\t\t}\n\n\t\t\tlong min = int.MaxValue;\n\t\t\tint previewBit = bit;\n\t\t\tif (node != goal)\n\t\t\t{\n\t\t\t\tpreviewBit &= ~(1 << node);\n\t\t\t}\n\t\t\tfor(var i = 0; i < v; i++)\n\t\t\t{\n\t\t\t\tif((previewBit & (1 << i)) == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(!pathes.ContainsKey(node) || !pathes[node].ContainsKey(i))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(i == goal && previewBit != (1 << goal))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmin = Min(min, Dp(costs, pathes, previewBit, i, goal, v) + pathes[node][i]);\n\t\t\t}\n\n\t\t\treturn costs[bit, node] = min;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace DPL2_A\n{\n    class Program\n    {\n        const int INF = 1 << 30;\n        const int MAX = 15;\n        static int ans = INF;\n        static int n;\n        static int[,] d = new int[MAX, MAX];\n        static int[,] dp = new int[1 << MAX, MAX];\n        static void solve(int f)\n        {\n            for (int i = 0; i < 1 << n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dp[i, j] = INF;\n                }\n            }\n            //goal(f) = 0 \n            dp[(1 << n) - 1, 0] = 0;\n\n            for (int S = (1 << n) - 2; S >= 0; S--)\n            {\n                for (int v = 0; v < n; v++)\n                {\n                    for (int u = 0; u < n; u++)\n                    {\n                        if ((S >> u & 1) == 0 && d[v,u] != INF)\n                        {\n                            dp[S, v] = Math.Min(dp[S, v], dp[S | 1 << u, u] + d[v, u]);\n                        }\n                    }\n                }\n            }\n            ans = ans > dp[0, 0] ? dp[0,0] : ans;\n        }\n        static void Main(string[] args)\n        {\n            var t = scan;\n            n = t[0];\n            int e = t[1];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    d[i, j] = INF;\n                }\n            }\n            for (int i = 0; i < e; i++)\n            {\n                var k = scan;\n                d[k[0], k[1]] = k[2];\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                solve(i);\n            }\n            \n\n            Console.WriteLine(ans == INF ? -1 : ans);\n        }\n\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n\nclass PriorityQueue<T> where T : IComparable<T> {\n    private List<T> _buf = new List<T>();\n    private IComparer<T> _comp;\n\n    private void Swap(int a, int b) {\n        T t = _buf[a];\n        _buf[a] = _buf[b];\n        _buf[b] = t;\n    }\n\n    private int Compare(T a, T b) {\n        if (_comp == null) return a.CompareTo(b);\n        return _comp.Compare(a, b);\n    }\n\n    public int Count { get { return _buf.Count; } }\n\n    public PriorityQueue() {\n    }\n\n    public PriorityQueue(IComparer<T> comp) {\n        _comp = comp;\n    }\n\n    public void Enqueue(T x) {\n        _buf.Add(x);\n\n        // shiftup\n        int p = Count-1;\n        while (p > 0) {\n            int parent = (p - 1) / 2;\n            if (Compare(_buf[parent], _buf[p]) <= 0)\n                break;\n            Swap(parent, p);\n            p = parent;\n        }\n    }\n\n    public T Dequeue() {\n        if (Count == 0)\n            throw new IndexOutOfRangeException();\n\n        T ret = _buf[0];\n        _buf[0] = _buf[Count-1];\n        _buf.RemoveAt(Count-1);\n\n        // shiftdown\n        int p = 0;\n        while (p < Count) {\n            int c = p * 2 + 1; // ?????????\n            if (c >= Count) break;\n\n            if (c+1 < Count) { // c+1 ????????????\n                if (Compare(_buf[c+1], _buf[c]) < 0) { // ??????????????????????°???????\n                    c++;\n                }\n            }\n\n            if (Compare(_buf[p], _buf[c]) <= 0)\n                break;\n            Swap(p, c);\n            p = c;\n        }\n\n        return ret;\n    }\n}\n\nclass Program {\n    static string ReadLine() { return Console.ReadLine(); }\n    static int ReadInt() { return int.Parse(ReadLine()); }\n    static int[] ReadInts() { return ReadLine().Split().Select(int.Parse).ToArray(); }\n    static string[] ReadStrings() { return ReadLine().Split(); }\n\n    struct D : IComparable<D> {\n        public int node;\n        public int visited;\n        public int cost;\n        public bool finished; // ??¨??????note????¨??????????\n\n        public int CompareTo(D o) { return cost - o.cost; }\n    }\n\n    static int Calc_1(int start, int v, int[,] adj) {\n        var q = new PriorityQueue<D>();\n        q.Enqueue(new D { node = start, visited = (1 << start), cost = 0, finished = false });\n        while (q.Count > 0) {\n            D d = q.Dequeue();\n\n            if (d.finished) return d.cost;\n\n            if (d.visited == (1 << v)-1) {\n                // ??¨???????????????????¨???????????????§???start ?????????\n                if (adj[d.node, start] != -1) {\n                    int cost = d.cost + adj[d.node, start];\n                    q.Enqueue(new D { node = start, visited = d.visited, cost = cost, finished = true });\n                }\n                continue;\n            }\n\n            for (int i = 0; i < v; i++) {\n                if (adj[d.node, i] == -1) continue; // ????????????\n\n                if ((d.node & (1 << i)) > 0) continue; // ?¨??????????\n\n                int vv = d.visited | (1 << i);\n                int cost = d.cost + adj[d.node, i];\n                q.Enqueue(new D { node = i, visited = vv, cost = cost, finished = d.finished });\n            }\n        }\n        return int.MaxValue;\n    }\n\n    static int Calc(int v, int[,] adj) {\n        int ans = int.MaxValue;\n        for (int i = 0; i < v; i++) {\n            ans = Math.Min(ans, Calc_1(i, v, adj));\n        }\n        return ans == int.MaxValue ? -1 : ans;\n    }\n\n    static void Main() {\n        var ve = ReadInts();\n        int v = ve[0], e = ve[1];\n\n        var adj = new int[v, v];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < v; j++)\n                adj[i, j] = -1;\n\n        for (int i = 0; i < e; i++) {\n            var std = ReadInts();\n            adj[std[0], std[1]] = std[2];\n        }\n        Console.WriteLine(Calc(v, adj));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly int INFTY = int.MaxValue / 2;\n        static int n, all;\n        static int[,] map, dp;\n        static int[] bitIdx;\n\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int V = input[0];\n            int E = input[1];\n\n            n = V;\n            map = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    map[i, j] = INFTY;\n                }\n            }\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                map[input[0], input[1]] = input[2];\n            }\n\n            bitIdx = new int[n];\n            bitIdx[1] = 1;\n            for (int i = 2; i < n; i++) bitIdx[i] = bitIdx[i - 1] << 1;\n\n            all = (bitIdx[n - 1] << 1) - 1;\n\n            dp = new int[n, all + 1];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j <= all; j++)\n                {\n                    dp[i, j] = INFTY;\n                }\n            }\n\n            int res = TSP(0, 0);\n            Console.WriteLine(res != INFTY ? res : -1);\n        }\n\n        static int TSP(int s, int mask)\n        {\n            if (mask == all) return map[s, 0];\n            if (dp[s, mask] < INFTY) return dp[s, mask];\n\n            int min = INFTY;\n            for (int i = 1; i < n; i++)\n            {\n                if ((mask & bitIdx[i]) != 0 || map[s, i] == INFTY) continue;\n\n                int d = TSP(i, (mask | bitIdx[i]));\n\n                if (d == INFTY) continue;\n\n                d += map[s, i];\n\n                if (d < min) min = d;\n            }\n            dp[s, mask] = min;\n            return min;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Library;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramA {\n        static void Main () {\n            int V = NextInt, E = NextInt;\n            var matrix = Enumerable.Range(0, V).Select(_ => Enumerable.Repeat(int.MaxValue >> 2, V).ToArray()).ToArray();\n            var dp = Enumerable.Range(0, 1 << V).Select(_ => Enumerable.Repeat(int.MaxValue >> 2, V).ToArray()).ToArray();\n            dp[1][0] = 0;\n\n            for (int i = 0; i < E; i++)\n            {\n                int s = NextInt, t = NextInt, d = NextInt;\n                matrix[s][t] = d;\n            }\n\n            for (int i = 2; i < (1 << V); i++)\n            {\n                for (int j = 0; j < V; j++)\n                {\n                    if ((i & (1 << j)) > 0)\n                    {\n                        for (int k = 0; k < V; k++)\n                        {\n                            dp[i][j] = Math.Min(dp[i^(1 << j)][k] + matrix[k][j], dp[i][j]);\n                        }\n                    }\n                }\n            }\n\n            int result = Enumerable.Range(0, V).Min(i => dp[(1 << V) - 1][i] + matrix[i][0]);\n            if (result >= int.MaxValue >> 2) System.Console.WriteLine(-1);\n            else System.Console.WriteLine(result);\n        }\n    }\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n\nnamespace Library {\n    \n    class Modular {\n        public const int mod = 1000000007;\n        public readonly long value;\n        public Modular (long value) { this.value = value; }\n        public static implicit operator Modular (long a) {\n            var m = a % mod;\n            return new Modular ((m < 0) ? m + mod : m);\n        }\n        public static Modular operator + (Modular a, Modular b) {\n            return a.value + b.value;\n        }\n        public static Modular operator - (Modular a, Modular b) {\n            return a.value - b.value;\n        }\n        public static Modular operator * (Modular a, Modular b) {\n            return a.value * b.value;\n        }\n        public static Modular Pow (Modular a, int n) {\n            switch (n) {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    var p = Pow (a, n / 2);\n                    return p * p * Pow (a, n % 2);\n            }\n        }\n        public static Modular operator / (Modular a, Modular b) {\n            return a * Pow (b, mod - 2);\n        }\n        private static readonly List<int> facs = new List<int> { 1 };\n        private static Modular Fac (int n) {\n            for (int i = facs.Count; i <= n; ++i) {\n                facs.Add ((int) (Math.BigMul (facs.Last (), i) % mod));\n            }\n            return facs[n];\n        }\n        public static Modular Ncr (int n, int r) {\n            return (n < r) ? 0 :\n                (n == r) ? 1 :\n                Fac (n) / (Fac (r) * Fac (n - r));\n        }\n        public static explicit operator int (Modular a) {\n            return (int) a.value;\n        }\n    }\n\n}\nnamespace Library {\n    class MyMath {\n        public static long Gcd (long a, long b) {\n            return b == 0 ? a : Gcd (b, a % b);\n        }\n\n        public static long Sqrt (long n) {\n            if (n < 0) return 0;\n            long a = 0, tmp = 0, b = 0;\n            for (int i = 62; i >= 0; i -= 2) {\n                tmp = (b << 1) + 1 <= (n >> i) ? 1 : 0;\n                a = a << 1 | tmp;\n                n -= (((b << 1) + 1) * tmp) << i;\n                b = (b << 1) + tmp + tmp;\n            }\n            return a;\n        }\n\n        public static long Nck (int n, int k) {\n            if (k == 0) return 1;\n            if (n == 0) return 0;\n            return n * Nck (n - 1, k - 1) / k;\n        }\n    }\n}\n\nnamespace Library {\n        public class PriorityQueue<T> {\n\n        readonly List<T> _heap = new List<T> ();\n        readonly Comparison<T> _comparison;\n\n        public PriorityQueue (Comparison<T> comparison) {\n            _comparison = comparison;\n        }\n\n        public PriorityQueue () : this (Comparer<T>.Default.Compare) { }\n\n        public PriorityQueue (IComparer<T> comparer) : this (comparer.Compare) { }\n\n        public void Enqueue (T item) {\n            _heap.Add (item);\n\n            int childID = _heap.Count - 1;\n            int parentID = (childID - 1) / 2;\n\n            while (childID > 0 && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                childID = parentID;\n                parentID = (parentID - 1) / 2;\n            }\n        }\n\n        public T Dequeue () {\n            var first = _heap.First ();\n            _heap[0] = _heap.Last ();\n            _heap.RemoveAt (_heap.Count - 1);\n\n            int parentID = 0;\n            int childID = parentID * 2 + 2;\n            if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n\n            while (childID < _heap.Count && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                parentID = childID;\n                childID = parentID * 2 + 2;\n                if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n            }\n\n            return first;\n        }\n\n        void Swap (int parent, int child) {\n            var tmp = _heap[parent];\n            _heap[parent] = _heap[child];\n            _heap[child] = tmp;\n        }\n\n        public T Peek () { return _heap[0]; }\n        public int Count => _heap.Count;\n        public bool Any () { return _heap.Any (); }\n        public List<T> Data => _heap;\n    }\n}\n\nnamespace Library {\n    \n    public class UnionFind {\n        public int[] Parents { get; set; }\n        public UnionFind (int size) {\n            Parents = Enumerable.Repeat (-1, size).ToArray ();\n        }\n\n        public int Find (int num) {\n            if (Parents[num] < 0) return num;\n\n            Parents[num] = Find (Parents[num]);\n            return Parents[num];\n        }\n\n        public int Size (int num) {\n            return -Parents[Find (num)];\n        }\n\n        public bool Same (int a, int b) {\n            return Find (a) == Find (b);\n        }\n\n        public void Unite (int a, int b) {\n            int x = Find (a), y = Find (b);\n\n            if (Size (x) > Size (y)) {\n                Parents[x] += Parents[y];\n                Parents[y] = x;\n            } else {\n                Parents[y] += Parents[x];\n                Parents[x] = y;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;using static System.Console;using System.Collections.Generic;using System.Linq;using System;using System.Collections;\n\nclass Program\n{\n    #region Reader\n    static string ReadStr => Console.ReadLine();\n    static string[] ReadStrs => Console.ReadLine().Split(' ');\n    static int ReadInt => Convert.ToInt32(Console.ReadLine());\n    static int[] ReadInts => Console.ReadLine().Split(' ').Select(s => Convert.ToInt32(s)).ToArray();\n    static long ReadLong => Convert.ToInt64(Console.ReadLine());\n    static long[] ReadLongs => Console.ReadLine().Split(' ').Select(s => Convert.ToInt64(s)).ToArray();\n    #endregion\n    #region Method\n    const int mod = 1000000007;\n    public static int Mod(int a,int mod) { return a % mod >= 0 ? a % mod : a % mod + mod; }\n    public static long Mod(long a, long mod = mod) { return a % mod >= 0 ? a % mod : a % mod + mod; }\n    #endregion\n\n\n    static void Main()\n    {\n        int[] VE = ReadInts;\n        int V = VE[0];\n        int E = VE[1];\n\n\n        List<int[]>[] roads = new List<int[]>[V];\n        for (int i = 0; i < V; i++)\n        {\n            roads[i] = new List<int[]>();\n        }\n        for (int i = 0; i < E; i++)\n        {\n            int[] vs = ReadInts;\n            roads[vs[0]].Add(new int[2] { vs[1], vs[2] });\n        }\n\n        int infty = 1000000000;\n        //コストのbitDP[通った集合,現在の位置]\n        int[,] dp = new int[(int)Pow(2, V),V];\n        for (int i = 0; i < (int)Pow(2,V); i++)\n        {\n            for (int j = 0; j < V; j++)\n            {\n                dp[i, j] = infty;\n            }\n        }\n\n        dp[0,0] = 0;\n\n\n        for (int s = 0; s < (int)Pow(2, V); s++)\n        {\n            int[] bits = ToNSinsu(s, 2, V);\n            for (int i = 0; i < V; i++)\n            {\n\n                foreach (int[] road in roads[i])\n                {\n                    if (bits[road[0]] == 1) {\n                        continue;\n                    }\n\n                    dp[s + (int)Pow(2, road[0]), road[0]] = Min(dp[s + (int)Pow(2, road[0]), road[0]],dp[s, i] + road[1]);\n                }\n            }\n        }\n\n        WriteLine(dp[(int)Pow(2, V) - 1, 0] != infty ? dp[(int)Pow(2, V) - 1, 0] : -1);\n\n\n    }\n\n    public static int[] ToNSinsu(int i, int baseNum, int digit)\n    {\n        int[] ans = new int[digit];\n        int index = 0;\n        while (i >= baseNum)\n        {\n            int d = i / baseNum;\n            int r = i % baseNum;\n\n            ans[index] = r;\n            index++;\n            i = d;\n        }\n        ans[index] = i;\n        return ans;\n    }\n\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PriorityQueue<T> where T : IComparable<T> {\n    private List<T> _buf = new List<T>();\n    private IComparer<T> _comp;\n\n    private void Swap(int a, int b) {\n        T t = _buf[a];\n        _buf[a] = _buf[b];\n        _buf[b] = t;\n    }\n\n    private int Compare(T a, T b) {\n        if (_comp == null) return a.CompareTo(b);\n        return _comp.Compare(a, b);\n    }\n\n    public int Count { get { return _buf.Count; } }\n\n    public PriorityQueue() {\n    }\n\n    public PriorityQueue(IComparer<T> comp) {\n        _comp = comp;\n    }\n\n    public void Enqueue(T x) {\n        _buf.Add(x);\n\n        // shiftup\n        int p = Count-1;\n        while (p > 0) {\n            int parent = (p - 1) / 2;\n            if (Compare(_buf[parent], _buf[p]) <= 0)\n                break;\n            Swap(parent, p);\n            p = parent;\n        }\n    }\n\n    public T Dequeue() {\n        if (Count == 0)\n            throw new IndexOutOfRangeException();\n\n        T ret = _buf[0];\n        _buf[0] = _buf[Count-1];\n        _buf.RemoveAt(Count-1);\n\n        // shiftdown\n        int p = 0;\n        while (p < Count) {\n            int c = p * 2 + 1; // ?????????\n            if (c >= Count) break;\n\n            if (c+1 < Count) { // c+1 ????????????\n                if (Compare(_buf[c+1], _buf[c]) < 0) { // ??????????????????????°???????\n                    c++;\n                }\n            }\n\n            if (Compare(_buf[p], _buf[c]) <= 0)\n                break;\n            Swap(p, c);\n            p = c;\n        }\n\n        return ret;\n    }\n}\n\nclass Program {\n    static string ReadLine() { return Console.ReadLine(); }\n    static int ReadInt() { return int.Parse(ReadLine()); }\n    static int[] ReadInts() { return ReadLine().Split().Select(int.Parse).ToArray(); }\n    static string[] ReadStrings() { return ReadLine().Split(); }\n\n    struct D : IComparable<D> {\n        public int node;\n        public int visited;\n        public int cost;\n        public bool finished; // ??¨??????note????¨??????????\n\n        public int CompareTo(D o) { return cost - o.cost; }\n    }\n\n    static int Calc_1(int start, int v, int[,] adj) {\n        var q = new PriorityQueue<D>();\n        q.Enqueue(new D { node = start, visited = (1 << start), cost = 0, finished = false });\n\n        var memo = new int[v, (1 << v)];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < (1 << v); j++)\n                memo[i, j] = int.MaxValue;\n\n        while (q.Count > 0) {\n            D d = q.Dequeue();\n\n            if (d.finished) return d.cost;\n\n            if (d.visited == (1 << v)-1) {\n                // ??¨???????????????????¨???????????????§???start ?????????\n                if (adj[d.node, start] != -1) {\n                    int cost = d.cost + adj[d.node, start];\n                    q.Enqueue(new D { node = start, visited = d.visited, cost = cost, finished = true });\n                }\n                continue;\n            }\n\n            if (memo[d.node, d.visited] < d.cost) continue;\n            memo[d.node, d.visited] = d.cost;\n\n            for (int i = 0; i < v; i++) {\n                if (adj[d.node, i] == -1) continue; // ????????????\n\n                if ((d.visited & (1 << i)) > 0) continue; // ?¨??????????\n\n                int vv = d.visited | (1 << i);\n                int cost = d.cost + adj[d.node, i];\n                q.Enqueue(new D { node = i, visited = vv, cost = cost, finished = d.finished });\n            }\n        }\n        return int.MaxValue;\n    }\n\n    static int Calc(int v, int[,] adj) {\n        int ans = int.MaxValue;\n        for (int i = 0; i < v; i++) {\n            ans = Math.Min(ans, Calc_1(i, v, adj));\n        }\n        return ans == int.MaxValue ? -1 : ans;\n    }\n\n    static void Main() {\n        var ve = ReadInts();\n        int v = ve[0], e = ve[1];\n\n        var adj = new int[v, v];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < v; j++)\n                adj[i, j] = -1;\n\n        for (int i = 0; i < e; i++) {\n            var std = ReadInts();\n            adj[std[0], std[1]] = std[2];\n        }\n        Console.WriteLine(Calc(v, adj));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tstring[] input = Console.ReadLine().Split(' ');\n\t\tint v = int.Parse(input[0]);\n\t\tint e = int.Parse(input[1]);\n    long[,] distance = new long[v,v];\n    long[,] dp = new long[1<<v, v];//dp[スタートを除く訪問した頂点,今いる頂点] := 通った距離\n    long answer = long.MaxValue/2;\n\n    for(int i = 0; i < v; i++)\n    {\n      for(int j = 0; j < v; j++)\n      {\n        distance[i,j] = -1;\n      }\n    }\n\n    for(int i = 0; i < e; i++)\n    {\n      string[] inputa = Console.ReadLine().Split(' ');\n      distance[int.Parse(inputa[0]), int.Parse(inputa[1])] = long.Parse(inputa[2]);\n    }\n\n    for(int i = 0; i < 1<<v; i++)\n    {\n      for(int j = 0; j < v; j++)\n      {\n        dp[i,j] = long.MaxValue/2;\n      }\n    }\n    dp[1,0] = 0;//初期化\n\n    for(int i = 2; i < 1<<v; i++)\n    {\n      for(int next = 0; next < v; next++)\n      {\n        if(((i>>next)&1) == 1)\n        {\n          for(int back = 0; back < v; back++)\n          {\n            if(distance[back, next] != -1 && dp[i^(1<<next),back] != long.MaxValue/2)\n            {\n              dp[i,next] = Math.Min(dp[i,next], dp[i^(1<<next),back]+distance[back,next]);\n              //Console.WriteLine(i+\" \"+next+\" \"+dp[i,next]);\n            }\n          }\n        }\n      }\n    }\n\n    for(int i = 1; i < v; i++)\n    {\n      //Console.WriteLine(dp[(1<<v)-1, i]+\" \"+((1<<v)-1)+\" \"+v);\n      if(dp[(1<<v)-1, i] != long.MaxValue/2 && distance[i,0] != -1)\n      {\n        answer = Math.Min(answer, dp[(1<<v)-1, i] + distance[i,0]);\n      }\n    }\n\t\t\n\t\tConsole.WriteLine(answer == long.MaxValue/2 ? -1 : answer);\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ_DPL_2_A_2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var VE = ReadInt();\n            V = VE[0];\n            int E = VE[1];\n\n            d = new long[V, V];\n            for (int i = 0; i < V; i++)\n            {\n                for (int j = 0; j < V; j++)\n                {\n                    d[i, j] = INF;\n                }\n            }\n\n            for (int i = 0; i < E; i++)\n            {\n                var input = ReadInt();\n                int s = input[0];\n                int t = input[1];\n                int d2 = input[2];\n                d[s, t] = d2;\n            }\n\n            //bitDP\n            dp = new long[1 << V, V];\n            long ans = Tsp(1, 0);\n\n            if (ans != INF) Console.WriteLine(ans);\n            else Console.WriteLine(-1);\n            Console.ReadKey();\n        }\n\n        static int V;   　 //頂点数\n        static long[,] d;　//頂点行列 頂点ない部分はlong.MaxValue / 4で初期化\n        static long[,] dp; //DP\n        static long INF = long.MaxValue / 2;\n        /// <summary>\n        /// 巡回セールスマン問題\n        /// </summary>\n        /// <param name=\"S\">bit訪れた場所のbit</param>\n        /// <param name=\"v\">現在の頂点</param>\n        /// <returns></returns>\n        static long Tsp(int S = 1, int v = 0)\n        {\n            if (dp[S, v] != 0) return dp[S, v];\n            if (S == (1 << V) - 1) return d[v, 0];\n\n            long ret = INF;\n            for (int i = 0; i < V; i++)\n            {\n                if ((S & (1 << i)) > 0) continue;\n                if (d[v, i] == INF) continue;\n                ret = Math.Min(ret, d[v, i] + Tsp(S | (1 << i), i));\n            }\n\n            return dp[S, v] = ret;\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int V = int.Parse(str[0]);\n        int E = int.Parse(str[1]);\n        long[,] cost = new long[V,V];\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                cost[i,j] = 1000000;\n            }\n        }\n        for(int i=0;i<E;i++){\n            str = Console.ReadLine().Split(' ');\n            int s = int.Parse(str[0]);\n            int t = int.Parse(str[1]);\n            int d = int.Parse(str[2]);\n            cost[s,t] = d;\n        }\n        long[,] DP = new long[1<<V,V];\n        for(int i=1;i<1<<V;i++){\n            for(int j=0;j<V;j++){\n                if(((1 << j) & i) != 0){\n                    DP[i,j] = 1000000;\n                }\n                else{\n                    long min = 1000000;\n                    for(int k=0;k<V;k++){\n                        if(((1 << k) & i) != 0){\n                            min = Math.Min(min,DP[i-(1 << k),k]+cost[k,j]);\n                        }\n                    }\n                    DP[i,j] = min;\n                }\n            }\n        }\n        {\n            long min = 1000000;\n            for(int i=1;i<V;i++){\n                min = Math.Min(min,DP[(1<<V)-1-(1<<i),i]+cost[i,0]);\n            }\n            if(min == 1000000){\n                min = -1;\n            }\n            sb.Append(min+\"\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int V = int.Parse(str[0]);\n        int E = int.Parse(str[1]);\n        long[,] cost = new long[V,V];\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                cost[i,j] = 1000000;\n            }\n        }\n        for(int i=0;i<E;i++){\n            str = Console.ReadLine().Split(' ');\n            int s = int.Parse(str[0]);\n            int t = int.Parse(str[1]);\n            int d = int.Parse(str[2]);\n            cost[s,t] = d;\n        }\n        long[,] DP = new long[1<<V,V];\n        for(int i=1;i<V;i++){\n            DP[0,i] = 1000000;\n        }\n        for(int i=1;i<1<<V;i++){\n            for(int j=0;j<V;j++){\n                if(((1 << j) & i) != 0){\n                    DP[i,j] = 1000000;\n                }\n                else{\n                    long min = 1000000;\n                    for(int k=0;k<V;k++){\n                        if(((1 << k) & i) != 0){\n                            min = Math.Min(min,DP[i-(1 << k),k]+cost[k,j]);\n                        }\n                    }\n                    DP[i,j] = min;\n                }\n            }\n        }\n        {\n            long min = 1000000;\n            for(int i=1;i<V;i++){\n                min = Math.Min(min,DP[(1<<V)-1-(1<<i),i]+cost[i,0]);\n            }\n            if(min == 1000000){\n                min = -1;\n            }\n            sb.Append(min+\"\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PriorityQueue<T> where T : IComparable<T> {\n    private List<T> _buf = new List<T>();\n    private IComparer<T> _comp;\n\n    private void Swap(int a, int b) {\n        T t = _buf[a];\n        _buf[a] = _buf[b];\n        _buf[b] = t;\n    }\n\n    private int Compare(T a, T b) {\n        if (_comp == null) return a.CompareTo(b);\n        return _comp.Compare(a, b);\n    }\n\n    public int Count { get { return _buf.Count; } }\n\n    public PriorityQueue() {\n    }\n\n    public PriorityQueue(IComparer<T> comp) {\n        _comp = comp;\n    }\n\n    public void Enqueue(T x) {\n        _buf.Add(x);\n\n        // shiftup\n        int p = Count-1;\n        while (p > 0) {\n            int parent = (p - 1) / 2;\n            if (Compare(_buf[parent], _buf[p]) <= 0)\n                break;\n            Swap(parent, p);\n            p = parent;\n        }\n    }\n\n    public T Dequeue() {\n        if (Count == 0)\n            throw new IndexOutOfRangeException();\n\n        T ret = _buf[0];\n        _buf[0] = _buf[Count-1];\n        _buf.RemoveAt(Count-1);\n\n        // shiftdown\n        int p = 0;\n        while (p < Count) {\n            int c = p * 2 + 1; // ?????????\n            if (c >= Count) break;\n\n            if (c+1 < Count) { // c+1 ????????????\n                if (Compare(_buf[c+1], _buf[c]) < 0) { // ??????????????????????°???????\n                    c++;\n                }\n            }\n\n            if (Compare(_buf[p], _buf[c]) <= 0)\n                break;\n            Swap(p, c);\n            p = c;\n        }\n\n        return ret;\n    }\n}\n\nclass Program {\n    static string ReadLine() { return Console.ReadLine(); }\n    static int ReadInt() { return int.Parse(ReadLine()); }\n    static int[] ReadInts() { return ReadLine().Split().Select(int.Parse).ToArray(); }\n    static string[] ReadStrings() { return ReadLine().Split(); }\n\n    struct D : IComparable<D> {\n        public int node;\n        public int visited;\n        public int cost;\n        public bool finished; // ??¨??????note????¨??????????\n\n        public int CompareTo(D o) { return cost - o.cost; }\n    }\n\n    static int Calc_1(int start, int v, int[,] adj) {\n        var q = new PriorityQueue<D>();\n        q.Enqueue(new D { node = start, visited = (1 << start), cost = 0, finished = false });\n        while (q.Count > 0) {\n            D d = q.Dequeue();\n\n            if (d.finished) return d.cost;\n\n            if (d.visited == (1 << v)-1) {\n                // ??¨???????????????????¨???????????????§???start ?????????\n                if (adj[d.node, start] != -1) {\n                    int cost = d.cost + adj[d.node, start];\n                    q.Enqueue(new D { node = start, visited = d.visited, cost = cost, finished = true });\n                }\n                continue;\n            }\n\n            for (int i = 0; i < v; i++) {\n                if (adj[d.node, i] == -1) continue; // ????????????\n\n                if ((d.visited & (1 << i)) > 0) continue; // ?¨??????????\n\n                int vv = d.visited | (1 << i);\n                int cost = d.cost + adj[d.node, i];\n                q.Enqueue(new D { node = i, visited = vv, cost = cost, finished = d.finished });\n            }\n        }\n        return int.MaxValue;\n    }\n\n    static int Calc(int v, int[,] adj) {\n        int ans = int.MaxValue;\n        for (int i = 0; i < v; i++) {\n            ans = Math.Min(ans, Calc_1(i, v, adj));\n        }\n        return ans == int.MaxValue ? -1 : ans;\n    }\n\n    static void Main() {\n        var ve = ReadInts();\n        int v = ve[0], e = ve[1];\n\n        var adj = new int[v, v];\n        for (int i = 0; i < v; i++)\n            for (int j = 0; j < v; j++)\n                adj[i, j] = -1;\n\n        for (int i = 0; i < e; i++) {\n            var std = ReadInts();\n            adj[std[0], std[1]] = std[2];\n        }\n        Console.WriteLine(Calc(v, adj));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    public static void Main(){\n        // 方針\n        // bitdp[(bit情報),(始点),(現在地点)]\n        var n = inta();\n        var squ = square(2,n[0]);\n        \n        var dis = new int[n[0],n[0]];\n        for(int i=0;i<n[0];i++){\n            for(int j=0;j<n[0];j++){\n                dis[i,j] = 999999999;\n            }\n        }\n        \n        var bitdp = new int[squ,n[0],n[0]];\n        for(int i=0;i<squ;i++){\n            for(int j=0;j<n[0];j++){\n                for(int k=0;k<n[0];k++){\n                    bitdp[i,j,k] = 999999999;\n                }\n            }\n        }\n        for(int i=0;i<n[0];i++){\n            bitdp[1<<i,i,i] = 0;\n        }\n        \n        for(int i=0;i<n[1];i++){\n            var t = inta();\n            dis[t[0],t[1]] = t[2];\n        }\n        \n        for(int i=0;i<squ;i++){\n            for(int j=0;j<n[0];j++){\n                if((i>>j)%2 == 0) continue;\n                for(int k=0;k<n[0];k++){\n                    if((i>>k)%2 == 0)continue;\n                    for(int l=0;l<n[0];l++){\n                        if((i>>l)%2==1) continue;\n                        var t = i | (1<<l);\n                        bitdp[t,j,l] = Min(bitdp[t,j,l],bitdp[i,j,k] + dis[k,l]);\n                    }\n                }\n            }\n        }\n        var ans = 999999999;\n        for(int i=0;i<n[0];i++){\n            for(int j=0;j<n[0];j++){\n                if(i==j) continue;\n                ans = Min(ans,bitdp[squ-1,i,j] + dis[j,i]);\n                //WriteLine($\"{bitdp[squ-1,i,j]} {dis[j,i]}\");\n            }\n        }\n        if(ans > 10000000){\n            WriteLine(-1);\n        }else{\n            WriteLine(ans);\n        }\n        \n        \n        \n        \n        \n    }\n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long divideup(long divided,long divid){ long temp_divide = divided/divid; if(divided % divid > 0){ temp_divide++; } return temp_divide; }\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(long[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        class Graph\n        {\n            internal int to, cost;\n\n            public Graph(int t,int d)\n            {\n                to = t;\n                cost = d;\n            }\n        }\n\n        class Salesman\n        {\n            internal int pos, sumCost;\n            internal bool[] visited;\n\n            public Salesman(int V)\n            {\n                visited = new bool[V];\n            }\n\n            public Salesman(Salesman other)\n            {\n                pos = other.pos;\n                sumCost = other.sumCost;\n\n                int temp = other.visited.Length;\n                visited = new bool[temp];\n                other.visited.CopyTo(visited, 0);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n\n            Dictionary<int, List<Graph>> G = new Dictionary<int, List<Graph>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<Graph>());\n\n            for(int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int s = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n                int d = int.Parse(input[2]);\n\n                G[s].Add(new Graph(t, d));\n            }\n\n            Queue<Salesman> que = new Queue<Salesman>();\n\n            foreach (var g in G[0])\n            {\n                Salesman willEnq = new Salesman(V);\n                int next = g.to;\n                willEnq.pos = next;\n                willEnq.sumCost += g.cost;\n                willEnq.visited[next] = true;\n                que.Enqueue(willEnq);\n            }\n\n            int minCost = int.MaxValue;\n\n            while (que.Count > 0)\n            {\n                Salesman cur = que.Dequeue();\n\n                if (!cur.visited.Contains(false))\n                {\n                    minCost = Math.Min(minCost, cur.sumCost);\n                    continue;\n                }\n                \n                foreach (var g in G[cur.pos])\n                {\n                    int next = g.to;\n                    if (cur.visited[next] == true) continue;\n                    if (next == 0 && cur.visited.Where(a => a == false).Count() > 1) continue;\n                    \n                    Salesman willEnq = new Salesman(cur);\n                    willEnq.pos = next;\n                    willEnq.sumCost += g.cost;\n                    willEnq.visited[next] = true;\n                    que.Enqueue(willEnq);\n                }\n            }\n            Console.WriteLine(minCost != int.MaxValue ? minCost : -1);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace DPL2_A\n{\n    class Program\n    {\n        const int INF = 1 << 30;\n        const int MAX = 15;\n        static int n;\n        static int[,] d = new int[MAX, MAX];\n        static int[,] dp = new int[1 << MAX, MAX];\n        static void solve()\n        {\n            for (int i = 0; i < 1 << n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dp[i, j] = INF;\n                }\n            }\n            dp[(1 << n) - 1, 0] = 0;\n\n            for (int S = (1 << n) - 2; S >= 0; S--)\n            {\n                for (int v = 0; v < n; v++)\n                {\n                    for (int u = 0; u < n; u++)\n                    {\n                        if ((S >> u & 1) == 0 && d[v,u] != INF)\n                        {\n                            dp[S, v] = Math.Min(dp[S, v], dp[S | 1 << u, u] + d[v, u]);\n                        }\n                    }\n                }\n            }\n            Console.WriteLine(dp[0,0] == INF ? -1 : dp[0,0]);\n        }\n        static void Main(string[] args)\n        {\n            var t = scan;\n            n = t[0];\n            int e = t[1];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    d[i, j] = INF;\n                }\n            }\n            for (int i = 0; i < e; i++)\n            {\n                var k = scan;\n                d[k[0], k[1]] = k[2];\n            }\n\n            solve();\n        }\n\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tint m=1<<s[0],inf=int.MaxValue;\n\t\tint[][] h=new int[s[0]][];\n\t\tvar dp=new long[m][];\n\t\tfor(int i = 0;i<s[0];i++) {h[i]=Enumerable.Repeat(inf,s[0]).ToArray();}\n\t\tfor(int i = 0;i<s[1];i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\th[e[0]][e[1]]=e[2];\n\t\t}\n\t\tfor(int i = 1;i<m;i++) {\n\t\t\tdp[i]=new long[s[0]];\n\t\t\tfor(int j = 0;j<s[0];j++) {\n\t\t\t\tif((1<<j)!=i){\n\t\t\t\t\tdp[i][j]=inf;\n\t\t\t\t\tif(((1<<j)&i)!=0){\n\t\t\t\t\t\tfor(int k = 0;k<s[0];k++) {\n\t\t\t\t\t\t\tif(dp[i][j]>dp[i^(1<<j)][k]+h[k][j]){\n\t\t\t\t\t\t\t\tdp[i][j]=dp[i^(1<<j)][k]+h[k][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(i!=1){dp[i][j]=inf;}\n\t\t\t}\n\t\t}\n\t\tlong ans=inf;\n\t\tfor(int i = 0;i<s[0];i++) {ans=Min(ans,dp[m-1][i]+h[i][0]);}\n\t\tConsole.WriteLine(\"{0}\",ans>=inf?-1:ans);\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace DPL2_A\n{\n    class Program\n    {\n        const int INF = 1 << 30;\n        const int MAX = 15;\n        static int ans = INF;\n        static int n;\n        static int[,] d = new int[MAX, MAX];\n        static int[,] dp = new int[1 << MAX, MAX];\n        static void solve(int f)\n        {\n            for (int i = 0; i < 1 << n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dp[i, j] = INF;\n                }\n            }\n            //goal(f) = 0 \n            dp[(1 << n) - 1, 0] = 0;\n\n            for (int S = (1 << n) - 2; S >= 0; S--)\n            {\n                for (int v = 0; v < n; v++)\n                {\n                    for (int u = 0; u < n; u++)\n                    {\n                        if ((S >> u & 1) == 0 && d[v,u] != INF)\n                        {\n                            dp[S, v] = Math.Min(dp[S, v], dp[S | 1 << u, u] + d[v, u]);\n                        }\n                    }\n                }\n            }\n            ans = ans > dp[0, 0] ? dp[0,0] : ans;\n        }\n        static void Main(string[] args)\n        {\n            var t = scan;\n            n = t[0];\n            int e = t[1];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    d[i, j] = INF;\n                }\n            }\n            for (int i = 0; i < e; i++)\n            {\n                var k = scan;\n                d[k[0], k[1]] = k[2];\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                solve(i);\n            }\n            \n\n            Console.WriteLine(ans == INF ? -1 : ans);\n        }\n\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    input = input.trim().split(\"\\n\").map(function(x) { return x.split(\" \")});\n    let lVl = parseInt(input[0][0], 10);\n\tlet lEl = parseInt(input[0][1], 10);\n\tdp = []; //global\n    graph = []; // global\n    for (let i = 0; i < lVl; i++){\n        graph.push([]);\n        for  (let j = 0; j < lVl; j++){\n            graph[i][j] = Infinity;\n        }\n        graph[i][i] = 0;\n    }\n    for (let i = 0; i < lEl; i++){\n        graph[parseInt(input[i + 1][0], 10)][parseInt(input[i + 1][1], 10)] = parseInt(input[i + 1][2], 10);\n    }\n    for (let i = 0; i < Math.pow(2, lVl); i++){\n        dp.push([]);\n        for (let j = 0; j < lVl; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\tdp[0][0] = 0; //start from node0\n\tdp[1][0] = 0;\n\t\n\tfor (let i = 1; i < lVl; i++) bitDP(Math.pow(2, lVl) - 1, i);\n\tlet ans = Infinity;\n\tfor (let i = 1; i < lVl; i++){\n\t\tans = Math.min(dp[dp.length - 1][i] + graph[i][0], ans);\n\t}\n\tif (ans === Infinity) ans = -1;\n\tconsole.log(ans);\n}\n\nfunction bitDP(S, v){\n\tif (S === 0) return (v === 0) ? 0: Infinity;\n\tif ((S & (1 << v)) === 0) return Infinity; //S does not include v\n\tif (dp[S][v] !== -1) return dp[S][v]; //initial value?\n\tlet ret = Infinity;\n\tfor (let i = 0; i <= Math.log2(S); i++){\n\t\tif (((S ^ (1 << v)) & (1 << i)) === 0) continue;\n\t\tret = Math.min(ret, bitDP((S ^ (1 << v)), i) + graph[i][v]);\n\t}\n\treturn dp[S][v] = ret;\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\ntype Scanner struct{}\n\nfunc (sc Scanner) Next() (s string) {\n\tfmt.Scan(&s)\n\treturn\n}\n\nfunc (sc Scanner) NextInt() (i int) {\n\tfmt.Scan(&i)\n\treturn\n}\n\ntype MinCostStatus struct {\n\tVisited   int\n\tPrevPoint int\n}\n\ntype Status struct {\n\tMinCostStatus\n\tCost int\n}\n\ntype PriorityQueueStatus []*Status\n\nfunc (pq PriorityQueueStatus) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq PriorityQueueStatus) Less(i, j int) bool {\n\treturn pq[i].Cost < pq[j].Cost\n}\n\nfunc (pq PriorityQueueStatus) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueueStatus) Push(data interface{}) {\n\t*pq = append(*pq, data.(*Status))\n}\n\nfunc (pq *PriorityQueueStatus) Pop() interface{} {\n\tl := len(*pq)\n\titem := (*pq)[l-1]\n\t*pq = (*pq)[0 : l-1]\n\treturn item\n}\n\nfunc main() {\n\tvar sc Scanner\n\tv, e := sc.NextInt(), sc.NextInt()\n\tm := make([]map[int]int, v)\n\tfor i := 0; i < v; i++ {\n\t\tm[i] = make(map[int]int)\n\t}\n\tfor i := 0; i < e; i++ {\n\t\ts, t, d := sc.NextInt(), sc.NextInt(), sc.NextInt()\n\t\tm[s][t] = d\n\t}\n\tpq := make(PriorityQueueStatus, 0)\n\tstart := &Status{\n\t\tMinCostStatus: MinCostStatus{\n\t\t\tVisited:   0,\n\t\t\tPrevPoint: 0,\n\t\t},\n\t\tCost: 0,\n\t}\n\tmemo := make(map[MinCostStatus]int)\n\theap.Push(&pq, start)\n\tfor pq.Len() > 0 {\n\t\tnow := pq.Pop().(*Status)\n\t\tif now.Visited == (1<<uint(v))-1 {\n\t\t\tfmt.Println(now.Cost)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range m[now.PrevPoint] {\n\t\t\tif now.Visited&(1<<uint(k)) == 0 {\n\t\t\t\tminCostStatus := MinCostStatus{\n\t\t\t\t\tVisited:   now.Visited | (1 << uint(k)),\n\t\t\t\t\tPrevPoint: k,\n\t\t\t\t}\n\t\t\t\tcost := now.Cost + v\n\t\t\t\tif v, ok := memo[minCostStatus]; !ok || (ok && cost < v) {\n\t\t\t\t\tnext := &Status{\n\t\t\t\t\t\tMinCostStatus: minCostStatus,\n\t\t\t\t\t\tCost:          cost,\n\t\t\t\t\t}\n\t\t\t\t\tmemo[minCostStatus] = cost\n\t\t\t\t\theap.Push(&pq, next)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(-1)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\ntype Scanner struct{}\n\nfunc (sc Scanner) Next() (s string) {\n\tfmt.Scan(&s)\n\treturn\n}\n\nfunc (sc Scanner) NextInt() (i int) {\n\tfmt.Scan(&i)\n\treturn\n}\n\ntype MinCostStatus struct {\n\tVisited   int\n\tPrevPoint int\n}\n\ntype Status struct {\n\tMinCostStatus\n\tCost int\n}\n\ntype PriorityQueueStatus []*Status\n\nfunc (pq PriorityQueueStatus) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq PriorityQueueStatus) Less(i, j int) bool {\n\treturn pq[i].Cost < pq[j].Cost\n}\n\nfunc (pq PriorityQueueStatus) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueueStatus) Push(data interface{}) {\n\t*pq = append(*pq, data.(*Status))\n}\n\nfunc (pq *PriorityQueueStatus) Pop() interface{} {\n\tl := len(*pq)\n\titem := (*pq)[l-1]\n\t*pq = (*pq)[0 : l-1]\n\treturn item\n}\n\nfunc main() {\n\tvar sc Scanner\n\tv, e := sc.NextInt(), sc.NextInt()\n\tm := make([]map[int]int, v)\n\tfor i := 0; i < v; i++ {\n\t\tm[i] = make(map[int]int)\n\t}\n\tfor i := 0; i < e; i++ {\n\t\ts, t, d := sc.NextInt(), sc.NextInt(), sc.NextInt()\n\t\tm[s][t] = d\n\t}\n\tpq := make(PriorityQueueStatus, 0)\n\tstart := &Status{\n\t\tMinCostStatus: MinCostStatus{\n\t\t\tVisited:   0,\n\t\t\tPrevPoint: 0,\n\t\t},\n\t\tCost: 0,\n\t}\n\tmemo := make(map[MinCostStatus]int)\n\theap.Push(&pq, start)\n\tfor pq.Len() > 0 {\n\t\tnow := heap.Pop(&pq).(*Status)\n\t\tif now.Visited == (1<<uint(v))-1 {\n\t\t\tfmt.Println(now.Cost)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range m[now.PrevPoint] {\n\t\t\tif now.Visited&(1<<uint(k)) == 0 {\n\t\t\t\tminCostStatus := MinCostStatus{\n\t\t\t\t\tVisited:   now.Visited | (1 << uint(k)),\n\t\t\t\t\tPrevPoint: k,\n\t\t\t\t}\n\t\t\t\tcost := now.Cost + v\n\t\t\t\tif v, ok := memo[minCostStatus]; !ok || (ok && cost < v) {\n\t\t\t\t\tnext := &Status{\n\t\t\t\t\t\tMinCostStatus: minCostStatus,\n\t\t\t\t\t\tCost:          cost,\n\t\t\t\t\t}\n\t\t\t\t\tmemo[minCostStatus] = cost\n\t\t\t\t\theap.Push(&pq, next)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(-1)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\ntype Scanner struct{}\n\nfunc (sc Scanner) Next() (s string) {\n\tfmt.Scan(&s)\n\treturn\n}\n\nfunc (sc Scanner) NextInt() (i int) {\n\tfmt.Scan(&i)\n\treturn\n}\n\ntype MinCostStatus struct {\n\tVisited   int\n\tPrevPoint int\n}\n\ntype Status struct {\n\tMinCostStatus\n\tCost int\n}\n\ntype PriorityQueueStatus []*Status\n\nfunc (pq PriorityQueueStatus) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq PriorityQueueStatus) Less(i, j int) bool {\n\treturn pq[i].Cost < pq[j].Cost\n}\n\nfunc (pq PriorityQueueStatus) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueueStatus) Push(data interface{}) {\n\t*pq = append(*pq, data.(*Status))\n}\n\nfunc (pq *PriorityQueueStatus) Pop() interface{} {\n\tl := len(*pq)\n\titem := (*pq)[l-1]\n\t*pq = (*pq)[0 : l-1]\n\treturn item\n}\n\nfunc main() {\n\tvar sc Scanner\n\tv, e := sc.NextInt(), sc.NextInt()\n\tm := make([]map[int]int, v)\n\tfor i := 0; i < v; i++ {\n\t\tm[i] = make(map[int]int)\n\t}\n\tfor i := 0; i < e; i++ {\n\t\ts, t, d := sc.NextInt(), sc.NextInt(), sc.NextInt()\n\t\tm[s][t] = d\n\t}\n\tpq := make(PriorityQueueStatus, 0)\n\tstart := &Status{\n\t\tMinCostStatus: MinCostStatus{\n\t\t\tVisited:   0,\n\t\t\tPrevPoint: 0,\n\t\t},\n\t\tCost: 0,\n\t}\n\tmemo := make(map[MinCostStatus]int)\n\theap.Push(&pq, start)\n\tfor pq.Len() > 0 {\n\t\tnow := heap.Pop(&pq).(*Status)\n\t\tif now.Visited == (1<<uint(v))-1 && now.PrevPoint == 0 {\n\t\t\tfmt.Println(now.Cost)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range m[now.PrevPoint] {\n\t\t\tif now.Visited&(1<<uint(k)) == 0 {\n\t\t\t\tminCostStatus := MinCostStatus{\n\t\t\t\t\tVisited:   now.Visited | (1 << uint(k)),\n\t\t\t\t\tPrevPoint: k,\n\t\t\t\t}\n\t\t\t\tcost := now.Cost + v\n\t\t\t\tif v, ok := memo[minCostStatus]; !ok || (ok && cost < v) {\n\t\t\t\t\tnext := &Status{\n\t\t\t\t\t\tMinCostStatus: minCostStatus,\n\t\t\t\t\t\tCost:          cost,\n\t\t\t\t\t}\n\t\t\t\t\tmemo[minCostStatus] = cost\n\t\t\t\t\theap.Push(&pq, next)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(-1)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tinitialBufSize = 100000\n\tmaxBufSize     = 1000000\n)\n\nvar sc *bufio.Scanner\n\nfunc initScanner(r io.Reader) *bufio.Scanner {\n\tbuf := make([]byte, initialBufSize)\n\n\tsc := bufio.NewScanner(r)\n\tsc.Buffer(buf, maxBufSize)\n\tsc.Split(bufio.ScanWords) // bufio.ScanLines\n\treturn sc\n}\n\nfunc main() {\n\tsc = initScanner(os.Stdin)\n\tfmt.Println(resolve(parseProblem()))\n}\n\nfunc parseProblem() (int, int, *weightedLinkedList) {\n\tn, m := scanInt(sc), scanInt(sc)\n\tg := nextDirectedWeightedLinkedList(n, m, 0, sc)\n\treturn n, m, g\n}\n\n// package: gocom\n// packed src of [/Users/masumi/dev/src/github.com/masu-mi/gamemo/lib/gocom/weigthedlinkedlist.go /Users/masumi/dev/src/github.com/masu-mi/gamemo/lib/gocom/next.go] with goone.\n\ntype weightedLinkedList struct {\n\tsize, deg int\n\n\tedges []map[int]int\n}\n\nfunc newWeightedLinkedList(size int) *weightedLinkedList {\n\tll := &weightedLinkedList{size: size, edges: make([]map[int]int, size)}\n\tfor i := 0; i < size; i++ {\n\t\tll.edges[i] = map[int]int{}\n\t}\n\treturn ll\n}\n\nfunc (ll *weightedLinkedList) addEdge(a, b, w int) {\n\tll.addDirectedEdge(a, b, w)\n\tll.addDirectedEdge(b, a, w)\n}\n\nfunc (ll *weightedLinkedList) addDirectedEdge(a, b, w int) {\n\tif _, ok := ll.edges[a][b]; !ok {\n\t\tll.edges[a][b] = w\n\t\tll.deg++\n\t}\n}\n\nfunc (ll *weightedLinkedList) weight(a, b int) (int, bool) {\n\tw, ok := ll.edges[a][b]\n\treturn w, ok\n}\n\nfunc nextWeightedLinkedList(n, m, offset int, sc *bufio.Scanner) *weightedLinkedList {\n\tll := newWeightedLinkedList(n)\n\tfor i := 0; i < m; i++ {\n\t\tx, y, w := nextInt(sc), nextInt(sc), nextInt(sc)\n\t\tx -= offset\n\t\ty -= offset\n\t\tll.addEdge(x, y, w)\n\t}\n\treturn ll\n}\n\nfunc nextDirectedWeightedLinkedList(n, m, offset int, sc *bufio.Scanner) *weightedLinkedList {\n\tll := newWeightedLinkedList(n)\n\tfor i := 0; i < m; i++ {\n\t\tx, y, w := nextInt(sc), nextInt(sc), nextInt(sc)\n\t\tx -= offset\n\t\ty -= offset\n\t\tll.addDirectedEdge(x, y, w)\n\t}\n\treturn ll\n}\nfunc nextInt(sc *bufio.Scanner) int {\n\tsc.Scan()\n\ta, _ := strconv.Atoi(sc.Text())\n\treturn int(a)\n}\n\nfunc nextString(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextIntSlice(sc *bufio.Scanner, n int) (a []int) {\n\n\ta = make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = nextInt(sc)\n\t}\n\treturn a\n}\n\nfunc resolve(n, m int, g *weightedLinkedList) int {\n\tdp := make([][]int, 1<<uint(n))\n\tfor i := 0; i < 1<<uint(n); i++ {\n\t\tdp[i] = make([]int, n)\n\t\tfor j := 0; j < n; j++ {\n\t\t\tdp[i][j] = math.MaxInt64\n\t\t}\n\t}\n\tdp[0][0] = 0\n\tfor i := 0; i < n; i++ {\n\t\tif c, ok := g.edges[0][i]; ok {\n\t\t\tdp[1<<uint(i)][i] = c\n\t\t}\n\t}\n\t// give dp\n\tfor i := 1; i < 1<<uint(n); i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif i&(1<<uint(j)) != 0 {\n\t\t\t\t// if j in subset(i), not target\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnext := i | 1<<uint(j)\n\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\tif i&(1<<uint(k)) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif dp[i][k] == math.MaxInt64 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif ec, ok := g.edges[k][j]; ok {\n\t\t\t\t\tcost := dp[i][k] + ec\n\t\t\t\t\tif dp[i|1<<uint(j)][j] > cost {\n\t\t\t\t\t\tdp[next][j] = cost\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tv := dp[1<<uint(n)-1][0]\n\tif v == math.MaxInt64 {\n\t\treturn -1\n\t}\n\treturn v\n}\n\n// snip-scan-funcs\nfunc scanInt(sc *bufio.Scanner) int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn int(i)\n}\nfunc scanString(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "let dbg = Printf.printf \"[debug]%s\"\n\nlet max_num = 1_000_000_000\n\nlet id = fun x -> x\nlet tuple2 x y = (x,y)\nlet tuple3 x y z = (x,y,z)\nlet succ x = x + 1\nlet pred x = x - 1\n\nlet (++) n m =\n  let rec aux i =\n    if i = m then [m]\n    else i :: aux (i+1) in\n  if n > m then [] else aux n\n\nlet (++^) n m = n ++ (m-1)\n\nlet scan fmt f = Scanf.sscanf (read_line ()) fmt f\n\nlet scan_lines n fmt f =\n  List.map (fun _ -> scan fmt f) (0++^n)\n\nlet scan_matrix n m e conv =\n  let arr = Array.make_matrix n m e in\n  Array.iteri (fun i line ->\n      let s = Scanf.Scanning.from_string @@ read_line () in\n      Array.iteri (fun j _ ->\n          arr.(i).(j) <- Scanf.bscanf s \" %s\" conv;\n        ) line) arr; arr\n\nlet between n x m = n <= x && x < m\n\nlet string_to_list s =\n  List.map (String.get s) (0 ++^ String.length s)\n\nlet (v,e) = scan \"%d %d\" tuple2\nlet edges =\n  let a = Array.make_matrix v v None in\n  scan_lines e \"%d %d %d\" tuple3\n  |> List.iter (fun (x,y,z)-> a.(x).(y) <- Some z);\n  a\n\n\nlet solve start =\n  let memo = Array.make_matrix (1 lsl v) v None in\n  let rec aux s w = match memo.(s).(w) with\n    | Some va -> va\n    | None ->\n      if s = (1 lsl v) - 1 then\n        if start = w then 0 else max_num\n      else\n        let va =\n          List.filter (fun i -> s land (1 lsl i) = 0) (0 ++^ v)\n          |> List.map (fun x ->\n              match edges.(w).(x) with\n              | None -> max_num\n              | Some e -> e + aux (s lor (1 lsl x)) x)\n          |> List.fold_left min max_num in\n        memo.(s).(w) <- Some va; va in\n  aux 0 start\n\nlet () =\n  List.map (fun i -> solve i) (0 ++^ v)\n  |> List.fold_left min max_num\n  |> (fun va -> if va >= max_num then -1 else va)\n  |>  Printf.printf \"%d\\n\"\n\n"
  },
  {
    "language": "OCaml",
    "code": "open Printf\nopen Scanf\n\nmodule P = struct\n  type path = Len of int | Inf | Unk\n\n  let min l1 l2 =\n    match l1, l2 with\n      Len x, Len y when x < y -> Len x\n    | Len x, Len y -> Len y\n    | Len x, _ -> Len x\n    | _, Len y -> Len y\n    | _, _ -> Inf\n                \n  let add l1 l2 =\n    match l1, l2 with\n      Len x, Len y -> Len (x + y)\n    | _, _ -> Inf\n                \n  let get = function\n      Len x -> x\n    | Inf -> (-1)\n    | _ -> failwith \"get\"\nend\n             \nlet () =\n  let nv, ne = scanf \"%d %d \" (fun x y -> (x, y)) in\n  let g = Array.make_matrix nv nv P.Inf in\n  let memo = Array.make_matrix (1 lsl nv) nv P.Unk in\n  let set_g n =\n    let rec loop x =\n      if x = 0 then ()\n      else let s, t, d = scanf \"%d %d %d \" (fun x y z -> (x, y, z)) in\n           g.(s).(t) <- P.Len d;\n           loop (x-1) in\n    loop n in\n  let rec search s v =\n    match memo.(s).(v) with\n      P.Unk -> \n      let rec loop u l =\n        if u = nv then l\n        else\n          if s lsr u land 1 = 0 then loop (u+1) (P.min l (P.add g.(v).(u) (search (s lor (1 lsl u)) u)))\n          else loop (u+1) l\n      in\n      let ml = loop 0 P.Inf in\n      memo.(s).(v) <- ml; ml\n    | x -> x in\n  set_g ne;\n  memo.((1 lsl nv) - 1 ).(0) <- P.Len 0;\n  printf \"%d\\n\" (P.get (search 0 0))"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.array;\n\nenum VMAX = 15 + 1;\nenum INF = 1 << 29;\n\nint[VMAX][VMAX] table;\nint[1<<VMAX][VMAX] dp;\nint V, E;\n\nint solve(int S, int v) {\n    if ( dp[v][S] >= 0 ) {\n        return dp[v][S];\n    }\n\n    if ( S == (1 << V) - 1 && v == 0 ) {\n        return dp[v][S] = 0;\n    }\n\n    int tmp = INF;\n    for( int u=0; u<V; ++u ) {\n        if ( !( S >> u & 1 ) ) {\n            // goto u from v\n            tmp = min(tmp, solve(S | 1 << u, u) + table[u][v]);\n        }\n    }\n\n    return dp[v][S] = tmp;\n}\n\nvoid main() {\n    fill(table[0..$][0..$], INF);\n\n    auto ss = readln.chomp.split(\" \").map!(to!int).array;\n    V = ss[0];\n    E = ss[1];\n\n    for( int i=0; i<E; ++i ) {\n        auto sss = readln.chomp.split(\" \").map!(to!int).array;\n        immutable start = sss[0], end = sss[1], cost = sss[2];\n        table[end][start] = cost;\n    }\n\n\n    fill(dp[0..$][0..$], -1);\n\n    immutable ans = solve(0, 0);\n    (ans == INF ? -1 : ans).writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.array;\n\nenum VMAX = 15 + 1;\nenum INF = 1 << 29;\n\nint[VMAX][VMAX] table;\nint[1<<VMAX][VMAX] dp;\nint V, E;\n\nint solve(int S, int v) {\n    if ( dp[v][S] >= 0 ) {\n        return dp[v][S];\n    }\n\n    if ( S == (1 << V) - 1 && v == 0 ) {\n        return dp[v][S] = 0;\n    }\n\n    int tmp = INF;\n    for( int u=0; u<V; ++u ) {\n        if ( !( S >> u & 1 ) ) {\n            // goto u from v\n            tmp = min(tmp, solve(S | 1 << u, u) + table[u][v]);\n        }\n    }\n\n    return dp[v][S] = tmp;\n}\n\nvoid main() {\n    fill(table[0..$][0..$], INF);\n\n    auto ss = readln.chomp.split(\" \").map!(to!int).array;\n    V = ss[0];\n    E = ss[1];\n\n    for( int i=0; i<E; ++i ) {\n        auto sss = readln.chomp.split(\" \").map!(to!int).array;\n        immutable start = sss[0], end = sss[1], cost = sss[2];\n        table[end][start] = cost;\n    }\n\n\n    fill(dp[0..$][0..$], -1);\n\n    solve(0, 0).writeln;\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.range;\nimport std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, std.random, core.bitop;\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\nbool chmin(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x > arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\nbool chmax(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x < arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\n\n\nvoid main() {\n    int N, M;\n    scan(N, M);\n\n    auto cost = new int[][](N, N);\n    fillAll(cost, inf);\n    foreach (i ; 0 .. M) {\n        int u, v, d;\n        scan(u, v, d);\n        cost[u][v] = d;\n    }\n\n    auto dp = new int[][](1 << N, N);\n    fillAll(dp, inf);\n    foreach (i ; 1 .. N) {\n        dp[1 << i][i] = cost[0][i];\n    }\n\n    foreach (mask ; 0 .. 1 << N) {\n        foreach (u ; 0 .. N) if (mask & 1 << u) {\n            auto sub = mask ^ 1 << u;\n            foreach (v ; 0 .. N) if (sub & 1 << v) {\n                chmin(dp[mask][u], dp[sub][v] + cost[v][u]);\n            }\n        }\n    }\n\n    auto ans = dp[(1 << N) - 1][0];\n    if (ans == inf) ans = -1;\n    writeln(ans);\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nalias P = Tuple!(int, \"to\", int, \"d\");\n\nvoid main()\n{\n    auto ve = readln.split.to!(int[]);\n    auto V = ve[0];\n    auto E = ve[1];\n\n    P[][] ps;\n    ps.length = V;\n    foreach (_; 0..E) {\n        auto std = readln.split.to!(int[]);\n        auto s = std[0];\n        auto t = std[1];\n        auto d = std[2];\n        ps[s] ~= P(t, d);\n    }\n\n    auto DP = new int[][][](V, V, 1<<V);\n    foreach (ref dp; DP) foreach (ref dp2; dp) dp2[] = -1;\n\n    int solve(int i, int f, uint s) {\n        if (s == (1<<V)-1) {\n            foreach (n; ps[i]) if (n.to == f) return n.d;\n            return int.max/3;\n        }\n        if (DP[i][f][s] == -1) {\n            auto r = int.max/2;\n            foreach (n; ps[i]) if (!(s & (1<<n.to))) {\n                r = min(r, solve(n.to, f, s | (1<<n.to)) + n.d);\n            }\n            DP[i][f][s] = r;\n        }\n        return DP[i][f][s];\n    }\n    auto r = int.max;\n    foreach (i; 0..V) r = min(r, solve(i, i, 1<<i));\n    if (r > 15000) r = -1;\n    writeln(r);\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.array;\n\nenum VMAX = 15 + 1;\nenum INF = 1 << 29;\n\nint[VMAX][VMAX] table;\nint[1<<VMAX][VMAX] dp;\nint V, E;\n\nint solve(int S, int v) {\n    if ( dp[v][S] >= 0 ) {\n        return dp[v][S];\n    }\n\n    if ( S == (1 << V) - 1 && v == 0 ) {\n        return dp[v][S] = 0;\n    }\n\n    int tmp = INF;\n    for( int u=0; u<V; ++u ) {\n        if ( !( S >> u & 1 ) ) {\n            // goto u from v\n            tmp = min(tmp, solve(S | 1 << u, u) + table[u][v]);\n        }\n    }\n\n    return dp[v][S] = tmp;\n}\n\nvoid main() {\n    fill(table[0..$][0..$], INF);\n\n    immutable ss = readln.chomp.split(\" \").map!(to!int).array;\n    V = ss[0];\n    E = ss[1];\n\n    for( int i=0; i<E; ++i ) {\n        immutable sss = readln.chomp.split(\" \").map!(to!int).array;\n        immutable start = sss[0], end = sss[1], cost = sss[2];\n        table[end][start] = cost;\n    }\n\n\n    fill(dp[0..$][0..$], -1);\n\n    solve(0, 0).writeln;\n\n}"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 10\nv, e = map(int, input().split())\nadj = [[INF] * v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    adj[s][t] = d\n\nmem = {}\nend = 2 ** v - 1\ndef minCost(state, pos):\n    if (state, pos) in mem:\n        return mem[(state, pos)]\n\n    if state == end:\n        return adj[pos][0]\n\n    mask = 1\n    ret = INF\n    for to in range(v):\n        if mask & state:\n            mask <<= 1\n            continue\n\n        ret = min(ret, adj[pos][to] + minCost(state | mask, to))\n        mask <<= 1\n\n    mem[(state, pos)] = ret\n    return ret\n\nresult = minCost(1, 0)\nif result >= INF:\n    print(-1)\nelse:\n    print(result)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    V, E = map(int, readline().split())\n    dist = [[INF] * V for _ in range(V)]\n    for i in range(E):\n        u, v, cost = map(int, readline().split())\n        dist[u][v] = cost\n    dp = [[-1] * V for _ in range(1<<V)]\n\n    def rec(s, v, dp):\n        if dp[s][v] >= 0:\n            return dp[s][v]\n\n        if s == ((1 << V) - 1) and v == 0:\n            dp[s][v] = 0\n            return 0\n\n        res = INF\n        for u in range(V):\n            if ((s >> u) & 1) == 0:\n                res = min(res, rec(s | (1 << u), u, dp) + dist[v][u])\n        dp[s][v] = res\n        return res\n\n    ans = rec(0, 0, dp)\n    if ans==INF:\n        print(-1)\n    else:\n        print(ans)\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "# ハミルトン閉路はどこから初めても答えは変わらない\nV, E = map(int, input().split())\nINF = 10**18\ndist = [[INF] * V for _ in range(V)]\nfor _ in range(E):\n  s, t, d = map(int, input().split())\n  dist[s][t] = d\n  \n# dp[i][j]:= 状態i(2**V)にするための距離の最小値\n# 最後に訪れたのがj\ndp = [[INF] * V for _ in range(2**V)]\n\n# 始点を0とする\ndp[0][0] = 0\n\nfor s in range(2**V):# 現在の状態\n  for j in range(V):# 次の頂点\n    if (s >> j & 1)==0:# jが集合Sに含まれない\n      for i in range(V):# 今いる頂点\n        if i != j:\n          dp[s|1<<j][j] = min(dp[s|1<<j][j],dp[s][i]+dist[i][j])\n\nprint(-1) if dp[2**V-1][0] == INF else print(dp[2**V-1][0])\n"
  },
  {
    "language": "Python",
    "code": "def TS(G,v,e):\n    INF = 16000\n    DP = [[INF for _ in range(v)] for _ in range(2**v)]\n    #DP[i][j]:訪問済みエリアのリストがiでjにいるような最短距離\n    DP[0][0] = 0\n    #   どれも訪問してない状態は00...0(長さv)として訪問済みを表現\n    for i in range(2**v):\n        for j in range(v):\n            for k in range(v):\n                if i ^ 2**k < i and j != k \\\n                and DP[i ^ 2**k][k] + G[k][j] < DP[i][j]:\n                    DP[i][j] = DP[i ^ 2**k][k] + G[k][j]\n\n    if DP[2**v-1][0] != INF:\n        return DP[2**v-1][0]\n    else:\n        return -1\n\ndef main():\n    v,e = map(int,input().split())\n    INF = 16000\n    G = [[INF for _ in range(v)] for _ in range(v)]\n    for i in range(e):\n        s,t,d = map(int,input().split())\n        G[s][t] = d\n\n    print(TS(G,v,e))\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import functools\n\n\n@functools.lru_cache(maxsize=None)\ndef rec(state, v):\n    if state == (1 << V) - 1 and v == 0:\n        return 0\n    ret = INF\n    for i, w in enumerate(A[v]):\n        if not (state >> i & 1):\n            ret = min(ret, rec(state | 1 << i, i) + w)\n    return ret\n\nINF = 10**6\nV, E = map(int, input().split())\nA = [[INF]*V for _ in range(V)]\nfor _ in range(E):\n    s, t, w = map(int, input().split())\n    A[s][t] = w\nans = rec(0, 0)\nprint(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "ii = lambda : int(input())\nmi = lambda : map(int,input().split())\nli = lambda : list(map(int,input().split()))\n\n\nv,e = mi()\nsb = [[]for i in range(e)]\nub = [[]for i in range(e)]\nw = [[float('inf')] * v for i in range(v)]\ndp = [[-1] * v for i in range(2**v +1) ] \n\n\nfor i in range(e):\n    s,t,d = mi()\n    sb[s].append(t)\n    w[s][t] = d\n\ndef rec(s,p,dp):\n    if dp[s][p] >0:\n        return dp[s][p]\n    \n    if s == (1<<v)-1 and p == 0:\n        dp[s][v-1] = 0\n        return 0\n\n    res = float('inf')\n    for i in sb[p]:\n        if (s >> i&1) == 0:\n            a = rec(s|(1<<i), i,dp) + w[p][i]\n            res = min(res, a)\n    \n    dp[s][p] = res\n    return res\n\nif v >= 3 and e >= 3:\n    ans = rec(0,0,dp)\nelse:\n    ans = -1\n\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nV, E = map(int, readline().split())\ng = [[] for i in xrange(V)]\ncost = {}\nto = [0]*V\nfor i in xrange(E):\n    s, t, d = map(int, readline().split())\n    g[s].append((t, d))\n    cost[s,t] = d\n    to[s] |= 1 << t\nget = cost.get\nINF = 10**9\nALL = 2**V-1\ndp = {}\nstart = -1\ndef dfs(state, v):\n    key = (state, v)\n    if key in dp: return dp[key]\n    if state == ALL:\n        res = get((v, start), INF)\n        dp[key] = res\n        return res\n    if state & to[v] != to[v]:\n        res = min((dfs(state | (1 << t), t) + d for t, d in g[v] if not state & (1 << t)))\n    else:\n        res = INF\n    dp[key] = res\n    return res\ndef solve(v):\n    global dp, start\n    dp = {}\n    start = v\n    return dfs(1<<v, v)\nres = min(solve(v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys, math, itertools, collections, bisect\ninput = lambda: sys.stdin.buffer.readline().rstrip().decode('utf-8')\ninf = float('inf') ;mod = 10**9+7\nmans = inf ;ans = 0 ;count = 0 ;pro = 1\n\nv,e=map(int,input().split())\nG=[[] for i in range(v)]\nfor i in range(e):\n    s,t,d=map(int,input().split())\n    G[s].append((t,d))\ndp=[[inf]*v for i in range(2**v)]\ndp[1][0]=0\nfor bit in range(1,2**v):\n    for i in range(v):\n        if dp[bit][i]==inf: continue\n        for gi,di in G[i]:\n            if not (bit >> gi & 1):\n                dp[bit|1<<gi][gi]=min(dp[bit|1<<gi][gi],dp[bit][i]+di)\n            if bit == (1 << v) - 1 and gi == 0:\n                dp[bit][0] = min (dp[bit][0],dp[bit][i]+di)\nprint(dp[2**v-1][0] if dp[2**v-1][0]!=inf else -1)\n# print(*dp,sep=\"\\n\")\n# print(*G,sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "max_d = 15001\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nD = [[max_d] * V for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    D[s][t] = d\n\n# Full search with bit mask\ndef tsp(v, b):\n    if b == (1 << V) - 1:\n        return D[v][0]\n    \n    res = max_d\n    for t, d in enumerate(D[v]):\n        if b & (1 << t) or d == max_d:\n            continue\n        res = min(res, d + tsp(t, b | (1 << t)))\n        \n    return res\n\n# Output\nans = tsp(0, 1)\n\nif ans == max_d:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\ncost = {}\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\n    cost[s,t] = d\nget = cost.get\nINF = 10**9\nALL = 2**V-1\ndp = [[-1]*V for i in xrange(2**V)]\ndef dfs(state, v, s):\n    if dp[state][v] != -1:\n        return dp[state][v]\n    if state == ALL:\n        res = get((v, s), INF)\n        dp[state][v] = res\n        return res\n    res = INF\n    for t, d in g[v]:\n        if not state & (1 << t):\n            res = min(res, dfs(state | (1 << t), t, s) + d)\n    dp[state][v] = res\n    return res\ndef solve(v):\n    global dp\n    dp = [[-1]*V for i in xrange(2**V)]\n    return dfs(1<<v, v, v)\nres = min(solve(v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "# DPL_2_A - 巡回セールスマン問題\n\nimport sys\nsys.setrecursionlimit(10 ** 8)\n\nV, E = map(int, sys.stdin.readline().strip().split())\nd = [[float('inf')] * V for _ in range(V)]\nfor _ in range(E):\n    s, t, _d = map(int, sys.stdin.readline().strip().split())\n    d[s][t] = _d\n\n# dp 初期化 -----------------\ndp = [[float('inf')] * V for _ in range(1 << V)]  # 1 << V は 2 ** V に同じ\ndp[0][0] = 0  # 頂点 0 からスタートするとする\n\n\ndef res(s, v):\n    # s: すでに訪問した街の集合, v: 今いる街の集合, dp: 動的計画法のテーブル\n    # 0 から出発して s, v　を満たすコストを返す関数\n\n    if dp[s][v] == -1:  # 到達不可能ならば\n        return float('inf')\n    elif dp[s][v] != float('inf'):\n        return dp[s][v]\n    elif (s >> v) & 1 == 0:  # 集合 s に頂点 v が含まれていないならば\n        dp[s][v] = -1\n        return float('inf')\n\n    ans = float('inf')\n    for u in range(V):\n        # if (s >> u) & 1 == 1:\n        # print(f's: {format(s ^ (1 << v), \"b\")}, u: {u}')\n        # print(f'{d[u][v]}')\n        ans = min(ans, res(s ^ (1 << v), u) + d[u][v])\n\n    if ans == float('inf'):  # 到達不可能ならば　\n        dp[s][v] = -1\n    else:\n        dp[s][v] = ans\n\n    return ans\n\n\nres((1 << V) - 1, 0)\n\n# for i in range(len(dp)):\n#     print(dp[i])\nprint(dp[-1][0])\n\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\nINF = 10**9\ndp = [[-1]*V for i in xrange(2**V)]\ntmp = {}\ndef dfs(state, v, s):\n    if dp[state][v] != -1:\n        return dp[state][v]\n    if state == 2**V-1:\n        for t, d in g[v]:\n            if t==s:\n                dp[state][v] = d\n                return d\n        return INF\n    res = INF\n    idx = -1\n    for t, d in g[v]:\n        if state & (1 << t):\n            continue\n        r = dfs(state | (1 << t), t, s) + d\n        if r < res:\n            idx = t\n        res = min(res, r)\n\n    tmp[state, v] = (idx, res)\n\n    return res\ndef solve(v):\n    global dp\n    dp = [[-1]*V for i in xrange(2**V)]\n    return dfs(1<<v, v, v)\nres = min(solve(v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\ngraph = [[] for _ in range(V)]\n\nfor _ in range(E):\n    s, t, d = map(int, input().split())\n    graph[s].append((t, d))\n\ncase = 2**V\nINF = 10**7\n\ndp = [[-1]*case for _ in range(V)]\n\ndef dfs(now, dist, checked):\n    if checked==(1<<V)-1:\n        if now==s:\n            return dist\n        else:\n            return INF\n    r = dp[now][checked]\n    if r!=-1:\n        return r+dist\n    ret = INF\n    try:\n        for q, d in graph[now]:\n            if not (checked>>q)&1 and dist+d<ans:\n                ret = min(ret, dfs(q, dist+d, checked|(1<<q)))\n    except:\n        return ret\n    dp[now][checked] = ret - dist\n    return ret\n\nans = INF\n# for i in range(V):\ns = 0\nans = min(ans, dfs(0, 0, 0))\n\nif ans<=10**6:\n    print(ans)\nelse:\n    print(-1)\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split())\nL=[[]for i in range(N+1)]\nfor i in range(M):\n    s,t,d=map(int,input().split())\n    L[s].append([t,d])\n\nD=[{}for i in range(N+1)]\nD[0][(0,0)]=0\n#print(D)\n\n\nfor i in range(1,N+1):\n    for k,v in D[i-1].items():\n        P,dist=k\n        for to,d in L[P]:\n            Ndist=dist|1<<to\n            if Ndist!=dist:\n                if (to,Ndist) not in D[i]:\n                    D[i][(to,Ndist)]=v+d\n                else:\n                    D[i][(to,Ndist)]=min(v+d,D[i][(to,Ndist)])\n#print(D)\nif len(D[-1])==0:\n    print(-1)\nelse:\n    for k,v in D[-1].items():\n        if k[0]==0:\n            print(v)\n            exit()\n    print(-1)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,m = LI()\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = LI()\n        v[a].append((b,c))\n\n    B = 1<<n\n    dp = [[float(\"inf\")]*n for i in range(B)]\n    for i,c in v[0]:\n        dp[1<<i][i] = c\n    for b in range(B):\n        for i in range(n):\n            if not b&(1<<i):\n                continue\n            for j,c in v[i]:\n                if b&(1<<j):\n                    continue\n                nb = b|(1<<j)\n                nd = dp[b][i]+c\n                if nd < dp[nb][j]:\n                    dp[nb][j] = nd\n    ans = dp[B-1][0]\n    if ans == float(\"inf\"):\n        print(-1)\n    else:\n        print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "v, e = map(int, input().split())\nG = [[float('inf')]*v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, input().split())            \n    G[s][t] = d\ndist = [[float(\"inf\")]*v for _ in range(1<<v)]\ndist[1][0] = 0\nfor s in range(1<<v):\n    for i in range(v):\n        for j in range(v):\n            # print(bin(s), dist[(1<<i)|s][i], dist[s][j], i, j, G[j][i])\n            if (s>>i)&1 == 1:continue\n            if (s>>j)&1 == 0:continue\n            dist[(1<<i|s)][i] = min(dist[1<<i|s][i], dist[s][j] + G[j][i])\n\nans = float('inf')\nfor i in range(v):\n    ans = min(ans, dist[(1<<v)-1][i] + G[i][0])\nprint(ans if ans != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "def read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\ndef rec(state, v):\n    if dp[state][v] >= 0:\n        return dp[state][v]\n    if (1 << V) - 1 == state and v == 0:\n        dp[state][0] = 0\n        return 0\n\n    ret = INF\n    for to, cost in edge[v]:\n        if not (state >> to & 1):\n            ret = min(ret, rec(state | 1 << to, to) + cost)\n    dp[state][v] = ret\n    return ret\n\nINF = 1<<27\nV, E = read_list(int)\nedge = [[] for _ in range(V)]\nfor _ in range(E):\n    fr, to, cost = map(int, input().split())\n    edge[fr].append((to, cost))\n\ndp = [[-1] * V for _ in range(1<<V)]\nprint(dp[0][0] if rec(0, 0) != INF else -1)"
  },
  {
    "language": "Python",
    "code": "n,w = map(int,input().split())\n\n#d[i][j]:i→jへの距離\nd = [[float(\"inf\")]*n for i in range(n)]\nfor i in range(w):\n   x,y,z = map(int,input().split())\n   d[x][y] = z \n\n\ndp = [[-1] * n for i in range(1<<n)]\n\n\n#訪れた集合がs、今いる点がvの時０に戻る最短経路\ndef rec(s,v,dp):\n    if dp[s][v] >= 0:\n        return dp[s][v]\n        \n    if s == (1<<n)-1 and v == 0:\n        #全ての頂点を訪れた(s = 11...11 and v = 0)\n        dp[s][v] = 0\n        return 0\n    \n    res = float(\"inf\")\n    for u in range(n):\n        if (s>>u&1) == 0:\n            #uに訪れていない時(uの箇所が0の時),次はuとすると\n            res = min(res,rec(s|(1<<u),u,dp)+d[v][u])\n            \n    dp[s][v] = res\n    return res\nif rec(0,0,dp) != float(\"inf\"):\n    ans = rec(0,0,dp)\nelse:\n    ans = -1\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "inf=float(\"inf\")\nv,e=map(int,input().split())\nSTD=[list(map(int,input().split())) for _ in range(e)]\n\nD=[[inf for _ in range(v)] for _ in range(v)]\nfor s,t,d in STD:\n    D[s][t]=d\n\nDP=[[-1 for _ in range(v)] for _ in range(1<<v)]\n\n\ndef bitDP(s,g,DP):\n    if DP[s][g]>=0:return DP[s][g]\n    if s==(1<<v)-1 and g==0:\n        DP[s][g]=0\n        return 0\n\n    ans=inf\n    for i in range(v):\n        if (s>>i & 1)==0:\n            ans=min(ans,bitDP(s|(1<<i),i,DP)+D[g][i])\n    DP[s][g]=ans\n    return ans\n\n\nans=bitDP(0,0,DP)\nprint(ans if ans!=inf else -1)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nINF = float('inf')\nG = [[INF] * N for i in range(N)]\nfor i in range(M):\n    s, t, d = map(int, input().split())\n    G[s][t] = d\n\n\ndp = [[INF] * N for i in range(1 << N)]\ndp[1][0] = 0\nfor bs in range(1 << N):\n    for n in range(N):\n        if dp[bs][n] == INF:\n            continue\n        for to in range(N):\n            if bs & (1 << to):\n                continue\n            next_index = bs | (1 << to)\n            dp[next_index][to] = min(dp[next_index][to], dp[bs][n] + G[n][to])\n\n\nans = INF\nfor fr in range(1, N):\n    ans = min(ans, dp[-1][fr] + G[fr][0])\nprint(ans if ans != INF else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\ncost = {}\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\n    cost[s,t] = d\nget = cost.get\nINF = 10**9\nALL = 2**V-1\ndp = {}\ndef dfs(state, v, s):\n    key = (state, v)\n    if key in dp:\n        return dp[key]\n    if state == ALL:\n        res = get((v, s), INF)\n        dp[key] = res\n        return res\n    res = INF\n    for t, d in g[v]:\n        if not state & (1 << t):\n            res = min(res, dfs(state | (1 << t), t, s) + d)\n    dp[key] = res\n    return res\ndef solve(v):\n    global dp\n    dp = {}\n    return dfs(1<<v, v, v)\nres = min(solve(v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nv, e = map(int, input().split())\n\nlinks = [set() for _ in range(v)]\nbests = [None] * (1 << v)\n\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    links[s].add((t, d))\n\nbests[0] = {0: 0}\n\nfor visited, best in enumerate(bests):\n    if best is None:\n        continue\n    for last, cost in best.items():\n        for t, d in links[last]:\n            new_visited = visited | (1 << t)\n            if visited == new_visited:\n                continue\n            new_best = bests[new_visited]\n            if new_best is None:\n                bests[new_visited] = defaultdict(lambda: 15001, [(t, cost + d)])\n            else:\n                new_best[t] = min(new_best[t], cost + d)\n\nresult = bests[-1]\nprint(-1 if result is None else -1 if result[0] == 15001 else result[0])"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 70\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "def dp(S, v):\n    if memo[S][v] != -1:\n        return memo[S][v]\n    if not S&(1<<v):\n        memo[S][v] = inf\n        return inf\n    res = inf\n    for i in range(n):\n        if S&(1<<i) and d[i][v] != inf and i != v:\n            res = min(res, dp(S&(~(1<<v)), i)+d[i][v])\n    memo[S][v] = res\n    return res\n\nn, m = map(int, input().split())\ninf = 10**10\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(m):\n    s, t, dis = map(int, input().split())\n    d[s][t] = dis\n\nmemo = [[-1 for i in range(n)] for j in range(2**n)]\nmemo[1][0] = 0\n\nans = min([dp(2**n-1, v)+d[v][0] for v in range(n)])\nprint(-1 if ans>=inf else ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nINF = float('inf')\nN, M = map(int, input().split())\ncost = [[INF]*N for _ in [0]*N]\nto = [set() for _ in [0]*N]\nfor _ in [0]*M:\n    a, b, c = map(int, input().split())\n    cost[a][b] = c\n    to[b].add(a)\n\nK = 1 << N\ndp = [[INF]*N for _ in range(K)]\ndp[K-1][0] = 0\n\nfor bit in range(K-1, -1, -1):\n    for i in range(N):\n        tmp = [dp[bit|1<<j][j]+cost[j][i] for j in to[i] if bit>>j&1==0]\n        if tmp:\n            dist = min(tmp)\n            if dp[bit][i] > dist:\n                dp[bit][i] = dist\n\nans = dp[0][0]\nprint(ans if ans < INF else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "#標準入力\nV, E = map(int, input().split())\ndist = [[float(\"inf\")] * (V + 1) for i in range(V + 1)]\nfor i in range(E):\n  s, t, d = map(int, input().split())\n  dist[s][t] = d\n  \nfor i in range(V):  \n  dist[i][i] = 0\n  \n#print(dist)\n#2 ** 15 = 1024 * 16 = 16384\ndp = [[-1] * (V + 1) for i in range(2 ** V + 1)]\n\ndef rec(bit, v):\n  #すでに探索済みだったらリターン\n  if dp[bit][v] != -1:\n    return dp[bit][v]\n  \n  #初期値\n  if bit == (1 << 0):\n    dp[bit][0] = 0\n    return 0\n  \n  res = float(\"inf\")\n  prev_bit = bit & ~(1 << v)\n  \n  for i in range(V):\n    if not (prev_bit & (1 << i)):\n      continue\n    else:\n      res = min(res, rec(prev_bit, i) + dist[i][v])\n  \n  dp[bit][v] = res\n  return res\n\nans = float(\"inf\")\nfor i in range(V):\n  ans = min(ans, rec((1 << V) - 1, i) + dist[i][0])\n  #print(dp)\n\nif ans >= 1000000:\n  print(-1)\nelse:\n  print(ans)\n#print(dp)\n"
  },
  {
    "language": "Python",
    "code": "V,E=map(int,input().split())\nd=[[float('inf')]*V for _ in range(V)]\nfor i in range(E):\n    com=list(map(int,input().split()))\n    d[com[0]][com[1]]=com[2]\nfor i in range(V):\n    d[i][i]=0\nS=pow(2,V-1)\ndp=[[0]+[float('inf')]*(S-1) for _ in range(V)]\nfor i in range(1,V):\n    dp[i][1<<(i-1)]=d[0][i]\nfor i in range(1,S):\n    for v in range(1,V):\n        if i>>(v-1) & 1:\n            #print(i,v)\n            #print(*dp,sep='\\n')\n            dp[v][i]=min([float('inf')]+[dp[v][i]]+[dp[u][i-(1<<(v-1))]+d[u][v] for u in range(1,V) if i>>(u-1) & 1 and u!=v])\nans=min([dp[i][S-1]+d[i][0] for i in range(V)])\nif ans==float('inf'):\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom math import isinf\n\nreadline = stdin.readline\n\n\nmin_cost = float('inf')\n\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    dfs(g, 0, 0, set(range(1, v)))\n    global min_cost\n    print(-1 if isinf(min_cost) else min_cost)\n\n\ndef dfs(g, cost, last, vs):\n    global min_cost\n    if min_cost < cost:\n        return\n    if vs:\n        for v in vs:\n            if isinf(g[last][v]):\n                continue\n            dfs(g, cost + g[last][v], v, vs - {v})\n    elif min_cost > cost + g[last][0]:\n        min_cost = cost + g[last][0]\n\nmain()"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\nINF = 1e9\ndp = [[INF]*V for i in xrange(2**V)]\ndef dfs(state, v, s):\n    if state == 2**V-1:\n        return 0\n    if dp[state][v] != INF:\n        return dp[state][v]\n    res = INF\n    for t, d in g[v]:\n        if state & (1 << t):\n            continue\n        r = dfs(state | (1 << t), t, s) + d\n        res = min(res, r)\n    dp[state][v] = res\n    return res\nres = min(dfs(0, v, v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\n \nsys.setrecursionlimit(10 ** 7)\n \nfrom collections import defaultdict\n \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn,w = map(int,input().split())\n\n#d[i][j]:i→jへの距離\nd = [[float(\"inf\")]*n for i in range(n)]\nfor i in range(w):\n   x,y,z = map(int,input().split())\n   d[x][y] = z \n\n\ndp = [[-1] * n for i in range(1<<n)]\n\n\n#訪れた集合がs、今いる点がvの時０に戻る最短経路\ndef rec(s,v):\n    if dp[s][v] != -1:\n        return dp[s][v]\n        \n    if s == (1<<n)-1 and v == 0:\n        #全ての頂点を訪れた(s = 11...11 and v = 0)\n        dp[s][v] = 0\n        return 0\n    \n    res = float(\"inf\")\n    for u in range(n):\n        if (s>>u&1) == 0:\n            #uに訪れていない時(uの箇所が0の時),次はuとすると\n            res = min(res,rec(s|(1<<u),u)+d[v][u])\n            \n    dp[s][v] = res\n    return res\nans = rec(0,0)\nif ans == float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nmin_cost = float('inf')\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    dfs(g, 0, 0, set(range(1, v)))\n    global min_cost\n    print(-1 if isinf(min_cost) else min_cost)\n\n\ndef dfs(g, cost, last, vs):\n    global min_cost\n    if min_cost <= cost:return\n    if vs:\n        for v in vs:dfs(g, cost + g[last][v], v, vs - {v})\n    elif min_cost > cost + g[last][0]:min_cost = cost + g[last][0]\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def tsp(matrix):\n    INF = float(\"inf\")\n    n = len(matrix)\n\n    # dp[bit_state][i] := すでにbit_stateの状態を訪れていて、\n    #                     最後に訪問したのがi番目のときの最小値\n    dp = [[INF]*n for i in range(1 << n)]\n    dp[1 << 0][0] = 0\n \n    for bit_state in range(1 << n):\n        for i in range(n):\n            # bit_stateにiを含んでいる\n            if (bit_state >> i) & 1:\n                for j in range(n):\n                    # bit_stateにjを含んでいない\n                    if not ((bit_state >> j) & 1):\n                        dp[bit_state|(1 << j)][j] = min(dp[bit_state|(1 << j)][j], dp[bit_state][i] + matrix[i][j])\n    ans = INF\n    for i in range(n):\n        ans = min(dp[(1 << n) - 1][i] + matrix[i][0], ans)\n    return ans\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(m)]\nINF = float(\"inf\")\n\nmatrix = [[INF]*n for i in range(n)]\nfor i in range(m):\n    a, b, cost = info[i]\n    matrix[a][b] = cost\nfor i in range(n):\n    matrix[i][i] = 0\n\nans = tsp(matrix)\nif ans == INF:\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 60\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from heapq import heappop, heappush\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    for i in range(V):\n        q = [(0, i, {i})]\n        while q:\n            cost, v, visited = heappop(q)\n            if len(visited) < V:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        heappush(q, (cost+d_cost, dest, visited | {dest}))\n            elif len(visited) == V:\n                for dest, d_cost in edges[v]:\n                    if dest == i:\n                        heappush(q, (cost+d_cost, i, visited | {-1}))\n            else:\n                if result > cost:\n                    result = cost\n                break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 80\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nmax_d = 1001\nadj = [[max_d] * V for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    adj[s][t] = d\n\nmax_path = 15001\ndp = [[max_path] * (1 << V) for i in range(V)]\ndp[0][0] = 0\n\n# Full search with bit mask\ndef tsp(v, b):\n    if b == (1 << V) - 1:\n        return None\n    \n    for t, d in enumerate(adj[v]):\n        if b & (1 << t) or d == max_d:\n            continue\n        mask = b | (1 << t)\n        t_d = dp[v][b] + adj[v][t]\n        if dp[t][mask] > t_d:\n            dp[t][mask] = t_d\n            tsp(t, mask)\n\n# Output\ntsp(0, 0)\n\nans = dp[0][-1]\nif ans == max_path:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nV, E = map(int, input().split())\n\n#dist[i][j]: i -> jへの距離\ndist = [[float(\"inf\")] * V for i in range(V)]\nfor _ in range(E):\n    s, t, d = map(int, input().split())\n    dist[s][t] = d\n\ndp = [[-1] * V for i in range(2**V)]\n\n#dp[s][v]: 集合sを経由して今vに居るとき、始点に戻る最短経路長\ndef rec(s, v, dp):\n    #　計算済みかどうか\n    if dp[s][v] >= 0:\n        return dp[s][v]\n    \n    #　すべての頂点を訪れたか\n    if s == 2**V - 1 and v == 0:\n        dp[s][v] = 0\n        return 0\n    \n    res = 10**100\n    for i in range(V):\n        if (s>>i & 1) == 0:\n            # i の箇所が訪れていないとき（0の時）次はiに行く\n            # s|(1<<i) は、今まで訪れたsに加えて、頂点iをおとずれたことを加えた和集合\n            res = min(res, rec(s|(1<<i), i, dp) + dist[v][i])\n    \n    dp[s][v] = res\n    return dp[s][v]\n\nans = rec(0, 0, dp)\nif ans == 10**100:\n    ans = -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\nN,M = inpl()\nlines = defaultdict(set)\nfor _ in range(M):\n    s,t,d = inpl()\n    lines[s].add((t,d))\n\n\nS = 0\ndp = [[INF]*N for _ in range(1<<(N+1)-1)]\ndp[0][S] = 0\nfor bit in range(1<<(N+1)-1):\n    for s in range(N):\n        now = dp[bit][s]\n        for t,c in lines[s]:\n            if bit & (1<<t): # 訪れたことがある\n                continue\n            else:\n                dp[bit+(1<<t)][t] = min(dp[bit+(1<<t)][t],now+c)\n\nans = dp[-1][S]\nif ans == INF:\n    print(-1)\nelse:\n    print(dp[-1][S])\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  V, E = map(int, input().split())\n  INF = float('INF')\n  graph = [[] for _ in range(V)]\n  for i in range(E):\n    s, t, d = map(int, input().split())\n    graph[s].append([t, d])\n  dp = [[INF] * V for _ in range(1<<V)]\n  dp[(1<<V)-1][0] = 0\n  for bit in range((1<<V)-2, -1, -1):\n    for v in range(V):\n      for u, d in graph[v]:\n        if not (bit>>u & 1):\n          dp[bit][v] = min(dp[bit|1<<u][u]+d, dp[bit][v])\n\n  if(dp[0][0] == INF):\n    print(-1)\n  else:\n    print(dp[0][0])\n  \nif __name__ == '__main__':\n\tmain()\n"
  },
  {
    "language": "Python",
    "code": "v,e=map(int,raw_input().split())\ndist=[[float(\"inf\")]*v for _ in xrange(v)]\nfor i in xrange(e):\n    s,t,d=map(int,raw_input().split())\n    dist[s][t]=d\n\ndp=[[float('inf')]*(v) for _ in xrange(1<<v)]\ndp[1][0]=0\nfor i in xrange(1<<v):\n    for j in xrange(v):\n        if dp[i][j]==float('inf'):continue\n        for k in xrange(v):\n            if not (i>>k)&1:\n                nexti=i|1<<k\n                nextdist=dp[i][j]+dist[j][k]\n                dp[nexti][k]=min(dp[nexti][k],nextdist)\n\nans=float('inf')\nfor i in xrange(v):\n    if dp[(1<<v)-1][i]==float('inf'):continue\n    ans=min(ans,dp[(1<<v)-1][i]+dist[i][0])\nif ans==float('inf'):\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "INF=10**18\nn,m=map(int,input().split())\ndist=[[INF for _ in range(n)]for _ in range(n)]\ndp=[[INF for _ in range(n+1)]for _ in  range(1<<n)]\nfor _ in range(m):\n  a,b,c=map(int,input().split())\n  dist[a][b]=c\ndp[(1<<n)-1][0]=0\nfor bit in range((1<<n)-2,-1,-1):\n  for v in range(n):\n    for u in range(n):\n      if not ((bit>>u) & 1):\n        dp[bit][v]=min(dp[bit][v],dp[bit|1<<u][u]+dist[u][v])\nprint(dp[0][0] if dp[0][0]!=INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "def dfs(g, last, vs, first):\n    if vs:return min(g[last][v] + dfs(g, v, vs - {v}, first) for v in vs)\n    else:return g[last][first]\n\nfrom sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nv, e = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    g[s][t] = d\n\ncost = []\nvs = set(range(v))\nsecond = 0\nfor first in range(1, v - 1):\n    if isinf(g[first][second]):continue\n    for third in range(first + 1, v):\n        if isinf(g[second][third]):continue\n        cost.append(g[first][second] + g[second][third] + dfs(g, third, vs - {first,second,third}, first))\n        \nprint(min(cost) if cost else -1)"
  },
  {
    "language": "Python",
    "code": "def read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\ndef rec(state, v):\n    if dp[state][v] >= 0:\n        return dp[state][v]\n    if (1 << V) - 1 == state and v == 0:\n        dp[state][0] = 0\n        return 0\n\n    ret = INF\n    for to, cost in edge[v]:\n        if not (state >> to & 1):\n            ret = min(ret, rec(state | 1 << to, to) + cost)\n    dp[state][v] = ret\n    return ret\n\nINF = float('inf')\nV, E = read_list(int)\nedge = [[] for _ in range(V)]\nfor _ in range(E):\n    fr, to, cost = map(int, input().split())\n    edge[fr].append((to, cost))\n\ndp = [[-1] * V for _ in range(1<<V)]\nprint(dp[0][0] if rec(0, 0) != INF else -1)"
  },
  {
    "language": "Python",
    "code": "def dfs(g, last, vs, first):\n    if vs:return min(g[last][v] + dfs(g, v, vs - {v}, first) for v in vs)\n    else:return g[last][first]\n\nfrom sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nv, e = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    g[s][t] = d\n\ncost = []\nvs = set(range(v))\n\nfirst = 0\nfor second in range(1, v):\n    if isinf(g[first][second]):continue\n    cost.append(g[first][second] + dfs(g, second, vs - {first,second}, first))\n        \nprint(min(cost) if cost else -1)"
  },
  {
    "language": "Python",
    "code": "def salesman(T, now_v, dp, graph, v):\n    if dp[T][now_v] >= 0:\n        return dp[T][now_v]\n    if T == (1 << v) - 1 and now_v == 0:\n        dp[T][now_v] = 0\n        return dp[T][now_v]\n    res = 10 ** 7\n    for i in range(v):\n        if not ((T >> i) & 1):\n            res = min(res, salesman(T | (1 << i), i, dp, graph, v) + graph[now_v][i])\n    dp[T][now_v] = res\n    return dp[T][now_v]\n\n\ndef main():\n    v, e = map(int, input().split())\n    INF = 10 ** 7\n    graph = [[INF for i in range(v)] for j in range(v)]\n    for i in range(e):\n        s, t, d = map(int, input().split())\n        graph[s][t] = d\n    dp = []\n    for i in range(1 << v):\n        dp.append([])\n        for j in range(v):\n            dp[i].append(-1)\n    salesman(0, 0, dp, graph, v)\n    if dp[0][0] >= INF:\n        print(-1)\n    else:\n        print(dp[0][0])\n    \n    \n\n\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    inf = 1000000000\n    n,m = map(int,input().split())\n    d = [[inf]*n for _ in range(n)]\n    for _ in range(m):\n        a,b,c = map(int,input().split())\n        d[a][b] = c\n    dp = [[inf]*n for _ in range(1<<n)]\n    dp[0][0] = 0\n    for bits in range(1<<n):\n        for i in range(n):\n            if bits&(1<<i):continue\n            for j in range(n):\n                dp[(1<<i)|bits][i] = min(dp[(1<<i)|bits][i],dp[bits][j]+d[i][j])\n    if dp[(1<<n)-1][0]==inf:print (-1)\n    else                   :print (dp[(1<<n)-1][0])\n\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nfrom pprint import pprint\nfrom collections import deque, defaultdict\nimport itertools\nimport math\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.buffer.readline\nINF = 10 ** 10\n\nn_nodes, m_edges = map(int, input().split())\ndist = [[INF] * n_nodes for _ in range(n_nodes)]\n\nfor _ in range(m_edges):\n    s, t, d = map(int, input().split())\n    dist[s][t] = d\n\nmemory = {}\nend = 2 ** n_nodes - 1\n\n\ndef rec(state, pos):\n    if (state, pos) in memory:\n        return memory[(state, pos)]\n\n    if state == end:\n        return dist[pos][0]\n\n    mask = 1\n    res = INF\n    for pos_next in range(n_nodes):\n        if mask & state:\n            mask <<= 1\n            continue\n\n        res = min(res, rec(state | mask, pos_next) + dist[pos][pos_next])\n        mask <<= 1\n\n    memory[(state, pos)] = res\n    return res\n\n\nres = rec(1, 0)\nif res == INF:\n    print(-1)\nelse:\n    print(res)\n\n"
  },
  {
    "language": "Python",
    "code": "def read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\nINF = 1<<27\nV, E = read_list(int)\nedge = [[] for _ in range(V)]\nfor _ in range(E):\n    fr, to, cost = map(int, input().split())\n    edge[fr].append((to, cost))\n\ndp = [[INF] * V for _ in range(1<<V)]\ndp[(1 << V) - 1][0] = 0\nfor state in reversed(range((1<<V)-1)):\n    for v in range(V):\n        for to, cost in edge[v]:\n            if not (state >> to & 1):\n                dp[state][v] = min(dp[state][v], dp[state | 1 << to][to] + cost)\nprint(dp[0][0] if dp[0][0] != INF else -1)"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=ja\n\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nV, E = map(int, input().split())\n\ncost = [[float(\"inf\")]*V for _ in range(V)]\nfor _ in range(E):\n    s, t, d = map(int, input().split())\n    cost[s][t] = d\n\ndp = [[float(\"inf\")]*(V) for _ in range((1<<V))]\n\ndp[0][0] = 0                                # どこにも訪れていない状態で、頂点0を出発点とする。\n                                            # 最後に頂点0に戻ってくるために頂点0にフラグは立てないようにしている。\n\nfor S in range(1<<V):\n    for v in range(V):\n        if not (1<<v)&S:                    # vをすでに訪れている場合を除く\n            dp[S|(1<<v)][v] = min(dp[S][u] + cost[u][v] for u in range(V))\n                                            # \"if (1<<u)&S\" が必要に見えるが、Sにuが含まれないようなdpテーブルは、\n                                            # dp[0][0]を除いて全てinfから動かない（漸化式の左辺に現れない）ので、自動的に除かれる。\n                                            # 逆に、\"if (1<<u)&S\"を入れようとすると、初期化を\"dp[1][0]=0\"として、\n                                            # かつ最後に頂点0に戻る場合を別に処理する必要があるので少し面倒。\n\nif dp[(1<<V)-1][0] == float(\"inf\"):\n    print(-1)\nelse:\n    print(dp[(1<<V)-1][0])\n\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\nINF = 1e9\ndp = [[INF]*V for i in xrange(2**V)]\ndef dfs(state, v, cost, s):\n    if state == 2**V-1:\n        for t, d in g[v]:\n            if t==s:\n                return cost+d\n        return INF\n    if dp[state][v] != INF:\n        return dp[state][v]\n    res = INF\n    for t, d in g[v]:\n        if state & (1 << t):\n            continue\n        r = dfs(state | (1 << t), t, cost + d, s)\n        res = min(res, r)\n    dp[state][v] = res\n    return res\nres = min(dfs(0, v, 0, v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\ninf = float('inf')\ngraphs = [[inf for _ in range(V)] for _ in range(V)]\n\n\nfor i in range(E):\n    s, t, d = map(int, input().split())\n    graphs[s][t] = d\n# print(graphs)\n\n\ndps = [[inf for _ in range(V)] for _ in range(1 << V)]\n\ndps[0][0] = 0\n\nfor S in range(1, 1 << V):\n    for i in range(V):\n        # 両方とも1のやつのみ残る。\n        # 1100 と0100(1<<2)だったら0100になる。\n        # 訪問済みであることがこれで確認できる。\n        if S & (1 << i) == 0:\n            continue\n        prev_bit = S - (1 << i)\n        for j in range(V):\n            # print(S, prev_bit, i, j)\n            dps[S][i] = min(dps[S][i], dps[prev_bit][j] + graphs[j][i])\n# print(dps)\nif dps[(1 << V) - 1][0] == inf:\n    print(-1)\nelse:\n    print(dps[(1 << V) - 1][0])\n\n"
  },
  {
    "language": "Python",
    "code": "# from scipy.sparse.csgraph import floyd_warshall\nINF = 100000000\n\n\ndef make_adj_list(vertex, edge):\n    adj_list = []\n    dp = []\n\n    # adj_listの初期化と入力\n    for i in range(vertex):\n        adj_list.append([])\n        for j in range(vertex):\n            if i == j:\n                adj_list[i].append(0)\n            else:\n                adj_list[i].append(INF)\n    for i in range(edge):\n        s, t, cost = map(int, input().split())\n        adj_list[s][t] = cost\n\n    # dpの初期化\n    for i in range(1 << vertex):\n        dp.append([])\n        for j in range(vertex):\n            dp[i].append(-1)\n\n    return adj_list, dp\n\n\ndef cal_min_cost(dp, vertex, edge, d, already, now_v):\n    if dp[already][now_v] >= 0:\n        # すでに通ったことがある場合\n        return dp[already][now_v]\n\n    if already == (1 << vertex) - 1 and now_v == 0:\n        # 全ての頂点を通った\n        dp[already][now_v] = 0\n        return dp[already][now_v]\n\n    res = INF\n    for i in range(vertex):\n        if not already >> i & 1:\n            # 次にiに移動する\n            res = min(res, cal_min_cost(dp, vertex, edge, d,\n                      already | 1 << i, i) + d[now_v][i])\n    dp[already][now_v] = res\n    return dp[already][now_v]\n\n\ndef main():\n    vertex, edge = map(int, input().split())\n    adj_list, dp = make_adj_list(vertex, edge)  # 初期化と入力\n    # d = floyd_warshall(adj_list)  # それぞれの頂点からの最小を求める\n    d = adj_list\n    # for k in range(vertex):\n    #     for i in range(vertex):\n    #         for j in range(vertex):\n    #             d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    # print(d)\n    # 最短距離は頂点のどこからはじめても変わらないので0からスタートとする\n    min_cost = cal_min_cost(dp, vertex, edge, d, 0, 0)  # 計算\n    if min_cost == INF:\n        print(-1)\n    else:\n        print(int(min_cost))\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# テーブル埋め\nINF = float('inf')\nV, E = [int(x) for x in input().split()]\nD = [[INF for _ in range(V)] for _ in range(V)]\nfor i in range(V):\n    D[i][i] = 0\nfor j in range(E):\n    s, t, d = [int(x) for x in input().split()]\n    D[s][t] = d\n\ndp = [[INF for _ in range(V)] for _ in range(1 << V)]\nfor S in range((1 << V) - 1, -1, -1):\n    for v in range(V):\n        if S == (1 << V) - 1:\n            if v == 0:\n                dp[S][v] = 0\n        else:\n            # 次に行くuを決める\n            for u in range(V):\n                if (S >> u) & 1 == 0:\n                    dp[S][v] = min(dp[S][v], D[v][u] + dp[S + (1 << u)][u])\n\nif dp[0][0] == INF:\n    print(-1)\nelse:\n    print(dp[0][0])\n"
  },
  {
    "language": "Python",
    "code": "# https://www.slideshare.net/hcpc_hokudai/advanced-dp-2016 動的計画法の問題の解説がされている 神\n\n# これが比較的わかりやすいかも https://algo-logic.info/bit-dp/\n\n'''\n定式化(本は\"集める\"DPで定義してるが、わかりやすさのため\"配る\"DPで定式化)\n\nノーテーション\nS ... 頂点集合\n| ... 和集合演算子\ndp[S][v] ... 重みの総和の最小。頂点0から頂点集合Sを経由してvに到達する。\n\n更新則\ndp[S|{v}] = min{dp[S][u]+d(u,v) | u∈S} ただしv∉S\n\n初期条件\ndp[∅][0] = 0 #Vはあらゆる集合\ndp[V][u] = INF #ほかはINFで初期化しておく\n\n答え\ndp[すべての要素][0] ... 0からスタートしてすべての要素を使って最後に0に戻るための最小コスト\n'''\n\n# verify https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_2_A\nINF = 2 ** 31\nfrom itertools import product\n\n\ndef solve(n, graph):\n    '''nは頂点数、graphは隣接行列形式'''\n    max_S = 1 << n  # n個のbitを用意するため\n    dp = [[INF] * n for _ in range(max_S)]\n    dp[0][0] = 0\n    for S in range(max_S):\n        for u, v in product(range(n), repeat=2):\n            if (S >> v) & 1 == 1:  # vが訪問済みの場合は飛ばす\n                continue\n            dp[S | (1 << v)][v] = min(dp[S | (1 << v)][v],\n                                      dp[S][u] + graph[u][v])\n    print(dp[-1][0] if dp[-1][0] != INF else -1)\n\n\n# # 入力例\n# n = 5\n# graph = [[INF, 3, INF, 4, INF],\n#          [INF, INF, 5, INF, INF],\n#          [4, INF, INF, 5, INF],\n#          [INF, INF, INF, 0, 3],\n#          [7, 6, INF, INF, INF]]\n# solve(n, graph)\n\n\n# verify用\nn, e = map(int, input().split())\ngraph = [[INF] * n for _ in range(n)]\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    graph[s][t] = d\nsolve(n, graph)\n\n"
  },
  {
    "language": "Python",
    "code": "INF = float('inf')\nn, k = map(int, input().split())\nG = [[] for _ in range(n)]\n_G = []\nfor _ in range(k):\n    ss, t, d = map(int, input().split())\n    G[ss].append((t,d))\n    if t == 0:_G.append((ss,d))\n    \ndp = [[INF]*n for _ in range(1<<n)]\ndp[1][0] = 0\n\nfor s in range(1,(1<<n)):\n    for v in range(n):\n        if dp[s][v] == INF:continue\n        for t, d in G[v]:\n            if not(s & (1<<t)):\n                next_s = s | (1<<t)\n                dp[next_s][t] = min(dp[next_s][t],dp[s][v]+d)\n                    \n                    \nans = INF\nfor pre, d in _G:\n    ans = min(ans, dp[-1][pre]+d)\nprint(ans if ans != INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[float('inf')] * N for i in range(N)]\nfor i in range(M):\n    s, t, d = map(int, input().split())\n    s, t = s - 1, t- 1\n    G[s][t] = d\n\ndp = [[float('inf')] * N for i in range(2 ** N)]\ndp[1][0] = 0\n\nfor bs in range(2 ** N):\n    for i in range(N):\n        if not bs & (1 << i):\n            continue\n        for j in range(N):\n            if bs & (1 << j):\n                continue\n            dp[bs | (1 << j)][j] = min(dp[bs | (1 << j)][j], dp[bs][i] + G[i][j])\n\nans = float('inf')\nfor i in range(N):\n    ans = min(ans, dp[-1][i] + G[i][0])\n\nprint(ans if ans != float('inf') else - 1)\n\n"
  },
  {
    "language": "Python",
    "code": "V,E = map(int,input().split())\ndist = [[float(\"inf\")]*V for _ in range(V)]\nfor i in range(E):\n    s,t,d = map(int,input().split())\n    dist[s][t] = d\ndp = [[-1]*V for i in range(1<<V)] #dp[S][v]Sは訪れた町の集合vは今いる点\n\n#訪れた集合がs、今いる点がvの時０に戻る最短経路\ndef rec(s,v,dp):\n    if dp[s][v] >= 0:\n        return dp[s][v]  #一度出てきたもの\n        \n    if s == (1<<V)-1 and v == 0:\n        #全ての頂点を訪れた(s = 11...11 and v = 0)\n        dp[s][v] = 0\n        return 0\n    \n    res = float(\"inf\")\n    for u in range(V):\n        if (s>>u&1) == 0:\n            #uに訪れていない時(uの箇所が0の時),次はuとすると\n            res = min(res,rec(s|(1<<u),u,dp)+dist[v][u])\n            \n    dp[s][v] = res\n    return res\na = rec(0,0,dp)\nif a == float(\"inf\"):\n    print(-1)\nelse:\n    print(a)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nPermutation/Path - Traveling Salesman Problem\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n\n\"\"\"\n\n\nV, E = map(int, input().split())\n\nd = [[float('inf')]*V for _ in range(V)]\nfor _ in range(E):\n    f, t, dist = map(int, input().split())\n    d[f][t] = dist\ndp = [[-1]*V for _ in range(2**V)]\n\n\ndef solve(S, v):\n    if dp[S][v] >= 0:\n        return dp[S][v]\n    if (S == 2**V-1) and (v == 0):\n        dp[S][v] = 0\n        return 0\n    res = float('inf')\n    for u in range(V):\n        if not ((S >> u) & 1):\n            res = min(res, solve(S | (1 << u), u) + d[v][u])\n    dp[S][v] = res\n    return res\n\nans = solve(0, 0)\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\n\ndis = [[float(\"inf\")] * V for _ in range(V)]\nfor i in range(E):\n\ts, t, d = map(int, input().split())\n\tdis[s][t] = d\n\ndp = [[-1] * V for _ in range(1<<V)]\n\ndef rec(s, v):\n\tif dp[s][v] >= 0:\n\t\treturn dp[s][v]\n\n\tif s == (1<<V) -1 and v == 0:\n\t\tdp[s][v] = 0\n\t\treturn 0\n\t\n\tres = float(\"inf\")\n\tfor u in range(V):\n\t\tif not s >> u&1:\n\t\t\tres = min(res, rec(s|(1<<u), u)+dis[v][u])\n\t\n\tdp[s][v] = res\n\treturn res\n\nres = rec(0, 0)\nif res == float(\"inf\"):\n\tprint(-1)\nelse:\n\tprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/problems/DPL_2_A\n\n\nINF = float('inf')\n\n\ndef rec(bit, v):\n    if dp[bit][v] != -1:\n        return dp[bit][v]\n\n    if (1 << V) - 1 == bit and v == 0:\n        dp[bit][0] = 0\n        return 0\n\n    res = INF\n    if v in D:\n        for to, dist in D[v].items():\n            if not (bit & (1 << to)):\n                res = min(res, rec(bit | (1 << to), to) + dist)\n\n    dp[bit][v] = res\n    return res\n\n\nif __name__ == \"__main__\":\n    D = {}\n    V, E = list(map(int, input().split()))\n    for _ in range(E):\n        s, t, d = list(map(int, input().split()))\n        if s not in D:\n            D[s] = {}\n        D[s][t] = d\n\n    dp = [[-1] * (V) for _ in range(1 << V)]\n\n    print(dp[0][0] if rec(0, 0) != INF else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 40\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nV, E = map(int, sys.stdin.readline().strip().split())\n\n# edges[i][j]:i→jへの距離\nedges = [[float(\"inf\")]*V for i in range(V)]\nfor i in range(E):\n   s, t, d = map(int, sys.stdin.readline().strip().split())\n   edges[s][t] = d\n\ndp = [[-1] * V for i in range(1<<V)]\n\n# 訪れた集合がs、今いる点がvの時に、v=0に戻る最短経路\ndef rec(bit, v):\n    if dp[bit][v] >= 0:\n        return dp[bit][v]\n\n    if bit == (1<<V)-1 and v == 0:\n        #全ての頂点を訪れた(bit = 11...11 and v = 0)\n        dp[bit][v] = 0\n        return 0\n\n    res = float(\"inf\")\n    for u in range(V):\n        if not (bit>>u & 1):\n            #uに訪れていない時(uの箇所が0の時),次はuとすると\n            res = min(res,rec(bit|(1<<u), u) + edges[v][u])\n\n    dp[bit][v] = res\n    return res\n\nres = rec(0, 0)\nprint(-1 if res == float(\"inf\") else res)\n"
  },
  {
    "language": "Python",
    "code": "num_V, num_E = map(int, input().split())\ninf = float('inf')\n\nd = [[inf] * num_V for _ in range(num_V)]\n\nfor _ in range(num_E):\n\tts,tt,td = map(int, input().split())\n\td[ts][tt] = td\n\ndp = [[-1] * num_V for _ in range(1 << num_V)]\n\ndef solve(s,v,dp):\n\tif dp[s][v] >= 0:\n\t\treturn dp[s][v]\n\n\tif s == ((1 << num_V) - 1) and v == 0:\n\t\treturn 0\n\n\ttmp = inf\n\tfor u in range(num_V):\n\t\tif s >> u & 1 == 0:\n\t\t\ttmp = min(tmp, solve(s|1 << u, u, dp) + d[v][u])\n\n\tdp[s][v] = tmp\n\treturn dp[s][v]\n\nans = solve(0,0,dp)\nif ans == inf:\n\tprint(-1)\nelse:\n\tprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "v,e = map(int,input().split()) #v:頂点, e:辺\ngraph = [[] for i in range(v)]\ncost = [[float('inf')]*v for i in range(v)]\nfor i in range(e):\n    x,y,z = map(int,input().split())\n    cost[x][y] = z\ndp = [[float('inf')]*v for i in range(1<<v)]\n#(1<<v)-1 == 2**v-1\ndp[(1<<v)-1][0] = 0 #全ての頂点を訪れて帰ってきた時（ここがゴール）\nfor i in range(2**v-2, -1, -1): #まだ見ていない頂点集合に対して\n    for j in range(v): #現在いる頂点から\n        for k in range(v): #次に行く頂点について\n            if i>>k & 1 != 1: #まだ訪れていないならば\n                dp[i][j] = min(dp[i][j], dp[i|1<<k][k]+cost[j][k])\n            #dp[i|1<<k]は「kを訪れた状態」を指す。\n            #視点を変える。「今kにいる状態からゴールに至るのに必要なコスト」+「j→kに必要なコスト」は、\n            #「今jにいる状態からゴールに至るのに必要なコスト」になる（遡る）\n            #これを「今0にいる状態からゴールに至るのに必要なコスト」まで遡って計算する。\nif dp[0][0] != float('inf'):\n    print(dp[0][0]) #まだどこも訪れていない状態から、ゴールである0を目指して進む\nelse:\n    print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\ndef dp3(ini, i, j, k): return [[[ini]*i for _ in range(j)] for _ in range(k)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from itertools import accumulate #list(accumulate(A))\n\n## 4/25\n\nV, E = mi()\nrel = [[] for _ in range(V)]\ninv_rel = [[] for _ in range(V)]\nfor i in range(E):\n    s, t, c = mi()\n    rel[s].append((t, c))\n    #inv_rel[t].append((s, c))\n\nB = 2**V\ndp = dp2(-1, V, B)\n\n# 前向きメモ化再帰\ndef rec_for(state, now):\n    if dp[state][now] != -1:\n        return dp[state][now]\n    if state == B-1:\n        dp[state][now] = 0\n        return 0\n    res = float('inf')\n    for v, c in rel[now]:\n        if v==0 and state|(1<<v)!=B-1:\n            continue\n        if not state & (1<<v):\n            res = min(res, rec_for(state|(1<<v), v)+c)\n    dp[state][now] = res\n    return res\n\n# 後ろ向きメモ化再帰\ndef rec_back(state, now):\n    if dp[state][now] != -1:\n        return dp[state][now]\n    if state==now==0:\n        dp[state][now] = 0\n        return 0\n    res = float('inf')\n    for pv, c in inv_rel[now]:\n        if pv==0 and state!=1:\n            continue\n        if state & (1<<pv):\n            res = min(res, rec_back(state^(1<<pv), pv)+c)\n    dp[state][now] = res\n    return res\n\nans = rec_for(0, 0)\n#ans = rec_back(B-1, 0)\nif ans == float('inf'):\n    print(-1)\n    exit()\nprint(ans)\n\n'''\n# DP\ndp = dp2(float('inf'), V, B)\ndp[0][0] = 0\n\nfor state in range(B-1):\n    for now in range(V):\n        if dp[state][now] != float('inf'):\n            for nv, c in rel[now]:\n                #if nv == 0 and state|1 != B-1:\n                    #continue\n                if not state & 1<<nv:\n                    dp[state|(1<<nv)][nv] = min(dp[state|(1<<nv)][nv], dp[state][now]+c)\n\nif dp[B-1][0] == float('inf'):\n    print(-1)\n    exit()\nprint(dp[B-1][0])\n'''\n"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=ja\n\nINF = 10**9\nn,e = map(int, input().split())\ngl = [ [INF]*(n) for _ in range(n)]\n\nfor _ in range(e):\n    s,t,d = map(int, input().split())\n    gl[s][t] = d\n\ndp = [ [INF]*(n) for _ in range(2**n) ]\ndp[1][0] = 0\nfor i in range(2**n):\n    for j in range(n):\n        if dp[i][j] == INF: continue\n        for k in range(n):\n            if (i>>k)%2 == 1: continue\n            dp[i|(1<<k)][k] = min(dp[i][j]+gl[j][k], dp[i|(1<<k)][k])\n\nans = INF\nfor i in range(1,n): \n    if gl[i][0] != INF:\n        ans = min(ans, dp[2**n-1][i] + gl[i][0])\n\nif ans == INF: ans = -1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom sys import setrecursionlimit\nsetrecursionlimit(10**9)\n\nreadline=stdin.readline\nn,w=map(int,readline().split())\nINF=10**9\nG=[[INF]*n for _ in range(n)]\n\nfor _ in range(w):\n    s,t,d=map(int,readline().split())\n    G[s][t]=d\n\ndp=[[-1]*n for _ in range(1<<n)]\n\ndef func(s,v):\n    if dp[s][v]>=0: return dp[s][v]\n\n    if (s==(1<<n)-1) and v==0:\n        dp[s][v]=0\n        return dp[s][v]\n\n    tmp=INF\n    for u in range(n):\n        t=(1<<u)|s\n        if t==s: continue\n        tmp=min(tmp,func(t,u)+G[v][u])\n    dp[s][v]=tmp\n    return dp[s][v]\n\nans=func(0,0)\nprint(ans if ans<INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "v,e=map(int,raw_input().split())\ndis=[[float(\"inf\")]*v for _ in xrange(v)]\nfor i in xrange(e):\n    s,t,d=map(int,raw_input().split())\n    dis[s][t]=d\ndp=[[float('inf')]*(v) for _ in xrange(1<<v)]\ndp[1][0]=0\nfor i in xrange(1<<v):\n    for j in xrange(v):\n        if dp[i][j]==float('inf'):continue\n        for k in xrange(v):\n            if (i>>k)%2==1:continue\n            nexti=i|1<<k\n            nextdis=dp[i][j]+dis[j][k]\n            dp[nexti][k]=min(dp[nexti][k],nextdis)\nans=float('inf')\nfor i in xrange(v):\n    if dp[(1<<v)-1][i]==float('inf'):continue\n    ans=min(ans,dp[(1<<v)-1][i]+dis[i][0])\nif ans==float('inf'):\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nsys.setrecursionlimit(10 ** 7)\nread = sys.stdin.buffer.read\ninp = sys.stdin.buffer.readline\ndef inpS(): return inp().rstrip().decode()\nreadlines = sys.stdin.buffer.readlines\nMOD = 10 ** 9 + 7\nINF = 1 << 60\n\n# ---------------------------------------------------\n# ---------------------------------------------------\n# ---------------------------------------------------\n\ndef resolve():\n    def rec(S, v):\n        if dp[S][v] >= 0:\n            return dp[S][v]\n        if S == (1<<V)-1 and v==0:\n            dp[S][v] = 0\n            return 0\n        res = INF\n        for to in range(V):\n            if not (S>>to & 1):\n                res = min(res, rec((S | (1<<to)), to) + dist[v][to])\n\n        dp[S][v] = res\n        return res\n\n    V, E = map(int, input().split())\n    dist = [[INF] * V for _ in range(V)]\n    for i in range(E):\n        x, y, d = map(int, input().split())\n        dist[x][y] = d\n\n    dp = [[-1] * V for _ in range(1 << V)]\n\n    res = rec(0, 0)\n    if res == INF:\n        print(-1)\n    else:\n        print(res)\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush, heappop\nimport copy\n\nBIG_NUM = 2000000000\nMOD = 1000000007\nEPS = 0.000000001\n\n\nclass Edge:\n    def __init__(self,arg_to,arg_dist):\n        self.to = arg_to\n        self.dist = arg_dist\n\n\nV,E = map(int,input().split())\n\nPOW = [None]*(V+1)\nPOW[0] = 1\nfor i in range(1,V+1):\n    POW[i] = POW[i-1]*2\n\nG = [[] for _ in range(V)]\n\nfor _ in range(E):\n    from_,to_,dist = map(int,input().split())\n    G[from_].append(Edge(to_,dist))\n\n#経路は輪になるので、スタートは0として良い\nstart = 0\ndp = [[BIG_NUM]*V for _ in range(POW[V])]\n\ndp[POW[start]][start] = 0\n\nfor state in range(1,POW[V]):\n    for last_node in range(V):\n        if dp[state][last_node] == BIG_NUM:\n            continue\n        for edge in G[last_node]:\n            if state & POW[edge.to] != 0:\n                continue #訪問済\n            next_state = state+POW[edge.to]\n            if dp[next_state][edge.to] > dp[state][last_node]+edge.dist:\n                dp[next_state][edge.to] = dp[state][last_node]+edge.dist\n\nans = BIG_NUM\n#startに戻る\nfor last_node in range(V):\n    if dp[POW[V]-1][last_node] == BIG_NUM:\n        continue\n    for edge in G[last_node]:\n        if edge.to != start:\n            continue\n        ans = min(ans,dp[POW[V]-1][last_node]+edge.dist)\n\nif ans == BIG_NUM:\n    print(\"-1\")\nelse:\n    print(\"%d\"%(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**10\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    V, E = LI()\n    con = [[INF]*V for _ in range(V)]\n    for _ in range(E):\n        std = LI()\n        con[std[0]][std[1]] = std[2]\n\n    # dp[S][i]: 集合Sを使ったiで終わるルートの最短コスト\n    dp = [[INF]*V for _ in range(2**V)]\n    # 0スタートに限定\n    dp[1][0] = 0\n    visited = [[False]*V for _ in range(2**V)]\n\n    def dfs(S, i):\n        if not visited[S][i]:\n            if S&1:\n                Smi = S & ~(1<<i)\n                for j in range(V):\n                    if Smi>>j & 1:\n                        tmp = dfs(Smi, j) + con[j][i]\n                        if dp[S][i] > tmp:\n                            dp[S][i] = tmp\n            visited[S][i] = True\n\n        return dp[S][i]\n\n    for i in range(V):\n        dfs(2**V-1, i)\n\n    ans = min([dp[-1][i]+con[i][0] for i in range(V)])\n    print(ans if ans<INF else -1)\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nfrom collections import deque\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    min_cost = float('inf')\n\n    que = deque([(0, 0, set(range(1, v)))])\n    while que:\n        cost, last, vs = que.pop()\n        if min_cost <= cost:continue\n        if vs:que.extend((cost + g[last][v], v, vs - {v}) for v in vs)\n        elif min_cost > cost + g[last][0]:min_cost = cost + g[last][0]\n\n    print(-1 if isinf(min_cost) else min_cost)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#!python3\n\niim = lambda: map(int, input().rstrip().split())\n\nfrom heapq import heappush, heappop\n\ndef resolve():\n    V, E = iim()\n    inf = float(\"inf\")\n    ad = [[inf]*V for i in range(V)]\n\n    for i in range(E):\n        s, t, d = iim()\n        ad[s][t] = d\n\n    bi = [1<<i for i in range(V)]\n    goal = (1<<V) - 1\n\n    dp = dict()\n    q = []\n    heappush(q, (0, 0, 1))\n    ans = inf\n    while q:\n        cost, v, state = heappop(q)\n\n        vs = (v, state)\n        if vs in dp:\n            if dp[vs] <= cost:\n                continue\n        dp[vs] = cost\n\n        if state == goal:\n            cost += ad[v][0]\n            if cost < ans:\n                ans = cost\n            continue\n\n        for i in range(V):\n            if bi[i] & state:\n                continue\n            heappush(q, (cost + ad[v][i], i, state | bi[i]))\n    print(ans if ans != inf else -1)\n    #print(dp[(0, goal)])\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "\n\ndef main():\n    V, E = map(int, input().split())\n    INF = float(\"inf\")\n    G = [[-1 for _ in range(V)] for _ in range(V)]\n\n    for i in range(E):\n        s,t,d = map(int, input().split())\n        G[s][t] = d\n\n    # dp[bit][i] bitの１が立っている場所を訪問済みで、現在iにいる\n    dp = [[INF for _ in range(V)] for _ in range(1 << V)]\n    # 各所一回だけ訪問して一周できるなら、どこから始めても同じなので0のみ初期化\n    dp[0][0] = 0\n\n\n\n    for bit in range(1 << V):\n        for curr in range(V):\n            for nxt in range(V):\n                # 現在地と次の場所が同じなら飛ばす\n                if curr == nxt:\n                    continue\n                # 次行くところが既に訪問済みなら飛ばす\n                if bit & (1 << nxt):\n                    continue\n                # 現在値から次の目的地にいけなければ飛ばす\n                if G[curr][nxt] == -1:\n                    continue\n                dp[bit | (1 << nxt)][nxt] = min(dp[bit | (1 << nxt)][nxt], dp[bit][curr] + G[curr][nxt])\n\n    ans = dp[-1][0]\n    print(ans if ans != INF else -1)\n        \nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nmax_d = 1001\nadj = [[] for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    adj[s].append((t, d))\n\nmax_path = 15001\ndp = [[max_path] * (1 << V) for i in range(V)]\ndp[0][0] = 0\n\n# Full search with bit mask\ndef tsp(v, b):\n    if b == (1 << V) - 1:\n        return None\n    \n    for t, d in adj[v]:\n        if b & (1 << t):\n            continue\n        mask = b | (1 << t)\n        t_d = dp[v][b] + d\n        if dp[t][mask] > t_d:\n            dp[t][mask] = t_d\n            tsp(t, mask)\n\n# Output\ntsp(0, 0)\n\nans = dp[0][-1]\nif ans == max_path:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "def read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\ndef rec(state, v):\n    if dp[state][v] >= 0:\n        return dp[state][v]\n    if (1 << V) - 1 == state and v == 0:\n        dp[state][0] = 0\n        return 0\n\n    ret = INF\n    for to in range(V):\n        if not (state >> to & 1):\n            ret = min(ret, rec(state | 1 << to, to) + mat[v][to])\n    dp[state][v] = ret\n    return ret\n\nINF = 1<<27\nV, E = read_list(int)\n#edge = [[] for _ in range(V)]\nmat = [[INF] * V for _ in range(V)]\nfor _ in range(E):\n    fr, to, cost = map(int, input().split())\n    mat[fr][to] = cost\n#    edge[fr].append((to, cost))\n\n\ndp = [[-1] * V for _ in range(1<<V)]\nprint(dp[0][0] if rec(0, 0) != INF else -1)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\n\nrl = sys.stdin.buffer.readline\nINF = sys.maxsize\n\nV, E = map(int, rl().split())\nES = [tuple(map(int, rl().split())) for i in range(E)]\n\n\n\n# グラフを初期化する\nG = defaultdict(lambda: defaultdict(lambda: INF))\nfor e in ES:\n  G[e[0]][e[1]] = e[2]\n\n\ndp = defaultdict(lambda: defaultdict(lambda: INF))\ndp[0][0] = 0\n\nfor s in range(1 << V):\n  for v in range(V):\n    if s & (1 << v) == 0: # s に頂点v が含まれていないときを考える\n      for u in range(V):\n        dp[s | (1 << v)][v] = min(dp[s | (1 << v)][v], dp[s][u] + G[u][v])\n\n\nprint(dp[(1 << V) - 1][0] if dp[(1 << V) - 1][0] < INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "def read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\ndef rec(state, v):\n    if dp[state][v] >= 0:\n        return dp[state][v]\n    if (1 << V) - 1 == state and v == 0:\n        dp[state][0] = 0\n        return 0\n\n    try:\n        dp[state][v] = min(INF, min(rec(state | 1 << to, to) + cost for to, cost in edge[v] if not (state >> to & 1)))\n    except:\n        dp[state][v] = INF\n    return dp[state][v]\n\nINF = 1<<27\nV, E = read_list(int)\nedge = [[] for _ in range(V)]\nfor _ in range(E):\n    fr, to, cost = map(int, input().split())\n    edge[fr].append((to, cost))\n\ndp = [[-1] * V for _ in range(1<<V)]\nprint(dp[0][0] if rec(0, 0) != INF else -1)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = map(int, input().split())\n\n    graph = [[f_inf] * n for _ in range(n)]\n    for i in range(n):\n        graph[i][i] = 0\n\n    for _ in range(m):\n        s, t, d = map(int, input().split())\n        graph[s][t] = d\n\n    dp = [[f_inf] * n for _ in range(1 << n)]\n    dp[0][0] = 0\n\n    for S in range(1 << n):\n        for v in range(n):\n            for u in range(n):\n                if ((1 << v) & S) == 0:\n                    if v != u:\n                        idx = S | (1 << v)\n                        dp[idx][v] = min(dp[idx][v], dp[S][u] + graph[u][v])\n\n    print(dp[-1][0] if dp[-1][0] != f_inf else -1)\n\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nV, E = [int(_) for _ in input().split()]\nSTD = [[int(_) for _ in input().split()] for _ in range(E)]\nG = [[float('inf')] * V for _ in range(V)]\nfor s, t, d in STD:\n    G[s][t] = d\nans = float('inf')\ndp = [[float('inf')] * V for _ in range(2**V)]\n#for start in range(V):\nfor start in range(1):\n    dp[(2**V - 1)][start] = 0\n    for S in range(2**V - 1 - 2**start, -1, -1):\n        for v in range(V):\n            for u in range(V):\n                if not (S >> u & 1):\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + G[v][u])\n    ans = min(ans, dp[0][start])\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=jp\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\n\n#distance_list[j][i] = 頂点j→iの距離（有向）\ndistance_list = [[float('inf') for i in range(V)] for j in range(V)]\nfor i in range(V):\n    distance_list[i][i] = 0\nfor node in range(E):\n    start, goal, distance = map(int, input().split())\n    distance_list[start][goal] = distance\n\ndp = [[-1 for v in range(V)] for S in range(1 << V)]\ndef TSP(S, v):\n    if dp[S][v] >= 0:\n        return dp[S][v]\n    else:\n        if S == (1 << V) - 1 and v == 0:\n            dp[S][v] = 0\n            return 0\n        else:\n            ans = float('inf')\n            for u in range(V):\n                if (S >> u) & 1 == 0:\n                    ans = min(ans, TSP(S | (1 << u), u) + distance_list[v][u])\n            dp[S][v] = ans\n            return ans\nif TSP(0,0) == float('inf'):\n    print(-1)\nelse:\n    print(TSP(0,0))\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nmin_cost = float('inf')\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    dfs(g, 0, 0, set(range(1, v)))\n    global min_cost\n    print(-1 if isinf(min_cost) else min_cost)\n\n\ndef dfs(g, cost, last, vs):\n    global min_cost\n    if min_cost <= cost:\n        return\n    if vs:\n        for v in vs:\n            dfs(g, cost + g[last][v], v, vs - {v})\n    elif min_cost > cost + g[last][0]:\n        min_cost = cost + g[last][0]\n\nmain()"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\nINF = 1e9\ndp = [[-1]*V for i in xrange(2**V)]\ntmp = []\ndef dfs(state, v, s):\n    if dp[state][v] != -1:\n        return dp[state][v]\n    if state == 2**V-1:\n        for t, d in g[v]:\n            if t==s:\n                return d\n        return INF\n    res = INF\n    for t, d in g[v]:\n        if state & (1 << t):\n            continue\n        tmp.append(t)\n        r = dfs(state | (1 << t), t, s) + d\n        res = min(res, r)\n        tmp.pop()\n    dp[state][v] = res\n    return res\nres = min(dfs(1<<v, v, v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "v, e = map(int, input().split())\n\ninf = 10**7\nedges = [[inf]*v for _ in range(v)]\n\nfor i in range(e):\n    s, t, d = map(int, input().split())\n    edges[s][t] = d\n\n#Dpは全体集合の部分集合Sについて最後がvであるという制約の下で順序を最適化したときのSの中での最小コスト\ndp = [[inf]*v for _ in range(2**v)]\ndp[0][0] = 0\n\n#集合（訪れたか訪れていないかを表す二進数）\nfor x in range(2**v):\n    #最後に訪れたノード\n    for y in range(v):\n        #最後に訪れた以外のノード\n        for z in range(v):\n            #1.すでに訪れたかどうか 2.最後に訪れたノードではないか 3. yとzはそもそもつながっているのか\n            if ((x >> y) & 1) and y != z and edges[z][y] < 10**6:\n                dp[x][y] = min(dp[x][y], dp[x^(1<<y)][z]+edges[z][y])\n\nif dp[-1][0] > 10**6:\n    print(-1)\nelse:\n    print(dp[-1][0])\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 65\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "INF = 10 **9 \nv , e = map(int,input().split())\nroute = [[] for i in range(v)]\nfor i in range(e):\n    s , t , d = map(int,input().split())\n    route[s].append((t,d))\n\ndp = [[INF for i in range(v)] for j in range(2**v)]\n\ndp[0][0] = 0\n\nfor i in range(2**v):\n    for j in range(v):\n        for k , d in route[j]:\n            if (i>>k) & 1 == 1:\n                continue\n            dp[i | (1<<k)][k] = min(dp[i | (1<<k)][k],dp[i][j] + d) \n\nprint(dp[-1][0] if dp[-1][0] != INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "# http://www.geocities.jp/m_hiroi/light/pyalgo65.html\n\ndef memoize(f):\n    table = {}\n    def func(*args):\n        if not args in table:\n            table[args] = f(*args)\n        return table[args]\n    return func\n\n@memoize\ndef tsp(p, v):\n    if (1 << point_size) - 1 == v:\n        return distance_table[p][0]\n    else:\n        return min(distance_table[p][x] + tsp(x, v | (1 << x)) for x in range(point_size) if not (v & (1 << x)))\n\nfrom sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\npoint_size, e = map(int, readline().split())\ndistance_table = [[float('inf')] * point_size for _ in range(point_size)]\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    distance_table[s][t] = d\nans = tsp(0,1)\nprint(-1 if isinf(ans) else ans)"
  },
  {
    "language": "Python",
    "code": "def solve():\n  ans = 0\n  V, E = map(int, input().split())\n  edge = [[] for _ in range(V)]\n  for i in range(E):\n    s,t,d = map(int, input().split())\n    edge[s].append([t,d])\n  dp = [[float('inf')]*V for _ in range(1<<V)]\n  for v,d in edge[0]:\n    dp[1<<v][v] = min(dp[1<<v][v],d)\n  for S in range(2,1<<V,2):\n    for u in range(V):\n      if (S>>u)&1:\n        for v,d in edge[u]:\n          if not (S>>v)&1:\n            dp[S+(1<<v)][v] = min(dp[S+(1<<v)][v],dp[S][u]+d)\n  return dp[-1][0] if dp[-1][0]<float('inf') else -1\nprint(solve())\n"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 10\nv, e = map(int, input().split())\nadj = [[INF] * v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    adj[s][t] = d\n\nmem = {}\nend = 2 ** v - 1\ndef minCost(state, pos):\n    if (state, pos) in mem:\n        return mem[(state, pos)]\n\n    if state == end:\n        return adj[pos][0]\n\n    mask = 1\n    ret = INF\n    for to in range(v):\n        if mask & state:\n            mask <<= 1\n            continue\n\n        ret = min(ret, adj[pos][to] + minCost(state | mask, to))\n        mask <<= 1\n\n    mem[(state, pos)] = ret\n    return ret\n\nresult = minCost(1, 0)\nif result >= INF:\n    print(-1)\nelse:\n    print(result)\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\n\ndist = [[float('inf') for _ in range(V)] for _ in range(V)]\nfor _ in range(E):\n    s, t, d = map(int, input().split())\n    dist[s][t] = d\n\n# 2**V回、-1がV個の配列を作る\ndp = [[-1]*V for _ in range(1<<V)]\n\ndef rec(s, v, dp):\n    \"\"\"\n    s: 訪れた集合のbit演算（すべて訪れたら2**V-1になる）\n    v: いまいる点\n    dp: dp配列\n    \"\"\"\n    if dp[s][v] >= 0:\n        return dp[s][v]\n    \n    # すべて訪れており、かつ今いる点が0（始点）の場合\n    if s == (1<<V)-1 and v == 0:\n        dp[s][v] = 0\n        return 0\n\n    res = float('inf')\n    for u in range(V):\n    # まだuに訪れていないときuに訪れる。コストを再帰的に出す\n        if (s>>u&1) == 0:\n            res = min(res, rec(s|(1<<u), u, dp) + dist[v][u])\n\n    dp[s][v] = res\n    return res\n\nans = rec(0, 0, dp)\n\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nmin_cost = float('inf')\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    dfs(g, 0, 0, set(range(1, v)))\n    global min_cost\n    print(-1 if isinf(min_cost) else min_cost)\n\n\ndef dfs(g, cost, last, vs):\n    global min_cost\n    if min_cost < cost:\n        return\n    if vs:\n        for v in vs:\n            dfs(g, cost + g[last][v], v, vs - {v})\n    elif min_cost > cost + g[last][0]:\n        min_cost = cost + g[last][0]\n\nmain()"
  },
  {
    "language": "Python",
    "code": "\nn,w = map(int,input().split())\n\n#d[i][j]:i→jへの距離\nd = [[float(\"inf\")]*n for i in range(n)]\nfor i in range(w):\n   x,y,z = map(int,input().split())\n   d[x][y] = z \n\ndp = [[-1] * n for i in range(1<<n)]\n\n#訪れた集合がs、今いる点がvの時０に戻る最短経路\ndef rec(s,v,dp):\n    if dp[s][v] >= 0:\n        return dp[s][v]\n        \n    if s == (1<<n)-1 and v == 0:\n        #全ての頂点を訪れた(s = 11...11 and v = 0)\n        dp[s][v] = 0\n        return 0\n    \n    res = float(\"inf\")\n    for u in range(n):\n        if (s>>u&1) == 0:\n            #uに訪れていない時(uの箇所が0の時),次はuとすると\n#            print(\"s:\",bin(s),\"u:\",u,\"v:\",v,\"sp:\",bin(s|(1<<u)),d[v][u])\n            res = min(res,rec(s|(1<<u),u,dp)+d[v][u])\n            \n    dp[s][v] = res\n    return res\n\nrec1=rec(0,0,dp)\nif rec1==float(\"inf\"):\n    print(-1)\nelse:\n    print(rec1)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    inf=float(\"inf\")\n    v,e=map(int,input().split())\n    con=[{} for _ in range(v)]\n    for _ in range(e):\n        s,t,d=map(int,input().split())\n        con[s][t]=d\n\n    #最終的に閉路が得られる場合、結果はスタート地点によらないので0→0を考えればよい\n    #ij成分はiのbitで表現された頂点0を含まない部分集合のうち、j番目の頂点で終わるものの最短経路長\n    dp=[[inf]*(v-1) for _ in range(2**(v-1))]\n    #initialize\n    for x in con[0]:\n        dp[2**(x-1)][x-1]=con[0][x]\n    \n    for i in range(1,2**(v-1)):\n        if bin(i).count(\"1\")==1 : continue\n        for j in range(v-1):\n            if not i>>j &1:continue\n            work=i-2**j\n            mn=inf\n            for k in range(v-1):\n                if not work>>k &1 : continue\n                if not j+1 in con[k+1] : continue\n                if dp[work][k]==inf : continue\n                if mn>dp[work][k]+con[k+1][j+1]:\n                    mn=dp[work][k]+con[k+1][j+1]\n            dp[i][j]=mn\n    \n    mn=inf\n    #得られたグラフの終点と0をつなげられるか調べ最短距離を求める\n    for i in range(v-1):\n        if 0 in con[i+1]:\n            if mn>con[i+1][0]+dp[2**(v-1)-1][i]:\n                mn=con[i+1][0]+dp[2**(v-1)-1][i]\n\n\n\n    if mn==inf : print(-1)\n    else : print(mn)\n    #print(dp)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "dp = []\ndist = []\nINF = 1000000000\n\ndef tsp(s, v, dp, n):\n    if dp[s][v] >= 0:\n        return dp[s][v]\n    if s == (1<<n)-1 and v == 0:\n        dp[s][v] = 0\n        return 0\n    res = INF\n    for u in range(n):\n        if (s >> u & 1) == 0:\n            res = min(res, tsp(s | (1 << u), u, dp, n) + dist[v][u])\n    dp[s][v] = res\n    return res\n    \nline = input()\nv, e = list(map(int, line.split()))\ndp = [ [-1] * v for _ in range(0, 1 << v)]\ndist = [ [INF] * v for _ in range(0, v)]\nfor _ in range(0, e):\n    line = input()\n    s, t, d = list(map(int, line.split()))\n    dist[s][t] = d\nans = tsp(0, 0, dp, v)\nprint(ans if ans < INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**6\nN, M = map(int, input().split())\n\nedge = [[inf] * N for _ in range(N)]\nfor _ in range(M):\n    s, t, c = map(int, input().split())\n    edge[s][t] = c\nfor i in range(N):\n    edge[i][i] = 0\n\n\n# 0からスタートするよ\ndp = [[inf] * (1 << N) for _ in range(N)]\ndp[0][0] = 0\n\nfor bit in range(1 << N):\n    for t in range(N):\n        if bit & (1 << t):\n            continue\n        bit_next = bit | (1 << t)\n        for s in range(N):\n            dp[t][bit_next] = min(dp[t][bit_next], dp[s][bit] + edge[s][t])\n\n\nif dp[0][(1 << N)-1] >= inf:\n    print(-1)\nelse:\n    print(dp[0][(1 << N) - 1])\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nmax_d = 1001\nadj = [[max_d] * V for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    adj[s][t] = d\n\nmax_path = 15001\ndp = [[max_path] * (1 << V) for i in range(V)]\ndp[0][0] = 0\n\n# Full search with bit mask\ndef tsp(v, b):\n    if b == (1 << V) - 1:\n        return None\n    \n    for t, d in filter(lambda x: x[1] != max_d, enumerate(adj[v])):\n        if b & (1 << t):\n            continue\n        mask = b | (1 << t)\n        t_d = dp[v][b] + adj[v][t]\n        if dp[t][mask] > t_d:\n            dp[t][mask] = t_d\n            tsp(t, mask)\n\n# Output\ntsp(0, 0)\n\nans = dp[0][-1]\nif ans == max_path:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from typing import List\n\nINT_INF = -1\n\nclass Graph:\n    v_num: int\n    edges: List[List[int]]\n\n    def __init__(self, v_num: int):\n        self.v_num = v_num\n        self.edges = [[INT_INF for c in range(v_num)] for r in range(v_num)]\n\n    def setDist(self, src: int, dest: int, dist: int):\n        self.edges[src][dest] = dist\n\n\nclass TSPSolver:\n    g: Graph\n\n    def __init__(self, g: Graph):\n        self.g = g\n\n    def solve(self) -> int:\n        \"\"\"\n\n        :param v:\n        :param state:\n        :return: -1 means INF\n        \"\"\"\n        N = self.g.v_num\n        dp = [[INT_INF for c in range(N)] for r in range(1 << N)]\n\n        dp[(1 << N) - 1][0] = 0\n\n        for state in range((1 << N) - 2, -1, -1):\n            for v in range(N):\n                for u in range(N):\n                    if ((state >> u) & 1) == 0:\n                        if dp[state | 1 << u][u] != INT_INF and self.g.edges[v][u] != INT_INF:\n                            if dp[state][v] == INT_INF:\n                                dp[state][v] = dp[state | 1 << u][u] + self.g.edges[v][u]\n                            else:\n                                dp[state][v] = min(dp[state][v], dp[state | 1 << u][u] + self.g.edges[v][u])\n        return dp[0][0]\n\n\ndef main():\n    V, E = map(int, input().split())\n    g: Graph = Graph(V)\n    for _ in range(E):\n        src, dest, dist = map(int, input().split())\n        g.setDist(src, dest, dist)\n\n    tsp: TSPSolver = TSPSolver(g)\n    print(tsp.solve())\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    n,m=map(int,input().split())\n    inf=10**6\n    edges=[[inf]*n for i in range(n)]\n\n    for i in range(m):\n        a,b,c=map(int,input().split())\n        a-=1\n        b-=1\n        edges[a][b]=c\n    \n    \n    dp=[[inf]*n for i in range(1<<n)]\n    dp[0][0]=0\n\n    for s in range(1<<n):\n        for v in range(n):\n            for j in range(n):\n                if (s>>j)&1 and v!=j and edges[j][v]<10**5:\n                    dp[s][v]=min(dp[s][v],dp[s^(1<<j)][j]+edges[j][v])\n                    \n    if dp[-1][0]>10**5:\n        print(-1)\n    else:\n        print(dp[-1][0])\n    \nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\ndef main():\n    v, e = map(int, readline().split())\n    g = [[float('inf')] * v for _ in range(v)]\n    for _ in range(e):\n        s, t, d = map(int, readline().split())\n        g[s][t] = d\n    from collections import deque\n    min_cost = float('inf')\n\n    que = deque()\n    que.append((0, 0, set(range(1, v))))\n    while que:\n        cost, last, vs = que.pop()\n        if min_cost < cost:\n            continue\n        if vs:\n            que.extend((cost + g[last][v], v, vs - {v}) for v in vs)\n        elif min_cost > cost + g[last][0]:\n            min_cost = cost + g[last][0]\n\n    print(-1 if isinf(min_cost) else min_cost)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "v,e=map(int,raw_input().split())\ndist=[[float(\"inf\")]*v for _ in xrange(v)]\nfor i in xrange(e):\n????????s,t,d=map(int,raw_input().split())\n????????dist[s][t]=d\n\ndp=[[float('inf')]*(v) for _ in xrange(1<<v)]\ndp[1][0]=0\nfor i in xrange(1<<v):\n????????for j in xrange(v):\n????????????????if dp[i][j]==float('inf'):continue\n????????????????for k in xrange(v):\n????????????????????????if not (i>>k)&1:\n????????????????????????    nexti=i|1<<k\n????????????????????????    nextdist=dp[i][j]+dist[j][k]\n????????????????????????    dp[nexti][k]=min(dp[nexti][k],nextdist)\n\nans=float('inf')\nfor i in xrange(v):\n????????if dp[(1<<v)-1][i]==float('inf'):continue\n????????ans=min(ans,dp[(1<<v)-1][i]+dist[i][0])\nif ans==float('inf'):\n????????print(-1)\nelse:\n????????print(ans)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nimport sys\nimport math\nimport string\nimport collections\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nimport bisect\n\nMOD = 10 ** 9 + 7\nINF = 10 ** 18\ninput = lambda: sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 8)\n\n\ndef solve():\n    V, E = map(int, input().split())\n    edges = [[INF] * V for _ in range(V)]\n\n    for _ in range(E):\n        s, t, d = map(int, input().split())\n        edges[s][t] = d\n\n    dp = [[INF] * (V + 1) for _ in range(2 ** V + 1)]\n    dp[0][0] = 0\n    for i in range(2 ** V):\n        for j in range(V):\n            for k in range(V):\n                if (i >> k) & 1 == 0:\n                    dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + edges[j][k])\n    print(dp[2 ** V - 1][0] if dp[2 ** V - 1][0] != INF else -1)\n\n\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nV, E = map(int, readline().split())\ng = [[] for i in xrange(V)]\ncost = {}\nto = [0]*V\nfor i in xrange(E):\n    s, t, d = map(int, readline().split())\n    g[s].append((t, d))\n    cost[s,t] = d\n    to[s] |= 1 << t\nget = cost.get\nINF = 10**9\nALL = 2**V-1\ndp = {}\nstart = 0\ndef dfs(state, v):\n    key = (state, v)\n    if key in dp: return dp[key]\n    if state == ALL:\n        dp[key] = res = get((v, start), INF)\n        return res\n    dp[key] = res = min((dfs(state | (1 << t), t) + d for t, d in g[v] if not state & (1 << t))) if state & to[v] != to[v] else INF\n    return res\nres = dfs(1, 0)\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "v,e=[int(j) for j in input().split()]\nd=[[10**18]*v for i in range(v)]\ndp=[[-1]*v for i in range(1<<v)]\nfor i in range(e):\n    s,t,w=[int(j) for j in input().split()]\n    d[s][t]=w\n\n\ndef f(s,n,dp):\n    if dp[s][n]>=0:\n        return dp[s][n]\n    if s==(1<<v)-1 and n==0:\n        dp[s][n]=0\n        return 0\n    tmp=10**18\n    for u in range(v):\n        if (s>>u&1)==0:\n            tmp=min(tmp,f(s|(1<<u),u,dp)+d[n][u])\n    dp[s][n]=tmp\n    return tmp\n\nans=f(0,0,dp)\nif ans==10**18:\n    print(-1)\nelse:\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "SENTINEL = 15001\nv, e = map(int, input().split())\n\nlinks = [set() for _ in range(v)]\nbests = [[SENTINEL] * v for _ in range(1 << v)]\n\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    links[s].add((t, d))\n\nbests[0][0] = 0\n\nfor visited, best in enumerate(bests):\n    for last, cost in enumerate(best):\n        for t, d in links[last]:\n            bit = 1 << t\n            if visited & bit:\n                continue\n            new_best = bests[visited | bit]\n            new_best[t] = min(new_best[t], cost + d)\n\nprint(-1 if bests[-1][0] == 15001 else bests[-1][0])"
  },
  {
    "language": "Python",
    "code": "import math\nimport copy\nimport sys\nimport fractions\n# import numpy as np\n# import statistics\nimport decimal\nimport heapq\nimport collections\nimport itertools\nimport bisect\n\n# from operator import mul\n\nsys.setrecursionlimit(100001)\n\n\n# input = sys.stdin.readline\n# sys.setrecursionlimit(10**6)\n\n# ===FUNCTION===\n\ndef getInputIntList():\n    outputDataList = []\n    inputData = input().split()\n    outputDataList = [int(n) for n in inputData]\n\n    return outputDataList\n\n\ndef getSomeInputInt(n):\n    outputDataList = []\n    for i in range(n):\n        inputData = int(input())\n        outputDataList.append(inputData)\n\n    return outputDataList\n\n\ndef getSomeInputListInt(n):\n    inputDataList = []\n    outputDataList = []\n    for i in range(n):\n        inputData = input().split()\n        inputDataList = [int(n) for n in inputData]\n        outputDataList.append(inputDataList)\n\n    return outputDataList\n\n\n# ===CODE===\n\nINF = sys.maxsize\n\nv, e = map(int, input().split())\ng = [[INF for _ in range(v)] for _ in range(1 << v)]\n\nfor i in range(e):\n    s, t, d = map(int, input().split())\n    g[s][t] = d\n\ndp = [[INF for _ in range(v)] for _ in range(1 << v)]\ndp[1][0] = 0\n\nfor bit in range(1, (1 << v) ):\n    for i in range(v):\n        if not bit>>i&1:\n            continue\n\n        for j in range(v):\n            if bit >> j&1:\n                continue\n            dp[bit | (1 << j)][j] = min(dp[bit | (1 << j)][j], dp[bit][i] + g[i][j])\n\nmn = INF\n\nfor end in range(v):\n    mn = min(mn, dp[(1 << v) - 1][end] + g[end][0])\nif mn == INF:\n    print(-1)\nelse:\n    print(mn)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nno_route = 15001\n\n# (v-1) th vertex is excluded\ndp = [[no_route] * (V - 1) for i in range(1 << (V - 1))]\n\nadj = [[] for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    if s == V - 1:\n        # Record the distance from the (v-1) th vertex to the adjacent vertex\n        dp[1 << t][t] = d\n    else: \n        # Store distance from source, not target\n        adj[t].append((s, d))\n\n# DP\nfor b in range(1, 1 << (V - 1)):\n    for i in range(V - 1):\n        b_i = 1 << i\n        if b & b_i:\n            pre_bit = b ^ b_i\n            dp_pre = dp[pre_bit]\n            for s, d in adj[i]:\n                pre_rec = dp_pre[s]\n                if pre_rec != no_route:\n                    dp[b][i] = min(dp[b][i], pre_rec + d)\n\nans = no_route\n\n# A state where all vertices other than (v-1) have been visited.\ndp_comp = dp[(1 << (V - 1)) - 1]\n\nfor s, d in adj[V - 1]:\n    comp_rec = dp_comp[s]\n    if comp_rec != no_route:\n        ans = min(ans, comp_rec + d)\n\nif ans == no_route:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t, d = map(int, raw_input().split())\n    g[s].append((t, d))\nINF = 1e9\ndp = [[INF]*V for i in xrange(2**V)]\ndef dfs(state, v, s):\n    if state == 2**V-1:\n        for t, d in g[v]:\n            if t==s:\n                return d\n        return INF\n    if dp[state][v] != INF:\n        return dp[state][v]\n    res = INF\n    for t, d in g[v]:\n        if state & (1 << t):\n            continue\n        r = dfs(state | (1 << t), t, s) + d\n        res = min(res, r)\n    dp[state][v] = res\n    return res\nres = min(dfs(1<<v, v, v) for v in xrange(V))\nprint res if res<INF else -1"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools,queue\n\nsys.setrecursionlimit(10**7)\nINF = 20000\nEPS = 1.0 / 10**10\nMOD = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\nn, e = LI()\ndist = [[INF for _ in range(n)] for _ in range(n)]\nfor _ in range(e):\n    a,b,c = LI()\n    dist[a][b] = c\n\ndp = [[INF for _ in range(n)] for _ in range(1<<n)]\n\nq = queue.Queue()\n\nfor i in range(1,n):\n    if dist[0][i] < INF:\n        dp[1 | (1<<i)][i] = dist[0][i]\n        q.put((1 | (1<<i),i))\n\nwhile not q.empty():\n    bit, v = q.get()\n    for u in range(1,n):\n        if dist[v][u] < INF and not(bit & (1<<u)):\n            next_bit = bit | (1<<u)\n            if dp[next_bit][u]  == INF:\n                q.put((next_bit, u))\n            dp[next_bit][u] = min(dp[next_bit][u], dp[bit][v] + dist[v][u])\n\nans = INF\nfor i in range(1,n):\n    ans = min(ans, dp[(1<<n)-1][i] + dist[i][0])\nif ans < INF:\n    print (ans)\nelse:\n    print (-1)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 50\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "INF=10**18\nV,E=map(int,input().split())\nG=[[INF]*V for i in range(V)]\nfor i in range(E):\n    s,t,d=map(int,input().split())\n    G[s][t]=d\nans=INF\ndp=[[INF]*V for i in range(1<<V)]\ndp[0][0]=0\n    \nfor S in range(1<<V):\n    for v in range(V):\n        if S&(1<<v):\n            for j in range(V):\n                dp[S][v]=min(dp[S][v],dp[S-(1<<v)][j]+G[j][v])\nprint(dp[(1<<V)-1][0] if dp[(1<<V)-1][0]!=INF else -1)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 66\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\ndef main():\n\tV, E = MAP()\n\tgraph = [[] for _ in range(V)]\n\tfor _ in range(E):\n\t\ts, t, d = MAP()\n\t\tgraph[s].append((t, d))\n\n\tdp = [[INF]*V for _ in range(1<<V)]\n\tdp[(1<<V)-1][0] = 0\n\tfor S in range((1<<V)-2, -1, -1):\n\t\tfor v in range(V):\n\t\t\tfor to, cost in graph[v]:\n\t\t\t\tif not ((S>>to) & 1):\n\t\t\t\t\tdp[S][v] = min(dp[S][v], dp[S|1<<to][to]+cost)\n\tif dp[0][0] != INF:\n\t\tprint(dp[0][0])\n\telse:\n\t\tprint(-1)\n\nif __name__ == '__main__':\n\tmain()\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nV, E = map(int, file_input.readline().split())\n\nD = [[] for i in range(V)]\n\nfor line in file_input:\n    s, t, d = map(int, line.split())\n    D[s].append((t, d))\n\nmax_d = 15001\n\n# Full search with bit mask\ndef tsp(v, b):\n    if b == (1 << V) - 1:\n        if D[v]:\n            t, d = min(D[v])\n            if t == 0:\n                return d\n            else:\n                return max_d\n        else:\n            return max_d\n    res = max_d\n    for t, d in D[v]:\n        if b & (1 << t):\n            continue\n        res = min(res, d + tsp(t, b | (1 << t)))\n    return res\n\n# Output\nans = tsp(0, 1)\n\nif ans == max_d:\n    print(-1)\nelse:\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    V, E = map(int, input().split())\n    edges = [[] for _ in [0]*V]\n    for _ in [0]*E:\n        s, t, d = map(int, input().split())\n        edges[s].append((t, d))\n\n    result = float(\"inf\")\n    beam_width = 20\n    for i in range(V):\n        q = [(0, i, {i})]\n        for j in range(V-1):\n            _q = []\n            append = _q.append\n            for cost, v, visited in q[:beam_width+1]:\n                for dest, d_cost in edges[v]:\n                    if dest not in visited:\n                        append((cost+d_cost, dest, visited | {dest}))\n            q = sorted(_q)\n        for cost, v, visited in q[:beam_width+1]:\n            for dest, d_cost in edges[v]:\n                if dest == i:\n                    if result > cost + d_cost:\n                        result = cost + d_cost\n                        break\n\n    print(result if result < float(\"inf\") else -1)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "def dfs(g, last, vs, first):\n    if vs:return min(g[last][v] + dfs(g, v, vs - {v}, first) for v in vs)\n    else:return g[last][first]\n\nfrom sys import stdin\nfrom collections import defaultdict\nfrom math import isinf\n\nreadline = stdin.readline\n\nv, e = map(int, readline().split())\ng = [[float('inf')] * v for _ in range(v)]\nfor _ in range(e):\n    s, t, d = map(int, readline().split())\n    g[s][t] = d\n\ncost = []\nvs = set(range(v))\n\nfirst = 0\nfor second in range(1, v):\n    if isinf(g[first][second]):continue\n    cost.append(g[first][second] + dfs(g, second, vs - {first,second}, first))\n        \nans = min(cost) if cost else -1\nprint(-1 if isinf(ans) else ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nV, E = map(int, input().split())\nINF = 10**9\nG = [[] for _ in range(V)]\nfor _ in range(E):\n    s, t, d = map(int, input().split())\n    G[t].append((s, d))\ndef rec(bit, v):\n    if dp[bit][v] != INF: return dp[bit][v]\n    before = bit^(1<<v)\n    for u, d in G[v]:\n        if before&(1<<u):\n            dp[bit][v] = min(dp[bit][v], rec(before, u)+d)\n        if before == 0 and u == 0:\n            dp[bit][v] = min(dp[bit][v], d)\n    return dp[bit][v]\n# dp[S][v]: 集合Sの中でvが最後になる時の最短距離\ndp = [[INF]*V for _ in range(1<<V)]\nans = INF\nans = min(ans, rec((1<<V)-1, 0))\nif ans != INF:\n    print(ans)\nelse:\n    print(-1)\n"
  },
  {
    "language": "Python",
    "code": "def traveling_salesman(n,edge,INF=10**18):\n    dist = [[INF for j in range(n)] for i in range(n)]\n    for s,t,d in edge:\n        dist[s][t] = d\n    dp = [[INF for j in range(n)] for i in range(2**n)]\n    dp[2**n-1][0] = 0\n    for i in range(2**n-1)[::-1]:\n        for j in range(n):\n            for k in range(n):\n                if not (i>>k & 1):\n                    dp[i][j] = min(dp[i][j],dp[i|1<<k][k]+dist[j][k])\n    return dp[0][0] if dp[0][0]!=INF else -1\n\nV,E = map(int,input().split())\nedge = [tuple(map(int,input().split())) for _ in range(E)]\n\nprint(traveling_salesman(V,edge))\n"
  },
  {
    "language": "Python",
    "code": "#よくわからないがAC\n\nimport sys\nsys.setrecursionlimit(10**7)\n\nn,m=map(int,input().split())\n#G[i]=iに来れるノード\nG=[[] for i in range(n)]\nfor i in range(m):\n    s,t,d=map(int,input().split())\n    G[t].append((s,d))\n\n\ndp=[[float('inf')]*n for i in range(2**n)]\n\n#頂点0からとする\ndp[0][0]=0\n#0からbitを辿ってvに来る(vはSに入っている)\ndef rec(bit,v):\n    if dp[bit][v]!=float('inf'):\n        return dp[bit][v]\n    \n    res=float('inf')\n    #Sからvを取る\n    prev_bit=bit&~(1<<v)\n    #print(bit,v,prev_bit)\n    for u,cost in G[v]:\n        #下手\n        if prev_bit==0 and u==0:\n            res=cost\n            break\n        if not (prev_bit&(1<<u)):\n            continue\n        \n        res=min(res,rec(prev_bit,u)+cost)\n    \n    dp[bit][v]=res\n    return dp[bit][v]\n\nans=rec(2**n-1,0)\nif ans==float('inf'):\n    print(-1)\nelse:\n    print(ans)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\n# 頂点がn個, 辺がw個の場合\nn, w = map(int, input().split())\n\nINF = 1 << 60\ngraph = defaultdict(lambda: INF)\n\nfor _ in range(w):\n    a, b, c = map(int, input().split())\n    graph[(a, b)] = c\n\n# -1でdpテーブルを初期化。bitで集合を管理するので1<<n（状態数） * n（curr）\ndp = [[-1] * n for _ in range(1 << n)]\n\n\n# 既に訪れた集合がs, curr=vの時に0に戻る最短経路を計算\ndef rec(s, v):\n    # 既に計算されている場合はそのまま返す（メモ化再帰）\n    if dp[s][v] >= 0:\n        return dp[s][v]\n\n    # 全ての頂点を訪問済みで、かつcurr=0の場合は0を返す\n    if s == (1 << n) - 1 and v == 0:\n        return 0\n\n    # INFで初期化\n    res = INF\n\n    # sが現在の状態なので、1つずつ右シフトで読んでいく。未訪問（=0）の場合に処理\n    # 最初は全て未訪問\n    for u in range(n):\n        if not (s >> u & 1):\n            # 未訪問を1つずつ潰していくイメージ。uまで訪問していて、curr=uの場合を計算\n            # 1回計算された結果はメモ化再帰で再利用\n            res = min(res, rec(s | (1 << u), u) + graph[(v, u)])\n\n    dp[s][v] = res\n    return dp[s][v]\n\n\nans = rec(0, 0)\n\nprint(-1 if ans == INF else ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nv, e = map(int, input().split())\n\nlinks = [set() for _ in range(v)]\nbests = [None] * (1 << v)\n\nfor _ in range(e):\n    s, t, d = map(int, input().split())\n    links[s].add((t, d))\n\nbests[0] = {0: 0}\n\nfor visited, best in enumerate(bests):\n    if best is None:\n        continue\n    for last, cost in best.items():\n        for t, d in links[last]:\n            new_visited = visited | (1 << t)\n            if visited == new_visited:\n                continue\n            new_best = bests[new_visited]\n            if new_best is None:\n                bests[new_visited] = defaultdict(lambda: 15001, [(t, cost + d)])\n            else:\n                new_best[t] = min(new_best[t], cost + d)\n\nresult = bests[-1]\nprint(-1 if result is None else result[0])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN, M = MAP()\nG = list2d(N, N, INF)\nfor i in range(M):\n    s, t, d = MAP()\n    G[s][t] = d\n\n# dp[bit][i] := 今iにいる時の、集合bitの最短距離\ndp = list2d(1<<N, N, INF)\n# 初期化：頂点0を開始位置として距離0にする\ndp[1][0] = 0\n\nfor bit in range(1, (1<<N)-1):\n    for i in range(N):\n        # 頂点iが集合bitに含まれていない\n        if not bit>>i&1: continue\n        for j in range(N):\n            # 頂点jは既に集合bitに含まれている\n            if bit>>j&1: continue\n            # 頂点iからjへの移動を遷移させる\n            dp[bit+(1<<j)][j] = min(dp[bit+(1<<j)][j], dp[bit][i] + G[i][j])\n\nmn=INF\nfor end in range(N):\n    # 最後の頂点から戻ってくる分を足す\n    mn = min(mn, dp[(1<<N)-1][end] + G[end][0])\nif mn==INF:\n    print(-1)\nelse:\n    print(mn)\n\n"
  },
  {
    "language": "Python",
    "code": "# 49\n\nv, e = map(int, input().split())\nn_l = [[float(\"Inf\")] * v for y in range(v)]\nfor i in range(e):\n    _s, _t, _d = map(int, input().split())\n    n_l[_s][_t] = _d\n\nans = float(\"Inf\")\ndp = [[float(\"Inf\")] * v for y in range(2**v)]\ndp[1][0] = 0\nfor s in range(2**v):\n    for i in range(v):\n        if not((s>>i) & 1):\n            continue\n        _s = s & ~(1<<i)\n        for j in range(v):\n            if (_s>>j) & 1:\n                dp[s][i] = min(dp[s][i], dp[_s][j] + n_l[j][i])\n\nfor i in range(v):\n    ans = min(ans, dp[2**v-1][i] + n_l[i][0])\n                \nif ans != float(\"Inf\"):\n    print(ans)\nelse:\n    print(\"-1\")\n                    \n            \n\n"
  },
  {
    "language": "Python",
    "code": "V,E = map(int,input().split())\ndist = [[float('inf')]*V for _ in range(V)]\nfor _ in range(E):\n  s,t,d = map(int,input().split())\n  s -= 1\n  t -= 1\n  dist[s][t] = d\n\n# dp[mask][destination]\ndp = [ [-1]*V for _ in range(1<<V) ]\nVISITED_ALL = (1<<V)-1\n\ndef tsp(mask, pos):\n  if mask == VISITED_ALL:\n    return dist[pos][0]\n\n  if dp[mask][pos] != -1:\n    return dp[mask][pos]\n\n  ans = float('inf')\n  for city in range(V):\n    if (1<<city)&mask == 0:\n      newAns = dist[pos][city] + tsp(mask | (1<<city), city)\n      ans = min(ans, newAns)\n\n  dp[mask][pos] = ans\n  return ans\n\nres = tsp(1,0)\nif res == float('inf'):\n  print(-1)\nelse:\n  print(res)\n\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int, input().split())\nd = [[10 ** 9] * V for _ in range(V)]\ndp = [[-1] * V for _ in range((1 << V))]\nfor i in range(E):\n    s, t, di = map(int, input().split())\n    d[s][t] = di\n\ndef rec(S, v, dp):\n    # メモ化再帰なのですでに探索済みなら値を返却する\n    if dp[S][v] >= 0: return dp[S][v]\n    # S == (1 << V) - 1はSを二進数表記したときに全てのbitが1であるかどうかを判定している\n    # Sの全てのbitが1かつ、v(現在のノード)が0のときは、一周巡回したということになるので、dp[S][v]=0を設定する\n    if (S == ((1 << V) - 1)) and v == 0:\n        dp[S][v] = 0\n        return 0\n    res = 10 ** 9\n    for u in range(V):\n        # 集合Sを右シフトして左からu番目のbitが0の場合、到達していないノードという判定になるから、そのノードの最短経路を求めにいく\n        if (S >> u & 1) == 0:\n            # 集合Sに対して、今から調査するノードを整数で表すと(1 << u)となるので、S | (1 << u)を引数にする\n            # ちなみにS >> u & 1 == 0であることが確定しているので、orだけじゃなくて加算しても動く\n            res = min(res, rec(S + (1 << u), u, dp) + d[v][u])\n    dp[S][v] = res\n    return dp[S][v]\n\nans = rec(0, 0, dp)\nprint(ans if ans < 10 ** 9 else -1)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import functools\n\n\n@functools.lru_cache(maxsize=None)\ndef rec(state, v):\n    if state == (1 << V) - 1 and v == 0:\n        return 0\n    ret = INF\n    for c, w in edge[v]:\n        if not (state >> c & 1):\n            ret = min(ret, rec(state | 1 << c, c) + w)\n    return ret\n\nINF = 10**6\nV, E = map(int, input().split())\nedge = [[] for _ in range(V)]\nfor _ in range(E):\n    s, t, w = map(int, input().split())\n    edge[s].append((t, w))\nans = rec(0, 0)\nprint(ans if ans != INF else -1)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nINF = 10**12\nV, E = map(int, input().split())\nd = [[INF]*(V) for _ in range(V)]\nfor i in range(E):\n    s, t, dd = map(int, input().split())\n    d[s][t] = dd\ndef f():\n    #dp[i][j] : i　はすでに訪れた集合, 現在いる状態から残りの全ての頂点を巡って頂点０に帰るようなパスの重みの最小値\n    dp = [[INF]*(V) for _ in range(1<<V)]\n    dp[(1<<V)-1][0] = 0\n    for i in range((1<<V)-2, -1, -1):\n        for j in range(V):\n            for k in range(V):\n                if not (i>>k & 1):\n                    dp[i][j] = min(dp[i][j], dp[i | 1 << k][k]+ d[j][k])\n    if dp[0][0] < INF:\n        print(dp[0][0])\n    else:\n        print(-1)\n    \nf()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom typing import List, Tuple\n\n\ndef rec(state: int, v: int, dp: List[List[int]],\n        edges: List[List[Tuple[int, int]]]) -> int:\n    if (dp[state][v] >= 0):\n        return dp[state][v]\n    if ((1 << V) - 1 == state and v == 0):\n        # Reach all vertices and get back to the starting point.\n        dp[state][0] = 0\n        return 0\n\n    ans = sys.maxsize\n    for to, cost in edges[v]:\n        if (not (state >> to & 1)):\n            ans = min(ans, rec(state | 1 << to, to, dp, edges) + cost)\n    dp[state][v] = ans\n    return ans\n\n\nif __name__ == \"__main__\":\n    V, E = map(lambda x: int(x), input().split())\n    edges: List[List[Tuple[int, int]]] = [[] for _ in range(V)]\n    for _ in range(E):\n        source, target, cost = map(lambda x: int(x), input().split())\n        edges[source].append((target, cost))\n\n    dp = [[-1] * V for _ in range(1 << V)]\n    print(dp[0][0] if rec(0, 0, dp, edges) != sys.maxsize else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "def rec(visited,curpos):\n    if (dp[visited][curpos] >= 0): return dp[visited][curpos]\n\n    if (curpos == 0) & (visited == ((1 << v) - 1)) : \n        dp[visited][curpos] = 0\n        return 0\n    ret = float('inf')\n    for i in range(v):\n        if not ((visited >> i) & 1):\n            ret = min(ret , rec((visited | 1 << i) , i ) + dis[curpos][i])\n    dp[visited][curpos] = ret\n    return ret\n\nv,e = map(int, input().split())\ndis = [[float('inf') for i in range(v)] for j in range(v)]\ndp = [[-1 for j in range(v)] for k in range(1 << v)]\n\nfor i in range(e):\n    s,t,d = map(int, input().split())\n    dis[s][t] = d\n\nans = float('inf')\nrec(0,0)\nans = min(ans , dp[0][0])\n\nif ans == float('inf'):\n    print('-1')\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "v, e = map(int, input().split())\n\ndp = [[float(\"inf\")] * (v) for _ in range(1 << v)]\nedges = [[float(\"inf\")] * v for _ in range(v)]\n\n\nfor edge in range(e):\n    frm, to, w = map(int, input().split())\n    edges[frm][to] = w\n\ndp[1][0] = 0\n\nfor i in range(1 << v):\n    for j in range(v):\n        if dp[i][j] == float(\"inf\"):\n            continue\n        for k in range(v):\n            if (i >> k) % 2 == 1:\n                continue\n            next_d = dp[i][j] + edges[j][k]\n            next_i = i | (1 << k)\n\n            dp[next_i][k] = min(dp[next_i][k], next_d)\n\nall = (1 << v) - 1\nans = float(\"inf\")\n\nfor i in range(1, v):\n    ans = min(ans, dp[all][i] + edges[i][0])\n\nif ans == float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "N,e = map(int, input().split())\ninf = float(\"inf\")\nadj = [[inf for _ in range(N)]  for _ in range(N)]\nfor _ in range(e):\n    s,t,d = map(int, input().split())\n    adj[s][t] = d\n\ndef memorize(f):\n    cache = {}\n    def func(*args):\n        if args not in cache:\n            cache[args] = f(*args)\n        return cache[args]\n    return func\n\n@memorize\ndef tsp(v, b):\n    if b == (1 << N) - 1:\n        return adj[v][0]\n    res = inf\n    for w in range(N):\n        if b & (1 << w): continue\n        res = min(res, adj[v][w] + tsp(w, b | (1 << w)))\n    return res\n\nif tsp(0,1) == inf:\n    print(-1)\nelse: print(tsp(0,1))"
  },
  {
    "language": "Python",
    "code": "INF = 10**10\nv, e = map(int, input().split())\ndis = [[INF]*v for _ in range(v)]\n\nfor i in range(e):\n    frm, to, d = map(int, input().split())\n    dis[frm][to] = d\n  \nmem = {}\nend = 2**v-1\n\ndef minCost(state, pos):\n    if state==end:\n        return dis[pos][0]\n    \n    if (state,pos) in mem:\n        return mem[(state, pos)]\n    \n    nxt = 1\n    ret = INF\n    \n    for to in range(v):\n        if 1<<to & state:\n            continue\n        \n        ret = min(ret, minCost(state|1<<to, to) + dis[pos][to])\n        \n    mem[(state, pos)] = ret\n    \n    return ret\n\nans = minCost(1, 0)\n\nif ans>=INF:\n    print(-1)\nelse:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef rec(p, V, bit, dist, matrix):\n  if 2 ** V - 1 == bit and p == 0:\n    return dist\n\n  mindist = sys.maxint\n  for i in range(V):\n    if bit & 2 ** i == 0 and matrix[p][i] != sys.maxint:\n      mindist = min(mindist, rec(i, V, bit | 2 ** i, dist + matrix[p][i], matrix))\n  return mindist\n\nipt = raw_input().split()\nV = int(ipt[0])\nE = int(ipt[1])\ns = {}\nt = {}\nd = {}\nmatrix = [[sys.maxint for i in range(V)] for j in range(V)]\n\nfor i in range(E):\n  ipt = raw_input().split()\n  matrix[int(ipt[0])][int(ipt[1])] = int(ipt[2])\n\nans = rec(0, V, 0, 0, matrix)\nif ans == sys.maxint:\n  print \"-1\"\nelse:\n  print ans"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nconst INF: i64 = 1 << 60;\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    let V: usize = sc.get();\n    let E: usize = sc.get();\n    let mut dist = vec![vec![-1; V]; V];\n    for _ in 0..E {\n        let s: usize = sc.get();\n        let t: usize = sc.get();\n        let d: i64 = sc.get();\n        dist[s][t] = d;\n    }\n    let mut dp = vec![vec![INF; V]; 1<<V];\n    dp[0][0] = 0;\n    for S in 1..1<<V {\n        for v in 0..V {\n            if ((S>>v) & 1) == 0 {\n                continue;\n            }\n            for u in 0..V {\n                if dist[u][v] == -1 {\n                    continue;\n                }\n                dp[S][v] = min(dp[S][v], dp[S & !(1<<v)][u] + dist[u][v]);\n            }\n        }\n    }\n    let ans = dp[(1<<V)-1][0];\n    println!(\"{}\", if ans != INF { ans } else { -1 });\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    input! {\n        V: usize, E: usize,\n        X: [(usize,usize,usize); E],\n    }\n\n    let inf = 1<<60;\n    let mut cost = vec![vec![inf; V]; V]; // cost of s->t\n    for i in 0..X.len() {\n        let (s,t,d) = X[i];\n        cost[s][t] = d;\n    }\n    // dp[bit][t]\n    // bit: visited nodes\n    // t: terminal\n    let mut dp = vec![vec![inf; V]; (1<<V)];\n\n    dp[0][0] = 0;\n    for bit in 1..(1<<V) {\n        for t in 0..V {\n            if bit & (1<<t) > 0 {\n                for k in 0..V {\n                    dp[bit][t] = min(dp[bit][t], dp[bit-(1<<t)][k] + cost[k][t]);\n                }\n            }\n        }\n    }\n\n    let ans = if dp[(1<<V)-1][0] == inf {\n        -1\n    } else {\n        dp[(1<<V)-1][0] as i64\n    };\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::min;\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nconst INF: i32 = std::i32::MAX;\n\nfn main() {\n    input! {\n    v: usize,\n    e: usize,\n    std: [(usize, usize, i32); e]\n    }\n    let mut g = vec![vec![-1; v]; v];\n    for i in 0..e {\n        let (s, t, d) = (std[i].0, std[i].1, std[i].2);\n        g[s][t] = d;\n    }\n    let mut dp = vec![vec![-1; v]; 1 << v];\n    let ans = dfs((1 << v) - 1, 0, &mut dp, &g);\n    println!(\"{}\", if ans < INF {ans} else {-1});\n}\n\nfn dfs(b: usize, t: usize, dp: &mut Vec<Vec<i32>>, g: &Vec<Vec<i32>>) -> i32 {\n    if dp[b][t] >= 0 { return dp[b][t]; }\n    if b.count_ones() == 1 && g[0][t] >= 0 {return g[0][t]}\n    let mut res = INF;\n    let v = dp[0].len();\n    for s in 0..v {\n        if b & (1 << s) == 0 { continue; }\n        if g[s][t] < 0 { continue; }\n        let p = dfs(b ^ (1 << t), s, dp, g);\n        if p == INF { continue; }\n        res = min(res, p + g[s][t]);\n    }\n    dp[b][t] = res;\n    res\n}\n\n"
  }
]