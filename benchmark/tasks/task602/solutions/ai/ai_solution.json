[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_VERTICES 15\n#define INF 1000000000\n\nint graph[MAX_VERTICES][MAX_VERTICES];\nint n;\nint min_cycle_length;\n\nvoid traveling_salesman_dp(int mask, int pos, int first_vertex, int curr_length) {\n    if (mask == (1 << n) - 1) {\n        if (graph[pos][first_vertex] != 0) {\n            min_cycle_length = (curr_length + graph[pos][first_vertex] < min_cycle_length) ? \n                                curr_length + graph[pos][first_vertex] : min_cycle_length;\n        }\n        return;\n    }\n\n    for (int next = 0; next < n; next++) {\n        if ((mask & (1 << next)) == 0 && graph[pos][next] != 0) {\n            traveling_salesman_dp(mask | (1 << next), next, first_vertex, \n                                  curr_length + graph[pos][next]);\n        }\n    }\n}\n\nint find_shortest_hamiltonian_cycle() {\n    min_cycle_length = INF;\n\n    for (int start = 0; start < n; start++) {\n        traveling_salesman_dp(1 << start, start, start, 0);\n    }\n\n    return (min_cycle_length == INF) ? -1 : min_cycle_length;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    int result = find_shortest_hamiltonian_cycle();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_V 20\n\nint n;\nint graph[MAX_V][MAX_V];\nint dp[1 << MAX_V][MAX_V];\n\nint tsp() {\n    int i, mask, u, v;\n    int min_cost = INT_MAX;\n    int full_mask = (1 << n) - 1;\n\n    for (mask = 0; mask < (1 << n); mask++) {\n        for (u = 0; u < n; u++) {\n            dp[mask][u] = INT_MAX;\n        }\n    }\n\n    for (u = 0; u < n; u++) {\n        dp[1 << u][u] = 0;\n    }\n\n    for (mask = 1; mask < (1 << n); mask++) {\n        for (u = 0; u < n; u++) {\n            if (mask & (1 << u)) {\n                for (v = 0; v < n; v++) {\n                    if (!(mask & (1 << v)) && graph[u][v] != 0) {\n                        int new_mask = mask | (1 << v);\n                        if (dp[mask][u] != INT_MAX && dp[new_mask][v] > dp[mask][u] + graph[u][v]) {\n                            dp[new_mask][v] = dp[mask][u] + graph[u][v];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (u = 0; u < n; u++) {\n        if (dp[full_mask][u] != INT_MAX && graph[u][0] != 0) {\n            int total_cost = dp[full_mask][u] + graph[u][0];\n            if (total_cost < min_cost) {\n                min_cost = total_cost;\n            }\n        }\n    }\n\n    return (min_cost == INT_MAX) ? -1 : min_cost;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n    printf(\"%d\\n\", tsp());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint shortestCycle(vector<vector<int>>& graph, int n) {\n    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX / 2));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[1 << i][i] = 0;\n    }\n    \n    for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int last = 0; last < n; ++last) {\n            if (!(mask & (1 << last))) continue;\n            for (int next = 0; next < n; ++next) {\n                if (mask & (1 << next)) continue;\n                if (graph[last][next] == 0) continue;\n                int new_mask = mask | (1 << next);\n                dp[new_mask][next] = min(dp[new_mask][next], dp[mask][last] + graph[last][next]);\n            }\n        }\n    }\n    \n    int full_mask = (1 << n) - 1;\n    int min_cycle = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        if (dp[full_mask][i] != INT_MAX / 2 && graph[i][0] != 0) {\n            min_cycle = min(min_cycle, dp[full_mask][i] + graph[i][0]);\n        }\n    }\n    \n    return (min_cycle == INT_MAX) ? -1 : min_cycle;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> graph[i][j];\n        }\n    }\n    \n    int result = shortestCycle(graph, n);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortestHamiltonianCycle {\n    public int shortestCycle(int[][] graph) {\n        int n = graph.length;\n        int[][] dp = new int[1 << n][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE / 2);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            dp[1 << i][i] = 0;\n        }\n        \n        for (int mask = 0; mask < (1 << n); mask++) {\n            for (int last = 0; last < n; last++) {\n                if ((mask & (1 << last)) == 0) continue;\n                for (int next = 0; next < n; next++) {\n                    if ((mask & (1 << next)) != 0) continue;\n                    if (graph[last][next] == 0) continue;\n                    int newMask = mask | (1 << next);\n                    dp[newMask][next] = Math.min(dp[newMask][next], dp[mask][last] + graph[last][next]);\n                }\n            }\n        }\n        \n        int minCycle = Integer.MAX_VALUE;\n        int fullMask = (1 << n) - 1;\n        for (int i = 0; i < n; i++) {\n            if (graph[i][0] == 0) continue;\n            minCycle = Math.min(minCycle, dp[fullMask][i] + graph[i][0]);\n        }\n        \n        return minCycle == Integer.MAX_VALUE / 2 ? -1 : minCycle;\n    }\n}",
    "timestamp": "2025-08-05 22:18:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int shortestCycle(int n, int[][] edges) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n        }\n        \n        int minCycleLength = Integer.MAX_VALUE;\n        \n        for (int start = 0; start < n; start++) {\n            int[] dist = new int[n];\n            int[] parent = new int[n];\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            Arrays.fill(parent, -1);\n            \n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(start);\n            dist[start] = 0;\n            \n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                \n                for (int neighbor : graph.get(current)) {\n                    if (dist[neighbor] == Integer.MAX_VALUE) {\n                        dist[neighbor] = dist[current] + 1;\n                        parent[neighbor] = current;\n                        queue.offer(neighbor);\n                    } else if (parent[current] != neighbor) {\n                        minCycleLength = Math.min(minCycleLength, dist[current] + dist[neighbor] + 1);\n                    }\n                }\n            }\n        }\n        \n        return minCycleLength == Integer.MAX_VALUE ? -1 : minCycleLength;\n    }\n}",
    "timestamp": "2025-08-05 22:18:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <climits>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int shortestRoute(int n, std::vector<std::vector<int>>& edges) {\n        const int INF = INT_MAX / 2;\n        std::vector<std::vector<int>> dist(n, std::vector<int>(n, INF));\n        \n        // Initialize distances for direct edges\n        for (const auto& edge : edges) {\n            dist[edge[0]][edge[1]] = edge[2];\n        }\n        \n        // Floyd-Warshall to find all-pairs shortest paths\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        int minCycle = INF;\n        \n        // Check all possible Hamiltonian cycles\n        for (int start = 0; start < n; start++) {\n            std::vector<int> path(n);\n            for (int i = 0; i < n; i++) {\n                path[i] = i;\n            }\n            \n            do {\n                if (path[0] != start) continue;\n                \n                int cycleLength = 0;\n                bool validCycle = true;\n                \n                for (int i = 0; i < n - 1; i++) {\n                    if (dist[path[i]][path[i+1]] == INF) {\n                        validCycle = false;\n                        break;\n                    }\n                    cycleLength += dist[path[i]][path[i+1]];\n                }\n                \n                if (validCycle) {\n                    // Check last edge to form a cycle\n                    if (dist[path[n-1]][path[0]] != INF) {\n                        cycleLength += dist[path[n-1]][path[0]];\n                        minCycle = std::min(minCycle, cycleLength);\n                    }\n                }\n            } while (std::next_permutation(path.begin(), path.end()));\n        }\n        \n        return minCycle == INF ? -1 : minCycle;\n    }\n};",
    "timestamp": "2025-08-05 22:18:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef shortest_hamiltonian_cycle(graph):\n    V = len(graph)\n    min_cycle = float('inf')\n    vertices = range(V)\n    \n    for perm in permutations(vertices):\n        if graph[perm[-1]][perm[0]] == 0:\n            continue\n        current_weight = sum(graph[perm[i]][perm[i + 1]] for i in range(V - 1)) + graph[perm[-1]][perm[0]]\n        \n        if current_weight < min_cycle:\n            min_cycle = current_weight\n    \n    return min_cycle if min_cycle != float('inf') else -1\n\n# Example graph as an adjacency matrix with 0 indicating no direct path\ngraph = [\n    [0, 29, 20, 21],\n    [29, 0, 15, 17],\n    [20, 15, 0, 28],\n    [21, 17, 28, 0]\n]\n\n# Call the function with the example graph\nprint(shortest_hamiltonian_cycle(graph))",
    "timestamp": "2025-08-13 09:50:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ShortestHamiltonianCycle {\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int shortestHamiltonianCycle(int[][] graph) {\n        int n = graph.length;\n        int V = 1 << n;\n        int[][] dp = new int[V][n];\n\n        for (int i = 0; i < V; i++) {\n            Arrays.fill(dp[i], INF);\n        }\n\n        dp[1][0] = 0; // start from vertex 0\n\n        for (int mask = 1; mask < V; mask++) {\n            for (int u = 0; u < n; u++) {\n                if ((mask & (1 << u)) == 0) continue;\n                for (int v = 0; v < n; v++) {\n                    if ((mask & (1 << v)) != 0 || graph[u][v] == 0) continue;\n                    dp[mask | (1 << v)][v] = Math.min(dp[mask | (1 << v)][v], dp[mask][u] + graph[u][v]);\n                }\n            }\n        }\n\n        int minCycle = INF;\n        for (int i = 1; i < n; i++) {\n            if (graph[i][0] != 0 && dp[V - 1][i] != INF) {\n                minCycle = Math.min(minCycle, dp[V - 1][i] + graph[i][0]);\n            }\n        }\n        return minCycle == INF ? -1 : minCycle;\n    }\n\n    public static void main(String[] args) {\n        int[][] graph = {\n            {0, 29, 20, 21},\n            {29, 0, 15, 17},\n            {20, 15, 0, 28},\n            {21, 17, 28, 0}\n        };\n        System.out.println(shortestHamiltonianCycle(graph));\n    }\n}",
    "timestamp": "2025-08-13 09:50:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define V 20 // Maximum number of vertices\n#define INFINITE INT_MAX\n\nint tsp(int graph[][V], int mask, int pos, int n, int dp[][V]) {\n    if (mask == ((1 << n) - 1)) {\n        return graph[pos][0] ? graph[pos][0] : INFINITE;\n    }\n    if (dp[mask][pos] != -1) {\n        return dp[mask][pos];\n    }\n    int ans = INFINITE;\n    for (int city = 0; city < n; city++) {\n        if ((mask & (1 << city)) == 0 && graph[pos][city]) {\n            int newAns = graph[pos][city] + tsp(graph, mask | (1 << city), city, n, dp);\n            if (newAns < ans) {\n                ans = newAns;\n            }\n        }\n    }\n    return dp[mask][pos] = ans;\n}\n\nint findShortestHamiltonianCycle(int graph[][V], int n) {\n    if (n <= 1) return -1;\n    int dp[1 << V][V];\n    for (int i = 0; i < (1 << V); i++) {\n        for (int j = 0; j < V; j++) {\n            dp[i][j] = -1;\n        }\n    }\n    int cycleLength = tsp(graph, 1, 0, n, dp);\n    return cycleLength == INFINITE ? -1 : cycleLength;\n}\n\nint main() {\n    int graph[V][V] = {\n        // Example graph\n        {0, 10, 15, 20},\n        {10, 0, 35, 25},\n        {15, 35, 0, 30},\n        {20, 25, 30, 0}\n    };\n    int n = 4; // Number of vertices\n    int result = findShortestHamiltonianCycle(graph, n);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:51:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\nimport sys\n\ndef solve_traveling_salesman_problem(graph):\n    vertices = list(graph.keys())\n    n = len(vertices)\n    \n    if n <= 1:\n        return -1\n    \n    min_cycle_cost = sys.maxsize\n    \n    for perm in permutations(vertices):\n        current_cost = 0\n        valid_path = True\n        \n        for i in range(n):\n            start = perm[i]\n            end = perm[(i + 1) % n]\n            \n            if end not in graph[start]:\n                valid_path = False\n                break\n            \n            current_cost += graph[start][end]\n        \n        if valid_path:\n            min_cycle_cost = min(min_cycle_cost, current_cost)\n    \n    return min_cycle_cost if min_cycle_cost != sys.maxsize else -1",
    "timestamp": "2025-08-13 09:51:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import permutations\n\ndef shortest_cycle(graph):\n    n = len(graph)\n    if n == 0:\n        return -1\n    vertices = range(n)\n    min_dist = sys.maxsize\n    \n    for perm in permutations(vertices[1:]):\n        current_path = [0] + list(perm)\n        total_dist = 0\n        valid = True\n        \n        for i in range(len(current_path)):\n            u = current_path[i]\n            v = current_path[(i + 1) % n]\n            if graph[u][v] == 0:\n                valid = False\n                break\n            total_dist += graph[u][v]\n        \n        if valid and total_dist < min_dist:\n            min_dist = total_dist\n    \n    return min_dist if min_dist != sys.maxsize else -1\n\n# Example usage:\n# graph = [\n#     [0, 10, 15, 20],\n#     [10, 0, 35, 25],\n#     [15, 35, 0, 30],\n#     [20, 25, 30, 0]\n# ]\n# print(shortest_cycle(graph))",
    "timestamp": "2025-08-13 09:51:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint main() {\n    int n, e;\n    cin >> n >> e;\n\n    vector<vector<int>> dist(n, vector<int>(n, INF));\n\n    for (int i = 0; i < e; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        dist[u][v] = w;\n    }\n\n    vector<vector<int>> dp(1 << n, vector<int>(n, INF));\n\n    for (int i = 0; i < n; ++i) {\n        dp[1 << i][i] = 0;\n    }\n\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int u = 0; u < n; ++u) {\n            if (!(mask & (1 << u)))\n                continue;\n            for (int v = 0; v < n; ++v) {\n                if (mask & (1 << v) || dist[u][v] == INF)\n                    continue;\n                dp[mask | (1 << v)][v] = min(dp[mask | (1 << v)][v], dp[mask][u] + dist[u][v]);\n            }\n        }\n    }\n\n    int res = INF;\n    for (int i = 0; i < n; ++i) {\n        if (dist[i][i] == INF) continue;\n        res = min(res, dp[(1 << n) - 1][i] + dist[i][i]);\n    }\n\n    if (res >= INF) {\n        cout << -1 << endl;\n    } else {\n        cout << res << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:55:11"
  }
]