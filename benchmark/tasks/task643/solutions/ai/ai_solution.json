[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\nint grid[MAX_N][MAX_M];\nint chosen[MAX_N][MAX_M];\nint N, M, K;\n\ntypedef struct {\n    int value;\n    int row;\n    int col;\n} Square;\n\nint compare(const void* a, const void* b) {\n    Square* s1 = (Square*)a;\n    Square* s2 = (Square*)b;\n    return s2->value - s1->value;\n}\n\nint solve() {\n    Square squares[MAX_N * MAX_M];\n    int square_count = 0;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            squares[square_count].value = grid[i][j];\n            squares[square_count].row = i;\n            squares[square_count].col = j;\n            square_count++;\n        }\n    }\n    \n    qsort(squares, square_count, sizeof(Square), compare);\n    \n    memset(chosen, 0, sizeof(chosen));\n    int row_count[MAX_N] = {0};\n    int col_count[MAX_M] = {0};\n    int total_value = 0;\n    \n    for (int i = 0; i < square_count; i++) {\n        int row = squares[i].row;\n        int col = squares[i].col;\n        \n        if (row_count[row] < K && col_count[col] < K) {\n            chosen[row][col] = 1;\n            total_value += squares[i].value;\n            row_count[row]++;\n            col_count[col]++;\n        }\n    }\n    \n    return total_value;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int max_value = solve();\n    printf(\"%d\\n\", max_value);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            printf(\"%d \", chosen[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int value;\n    int row;\n    int col;\n} Cell;\n\nint compare(const void *a, const void *b) {\n    return ((Cell *)b)->value - ((Cell *)a)->value;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    Cell *cells = (Cell *)malloc(N * M * sizeof(Cell));\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &cells[idx].value);\n            cells[idx].row = i;\n            cells[idx].col = j;\n            idx++;\n        }\n    }\n    \n    qsort(cells, N * M, sizeof(Cell), compare);\n    \n    int *row_count = (int *)calloc(N, sizeof(int));\n    int *col_count = (int *)calloc(M, sizeof(int));\n    int **selected = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        selected[i] = (int *)calloc(M, sizeof(int));\n    }\n    \n    long long sum = 0;\n    for (int i = 0; i < N * M; i++) {\n        int r = cells[i].row;\n        int c = cells[i].col;\n        if (row_count[r] < K && col_count[c] < K) {\n            selected[r][c] = 1;\n            sum += cells[i].value;\n            row_count[r]++;\n            col_count[c]++;\n        }\n    }\n    \n    printf(\"%lld\\n\", sum);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            printf(\"%d \", selected[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    free(cells);\n    free(row_count);\n    free(col_count);\n    for (int i = 0; i < N; i++) {\n        free(selected[i]);\n    }\n    free(selected);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, rev, capacity;\n    long long cost;\n};\n\nclass MinCostMaxFlow {\nprivate:\n    int n;\n    vector<vector<Edge>> graph;\n    vector<long long> potential, dist;\n    vector<int> prev_node, prev_edge;\n    vector<bool> in_queue;\n\npublic:\n    MinCostMaxFlow(int n) : n(n), graph(n), potential(n, 0), dist(n), prev_node(n), prev_edge(n), in_queue(n) {}\n\n    void add_edge(int from, int to, int capacity, long long cost) {\n        graph[from].push_back({to, (int)graph[to].size(), capacity, cost});\n        graph[to].push_back({from, (int)graph[from].size() - 1, 0, -cost});\n    }\n\n    pair<long long, long long> flow(int s, int t, int maxf) {\n        long long flow = 0;\n        long long total_cost = 0;\n        while (flow < maxf) {\n            fill(dist.begin(), dist.end(), LLONG_MAX);\n            fill(in_queue.begin(), in_queue.end(), false);\n            queue<int> q;\n            q.push(s);\n            dist[s] = 0;\n            in_queue[s] = true;\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                in_queue[u] = false;\n                for (int i = 0; i < graph[u].size(); ++i) {\n                    Edge &e = graph[u][i];\n                    if (e.capacity > 0 && dist[e.to] > dist[u] + e.cost + potential[u] - potential[e.to]) {\n                        dist[e.to] = dist[u] + e.cost + potential[u] - potential[e.to];\n                        prev_node[e.to] = u;\n                        prev_edge[e.to] = i;\n                        if (!in_queue[e.to]) {\n                            in_queue[e.to] = true;\n                            q.push(e.to);\n                        }\n                    }\n                }\n            }\n            if (dist[t] == LLONG_MAX) break;\n            for (int i = 0; i < n; ++i) {\n                if (dist[i] != LLONG_MAX) potential[i] += dist[i];\n            }\n            int f = maxf - flow;\n            for (int u = t; u != s; u = prev_node[u]) {\n                f = min(f, graph[prev_node[u]][prev_edge[u]].capacity);\n            }\n            flow += f;\n            total_cost += f * potential[t];\n            for (int u = t; u != s; u = prev_node[u]) {\n                Edge &e = graph[prev_node[u]][prev_edge[u]];\n                e.capacity -= f;\n                graph[u][e.rev].capacity += f;\n            }\n        }\n        return {flow, total_cost};\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    int source = 0;\n    int row_start = 1;\n    int col_start = row_start + N;\n    int sink = col_start + M;\n    int total_nodes = sink + 1;\n\n    MinCostMaxFlow mcmf(total_nodes);\n\n    for (int i = 0; i < N; ++i) {\n        mcmf.add_edge(source, row_start + i, K, 0);\n    }\n    for (int j = 0; j < M; ++j) {\n        mcmf.add_edge(col_start + j, sink, K, 0);\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            mcmf.add_edge(row_start + i, col_start + j, 1, -A[i][j]);\n        }\n    }\n\n    auto result = mcmf.flow(source, sink, N * K);\n    cout << -result.second << '\\n';\n\n    vector<vector<char>> output(N, vector<char>(M, '.'));\n    for (int i = 0; i < N; ++i) {\n        for (const Edge &e : mcmf.graph[row_start + i]) {\n            if (e.to >= col_start && e.to < col_start + M && e.capacity == 0) {\n                int j = e.to - col_start;\n                output[i][j] = 'X';\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            cout << output[i][j];\n        }\n        cout << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GridSelection {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        int[][] A = new int[N][M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                A[i][j] = scanner.nextInt();\n            }\n        }\n\n        List<int[]> elements = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                elements.add(new int[]{A[i][j], i, j});\n            }\n        }\n        elements.sort((a, b) -> Integer.compare(b[0], a[0]));\n\n        int[] rowCount = new int[N];\n        int[] colCount = new int[M];\n        boolean[][] chosen = new boolean[N][M];\n        long total = 0;\n\n        for (int[] element : elements) {\n            int val = element[0];\n            int i = element[1];\n            int j = element[2];\n            if (rowCount[i] < K && colCount[j] < K) {\n                chosen[i][j] = true;\n                total += val;\n                rowCount[i]++;\n                colCount[j]++;\n            }\n        }\n\n        System.out.println(total);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                System.out.print(chosen[i][j] ? \"1 \" : \"0 \");\n            }\n            System.out.println();\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:26:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxSquareSelection {\n    static int[][] grid;\n    static int N, M, K;\n    static int[][] selection;\n    static int maxValue;\n\n    public static int[] solve(int[][] A, int maxPerRowCol) {\n        grid = A;\n        N = A.length;\n        M = A[0].length;\n        K = maxPerRowCol;\n        selection = new int[N][M];\n        maxValue = 0;\n\n        // Use dynamic programming with bitmask to solve\n        int[] result = new int[N * M + 2];\n        backtrack(0, 0, 0);\n\n        // Populate result array\n        result[0] = maxValue;\n        int index = 1;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (selection[i][j] == 1) {\n                    result[index++] = i * M + j;\n                }\n            }\n        }\n        result[index] = -1;\n\n        return result;\n    }\n\n    static void backtrack(int row, int currentValue, int[] rowCount, int[] colCount) {\n        if (row == N) {\n            maxValue = Math.max(maxValue, currentValue);\n            return;\n        }\n\n        // Try not selecting current row\n        backtrack(row + 1, currentValue, rowCount, colCount);\n\n        // Try selecting possible squares in current row\n        for (int j = 0; j < M; j++) {\n            if (rowCount[row] < K && colCount[j] < K) {\n                rowCount[row]++;\n                colCount[j]++;\n                selection[row][j] = 1;\n                \n                backtrack(row + 1, \n                          currentValue + grid[row][j], \n                          rowCount, \n                          colCount);\n                \n                // Backtrack\n                rowCount[row]--;\n                colCount[j]--;\n                selection[row][j] = 0;\n            }\n        }\n    }\n\n    static void backtrack(int row, int currentValue) {\n        int[] rowCount = new int[N];\n        int[] colCount = new int[M];\n        backtrack(row, currentValue, rowCount, colCount);\n    }\n}",
    "timestamp": "2025-08-05 22:26:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 205;\nint grid[MAXN][MAXN];\nint N, M, K;\nvector<pair<int, pair<int, int>>> candidates;\nint rowCount[MAXN], colCount[MAXN];\nvector<pair<int, int>> chosen;\n\nbool canInclude(int r, int c) {\n    return rowCount[r] < K && colCount[c] < K;\n}\n\nint solve() {\n    sort(candidates.rbegin(), candidates.rend());\n    \n    memset(rowCount, 0, sizeof(rowCount));\n    memset(colCount, 0, sizeof(colCount));\n    chosen.clear();\n    \n    int totalSum = 0;\n    for (auto& candidate : candidates) {\n        int val = candidate.first;\n        int r = candidate.second.first;\n        int c = candidate.second.second;\n        \n        if (canInclude(r, c)) {\n            totalSum += val;\n            rowCount[r]++;\n            colCount[c]++;\n            chosen.push_back({r, c});\n        }\n    }\n    \n    return totalSum;\n}\n\nint main() {\n    cin >> N >> M >> K;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n            candidates.push_back({grid[i][j], {i, j}});\n        }\n    }\n    \n    int maxSum = solve();\n    \n    cout << maxSum << endl;\n    \n    cout << chosen.size() << endl;\n    for (auto& p : chosen) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import product\nfrom ortools.linear_solver import pywraplp\n\ndef max_sum_of_squares(grid, N, M, K):\n    solver = pywraplp.Solver.CreateSolver('SCIP')\n    if not solver:\n        return None\n\n    # Variables\n    x = {}\n    for i in range(N):\n        for j in range(M):\n            x[i, j] = solver.IntVar(0, 1, f'x_{i}_{j}')\n\n    # Constraints\n    for i in range(N):\n        solver.Add(sum(x[i, j] for j in range(M)) <= K)  # At most K in each row\n    for j in range(M):\n        solver.Add(sum(x[i, j] for i in range(N)) <= K)  # At most K in each column\n\n    # Objective\n    solver.Maximize(solver.Sum(grid[i][j] * x[i, j] for i, j in product(range(N), range(M))))\n\n    # Solve\n    solver.Solve()\n\n    # Retrieve results\n    max_value = solver.Objective().Value()\n    chosen_squares = [(i, j) for i in range(N) for j in range(M) if x[i, j].solution_value() > 0]\n\n    return max_value, chosen_squares\n\n# Example usage (you can replace this with your test cases)\nif __name__ == '__main__':\n    grid = [\n        [3, 7, 9],\n        [2, 1, 8],\n        [4, 6, 5]\n    ]\n    N = 3\n    M = 3\n    K = 1\n    max_value, chosen_squares = max_sum_of_squares(grid, N, M, K)\n    print(\"Maximum value:\", max_value)\n    print(\"Chosen squares:\", chosen_squares)",
    "timestamp": "2025-08-13 10:32:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridMaximumSum {\n    static class Square {\n        int row, col, value;\n        Square(int row, int col, int value) {\n            this.row = row;\n            this.col = col;\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        int N = 4; // Number of rows\n        int M = 4; // Number of columns\n        int K = 2; // Maximum chosen squares per row and column\n        int[][] A = {\n            {5, 3, 8, 6},\n            {7, 5, 2, 4},\n            {3, 9, 6, 8},\n            {4, 1, 7, 2}\n        };\n\n        int maxSum = getMaxSum(N, M, K, A);\n        System.out.println(\"Maximum Sum: \" + maxSum);\n    }\n\n    public static int getMaxSum(int N, int M, int K, int[][] A) {\n        PriorityQueue<Square> pq = new PriorityQueue<>((a, b) -> b.value - a.value);\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < M; j++)\n                pq.add(new Square(i, j, A[i][j]));\n\n        int[] rowCount = new int[N];\n        int[] colCount = new int[M];\n        List<Square> chosenSquares = new ArrayList<>();\n\n        int maxSum = 0;\n        while (!pq.isEmpty()) {\n            Square square = pq.poll();\n            if (rowCount[square.row] < K && colCount[square.col] < K) {\n                chosenSquares.add(square);\n                maxSum += square.value;\n                rowCount[square.row]++;\n                colCount[square.col]++;\n            }\n        }\n\n        System.out.println(\"Chosen Squares: \");\n        for (Square s : chosenSquares) {\n            System.out.println(\"Square at (\" + s.row + \", \" + s.col + \") with value \" + s.value);\n        }\n\n        return maxSum;\n    }\n}",
    "timestamp": "2025-08-13 10:32:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 50\n#define MAXM 50\n\nint N, M, K;\nint A[MAXN][MAXM];\nint dp[MAXN + 1][1 << MAXM];\nint choice[MAXN + 1][1 << MAXM];\n\nvoid printSolution(int row, int mask) {\n    if(row == 0) return;\n\n    int prev_mask = choice[row][mask];\n    printSolution(row - 1, prev_mask);\n\n    int chosen_mask = mask & ~prev_mask;\n    for(int j = 0; j < M; j++) {\n        if(chosen_mask & (1 << j)) {\n            printf(\"Choose square (%d, %d)\\n\", row - 1, j);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < M; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    memset(dp, 0, sizeof(dp));\n\n    for(int i = 1; i <= N; i++) {\n        for(int mask = 0; mask < (1 << M); mask++) {\n            if(__builtin_popcount(mask) > K) continue;\n\n            for(int prev_mask = 0; prev_mask < (1 << M); prev_mask++) {\n                int valid = 1;\n                for(int j = 0; j < M; j++) {\n                    if((mask & (1 << j)) && (prev_mask & (1 << j))) {\n                        valid = 0;\n                        break;\n                    }\n                }\n                if(valid) {\n                    int sum = 0;\n                    for(int j = 0; j < M; j++) {\n                        if(mask & (1 << j)) {\n                            sum += A[i - 1][j];\n                        }\n                    }\n\n                    if(dp[i][mask] < dp[i - 1][prev_mask] + sum) {\n                        dp[i][mask] = dp[i - 1][prev_mask] + sum;\n                        choice[i][mask] = prev_mask;\n                    }\n                }\n            }\n        }\n    }\n\n    int maxSum = 0, finalMask = 0;\n    for(int mask = 0; mask < (1 << M); mask++) {\n        if(dp[N][mask] > maxSum) {\n            maxSum = dp[N][mask];\n            finalMask = mask;\n        }\n    }\n\n    printf(\"Maximum Sum: %d\\n\", maxSum);\n    printSolution(N, finalMask);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:32:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_value_square_selection(grid, K):\n    N, M = len(grid), len(grid[0])\n    \n    # Dynamic programming with bitmasking\n    dp = [[-float('inf')] * (1 << M) for _ in range(N + 1)]\n    dp[0][0] = 0\n    \n    # Track selections for backtracking\n    selections = [[[None] * (1 << M) for _ in range(M + 1)] for _ in range(N + 1)]\n    \n    for row in range(N):\n        for mask in range(1 << M):\n            if dp[row][mask] == -float('inf'):\n                continue\n            \n            # Try all possible selections for next row\n            for next_mask in range(1 << M):\n                # Check row constraints\n                row_count = bin(next_mask).count('1')\n                if row_count > K:\n                    continue\n                \n                # Check column constraints\n                valid_mask = True\n                col_counts = [0] * M\n                for col in range(M):\n                    if next_mask & (1 << col):\n                        col_counts[col] += 1\n                        if col_counts[col] > K or (mask & (1 << col) and col_counts[col] > 1):\n                            valid_mask = False\n                            break\n                \n                if not valid_mask:\n                    continue\n                \n                # Calculate value of current selection\n                value = dp[row][mask]\n                for col in range(M):\n                    if next_mask & (1 << col):\n                        value += grid[row][col]\n                \n                # Update dp and selections\n                if value > dp[row + 1][next_mask]:\n                    dp[row + 1][next_mask] = value\n                    selections[row + 1][next_mask] = (row, mask)\n    \n    # Find maximum value\n    max_value = max(dp[N])\n    max_mask = dp[N].index(max_value)\n    \n    # Backtrack to find selected squares\n    result_selections = []\n    current_row, current_mask = N, max_mask\n    \n    while current_row > 0:\n        prev_selection = selections[current_row][current_mask]\n        prev_row, prev_mask = prev_selection\n        \n        # Find selected columns in current row\n        for col in range(M):\n            if current_mask & (1 << col):\n                result_selections.append((prev_row, col))\n        \n        current_row, current_mask = prev_row, prev_mask\n    \n    return max_value, result_selections\n\n# Example usage\ngrid = [\n    [1, 3, 2],\n    [4, 2, 5],\n    [3, 1, 4]\n]\nK = 2\n\nmax_sum, selected_squares = max_value_square_selection(grid, K)\nprint(\"Maximum Sum:\", max_sum)\nprint(\"Selected Squares:\", selected_squares)",
    "timestamp": "2025-08-13 10:33:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity, cost):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n        self.cost = cost\n\nclass MinCostMaxFlow:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap, cost):\n        forward = Edge(to, len(self.graph[to]), cap, cost)\n        backward = Edge(fr, len(self.graph[fr]), 0, -cost)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def flow(self, s, t, maxf):\n        n = self.n\n        res = 0\n        h = [0] * n\n        prevv = [0] * n\n        preve = [0] * n\n        INF = float('inf')\n        f = 0\n        while f < maxf:\n            dist = [INF] * n\n            dist[s] = 0\n            in_queue = [False] * n\n            in_queue[s] = True\n            q = deque([s])\n            while q:\n                v = q.popleft()\n                in_queue[v] = False\n                for i, edge in enumerate(self.graph[v]):\n                    if edge.capacity > 0 and dist[edge.to] > dist[v] + edge.cost + h[v] - h[edge.to]:\n                        dist[edge.to] = dist[v] + edge.cost + h[v] - h[edge.to]\n                        prevv[edge.to] = v\n                        preve[edge.to] = i\n                        if not in_queue[edge.to]:\n                            in_queue[edge.to] = True\n                            q.append(edge.to)\n            if dist[t] == INF:\n                break\n            for v in range(n):\n                if dist[v] < INF:\n                    h[v] += dist[v]\n            d = maxf - f\n            v = t\n            while v != s:\n                d = min(d, self.graph[prevv[v]][preve[v]].capacity)\n                v = prevv[v]\n            f += d\n            res += d * h[t]\n            v = t\n            while v != s:\n                edge = self.graph[prevv[v]][preve[v]]\n                edge.capacity -= d\n                self.graph[v][edge.rev].capacity += d\n                v = prevv[v]\n        return res\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    A = []\n    for _ in range(N):\n        row = list(map(int, input[ptr:ptr+M]))\n        ptr += M\n        A.append(row)\n    \n    # Construct the flow network\n    # Nodes: 0..N-1 are rows, N..N+M-1 are columns, N+M is source, N+M+1 is sink\n    source = N + M\n    sink = N + M + 1\n    mcmf = MinCostMaxFlow(N + M + 2)\n    \n    # Connect source to rows with capacity K, cost 0\n    for i in range(N):\n        mcmf.add_edge(source, i, K, 0)\n    \n    # Connect columns to sink with capacity K, cost 0\n    for j in range(M):\n        mcmf.add_edge(N + j, sink, K, 0)\n    \n    # Connect rows to columns with capacity 1, cost -A[i][j]\n    for i in range(N):\n        for j in range(M):\n            mcmf.add_edge(i, N + j, 1, -A[i][j])\n    \n    total_cost = -mcmf.flow(source, sink, N * K)\n    \n    # Reconstruct the solution\n    chosen = [[False for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        for edge in mcmf.graph[i]:\n            if edge.to >= N and edge.to < N + M and edge.capacity == 0:\n                j = edge.to - N\n                chosen[i][j] = True\n    \n    print(total_cost)\n    for i in range(N):\n        line = []\n        for j in range(M):\n            if chosen[i][j]:\n                line.append('1')\n            else:\n                line.append('0')\n        print(' '.join(line))\n\nsolve()",
    "timestamp": "2025-08-13 10:33:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX = 100;\n\nint N, M, K;\nint A[MAX][MAX];\nint dp[1 << 16][16], select[1 << 16][16];\n\nint main() {\n    cin >> N >> M >> K;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> A[i][j];\n        }\n    }\n\n    int maxMask = 1 << M;\n    for (int mask = 0; mask < maxMask; mask++) {\n        for (int count = 0; count <= K; count++) {\n            dp[mask][count] = INT_MIN;\n        }\n    }\n    \n    dp[0][0] = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int count = 0; count <= K; count++) {\n            for (int mask = 0; mask < maxMask; mask++) {\n                if (dp[mask][count] == INT_MIN) continue;\n                for (int newMask = 0; newMask < maxMask; newMask++) {\n                    int bits = 0, sum = 0;\n                    for (int j = 0; j < M; j++) {\n                        if (newMask & (1 << j)) {\n                            bits++;\n                            sum += A[i][j];\n                        }\n                    }\n                    if (bits <= K) {\n                        int nextCount = count + bits;\n                        if (nextCount <= K) {\n                            int &nextDP = dp[newMask][nextCount];\n                            if (nextDP < dp[mask][count] + sum) {\n                                nextDP = dp[mask][count] + sum;\n                                select[newMask][nextCount] = mask;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    int finalMask = 0, finalCount = 0;\n    \n    for (int mask = 0; mask < maxMask; mask++) {\n        for (int count = 0; count <= K; count++) {\n            if (ans < dp[mask][count]) {\n                ans = dp[mask][count];\n                finalMask = mask;\n                finalCount = count;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    vector<pair<int, int>> chosenSquares;\n    \n    for (int i = N-1; i >= 0; i--) {\n        int prevMask = select[finalMask][finalCount];\n        for (int j = 0; j < M; j++) {\n            if (finalMask & (1 << j)) {\n                chosenSquares.push_back({i, j});\n            }\n        }\n        finalCount -= __builtin_popcount(finalMask);\n        finalMask = prevMask;\n    }\n\n    for (auto &square : chosenSquares) {\n        cout << square.first + 1 << \" \" << square.second + 1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:59:40"
  }
]