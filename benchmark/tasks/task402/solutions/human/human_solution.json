[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nint n, m, l;\nvoid solve() {\n\tvector<int> b(n);\n\trep(i, n) {\n\t\tcin >> b[i]; b[i]--;\n\t}\n\tvector<ll> a(m);\n\tvector<ll> ra(m+1,0);\n\trep(i, m)cin >> a[i];\n\trep(i, m) {\n\t\tra[i + 1] = ra[i] + a[i];\n\t}\n\tsort(b.begin(), b.end());\n\tvector<vector<ll>> dp(n);\n\trep(i, n) {\n\t\tdp[i].resize(n, INF);\n\t}\n\tdp[0][0] = 0;\n\trep1(i, n - 2) {\n\t\trep(j, i) {\n\t\t\tll cost = dp[i - 1][j] + (ra[b[i] + 1] - ra[b[j]]) / l;\n\t\t\tdp[i][i - 1] = min(dp[i][i - 1], cost);\n\t\t\tcost = dp[i - 1][j] + (ra[b[i]+1] - ra[b[i - 1]]) / l;\n\t\t\tdp[i][j] = min(dp[i][j], cost);\n\t\t}\n\t}\n\tll ans = INF;\n\trep(j, n - 1) {\n\t\tll cost = dp[n - 2][j];\n\t\tcost += (ra[b[n - 1]+1] - ra[b[n - 2]]) / l;\n\t\tcost += (ra[b[n - 1] + 1] - ra[b[j]]) / l;\n\t\tans = min(ans, cost);\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\twhile (cin >> n>>m>>l, n) {\n\t\tsolve();\n\t\tbreak;\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nint main()\n{\n    ll N, M, L;\n    cin >> N >> M >> L;\n    vector<ll> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n        K[i]--;\n    }\n    sort(K.begin(), K.end());\n    vector<ll> S(M);\n    vector<ll> sum(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n        sum[i] = ((i > 0) ? sum[i - 1] : 0) + S[i];\n    }\n    vector<vector<ll>> dist(N, vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ll l = min(K[i], K[j]);\n            ll r = max(K[i], K[j]);\n            dist[i][j] = (sum[r] - ((l > 0) ? sum[l - 1] : 0)) / L;\n        }\n    }\n    //    show(dist);\n    ll suma = 0;\n    for (int i = 0; i < N; i++) {\n        suma += dist[i][(i + 1) % N];\n    }\n    cout << suma << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int_fast64_t;\n\nint n,m,L;\nint k[2010];\ni64 s[100100]; \ni64 dp[2010][2010];\nconstexpr i64 inf=1e18;\n\ni64 calc(int a,int b) {\n    if(a<b) swap(a,b);\n    return (s[a+1]-s[b])/L;\n}\n\nint main() {\n    cin>>n>>m>>L;\n    for(int i=0; i<n; ++i) {\n        cin>>k[i];\n        k[i]--;\n    }\n    sort(k,k+n);\n    for(int i=0; i<m; ++i) {\n        cin>>s[i+1];\n        s[i+1]+=s[i];\n    }\n    dp[0][0]=0;\n    for(int i=0; i+1<n; ++i) {\n        fill(begin(dp[i+1]),end(dp[i+1]),inf);\n        for(int j=0; j<=i; ++j) {\n            i64 now=dp[i][j];\n            dp[i+1][j]=min(dp[i+1][j],now+calc(k[i],k[i+1]));\n            dp[i+1][i]=min(dp[i+1][i],now+calc(k[j],k[i+1]));\n        }\n    }\n    i64 ans=inf;\n    for(int i=0; i<n; ++i) {\n        ans=min(ans,dp[n-1][i]+calc(k[n-1],k[i]));\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> s_acc(1); partial_sum(whole(s), back_inserter(s_acc));\n    auto penalty = [&](int a, int b) { if (a > b) swap(a, b); return (s_acc[k[b] + 1] - s_acc[k[a]]) / l; };\n    auto dp = vectors(n, n, inf);\n    dp[1][0] = penalty(0, 1);\n    repeat (a, n - 1) {\n        repeat (b, a) {\n            setmin(dp[a + 1][a], dp[a][b] + penalty(b, a + 1));\n            setmin(dp[a + 1][b], dp[a][b] + penalty(a, a + 1));\n        }\n    }\n    ll result = inf;\n    repeat (c, n - 1) {\n        setmin(result, dp[n - 1][c] + penalty(n - 1, c));\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define mz(x,y) x=min(x,y)\ntypedef long long ll;\nint K[2000],S[100000];\nll inf=1e17;\nll dp[2][100001];\nll sum[100001];\nint N,M,L;\nll dis(int a,int b){\n\tif(a>b) return inf;\n\treturn (sum[b+1]-sum[a])/L;\n}\nint main(){\n\tcin>>N>>M>>L;\n\trep(i,N) cin>>K[i];\n\trep(i,N) K[i]--;\n\trep(i,M) cin>>S[i];\n\trep(i,M) sum[i+1]=sum[i]+S[i];\n\tsort(K,K+N);\n\trep(j,M+1) dp[0][j]=inf;\n\tdp[0][K[0]]=0;\n\trep(i,N-1){\n\t\trep(j,M+1) dp[1-i%2][j]=inf; \n\t\trep(j,M){\n\t\t\tmz(dp[1-i%2][j],dp[i%2][j]+dis(K[i],K[i+1]));\n\t\t\tmz(dp[1-i%2][K[i]],dp[i%2][j]+dis(j,K[i+1]));\n\t\t}\n\t}\n\tll ans=inf;\n\trep(j,M) mz(ans,dp[1-N%2][j]+dis(j,K[N-1]));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        if(i==j && i!=0) continue;\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll INF = LLONG_MAX/3;\n\nint n,m,l;\nvector<int> k,s;\n\nll cost(int a, int b){\n    return (s[k[b]]-s[k[a]-1])/l;\n}\n\nconst int N = 2002;\nll dp[N][N];\nll dfs(int x, int y){\n    if(dp[x][y]>=0) return dp[x][y];\n\n    int nx = max(x,y)+1;\n    if(nx == n){\n        return cost(min(x,y), max(x,y));\n    }\n\n    ll ret = min(dfs(nx,y)+cost(x,nx), dfs(x,nx)+cost(y,nx));\n    return dp[x][y] = ret;\n}\n\nint main(){\n    cin >>n >>m >>l;\n\n    k = vector<int>(n);\n    s = vector<int>(m+1);\n    rep(i,n) cin >>k[i];\n    sort(all(k));\n\n    rep(i,m) cin >>s[i+1];\n    for(int i=1; i<=m; ++i) s[i] += s[i-1];\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll N, M, L;\n  cin >> N >> M >> L;\n  vector<ll> K(N), S(M);\n  REP(i, 0, N) cin >> K[i], K[i]--;\n  REP(i, 0, M) cin >> S[i];\n\n  sort(K.begin(), K.end());\n  vector<ll> sum(M + 1);\n  REP(i, 0, M) sum[i + 1] = sum[i] + S[i];\n\n#define cost(p, q) ((sum[(q) + 1] - sum[(p)]) / L)\n  const ll INF = 1LL << 60;\n  vector<vector<ll>> dp(N, vector<ll>(N, INF));\n  dp[0][0] = 0;\n  REP(i, 0, N - 1) REP(j, 0, N - 1) {\n    ll k = max(i, j) + 1;\n    if (k == N - 1) {\n      dp[k][k] = min(dp[k][k], dp[i][j] + cost(K[i], K[k]) + cost(K[j], K[k]));\n    } else {\n      dp[k][j] = min(dp[k][j], dp[i][j] + cost(K[i], K[k]));\n      dp[i][k] = min(dp[i][k], dp[i][j] + cost(K[j], K[k]));\n    }\n  }\n  cout << dp[N - 1][N - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 2001;\nconst int MAX_M = 100001;\nint N, M, L, K[MAX_N], S[MAX_M];\n\n// sum[i] := s[i] + s[i+1] + ... + s[m-1];\nint sum[MAX_M] = {0};\n\n// 反発力 (s[a] + s[a+1] + ... + s[b]) / L を返す.\nint power(int a, int b){\n\tif( b < a ) swap(a,b);\n\treturn (sum[a] - sum[b+1]) / L;\n}\n\nint solve(){\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tsum[0] += S[i];\n\t}\n\tfor(int i=1 ; i < M ; i++ ){\n\t\tsum[i] = sum[i-1] - S[i-1];\n\t}\n\tsum[M] = 0;\n\t// sort(K,K+N);\n\tint res = 1e+8;\n\tfor(int k=0 ; k < 1000000 ; k++ ){\n\t\trandom_shuffle(K,K+N);\n\t\tint s = 0;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\ts += power( K[i] , K[(i+1)%N] );\n\t\t}\n\t\tres = min( res , s );\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> N >> M >> L;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tcin >> S[i];\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        int N, M, L;\n        cin >> N >> M >> L;\n        vector<ll> K(N);\n        for(int i = 0; i < N; ++i){\n                cin >> K[i];\n                --K[i];\n        }\n        sort(K.begin(), K.end());\n        vector<ll> S(M);\n        for(int i = 0; i < M; ++i){ cin >> S[i]; }\n        vector<ll> Si(M + 1);\n        for(int i = 1; i <= M; ++i){ Si[i] = Si[i - 1] + S[i - 1]; }\n        ll skip = 0;\n        for(int i = 2; i < N; i += 2){ skip += (Si[K[i] + 1] - Si[K[i - 2]]) / L; }\n        skip += (Si[K[N - 1] + 1] - Si[K[N - 2]]) / L;\n        for(int i = 3; i < N; i += 2){ skip += (Si[K[i] + 1] - Si[K[i - 2]]) / L; }\n        skip += (Si[K[1] + 1] - Si[K[0]]) / L;\n        ll cycle = (Si[K[N - 1] + 1] - Si[K[0]]) / L;\n        for(int i = 1; i < N; ++i){ cycle += (Si[K[i] + 1] - Si[K[i - 1]]) / L; }\n        cout << min(cycle, skip) << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<numeric>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX (1<<20)\nint N,M,L;\nint k[2001];\nint s[100001];\nint wa[2003][2003];\nint rw[100001];\nbool f[2001];\n\n\nint riv(int ik,int ret){\n  int i;\n  for(i=N-1;i>0;i--,ik++){\n    if(ik>=N-1) break;\n    ret+=wa[k[i]][k[i-1]];\n  }\n  return ret+wa[k[i]][k[0]];\n}/*\nint stv(int ik,int ret){\n  int i;\n  for(i=0;i<N-1;i++,ik++){\n    if(ik>=N-1) break;\n    ret+=wa[k[i]][k[i+1]];\n  }\n  return ret+wa[k[i]][k[N-1]];\n  }*/\n\nmain(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++) scanf(\"%d\",&k[i]);\n  for(int i=0;i<M;i++) scanf(\"%d\",&s[i]);\n  sort(k,k+N);\n\n  rw[0]=s[0];\n  for(int i=1;i<M;i++)\n    rw[i]=rw[i-1]+s[i];\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j) continue;\n      int ni=min(k[i],k[j])-1;\n      int nj=max(k[i],k[j])-1;\n      int sa=rw[ni-1];\n      if(ni-1<0) sa=0;\n      wa[k[i]][k[j]]=(rw[nj]-sa)/L;\n      //     printf(\"%d %d : %d\\n\",k[i],k[j],wa[k[i]][k[j]]);\n    }\n  }\n\n  int res=MAX;\n  int at=MAX;\n  int sum=0;\n  for(int i=0;i<N;i++){\n    at=min(at,riv(i+1,sum+wa[k[i]][k[N-1]]));\n    sum+=wa[k[i]][k[(i+1)%N]];\n  }\n  /*  for(int i=N-1;i>=0;i--){\n    res+=wa[k[i]][k[(i-1<0)?N-1:i-1]];\n  }\n  printf(\"%d %d\\n\",at,res);*/\n  res=min(sum,at);\n  printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<int>ks;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tk--;\n\t\tks.push_back(k);\n\n\t}\n\tsort(ks.begin(), ks.end());\n\tvector<int>beaus;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s; cin >> s;\n\t\tbeaus.push_back(s);\n\t}\n\tvector<long long int>sums;\n\tsums.push_back(0);\n\tlong long int now = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tnow += beaus[i];\n\t\tsums.push_back(now);\n\t}\n\tlong long int ans = 0;\n\t\n\tfor (int i = 1; i < N; ++i) {\n\t\tans += (sums[ks[i]+1] - sums[ks[i - 1]])/L;\n\t}\n\tans += (sums[ks[N-1] + 1] - sums[ks[0]])/L;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, l;\n  cin >> n >> m >> l;\n  VI k(n), s(m);\n  REP(i, n) cin >> k[i], k[i]--;\n  REP(i, m) cin >> s[i];\n\n  FOR(i, 1, m) s[i] += s[i-1];\n  sort(ALL(k));\n\n  auto sum = [&](int from, int to) {\n    if(to < from) swap(from, to);\n    return (s[to] - (from >= 1 ? s[from-1] : 0)) / l;\n  };\n\n  VVI dp(n, VI(n, -1));\n  function<int(int,int)> dfs = [&](int x, int y) -> int {\n    if(dp[x][y] >= 0) return dp[x][y];\n    int nxt = max(x, y) + 1;\n    if(nxt == n) return 0;\n    int vl = dfs(nxt, y) + sum(k[x], k[nxt]);\n    int vr = dfs(x, nxt) + sum(k[y], k[nxt]);\n    return dp[x][y] = min(vl, vr);\n  };\n\n  cout << dfs(0, 0) + sum(k[0], k[n-1]) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 2020;\nconst int ML = 100100;\nint n, m;\nll l;\nint k[MN];\nll s[ML], ssm[ML];\n\nll gt(int a, int b) {\n    return (ssm[k[b]+1]-ssm[k[a]])/l;\n}\n\n\nll calc(int a, int b) {\n    if (a > b) return calc(b, a);\n    if (b == n-2) {\n        return gt(a, n-1)+gt(b, n-1);\n    }\n    static ll dp[MN][MN];\n    static bool used[MN][MN];\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    ll &ans = dp[a][b];\n    ans = TEN(16);\n    ans = min(ans, calc(b+1, b)+gt(a, b+1));\n    ans = min(ans, calc(a, b+1)+gt(b, b+1));\n    return ans;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    for (int i = 0; i < n; i++) {\n\tcin >> k[i]; k[i]--;\n    }\n    sort(k, k+n);\n    for (int i = 0; i < m; i++) {\n\tcin >> s[i];\n    }\n    ssm[0] = 0;\n    for (int i = 0; i < m; i++) {\n\tssm[i+1] = s[i]+ssm[i];\n    }\n    cout << calc(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nll dp[2100][2100];\nll sum[1000100];\nint N, M, L;\nvector<ll> K;\nvector<ll> S;\nconst ll INF = 1e15;\n\nll gauss(int a, int l) {\n\treturn a/l - !(a%l);\n}\n\nll solve(int a, int b) {\n\t// a, b ???????????§?????°\n\tif(dp[a][b]+1)\n\t\treturn dp[a][b];\n\tif(a == b)\n\t\treturn dp[a][b] = INF;\n\n\tll res = INF;\n\tif(abs(a-b) == 1) {\n\t\tfor(int i = 1; i < min(a,b); i++) {\n\t\t\tif(a > b)\n\t\t\t\tres = min(res, solve(i,b) + gauss(sum[K[a-1]] - sum[K[i-1]-1], L));\n\t\t\telse\n\t\t\t\tres = min(res, solve(a,i) + gauss(sum[K[b-1]] - sum[K[i-1]-1], L));\n\t\t}\n\t}\n\telse {\n\t\tif(a > b)\n\t\t\tres = min(res, solve(a-1,b) + gauss(sum[K[a-1]]-sum[K[a-2]-1], L));\n\t\telse\n\t\t\tres = min(res, solve(a,b-1) + gauss(sum[K[b-1]]-sum[K[b-2]-1], L));\n//\t\tcout << a << \",\" << b << \" \"<< K[max(a,b)-1] << \",\" << K[max(a,b)-2] << \" \" << res << endl;\n\t}\n\treturn dp[a][b] = res;\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tK.resize(N); S.resize(M);\n\tfor(int i = 0; i < N; i++)\n\t\tcin >> K[i];\n\tfor(int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\n\tfor(int i = 0; i < 2100; i++)\n\t\tfor(int j = 0; j < 2100; j++)\n\t\t\tdp[i][j] = -1;\n\tfor(int i = 0; i < S.size(); i++)\n\t\tsum[i+1] = S[i]+sum[i];\n\n\tll res = INF;\n\tsort(K.begin(), K.end());\n\tdp[1][1] = 0;\n\tdp[1][2] = dp[2][1] = gauss(sum[K[1]]-sum[K[0]-1],L);\n\tfor(int i = 1; i < N; i++) {\n\t\tres = min(res, solve(i,N) + gauss(sum[K[N-1]]-sum[K[i-1]-1],L));\n//\t\tcout << solve(i,N) << \",\" << gauss(sum[K[N-1]]-sum[K[i-1]-1],L) << \" \" << res << endl;\n\t}\n\t/*\n\tfor(int i = 0; i < 10; i++) {\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tcout << dp[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\t// */\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate<typename T>\nstruct CumSum{\nprivate:\n  size_t size;\n  vector<T> data;\npublic:\n  CumSum(vector<T> dat){\n    size = dat.size();\n    data.resize(size+1,0);\n    for(size_t i = 0; i < size; ++i)\n      data[i+1] = data[i] + dat[i];\n  }\n  T getsum(size_t l, size_t r){//0-indexed, [l,r)\n    return data[r] - data[l];\n  }\n  T getsum(size_t r){//0-indexed, [0,r)\n    return data[r];\n  }\n};\n\nint main(){\n  long long N, M, L;\n  cin >> N >> M >> L;\n  vector<long long> K(N), S(M);\n  for(long long i = 0; i < N; ++i)\n    cin >> K[i], --K[i];\n  for(long long i = 0; i < M; ++i)\n    cin >> S[i];\n  CumSum<long long> cs(S);\n  const long long INF = 1e18;\n  sort(K.begin(), K.end());\n  vector<long long> dp(N,INF);\n  dp[0] = 0;\n  for(long long i = 1; i < N; ++i){\n    vector<long long> dp_(N,INF);\n    for(long long j = 0; j < N; ++j){\n      if(dp[j] >= INF) continue;\n      {\n        // i-1 | i\n        //  j  |\n        long long l = K[i-1], r = K[i];\n        if(r < l) swap(l,r);\n        ++r;\n        dp_[j] = min(dp_[j],dp[j]+cs.getsum(l,r)/L);\n      }\n      {\n        // i-1 |\n        //  j  | i\n        long long l = K[j], r = K[i];\n        if(r < l) swap(l,r);\n        ++r;\n        dp_[i-1] = min(dp_[i-1],dp[j]+cs.getsum(l,r)/L);\n      }\n    }\n    swap(dp,dp_);\n  }\n  long long ans = INF;\n  for(long long i = 0; i < N; ++i){\n    if(i == N-1) continue;\n    if(dp[i] >= INF) continue;\n    long long l = K[i], r = K.back();\n    if(r < l) swap(l,r);\n    ++r;\n    ans = min(ans,dp[i]+cs.getsum(l,r)/L);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INFTY=1ll<<61;\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b){\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l;){\n\t\tvector<int> ks(n),ss(m);\n\t\tfor(int& k:ks) cin>>k,k--;\n\t\tfor(int& s:ss) cin>>s;\n\t\t\n\t\tsort(begin(ks),end(ks));\n\t\t\n\t\tvector<ll> sum(m+1);\n\t\tfor(int i=0;i<m;i++) sum[i+1]=sum[i]+ss[i];\n\t\t\n\t\tvector<vector<ll>> dp(n,vector<ll>(n,INFTY));\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n-1;i++) for(int j=0;j<i;j++){\n\t\t\tchmin(dp[i][j],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[i-1]])/l);\n\t\t\tchmin(dp[i][i-1],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[j]])/l);\n\t\t}\n\t\tll res=INFTY;\n\t\tfor(int i=0;i<n-1;i++)\n\t\t\tchmin(res,dp[n-2][i]+(sum[ks[n-1]+1]-sum[ks[n-2]])/l+(sum[ks[n-1]+1]-sum[ks[i]])/l);\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l){\n\t\tvector<ll> K(n), S(m), sum(m+1);\n\t\tREP(i, n) cin >> K[i], K[i]--;\n\t\tREP(i, m) cin >> S[i];\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vector<ll>> dp(n+1, vector<ll>(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tchmin(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tchmin(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tcout << dp[n-1][n-2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<int>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\n\t\tvector<int> ring = { K[0], K[1], K[2] };\n\t\tFOR(x, 3, N)\n\t\t{\n\t\t\tint minj = 0;\n\t\t\tint val = INF;\n\t\t\tREP(i, ring.size())\n\t\t\t{\n\t\t\t\tint j = (i + 1) % ring.size();\n\t\t\t\tint d = deltaS(ring[i], K[x]) + deltaS(K[x], ring[j]) - deltaS(ring[i], ring[j]);\n\t\t\t\tif (d < val){ minj = j; val = d; }\n\t\t\t}\n\t\t\tring.insert(ring.begin() + minj, K[x]);\n\t\t}\n\n\t\tint cost = 0;\n\t\tREP(i, ring.size())\n\t\t{\n\t\t\tint j = (i + 1) % ring.size();\n\t\t\tcost += deltaS(ring[i], ring[j]);\n\t\t}\n\t\twrite(cost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\t//if(vec[a].first > vec[b].first) swap(a, b);\n\t//return (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n\treturn (cum[K[a]] - cum[K[b]-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\t//sort(vec, vec+n);\n\t//reverse(vec, vec+n);\n\tsort(K, K+n);\n\treverse(K, K+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\t//dp[i+1][j] = min(dp[j][i+1], dp[i][j] + calc(i, i+1));\n\t\t\t//dp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(j, i+1));\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + (cum[K[i]] - cum[K[i+1]-1]) / l);\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + (cum[K[j]] - cum[K[i+1]-1]) / l);\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + (cum[K[i]] - cum[K[n-1]-1]) / l);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\nint main()\n{\n\tint N, M, L, K[2000], S[10001];\n\tscanf(\"%d%d%d\", &N, &M, &L);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%d\", K + i);\n\tfor (int i = 1; i <= M; ++i)\n\t\tscanf(\"%d\", S + i);\n\tsort(K, K + N);\n\n\tstatic ll sum[10001];\n\tsum[0] = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t\tsum[i] = sum[i-1] + S[i];\n\n\tconst ll INF = 100000000000000ll;\n\tstatic ll dp[2000][2001];\n\tfor (int i = 0; i < 2000; ++i)\n\t\tfor (int j = i; j < 2001; ++j)\n\t\t\tdp[i][j] = INF;\n\n#define seg_sum(a, b) ((sum[b] - sum[a-1]) / L)\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < N-1; ++i)\n\t{\n\t\tfor (int j = i + 1; j < N; ++j)\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-1] + seg_sum(K[j-1], K[j]));\n\t\tfor (int j = i + 1; j < N-1; ++j)\n\t\t\tdp[j][j+1] = min(dp[j][j+1], dp[i][j] + seg_sum(K[i], K[j+1]));\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i < N-1; ++i)\n\t\tans = min(ans, dp[i][N-1] + seg_sum(K[i], K[N-1]));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, l; cin >> n >> m >> l;\n    vi k(n); rep(i, n) { cin >> k[i]; k[i]--; }\n    vi s(m); rep(i, m) cin >> s[i];\n\n    sort(all(k));\n\n    vll ss(m+1); rep(i, m) ss[i+1] = ss[i] + s[i];\n\n    function<ll(ll, ll)> dist = [&](ll i_, ll j_){\n        ll i = k[i_], j = k[j_];\n        if (i > j) swap(i, j);\n        return (ss[j+1] - ss[i]) / l;\n    };\n//    cout << ss << endl;\n\n    static ll memo[2001][2001] = {};\n    rep(i, 2001) rep(j, 2001) memo[i][j] = -1;\n    function<ll(ll, ll)> f = [&](ll l, ll r){\n//        cout << l << \" \" << r << endl;\n        ll next = max(l, r) + 1;\n        if (next >= n) return dist(l, r);\n        if (memo[l][r] >= 0) return memo[l][r];\n\n        return memo[l][r] = min(f(l, next) + dist(next, r) , dist(next, l) + f(next, r));\n    };\n\n    cout << f(0, 0) << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 2000;\nconst int M = 1e5;\nconst int INF = 1 << 28;\n\nint n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nint calc(int a, int b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(int i=0;i<n;i++) cin >> K[i];\n\tfor(int i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(int i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(int i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(int i=0;i<n-2;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\tdp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i=0;i<n;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nint main() {\n  int n,m,l;\n  cin>>n>>m>>l;\n  vector<int> vk(n);\n  REP(i,n) cin>>vk[i];\n  vector<int64_t> vs(m);\n  REP(i,m) cin>>vs[i];\n  vector<int64_t> pss(m+1);\n  partial_sum(ALL(vs), begin(pss)+1);\n  sort(ALL(vk));\n  vector<vector<int64_t>> dp(n, vector<int64_t>(n, INF));\n  dp[0][0] = 0;\n  REP(i,n-1) {\n    REP(j,max(1,i)) {\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (pss[vk[i+1]] - pss[vk[i]-1])/l);\n      dp[i+1][i] = min(dp[i+1][i], dp[i][j] + (pss[vk[i+1]] - pss[vk[j]-1])/l);\n    }\n  }\n  int64_t res = INF;\n  REP(i,n-1) {\n    res = min(res, dp[n-1][i] + (pss[vk[n-1]] - pss[vk[i]-1])/l);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst ll INF = 1LL<<60;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nll dp[2001][2001];\nint K[2000];\nint S[100000];\nll SUM[100001];\nint l;\n\nint calc(int a,int b) {\n  if (a>b) swap(a,b);\n  //cout << a << \" \" << b << \" \"  << SUM[b]-SUM[a-1] << endl;\n  return (SUM[b]-SUM[a-1])/l;\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m >> l;\n  REP(i,n) cin >> K[i];\n  REP(i,m) cin >> S[i];\n\n  SUM[0] = 0;\n  REP(i,m) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K+n);\n  ll ans = INF;\n  REP(i, n+1)REP(j,n+1)dp[i][j] = INF;\n  dp[0][0] = 0;\n  REP(now, n) {                 // max(i,j) = now\n    REP(j, now+1) {\n      if (now == n-1) ans = min(ans, dp[n-1][j] + calc(K[j], K[n-1]));\n      else {\n        dp[now][now+1] = min(dp[now][now+1], dp[now][j] + calc(K[j], K[now+1]));\n        dp[now+1][j] = min(dp[now+1][j], dp[now][j] + calc(K[now], K[now+1]));\n      }\n    }\n    REP(i,now+1) {\n      if (now == n-1) ans = min(ans, dp[i][n-1] + calc(K[i],K[n-1]));\n      else {\n        dp[now+1][now] = min(dp[now+1][now], dp[i][now] + calc(K[i], K[now+1]));\n        dp[i][now+1] = min(dp[i][now+1], dp[i][now] + calc(K[now], K[now+1]));\n      }\n    }\n  }\n  // REP(i, n+1) {\n  //   REP(j, n+1) {\n  //     cout << dp[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nll dp[2010][2010];\nll s[2010];\nint L;\n\nll sum(int a,int b){\n\tif(a>b) swap(a,b);\n\tll ret = s[b];\n\tif(a) ret-=s[a-1];\n\t// cout<<\"sum \"<<a<<\" \"<<b<<\" \"<<ret<<\" \"<<ret/L<<endl;\n\treturn ret/L;\n}\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tsort(ALL(v));\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\trep(i,m){\n\t\tif(!i){\n\t\t\ts[i]=w[i];\n\t\t}\n\t\telse{\n\t\t\ts[i]=s[i-1]+w[i];\n\t\t}\n\t}\n\trep(i,2010) rep(j,2010) dp[i][j]=INFL;\n\tdp[0][0] = 0;\n\tdp[1][0] = sum(v[0],v[1]);\n\trep(i,n-1){\n\t\trep(j,i){\n\t\t\tmins(dp[i+1][j],dp[i][j]+sum(v[i],v[i+1]));\n\t\t\tmins(dp[i+1][i],dp[i][j]+sum(v[j],v[i+1]));\n\t\t}\n\t}\n\t// rep(i,n){\n\t// \trep(j,n){\n\t// \t\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t// \t}\n\t// }\n\tll ans = INFL;\n\trep(i,n){\n\t\tmins(ans,dp[n-1][i]+sum(v[i],v[n-1]));\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nll n, m, l;\nll a[2000];\nll b[100000];\nll s[100010];\nll dp[2000][2000];\n\nll sum(ll i, ll j){\n  return (s[max(i, j) + 1] - s[min(i, j)]) / l;\n}\n\nll dfs(ll i, ll j){\n  if (i == n) return sum(a[i - 1], j);\n  if (~dp[i][j]) return dp[i][j];\n  ll vl = sum(a[i - 1], a[i]) + dfs(i + 1, j);\n  ll vr = sum(a[j], a[i]) + dfs(i + 1, i - 1);\n  return dp[i][j] = min(vl, vr);\n}\n\nint main(){\n  cin >> n >> m >> l;\n  rep(i, n) cin >> a[i], a[i]--;\n  rep(i, m) cin >> b[i];\n  rep(i, m) s[i + 1] = s[i] + b[i];\n  sort(a, a + n);\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(1, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ll INF = LLONG_MAX;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nll l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tif (dp[left][right] < INF ) return dp[left][right];\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = INF;\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint N, M, L;\nint K[2010], S[100010];\nint sum[100010];\n\nint sumV(int l, int r){\n  if(l > r) swap(l, r);\n  return (sum[r] - sum[l-1]) / L;\n}\n\nint calc(){\n  int ret = 0;\n  for(int i = 0 ; i < N ; i++){\n    int s, e;\n    s = K[i], e = K[i+1];\n    if(i == N-1){ s = K[0]; e = K[i];}\n    if(s > e) swap(s, e);\n    ret += sumV(s, e);\n  }\n  return ret;\n}\n\nint solve(){\n  int t = calc();\n  int ans = t;\n  for(int i = 0 ; i < N ; i++){\n    for(int j = i+1 ; j < N ; j++){\n      int tmp = t;\n      tmp -= sumV(K[i], K[i+1]);\n      tmp -= sumV(K[i-1], K[i]);\n      tmp -= sumV(K[j], K[j+1]);\n      tmp -= sumV(K[j-1], K[j]);\n      swap(K[i], K[j]);\n      tmp += sumV(K[i], K[i+1]);\n      tmp += sumV(K[i-1], K[i]);\n      tmp += sumV(K[j], K[j+1]);\n      tmp += sumV(K[j-1], K[j]);\n      swap(K[i], K[j]);\n      ans = min(ans, tmp);\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L){\n    memset(K, 0, sizeof(K));\n    memset(S, 0, sizeof(S));\n    memset(sum, 0, sizeof(sum));\n    for(int i = 0 ; i < N ; i++) cin >> K[i], K[i]--;\n    for(int i = 0 ; i < M ; i++) cin >> S[i];\n    sort(K, K+N);\n    sum[0] = S[0];\n    for(int i = 1 ; i < M ; i++){\n      sum[i] += sum[i-1] + S[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\t//if(vec[a].first > vec[b].first) swap(a, b);\n\t//return (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n\treturn (cum[K[a]] - cum[K[b]-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\treverse(vec, vec+n);\n\t//sort(K, K+n);\n\t//reverse(K, K+n);\n\tfor(int i=0;i<n;i++) K[i] = vec[i].second;\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + (cum[K[i]] - cum[K[i+1]-1]) / l);\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + (cum[K[j]] - cum[K[i+1]-1]) / l);\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + (cum[K[i]] - cum[K[n-1]-1]) / l);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint K[120000];\nint S[120000];\nint sum[120000];\n\nint SS(int a,int b){\n  return sum[b+1]-sum[a];\n}\n\nbool vis[2100][2100];\n\nint main() {\n  int N, M, L;\n  cin >> N >> M >> L;\n  rep(i, N) cin >> K[i];\n  rep(i, N) --K[i];\n  rep(i, M) cin >> S[i];\n\n  rep(i,M) sum[i+1] = sum[i] + S[i];\n  sort(K,K+N);\n  priority_queue<pair<int,PI> > q;\n  if(N==1){\n    cout << 0 << endl;\n    return 0;\n  }else if(N==2){\n    cout << SS(K[0],K[1])/L*2 << endl;\n    return 0;\n  }\n  \n  q.push(mp(-SS(K[0],K[1])/L,mp(0,1)));\n  int ans = 1LL<<30LL;\n  while(!q.empty()){\n    int cc=-q.top().F;\n    PI cv=q.top().S;\n    q.pop();\n    if(vis[cv.F][cv.S]) continue;\n    vis[cv.F][cv.S] = true;\n    //cout << cc << ' ' << cv.F << ' ' << cv.S << endl;\n    int nidx = max(cv.F,cv.S) + 1;\n    if(nidx==N-1){\n      //cout << cv.F << ' ' << K[N-1] << ' ' << SS(K[cv.F, K[N-1])/ L << endl;\n      //cout << cv.S << ' ' << K[N-1] << ' ' << SS(cv.S, K[N-1])/ L << endl;      \n      ans = min(ans,cc + SS(K[cv.F], K[N-1])/L + SS(K[cv.S], K[N-1])/L);\n      //cout << ans << endl;\n      continue;\n    }\n    \n    q.push(mp(-cc-SS(K[cv.F],K[nidx])/L,mp(cv.S,nidx)));\n    q.push(mp(-cc-SS(K[cv.S],K[nidx])/L,mp(cv.F,nidx)));    \n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 2020;\nconst int ML = 100100;\nint n, m, l;\nint k[MN];\nint s[ML], ssm[ML];\n\nint gt(int a, int b) {\n    return (ssm[k[b]+1]-ssm[k[a]])/l;\n}\n\n\nint calc(int a, int b) {\n    if (a > b) return calc(b, a);\n    if (b == n-2) {\n        return gt(a, n-1)+gt(b, n-1);\n    }\n    static int dp[MN][MN];\n    static bool used[MN][MN];\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    int &ans = dp[a][b];\n    ans = TEN(9);\n    ans = min(ans, calc(b+1, b)+gt(a, b+1));\n    ans = min(ans, calc(a, b+1)+gt(b, b+1));\n    return ans;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    for (int i = 0; i < n; i++) {\n\tcin >> k[i]; k[i]--;\n    }\n    sort(k, k+n);\n    for (int i = 0; i < m; i++) {\n\tcin >> s[i];\n    }\n    ssm[0] = 0;\n    for (int i = 0; i < m; i++) {\n\tssm[i+1] = s[i]+ssm[i];\n    }\n    cout << calc(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1LL << 40;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tdp[i+1][j] = min(dp[j][i+1], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(i+1, j));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + calc(n-1, i));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m,L;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\tll ans = 0;\n\tsort(ALL(v));\n\trep(i,n){\n\t\tpii a = minmax(v[i],v[(i+1)%n]);\n\t\tll t = 0;\n\t\treep(j,a.F,a.S+1){\n\t\t\tt+=w[j];\n\t\t}\n\t\t// cout<<a.F<<\" \"<<a.S<<\" \"<<t<<endl;\n\t\tans+=t/L;\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef pair<int,int> pii;\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<int> k(n),s(m);\n    vector<int64_t> sum(m);\n    rep(i,0,n){\n        cin >> k[i];\n        --k[i];\n    }\n    rep(i,0,m){\n        cin >> s[i];\n        sum[i]=s[i];\n        if(i>0) sum[i]+=sum[i-1];\n    }\n    sort(k.begin(),k.end());\n\n    vector<vector<int64_t>> memo(n,vector<int64_t>(n,inf64));\n    vector<vector<bool>> done(n,vector<bool>(n));\n    function<int64_t(int,int)> rec=[&](int p,int q){\n        if(done[p][q]) return memo[p][q];\n        done[p][q]=true;\n        if(p==n-1 and q==n-1) return memo[p][q]=0;\n        int64_t res=inf64;\n        if(p!=n-1){\n            int p_=p+1;\n            if(p_!=n-1 and p_==q) ++p_;\n            int left=k[p],right=k[p_];\n            int64_t tmp=sum[right];\n            if(left>0) tmp-=sum[left-1];\n            res=min(res,rec(p_,q)+tmp/l);\n        }\n        if(q!=n-1){\n            int q_=q+1;\n            if(q_!=n-1 and q_==p) ++q_;\n            int left=k[q],right=k[q_];\n            int64_t tmp=sum[right];\n            if(left>0) tmp-=sum[left-1];\n            res=min(res,rec(p,q_)+tmp/l);\n        }\n        return memo[p][q]=res;\n    };\n    cout << rec(0,0) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M,L;\nint K[2010];\nint S[100010];\n\nint memo[2010][2010];\n\ninline int cost(int l,int r){\n    l=K[l];r=K[r];\n    if(l>r)swap(l,r);\n    return (S[r]-S[l-1])/L;\n}\n\nint dfs(int l,int r){\n    int t=max(l,r)+1;\n    if(t==N-1)return cost(l,t)+cost(r,t);\n    int &ret=memo[l][r];\n    if(ret!=-1)return ret;\n    return ret=min(dfs(t,r)+cost(l,t),dfs(l,t)+cost(r,t));\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&N,&M,&L);\n    rep(i,N)scanf(\"%lld\",&K[i]);\n    sort(K,K+N);\n    rep(i,M)scanf(\"%lld\",&S[i+1]),S[i+1]+=S[i];\n\n    memset(memo,-1,sizeof(memo));\n    printf(\"%lld\\n\",dfs(0,0));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nstruct SegmentTree {\nprivate:\n\tint n;\n\tvector<int> node;\npublic:\n\tSegmentTree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1, 0);\n\n\t\tfor (int i = 0; i < sz; i++) node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) node[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t}\n\n\tvoid add(int k, int val) {\n\t\tk += (n - 1);\n\t\tnode[k] += val;\n\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = node[2 * k + 1] + node[2 * k + 2];\n\t\t}\n\t}\n\n\tint getsum(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\tif (b <= l || r <= a) return 0;\n\t\tif (a <= l && r <= b) return node[k];\n\n\t\tint vl = getsum(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tint vr = getsum(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn vl + vr;\n\t}\n};//半開区間\n\nint n, m, l;\nint k[101010];\nint s;\nvector<int> v;\n\nint main() {\n\tcin >> n >> m >> l;\n\tREP(i, n)cin >> k[i];\n\tv.emplace_back(0);\n\tREP(j, m) {\n\t\tcin >> s;\n\t\tv.emplace_back(s);\n\t}\n\tSegmentTree seg(v);\n\tLL ans = 0;\n\tREP(i, n - 1) {\n\t\tans += seg.getsum(min(k[i], k[i + 1]), max(k[i], k[i + 1]) + 1) / l;\n\t}\n\tans += seg.getsum(min(k[0], k[n - 1]), max(k[0], k[n - 1]) + 1) / l;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 C : @­³â©¿áñ\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint N, M, L;\n\tint K[2000], S[100000];\n\tlong long sum[100001];\n\twhile(cin >> N >> M >> L){\n\t\tfor(int i=0;i<N;i++) scanf(\"%d\", &K[i]);\n\t\tfor(int i=0;i<M;i++) scanf(\"%d\", &S[i]);\n\t\tsort(K, K+N);\n\t\tsum[0] = 0;\n\t\tfor(int i=1;i<=M;i++) sum[i] = sum[i-1]+S[i-1];\n\t\tstatic long long dp[2000][2000];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[0][1] = (sum[K[1]]-sum[K[0]-1])/L;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tfor(int j=i+1;j<N-1;j++){\n\t\t\t\t// K[i], K[j+1] ÌÀÑðìéê\n\t\t\t\tif(dp[j][j+1]==-1) dp[j][j+1] = dp[i][j]+(sum[K[j+1]]-sum[K[i]-1])/L;\n\t\t\t\telse               dp[j][j+1] = min(dp[j][j+1], dp[i][j]+(sum[K[j+1]]-sum[K[i]-1])/L);\n\t\t\t\t// K[j], K[j+1] ÌÀÑðìéê\n\t\t\t\tif(dp[i][j+1]==-1) dp[i][j+1] = dp[i][j]+(sum[K[j+1]]-sum[K[j]-1])/L;\n\t\t\t\telse               dp[i][j+1] = min(dp[i][j+1], dp[i][j]+(sum[K[j+1]]-sum[K[j]-1])/L);\n\t\t\t}\n\t\t}\n\t\tlong long res = 1000000000000000LL;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tres = min(res, dp[i][N-1]+(sum[K[N-1]]-sum[K[i]-1])/L);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,M,L;\n  cin>>N>>M>>L;\n  int K[2000];\n  for(int i=0;i<N;i++){\n    cin>>K[i];\n  }\n  int S[100001];\n  long long as[100001]={};\n  for(int i=1;i<=M;i++){\n    cin>>S[i];\n    as[i]=as[i-1]+S[i];\n  }\n  sort(begin(K),begin(K)+N,[&](int a,int b){\n      return S[a]<S[b];\n    });\n  static long long dp[2000][2000];\n  fill(dp[0],dp[2000],1LL<<62);\n  dp[0][0]=0;\n  auto f=[&](int a,int b){\n    return (as[K[b]]-as[K[a]-1])/L;\n  };\n  for(int i=0;i<N-1;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j]=min(dp[i+1][j],dp[i][j]+f(i,i+1));\n      dp[i+1][i]=min(dp[i+1][i],dp[i][j]+f(j,i+1));\n    }\n  }\n  long long m=1LL<<62;\n  for(int i=0;i<N;i++){\n    m=min(m,dp[N-1][i]+f(i,N-1));\n  }\n  cout<<m<<endl;\n}\n  \n  "
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL n, m, l;\nLL s[101010], k[101010], sum[101010], dp[2020][2020];\n\nLL calc(int a, int b) {\n\treturn (sum[b + 1] - sum[a]) / l;\n}\n\nLL solve(int a, int b) {\n\tif (a < b)swap(a, b);\n\tif (dp[a][b] >= 0)return dp[a][b];\n\tint pos = max(a, b);\n\tif (pos == n - 1) {\n\t\treturn dp[a][b] = calc(k[min(a, b)], k[pos]);\n\t}\n\treturn dp[a][b] = min(solve(pos + 1, b) + calc(k[a], k[pos + 1]), solve(a, pos + 1) + calc(k[b], k[pos + 1]));\n}\n\nint main() {\n\tcin >> n >> m >> l;\n\tREP(i, 2020)REP(j, 2020)dp[i][j] = -1;\n\tREP(i, n) {\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\tsort(k, k + n);\n\tREP(i, m) {\n\t\tcin >> s[i];\n\t}\n\tREP(i, m + 1) {\n\t\tsum[i] += sum[i - 1] + s[i - 1];\n\t}\n\tcout << solve(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst ll inf = (ll)4e18;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, k[2000], s[100001];\nll sum[100001], dp[2001][2001];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\trep(i, n) scanf(\"%d\", k + i);\n\trep(i, m) scanf(\"%d\", s + i), sum[i + 1] = sum[i] + s[i];\n\t\n\tsort(k, k + n, greater<int>());\n\trep(i, n + 1) rep(j, n + 1) dp[i][j] = inf;\n\tdp[0][0] = 0;\n\t\n\tll ans = inf;\n\trep(i, n) rep(j, i + 1) if(dp[i][j] < inf){\n\t\tint h = max(i, j) + 1;\n\t\tdp[h][j] = min(dp[j][h], dp[i][j] + (sum[k[i]] - sum[k[h] - 1]) / l);\n\t\tdp[h][i] = min(dp[h][i], dp[i][j] + (sum[k[j]] - sum[k[h] - 1]) / l);\n\t}\n\trep(i, n) ans = min(ans, dp[n - 1][i] + (sum[k[i]] - sum[k[n - 1] - 1]) / l);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int IINF = INT_MAX;\n\nint K[2000],S[100000],N,M,memo[2000][2000],L;\nll cost[2000][2000],sum[100000];\n\nint dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return cost[p1][N-1] + cost[p2][N-1];\n  if( memo[p1][p2] != IINF ) return memo[p1][p2];\n  return memo[p1][p2] = min(cost[p1][v]+dfs(v,p2),\n                            cost[p2][v]+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + S[i];\n  rep(i,N){\n    REP(j,i,N){\n      ll value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n      cost[i][j] = sum[K[j]] - value;\n    }\n  }\n  rep(i,N) REP(j,i,N) cost[i][j] = floor((double)cost[i][j] / (double)L);\n  rep(i,N) rep(j,N) memo[i][j] = IINF;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m, l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nint compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = sum[notes[j] - 1];\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      for(int j=0;j<=i;j++){\n        int next = i + 1;\n\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, l;\n  cin >> n >> m >> l;\n  VI k(n), s(m);\n  REP(i, n) cin >> k[i], k[i]--;\n  REP(i, m) cin >> s[i];\n\n  FOR(i, 1, m) s[i] += s[i-1];\n  sort(ALL(k));\n\n  auto sum = [&](int from, int to) {\n    if(to < from) swap(from, to);\n    return (s[to] - (from >= 1 ? s[from-1] : 0)) / l;\n  };\n\n  VVI dp(n, VI(n, -1));\n  function<int(int,int)> dfs = [&](int x, int y) -> int {\n    if(dp[x][y] >= 0) return dp[x][y];\n    int nxt = max(x, y) + 1;\n    if(nxt == n) {\n      int tmp = min(x, y);\n      return sum(k[tmp], k[n-1]);\n    }\n    int vl = dfs(nxt, y) + sum(k[x], k[nxt]);\n    int vr = dfs(x, nxt) + sum(k[y], k[nxt]);\n    return dp[x][y] = min(vl, vr);\n  };\n\n  cout << dfs(0, 0) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint N, M, L;\nvector<int>ks;\nvector<long long int>sums;\n\nlong long int getmen(const int l, const int r) {\n\treturn  (sums[ks[r] + 1] - sums[ks[l]]) / L;\n}\n\nlong long int dp[2010][2010];\nint main() {\n\tcin >> N >> M >> L;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tk--;\n\t\tks.push_back(k);\n\n\t}\n\tsort(ks.begin(), ks.end());\n\tvector<int>beaus;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s; cin >> s;\n\t\tbeaus.push_back(s);\n\t}\n\tsums.push_back(0);\n\tlong long int now = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tnow += beaus[i];\n\t\tsums.push_back(now);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < 2010; ++i) {\n\t\tfor (int j = 0; j < 2010; ++j) {\n\t\t\tdp[i][j] = 9999999999999999;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < N-2; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + getmen(j, i + 1));\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + getmen(i, i + 1));\n\t\t}\n\t}\n\tlong long int ans = 9999999999999999;\n\tfor (int i = 0; i < N-2; ++i) {\n\t\tans = min(ans, dp[N - 2][i] + getmen(N - 2, N - 1) + getmen(i, N - 1));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint64 N, M, L, K[2000], S[100000], dp[2000][2000];\n\nint64 Range(int a, int b) {\n  if(a < b) swap(a, b);\n  if(b == 0) return(S[a]);\n  return(S[a] - S[b - 1]);\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return Range( K[right], K[left]) / L;\n  if(~dp[right][left]) return dp[right][left];\n  int64 ret = 1LL << 55;\n  ret = min( ret, rec( idx + 1, idx, left) + Range( K[right], K[idx]) / L);\n  ret = min( ret, rec( idx + 1, right, idx) + Range( K[left], K[idx]) / L);\n  return dp[right][left] = ret;\n}\n \nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  sort(K, K + N);\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nint64_t F[100001];\nint N,M;\nint64_t L;\n\nint64_t f(int a, int b){\n    return (F[b+1]-F[a])/L;\n}\n\nint main(){\n    cin>>N>>M>>L;\n    vector<int64_t> K(N),S(M);\n    for(auto &k:K)cin>>k;\n    for(auto &s:S)cin>>s;\n    for(int i=0;i<M;i++){\n        F[i+1]=F[i]+S[i];//(a,b)????????????=(F[b+1]-F[a])/L\n    }\n    sort(K.begin(), K.end());\n    for(auto &k:K)k--;\n    int64_t DP[N][N];\n    fill(DP[0],DP[N],100000000);\n    DP[0][0]=0;\n    DP[1][0]=f(K[0],K[1]);\n    for(int i=1;i<N;i++){\n        for(int j=0;j<i-1;j++){\n            DP[i][j]=DP[i-1][j]+f(K[i-1],K[i]);\n        }\n        for(int k=0;k<i-1;k++){\n            DP[i][i-1]=min(DP[i][i-1],DP[i-1][k]+f(K[k],K[i]));\n        }\n    }\n    int64_t ans = 100000000;\n    for(int i=0;i<N-1;i++){\n        ans=min(ans,DP[N-1][i]+f(K[i],K[N-1]));\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2312>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll N,M,L;\nll Cost(ll a,ll b,vector<ll>& cusum){\n    if(a > b) swap(a,b);\n    return (cusum[b]-cusum[a-1])/L;\n}\nll solve(){\n    ll res = LINF;\n    cin >> N >> M >> L;\n    vector<ll> K(N),S(M);\n    for(auto& in:K) {cin >> in;}\n    for(auto& in:S) cin >> in;\n    vector<ll> cusum(M+1,0);\n    for(int i = 0; i < M;i++) cusum[i+1] += cusum[i] + S[i];\n    sort(K.begin(),K.end());\n    \n    vector<vector<ll>> dp(N,vector<ll>(N,0));\n    for(int j = 1; j < N;j++){\n        for(int i = 0; i < j; i++){\n            if(i == 0&& j == 1){\n                dp[i][j] = Cost(K[i],K[j],cusum);\n            }else if(i < j - 1){\n                dp[i][j] = dp[i][j-1] + Cost(K[j-1],K[j],cusum);\n            }else{\n                dp[i][j] = LINF;\n                for(int k = 0; k < i; k++){\n                    dp[i][j] = min(dp[i][j],dp[k][i] + Cost(K[k],K[j],cusum));\n                }\n            }\n        }\n    }\n    \n    for(int k = 0; k < N-1;k++){\n        res = min(res,dp[k][N-1]+Cost(K[k],K[N-1],cusum));\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nint main()\n{\n  int N,M,L;\n  vector<int>K,S;\n  long long int ans=LLONG_MAX;\n  cin>>N>>M>>L;\n  K.resize(N);\n  S.resize(M);\n  for(int i=0;i<N;i++)cin>>K[i];\n  for(int i=0;i<M;i++)cin>>S[i];\n  sort(K.begin(),K.end());\n  do{\n    long long int sum=0;\n    for(int i=0;i<N;i++){\n      long long int tmp=0;\n      int a=K[i],b=K[(i+1)%N];\n      if(a>b)swap(a,b);\n      for(int j=a;j<=b;j++){tmp+=S[j-1];}\n      tmp/=L;\n      sum+=tmp;\n    }\n    ans=ans<sum?ans:sum;\n  }while(next_permutation(K.begin(),K.end()));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\n#include<map>\n#include<set>\nusing namespace std;\n#define int long long\nvector<int> SS;\nint L;\nint sum(int a, int b) {\n\tint res = SS[b];\n\tif (a > 0)res -= SS[a - 1];\n\treturn (res / L);\n}\nsigned main() {\n\n\tint N, M;\n\tcin >> N >> M >> L;\n\tvector<int> S(M);\n\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tmp[a]++;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> S[i];\n\t}\n\tSS = S;\n\tfor (int i = 1; i < M; i++) {\n\t\tSS[i] += SS[i - 1];\n\t}\n\tN = mp.size();\n\tvector<int> A(N);\n\tvector<int> C(N);\n\tint t = 0;\n\tfor (auto m : mp) {\n\t\tA[t] = m.first;\n\t\tC[t] = m.second;\n\t\tt++;\n\t}\n\n\tint INF = (int)1 << 60;\n\tif (N == 1) {\n\t\tcout << sum(A[0],A[0]) * C[0] << endl;\n\t}\n\telse {\n\t\tint x = C[N - 1];\n\t\tC[N - 1] = 2;\n\t\tint res = 0;\n\t\tvector<vector<int> > dp(N, vector<int>(N, INF));\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tif (C[i] == 1) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + sum(A[i - 1], A[i]));\n\t\t\t\t\tdp[i][i - 1] = min(dp[i][i - 1], dp[i - 1][j] + sum(A[j], A[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdp[i][i] = min(dp[i][i], dp[i - 1][j] + sum(A[j], A[i]) + sum(A[i - 1], A[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cerr << dp[N - 1][N - 1] << endl;\n\t\tres += dp[N - 1][N - 1];\n\t\tres += (x - 1) * sum(A[N - 1], A[N - 1]);\n\t\tres += (C[0] - 1) * sum(A[0], A[0]);\n\t\tfor (int i = 1; i < N - 1; i++) {\n\t\t\tif (C[i] > 2) {\n\t\t\t\tres += (C[i] - 2) * sum(A[i], A[i]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,M,L;\nint K[2000],S[100001],dp[2000][2000];\n\n\nint calc(int left,int right){\n\treturn (S[right]-S[left-1])/L;\n}\n\nint recursive(int tail_A,int tail_B){\n\n\tif(dp[tail_A][tail_B] != BIG_NUM)return dp[tail_A][tail_B];\n\n\tint next = max(tail_A,tail_B)+1;\n\n\tif(next == N-1){\n\t\treturn calc(K[tail_A],K[N-1])+calc(K[tail_B],K[N-1]);\n\t}\n\n\tint ret_A = recursive(next,tail_B) + calc(K[tail_A],K[next]);\n\tint ret_B = recursive(tail_A,next) + calc(K[tail_B],K[next]);\n\n\treturn dp[tail_A][tail_B] = min(ret_A,ret_B);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&N,&M,&L);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&K[i]);\n\tsort(K,K+N);\n\n\tS[0] = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%d\",&S[i]);\n\t\tS[i] += S[i-1];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)dp[i][k] = BIG_NUM;\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,0));\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INFTY=1ll<<61;\n\ntemplate<typename T>\nvoid chmin(T& a,const T& b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l;){\n\t\tvector<int> ks(n),ss(m);\n\t\tfor(int& k:ks) cin>>k,k--;\n\t\tfor(int& s:ss) cin>>s;\n\t\t\n\t\tsort(begin(ks),end(ks));\n\t\t\n\t\tvector<ll> sum(m+1);\n\t\tfor(int i=0;i<m;i++) sum[i+1]=sum[i]+ss[i];\n\t\t\n\t\tvector<vector<ll>> dp(n,vector<ll>(n,INFTY));\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n-1;i++) for(int j=0;j<i;j++){\n\t\t\tchmin(dp[i][j],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[i-1]])/l);\n\t\t\tchmin(dp[i][i-1],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[j]])/l);\n\t\t}\n\t\tll res=INFTY;\n\t\tfor(int i=0;i<n-1;i++)\n\t\t\tchmin(res,dp[n-2][i]+(sum[ks[n-1]+1]-sum[ks[n-2]])/l+(sum[ks[n-1]+1]-sum[ks[i]])/l);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long lli;\n\nconst lli INF = 1LL<<60;\nconst int MAXN = 2005;\nconst int MAXM = 100005;\n\nint N, M, L;\nlli K[MAXN], S[MAXM];\nlli dp[MAXN][MAXN];\n\ninline lli sumS(int a, int b) {\n  if(a > b) swap(a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a-1];\n}\n\nint main() {\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n    }\n    for(int i = 1; i <= M; ++i) {\n      cin >> S[i];\n      if(i != 0) S[i] += S[i-1];\n    }\n    sort(K, K+N);\n    fill(dp[0], dp[MAXN], INF);\n    dp[0][0] = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        int k = max(i,j)+1;\n        if(k == N-1) {\n          dp[k][k] = min(dp[k][k],\n                         dp[i][j] + sumS(K[i],K[k])/L + sumS(K[j],K[k])/L);\n        } else {\n          dp[k][j] = min(dp[k][j], dp[i][j] + sumS(K[i], K[k])/L);\n          dp[i][k] = min(dp[i][k], dp[i][j] + sumS(K[j], K[k])/L);\n        }\n      }\n    }\n    cout << dp[N-1][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long N, M, L, K[100009], S[100009], T[100009];\nlong long dp[2009][2009];\n\nlong long scores(long long a, long long b) {\n\treturn (T[b] - T[a - 1]) / L;\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor (int i = 1; i <= N; i++) cin >> K[i];\n\tfor (int i = 1; i <= M; i++) cin >> S[i];\n\tfor (int i = 1; i <= M; i++) T[i] = T[i - 1] + S[i];\n\n\tfor (int i = 1; i <= N; i++) { for (int j = 1; j <= N; j++) dp[i][j] = (1LL << 60); }\n\tsort(K + 1, K + N + 1);\n\n\tdp[1][1] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (dp[i][j] == (1LL << 60)) continue;\n\t\t\t// i : この前のやつ, j : もう一方のやつ\n\t\t\t\n\t\t\tif (i == N - 1) {\n\t\t\t\tdp[N][N] = min(dp[N][N], dp[i][j] + scores(K[i], K[N]) + scores(K[j], K[N]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + scores(K[j], K[i + 1]));\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + scores(K[i], K[i + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N][N] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\nstruct _Writer\n{\n\tbool f;\n\t_Writer() : f(false) { }\n\ttemplate <class T> _Writer operator ,(T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; }\n};\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\n\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<long>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\tdp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\tminCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\tWRITE(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\ntypedef long long ll;\n\nusing namespace std;\n\nll N,M,L,K[2001],sum[100001],dp[2001][2001];\n\nll func(ll l,ll r){\n\n  if(dp[l][r]>0)return dp[l][r];\n\n  ll n=max(l,r)+1;\n  if(n==N)return (sum[K[n]]-sum[K[l]-1])/L+(sum[K[n]]-sum[K[r]-1])/L;\n\n  ll lf=func(n,r)+(sum[K[n]]-sum[K[l]-1])/L;\n  ll rt=func(l,n)+(sum[K[n]]-sum[K[r]-1])/L;\n\n  return dp[l][r]=min(lf,rt);\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++)cin >> K[i];\n  \n  sort(K+1,K+N+1);\n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  cout << func(1,1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nint K[2000],S[100000],N,M;\nll cost[2000][2000],sum[100000],memo[2000][2000],L;\n\nll dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return cost[p1][N-1] + cost[p2][N-1];\n  if( memo[p1][p2] != LLINF ) return memo[p1][p2];\n  return memo[p1][p2] = min(cost[p1][v]+dfs(v,p2),\n                            cost[p2][v]+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + (ll)S[i];\n  rep(i,N){\n    REP(j,i,N){\n      ll value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n      cost[i][j] = sum[K[j]] - value;\n    }\n  }\n  rep(i,N) REP(j,i,N) cost[i][j] = floor((double)cost[i][j] / (double)L);\n  rep(i,N) rep(j,N) memo[i][j] = LLINF;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst ll INF = 1LL<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nll get_cost(int from, int to, int L, const vector<ll>& accum){\n  ll sum = accum[to] - accum[from - 1];\n  return sum / L;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    vector<int> K(N);\n    vector<int> S(M);\n    REP(i, N) cin >> K[i];\n    REP(i, M) cin >> S[i];\n\n    vector<ll> accum(M + 1);\n    REP(i, M) accum[i + 1] = accum[i] + S[i];\n\n    sort(K.begin(), K.end());\n    static ll dp[2000][2000] = {};\n    REP(i, N)REP(j, N) dp[i][j] = INF;\n    dp[0][1] = get_cost(K[0], K[1], L, accum);\n    ll ans = INF;\n    REP(i, N - 1) FOR(j, i + 1, N - 1){\n      if(j + 1 != N - 1){ // default\n        dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + get_cost(K[j], K[j + 1], L, accum)); // j -> j + 1\n        dp[j][j + 1] = min(dp[j][j + 1], dp[i][j] + get_cost(K[i], K[j + 1], L, accum)); // i -> j + 1\n      }else{ // goal\n        ans = min(ans, dp[i][j] + get_cost(K[i], K[N - 1], L, accum) + get_cost(K[j], K[N - 1], L, accum));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n// mt19937 mt{random_device{}()};\n// uniform_int_distribution<ll> ndist{3, 6};\n// uniform_int_distribution<ll> mdist{1, 100};\n// uniform_int_distribution<ll> ldist{1, 100000};\n// uniform_int_distribution<ll> sdist{1, 100000};\n\nint main()\n{\n    ll N, M, L;\n    cin >> N >> M >> L;\n    //    N = ndist(mt), M = mdist(mt), L = ldist(mt);\n    uniform_int_distribution<ll> kdist{1, M};\n    vector<ll> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n        //        K[i] = kdist(mt);\n        K[i]--;\n    }\n    auto zip = K;\n    sort(zip.begin(), zip.end());\n    zip.erase(unique(zip.begin(), zip.end()), zip.end());\n    const int size = zip.size();\n    map<ll, ll> unzip;\n    for (int i = 0; i < size; i++) {\n        unzip[zip[i]] = i;\n    }\n    for (int i = 0; i < N; i++) {\n        K[i] = unzip[K[i]];\n    }\n    // show(K);\n\n    vector<ll> S(M);\n    vector<ll> sum(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n        //  S[i] = sdist(mt);\n        sum[i] = ((i > 0) ? sum[i - 1] : 0) + S[i];\n    }\n    vector<vector<ll>> dist(size, vector<ll>(size, 0));\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            ll l = min(zip[i], zip[j]);\n            ll r = max(zip[i], zip[j]);\n            dist[i][j] = (sum[r] - ((l > 0) ? sum[l - 1] : 0)) / L;\n        }\n    }\n    //    show(dist);\n\n    sort(K.begin(), K.end());\n    ll mini = 1LL << 60;\n    for (int i = 0; i < N; i++) {\n        vector<ll> tmp;\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                tmp.push_back(K[j]);\n            }\n        }\n        tmp.push_back(K[i]);\n        ll suma = 0;\n        for (int i = 0; i < N; i++) {\n            suma += dist[tmp[i]][tmp[(i + 1) % N]];\n        }\n        mini = min(mini, suma);\n    }\n    cout << mini << endl;\n\n    // vector<ll> perm(N);\n    // do {\n    //     ll s = 0;\n    //     for (int i = 0; i < N; i++) {\n    //         s += dist[K[i]][K[(i + 1) % N]];\n    //     }\n    //     if (mini > s) {\n    //         perm = K;\n    //         mini = s;\n    //     }\n    // } while (next_permutation(K.begin(), K.end()));\n    // cout << mini << endl;\n    // show(perm);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1LL << 40;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n-2;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\t//dp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\t//dp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m,l;\nll a[2002],b[200002];\nll sum[200002];\nll dp[2002][2002];\n\nll f(int i,int j){\n  if(a[i]>a[j])swap(i,j);\n  return (sum[a[j]+1]-sum[a[i]])/l;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>l;\n  rep(i,n){\n    cin>>a[i];\n    a[i]--;\n  }\n  sort(a,a+n);\n  rep(i,m){\n    cin>>b[i];\n  }\n  rep(i,m){\n    sum[i+1]=sum[i]+b[i];\n  }\n  rep(i,2002)rep(j,2002)dp[i][j]=INF;\n  dp[0][0]=f(0,n-1)*2;\n  rep(i,n-2){\n    rep(j,i+1){\n      if(dp[i][j]==INF)continue;\n      minch(dp[i+1][j],dp[i][j]-f(i,n-1)+f(i,i+1)+f(i+1,n-1));\n      minch(dp[i][i+1],dp[i][j]-f(j,n-1)+f(j,i+1)+f(i+1,n-1));\n    }\n  }\n  ll res=INF;\n  rep(i,n){\n    minch(res,min(dp[n-2][i],dp[i][n-2]));\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M,L;\nint K[2001];\nint S[100001];\npair<int,int> Onpu[2001];\n\nll dp[2001][2001];\nll sums[100001];\n\nll dfs(int a,int b){\n    if(a==N-1||b==N-1){\n        if(a<b)swap(a,b);\n        return (sums[K[a]+1]-sums[K[b]])/L;\n    }\n    else if(dp[a][b]!=-1)return dp[a][b];\n    int nxtIdx=max(a,b)+1;\n    ll tmp=(sums[K[nxtIdx]+1]-sums[K[a]])/L;\n    ll res=dfs(nxtIdx,b)+tmp;\n    res=min(res,dfs(a,nxtIdx)+(sums[K[nxtIdx]+1]-sums[K[b]])/L);\n    return dp[a][b]=res;\n}\nint main(){\n\n    while(cin>>N>>M>>L&&(N|M|L)){\n        for(int i=0;i<N;i++){\n            cin>>K[i];\n            K[i]--;\n        }\n        for(int i=0;i<M;i++){\n            cin>>S[i];\n            sums[i+1]=sums[i]+S[i];\n        }\n        for(int i=0;i<N;i++){\n            Onpu[i].first=S[K[i]];\n            Onpu[i].second=K[i];\n        }\n        sort(Onpu,Onpu+N);\n        for(int i=0;i<N;i++)K[i]=Onpu[i].second;\n        memset(dp,-1,sizeof(dp));\n        ll res=dfs(0,0);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2312.cc: Magical Girl Sayaka-chan\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 2000;\nconst int MAX_M = 100000;\n\n/* typedef */\n\n/* global variables */\n\nint ks[MAX_N], ss[MAX_M], sums[MAX_M + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m, l;\n  cin >> n >> m >> l;\n\n  for (int i = 0; i < n; i++) cin >> ks[i];\n  for (int i = 0; i < m; i++) {\n    cin >> ss[i];\n    sums[i + 1] = sums[i] + ss[i];\n  }\n\n  int mp = 0;\n  for (int i = 0; i < n; i++) {\n    int a = ks[i], b = ks[(i + 1) % n];\n    if (a > b) swap(a, b);\n    mp += (sums[b] - sums[a - 1]) / l;\n  }\n\n  printf(\"%d\\n\", mp);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 4005\ntypedef pair<ll,int> P;\nll INF=1000000000000000000LL;\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\n\nll min_cost_flow(int s,int t,int f){\n  ll res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i< (int) G[v].size();i++){\n          edge &e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve [e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\n\nint N,M,L;\nint t[2000];\nll u[100005];\n\nll calc(int a,int b){\n  if(a>b)swap(a,b);\n  return (u[b]-u[a-1])/(ll)L;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++)scanf(\"%d\",&t[i]);\n  sort(t,t+N);\n  \n  for(int i=1;i<=M;i++){\n    scanf(\"%lld\",&u[i]);\n    u[i]+=u[i-1];\n  }\n  \n  ll D=10000000000LL;\n  V=N;\n  for(int i=0;i<N;i++){\n    for(int j=i+1;j<N;j++){\n      ll key=calc(t[i],t[j])-D;\n      add_edge(i,j,1,key);\n    }\n  }\n  cout<<min_cost_flow(0,N-1,2)+D*N<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  10000000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[20100];\nll v[2010];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tvector<ll> k(n),s(m);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\trep(i,m){\n\t\tcin >> s[i];\n\t}\n\tsort(k.begin(),k.end());\n\tdst[0] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i] = dst[i-1] + s[i-1];\n\t}\n\tv[1] = (dst[k[1]+1]-dst[k[0]])/l;\n\tfor (int i=2;i<n;i++){\n\t\tv[i] = v[i-1] + (dst[k[i]+1]-dst[k[i-1]])/l;\n\t}\n\t\n\tdp[n-1] = (dst[k[n-1]+1]-dst[k[n-2]])/l;\n\tfor(int i=n-2;i>0;i--){\n\t\tdp[i] = inf;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(j==i+1){\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+dp[j]);\n\t\t\t}else{\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+v[j]-v[i]+dp[j]);\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i]])/l+(dst[k[i+1]+1]-dst[k[i-1]])/l+v[j-1]-v[i+1]+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = inf;\n\tfor(int i=1;i<n;i++){\n\t\tmi = min(mi,dp[i]+(dst[k[i]+1]-dst[k[0]])/l+v[i-1]);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\nint N, M, L, K[2000], S[10001];\nconst ll INF = 100000000000000ll;\nll sum[10001];\nll dp[2000][2001];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &L);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%d\", K + i);\n\tfor (int i = 1; i <= M; ++i)\n\t\tscanf(\"%d\", S + i);\n\tsort(K, K + N);\n\n\tsum[0] = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t\tsum[i] = sum[i-1] + S[i];\n\n\tfor (int i = 0; i < 2000; ++i)\n\t\tfor (int j = i; j < 2001; ++j)\n\t\t\tdp[i][j] = INF;\n\n#define seg_sum(a, b) ((sum[b] - sum[a-1]) / L)\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < N-1; ++i)\n\t{\n\t\tfor (int j = i + 1; j < N; ++j)\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-1] + seg_sum(K[j-1], K[j]));\n\t\tfor (int j = i + 1; j < N-1; ++j)\n\t\t\tdp[j][j+1] = min(dp[j][j+1], dp[i][j] + seg_sum(K[i], K[j+1]));\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i < N-1; ++i)\n\t\tans = min(ans, dp[i][N-1] + seg_sum(K[i], K[N-1]));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, l; cin >> n >> m >> l;\n    vll k(n); rep(i, n) { cin >> k[i]; k[i]--; }\n    vll s(m); rep(i, m) cin >> s[i];\n\n    sort(all(k));\n\n    vll ss(m+1); rep(i, m) ss[i+1] = ss[i] + s[i];\n\n    function<ll(ll, ll)> dist = [&](ll i_, ll j_){\n        ll i = k[i_], j = k[j_];\n        if (i > j) swap(i, j);\n        return (ss[j+1] - ss[i]) / l;\n    };\n//    cout << ss << endl;\n\n    map<P, ll> memo;\n    function<ll(ll, ll)> f = [&](ll l, ll r){\n//        cout << l << \" \" << r << endl;\n        ll next = max(l, r) + 1;\n        if (next >= n) return dist(l, r);\n        if (memo.count(P(l, r))) return memo[P(l, r)];\n\n        memo[P(l, r)] = min(f(l, next) + dist(next, r) , dist(next, l) + f(next, r));\n        return memo[P(l, r)];\n    };\n\n    /*\n    cout << dist(0, 2) << endl;\n    cout << dist(2, 4) << endl;\n    cout << dist(4, 3) << endl;\n    cout << dist(3, 0) << endl;\n    */\n    cout << f(0, 0) << endl;\n    /*\n    cout << f(0, 3) << endl;\n    */\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nll N,M,L;\nll K[2000],S[100001],dp[2000][2000];\n\n\nll calc(int left,int right){\n\treturn (S[right]-S[left-1])/L;\n}\n\nll recursive(int tail_A,int tail_B){\n\n\tif(dp[tail_A][tail_B] != 999999999999)return dp[tail_A][tail_B];\n\n\tint next = max(tail_A,tail_B)+1;\n\n\tif(next == N-1){\n\t\treturn calc(K[tail_A],K[N-1])+calc(K[tail_B],K[N-1]);\n\t}\n\n\tll ret_A = recursive(next,tail_B) + calc(K[tail_A],K[next]);\n\tll ret_B = recursive(tail_A,next) + calc(K[tail_B],K[next]);\n\n\treturn dp[tail_A][tail_B] = min(ret_A,ret_B);\n}\n\n\nint main(){\n\n\tscanf(\"%lld %lld %lld\",&N,&M,&L);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%lld\",&K[i]);\n\tsort(K,K+N);\n\n\tS[0] = 0;\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%lld\",&S[i]);\n\t\tS[i] += S[i-1];\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)dp[i][k] = 999999999999;\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0));\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,M,L;\n  cin>>N>>M>>L;\n  int K[2000];\n  for(int i=0;i<N;i++){\n    cin>>K[i];\n  }\n  sort(begin(K),begin(K)+N);\n  int S[100001];\n  long long as[100001]={};\n  for(int i=1;i<=M;i++){\n    cin>>S[i];\n    as[i]=as[i-1]+S[i];\n  }\n  static long long dp[2000][2000];\n  fill(dp[0],dp[2000],1LL<<62);\n  dp[0][0]=0;\n  auto f=[&](int a,int b){\n    return (as[K[b]]-as[K[a]-1])/L;\n  };\n  for(int i=0;i<N-1;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j]=min(dp[i+1][j],dp[i][j]+f(i,i+1));\n      dp[i+1][i]=min(dp[i+1][i],dp[i][j]+f(j,i+1));\n    }\n  }\n  long long m=1LL<<62;\n  for(int i=0;i<N;i++){\n    m=min(m,dp[N-1][i]+f(i,N-1));\n  }\n  cout<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    cin >> n >> m >> l;\n\n    vector<int> k(n);\n    for(int i=0; i<n; ++i){\n        cin >> k[i];\n        -- k[i];\n    }\n    sort(k.begin(), k.end());\n\n    vector<int> sum(m+1, 0);\n    for(int i=1; i<=m; ++i){\n        cin >> sum[i];\n        sum[i] += sum[i-1];\n    }\n\n    vector<long long> dp(1);\n    dp[0] = abs(sum[k[1]+1] - sum[k[0]]) / l;\n    for(int i=2; i<n; ++i){\n        vector<long long> nextDp(i, LLONG_MAX);\n        for(int j=0; j<i-1; ++j){\n            nextDp[i-1] = min(nextDp[i-1], dp[j] + abs(sum[k[i]+1] - sum[k[j]]) / l);\n            nextDp[j] = min(nextDp[j], dp[j] + abs(sum[k[i]+1] - sum[k[i-1]]) / l);\n        }\n        dp.swap(nextDp);\n    }\n\n    long long ret = LLONG_MAX;\n    for(int i=0; i<n-1; ++i)\n        ret = min(ret, dp[i] + abs(sum[k[n-1]+1] - sum[k[i]]) / l);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nll n,m,l;\nll k[2222];\nll sum[111111];\n\nvector<ll> magic[2];\n\nint main(void)\n{\n  cin >> n >> m >> l;\n  for(int i = 0; i < n; i++){\n    cin >> k[i];\n  }\n  for(int i = 1; i <= m; i++){\n    int s;\n    cin >> s;\n    sum[i] = sum[i-1] + s;\n    //cout << sum[i] << \" \";\n  }\n  //cout << endl;\n\n  sort(k, k + n);\n\n  magic[0].push_back(k[0]);\n  magic[1].push_back(k[0]);\n  for(int i = 1; i < n - 1; i++){\n    if(sum[k[i]] - sum[magic[0][magic[0].size()-1] - 1] < \n       sum[k[i]] - sum[magic[1][magic[1].size()-1] - 1]){\n      magic[0].push_back(k[i]);\n    }else{\n      magic[1].push_back(k[i]);\n    }\n  }\n  magic[0].push_back(k[n-1]);\n  magic[1].push_back(k[n-1]);\n\n  ll ret = 0;\n\n  for(int i = 0; i < 2; i++){\n    for(int j = 1; j < (int)magic[i].size(); j++){\n      //cout << ( sum[magic[i][j]] - sum[magic[i][j-1] - 1] )  << \" \";\n      ret += ( sum[magic[i][j]] - sum[magic[i][j-1] - 1] ) / l;\n    }\n    //cout << endl;\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L, K[2000], S[100000];\nint dp[2000][2000];\n\nint Range(int a, int b) {\n  if(b < a) swap(a, b);\n  return(S[b] - S[a - 1]);\n}\n\nint rec(int idx, int left, int right)\n{\n  if(idx == N) return(Range(K[left], K[right]) / L);\n  if(~dp[left][right]) return(dp[left][right]);\n  int A = rec(idx + 1, idx, right) + Range(K[idx], K[left]) / L;\n  int B = rec(idx + 1, left, idx) + Range(K[idx], K[right]) / L;\n  return(dp[left][right] = min(A, B));\n}\n\nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nint main() {\n  int n,m,l;\n  cin>>n>>m>>l;\n  vector<int> vk(n);\n  REP(i,n) cin>>vk[i];\n  vector<int> vs(m);\n  REP(i,m) cin>>vs[i];\n  vector<int> pss(m+1);\n  partial_sum(ALL(vs), begin(pss)+1);\n  sort(ALL(vk));\n  vector<vector<int>> dp(n, vector<int>(n, INF));\n  dp[0][0] = 0;\n  REP(i,n-1) {\n    REP(j,max(1,i)) {\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (pss[vk[i+1]] - pss[vk[i]-1])/l);\n      dp[i+1][i] = min(dp[i+1][i], dp[i][j] + (pss[vk[i+1]] - pss[vk[j]-1])/l);\n    }\n  }\n  int res = INF;\n  REP(i,n-1) {\n    res = min(res, dp[n-1][i] + (pss[vk[n-1]] - pss[vk[i]-1])/l);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint N, M, L;\nvector<int> K, S;\nvector<int> sum;\n\nint dp[2010][2010];\n\nint solve(int l, int r)\n{\n  if(max(l, r) == N-1) {\n    int mn, mx;\n    tie(mn, mx) = minmax(l, r);\n    return (sum[K[mx]+1] - sum[K[mn]]) / L;\n  }\n  \n  int& ret = dp[l][r];\n  if(~ret) return ret;\n\n  int s = max(l, r) + 1;\n  ret = min(solve(s, r) + (sum[K[s]+1] - sum[K[l]]) / L,\n\t    solve(l, s) + (sum[K[s]+1] - sum[K[r]]) / L);\n  \n  return ret;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> L;\n  K.resize(N); S.resize(M); sum.resize(M + 1, 0);\n  rep(i, N) cin >> K[i], K[i]--; sort(all(K));\n  rep(i, M) cin >> S[i], sum[i+1] = sum[i] + S[i];\n  \n  memset(dp, -1, sizeof(dp));\n  cout << solve(0, 1) + (sum[K[1]+1] - sum[K[0]]) / L << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[201000];\nint S[201000];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n  \n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x3fffffffffffff\n\ntypedef long long int LLI;\n\nint N;\nint M;\nLLI L;\nLLI K[11451419];\nLLI S[11451419];\nLLI ssum[11451419];\nLLI dp[2010][2010];\n\nLLI sum(int a, int b) {\n  if (a > b) swap(a, b);\n  return (ssum[b] - ssum[a-1])/L;\n}\n\nint main() {\n  scanf(\"%d%d%lld\", &N, &M, &L);\n  for (int i=1; i<=N; i++) {\n    scanf(\"%lld\", &K[i]);\n  }\n  sort(K+1, K+N+1);\n  \n  for (int i=1; i<=M; i++) {\n    scanf(\"%lld\", &S[i]);\n    ssum[i] = ssum[i-1]+S[i];\n  }\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; j<=N; j++) {\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[1][0] = 0;\n  for (int i=2; i<=N; i++) {\n    for (int j=0; j<i-1; j++) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]+sum(K[i-1], K[i]));\n      if (j != 0) {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[j], K[i]));\n      } else {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[1], K[i]));\n      }\n    }\n  }\n\n  LLI ans = INF;\n  for (int j=0; j<=N; j++) {\n    if (j != 0) {\n      dp[N][j] += sum(K[j], K[N]);\n    } else {\n      dp[N][j] += sum(K[1], K[N]);\n    }\n    ans = min(ans, dp[N][j]);\n  }\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#define range(i,a,b) assert(a<=i && i<=b)\nusing namespace std;\nint N, M, L;\nvector<long long> K, S;\nlong long floorL(long long x){\n\treturn (x / L)*L;\n}\nlong long sumofS(int a, int b){\n\tlong long sum = 0;\n\tfor (int i = a; i < b + 1; i++){\n\t\trange(i, 0, M - 1);\n\t\tsum += S[i];\n\t}\n\treturn sum;\n}\nlong long solve(int n){\n\tif (n > 0){\n\t\tauto res = solve(n - 1);\n\t\tauto sum1 = sumofS(K[n - 1] + 1, K[n]);\n\t\tauto sum2 = sumofS(K[n - 1], K[n]);\n\t\trange(n, 1, N - 1);\n\t\tauto candi1 = floorL(res + sum1) + sum2;\n\t\tauto candi2 = res + sum1 + floorL(sum2);\n\t\t//cerr << candi1 << \" \" << candi2 << endl;\n\t\treturn min(candi1,candi2);\n\t}\n\telse{\n\t\trange(K[0], 0, M - 1);\n\t\t//cerr << S[K[0]] << endl;\n\t\treturn S[K[0]];\n\t}\n}\nint main(){\n\tcin >> N >> M >> L;\n\tK = vector<long long>(N);\n\tS = vector<long long>(M);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\tsort(K.begin(), K.end());\n\tauto ans = solve(N - 1) / L;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1ll<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l){\n\t\tvector<ll> K(n), S(m), sum(m+1);\n\t\tREP(i, n) cin >> K[i], K[i]--;\n\t\tREP(i, m) cin >> S[i];\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vector<ll>> dp(n+1, vector<ll>(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tchmin(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tchmin(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tcout << dp[n-1][n-2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nll n,m,l;\nll k[2222];\nll sum[111111];\n\nll dp[2222][2222];\n\nvector<ll> magic[2];\n\nll solve(int m1,int m2){\n  if(dp[m1][m2]) return dp[m1][m2];\n\n  if(m1 >= n-1) return (sum[k[n-1]] - sum[k[m2] - 1]) / l;\n  if(m2 >= n-1) return (sum[k[n-1]] - sum[k[m1] - 1]) / l;\n\n  ll ret = 0;\n  \n  int next = max(m1,m2) + 1;\n\n  ret = min(solve(next,m2) + (sum[k[next]] - sum[k[m1] - 1]) / l,\n\t    solve(next,m1) + (sum[k[next]] - sum[k[m2] - 1]) / l);\n  return dp[m1][m2] = ret;\n}\n\nint main(void)\n{\n  cin >> n >> m >> l;\n  for(int i = 0; i < n; i++){\n    cin >> k[i];\n  }\n  for(int i = 1; i <= m; i++){\n    int s;\n    cin >> s;\n    sum[i] = sum[i-1] + s;\n  }\n\n  sort(k, k + n);\n\n  /*\n  magic[0].push_back(k[0]);\n  magic[1].push_back(k[0]);\n  for(int i = 1; i < n - 1; i++){\n    if(sum[k[i]] - sum[magic[0][magic[0].size()-1] - 1] < \n       sum[k[i]] - sum[magic[1][magic[1].size()-1] - 1]){\n      magic[0].push_back(k[i]);\n    }else{\n      magic[1].push_back(k[i]);\n    }\n  }\n  magic[0].push_back(k[n-1]);\n  magic[1].push_back(k[n-1]);\n\n  ll ret = 0;\n\n  for(int i = 0; i < 2; i++){\n    for(int j = 1; j < (int)magic[i].size(); j++){\n      ret += ( sum[magic[i][j]] - sum[magic[i][j-1] - 1] ) / l;\n    }\n  }\n  cout << ret << endl;\n  */\n\n  cout << solve(0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <deque>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    {\n        deque<int> k1;\n        repeat (i, n) {\n            if (i % 2 == 0) {\n                k1.push_back(k[i]);\n            } else {\n                k1.push_front(k[i]);\n            }\n        }\n        k = vector<int>(whole(k1));\n    }\n    vector<ll> acc(1); partial_sum(whole(s), back_inserter(acc));\n    ll score = 0;\n    repeat (i, n) {\n        int a = k[i];\n        int b = k[(i + 1) % n];\n        if (a > b) swap(a, b);\n        score += (acc[b + 1] - acc[a]) / l;\n    }\n    ll result = score;\n    repeat (i, n - 1) {\n        setmin(result,\n                score\n                - (acc[i + 1] - acc[i]) / l\n                - (acc[n - 1] - acc[1]) / l\n                + (acc[i + 1] - acc[1]) / l\n                + (acc[n - 1] - acc[i]) / l\n                );\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  10000000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[50100];\nll v[2010];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tvector<ll> k(n),s(m);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\trep(i,m){\n\t\tcin >> s[i];\n\t}\n\tsort(k.begin(),k.end());\n\tdst[0] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i] = dst[i-1] + s[i-1];\n\t}\n\tv[1] = (dst[k[1]+1]-dst[k[0]])/l;\n\tfor (int i=2;i<n;i++){\n\t\tv[i] = v[i-1] + (dst[k[i]+1]-dst[k[i-1]])/l;\n\t}\n\t\n\tdp[n-1] = (dst[k[n-1]+1]-dst[k[n-2]])/l;\n\tfor(int i=n-2;i>0;i--){\n\t\tdp[i] = inf;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(j==i+1){\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+dp[j]);\n\t\t\t}else{\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+v[j]-v[i]+dp[j]);\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i]])/l+(dst[k[i+1]+1]-dst[k[i-1]])/l+v[j-1]-v[i+1]+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = inf;\n\tfor(int i=1;i<n;i++){\n\t\tmi = min(mi,dp[i]+(dst[k[i]+1]-dst[k[0]])/l+v[i-1]);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    cin >> n >> m >> l;\n\n    vector<int> k(n);\n    for(int i=0; i<n; ++i){\n        cin >> k[i];\n        -- k[i];\n    }\n    sort(k.begin(), k.end());\n\n    vector<long long> sum(m+1, 0);\n    for(int i=1; i<=m; ++i){\n        cin >> sum[i];\n        sum[i] += sum[i-1];\n    }\n\n    vector<long long> dp(1);\n    dp[0] = (sum[k[1]+1] - sum[k[0]]) / l;\n    for(int i=2; i<n; ++i){\n        vector<long long> nextDp(i, LLONG_MAX);\n        for(int j=0; j<i-1; ++j){\n            nextDp[i-1] = min(nextDp[i-1], dp[j] + (sum[k[i]+1] - sum[k[j]]) / l);\n            nextDp[j] = min(nextDp[j], dp[j] + (sum[k[i]+1] - sum[k[i-1]]) / l);\n        }\n        dp.swap(nextDp);\n    }\n\n    long long ret = LLONG_MAX;\n    for(int i=0; i<n-1; ++i)\n        ret = min(ret, dp[i] + (sum[k[n-1]+1] - sum[k[i]]) / l);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint n, m, l;\nint k[2000];\nll s[100010];\n\nint main()\n{\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> k[i];\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tcin >> s[i];\n\t\ts[i] += s[i - 1];\n\t}\n\t\n\tsort(k, k + n);\n\tll a = k[0], b = k[0], res = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tll u = s[k[i]] - s[a - 1];\n\t\tll v = s[k[i]] - s[b - 1];\n\t\tif (i == n - 1){\n\t\t\tres += u / l + v / l;\n\t\t}\n\t\telse if (u < v){\n\t\t\tres += u / l;\n\t\t\ta = k[i];\n\t\t}\n\t\telse {\n\t\t\tres += v / l;\n\t\t\tb = k[i];\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[201001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INFTY=1ll<<61;\n\nint main()\n{\n\tfor(int n,m,l;cin>>n>>m>>l;){\n\t\tvector<int> ks(n),ss(m);\n\t\tfor(int i=0;i<n;i++) cin>>ks[i];\n\t\tfor(int i=0;i<m;i++) cin>>ss[i];\n\t\t\n\t\tfor(int& k:ks) k--;\n\t\tsort(begin(ks),end(ks));\n\t\t\n\t\tvector<ll> sum(m+1);\n\t\tfor(int i=0;i<m;i++) sum[i+1]=sum[i]+ss[i];\n\t\t\n\t\tvector<vector<ll>> dp(n,vector<ll>(n,INFTY));\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n-1;i++)\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[i-1]])/l);\n\t\t\t\tdp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+(sum[ks[i]+1]-sum[ks[j]])/l);\n\t\t\t}\n\t\tll res=INFTY;\n\t\tfor(int i=0;i<n-1;i++)\n\t\t\tres=min(res,dp[n-2][i]+(sum[ks[n-1]+1]-sum[ks[n-2]])/l+(sum[ks[n-1]+1]-sum[ks[i]])/l);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define INF 50000000000LL\nusing namespace std;\nint s[2000];\nlong long r[100001];\nlong long dp[2][2][2000];//直前に使わなかった方がiでその一つ前がjの最小値\nlong long min(long long a,long long b){return a<b?a:b;}\nint main(){\n\tint n,m,k;\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&s[i]);\n\tsort(s,s+n);\n\tr[0]=0;\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%lld\",&r[i]);\n\t\tr[i]+=r[i-1];\n\t}\n\tfor(j=0;j<n;j++){\n\t\tdp[1][0][j]=INF;\n\t\tdp[1][1][j]=INF;\n\t}\n\tdp[1][0][0]=0;\n\tdp[1][1][0]=0;\n\tfor(i=1;i<n-1;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[(i+1)%2][0][j]=INF;\n\t\t\tdp[(i+1)%2][1][j]=INF;\n\t\t}\n\t\tfor(j=0;j<i;j++){\n\t\t\tdp[(i+1)%2][0][j]=min(dp[(i+1)%2][0][j],dp[i%2][0][j]+(r[s[i]]-r[s[i-1]-1])/k);\n\t\t\tdp[(i+1)%2][1][i-1]=min(dp[(i+1)%2][1][i-1],dp[i%2][0][j]+(r[s[i]]-r[s[j]-1])/k);\n\t\t\tdp[(i+1)%2][0][i-1]=min(dp[(i+1)%2][0][i-1],dp[i%2][1][j]+(r[s[i]]-r[s[j]-1])/k);\n\t\t\tdp[(i+1)%2][1][j]=min(dp[(i+1)%2][1][j],dp[i%2][1][j]+(r[s[i]]-r[s[i-1]-1])/k);\n\t\t}\n\t}\n\tlong long ans=INF;\n\tfor(i=0;i<n;i++){\n\t\tlong long res=min(dp[(n-1)%2][0][i],dp[(n-1)%2][1][i]);\n\t\tres+=(r[s[n-1]]-r[s[i]-1])/k+(r[s[n-1]]-r[s[n-2]-1])/k;\n\t\tans=min(ans,res);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[2][2020];\nsigned main(){\n  Int n,m,l;\n  cin>>n>>m>>l;\n  vector<Int> k(n),s(m);\n  for(Int i=0;i<n;i++) cin>>k[i];\n  for(Int i=0;i<m;i++) cin>>s[i];\n  vector<Int> a(m+1,0);\n  for(Int i=0;i<m;i++) a[i+1]=a[i]+s[i];\n  memset(dp,-1,sizeof(dp));\n  sort(k.begin(),k.end());\n  auto calc=[&](Int x,Int y){\n    if(k[x]>k[y]) swap(x,y);\n    return (a[k[y]]-a[k[x]-1])/l;\n  };\n  Int inf=1LL<<55LL;\n  for(Int j=0;j<2020;j++) dp[1][j]=inf;\n  dp[1][0]=calc(1,0);\n  for(Int i=2;i<n;i++){\n    bool f=i&1;\n    for(Int j=0;j<n;j++) dp[f][j]=inf;\n    for(Int j=0;j<n;j++){\n      dp[f][i-1]=min(dp[f][i-1],dp[!f][j]+calc(i,j));\n      dp[f][j]=min(dp[f][j],dp[!f][j]+calc(i,i-1));\n    }\n  }\n  Int ans=inf;\n  for(Int i=0;i<n;i++)\n    ans=min(ans,dp[(n-1)&1][i]+calc(n-1,i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n\ni64 n,m,L;\nint k[2020];\ni64 s[101010];\ni64 sum[101010];\ni64 dp[2020][2020];\ni64 get_sum(int l,int r){\n    return sum[k[r]] - sum[k[l] - 1];\n}\n\ni64 dfs(int l,int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    \n    //its end?\n    if(min(l,r) == 0){\n        return dp[l][r] = get_sum(min(l,r),max(l,r)) / L;\n    }\n    \n    int next = min(l,r) - 1;\n\n    //left\n    dp[l][r] = dfs(next,r) + get_sum(next ,l) / L;\n    dp[l][r] = min(dp[l][r] , dfs(l,next) + get_sum(next , r) / L);\n\n    return dp[l][r];\n}\n\nint main(){\n    cin >> n >> m >> L;\n    for(int i = 0;i < n;i++){\n        cin >> k[i];\n    }\n    for(int i = 1;i <= m;i++){\n        cin >> s[i];\n        sum[i] = sum[i - 1] + s[i];\n    }\n\n    sort(k , k + n);\n\n    memset(dp,-1,sizeof(dp));\n\n    cout << dfs(n - 1,n - 2) + get_sum(n - 2,n - 1) / L << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef long long LL;\ntypedef vector<LL> V;\nconst LL INF=1e17;\nint main(){\n    int N,M,L;\n    cin>>N>>M>>L;\n    V onp(N);\n    V sum(M+1,0);\n    for(auto &it:onp)cin>>it;\n    for(int i=1;i<=M;i++){\n        cin>>sum[i];\n        sum[i]+=sum[i-1];\n    }\n    sort(onp.begin(),onp.end());\n    auto f=[&](int a,int b){\n        return (sum[b]-sum[a-1])/L;\n    };\n    V dp(1,f(onp[0],onp[1]));\n    for(int i=2;i<N;i++){\n        V nxt(i,INF);\n        for(int j=0;j<i-1;j++){\n            nxt[j]=min(nxt[j],dp[j]+f(onp[i-1],onp[i]));\n            nxt[i-1]=min(nxt[i-1],dp[j]+f(onp[j],onp[i]));\n        }\n        swap(dp,nxt);\n    }\n    LL res=INF;\n    for(int i=0;i<N-1;i++)\n        res=min(res,dp[i]+f(onp[i],onp.back()));\n    cout<<res<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define mins(x,y) x=min(x,y)\n\nll dp[2010][2010];\nll s[100010];\nint L;\n\nll sum(int a,int b){\n\treturn (s[b]-(a?:s[a-1]:0))/L;\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tsort(ALL(v));\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\trep(i,m){\n\t\tif(!i){\n\t\t\ts[i]=w[i];\n\t\t}\n\t\telse{\n\t\t\ts[i]=s[i-1]+w[i];\n\t\t}\n\t}\n\trep(i,2010) rep(j,2010) dp[i][j]=INFL;\n\tdp[0][0] = 0;\n\tdp[1][0] = sum(v[0],v[1]);\n\trep(i,n-1){\n\t\trep(j,i){\n\t\t\tmins(dp[i+1][j],dp[i][j]+sum(v[i],v[i+1]));\n\t\t\tmins(dp[i+1][i],dp[i][j]+sum(v[j],v[i+1]));\n\t\t}\n\t}\n\tll ans = INFL;\n\trep(i,n){\n\t\tmins(ans,dp[n-1][i]+sum(v[i],v[n-1]));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[2010];\nint S[2010];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n\n  if(a == 0){\n    cerr << \"a < 0\" << endl;\n    assert(false);\n  }\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n  \n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint calc_power(const vector<int>& ss,const int p,const int n,const int L){\n    if(n < p) return calc_power(ss,n,p,L);\n    return (ss[n] - ss[p-1]) / L;\n}\n\nint solve(int i,int u,int d,vector<int>& ss,vector<int>& k,const int L){\n    if(i == k.size()-1){\n        return calc_power(ss,u,k.back(),L) + calc_power(ss,d,k.back(),L);\n    }else{\n        return min(calc_power(ss,u,k[i],L) + solve(i+1,k[i],d,ss,k,L),\n                   calc_power(ss,d,k[i],L) + solve(i+1,u,k[i],ss,k,L));\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N,M,L;\n    cin >> N >> M >> L;\n\n    vector<int> K(N);\n    sort(all(K));\n    vector<int> S(M);\n    for(int& i : K) cin >> i;\n    for(int& i : S) cin >> i;\n\n    vector<int> SS(M+1);\n    for(int i=1;i<SS.size();i++){\n        SS[i] = SS[i-1] + S[i-1];\n    }\n    cout << solve(1,K[0],K[0],SS,K,L) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nll l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tif (dp[left][right] >= 0) return dp[left][right];\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = INF;\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(a) a.begin(),a.end()\n\nconst int INF = 1e9;\n\nint n, m, l;\nint sm[100001];\nint cost(int a, int b) {\n\tif (a > b)swap(a, b);\n\treturn (sm[b + 1] - sm[a]) / l;\n}\n\nint dp[2001][2001];\nint main() {\n\tcin >> n >> m >> l;\n\tvector<int> k(n), s(m);\n\trep(i, n) {\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\tsort(all(k));\n\trep(i, n)rep(j, n) {\n\t\tdp[i][j] = -1;\n\t}\n\n\trep(i, m) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tsm[i] = sm[i - 1] + s[i - 1];\n\t}\n\tfunction<int(int, int)> solve = [&](int a, int b) {\n\t\tif (dp[a][b] != -1)return dp[a][b];\n\t\tint next = max(a, b) + 1;\n\t\tif (next == n) {\n\t\t\treturn cost(k[max(a, b)], k[min(a, b)]);\n\t\t}\n\t\tint t0 = solve(next, b) + cost(k[next], k[a]);\n\t\tint t1 = solve(a, next) + cost(k[next], k[b]);\n\t\treturn dp[a][b] = min(t0, t1);\n\t};\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\n\nint K[120000];\nint S[120000];\nll sum[120000];\n\nll SS(int a,int b){\n  return sum[b+1]-sum[a];\n}\n\nbool vis[2100][2100];\n\nint main() {\n\n  ll N, M, L;\n  cin >> N >> M >> L;\n  rep(i, N) cin >> K[i];\n  rep(i, N) --K[i];\n  rep(i, M) cin >> S[i];\n\n  rep(i,M) sum[i+1] = sum[i] + S[i];\n  sort(K,K+N);\n  priority_queue<pair<ll,PI> > q;\n  if(N==1){\n    cout << 0 << endl;\n    return 0;\n  }else if(N==2){\n    cout << SS(K[0],K[1])/L*2 << endl;\n    return 0;\n  }\n  \n  q.push(mp(-SS(K[0],K[1])/L,mp(0,1)));\n  ll ans = 1LL<<50LL;\n  while(!q.empty()){\n    ll cc=-q.top().F;\n    PI cv=q.top().S;\n    q.pop();\n    if(vis[cv.F][cv.S]) continue;\n    vis[cv.F][cv.S] = true;\n    //cout << cc << ' ' << cv.F << ' ' << cv.S << endl;\n    int nidx = max(cv.F,cv.S) + 1;\n    if(nidx==N-1){\n      //cout << cv.F << ' ' << K[N-1] << ' ' << SS(K[cv.F, K[N-1])/ L << endl;\n      //cout << cv.S << ' ' << K[N-1] << ' ' << SS(cv.S, K[N-1])/ L << endl;      \n      ans = min(ans,cc + SS(K[cv.F], K[N-1])/L + SS(K[cv.S], K[N-1])/L);\n      cout << ans << endl;\n      return 0;\n      continue;\n    }\n    \n    q.push(mp(-cc-SS(K[cv.F],K[nidx])/L,mp(cv.S,nidx)));\n    q.push(mp(-cc-SS(K[cv.S],K[nidx])/L,mp(cv.F,nidx)));    \n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, l;\n  cin >> n >> m >> l;\n  VI k(n), s(m);\n  REP(i, n) cin >> k[i], k[i]--;\n  REP(i, m) {\n    cin >> s[i];\n    // cout << i << endl;\n  }\n\n  // cout << n << \" \" << m << endl;\n\n  FOR(i, 1, m) {\n    s[i] += s[i-1];\n  }\n\n  auto sum = [&](int from, int to) {\n    return s[to] - (from >= 1 ? s[from-1] : 0);\n  };\n\n  sort(ALL(k));\n  int all = 0;\n  FOR(i, 1, n) {\n    int a = k[i-1], b = k[i];\n    if(a > b) swap(a, b);\n    all += sum(a, b)/l;\n  }\n\n  int ans = INF;\n  REP(i, n) FOR(j, i+1, n) {\n    // k[i], sort列, k[j] みたいな列\n    int ret = all;\n    if(i != 0) {\n      // マイナス s[k[i-1]] ~ s[k[i]], s[k[i]] ~ s[k[i+1]]\n      // プラス s[k[0]] ~ s[k[i]], s[k[i-1]] ~ s[k[i+1]]\n      ret -= sum(k[i-1], k[i])/l; ret -= sum(k[i], k[i+1])/l;\n      ret += sum(k[0], k[i])/l; ret += sum(k[i-1], k[i+1])/l;\n    }\n    if(j != n-1) {\n      ret -= sum(k[j-1], k[j])/l; ret -= sum(k[j], k[j+1])/l;\n      ret += sum(k[j], k[n-1])/l; ret += sum(k[j-1], k[j+1])/l;\n    }\n    ret += sum(k[i], k[j])/l;\n    chmin(ans, ret);\n    // cout << i << \" \" << j << \" \" << ret << endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint K[2000],S[100000],N,M,L;\nll cost[2000][2000],sum[100000],memo[2000][2000];\n\nll dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return cost[p1][N-1] + cost[p2][N-1];\n  if( memo[p1][p2] != -1 ) return memo[p1][p2];\n  return memo[p1][p2] = min(cost[p1][v]+dfs(v,p2),\n                            cost[p2][v]+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + S[i];\n  rep(i,N){\n    REP(j,i,N){\n      ll value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n      cost[i][j] = sum[K[j]] - value;\n    }\n  }\n  rep(i,N) REP(j,i,N) cost[i][j] = floor((double)cost[i][j] / (double)L);\n  rep(i,N) rep(j,N) memo[i][j] = -1;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nll dp[2100][2100];\nll sum[1000100];\nint N, M, L;\nvector<ll> K;\nvector<ll> S;\nconst ll INF = 1e15;\n\nll gauss(ll a, ll l) {\n\treturn a/l - !(a%l);\n}\n\nll solve(int a, int b) {\n\t// a, b ???????????§?????°\n\tif(dp[a][b]+1)\n\t\treturn dp[a][b];\n\tif(a == b)\n\t\treturn dp[a][b] = INF;\n\n\tll res = INF;\n\tif(abs(a-b) == 1) {\n\t\tfor(int i = 1; i < min(a,b); i++) {\n\t\t\tif(a > b)\n\t\t\t\tres = min(res, solve(i,b) + gauss(sum[K[a-1]] - sum[K[i-1]-1], L));\n\t\t\telse\n\t\t\t\tres = min(res, solve(a,i) + gauss(sum[K[b-1]] - sum[K[i-1]-1], L));\n\t\t}\n\t}\n\telse {\n\t\tif(a > b)\n\t\t\tres = min(res, solve(a-1,b) + gauss(sum[K[a-1]]-sum[K[a-2]-1], L));\n\t\telse\n\t\t\tres = min(res, solve(a,b-1) + gauss(sum[K[b-1]]-sum[K[b-2]-1], L));\n//\t\tcout << a << \",\" << b << \" \"<< K[max(a,b)-1] << \",\" << K[max(a,b)-2] << \" \" << res << endl;\n\t}\n\treturn dp[a][b] = res;\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tK.resize(N); S.resize(M);\n\tfor(int i = 0; i < N; i++)\n\t\tcin >> K[i];\n\tfor(int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\n\tfor(int i = 0; i < 2100; i++)\n\t\tfor(int j = 0; j < 2100; j++)\n\t\t\tdp[i][j] = -1;\n\tfor(int i = 0; i < S.size(); i++)\n\t\tsum[i+1] = S[i]+sum[i];\n\n\tll res = INF;\n\tsort(K.begin(), K.end());\n\tdp[1][1] = 0;\n\tdp[1][2] = dp[2][1] = gauss(sum[K[1]]-sum[K[0]-1],L);\n\tfor(int i = 1; i < N; i++) {\n\t\tres = min(res, solve(i,N) + gauss(sum[K[N-1]]-sum[K[i-1]-1],L));\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\nint N, M, L, K[2000], S[100001];\nconst ll INF = 1000000000000000000LL;\nll sum[100001];\nstatic ll dp[2000][2001];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &L);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%d\", K + i);\n\tfor (int i = 0; i < M; ++i)\n\t\tscanf(\"%d\", S + i);\n\tsort(K, K + N);\n\n\tsum[0] = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t\tsum[i] = sum[i-1] + S[i-1];\n\n\tfor (int i = 0; i < 2000; ++i)\n\t\tfor (int j = i; j < 2001; ++j)\n\t\t\tdp[i][j] = INF;\n\n#define seg_sum(a, b) ((sum[b] - sum[a-1]) / L)\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < N-1; ++i)\n\t{\n\t\tfor (int j = i + 1; j < N; ++j)\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-1] + seg_sum(K[j-1], K[j]));\n\t\tfor (int j = i + 1; j < N-1; ++j)\n\t\t\tdp[j][j+1] = min(dp[j][j+1], dp[i][j] + seg_sum(K[i], K[j+1]));\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i < N-1; ++i)\n\t\tans = min(ans, dp[i][N-1] + seg_sum(K[i], K[N-1]));\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\n\nint N,M,L,v[2001],sum[100001],S[2001],dp[2001][100001];\n\nint func(int n,int p){\n\n  if(dp[n][p]>0)return dp[n][p];\n\n  if(n==N){\n    int b=max(S[p],S[1]);\n    int a=min(S[p],S[1]);\n    return (sum[b]-sum[a-1])/L;\n  }\n\n  int res=1000000000;\n  for(int i=1;i<=N;i++){\n    int b=max(S[i],S[p]);\n    int a=min(S[i],S[p]);\n    if(v[i]==0){\n      v[i]=1,res=min(res,func(n+1,S[i])+(sum[b]-sum[a-1])/L),v[i]=0;\n    }\n  }\n  return dp[n][p]=res;\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++){\n    cin >> S[i];\n  }\n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  v[1]=1;\n  cout << func(1,S[1]) << endl;;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nclass Bit\n{\n\tint n;\n\tvector<long long> data;\npublic:\n\tBit(int n){\n\t\tthis->n = n;\n\t\tdata.assign(n+1, 0);\n\t}\n\tvoid add(int k, long long x){\n\t\t++ k;\n\t\twhile(k <= n){\n\t\t\tdata[k] += x;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\tlong long sum(int k){\n\t\t++ k;\n\t\tlong long ret = 0;\n\t\twhile(k > 0){\n\t\t\tret += data[k];\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long sum(int a, int b){\n\t\treturn sum(b) - sum(a-1);\n\t}\n};\n\nint main()\n{\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<int> k(n);\n\tfor(int i=0; i<n; ++i){\n\t\tcin >> k[i];\n\t\t-- k[i];\n\t}\n\tsort(k.begin(), k.end());\n\n\tBit s(m);\n\tfor(int i=0; i<m; ++i){\n\t\tint a;\n\t\tcin >> a;\n\t\ts.add(i, a);\n\t}\n\n\tvector<long long> dp(1);\n\tdp[0] = s.sum(k[0], k[1]) / l;\n\tfor(int i=2; i<n; ++i){\n\t\tvector<long long> nextDp(i, LLONG_MAX);\n\t\tfor(int j=0; j<i-1; ++j){\n\t\t\tnextDp[i-1] = min(nextDp[i-1], dp[j] + s.sum(k[j], k[i]) / l);\n\t\t\tnextDp[j] = min(nextDp[j], dp[j] + s.sum(k[i-1], k[i]) / l);\n\t\t}\n\t\tdp.swap(nextDp);\n\t}\n\n\tlong long ret = LLONG_MAX;\n\tfor(int i=0; i<n-1; ++i)\n\t\tret = min(ret, dp[i] + s.sum(k[i], k[n-1]) / l);\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2000;\nconst lli M = 1e5;\nconst lli INF = 1LL << 40;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n-2;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\tdp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define INF 50000000000LL\nusing namespace std;\nint s[2000];\nlong long r[100001];\nlong long dp[2][2000];//直前に使わなかった方がiでその一つ前がjのときの最小値\nlong long min(long long a,long long b){return a<b?a:b;}\nint main(){\n\tint n,m,k;\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&s[i]);\n\tsort(s,s+n);\n\tr[0]=0;\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d\",&r[i]);\n\t\tr[i]+=r[i-1];\n\t}\n\tfor(j=0;j<n;j++)dp[1][j]=INF;\n\tdp[1][0]=0;\n\tfor(i=1;i<n-1;i++){\n\t\tfor(j=0;j<n;j++)dp[(i+1)%2][j]=INF;\n\t\tfor(j=0;j<i;j++){\n\t\t\tdp[(i+1)%2][j]=min(dp[(i+1)%2][j],dp[i%2][j]+(r[s[i]]-r[s[i-1]-1])/k);\n\t\t\tdp[(i+1)%2][i-1]=min(dp[(i+1)%2][i-1],dp[i%2][j]+(r[s[i]]-r[s[j]-1])/k);\n\t\t}\n\t}\n\tlong long ans=INF;\n\tfor(i=0;i<n;i++){\n\t\tlong long res=dp[(n-1)%2][i]+(r[s[n-1]]-r[s[i]-1])/k+(r[s[n-1]]-r[s[n-2]-1])/k;\n\t\tans=min(ans,res);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\n\nint m,dp[1999][1999],c[2000][2000];\n\n#define BIT_MAX_N 100000 \n\nlong long bit[BIT_MAX_N+1];\n\nvoid update(int k,int a){\n\twhile(k<=m){\n\t\tbit[k]+=a;\n\t\tk=(k|(k-1))+1;\n\t}\n}\n\nlong long s(int k){\n\tlong long r=0;\n\twhile(k>0){\n\t\tr+=bit[k];\n\t\tk=k&(k-1);\n\t}\n\treturn r;\n}\n\nint main(){\n\tint n,l,k[2000],a=0,ind=1;\n\tlong long b=0;\n\tcin>>n>>m>>l;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>k[i];\n\t}\n\tsort(k,k+n);\n\tfor(int j=1;j<=m;++j){\n\t\tint S;\n\t\tcin>>S;\n\t\twhile(ind<n-1&&j==k[ind]){\n\t\t\tb+=S;\n\t\t\t++ind;\n\t\t}\n\t\tupdate(j,S);\n\t}\n\tb+=2*(s(k[n-1])-s(k[0]-1));\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tc[i][j]=(s(k[j])-s(k[i]-1))%l;\n\t\t}\n\t}\n\tdp[0][1]=c[0][1];\n\tfor(int j=2;j<n-1;++j){\n\t\tfor(int i=0;i<j-1;++i){\n\t\t\tdp[i][j]=dp[i][j-1]+c[j-1][j];\n\t\t}\n\t\tdp[j-1][j]=0;\n\t\tfor(int k=0;k<j-1;++k){\n\t\t\tdp[j-1][j]=max(dp[j-1][j],dp[k][j-1]+c[k][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<n-2;++i){\n\t\ta=max(a,dp[i][n-2]+c[i][n-1]);\n\t}\n\ta+=c[n-2][n-1];\n\tcout<<(b-a)/l<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,l;\nvi in,dp;\nll mm[2010][2010];\nint f(int a,int b){\n\tif(mm[a][b]+1)return mm[a][b];\n\tif(b==n-1)return mm[a][b]=(dp[in[n-1]]-dp[in[a]-1])/l;\n\treturn mm[a][b]=min(f(a,b+1)+(dp[in[b+1]]-dp[in[b]-1])/l,f(b,b+1)+(dp[in[b+1]]-dp[in[a]-1])/l);\n}\nint main(){\n\tcin>>n>>m>>l;\n\trep(i,2010)rep(j,2010)mm[i][j]=-1;\n\tin=vi(n);\n\tdp=vi(m+1);\n\trep(i,n)cin>>in[i];\n\trep(i,m)cin>>dp[i+1];\n\trep(i,m)dp[i+1]+=dp[i];\n\tsort(all(in));\n\tcout<<f(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<numeric>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX (1<<20)\nint N,M,L;\nint k[2001];\nint s[100001];\nint wa[2003][2003];\nint rw[100001];\nbool f[2001];\n\n\nmain(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++) scanf(\"%d\",&k[i]);\n  for(int i=0;i<M;i++) scanf(\"%d\",&s[i]);\n  sort(k,k+N);\n\n  rw[0]=s[0];\n  for(int i=1;i<M;i++)\n    rw[i]=rw[i-1]+s[i];\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j) continue;\n      int ni=min(k[i],k[j])-1;\n      int nj=max(k[i],k[j])-1;\n      int sa=rw[ni-1];\n      if(ni-1<0) sa=0;\n      wa[k[i]][k[j]]=(rw[nj]-sa)/L;\n      //     printf(\"%d %d : %d\\n\",k[i],k[j],wa[k[i]][k[j]]);\n    }\n  }\n\n  int res=0;\n  for(int i=0;i<N;i++){\n    res+=wa[k[i]][k[(i+1)%N]];\n  }\n  printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    ll N, M, L;\n    cin >> N >> M >> L;\n    vi K(N);\n    REP(i, N) {\n        cin >> K[i];\n        --K[i];\n    }\n    sort(all(K));\n    // debug(K);\n\n    vll S(M+1);\n    REP(i, M) {\n        cin >> S[i+1];\n        S[i+1] += S[i];\n    }\n    // debug(S);\n\n    vvll dp(N, vll(N, LINF));\n    dp[0][0] = 0;\n    REP(i, N-1) {\n        REP(j, N-1) {\n            if (dp[i][j] == INF) continue;\n            int m = max(i, j);\n            chmin(dp[m+1][j], dp[i][j] + (S[K[m+1]+1] - S[K[i]]) / L);\n            chmin(dp[i][m+1], dp[i][j] + (S[K[m+1]+1] - S[K[j]]) / L);\n        }\n        // REP(k, N) {\n        //     debug(dp[k]);\n        // }\n        // cerr << endl;\n    }\n\n    REP(i, N-1) {\n        if (chmin(dp[N-1][N-1], dp[i][N-1] + (S[K[N-1]+1] - S[K[i]]) / L)) {\n            // debug(i);\n            // debug(dp[N-1][N-1]);\n        }\n    }\n    // REP(j, N) {\n    //     chmin(dp[N][N], dp[N][j] + (S[K[j]+1] - (j ? S[K[j-1]] : 0)) / L);\n    // }\n    // REP(i, N) {\n    //     debug(dp[i]);\n    // }\n    // cerr << endl;\n\n\n    cout << dp[N-1][N-1] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll INF = LLONG_MAX/3;\n\nint n,m,l;\nvector<ll> k,s;\n\nll cost(int a, int b){\n    return (s[k[b]]-s[k[a]-1])/l;\n}\n\nconst int N = 2002;\nll dp[N][N];\nll dfs(int x, int y){\n    if(dp[x][y]>=0) return dp[x][y];\n\n    int nx = max(x,y)+1;\n    if(nx == n){\n        return cost(min(x,y), max(x,y));\n    }\n\n    ll ret = min(dfs(nx,y)+cost(x,nx), dfs(x,nx)+cost(y,nx));\n    return dp[x][y] = ret;\n}\n\nint main(){\n    cin >>n >>m >>l;\n\n    k = vector<int>(n);\n    s = vector<int>(m+1);\n    rep(i,n) cin >>k[i];\n    sort(all(k));\n\n    rep(i,m) cin >>s[i+1];\n    for(int i=1; i<=m; ++i) s[i] += s[i-1];\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nll l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tif (dp[left][right] >= 0) return dp[left][right];\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ll INF = LLONG_MAX;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nll l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tif (dp[left][right] < INF) return dp[left][right];\n\tint t = max(left, right);\n\tll res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n - 1]] - sum[k[left] - 1]) / l + (sum[k[n - 1]] - sum[k[right] - 1]) / l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t + 1]] - sum[k[left] - 1]) / l, solve(left, t + 1) + (sum[k[t + 1]] - sum[k[right] - 1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tREP(i, 2222)REP(j, 2222) dp[i][j] = INF;\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m + 1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> s_acc(m + 1);\n    repeat (i, m) s_acc[i + 1] = s_acc[i] + s[i];\n    auto penalty = [&](int a, int b) { if (a > b) swap(a, b); return (s_acc[k[b] + 1] - s_acc[k[a]]) / l; };\n    auto dp = vectors(n, n, inf);\n    dp[1][0] = penalty(0, 1);\n    repeat (a, n - 1) {\n        repeat (b, a) {\n            setmin(dp[a + 1][a], dp[a][b] + penalty(b, a + 1));\n            setmin(dp[a + 1][b], dp[a][b] + penalty(a, a + 1));\n        }\n    }\n    ll result = inf;\n    repeat (c, n - 1) {\n        setmin(result, dp[n - 1][c] + penalty(n - 1, c));\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M,L;\nint K[2001];\nint S[100001];\npair<int,int> Onpu[2001];\n\nll dp[2001][2001];\nll sums[100001];\n\nll dfs(int a,int b){\n    if(a==N-1||b==N-1){\n        if(a<b)swap(a,b);\n        return (sums[K[a]+1]-sums[K[b]])/L;\n    }\n    else if(dp[a][b]!=-1)return dp[a][b];\n    int nxtIdx=max(a,b)+1;\n    ll tmp=(sums[K[nxtIdx]+1]-sums[K[a]])/L;\n    ll res=dfs(nxtIdx,b)+tmp;\n    res=min(res,dfs(a,nxtIdx)+(sums[K[nxtIdx]+1]-sums[K[b]])/L);\n    return dp[a][b]=res;\n}\nint main(){\n    cin>>N>>M>>L;\n    for(int i=0;i<N;i++){\n        cin>>K[i];\n        K[i]--;\n    }\n    for(int i=0;i<M;i++){\n        cin>>S[i];\n        sums[i+1]=sums[i]+S[i];\n    }\n    for(int i=0;i<N;i++){\n        Onpu[i].first=S[K[i]];\n        Onpu[i].second=K[i];\n    }\n    sort(Onpu,Onpu+N);\n    for(int i=0;i<N;i++)K[i]=Onpu[i].second;\n    memset(dp,-1,sizeof(dp));\n    ll res=dfs(0,0);\n    cout<<res<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\nstruct _Writer\n{\n\tbool f;\n\t_Writer() : f(false) { }\n\ttemplate <class T> _Writer operator ,(T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; }\n};\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\n\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<long>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\t//dp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\t//dp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\t//minCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\tWRITE(dp[0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N, M, L;\nint K[2048];\nint SSum[100001];\nint memo[2048][2048];\n\nint pls(int r, int l)\n{\n\treturn ((SSum[r] - SSum[l]) / L);\n}\n\nint saveSayaka(int l, int r)\n{\n\tint next = max(l, r) + 1;\n\t\n\tif (memo[l][r] >= 0){\n\t\treturn (memo[l][r]);\n\t}\n\t\n\tif (next == N - 1){\n\t\treturn (pls(K[next], K[l] - 1) + pls(K[next], K[r] - 1));\n\t}\n\t\n\tint left = saveSayaka(next, r) + pls(K[next], K[l] - 1);\n\tint right = saveSayaka(l, next) + pls(K[next], K[r] - 1);\n\t\n\treturn (memo[l][r] = min(left, right));\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &N, &M, &L);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &K[i]);\n\t}\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tSSum[i + 1] = SSum[i] + s;\n\t}\n\t\n\tsort(K, K + N);\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tprintf(\"%d\\n\", saveSayaka(0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAX = 2525;\n\nint N, M, L;\nll memo[MAX][MAX];\nvector<ll> K, sum;\n\nll calc(int l, int r)\n{\n    return (sum[K[r] + 1] - sum[K[l]]) / L;\n}\n\nll solve(int l, int r)\n{    \n    ll& res = memo[l][r];\n    if (res != -1) return res;\n\n    int n = max(l, r) + 1;\n    if (n == N - 1) {\n        return calc(l, n) + calc(r, n);\n    }\n    res = min(solve(n, r) + calc(l, n),\n              solve(l, n) + calc(r, n));    \n    return res;\n}\n\nint main()\n{    \n    cin >> N >> M >> L;\n    K.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i]; K[i]--;\n    }\n    sort(K.begin(), K.end());\n    \n    vector<int> S(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n    }\n    \n    sum.resize(M + 1);\n    for (int i = 0; i < M; i++) {\n        sum[i + 1] = sum[i] + S[i];\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint N,M,L,K[2001],sum[100001],dp[2001][2001];\n\nint func(int l,int r){\n\n  if(dp[l][r]>-1)return dp[l][r];\n\n  int n=max(l,r)+1;\n  if(n==N)return (sum[K[n]]-sum[K[l]-1])/L+(sum[K[n]]-sum[K[r]-1])/L;\n\n  int lf=func(n,r)+(sum[K[n]]-sum[K[l]-1])/L;\n  int rt=func(l,n)+(sum[K[n]]-sum[K[r]-1])/L;\n\n  return dp[l][r]=min(lf,rt);\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++)cin >> K[i];\n  \n  sort(K+1,K+N+1);\n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  memset(dp,-1,sizeof(dp));\n\n  cout << func(1,1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL N, M, L;\nLL naive(VI s, vector<LL>& acc){\n  LL res = 1e15;\n  do{\n\tLL sum = 0;\n\tREP(i,N){\n\t  int mx = max(s[i], s[(i+1)%N]);\n\t  int mn = min(s[i], s[(i+1)%N]);\n\t  sum += (acc[mx+1] - acc[mn]) / L;\n\t}\n\tres = min(res, sum);\n  }while(next_permutation(ALL(s)));\n  return res;\n}\n\nLL naive2(VI s, vector<LL>& acc){\n  LL res = 1e15;\n  REP(b,1<<N){\n\tLL sum = 0;\n\tint p = s[0];\n\tFOR(i,1,N-1)\n\t  if((b>>i&1) == 0){\n\t\tsum += (acc[s[i]+1] - acc[p])/L;\n\t\tp = s[i];\n\t  }\n\tsum += (acc[s.back()+1] - acc[p])/L;\n\tp = s.back();\n\tfor(int i=N-2;i>0;--i){\n\t  if((b>>i&1) == 1){\n\t\tsum += (acc[p+1] - acc[s[i]])/L;\n\t\tp = s[i];\n\t  }\n\t}\n\tsum += (acc[p+1] - acc[s[0]])/L;\n\tres = min(res, sum);\n  }\n\n  return res;\n}\n\nLL cost(vector<LL>& acc, int s, int t){\n  return (acc[t+1] - acc[s]) / L;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> M >> L;\n  VI ks(N);\n  REP(i,N){\n\tcin >> ks[i]; --ks[i];\n  }\n  vector<LL> s(M), acc(M+1);\n  REP(i,M){\n\tcin >> s[i];\n\tacc[i+1] = acc[i] + s[i];\n  }\n  SORT(ks);\n  //cout << naive2(ks, acc) << endl;\n\n  LL ans = 0;\n  REP(i,N-1) ans += cost(acc, ks[i], ks[i+1]);\n  ans += cost(acc, ks[0], ks.back());\n\n  int crt = 0, nxt = 1;\n  map<PII,LL> memo[2];\n  memo[crt][MP(ks[0],ks[0])] = cost(acc,ks[0],ks[1]) * 2;\n  FOR(i,2,N){\n\tmemo[nxt].clear();\n\tfor(auto& p: memo[crt]){\n\t  PII prv = p.FF;\n\t  LL t1 = p.SS - cost(acc,prv.FF,ks[i-1])\n\t\t+ cost(acc,prv.FF,ks[i]) + cost(acc,ks[i-1],ks[i]);\n\t  LL t2 = p.SS - cost(acc,prv.SS,ks[i-1])\n\t\t+cost(acc,ks[i-1],ks[i]) + cost(acc,prv.SS,ks[i]);\n\n\t  prv = MP(p.FF.FF, ks[i-1]);\n\t  if(!memo[nxt].count(prv)) memo[nxt][prv] = t1;\n\t  else memo[nxt][prv] = min(memo[nxt][prv], t1);\n\t  prv = MP(ks[i-1], p.FF.SS);\n\t  if(!memo[nxt].count(prv)) memo[nxt][prv] = t2;\n\t  else memo[nxt][prv] = min(memo[nxt][prv], t2);\n\t}\n\tswap(crt, nxt);\n  }\n  for(auto& p: memo[crt]) ans = min(ans, p.SS);\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint64 N, M, L, K[2000], S[100000], dp[2000][2000];\n\nint64 Range(int a, int b) {\n  if(b < a) swap(a, b);\n  return(S[b] - S[a - 1]);\n}\n\nint64 rec(int idx, int left, int right)\n{\n  if(idx == N) return(Range(K[left], K[right]) / L);\n  if(~dp[left][right]) return(dp[left][right]);\n  int64 A = rec(idx + 1, idx, right) + Range(K[idx], K[left]) / L;\n  int64 B = rec(idx + 1, left, idx) + Range(K[idx], K[right]) / L;\n  return(dp[left][right] = min(A, B));\n}\n\nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint consume(vector<int> &S, int L, int l, int r) {\n    int ret = 0;\n    for (int i=l-1; i<=r-1; ++i) {\n        ret += S[i];\n    }\n    return ret / L;\n}\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n\n    vector<int> K(N);\n    for (int i=0; i<N; ++i) cin >> K[i];\n\n    vector<int> S(M);\n    for (int i=0; i<M; ++i) cin >> S[i];\n\n    sort(K.begin(), K.end());\n\n    int ans = 0;\n    int n = K.size();\n    for (int i=0; i<n; ++i) {\n        if (i == n - 1) {\n            ans += consume(S, L, K[0], K[n-1]);\n        } else {\n            ans += consume(S, L, K[i], K[i+1]);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(a) a.begin(),a.end()\n\n#define int long long\n\nconst int INF = 1e15;\n\nint n, m, l;\nint sm[100001];\nint cost(int a, int b) {\n\tif (a > b)swap(a, b);\n\treturn (sm[b + 1] - sm[a]) / l;\n}\n\nint dp[2001][2001];\nsigned main() {\n\tcin >> n >> m >> l;\n\tvector<int> k(n), s(m);\n\trep(i, n) {\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\tsort(all(k));\n\trep(i, n)rep(j, n) {\n\t\tdp[i][j] = -1;\n\t}\n\n\trep(i, m) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tsm[i] = sm[i - 1] + s[i - 1];\n\t}\n\tfunction<int(int, int)> solve = [&](int a, int b) {\n\t\tif (dp[a][b] != -1)return dp[a][b];\n\t\tint next = max(a, b) + 1;\n\t\tif (next == n) {\n\t\t\treturn cost(k[max(a, b)], k[min(a, b)]);\n\t\t}\n\t\tint t0 = solve(next, b) + cost(k[next], k[a]);\n\t\tint t1 = solve(a, next) + cost(k[next], k[b]);\n\t\treturn dp[a][b] = min(t0, t1);\n\t};\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nint64_t F[100001];\nint N,M;\nint64_t L;\n\nint64_t f(int a, int b){\n    return (F[b+1]-F[a])/L;\n}\n\nint main(){\n    cin>>N>>M>>L;\n    vector<int64_t> K(N),S(M);\n    for(auto &k:K)cin>>k;\n    for(auto &s:S)cin>>s;\n    for(int i=0;i<M;i++){\n        F[i+1]=F[i]+S[i];//(a,b)????????????=(F[b+1]-F[a])/L\n    }\n    sort(K.begin(), K.end());\n    for(auto &k:K)k--;\n    int64_t DP[2][N];\n    fill(DP[0],DP[2],100000000);\n    DP[0][0]=0;\n    DP[1][0]=f(K[0],K[1]);\n    for(int i=1;i<N;i++){\n        for(int j=0;j<i-1;j++){\n            DP[i&1][j]=DP[i&1^1][j]+f(K[i-1],K[i]);\n        }\n        for(int k=0;k<i-1;k++){\n            DP[i&1][i-1]=min(DP[i&1][i-1],DP[i&1^1][k]+f(K[k],K[i]));\n        }\n    }\n    int64_t ans = 100000000;\n    for(int i=0;i<N-1;i++){\n        ans=min(ans,DP[N&1^1][i]+f(K[i],K[N-1]));\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\nconst ll MOD=1e9+7;\n\n//last*other -> minCost\nll dp[2123][2123];\nconst ll INF=2e15;\nvector<ll> a,sum;\nint n,m,l;\nll cost(int L,int r){\n  return (sum[a[r]+1]-sum[a[L]])/l;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin>>n>>m>>l;\n  a.resize(n); sum.resize(m+1);\n  rep(i,n){\n    cin>>a[i]; --a[i];\n  }\n  sort(all(a));\n  rep(i,m){\n    cin>>sum[i+1];\n    sum[i+1]+=sum[i];\n  }\n  //cout<<a<<sum;\n  fill(dp[0],dp[0]+2123*2123,INF);\n  dp[1][0]=cost(0,1);\n  for(int i=2;i<n;++i){\n    rep(j,i-1){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+cost(i-1,i));\n      dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+cost(j,i));\n    }\n  }\n  ll re=INF;\n  rep(i,n-1){\n    re=min(re,dp[n-1][i]+cost(i,n-1));\n  }\n  cout<<re<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  10000000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[100100];\nll v[2010];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tvector<ll> k(n),s(m);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\trep(i,m){\n\t\tcin >> s[i];\n\t}\n\tsort(k.begin(),k.end());\n\tdst[0] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i] = dst[i-1] + s[i-1];\n\t}\n\tv[1] = (dst[k[1]+1]-dst[k[0]])/l;\n\tfor (int i=2;i<n;i++){\n\t\tv[i] = v[i-1] + (dst[k[i]+1]-dst[k[i-1]])/l;\n\t}\n\t\n\tdp[n-1] = (dst[k[n-1]+1]-dst[k[n-2]])/l;\n\tfor(int i=n-2;i>0;i--){\n\t\tdp[i] = inf;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(j==i+1){\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+dp[j]);\n\t\t\t}else{\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+v[j]-v[i]+dp[j]);\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i]])/l+(dst[k[i+1]+1]-dst[k[i-1]])/l+v[j-1]-v[i+1]+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = inf;\n\tfor(int i=1;i<n;i++){\n\t\tmi = min(mi,dp[i]+(dst[k[i]+1]-dst[k[0]])/l+v[i-1]);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\n#include<map>\n#include<set>\nusing namespace std;\n#define int long long\nvector<int> SS;\nint L;\nint sum(int a, int b) {\n\tint res = SS[b];\n\tif (a > 0)res -= SS[a - 1];\n\treturn (res / L);\n}\nsigned main() {\n\n\tint N, M;\n\tcin >> N >> M >> L;\n\tvector<int> S(M);\n\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tmp[a]++;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> S[i];\n\t}\n\tSS = S;\n\tfor (int i = 1; i < M; i++) {\n\t\tSS[i] += SS[i - 1];\n\t}\n\tN = mp.size();\n\tvector<int> A(N);\n\tvector<int> C(N);\n\tint t = 0;\n\tfor (auto m : mp) {\n\t\tA[t] = m.first;\n\t\tC[t] = m.second;\n\t\tt++;\n\t}\n\n\tint INF = (int)1 << 60;\n\tif (N == 1) {\n\t\tcout << sum(A[0],A[0]) * C[0] << endl;\n\t}\n\telse {\n\t\tint x = C[N - 1];\n\t\tC[N - 1] = 2;\n\t\tint res = 0;\n\t\tvector<vector<int> > dp(N, vector<int>(N, INF));\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tif (C[i] == 1) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + sum(A[i - 1], A[i]));\n\t\t\t\t\tdp[i][i - 1] = min(dp[i][i - 1], dp[i - 1][j] + sum(A[j], A[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tdp[i][i] = min(dp[i][i], dp[i - 1][j] + sum(A[j], A[i]) + sum(A[i - 1], A[i]));\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + sum(A[i - 1], A[i]) + sum(A[i], A[i]));\n\t\t\t\t\tdp[i][i - 1] = min(dp[i][i - 1], dp[i - 1][j] + sum(A[j], A[i]) + sum(A[i], A[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cerr << dp[N - 1][N - 1] << endl;\n\t\tres += dp[N - 1][N - 1];\n\t\tres += (x - 1) * sum(A[N - 1], A[N - 1]);\n\t\tres += (C[0] - 1) * sum(A[0], A[0]);\n\t\tfor (int i = 1; i < N - 1; i++) {\n\t\t\tif (C[i] > 2) {\n\t\t\t\tres += (C[i] - 2) * sum(A[i], A[i]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, l;\n  cin >> n >> m >> l;\n  VI k(n), s(m);\n  REP(i, n) cin >> k[i], k[i]--;\n  REP(i, m) {\n    cin >> s[i];\n    // cout << i << endl;\n  }\n\n  // cout << n << \" \" << m << endl;\n\n  FOR(i, 1, m) {\n    s[i] += s[i-1];\n  }\n\n  auto sum = [&](int from, int to) {\n    return s[to] - (from >= 1 ? s[from-1] : 0);\n  };\n\n  sort(ALL(k));\n  int all = 0;\n  FOR(i, 1, n) {\n    int a = k[i-1], b = k[i];\n    if(a > b) swap(a, b);\n    all += sum(a, b)/l;\n  }\n\n  int ans = LLINF;\n  REP(i, n) FOR(j, i+1, n) {\n    // k[i], sort列, k[j] みたいな列\n    int ret = all;\n    if(i != 0) {\n      // マイナス s[k[i-1]] ~ s[k[i]], s[k[i]] ~ s[k[i+1]]\n      // プラス s[k[0]] ~ s[k[i]], s[k[i-1]] ~ s[k[i+1]]\n      ret -= sum(k[i-1], k[i])/l; ret -= sum(k[i], k[i+1])/l;\n      ret += sum(k[0], k[i])/l; ret += sum(k[i-1], k[i+1])/l;\n    }\n    if(j != n-1) {\n      ret -= sum(k[j-1], k[j])/l; ret -= sum(k[j], k[j+1])/l;\n      ret += sum(k[j], k[n-1])/l; ret += sum(k[j-1], k[j+1])/l;\n    }\n    ret += sum(k[i], k[j])/l;\n    chmin(ans, ret);\n    // cout << i << \" \" << j << \" \" << ret << endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst ll INF = 1LL<<60;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nll dp[2001][2001];\nint K[2000];\nint S[100000];\nll SUM[100001];\nint l;\n\nll calc(int a,int b) {\n  if (a>b) swap(a,b);\n  //cout << a << \" \" << b << \" \"  << SUM[b]-SUM[a-1] << endl;\n  return (SUM[b]-SUM[a-1])/l;\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m >> l;\n  REP(i,n) cin >> K[i];\n  REP(i,m) cin >> S[i];\n\n  SUM[0] = 0;\n  REP(i,m) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K+n);\n  ll ans = INF;\n  REP(i, n+1)REP(j,n+1)dp[i][j] = INF;\n  dp[0][0] = 0;\n  REP(now, n) {                 // max(i,j) = now\n    REP(j, now+1) {\n      if (now == n-1) ans = min(ans, dp[n-1][j] + calc(K[j], K[n-1]));\n      else {\n        dp[now][now+1] = min(dp[now][now+1], dp[now][j] + calc(K[j], K[now+1]));\n        dp[now+1][j] = min(dp[now+1][j], dp[now][j] + calc(K[now], K[now+1]));\n      }\n    }\n    REP(i,now+1) {\n      if (now == n-1) ans = min(ans, dp[i][n-1] + calc(K[i],K[n-1]));\n      else {\n        dp[now+1][now] = min(dp[now+1][now], dp[i][now] + calc(K[i], K[now+1]));\n        dp[i][now+1] = min(dp[i][now+1], dp[i][now] + calc(K[now], K[now+1]));\n      }\n    }\n  }\n  // REP(i, n+1) {\n  //   REP(j, n+1) {\n  //     cout << dp[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x3fffffffffff\n\ntypedef long long int LLI;\n\nint N;\nint M;\nLLI L;\nLLI K[114514];\nLLI S[114514];\nLLI ssum[114514];\nLLI dp[2010][2010];\n\nint sum(int a, int b) {\n  if (a > b) swap(a, b);\n  return (ssum[b] - ssum[a-1])/L;\n}\n\nint main() {\n  scanf(\"%d%d%lld\", &N, &M, &L);\n  for (int i=1; i<=N; i++) {\n    scanf(\"%lld\", &K[i]);\n  }\n  sort(K+1, K+N+1);\n  \n  for (int i=1; i<=M; i++) {\n    scanf(\"%lld\", &S[i]);\n    ssum[i] = ssum[i-1]+S[i];\n  }\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; j<=N; j++) {\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[1][0] = 0;\n  for (int i=2; i<=N; i++) {\n    for (int j=0; j<i-1; j++) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]+sum(K[i-1], K[i]));\n      if (j != 0) {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[j], K[i]));\n      } else {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[1], K[i]));\n      }\n    }\n  }\n\n  LLI ans = INF;\n  for (int j=0; j<=N; j++) {\n    if (j != 0) {\n      dp[N][j] += sum(K[j], K[N]);\n    } else {\n      dp[N][j] += sum(K[1], K[N]);\n    }\n    ans = min(ans, dp[N][j]);\n  }\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e18;\n\nint main(){\n    int n,m;\n    lli l;\n    cin >> n >> m >> l;\n    vector<int> k(n);\n    for(int i=0; i<n; i++){\n        cin >> k[i];\n    }\n    sort(k.begin(), k.end());\n    vector<lli> s(m+1);\n    for(int i=0; i<m; i++){\n        cin >> s[i+1];\n        s[i+1] += s[i];\n    }\n\n    vector<vector<lli>> dp(n, vector<lli>(n, inf));\n    dp[0][1] = (s[k[1]]-s[k[0]-1])/l;\n    for(int i=1; i<n-1; i++){ //last\n        for(int j=0; j<i; j++){ //opp\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j] +(s[k[i+1]]-s[k[i]-1])/l);\n            dp[i][i+1] = min(dp[i][i+1], dp[i][j] +(s[k[i+1]]-s[k[j]-1])/l);\n            dp[i+1][i] = min(dp[i+1][i], dp[j][i] +(s[k[i+1]]-s[k[j]-1])/l);\n            dp[j][i+1] = min(dp[j][i+1], dp[j][i] +(s[k[i+1]]-s[k[i]-1])/l);\n            /*\n            dp[i][j] -> dp[i+1][j], dp[i][i+1];\n            dp[j][i] -> dp[i+1][i], dp[j][i+1];\n            */\n        }\n    }\n    lli ans = inf;\n    for(int i=0; i<n-1; i++){\n        ans = min(ans, dp[i][n-1] +(s[k[n-1]]-s[k[i]-1])/l);\n        ans = min(ans, dp[n-1][i] +(s[k[n-1]]-s[k[i]-1])/l);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x3fffffffffff\n\ntypedef long long int LLI;\n\nint N;\nint M;\nLLI L;\nLLI K[114514];\nLLI S[114514];\nLLI ssum[114514];\nLLI dp[2010][2010];\n\nint sum(int a, int b) {\n  if (a > b) swap(a, b);\n  return (ssum[b] - ssum[a-1])/L;\n}\n\nint main() {\n  scanf(\"%d%d%lld\", &N, &M, &L);\n  for (int i=1; i<=N; i++) {\n    scanf(\"%lld\", &K[i]);\n  }\n  sort(K+1, K+N+1);\n  \n  for (int i=1; i<=M; i++) {\n    scanf(\"%lld\", &S[i]);\n    ssum[i] = ssum[i-1]+S[i];\n  }\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; j<=N; j++) {\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[1][0] = 0;\n  for (int i=2; i<=N; i++) {\n    for (int j=0; j<i-1; j++) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]+sum(K[i-1], K[i]));\n      if (j != 0) {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[j], K[i]));\n      } else {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[1], K[i]));\n      }\n    }\n  }\n\n  LLI ans = INF;\n  for (int j=0; j<=N; j++) {\n    if (j != 0) {\n      dp[N][j] += sum(K[j], K[N]);\n    } else {\n      dp[N][j] += sum(K[1], K[N]);\n    }\n    ans = min(ans, dp[N][j]);\n  }\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m,l;\n\tcin>>n>>m>>l;\n\tvl k(n), s(m+1,0);\n\tcin>>k; rep(i,m)cin>>s[i+1];\n\tpartial_sum(all(s),s.begin());\n\n\tsort(rall(k));\n\tvvl dp(n, vl(n, LINF));\n\tdp[0][1]=dp[1][0]=(s[k[0]]-s[k[1]-1])/l;\n\trange(len,3,n+1){\n\t\trep(i,len-2){\n\t\t\tll j=(i+1==len-1 ? max(i-1,0) : len-2);\n\t\t\tchmin(dp[i][len-1], dp[i][j] + (s[k[j]] - s[k[len-1]-1]) / l );\n\t\t\tchmin(dp[len-1][j], dp[i][j] + (s[k[i]] - s[k[len-1]-1]) / l );\n\t\t\tchmin(dp[j][len-1], dp[j][i] + (s[k[i]] - s[k[len-1]-1]) / l );\n\t\t\tchmin(dp[len-1][i], dp[j][i] + (s[k[j]] - s[k[len-1]-1]) / l );\n\t\t}\n\t}\n\tll ans=LINF;\n\trep(i,n)range(j,i+1,n)if(i==n-1 or j==n-1){\n\t\tchmin(ans, dp[i][j]+(s[k[i]] - s[k[j]-1])/l);\n\t}\n\tputa(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<int>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvector<int> ring = { K[0], K[1] };\n\t\tFOR(x, 2, N)\n\t\t{\n\t\t\tint minj = 0;\n\t\t\tint val = INF;\n\t\t\tREP(i, ring.size())\n\t\t\t{\n\t\t\t\tint j = (i + 1) % ring.size();\n\t\t\t\tint d = deltaS(ring[i], K[x]) + deltaS(K[x], ring[j]) - deltaS(ring[i], ring[j]);\n\t\t\t\tif (d < val){ minj = j; val = d; }\n\t\t\t}\n\t\t\tring.insert(ring.begin() + minj, K[x]);\n\t\t}\n\n\t\tint cost = 0;\n\t\tREP(i, ring.size())\n\t\t{\n\t\t\tint j = (i + 1) % ring.size();\n\t\t\tcost += deltaS(ring[i], ring[j]);\n\t\t}\n\t\twrite(cost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    bool solve() {\n        int N, M, L; cin >> N >> M >> L;\n        vector<ll> K(N), S(M); cin >> K >> S;\n        vector<ll> sum(M + 1);\n        rep(i, M) sum[i + 1] = sum[i] + S[i];        \n        sort(all(K));\n        // debug(sum);\n        // debug(K);\n        ll ans = 0;\n        rep(i, N) {\n            int a = K[i], b = K[(i + 1) % N];\n            if(a > b) swap(a, b);\n            ans += (sum[b + 1 - 1] - sum[a - 1]) / L;\n            // set_min(ans, (sum[b + 1 - 1] - sum[a - 1]));\n        }\n        cout << ans << endl;\n\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<int>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\twrite(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint N, M, L, K[2000], S[100000];\nint64 dp[2000][2000];\n\nint Range(int a, int b) {\n  if(b < a) swap(a, b);\n  return(S[b] - S[a - 1]);\n}\n\nint64 rec(int idx, int left, int right)\n{\n  if(idx == N) return(Range(K[left], K[right]) / L);\n  if(~dp[left][right]) return(dp[left][right]);\n  int64 A = rec(idx + 1, idx, right) + Range(K[idx], K[left]) / L;\n  int64 B = rec(idx + 1, left, idx) + Range(K[idx], K[right]) / L;\n  return(dp[left][right] = min(A, B));\n}\n\nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint K[2000],S[100000],N,M,L;\nll sum[100000],memo[2000][2000];\n\nll getCost(int i,int j){\n  ll value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n  ll cost = sum[K[j]] - value;\n  return floor((double)cost/(double)L);\n}\n\nll dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return getCost(p1,N-1) + getCost(p2,N-1);\n  if( memo[p1][p2] != -1 ) return memo[p1][p2];\n  return memo[p1][p2] = min(getCost(p1,v)+dfs(v,p2),\n                            getCost(p2,v)+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + S[i];\n  rep(i,N) rep(j,N) memo[i][j] = -1;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long sum[100010];\nlong long K[2010];\n\nint N,M,L;\nlong long f(int a,int b){\n\treturn (sum[max(a,b)] - sum[min(a,b)-1]) / L;\n}\n\nlong long dp[2010][2010];\nlong long dfs(int x,int y){\n\tint z = max(x,y);\n\tif( z == N-2 ){\n\t\treturn f(K[N-1],K[x]) + f(K[N-1],K[y]);\n\t}\n\tif( dp[x][y] != -1 ) return dp[x][y];\n\tlong long ans = 1e18;\n\tans = min(dfs(z+1,y)+f(K[x],K[z+1]),dfs(x,z+1)+f(K[y],K[z+1]));\n\treturn dp[x][y] = ans;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tcin >> N >> M >> L;\n\tfor(int i = 0 ; i < N ; i++) cin >> K[i];\n\tfor(int i = 1 ; i <= M ; i++){\n\t\tcin >> sum[i];\n\t\tsum[i] += sum[i-1];\n\t}\n\tsort(K,K+N);\n\tcout << dfs(0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\n\nint n,m,L,a[2222],b[200000],dp[2002][2002];\n\nint cost(int r,int l){ return (b[a[l]]-b[a[r]-1])/L; }\n\nint dfs(int l,int r,int dep){\n  if(dp[l][r]!=-1)return dp[l][r];\n  if(dep==n)return dp[l][r]=max( cost(l,dep-1) , cost(r,dep-1) );\n  if(dp[l][r]!=-1)return dp[l][r];\n  return dp[l][r] = min( dfs(dep,r,dep+1)+cost(l,dep) , dfs(l,dep,dep+1)+cost(r,dep) );\n}\n\nsigned main(){\n  memset(dp,-1,sizeof(dp));\n  cin>>n>>m>>L;\n  r(i,n)cin>>a[i];\n  r(i,m)cin>>b[i+1],b[i+1]+=b[i];\n  sort(a,a+n);\n  cout<<dfs(0,0,1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nll N, M, L;\nll K[100002], S[100002];\nll dp[2002][2002];\nll sum[100002];\n\nll getCost(int a, int b){\n  a = K[a];\n  b = K[b];\n  if(a > b) swap(a, b);\n  ll tmp = sum[b] - (a - 1 < 0 ? 0 : sum[a - 1]);\n  tmp /= L;\n  return tmp;\n}\n\nll update(ll a, ll b){\n  if(a == -1) return b;\n  return min(a, b);\n}\n\nvoid solve(){\n  sum[0] = S[0];\n  for(int i = 1; i < M; i++){\n    sum[i] = sum[i - 1] + S[i];\n  }\n\n  sort(K, K + N);\n  memset(dp, -1, sizeof(dp));\n  dp[0][0] = 0;\n\n  for(int i = 0; i < N - 1; i++){\n    for(int j = 0; j < N - 1; j++){\n      if(dp[i][j] == -1) continue;\n\n      int next = max(i + 1, j + 1);\n      dp[next][j] = update(dp[next][j], dp[i][j] + getCost(i, next));\n      dp[i][next] = update(dp[i][next], dp[i][j] + getCost(j, next));\n    }\n  }\n\n  ll ans = -1;\n\n  for(int i = 0; i < N; i++){\n    if(dp[N - 1][i] != -1){\n      ans = update(ans, dp[N - 1][i] + getCost(N - 1, i));\n    }\n    if(dp[i][N - 1] != -1){\n      ans = update(ans, dp[i][N - 1] + getCost(N - 1, i));\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> L){\n    for(int i = 0; i < N; i++){\n      cin >> K[i];\n      K[i]--;\n    }\n    for(int i = 0; i < M; i++){\n      cin >> S[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<long>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\tdp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\tminCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\twrite(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[2020][2020];\nsigned main(){\n  Int n,m,l;\n  cin>>n>>m>>l;\n  vector<Int> k(n),s(m);\n  for(Int i=0;i<n;i++) cin>>k[i];\n  for(Int i=0;i<m;i++) cin>>s[i];\n  vector<Int> a(m+1,0);\n  for(Int i=0;i<m;i++) a[i+1]=a[i]+s[i];\n  memset(dp,-1,sizeof(dp));\n  sort(k.begin(),k.end());\n  auto calc=[&](Int x,Int y){\n    if(k[x]>k[y]) swap(x,y);\n    return (a[k[y]]-a[k[x]-1])/l;\n  };\n  Int inf=1LL<<55LL;\n  for(Int i=0;i<2020;i++)\n    for(Int j=0;j<2020;j++)\n      dp[i][j]=inf;\n  \n  dp[1][0]=calc(1,0);\n  //cout<<dp[1][0]<<endl;\n  for(Int i=2;i<n;i++){\n    for(Int j=0;j<n;j++){\n      dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+calc(i,j));\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+calc(i,i-1));\n    }\n  }\n  Int ans=inf;\n  for(Int i=0;i<n;i++) ans=min(ans,dp[n-1][i]+calc(n-1,i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 2001;\nconst int MAX_M = 100001;\nint N, M, L, K[MAX_N], S[MAX_M];\n\n// sum[i] := s[i] + s[i+1] + ... + s[m-1];\nint sum[MAX_M] = {0};\n\n// 反発力 (s[a] + s[a+1] + ... + s[b]) / L を返す.\nint power(int a, int b){\n\tif( b < a ) swap(a,b);\n\treturn (sum[a] - sum[b+1]) / L;\n}\n\nint solve(){\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tsum[0] += S[i];\n\t}\n\tfor(int i=1 ; i < M ; i++ ){\n\t\tsum[i] = sum[i-1] - S[i-1];\n\t}\n\tsum[M] = 0;\n\t// sort(K,K+N);\n\tint res = 1e+8;\n\tfor(int k=0 ; k < 1000 ; k++ ){\n\t\trandom_shuffle(K,K+N);\n\t\tint s = 0;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\ts += power( K[i] , K[(i+1)%N] );\n\t\t}\n\t\tres = min( res , s );\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> N >> M >> L;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tcin >> S[i];\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1LL << 40;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(i+1, j));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + calc(n-1, i));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define INF (1LL<<60)\ntypedef long long Int;\ninline void update(Int &a, Int b) { if(a>b) a=b; }\n\nint N, M, L, K[2048], S[200000];\nInt sum[200000], dp[2048][2048];\n\ninline Int f(int l, int r) { return (sum[K[r]+1]-sum[K[l]])/L; }\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &L);\n    rep(i, N) scanf(\"%d\", K+i);\n    rep(i, N) K[i]--;\n    rep(i, M) scanf(\"%d\", S+i);\n    rep(i, M) sum[i+1] = sum[i] + S[i];\n    sort(K, K+N);\n    rep(i, 2048) rep(j, 2048) dp[i][j] = INF;\n    dp[0][1] = f(0, 1);\n    for(int k=1; k<N-1; k++) rep(i, k) {\n        update(dp[i][k+1], dp[i][k]+f(k, k+1));\n        update(dp[k][k+1], dp[i][k]+f(i, k+1));\n    }\n    Int ans = INF;\n    rep(i, N-1) update(ans, dp[i][N-1]+f(i, N-1));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nint K[2000],S[100000],N,M,cost[2000][2000],sum[100000],memo[2000][2000],L;\n\nint dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return cost[p1][N-1] + cost[p2][N-1];\n  if( memo[p1][p2] != IINF ) return memo[p1][p2];\n  return memo[p1][p2] = min(cost[p1][v]+dfs(v,p2),\n                            cost[p2][v]+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + S[i];\n  rep(i,N){\n    REP(j,i,N){\n      int value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n      cost[i][j] = sum[K[j]] - value;\n    }\n  }\n  rep(i,N) REP(j,i,N) cost[i][j] = floor((double)cost[i][j] / (double)L);\n  rep(i,N) rep(j,N) memo[i][j] = IINF;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\nconst ll MOD=1e9+7;\n\n//last*other -> minCost\nll dp[2123][2123];\nconst ll INF=2e15;\nvector<ll> a,sum;\nint n,m,l;\nll cost(int L,int r){\n  return (sum[a[r]+1]-sum[a[L]])/l;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin>>n>>m>>l;\n  a.resize(n); sum.resize(m+1);\n  rep(i,n){\n    cin>>a[i]; --a[i];\n  }\n  sort(all(a));\n  rep(i,m){\n    cin>>sum[i+1];\n    sum[i+1]+=sum[i];\n  }\n  //cout<<a<<sum;\n  fill(dp[0],dp[0]+2123*2123,INF);\n  dp[1][0]=cost(0,1);\n  for(int i=2;i<n;++i){\n    rep(j,i-1){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+cost(i-1,i));\n      dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+cost(j,i));\n    }\n  }\n  ll re=INF;\n  rep(i,n-1){\n    re=min(re,dp[n-1][i]+cost(i,n-1));\n  }\n  cout<<re<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint dp[2001][2001];\nint K[2000];\nint S[100000];\nint SUM[100001];\nint l;\n\nint calc(int a,int b) {\n  if (a>b) swap(a,b);\n  //cout << a << \" \" << b << \" \"  << SUM[b]-SUM[a-1] << endl;\n  return (SUM[b]-SUM[a-1])/l;\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m >> l;\n  REP(i,n) cin >> K[i];\n  REP(i,m) cin >> S[i];\n\n  SUM[0] = 0;\n  REP(i,m) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K+n);\n  int ans = INF;\n  REP(i, n+1)REP(j,n+1)dp[i][j] = INF;\n  dp[0][0] = 0;\n  REP(now, n) {                 // max(i,j) = now\n    REP(j, now+1) {\n      if (now == n-1) ans = min(ans, dp[n-1][j] + calc(K[j], K[n-1]));\n      else {\n        dp[now][now+1] = min(dp[now][now+1], dp[now][j] + calc(K[j], K[now+1]));\n        dp[now+1][j] = min(dp[now+1][j], dp[now][j] + calc(K[now], K[now+1]));\n      }\n    }\n    REP(i,now+1) {\n      if (now == n-1) ans = min(ans, dp[i][n-1] + calc(K[i],K[n-1]));\n      else {\n        dp[now+1][now] = min(dp[now+1][now], dp[i][now] + calc(K[i], K[now+1]));\n        dp[i][now+1] = min(dp[i][now+1], dp[i][now] + calc(K[now], K[now+1]));\n      }\n    }\n  }\n  // REP(i, n+1) {\n  //   REP(j, n+1) {\n  //     cout << dp[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x3fffffff\n\nint N;\nint M;\nint L;\nint K[114514];\nint S[114514];\nint ssum[114514];\nint dp[2010][2010];\n\nint sum(int a, int b) {\n  if (a > b) swap(a, b);\n  return (ssum[b] - ssum[a-1])/L;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &N, &M, &L);\n  for (int i=1; i<=N; i++) {\n    scanf(\"%d\", &K[i]);\n  }\n  sort(K+1, K+N+1);\n  \n  for (int i=1; i<=M; i++) {\n    scanf(\"%d\", &S[i]);\n    ssum[i] = ssum[i-1]+S[i];\n  }\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; j<=N; j++) {\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[1][0] = 0;\n  for (int i=2; i<=N; i++) {\n    for (int j=0; j<i-1; j++) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]+sum(K[i-1], K[i]));\n      if (j != 0) {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[j], K[i]));\n      } else {\n        dp[i][i-1] = min(dp[i][i-1], dp[i-1][j]+sum(K[1], K[i]));\n      }\n    }\n  }\n\n  int ans = INF;\n  for (int j=0; j<=N; j++) {\n    if (j != 0) {\n      dp[N][j] += sum(K[j], K[N]);\n    } else {\n      dp[N][j] += sum(K[1], K[N]);\n    }\n    ans = min(ans, dp[N][j]);\n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\nstruct _Writer\n{\n\tbool f;\n\t_Writer() : f(false) { }\n\ttemplate <class T> _Writer operator ,(T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; }\n};\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\n\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<long>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\t//dp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\t//dp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\t//minCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\tWRITE(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[i][next]\n          = min(dp[i][next],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\n#define INF 1e+15\nusing namespace std;\n\nsigned main(){\n\tint n,m,l,x[2000],s[100001] = {},dp[2010][2010];\n\tcin >> n >> m >> l;\n\tfor(int i = 0;i < n;i++) cin >> x[i];\n\tfor(int i = 1;i <= m;i++) {\n\t\tcin >> s[i];\n\t\ts[i] += s[i - 1];\n\t}\n\tsort(x,x + n);\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n;j++) dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tint next = max(i,j) + 1;\n\t\t\tif(next == n){\n\t\t\t\tif(i == n - 1) dp[n - 1][n - 1] = min(dp[n - 1][n - 1],dp[i][j] + (s[x[n - 1]] - s[x[j] - 1]) / l);\n\t\t\t\telse dp[n - 1][n - 1] = min(dp[n - 1][n - 1],dp[i][j] + (s[x[n - 1]] - s[x[i] - 1]) / l);\n\t\t\t}else {\n\t\t\t\tdp[i][next] = min(dp[i][next],dp[i][j] + (s[x[next]] - s[x[j] - 1]) / l);\n\t\t\t\tdp[next][j] = min(dp[next][j],dp[i][j] + (s[x[next]] - s[x[i] - 1]) / l);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n - 1][n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 171019.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<int>K(N),S(M);\n\tfor (int i = 0; i < N; i++)cin >> K[i];\n\tfor (int i = 0; i < M; i++)cin >> S[i];\n\tsort(K.begin(), K.end());\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint cK = K[i];\n\t\tint nK = K[(i + 1) % N];\n\t\tif (nK < cK)swap(cK, nK);\n\t\tlong long sum = 0;\n\t\tfor (int j = cK - 1; j < nK; j++) {\n\t\t\tsum += S[j];\n\t\t}\n\n\t\tans += floor(1.*sum/L);\n\t}\n\n\tcout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\nint main(){\n\tint n,m,L; scanf(\"%d%d%d\",&n,&m,&L);\n\tint a[2002];\n\trep(i,n) scanf(\"%d\",a+i), a[i]--;\n\tstatic ll v[100001];\n\trep(i,m) scanf(\"%lld\",v+i+1), v[i+1]+=v[i];\n\n\ta[n]=*min_element(a,a+n); n++;\n\ta[n]=*max_element(a,a+n); n++;\n\tsort(a,a+n);\n\n\tstatic ll dp[2002][2002];\n\trep(i,n) rep(j,n) dp[i][j]=INF;\n\tdp[0][1]=0;\n\trep(i,n-1) rep(j,n-1) if(i!=j) {\n\t\tint next=max(i,j)+1;\n\t\tdp[next][j]=min(dp[next][j],dp[i][j]+llabs(v[a[next]+1]-v[a[i]])/L);\n\t\tdp[i][next]=min(dp[i][next],dp[i][j]+llabs(v[a[next]+1]-v[a[j]])/L);\n\t}\n\n\tprintf(\"%lld\\n\",dp[n-2][n-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\n\nint K[120000];\nint S[120000];\nll sum[120000];\n\nll SS(int a,int b){\n  return sum[b+1]-sum[a];\n}\n\nbool vis[2100][2100];\n\nint main() {\n\n  ll N, M, L;\n  cin >> N >> M >> L;\n  rep(i, N) cin >> K[i];\n  rep(i, N) --K[i];\n  rep(i, M) cin >> S[i];\n\n  rep(i,M) sum[i+1] = sum[i] + S[i];\n  sort(K,K+N);\n  priority_queue<pair<ll,PI> > q;\n  if(N==1){\n    cout << 0 << endl;\n    return 0;\n  }else if(N==2){\n    cout << SS(K[0],K[1])/L*2 << endl;\n    return 0;\n  }\n  \n  q.push(mp(-SS(K[0],K[1])/L,mp(0,1)));\n  ll ans = 1LL<<50LL;\n  while(!q.empty()){\n    ll cc=-q.top().F;\n    PI cv=q.top().S;\n    q.pop();\n    if(vis[cv.F][cv.S]) continue;\n    vis[cv.F][cv.S] = true;\n    //cout << cc << ' ' << cv.F << ' ' << cv.S << endl;\n    int nidx = max(cv.F,cv.S) + 1;\n    if(nidx==N-1){\n      //cout << cv.F << ' ' << K[N-1] << ' ' << SS(K[cv.F, K[N-1])/ L << endl;\n      //cout << cv.S << ' ' << K[N-1] << ' ' << SS(cv.S, K[N-1])/ L << endl;      \n      ans = min(ans,cc + SS(K[cv.F], K[N-1])/L + SS(K[cv.S], K[N-1])/L);\n      //cout << ans << endl;\n      continue;\n    }\n    \n    q.push(mp(-cc-SS(K[cv.F],K[nidx])/L,mp(cv.S,nidx)));\n    q.push(mp(-cc-SS(K[cv.S],K[nidx])/L,mp(cv.F,nidx)));    \n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint K[2000],S[100000],N,M,L;\nll cost[2000][2000],sum[100000],memo[2000][2000];\n\nll dfs(int p1,int p2){\n  int v = 1 + max(p1,p2);\n  if( v == N-1 ) return cost[p1][N-1] + cost[p2][N-1];\n  if( memo[p1][p2] != -1 ) return memo[p1][p2];\n  return memo[p1][p2] = min(cost[p1][v]+dfs(v,p2),\n                            cost[p2][v]+dfs(p1,v));\n}\n\nint main(){\n\n  cin >> N >> M >> L;\n  rep(i,N) { cin >> K[i]; --K[i]; }\n  rep(i,M) cin >> S[i];\n  sort(K,K+N);\n  sum[0] = S[0];\n  REP(i,1,M) sum[i] = sum[i-1] + S[i];\n  rep(i,N){\n    REP(j,i,N){\n      ll value = ((K[i]-1>=0)?sum[K[i]-1]:0LL);\n      cost[i][j] = sum[K[j]] - value;\n    }\n  }\n  rep(i,N) REP(j,i,N) cost[i][j] = floor((double)cost[i][j] / (double)L);\n  rep(i,N) rep(j,N) memo[i][j] = -1;\n  cout << dfs(0,0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll inf = 1e9;\n\nint main() {\n  int N, M, L;\n  cin >> N >> M >> L;\n  vector<ll> K(N), S(M);\n  for(int i = 0; i < N; ++i) {\n    cin >> K[i];\n    K[i]--;\n  }\n  vector<ll> sum(M + 1);\n  for(int i = 0; i < M; ++i) {\n    cin >> S[i];\n    sum[i + 1] = sum[i] + S[i];\n  }\n  sort(begin(K), end(K));\n  vector<vector<ll>> dp(N + 1, vector<ll>(N + 1, inf));\n  dp[1][1] = 0;\n  for(int i = 1; i < N; ++i) {\n    for(int p1 = 1; p1 <= i; ++p1) {\n      int p2 = i;\n      if(dp[p1][p2] == inf) continue;\n      int c1 = (sum[K[i] + 1] - sum[K[p1 - 1]]) / L; // put left\n      assert(c1 >= 0);\n      dp[i + 1][p2] = min(dp[i + 1][p2], dp[p1][p2] + c1);\n      int c2 = (sum[K[i] + 1] - sum[K[p2 - 1]]) / L;\n      assert(c2 >= 0);\n      dp[p1][i + 1] = min(dp[p1][i + 1], dp[p1][p2] + c2);\n    }\n    for(int p2 = 1; p2 <= i; ++p2) {\n      int p1 = i;\n      if(dp[p1][p2] == inf) continue;\n      int c1 = (sum[K[i] + 1] - sum[K[p1 - 1]]) / L;\n      assert(c1 >= 0);\n      dp[i + 1][p2] = min(dp[i + 1][p2], dp[p1][p2] + c1);\n      int c2 = (sum[K[i] + 1] - sum[K[p2 - 1]]) / L;\n      assert(c2 >= 0);\n      dp[p1][i + 1] = min(dp[p1][i + 1], dp[p1][p2] + c2);\n    }\n  }\n\n  ll ans = inf;\n  for(int i = 1; i < N; ++i) {\n    if(dp[N][i] == inf) continue;\n    ans = min(ans, dp[N][i] + (sum[K[N - 1] + 1] - sum[K[i - 1]]) / L);\n    assert(sum[K[N - 1] + 1] - sum[K[i - 1]] >= 0);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n\nint64 N, M, L, K[2000], S[100000];\nint64 dp[2000][2000];\nint64 get_Sum(int a, int b){\n  if(a > b) swap( a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a - 1];\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return get_Sum( K[right], K[left]);\n  if(~dp[right][left]) return dp[right][left];\n  int64 ret = INF;\n  ret = min( ret, rec( idx + 1, idx, left) + get_Sum( K[right], K[idx]));\n  ret = min( ret, rec( idx + 1, right, idx) + get_Sum( K[left], K[idx]));\n  return dp[right][left] = ret;\n}\n\nint main(){\n  fill_n( *dp, 2000 * 2000, -1);\n  scanf(\"%lld %lld %lld\", &N, &M, &L);\n  for(int i = 0; i < N; i++){\n    scanf(\"%lld\", &K[i]); --K[i];\n  }\n  for(int i = 0; i < M; i++){\n    scanf(\"%lld\", &S[i]);\n    if(i) S[i] += S[i - 1];\n  }\n  sort( K, K + N);\n  printf(\"%lld\\n\", (rec(1,0,0) - L + 1) / L);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<int> k(n);\n    for(int i=0;i<n;i++){\n        cin>>k[i];\n        k[i]--;\n    }\n    sort(k.begin(),k.end());\n    vector<ll> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    vector<ll> ssum(m+1);\n    ssum[0]=0;\n    for(int i=0;i<m;i++){\n        ssum[i+1]=ssum[i]+s[i];\n    }\n    \n    auto cost=[&](int i,int j){\n        return (ssum[k[j]+1]-ssum[k[i]])/l;\n    };\n\n    const ll INF=1e12;\n    vector<vector<ll>> dp(n,vector<ll>(n,INF));\n    dp[0][0]=0;\n    for(int k=0;k<n;k++){\n        for(int r=0;r<=k;r++){\n            int i=k;\n            int j=r;\n            if(j+1<n){\n                dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n            i=r;\n            j=k;\n            if(j+1<n){\n                dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n        }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<n;i++){\n        ans=min(ans,dp[i][n-1]+cost(i,n-1));\n        ans=min(ans,dp[n-1][i]+cost(i,n-1));\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint N,M,L,K[2001],sum[100001],dp[2001][2001];\n\nint func(int l,int r){\n\n  if(dp[l][r]>-1)return dp[l][r];\n\n  int n=max(l,r)+1;\n  if(n==N)return (sum[K[n]]-sum[K[l]-1])/L+(sum[K[n]]-sum[K[r]-1])/L;\n\n  int lf=func(n,r)+(sum[K[n]]-sum[K[l]-1])/L;\n  int rt=func(l,n)+(sum[K[n]]-sum[K[r]-1])/L;\n\n  return dp[l][r]=min(lf,rt);\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++)cin >> K[i];\n  \n  sort(K+1,K+N+1);\n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  memset(dp,-1,sizeof(dp));\n\n  cout << func(1,1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<int> k(n);\n    for(int i=0;i<n;i++){\n        cin>>k[i];\n        k[i]--;\n    }\n    sort(k.begin(),k.end());\n    vector<ll> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    vector<ll> ssum(m+1);\n    ssum[0]=0;\n    for(int i=0;i<m;i++){\n        ssum[i+1]=ssum[i]+s[i];\n    }\n    \n    auto cost=[&](int i,int j){\n        return (ssum[k[j]+1]-ssum[k[i]])/l;\n    };\n\n    const ll INF=1e12;\n    vector<vector<ll>> dp(n,vector<ll>(n,INF));\n    dp[0][0]=0;\n    for(int k=0;k<n;k++){\n        for(int r=0;r<=k;r++){\n            int i=k;\n            int j=r;\n            if(j+1<n && i<j+1){\n                dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n && j<i+1){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n            i=r;\n            j=k;\n            if(j+1<n && i<j+1){\n                dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n && j<i+1){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n        }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<n;i++){\n        ans=min(ans,dp[i][n-1]+cost(i,n-1));\n        ans=min(ans,dp[n-1][i]+cost(i,n-1));\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[2000],b[100001],n,m,l;\nlong long c[2000][2000];\nlong long fi(int p,int q){\n  if(p==n-1)\n    return (b[a[p]+1]-b[a[p-1]])/l+(b[a[p]+1]-b[a[q]])/l;\n  if(c[p][q]>=0)\n    return c[p][q];\n  return c[p][q]=min(fi(p+1,q)+(b[a[p]+1]-b[a[p-1]])/l,fi(p+1,p-1)+(b[a[p]+1]-b[a[q]])/l);\n}\nint main(){\n  int i;\n  scanf(\"%d%d%d\",&n,&m,&l);\n  for(i=0;i<n;++i){\n    scanf(\"%d\",a+i);\n    --a[i];\n  }\n  for(i=0;i<m;++i){\n    int p;\n    scanf(\"%d\",&p);\n    b[i+1]=b[i]+p;\n  }\n  sort(a,a+n);\n  memset(c,-1,sizeof(c));\n  printf(\"%lld\\n\",fi(1,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  10000000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[2010][2010];\nll v[2010];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tvector<ll> k(n),s(m);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\trep(i,m){\n\t\tcin >> s[i];\n\t}\n\tsort(k.begin(),k.end());\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=i;j<m;j++){\n\t\t\tif(i==j)dst[i][j]=s[i];\n\t\t\telse dst[i][j] = dst[i][j-1]+s[j];\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=i;j<m;j++){\n\t\t\tdst[i][j]=dst[i][j]/l;\n\t\t}\n\t}\n\tv[1] = dst[k[0]][k[1]];\n\tfor (int i=2;i<n;i++){\n\t\tv[i] = v[i-1] + dst[k[i-1]][k[i]];\n\t}\n\tdp[n-1] = dst[k[n-2]][k[n-1]];\n\tfor(int i=n-2;i>0;i--){\n\t\tdp[i] = inf;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(j==i+1){\n\t\t\t\tdp[i] = min(dp[i],dst[k[i-1]][k[j]]+dp[j]);\n\t\t\t}else{\n\t\t\t\tdp[i] = min(dp[i],dst[k[i-1]][k[j]]+v[j]-v[i]+dp[j]);\n\t\t\t\tdp[i] = min(dp[i],dst[k[i]][k[j]]+dst[k[i-1]][k[i+1]]+v[j-1]-v[i+1]+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = inf;\n\tfor(int i=1;i<n;i++){\n\t\tmi = min(mi,dp[i]+dst[k[0]][k[i]]+v[i-1]);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[2010][2010];\nll v[2010];\nint pre[1000];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tset<int> st;\n\tvector<ll> k(n),s(m+1),t(n),p(m+1);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tst.insert(k[i]);\n\t}\n\trep(i,m){\n\t\tcin >> s[i+1];\n\t}\n\tsort(k.begin(),k.end());\n\tll ans = 0;\n\tvector<ll> q;\n\tq.PB(k[0]);\n\tp[k[0]]++;\n\tint x = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(q[x]==k[i]){\n\t\t\tp[k[i]]++;\n\t\t}else{\n\t\t\tq.PB(k[i]);\n\t\t\tp[k[i]]++;\n\t\t\tx++;\n\t\t}\n\t}\n\tif(m==1){\n\t\tcout << (p[1]*(s[1]/l)) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i][i] = s[i];\n\t}\n\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=i+1;j<=m;j++){\n\t\t\tdst[i][j] = dst[i][j-1] + s[j];\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=i;j<=m;j++){\n\t\t\tdst[i][j] = dst[i][j]/l;\n\t\t}\n\t}\n\tx = 1;\n\tfor(int i=2;i<=m;i++){\n\t\tif(st.count(i)!=0){\n\t\t\tpre[i] = x;\n\t\t\tx = i;\n\t\t}\n\t}\n\n\n\trep(i,m+1){\n\t\tif(p[i]>=2){\n\t\t\tans += (p[i]-1)*((s[i])/l);\n\t\t}\n\t}\n\tx = 1;\n\tfor(int i=2;i<=m;i++){\n\t\tif(st.count(i)==0){\n\t\t\tv[i] = v[i-1];\n\t\t}else{\n\t\t\tv[i] = v[i-1]+dst[x][i];\n\t\t\tx = i;\n\t\t}\n\t}\n\n\tdp[m] = dst[m-1][m];\n\tfor(int i=m-1;i>=2;i--){\n\t\tif(st.count(i)==0)continue;\n\t\tdp[i]=100000000000000;\n\t\tfor(int j=i+2;j<=m;j++){\n\t\t\tif(st.count(j)!=0){\n\t\t\t\tll tmp = 0;\n\t\t\t\ttmp += dst[i][j];\n\t\t\t\ttmp += v[j]-v[i+1];\n\t\t\t\ttmp += dst[pre[i]][i+1];\n\t\t\t\tdp[i] = min(dp[i],dp[j]+tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1;j<=m;j++){\n\t\t\tif(st.count(j)!=0){\n\t\t\t\tll tmp = 0;\n\t\t\t\ttmp += dst[pre[i]][j];\n\t\t\t\ttmp += v[j-1]-v[i];\n\t\t\t\tdp[i] = min(dp[i],dp[j]+tmp);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = 10000000000;\n\tfor(int i=2;i<=n;i++){\n\t\tif(st.count(i)==0)continue;\n\t\tif(st.count(i)!=0){\n\t\t\tll tmp = 0;\n\t\t\ttmp += dst[1][i];\n\t\t\ttmp += v[i-1];\n\t\t\tmi = min(mi,tmp + dp[i]);\n\t\t}\n\t}\n\t/*rep(i,m+1){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n\n\trep(i,m+1){\n\t\tcout << dp[i] << \" \";\n\t}\n\tcout << endl;\n*/\n\n\tcout << ans+mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nint n, m, l;\n\nint a[100010];\nint b[100010];\n\nint sum[100010];\n\nint dp[2010][2][2010];\n\nint main(){\n\n  n = in();\n  m = in();\n  l = in();\n\n  REP( i , n ){\n    a[i] = in();\n  }\n  sort( a , a+n );\n  REP( i , m ){\n    b[i] = in();\n  }\n\n  REP( i , m ){\n    sum[i+1] = sum[i] + b[i];\n  }\n\n  REP( i , 2010 ){\n    REP( j , 2 ){\n      REP( k , 2010 ){\n        dp[i][j][k] = INF;\n      }\n    }\n  }\n  \n  dp[0][0][0] = 0;\n\n  REP( i , n-1 ){\n    int ni = i+1;\n    REP( j , 2 ){\n      REP( k , n+1 ){\n        if( j == 0 ){\n          // left\n          int ad = abs( sum[a[ni]+1] - sum[a[i]] ) / l;\n          chmin( dp[ni][0][k] , dp[i][j][k] + ad );\n\n          // right\n          ad = abs( sum[a[ni]+1] - sum[a[k]] ) / l;\n          chmin( dp[ni][1][i] , dp[i][j][k] + ad );\n        } else if( j == 1 ){\n          // left\n          int ad = abs( sum[a[ni]+1] - sum[a[k]] ) / l;\n          chmin( dp[ni][0][i] , dp[i][j][k] + ad );\n\n          // right\n          ad = abs( sum[a[ni]+1] - sum[a[i]] ) / l;\n          chmin( dp[ni][1][k] , dp[i][j][k] + ad );\n        }\n      }\n    }\n  }\n\n  int ans = INF;\n  REP( j , 2 ){\n    REP( k , n+1 ){\n      int ni = n-1;\n      int ad = abs( sum[a[ni]+1] - sum[a[n-2]] ) / l + abs( sum[a[ni]+1] - sum[a[k]] ) / l;\n      chmin( ans , dp[n-1][j][k] + ad );\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll INF = LLONG_MAX/3;\n\nint n,m,l;\nvector<ll> k,s;\n\nll cost(int a, int b){\n    return (s[k[b]]-s[k[a]-1])/l;\n}\n\nconst int N = 2002;\nll dp[N][N];\nll dfs(int x, int y){\n    if(dp[x][y]>=0) return dp[x][y];\n\n    int nx = max(x,y)+1;\n    if(nx == n){\n        return cost(min(x,y), max(x,y));\n    }\n\n    ll ret = min(dfs(nx,y)+cost(x,nx), dfs(x,nx)+cost(y,nx));\n    return dp[x][y] = ret;\n}\n\nint main(){\n    cin >>n >>m >>l;\n\n    k = vector<ll>(n);\n    s = vector<ll>(m+1);\n    rep(i,n) cin >>k[i];\n    sort(all(k));\n\n    rep(i,m) cin >>s[i+1];\n    for(int i=1; i<=m; ++i) s[i] += s[i-1];\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define INF 2000000000\n#define int long long int\nint const MOD = 1000000007;\n\nint N, M, L;\nint K[2010], S[100010], acc[100010];\nint dp[2010][2010];\n\nint calc(int l, int r) {\n    return (acc[r+1] - acc[l]) / L;\n}\n\nint solve(int a, int b) {\n    if(a > b) swap(a, b); // a < b\n    if(dp[a][b] != -1) return dp[a][b];\n    if(b == N-1) return dp[a][b] = calc(K[a], K[N-1]);\n    int nxnote = b+1;\n    int vl = solve(a, nxnote) + calc(K[b], K[nxnote]);\n    int vr = solve(nxnote, b) + calc(K[a], K[nxnote]);\n    return dp[a][b] = min(vl, vr);\n}\n\nsigned main() {\n    memset(dp, -1, sizeof(dp));\n    cin >> N >> M >> L;\n    rep(i,0,N) cin >> K[i], K[i]--;\n    sort(K, K+N);\n    rep(i,0,M) {\n        cin >> S[i];\n        acc[i+1] = acc[i] + S[i];\n    }\n    cout << solve(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\t//for \"geometry.cpp\"\n#include<iomanip>\t//for \"cout<<fixed<<setprecision(a number)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\n\nint m,dp[1999][1999],c[2000][2000];\n\n#define BIT_MAX_N 100000 \n\nlong long bit[BIT_MAX_N+1];\n\nvoid update(int k,int a){\n\twhile(k<=m){\n\t\tbit[k]+=a;\n\t\tk=(k|(k-1))+1;\n\t}\n}\n\nlong long s(int k){\n\tlong long r=0;\n\twhile(k>0){\n\t\tr+=bit[k];\n\t\tk=k&(k-1);\n\t}\n\treturn r;\n}\n\nint main(){\n\tint n,l,k[2000],a=0,ind=1;\n\tlong long b=0;\n\tcin>>n>>m>>l;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>k[i];\n\t}\n\tsort(k,k+n);\n\tfor(int j=1;j<=m;++j){\n\t\tint S;\n\t\tcin>>S;\n\t\tif(ind<n-1&&j==k[ind]){\n\t\t\tb+=S;\n\t\t\t++ind;\n\t\t}\n\t\tupdate(j,S);\n\t}\n\tb+=2*(s(k[n-1])-s(k[0]-1));\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tc[i][j]=(s(k[j])-s(k[i]-1))%l;\n\t\t}\n\t}\n\tdp[0][1]=c[0][1];\n\tfor(int j=2;j<n-1;++j){\n\t\tfor(int i=0;i<j-1;++i){\n\t\t\tdp[i][j]=dp[i][j-1]+c[j-1][j];\n\t\t}\n\t\tdp[j-1][j]=0;\n\t\tfor(int k=0;k<j-1;++k){\n\t\t\tdp[j-1][j]=max(dp[j-1][j],dp[k][j-1]+c[k][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<n-2;++i){\n\t\ta=max(a,dp[i][n-2]+c[i][n-1]);\n\t}\n\ta+=c[n-2][n-1];\n\tcout<<(b-a)/l<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAX = 1011;\n\nint N, M, L;\nll memo[MAX][MAX];\nvector<ll> K, sum;\n\nll calc(int l, int r)\n{\n    return (sum[K[r] + 1] - sum[K[l]]) / L;\n}\n\nll solve(int l, int r)\n{    \n    ll& res = memo[l][r];\n    if (res != -1) return res;\n\n    int n = max(l, r) + 1;\n    if (n == N - 1) {\n        return calc(l, n) + calc(r, n);\n    }\n    res = min(solve(n, r) + calc(l, n),\n              solve(l, n) + calc(r, n));    \n    return res;\n}\n\nint main()\n{    \n    cin >> N >> M >> L;\n    K.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i]; K[i]--;\n    }\n    sort(K.begin(), K.end());\n    \n    vector<int> S(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n    }\n    \n    sum.resize(M + 1);\n    for (int i = 0; i < M; i++) {\n        sum[i + 1] = sum[i] + S[i];\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 10000000000000000LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, m, k[2000];\n\tll l, s[100001], ss[100001];\n\tcin>>n>>m>>l;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>k[i];\n\t}\n\tss[0]=0;\n\tfor(int i=1; i<=m; i++){\n\t\tcin>>s[i];\n\t\tss[i]=ss[i-1]+s[i];\n\t}\n\tsort(k, k+n);\n\tif(n==3){\n\t\tcout<<(ss[k[1]]-ss[k[0]-1])/l+(ss[k[2]]-ss[k[1]-1])/l+(ss[k[2]]-ss[k[0]-1])/l<<endl;\n\t\treturn 0;\n\t}\n\tll dp[2000][2000];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][1]=0;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=1; j<n; j++){\n\t\t\tif(i<j-1){\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[i][j-1]+(ss[k[j]]-ss[k[j-1]-1])/l);\n\t\t\t}\n\t\t\tif(i-1>j){\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[i-1][j]+(ss[k[i]]-ss[k[i-1]-1])/l);\n\t\t\t}\n\t\t\tif(j==i+1){\n\t\t\t\tfor(int t=1; t<i; t++){\n\t\t\t\t\tdp[i][j]=min(dp[i][j], dp[i][t]+(ss[k[j]]-ss[k[t]-1])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==j+1){\n\t\t\t\tfor(int t=0; t<j; t++){\n\t\t\t\t\tdp[i][j]=min(dp[i][j], dp[t][j]+(ss[k[i]]-ss[k[t]-1])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(ss[k[1]]-ss[k[0]-1])/l+(ss[k[n-1]]-ss[k[n-2]-1])/l+min(dp[n-1][n-2], dp[n-2][n-1]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[2010];\nint S[2010];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n\n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e15;\n\n\nint main(){\n    int n,m;\n    ll l;\n    cin>>n>>m>>l;\n    vector<ll> k(n);\n    for(int i=0;i<n;i++){\n        cin>>k[i];\n        k[i]--;\n    }   \n    sort(k.begin(),k.end());\n    vector<ll> s(m); \n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    vector<ll> sum(m+1);\n    partial_sum(s.begin(),s.end(),sum.begin()+1);\n    \n    auto rev=[&](int a,int b){\n        return (sum[b+1]-sum[a])/l;\n    };\n    vector<vector<ll>> dp(n,vector<ll>(n,INF));\n    dp[0][0]=0;\n    for(int i=0;i+1<n;i++){\n        for(int j=0;j+1<n;j++){\n            int to=max(i,j)+1;\n            dp[to][j]=min(dp[to][j],dp[i][j]+rev(k[i],k[to]));\n            dp[i][to]=min(dp[i][to],dp[i][j]+rev(k[j],k[to]));\n        }\n    }\n    \n    ll res=INF;\n    for(int i=0;i<n;i++){\n        res=min(res,dp[i][n-1]+rev(k[i],k[n-1]));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ntemplate<typename T>\nclass tRMQ {\n  vector<T> data;\n  T unit;\n\npublic:\n  static const long long INF = 100000000000;\n  int n;\n  function<T(const T &, const T &)> f;\n\n  tRMQ(int _, T u, function<T(T, T)> bi) {\n    unit = u;\n    f = bi;\n    n = 1;\n    while (n < _) {\n      n <<= 1;\n    }\n    data.resize(n * 4);\n    for (int i = 0; i < n * 4; i++)\n      data[i] = unit;\n  }\n\n  void update(int index, T val) {\n    int i = index + n - 1;\n    data[i] = val;\n    while (i > 0) {\n      i = (i - 1) / 2;\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n\n  // [a, b)\n  T query(int a, int b, int k, int l, int r) {\n    if (a < 0 || r <= a || b <= l)\n      return unit;\n    if (a <= l && r <= b)\n      return data[k];\n    else\n      return f(query(a, b, k * 2 + 1, l, (l + r) / 2),\n               query(a, b, k * 2 + 2, (r + l) / 2, r));\n  }\n\n  T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\ntRMQ<ll> minrmq(int n) {\n  return tRMQ<ll>(n, 10000000000000000LL, [](ll r, ll l) { return min(l, r); });\n}\n\ntRMQ<ll> maxrmq(int n) {\n  return tRMQ<ll>(n, -10000000000000000LL,\n                  [](ll r, ll l) { return max(l, r); });\n}\n\ntRMQ<ll> sumrmq(int n) {\n  return tRMQ<ll>(n, 0, [](ll l, ll r) { return l + r; });\n}\n\nll dp[2020][2020] = {0};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  ll n, m, l;\n  cin >> n >> m >> l;\n  vector<ll> k(n), s(m);\n  for (int i = 0; i < n; i++) cin >> k[i];\n  for (int i = 0; i < m; i++) cin >> s[i];\n  sort(k.begin(), k.end());\n  auto r = sumrmq(m);\n  for (int i = 0; i < m; i++) r.update(i, s[i]);\n  ll INF = 1LL << 60;\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) dp[i][j] = INF;\n  dp[0][0] = 0;\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = 0; j < n - 1; j++) {\n      int next = max(i, j) + 1;\n      dp[i][next] = min(dp[i][next], dp[i][j] + r.query(k[j] - 1, k[next]) / l);\n      dp[next][j] = min(dp[next][j], dp[i][j] + r.query(k[i] - 1, k[next]) / l);\n    }\n  }\n  ll ans = INF;\n  for (int i = 0; i < n - 1; i++) ans = min(ans, dp[n - 1][i] + r.query(k[i] - 1, k[n - 1]) / l);\n  for (int i = 0; i < n - 1; i++) ans = min(ans, dp[i][n - 1] + r.query(k[i] - 1, k[n - 1]) / l);\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[i][next]\n          = min(dp[i][next],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n      res = min(dp[i][num_of_notes - 1] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> acc(1); partial_sum(whole(s), back_inserter(acc));\n    ll score = 0;\n    repeat (i, n) {\n        int a = k[i];\n        int b = k[(i + 1) % n];\n        if (a > b) swap(a, b);\n        score += (acc[b + 1] - acc[a]) / l;\n    }\n    ll result = score;\n    repeat (i, n - 1) {\n        setmin(result,\n                score\n                - (acc[i + 1] - acc[i]) / l\n                - (acc[n - 1] - acc[1]) / l\n                + (acc[i + 1] - acc[1]) / l\n                + (acc[n - 1] - acc[i]) / l\n                );\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l){\n\t\tvi K(n), S(m);\n\t\tREP(i, n) cin >> K[i], K[i]--;\n\t\tREP(i, m) cin >> S[i];\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tvi sum(m+1);\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vi> dp(n+1, vi(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tchmin(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tchmin(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tcout << dp[n-1][n-2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2312.cc: Magical Girl Sayaka-chan\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 2000;\nconst int MAX_M = 100000;\n\ntypedef long long ll;\nconst ll LINF = 1LL << 62;\n\n/* typedef */\n\n/* global variables */\n\nint ks[MAX_N], ss[MAX_M];\nll sums[MAX_M + 1], dp[MAX_N][MAX_N];\n\n/* subroutines */\n\ninline ll force(int a, int b, int l) {\n  return\n    (a <= b) ? (sums[b] - sums[a - 1]) / l : (sums[a] - sums[b - 1]) / l;\n}\n\n/* main */\n\nint main() {\n  int n, m, l;\n  cin >> n >> m >> l;\n\n  for (int i = 0; i < n; i++) cin >> ks[i];\n  sort(ks, ks + n);\n  \n  for (int i = 0; i < m; i++) {\n    cin >> ss[i];\n    sums[i + 1] = sums[i] + ss[i];\n  }\n\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++) dp[i][j] = LINF;\n  dp[0][0] = 0;\n  \n  for (int i = 0; i < n - 1; i++)\n    for (int j = 0; j < n - 1; j++)\n      if (dp[i][j] < LINF) {\n\tint k = (i > j) ? i + 1 : j + 1;\n\tll dik = dp[i][j] + force(ks[j], ks[k], l);\n\tll dkj = dp[i][j] + force(ks[i], ks[k], l);\n\tif (dp[i][k] > dik) dp[i][k] = dik;\n\tif (dp[k][j] > dkj) dp[k][j] = dkj;\n      }\n\n  ll mind = LINF;\n  for (int i = 0; i < n; i++)\n    if (dp[i][n - 1] < LINF) {\n      ll d = dp[i][n - 1] + force(ks[i], ks[n - 1], l);\n      if (mind > d) mind = d;\n    }\n  printf(\"%lld\\n\", mind);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n\n#define int long long\nll dp[3000][3000];\nll val[200000];\nint n, m, border;\nint calc(int l, int r) {\n    if (l >= r) swap(l, r);\n    return (val[r] - val[l - 1]) / border;\n}\nvoid solve(){\n    cin >> n >> m >> border;\n    vector<int> vertexs;\n    REP(i, n) {\n        int a;\n        cin >> a;\n        vertexs.push_back(a);\n    }\n    vector<int> gogo;\n    REP(i, m) {\n        int a;\n        cin >> a;\n        val[i + 1] = val[i] + a;\n    }\n    sort(ALL(vertexs));\n    REP(i, n + 1) {\n        REP(q, n + 1) {\n            dp[i][q] = 1e18;\n        }\n    }\n    int hoge = 0;\n    for (int q = 1; q < vertexs.size();++q) {\n        hoge += calc(vertexs[q], vertexs[q - 1]);\n        dp[q - 1][q] = calc(vertexs[q], vertexs[0]) + hoge;\n        dp[q][q-1] = dp[q-1][q];\n    }\n    for (int i = 1; i < vertexs.size()-1; ++i) {\n        REP(q, i) {\n            dp[i + 1][i] = min(dp[i + 1][i], dp[q][i] - calc(vertexs[q], vertexs[i]) + calc(vertexs[q], vertexs[i + 1]) + calc(vertexs[i], vertexs[i + 1]));\n            dp[q][i + 1] = min(dp[q][i + 1], dp[q][i] - calc(vertexs[q], vertexs[i]) + calc(vertexs[q], vertexs[i + 1]) + calc(vertexs[i], vertexs[i + 1]));\n            dp[i][i + 1] = min(dp[i][i + 1], dp[i][q] - calc(vertexs[q], vertexs[i]) + calc(vertexs[q], vertexs[i + 1]) + calc(vertexs[i], vertexs[i + 1]));\n            dp[i+1][q] = min(dp[i+1][q], dp[i][q] - calc(vertexs[q], vertexs[i]) + calc(vertexs[q], vertexs[i + 1]) + calc(vertexs[i], vertexs[i + 1]));\n        }\n    }\n    int ans = 1e18;\n    REP(q, vertexs.size()) {\n        ans = min({ ans,dp[vertexs.size() - 1][q],dp[q][vertexs.size() - 1] });\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, M, L;\nll K[2048];\nll SSum[100001];\nll memo[2048][2048];\n\nll pls(int r, int l)\n{\n\treturn ((SSum[r] - SSum[l]) / (ll)L);\n}\n\nll saveSayaka(int l, int r)\n{\n\tint next = max(l, r) + 1;\n\t\n\tif (memo[l][r] >= 0){\n\t\treturn (memo[l][r]);\n\t}\n\t\n\tif (next == N - 1){\n\t\treturn (pls(K[next], K[l] - 1) + pls(K[next], K[r] - 1));\n\t}\n\t\n\tll left = saveSayaka(next, r) + pls(K[next], K[l] - 1);\n\tll right = saveSayaka(l, next) + pls(K[next], K[r] - 1);\n\t\n\treturn (memo[l][r] = min(left, right));\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &N, &M, &L);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &K[i]);\n\t}\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tSSum[i + 1] = SSum[i] + s;\n\t}\n\t\n\tsort(K, K + N);\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tprintf(\"%lld\\n\", saveSayaka(0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[2010];\nint S[2010];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n\n  if(a < 0){\n    cerr << \"a < 0\" << endl;\n    assert(false);\n  }\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n\n  cerr << N << \" \"  << M << \" \" << L << endl;\n  assert(false);\n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n, m, l; cin >> n >> m >> l;\n\tvl k(n); REP(i, n) cin >> k[i];\n\tvl s(m); REP(i, m) cin >> s[i];\n\n\tvl sum(m + 1); sum[0] = 0;\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\n\tsort(ALL(k));\n\tvvl dp(n, vl((n - 1) * 2 + 1, TEN(13)));\n\tdp[0][n - 1] = 0;\n\tll ans = TEN(13);\n\tFOR(i, 1, n) REP(j, (n - 1) * 2 + 1) {\n\t\tll j_zero = j - (n - 1);\n\t\tll times = abs(j_zero);\n\t\tif (times >= i || dp[i - 1][j] == TEN(13)) continue;\n\t\tif (i == n - 1) {\n\t\t\tMINC(\n\t\t\t\tans,\n\t\t\t\tdp[i - 1][j]\n\t\t\t\t+ (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t\t+ (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t);\n\t\t} else {\n\t\t\tMINC(\n\t\t\t\tdp[i][(n - 1) + (j_zero <= 0 ? 1 : -1)],\n\t\t\t\tdp[i - 1][j] + (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t); // ???\n\t\t\tMINC(\n\t\t\t\tdp[i][j + (j_zero <= 0 ? -1 : 1)],\n\t\t\t\tdp[i - 1][j] + (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t); // ??£?¶?\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAX = 2525;\n\nint N, M, L;\nll memo[MAX][MAX];\nvector<ll> K, sum;\n\nll calc(int l, int r)\n{\n    return (sum[K[r] + 1] - sum[K[l]]) / L;\n}\n\nll solve(int l, int r)\n{    \n    ll& res = memo[l][r];\n    if (res != -1) return res;\n\n    int n = max(l, r) + 1;\n    if (n == N - 1) {\n        return calc(l, n) + calc(r, n);\n    }\n    res = min(solve(n, r) + calc(l, n),\n              solve(l, n) + calc(r, n));    \n    return res;\n}\n\nint main()\n{    \n    cin >> N >> M >> L;\n    K.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i]; K[i]--;\n    }\n    sort(K.begin(), K.end());\n    \n    vector<int> S(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n    }\n    \n    sum.resize(M + 1);\n    for (int i = 0; i < M; i++) {\n        sum[i + 1] = sum[i] + S[i];\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 2001;\nconst ll inf = (1LL<<62);\nll dp[N][N];\nll compute(int a,int b,const vector<ll> &sum,const ll l){\n  if (a < b)swap(a,b);\n  return (sum[a]-sum[b-1])/l;\n}\n\n//a > b should be satisfied: a,b is index\nll solve(int n,const ll l,int a,int b,const vector<int> &all,const vector<ll> &sum){\n  //cout << a << \" \" << b << \" \" << n <<\" \" << endl;\n  if (a+1 == n || b+1 == n){\n    ll ret=0;\n    if (b == 0){//circular\n      ret=compute(all[a],all[1],sum,l);\n    }else {\n      ret=compute(all[a],all[b],sum,l);\n    }\n    return ret;\n  }\n  if (a < b)swap(a,b);\n  int now=max(a,b)+1;\n\n  ll &ret=dp[a][b];\n  if (dp[a][b] != -1)return ret;\n  ret=inf;\n  //right//\n  ret=min(ret,compute(all[now],all[a],sum,l)+solve(n,l,now,b,all,sum));\n\n  //left//b->now\n  if (b == 0){\n    ret=min(ret,compute(all[1],all[now],sum,l)+solve(n,l,a,now,all,sum));\n  }else {\n    ret=min(ret,compute(all[now],all[b],sum,l)+solve(n,l,a,now,all,sum));\n  }\n  return ret;\n}\n\n\n\nmain(){\n  int n,m;\n  ll l;\n  while(cin>>n>>m>>l){\n    vector<ll> sum(m+1);\n    vector<int> all(n+1);\n    rep(i,n){\n      cin>>all[i];\n      //all[i]--;\n    }\n    sum[0]=0;\n    rep(i,m){\n      int in;\n      cin>>in;\n      sum[i+1]=in+sum[i];\n    }\n    sort(all.begin(),all.end());\n    rep(i,n+1)rep(j,n+1)dp[i][j]=-1;\n    n++;\n    cout << solve(n,l,1,0,all,sum) << endl;\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nint compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 :sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      for(int j=0;j<=i;j++){\n        int next = i + 1;\n\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(i,num_of_notes - 1),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1LL<<60)\ntypedef long long Int;\ninline void cmin(Int &a, Int b) { if (a > b) a = b; }\n\nint N, M, L, K[2048], S[200000];\nInt sum[200000], dp[2048][2048];\n\ninline Int cost(int a, int b) { return (sum[K[b]+1]-sum[K[a]]) / L; }\n\nint main() {\n    scanf(\"%d%d%d\", &N, &M, &L);\n    rep (i, N) scanf(\"%d\", K+i);\n    rep (i, M) scanf(\"%d\", S+i);\n    rep (i, M) sum[i+1] = sum[i] + S[i];\n    rep (i, 2048) rep (j, 2048) dp[i][j] = INF;\n    rep (i, N) K[i]--;\n    sort(K, K+N);\n    dp[1][0] = cost(0, 1);\n    for (int i = 2; i < N; i++) {\n        rep (j, i) {\n            cmin(dp[i][i-1], dp[i-1][j] + cost(j, i));\n            cmin(dp[i][j], dp[i-1][j] + cost(i-1, i));\n        }\n    }\n    Int ans = INF;\n    rep (i, N) cmin(ans, dp[N-1][i] + cost(i, N-1));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint n, m, l;\nvector<int> k, imos;\nint cost(int i, int j) {\n    return (imos[k[min(j, n)]] - imos[k[max(i, 1)] - 1]) / l;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    k.resize(n + 1);\n    k[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> k[i + 1];\n    }\n    vector<int> s(m);\n    imos.resize(m + 1, 0);\n    for (int i = 0; i < m; ++i) {\n        cin >> s[i];\n        imos[i + 1] = imos[i] + s[i];\n    }\n    sort(k.begin(), k.end());\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, M));\n    vector<int> mi(n + 1, M);\n    dp[0][0] = cost(1, n);\n    for (int i = 1; i < n; ++i) {\n        dp[0][0] += cost(i, i + 1);\n    }\n    mi[0] = dp[0][0];\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i - 1; ++j) {\n            dp[i][1] = min(dp[i][1], mi[j] - cost(i - 1, i) - cost(i, i + 1) + cost(i - 1, i + 1) - cost(j, n) + cost(j, i) + cost(i, n));\n            mi[i] = min(mi[i], dp[i][1]);\n        }\n        for (int j = 2; j <= i; ++j) {\n            dp[i][j] = dp[i - 1][j - 1] - cost(i - j, i) - cost(i, i + 1) + cost(i - j, i + 1) - cost(i - 1, n) + cost(i - 1, i) + cost(i, n);\n            mi[i] = min(mi[i], dp[i][j]);\n        }\n    }\n    int ans = M;\n    for (int i : mi) {\n        ans = min(ans, i);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m,l;\n\tcin>>n>>m>>l;\n\tvl k(n),s(m);\n\trep(i,n)cin>>k[i],k[i]--;\n\trep(i,m)cin>>s[i];\n\t\n\tsort(rall(k));\n\tvl cum(m+1);\n\tvvl dp(n,vl(n,LINF));\n\tll sum=0,it=m-1,left,right;\n\t\n\trep(i,m)sum+=s[i],cum[i+1]=sum;\n\tdp[0][0]=0;\n\tdp[1][0]=dp[0][1]=((cum[k[0]+1]-cum[k[1]])/l)*2;\n\trange(i,1,n-1){\n\t\trep(j,max(1,i)){\n\t\t\tchmin(dp[i+1][j],dp[i][j]-(cum[k[j]+1]-cum[k[i]])/l+(cum[k[i]+1]-cum[k[i+1]])/l+(cum[k[j]+1]-cum[k[i+1]])/l);\n\t\t\tchmin(dp[i][i+1],dp[i][j]-(cum[k[j]+1]-cum[k[i]])/l+(cum[k[i]+1]-cum[k[i+1]])/l+(cum[k[j]+1]-cum[k[i+1]])/l);\n\t\t\tchmin(dp[i+1][i],dp[j][i]-(cum[k[j]+1]-cum[k[i]])/l+(cum[k[i]+1]-cum[k[i+1]])/l+(cum[k[j]+1]-cum[k[i+1]])/l);\n\t\t\tchmin(dp[j][i+1],dp[j][i]-(cum[k[j]+1]-cum[k[i]])/l+(cum[k[i]+1]-cum[k[i+1]])/l+(cum[k[j]+1]-cum[k[i+1]])/l);\n\t\t}\n\t}\n\tll ans=LINF;\n\trep(i,n-1)chmin(ans,dp[n-1][i]),chmin(ans,dp[i][n-1]);\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 2222;\nconst int MAXM = 100100;\nconst ll INF = 1ll<<60;\nint K[MAXN], S[MAXM], sum[MAXM];\n\nll dp[MAXN][MAXN];\nint N, M, L;\n\nll dfs(int lp, int rp) {\n\tll& ret = dp[lp][rp];\n\tif (ret >= 0) return ret;\n\tif (min(lp, rp) == 0) {\n\t\tint maxi = max(lp, rp), mini = min(lp, rp);\n\t\treturn ret = (sum[K[maxi]+1] - sum[K[mini]]) / L;\n\t}\n\tint now = min(lp, rp)-1;\n\tret = (sum[K[lp]+1]-sum[K[now]])/L + dfs(now, rp);\n\tret = min(ret, (sum[K[rp]+1]-sum[K[now]])/L + dfs(lp, now));\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> L;\n    for (int i = 0; i < N; i++) {\n    \tcin >> K[i];\n    \tK[i]--;\n    }\n    sort(K, K+N);\n    for (int i = 0; i < M; i++)\n    \tcin >> S[i];\n    for (int i = 0; i < M; i++) {\n    \tsum[i+1] = sum[i] + S[i];\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << dfs(N-1, N-2) + (sum[K[N-1]+1]-sum[K[N-2]])/L << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m,l;\nll a[2002],b[200002];\nll sum[200002];\nll dp[2002][2002];\n\nll f(int i,int j){\n  if(a[i]>a[j])swap(i,j);\n  return (sum[a[j]+1]-sum[a[i]])/l;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m>>l;\n  rep(i,n){\n    cin>>a[i];\n    a[i]--;\n  }\n  sort(a,a+n);\n  rep(i,m){\n    cin>>b[i];\n  }\n  rep(i,m){\n    sum[i+1]=sum[i]+b[i];\n  }\n  rep(i,2002)rep(j,2002)dp[i][j]=INF;\n  dp[0][0]=f(0,n-1)*2;\n  rep(i,n-2){\n    rep(j,i+1){\n      if(dp[i][j]==INF)continue;\n      minch(dp[i+1][j],dp[i][j]-f(i,n-1)+f(i,i+1)+f(i+1,n-1));\n      minch(dp[i+1][i],dp[i][j]-f(j,n-1)+f(j,i+1)+f(i+1,n-1));\n    }\n  }\n  ll res=INF;\n  rep(i,n){\n    minch(res,min(dp[n-2][i],dp[i][n-2]));\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#define range(i,a,b) assert(a<=i && i<=b)\nusing namespace std;\nint N, M, L;\nvector<long long> K, S;\nlong long floorL(long long x){\n\treturn (x / L)*L;\n}\nlong long sumofS(int a, int b){\n\tlong long sum = 0;\n\tfor (int i = a; i < b + 1; i++){\n\t\trange(i, 0, M - 1);\n\t\tsum += S[i];\n\t}\n\treturn sum;\n}\nlong long solve(int n){\n\tif (n > 0){\n\t\tauto res = solve(n - 1);\n\t\tauto sum1 = sumofS(K[n - 1] + 1, K[n]);\n\t\tauto sum2 = sumofS(K[n - 1], K[n]);\n\t\trange(n, 1, N - 1);\n\t\tauto candi1 = floorL(res + sum1) + sum2;\n\t\tauto candi2 = res + sum1 + floorL(sum2);\n\t\tcerr << candi1 << \" \" << candi2 << endl;\n\t\treturn min(candi1,candi2);\n\t}\n\telse{\n\t\trange(K[0], 0, M - 1);\n\t\tcerr << S[K[0]] << endl;\n\t\treturn S[K[0]];\n\t}\n}\nint main(){\n\tcin >> N >> M >> L;\n\tK = vector<long long>(N);\n\tS = vector<long long>(M);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\tsort(K.begin(), K.end());\n\tauto ans = solve(N - 1) / L;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> s_acc(1); partial_sum(whole(s), back_inserter(s_acc));\n    auto penalty = [&](int a, int b) { if (a > b) swap(a, b); return (s_acc[k[b] + 1] - s_acc[k[a]]) / l; };\n    auto dp = vectors(n, n, inf);\n    dp[1][0] = penalty(0, 1);\n    repeat (a, n - 1) {\n        repeat (b, a) {\n            setmin(dp[a + 1][a], dp[a][b] + penalty(b, a + 1));\n            setmin(dp[a + 1][b], dp[a][b] + penalty(a, a + 1));\n        }\n    }\n    ll result = inf;\n    repeat (c, n - 1) {\n        setmin(result, dp[n - 1][c] + penalty(n - 1, c));\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint64 N, M, L, K[2000], S[100000], dp[2000][2000];\n\nint64 Range(int a, int b) {\n  if(a < b) swap(a, b);\n  if(b == 0) return(S[a]);\n  return(S[a] - S[b - 1]);\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return Range( K[right], K[left]) / L;\n  if(~dp[right][left]) return dp[right][left];\n  int64 ret = 1LL << 55;\n  ret = min( ret, rec( idx + 1, idx, left) + Range( K[right], K[idx]) / L);\n  ret = min( ret, rec( idx + 1, right, idx) + Range( K[left], K[idx]) / L);\n  return dp[right][left] = ret;\n}\n \nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr long long INF = (1ll << 60);\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tlong long n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<int> k(n);\n\tfor(auto &e : k) cin >> e;\n\tsort(begin(k), end(k));\n\n\tvector<long long> s(m);\n\tfor(auto &e : s) cin >> e;\n\n\tvector<long long> sum(m + 1, 0);\n\tpartial_sum(begin(s), end(s), begin(sum) + 1);\n\n\tconst auto calc = [&](int a, int b) -> long long {\n\t\tif(a > b) swap(a, b);\n\t\treturn (sum[k[b]] - sum[k[a] - 1]) / l;\n\t};\n\n\tvector<vector<long long>> dp(n - 1, vector<long long>(n - 1, INF));\n\tdp[0][1] = calc(0, 1);\n\n\tfor(int i = 0; i < n - 2; ++i) {\n\t\tfor(int j = i + 1; j < n - 2; ++j) {\n\t\t\tconst int next = j + 1;\n\t\t\tchmin(dp[i][next], dp[i][j] + calc(j, next));\n\t\t\tchmin(dp[j][next], dp[i][j] + calc(i, next));\n\t\t}\n\t}\n\n\tlong long ans = INF;\n\tfor(int i = 0; i < n - 2; ++i) {\n\t\tchmin(ans, dp[i][n - 2] + calc(i, n - 1));\n\t}\n\tans += calc(n - 2, n - 1);\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> acc(1); partial_sum(whole(s), back_inserter(acc));\n    ll result = 0;\n    repeat (i, n) {\n        int a = k[i];\n        int b = k[(i + 1) % n];\n        if (a > b) swap(a, b);\n        result += (acc[b + 1] - acc[a]) / l;\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<numeric>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX (1<<20)\nint N,M,L;\nint k[2001];\nint s[100001];\nint wa[2003][2003];\nint rw[100001];\nbool f[2001];\n\nint en[2002];\n\nvector <int> ke;\n\nint dp[2002][2002];\n\n\nmain(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++) scanf(\"%d\",&k[i]);\n  for(int i=0;i<M;i++) scanf(\"%d\",&s[i]);\n  sort(k,k+N);\n  rw[0]=s[0];\n  for(int i=1;i<M;i++)\n    rw[i]=rw[i-1]+s[i];\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(i==j) continue;\n      int ni=min(k[i],k[j])-1;\n      int nj=max(k[i],k[j])-1;\n      int sa=rw[ni-1];\n      if(ni-1<0) sa=0;\n      wa[k[i]][k[j]]=(rw[nj]-sa)/L;\n    }\n  }\n\n  int res=0;\n\n  en[0]=k[0];\n  for(int i=1;i<N/2+1;i++){\n    en[i]=k[i*2-1];\n    if(N-i>N/2)\n      en[N-i]=k[i*2];\n    //  printf(\"%d : %d - %d \\n\",i,en[i],en[N-i]);\n  }\n  \n  for(int i=0;i<N;i++){\n    res+=wa[en[i]][en[(i+1)%N]];\n    //printf(\"%d - %d = %d\\n\",en[i],en[(i+1)%N],res);\n  }\n\n  printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n\nint64 N, M, L, K[2000], S[100000];\nint64 dp[2000][2000];\nint64 get_Sum(int a, int b){\n  if(a > b) swap( a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a - 1];\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return get_Sum( K[right], K[left]);\n  if(~dp[right][left]) return dp[right][left];\n  int64 ret = INF;\n  ret = min( ret, rec( idx + 1, idx, left) + get_Sum( K[right], K[idx]));\n  ret = min( ret, rec( idx + 1, right, idx) + get_Sum( K[left], K[idx]));\n  return dp[right][left] = ret;\n}\n\nint main(){\n  fill_n( *dp, 2000 * 2000, -1);\n  scanf(\"%lld %lld %lld\", &N, &M, &L);\n  for(int i = 0; i < N; i++){\n    scanf(\"%lld\", &K[i]); --K[i];\n  }\n  for(int i = 0; i < M; i++){\n    scanf(\"%lld\", &S[i]);\n    if(i) S[i] += S[i - 1];\n  }\n  sort( K, K + N);\n  printf(\"%lld\\n\", rec(1,0,0) / L);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint v[2000];\nlong long s[100001];\nlong long dp[2001][2001];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",v+i);\n\tfor(int i=0;i<b;i++)scanf(\"%lld\",s+i+1);\n\tfor(int i=0;i<b;i++)s[i+1]+=s[i];\n\tstd::sort(v,v+a);\n\tfor(int i=0;i<2001;i++)\n\t\tfor(int j=0;j<2001;j++)\n\t\t\tdp[i][j]=999999999999999LL;\n\tdp[a][a]=0LL;\n\tfor(int i=a;i>1;i--){\n\t\tfor(int j=a;j>1;j--){\n\t\t\tint next=min(i,j)-1;\n\t\t\tdp[next][j]=min(dp[next][j],dp[i][j]+(s[v[i-1]]-s[v[next-1]-1])/c);\n\t\t\tdp[i][next]=min(dp[i][next],dp[i][j]+(s[v[j-1]]-s[v[next-1]-1])/c);\n\t\t}\n\t}\n\tlong long ret=99999999999999999LL;\n\tfor(int i=2;i<=a;i++){\n\t\tret=min(ret,dp[i][1]+(s[v[i-1]]-s[v[0]-1])/c);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\t//if(vec[a].first > vec[b].first) swap(a, b);\n\t//return (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n\treturn (cum[K[a]] - cum[K[b]-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\t//sort(vec, vec+n);\n\t//reverse(vec, vec+n);\n\tsort(K, K+n);\n\treverse(K, K+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tint h = i+1;\n\t\t\t//dp[i+1][j] = min(dp[j][i+1], dp[i][j] + calc(i, i+1));\n\t\t\t//dp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(j, i+1));\n\t\t\tdp[h][j] = min(dp[j][h], dp[i][j] + (cum[K[i]] - cum[K[h]-1]) / l);\n\t\t\tdp[h][i] = min(dp[h][i], dp[i][j] + (cum[K[j]] - cum[K[h]-1]) / l);\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + (cum[K[i]] - cum[K[n-1]-1]) / l);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nll n, m, l;\nll a[2000];\nll b[100000];\nll s[100010];\nll dp[2000][2000];\n\nll sum(ll i, ll j){\n  return (s[max(i, j) + 1] - s[min(i, j)]) / l;\n}\n\nll dfs(ll i, ll j){\n  if (i == n) return sum(a[i - 1], j);\n  if (~dp[i][j]) return dp[i][j];\n  ll vl = sum(a[i - 1], a[i]) + dfs(i + 1, j);\n  ll vr = sum(a[j], a[i]) + dfs(i + 1, i - 1);\n  return dp[i][j] = min(vl, vr);\n}\n\nint main(){\n  cin >> n >> m >> l;\n  rep(i, n) cin >> a[i], a[i]--;\n  rep(i, m) cin >> b[i];\n  rep(i, m) s[i + 1] = s[i] + b[i];\n  sort(a, a + n);\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(1, a[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define D double\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m,l;\n  cin >> n >> m >> l;\n\n  vec a(n);\n  REP(i,n) cin >> a[i];\n  \n  vec b(m);\n  REP(i,m) cin >> b[i];\n  \n  vec s(m+1,0);\n  REP(i,m) s[i+1] = s[i]+b[i];\n\n  sort(a.begin(),a.end());\n\n  mat dp(n,vec(n,INF));\n  dp[n-1][n-1] = 0;\n  RREP(i,n-1){\n    FOR(j,i+1,n){\n      dp[i][j] = min(dp[i][j],dp[i+1][j]+(s[a[i+1]]-s[a[i]-1])/l); \n      dp[i+1][i] = min(dp[i+1][i],dp[i+1][j]+(s[a[j]]-s[a[i]-1])/l);\n\n      dp[j][i] = min(dp[j][i],dp[j][i+1]+(s[a[i+1]]-s[a[i]-1])/l); \n      dp[i][i+1] = min(dp[i][i+1],dp[j][i+1]+(s[a[j]]-s[a[i]-1])/l);\n    }\n      // cout << endl;\n      // REP(i,n){\n      //   REP(j,n)cout << dp[i][j] << \" \";\n      //   cout << endl;\n      // }\n  }\n\n  int ans = INF;\n  REP(i,n){\n    ans = min({ans,dp[0][i]+(s[a[i]]-s[a[0]-1])/l,dp[i][0]+(s[a[i]]-s[a[0]-1])/l});\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 2000;\nconst int M = 1e5;\nconst int INF = 1 << 28;\n\nint n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nint calc(int a, int b){\n\tif(vec[a].second > vec[b].second) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(int i=0;i<n;i++) cin >> K[i];\n\tfor(int i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(int i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(int i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(dp[i][j] != INF){\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\t}\n\t\t\tif(dp[j][i] != INF){\n\t\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\t\tdp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i=0;i<n-1;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,l;\nvi in,dp;\nll mm[2010][2010];\nll f(ll a,ll b){\n\tif(mm[a][b]+1)return mm[a][b];\n\tif(b==n-1)return mm[a][b]=(dp[in[n-1]]-dp[in[a]-1])/l;\n\treturn mm[a][b]=min(f(a,b+1)+(dp[in[b+1]]-dp[in[b]-1])/l,f(b,b+1)+(dp[in[b+1]]-dp[in[a]-1])/l);\n}\nint main(){\n\tcin>>n>>m>>l;\n\trep(i,2010)rep(j,2010)mm[i][j]=-1;\n\tin=vi(n);\n\tdp=vi(m+1);\n\trep(i,n)cin>>in[i];\n\trep(i,m)cin>>dp[i+1];\n\trep(i,m)dp[i+1]+=dp[i];\n\tsort(all(in));\n\tcout<<f(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2002;\n\nll dp[MAX_N][MAX_N];\nll sm[100005];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,m,l;\n    cin >> n >> m >> l;\n    vi K(n),s(m);\n    rep(i,n){\n        cin >> K[i];\n        --K[i];\n    }\n    rep(i,m){\n        cin >> s[i];\n    }\n    sort(all(K));\n    rep(i,n+1){\n        rep(j,n+1){\n            dp[i][j] = (1LL << 60);\n        }\n    }\n    sm[0] = 0;\n    rep(i,m){\n        sm[i+1] = sm[i]+s[i];\n    }\n    dp[0][0] = 0;\n    rep(i,n-2){\n        rep(j,i+1){\n            cmn(dp[i+1][j],dp[i][j]+(sm[K[i+1]+1]-sm[K[i]])/l);\n            cmn(dp[i+1][i],dp[i][j]+(sm[K[i+1]+1]-sm[K[j]])/l);\n        }\n    }\n    // rep(i,n-1){\n    //     rep(j,i){\n    //         cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n    //     }\n    // }\n    ll ans = (1LL << 60);\n    rep(i,n-1){\n        cmn(ans,dp[n-2][i]+(sm[K[n-1]+1]-sm[K[n-2]])/l+(sm[K[n-1]+1]-sm[K[i]])/l);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n, m, l; cin >> n >> m >> l;\n\tvl k(n); REP(i, n) cin >> k[i];\n\tvl s(m); REP(i, m) cin >> s[i];\n\n\tvl sum(m + 1); sum[0] = 0;\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\n\tsort(ALL(k));\n\tvvl dp(2, vl((n - 1) * 2 + 1, TEN(13)));\n\tdp[0][n - 1] = 0;\n\tll ans = TEN(13);\n\tFOR(i, 1, n) REP(j, (n - 1) * 2 + 1) {\n\t\tll j_zero = j - (n - 1);\n\t\tll times = abs(j_zero);\n\t\tif (times >= i || dp[(i - 1) % 2][j] == TEN(13)) continue;\n\t\tif (i == n - 1) {\n\t\t\tMINC(\n\t\t\t\tans,\n\t\t\t\tdp[(i - 1) % 2][j]\n\t\t\t\t+ (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t\t+ (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t);\n\t\t} else {\n\t\t\tMINC(\n\t\t\t\tdp[i % 2][(n - 1) + (j_zero <= 0 ? 1 : -1)],\n\t\t\t\tdp[(i - 1) % 2][j] + (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t); // ???\n\t\t\tMINC(\n\t\t\t\tdp[i % 2][j + (j_zero <= 0 ? -1 : 1)],\n\t\t\t\tdp[(i - 1) % 2][j] + (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t); // ??£?¶?\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nint main()\n{\n    ll N, M, L;\n    cin >> N >> M >> L;\n    uniform_int_distribution<ll> kdist{1, M};\n    vector<ll> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n        K[i]--;\n    }\n    vector<ll> S(M);\n    vector<ll> sum(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n        sum[i] = ((i > 0) ? sum[i - 1] : 0) + S[i];\n    }\n    sort(K.begin(), K.end());\n    vector<vector<ll>> dist(N, vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ll l = min(K[i], K[j]);\n            ll r = max(K[i], K[j]);\n            dist[i][j] = (sum[r] - ((l > 0) ? sum[l - 1] : 0)) / L;\n        }\n    }\n    constexpr ll INF = 1LL << 60;\n\n    vector<vector<ll>> dp(N, vector<ll>(N, INF));\n    dp[0][0] = 0;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j <= i; j++) {\n            dp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + dist[j][i + 1]);\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dist[i][i + 1]);\n        }\n    }\n    for (int j = 0; j < N - 1; j++) {\n        dp[N - 1][N - 1] = min(dp[N - 1][N - 1], dp[N - 1][j] + dist[j][N - 1]);\n    }\n    cout << dp[N - 1][N - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nint main(){\n  int num_of_notes;\n  int num_of_beauty;\n  ll force_of_repulsion;\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      for(int j=0;j<=i;j++){\n        int larger_idx = max(i,j) + 1;\n        dp[larger_idx][j]\n          = min(dp[larger_idx][j],\n                dp[i][j] + (sum[notes[i]] - sum[notes[larger_idx] - 1]) / force_of_repulsion);\n\n        dp[larger_idx][i]\n          = min(dp[larger_idx][i],\n                dp[i][j] + (sum[notes[j]] - sum[notes[larger_idx] - 1]) / force_of_repulsion);\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i]\n                + (sum[notes[i]] - sum[notes[num_of_notes - 1] - 1]) / force_of_repulsion,\n                res);\n    }\n\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<int> k(n);\n    for(int i=0;i<n;i++){\n        cin>>k[i];\n        k[i]--;\n    }\n    sort(k.begin(),k.end());\n    vector<ll> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    vector<ll> ssum(m+1);\n    ssum[0]=0;\n    for(int i=0;i<m;i++){\n        ssum[i+1]=ssum[i]+s[i];\n    }\n    \n    auto cost=[&](int i,int j){\n        return (ssum[k[j]+1]-ssum[k[i]])/l;\n    };\n\n    const ll INF=1e12;\n    vector<vector<ll>> dp(n,vector<ll>(n,INF));\n    dp[0][0]=0;\n    for(int k=0;k<n;k++){\n        for(int r=0;r<=k;r++){\n            int i=k;\n            int j=r;\n            if(j+1<n){\n                if(i<j+1) dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                if(j<i+1) dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n            i=r;\n            j=k;\n            if(j+1<n){\n                if(i<j+1) dp[j+1][j]=min(dp[j+1][j],dp[i][j]+cost(i,j+1));\n                dp[i][j+1]=min(dp[i][j+1],dp[i][j]+cost(j,j+1));\n            }\n            if(i+1<n){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost(i,i+1));\n                if(j<i+1) dp[i][i+1]=min(dp[i][i+1],dp[i][j]+cost(j,i+1));\n            }\n        }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<n;i++){\n        ans=min(ans,dp[i][n-1]+cost(i,n-1));\n        ans=min(ans,dp[n-1][i]+cost(i,n-1));\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1ll<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\twhile(~scanf(\"%d%d%d\", &n, &m, &l)){\n\t\tvector<ll> K(n), S(m), sum(m+1);\n\t\tREP(i, n) scanf(\"%lld\", &K[i]), K[i]--;\n\t\tREP(i, m) scanf(\"%lld\", &S[i]);\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vector<ll>> dp(n+1, vector<ll>(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tdp[i][j]   = min(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tdp[i][i-1] = min(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[n-1][n-2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint calc_power(const vector<int>& ss,const int p,const int n,const int L){\n    if(n < p) return calc_power(ss,n,p,L);\n    return (ss[n] - ss[p-1]) / L;\n}\n\nint solve(int i,int u,int d,vector<int>& ss,vector<int>& k,const int L){\n    if(i == k.size()-1){\n        return calc_power(ss,u,k.back(),L) + calc_power(ss,d,k.back(),L);\n    }else{\n        return min(calc_power(ss,u,k[i],L) + solve(i+1,k[i],d,ss,k,L),\n                   calc_power(ss,d,k[i],L) + solve(i+1,u,k[i],ss,k,L));\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N,M,L;\n    cin >> N >> M >> L;\n\n    vector<int> K(N);\n    vector<int> S(M);\n    for(int& i : K) cin >> i;\n    sort(all(K));\n    for(int& i : S) cin >> i;\n\n    vector<int> SS(M+1);\n    for(int i=1;i<SS.size();i++){\n        SS[i] = SS[i-1] + S[i-1];\n    }\n    cout << solve(1,K[0],K[0],SS,K,L) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll inf = 1e18;\n\nint main() {\n  int N, M, L;\n  cin >> N >> M >> L;\n  vector<ll> K(N), S(M);\n  for(int i = 0; i < N; ++i) {\n    cin >> K[i];\n    K[i]--;\n  }\n  vector<ll> sum(M + 1);\n  for(int i = 0; i < M; ++i) {\n    cin >> S[i];\n    sum[i + 1] = sum[i] + S[i];\n  }\n  sort(begin(K), end(K));\n  vector<vector<ll>> dp(N + 1, vector<ll>(N + 1, inf));\n  dp[1][1] = 0;\n  for(int i = 1; i < N; ++i) {\n    for(int p1 = 1; p1 <= i; ++p1) {\n      int p2 = i;\n      if(dp[p1][p2] == inf) continue;\n      ll c1 = (sum[K[i] + 1] - sum[K[p1 - 1]]) / L; // put left\n      assert(c1 >= 0);\n      dp[i + 1][p2] = min(dp[i + 1][p2], dp[p1][p2] + c1);\n      ll c2 = (sum[K[i] + 1] - sum[K[p2 - 1]]) / L;\n      assert(c2 >= 0);\n      dp[p1][i + 1] = min(dp[p1][i + 1], dp[p1][p2] + c2);\n    }\n    for(int p2 = 1; p2 <= i; ++p2) {\n      int p1 = i;\n      if(dp[p1][p2] == inf) continue;\n      ll c1 = (sum[K[i] + 1] - sum[K[p1 - 1]]) / L;\n      assert(c1 >= 0);\n      dp[i + 1][p2] = min(dp[i + 1][p2], dp[p1][p2] + c1);\n      ll c2 = (sum[K[i] + 1] - sum[K[p2 - 1]]) / L;\n      assert(c2 >= 0);\n      dp[p1][i + 1] = min(dp[p1][i + 1], dp[p1][p2] + c2);\n    }\n  }\n\n  ll ans = inf;\n  for(int i = 1; i < N; ++i) {\n    if(dp[N][i] == inf) continue;\n    ans = min(ans, dp[N][i] + (sum[K[N - 1] + 1] - sum[K[i - 1]]) / L);\n    assert(sum[K[N - 1] + 1] - sum[K[i - 1]] >= 0);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint N,M,L,K[2001],sum[100001],dp[2001][2001];\n\nint func(int l,int r){\n\n  if(dp[l][r]>0)return dp[l][r];\n\n  int n=max(l,r)+1;\n  if(n==N)return (sum[K[n]]-sum[K[l]-1])/L+(sum[K[n]]-sum[K[r]-1])/L;\n\n  int lf=func(n,r)+(sum[K[n]]-sum[K[l]-1])/L;\n  int rt=func(l,n)+(sum[K[n]]-sum[K[r]-1])/L;\n\n  return dp[l][r]=min(lf,rt);\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++)cin >> K[i];\n  \n  sort(K+1,K+N+1);\n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  cout << func(1,1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\nconst int inf = 1LL << 50;\n\nint n, m, L;\nvector<int> K, S, sum;\nvector<vector<int>> memo;\n\nint calc(int a, int b){\n    return (sum[K[b] + 1] - sum[K[a]]) / L;\n}\n\nint rec(int li, int ri){\n    if(memo[li][ri] != inf) return memo[li][ri];\n    \n    int ni = max(li, ri) + 1;\n\n    if(ni == n - 1){\n        return memo[li][ri] = calc(li, ni) + calc(ri, ni);\n    }\n\n    return memo[li][ri] = min(rec(li, ni) + calc(ri, ni), rec(ni, ri) + calc(li, ni));\n}\n\nsigned main(void){\n    cin >> n >> m >> L;\n    K = vector<int>(n), S = vector<int>(m);\n    for(auto & e : K) cin >> e, e--;\n    for(auto & e : S) cin >> e;\n\n    sort(begin(K), end(K));\n\n    sum = vector<int>(m + 1);\n    sum[0] = 0;\n    rep(i, m){\n        sum[i + 1] = sum[i] + S[i];\n    }\n\n    memo = vector<vector<int>>(n, vector<int>(n, inf));\n\n    cout << rec(0, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll n,m,l;\nvector<ll> k;\nvector<ll> s;\nvector<ll> acm;\nvector<vector<vector<ll>>> memo(2000,vector<vector<ll>>(2,vector<ll>(2000,-1)));\n\nll sum(ll _l, ll _r) {\n\tll ret=0;\n\tif(_l==0) ret=acm[_r];\n\telse ret=acm[_r]-acm[_l-1];\n\tret-=ret%l;\n\treturn ret;\n}\n\nll dfs(ll pos, ll col, ll bef) {\n\tif(memo[pos][col][bef]!=-1) return memo[pos][col][bef];\n\tif(pos==1) return memo[pos][col][bef]=sum(k[0],k[1]);\n\tif(bef+1!=pos) return memo[pos][col][bef]=sum(k[pos-1],k[pos])+dfs(pos-1,col,bef);\n\telse {\n\t\tll mini=INF*INF;\n\t\tREP(i,pos-1) {\n\t\t\tmini=min(mini,sum(k[i],k[pos])+dfs(pos-1,!col,i));\n\t\t}\n\t\treturn memo[pos][col][bef]=mini;\n\t}\n}\n\nll solve() {\n\tvector<ll> vec;\n\tsort(ALL(k));\n\tll ret=INF*INF;\n\tREP(i,2) REP(j,n-2) {\n\t\tret=min(ret,sum(k[j],k[n-1])+sum(k[n-2],k[n-1])+dfs(n-2,i,j));\n\t}\n\treturn ret/l;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>n>>m>>l;\n\tk.assign(n,0);\n\ts.assign(m,0);\n\tacm.assign(m,0);\n\tREP(i,n) cin>>k[i];\n\tREP(i,n) k[i]--;\n\tREP(i,m) cin>>s[i];\n\tacm[0]=s[0];\n\tFOR(i,1,m) acm[i]=acm[i-1]+s[i];\n\tcout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[2010][2010];\nll v[2010];\nint pre[1000];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tset<int> st;\n\tvector<ll> k(n),s(m+1),t(n),p(m+1);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tst.insert(k[i]);\n\t}\n\trep(i,m){\n\t\tcin >> s[i+1];\n\t}\n\tsort(k.begin(),k.end());\n\tll ans = 0;\n\tvector<ll> q;\n\tq.PB(k[0]);\n\tp[k[0]]++;\n\tint x = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(q[x]==k[i]){\n\t\t\tp[k[i]]++;\n\t\t}else{\n\t\t\tq.PB(k[i]);\n\t\t\tp[k[i]]++;\n\t\t\tx++;\n\t\t}\n\t}\n\tif(m==1){\n\t\tcout << (p[1]*(s[1]/l)) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i][i] = s[i];\n\t}\n\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=i+1;j<=m;j++){\n\t\t\tdst[i][j] = dst[i][j-1] + s[j];\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=i;j<=m;j++){\n\t\t\tdst[i][j] = dst[i][j]/l;\n\t\t}\n\t}\n\tint f;\n\trep(i,m+1){\n\t\tif(st.count(i)!=0){\n\t\t\tf = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tx = f;\n\tfor(int i=f+1;i<=m;i++){\n\t\tif(st.count(i)!=0){\n\t\t\tpre[i] = x;\n\t\t\tx = i;\n\t\t}\n\t}\n\n\n\trep(i,m+1){\n\t\tif(p[i]>=2){\n\t\t\tans += (p[i]-1)*((s[i])/l);\n\t\t}\n\t}\n\n\tx = f;\n\tfor(int i=f+1;i<=m;i++){\n\t\tif(st.count(i)==0){\n\t\t\tv[i] = v[i-1];\n\t\t}else{\n\t\t\tv[i] = v[i-1]+dst[x][i];\n\t\t\tx = i;\n\t\t}\n\t}\n\n\tdp[m] = dst[m-1][m];\n\tfor(int i=m-1;i>=f+1;i--){\n\t\tif(st.count(i)==0)continue;\n\t\tdp[i]=100000000000000;\n\t\tfor(int j=i+2;j<=m;j++){\n\t\t\tif(st.count(j)!=0){\n\t\t\t\tll tmp = 0;\n\t\t\t\ttmp += dst[i][j];\n\t\t\t\ttmp += v[j]-v[i+1];\n\t\t\t\ttmp += dst[pre[i]][i+1];\n\t\t\t\tdp[i] = min(dp[i],dp[j]+tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1;j<=m;j++){\n\t\t\tif(st.count(j)!=0){\n\t\t\t\tll tmp = 0;\n\t\t\t\ttmp += dst[pre[i]][j];\n\t\t\t\ttmp += v[j-1]-v[i];\n\t\t\t\tdp[i] = min(dp[i],dp[j]+tmp);\n\t\t\t}\n\t\t}\n\t}\n\tll mi = 10000000000;\n\tfor(int i=f+1;i<=n;i++){\n\t\tif(st.count(i)==0)continue;\n\t\tif(st.count(i)!=0){\n\t\t\tll tmp = 0;\n\t\t\ttmp += dst[f][i];\n\t\t\ttmp += v[i-1];\n\t\t\tmi = min(mi,tmp + dp[i]);\n\t\t}\n\t}\n\t/*rep(i,m+1){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n\n\trep(i,m+1){\n\t\tcout << dp[i] << \" \";\n\t}\n\tcout << endl;\n*/\n\n\tcout << ans+mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst ll inf = (int)1e18;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, k[2000], s[100001];\nll sum[100001], dp[2001][2001];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\trep(i, n) scanf(\"%d\", k + i);\n\trep(i, m) scanf(\"%d\", s + i), sum[i + 1] = sum[i] + s[i];\n\t\n\tsort(k, k + n, greater<int>());\n\trep(i, n + 1) rep(j, n + 1) dp[i][j] = inf;\n\tdp[0][0] = 0;\n\tll ans = inf;\n\t\n\trep(i, n) rep(j, n) if(dp[i][j] < inf){\n\t\tint h = max(i, j) + 1;\n\t\tdp[h][j] = min(dp[h][j], dp[i][j] + (sum[k[i]] - sum[k[h] - 1]) / l);\n\t\tdp[i][h] = min(dp[i][h], dp[i][j] + (sum[k[j]] - sum[k[h] - 1]) / l);\n\t}\n\trep(i, n) ans = min(ans, min(dp[n - 1][i], dp[i][n - 1]) + (sum[k[i]] - sum[k[n - 1] - 1]) / l);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\nll N, M, L;\nvector<ll> K;\nvector<ll> sum;\nvector<vector<ll>> dp;\n\nll rec(int l, int r, vector<vector<ll>>& dp)  {\n    int mi = min(l, r);\n    int ma = max(l ,r);\n    if(ma == N-1) {\n        return (sum[K[ma]] - sum[K[mi]-1]) / L;\n    }\n    ll& res = dp[l][r];\n    if(res != -1) {\n        return res;\n    }\n    res = rec(ma+1, r, dp) + (sum[K[ma+1]] - sum[K[l]-1]) / L;\n    res = min(res, rec(l, ma+1, dp) + (sum[K[ma+1]] - sum[K[r]-1]) / L);\n    return res;\n}\n\nint main() {\n    cin >> N >> M >> L;\n    vector<ll> S(M);\n    K.resize(N);\n    for(int i=0; i<N; ++i) {\n        cin >> K[i];\n    }\n    sort(K.begin(), K.end());\n    sum.resize(M+1);\n    for(int j=0; j<M; ++j) {\n        cin >> S[j];\n        sum[j+1] = sum[j] + S[j];\n    }\n    dp.resize(N);\n    for(int i=0; i<N; ++i) {\n        dp[i].assign(N, -1);\n    }\n    cout << rec(0, 1, dp) + (sum[K[1]] - sum[K[0]-1])/L << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 1-indexed\ntemplate <class T>\nstruct BIT {\n  vector<T> lst;\n  int treesize;\n  // constructor\n  BIT(int newn = 0) {\n    treesize = newn;\n    lst.resize(treesize + 1);\n    for(int i = 0; i <= treesize; ++i) lst[i] = 0;\n  }\n  // a_place += num\n  bool add(int place, T num) {\n    while(place <= treesize) {\n      lst[place] += num;\n      place += place & -place;\n    }\n    return 1;\n  }\n  // add wide ver.(add num between l and r)\n  bool addw(int left, int right, T num) {\n    while(left <= right && left >= 1 && right <= treesize)\n      add(left++, num);\n    return 1;\n  }\n  // sum between [1,place]\n  T calcsum(int place) {\n    T answer = 0;\n    while(place > 0) {\n      answer += lst[place];\n      place -= place & -place;\n    }\n    return answer;\n  }\n  // sum [l,r]\n  T calcsumw(int left, int right) {\n    return calcsum(right) - calcsum(left - 1);\n  }\n};\n\nlong long n, m, l;\nvector<long long> k;\nBIT<long long> bit;\nvector<vector<vector<long long>>> dp;\n\nlong long solve();\n\nint main() {\n  cin >> n >> m >> l;\n  bit = BIT<long long>(m);\n  k.resize(n);\n  for(int i = 0; i < n; ++i) cin >> k[i];\n  for(int i = 0; i < m; ++i) {\n    long long x;\n    cin >> x;\n    bit.add(i + 1, x);\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = 1e17;\n  sort(k.begin(), k.end());\n  dp.assign(n,\n            vector<vector<long long>>(\n                2, vector<long long>(n, (long long)1e17)));\n  dp[0][0][0] = dp[0][1][0] = 0;\n  for(int i = 1; i < n; ++i)\n    for(int f = 0; f < 2; ++f)\n      for(int j = 0; j < i; ++j) {\n        dp[i][f][j] = dp[i - 1][f][j] +\n                      bit.calcsumw(k[i - 1], k[i]) / l;\n        if(j == i - 1)\n          for(int x = 0; x < j; ++x)\n            dp[i][f][j] =\n                min(dp[i][f][j],\n                    dp[i - 1][1 - f][x] +\n                        bit.calcsumw(k[x], k[i]) / l);\n      }\n  for(int i = 0; i < n; ++i)\n    res = min(res, dp[n - 1][0][i] +\n                       bit.calcsumw(k[i], k[n - 1]) / l);\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, L;\nint card[2010];\nint seq[100010];\nll sum[100010];\nll memo[2010][2010];\n\ninline ll score(int l, int r) {\n  l = card[l]; r = card[r];\n  if (l > r) { swap(l, r); }\n  return (sum[r + 1] - sum[l]) / L;\n}\n\nll calc(int left, int right) {\n  if (memo[left][right] != -1) { return memo[left][right]; }\n  int index = max(left, right) + 1;\n  if (index == n) {\n    return score(left, right);\n  }\n  ll ret = 1LL << 60;\n  ret = min(ret, calc(index, right) + score(left, index));\n  ret = min(ret, calc(left, index) + score(right, index));\n  return memo[left][right] = ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &L) > 0) {\n    MEMSET(memo, -1);\n    MEMSET(sum, 0);\n    REP(i, n) {\n      int v = scanf(\"%d\", &card[i]);\n      card[i]--;\n      assert(v == 1);\n    }\n    REP(i, m) {\n      int v = scanf(\"%d\", &seq[i]);\n      assert(v == 1);\n    }\n    sum[0] = 0;\n    REP(i, 100000) {\n      sum[i + 1] = sum[i] + seq[i];\n    }\n    sort(card, card + n);\n    reverse(card, card + n);\n    ll ans = calc(0, 0);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n\nint main()\n{\n\tint N, M, L, K[2000], S[10001];\n\tscanf(\"%d%d%d\", &N, &M, &L);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%d\", K + i);\n\tfor (int i = 1; i <= M; ++i)\n\t\tscanf(\"%d\", S + i);\n\tsort(K, K + N);\n\n\tll sum[10001];\n\tsum[0] = 0;\n\tfor (int i = 1; i <= M; ++i)\n\t\tsum[i] = sum[i-1] + S[i];\n\n\tconst ll INF = 100000000000000ll;\n\tstatic ll dp[2000][2001];\n\tfor (int i = 0; i < 2000; ++i)\n\t\tfor (int j = i; j < 2001; ++j)\n\t\t\tdp[i][j] = INF;\n\n#define seg_sum(a, b) ((sum[b] - sum[a-1]) / L)\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < N-1; ++i)\n\t{\n\t\tfor (int j = i + 1; j < N; ++j)\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-1] + seg_sum(K[j-1], K[j]));\n\t\tfor (int j = i + 1; j < N-1; ++j)\n\t\t\tdp[j][j+1] = min(dp[j][j+1], dp[i][j] + seg_sum(K[i], K[j+1]));\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i < N-1; ++i)\n\t\tans = min(ans, dp[i][N-1] + seg_sum(K[i], K[N-1]));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M,L;\nint K[2001];\nint S[100001];\npair<int,int> Onpu[2001];\n\nll dp[2001][2001];\nll sums[100001];\n\nll dfs(int a,int b){\n    if(a==N-1||b==N-1){\n        if(a<b)swap(a,b);\n        return (sums[K[a]+1]-sums[K[b]])/L;\n    }\n    else if(dp[a][b]!=-1)return dp[a][b];\n    int nxtIdx=max(a,b)+1;\n    ll tmp=(sums[K[nxtIdx]+1]-sums[K[a]])/L;\n    ll res=dfs(nxtIdx,b)+tmp;\n    res=min(res,dfs(a,nxtIdx)+(sums[K[nxtIdx]+1]-sums[K[b]])/L);\n    return dp[a][b]=res;\n}\nint main(){\n    cin>>N>>M>>L;\n    for(int i=0;i<N;i++){\n        cin>>K[i];\n        K[i]--;\n    }\n    for(int i=0;i<M;i++){\n        cin>>S[i];\n        sums[i+1]=sums[i]+S[i];\n    }\n    for(int i=0;i<N;i++){\n        Onpu[i].first=S[K[i]];\n        Onpu[i].second=K[i];\n    }\n    //sort(Onpu,Onpu+N);\n    //for(int i=0;i<N;i++)K[i]=Onpu[i].second;\n    sort(K,K+N);\n    memset(dp,-1,sizeof(dp));\n    ll res=dfs(0,0);\n    cout<<res<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Magical Girl Sayaka-chan\n//Level: 3\n//Category: 動的計画法,DP\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i_, n_) for(int i_ = 0; i_ < (n_); ++i_)\ntypedef long long LL;\n\nint N, M, L;\nvector<int> ks;\nvector<int> ss;\nvector<LL> acc;\nLL memo[2001][2001];\n\nLL cost(int a, int b) {\n    int ka = ks[a];\n    int kb = ks[b];\n    if(ka > kb) swap(ka, kb);\n    return (acc[kb] - acc[ka-1]) / L;\n}\n\nLL calc(int l, int r) {\n    if(memo[l][r] != -1) return memo[l][r];\n    const int next = max(l, r) + 1;\n    if(next == N) {\n        return cost(l, r);\n    }\n    memo[l][r] = min(calc(next, r) + cost(l, next), calc(l, next) + cost(r, next));\n    return memo[l][r];\n}\n\nbool solve() {\n    if(!(cin >> N >> M >> L)) return false;\n    if(!N && !M && !L) return false;\n\n    ks.resize(N);\n    TIMES(i, N) {\n        cin >> ks[i];\n    }\n    ss.resize(M);\n    TIMES(i, M) {\n        cin >> ss[i];\n    }\n    acc.resize(M+1);\n    acc[0] = 0;\n    for(int i = 1; i <= M; ++i) {\n        acc[i] = acc[i-1] + ss[i-1];\n    }\n\n    sort(ks.begin(), ks.end());\n    TIMES(i, N) {\n        TIMES(j, N) {\n            memo[i][j] = -1;\n        }\n    }\n    cout << calc(0, 0) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\treverse(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + calc(n-1, i));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(next,i));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(next,j));\n      }\n    }\n\n    ll res = LINF;\n    for(int i=0;i<num_of_notes;i++){\n      res = min(dp[num_of_notes - 1][i] + compute(num_of_notes-1,i),res);\n    }\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\n\nint num_of_notes;\nint num_of_beauty;\nll force_of_repulsion;\nll sum[200001];\nll dp[2001][2001];\nint notes[2001];\nll beauty[100001];\n\nll compute(int i,int j){\n  ll lhs = sum[notes[i]];\n  ll rhs = (notes[j] - 1 < 0 ? 0 : sum[notes[j] - 1]);\n\n  return (lhs - rhs) / force_of_repulsion;\n}\n\nint main(){\n  while(~scanf(\"%d %d %lld\",\n               &num_of_notes,\n               &num_of_beauty,\n               &force_of_repulsion)){\n\n    for(int note_idx = 0; note_idx < num_of_notes; note_idx++){\n      scanf(\"%d\",notes + note_idx);\n      notes[note_idx]--;\n    }\n\n    memset(sum,0,sizeof(sum));\n\n    for(int beauty_idx = 0; beauty_idx < num_of_beauty; beauty_idx++){\n      scanf(\"%d\",beauty + beauty_idx);\n      sum[beauty_idx] = (beauty_idx - 1 >= 0 ? sum[beauty_idx - 1] : 0) + beauty[beauty_idx];\n    }\n\n    sort(notes,notes + num_of_notes);\n    reverse(notes,notes + num_of_notes);\n\n    memset(dp,0x3f,sizeof(dp));\n\n    dp[0][0] = 0;\n    for(int i=0;i<num_of_notes;i++){\n      int next = i + 1;\n      if(next >= num_of_notes) break;\n      for(int j=0;j<=i;j++){\n        if(i==j && i!=0) continue;\n        dp[next][j]\n          = min(dp[next][j],dp[i][j] + compute(i,next));\n\n        dp[next][i]\n          = min(dp[next][i],dp[i][j] + compute(j,next));\n      }\n    }\n\n    ll res = LINF;\n    res = min(dp[num_of_notes - 1][0] + compute(0,num_of_notes - 1),res);\n    \n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> l){\n\t\tvi K(n), S(m);\n\t\tREP(i, n) cin >> K[i], K[i]--;\n\t\tREP(i, m) cin >> S[i];\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tvi sum(m+1);\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vi> dp(n+1, vi(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tchmin(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tchmin(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tcout << dp << endl;\n\t\tcout << dp[n-1][n-2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nll N,M,L,K[2010],S[100010],sum[100010];\nll dp[2010][2010];\n\nll f(int a,int b){\n\tif(K[a] > K[b]) swap(a,b);\n\treturn (sum[K[b]+1] - sum[K[a]])/L;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>L;\n\trep(i,N)cin>>K[i],K[i]--;\n\tsum[0] = 0;\n\trep(i,M){\n\t\tcin>>S[i];\n\t\tsum[i+1] = sum[i] + S[i];\n\t}\n\tsort(K,K+N);\n\trep(i,N)rep(j,i) dp[i][j] = INF*INF;\n\tdp[1][0] = f(0,1);\n\trep(i,N)rep(j,i){\n\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + f(i,i+1));\n\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + f(j,i+1));\n\t}\n\tll ans = INF*INF;\n\trep(j,N-1) ans = min(ans, dp[N-1][j] + f(j,N-1));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 2020;\nconst int ML = 100100;\nint n, m;\nll l;\nint k[MN];\nll s[ML], ssm[ML];\n\nll gt(int a, int b) {\n    return (ssm[k[b]+1]-ssm[k[a]])/l;\n}\n\n\nll calc(int a, int b) {\n    if (a > b) return calc(b, a);\n    if (b == n-2) {\n        return gt(a, n-1)+gt(b, n-1);\n    }\n    static ll dp[MN][MN];\n    static bool used[MN][MN];\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    ll &ans = dp[a][b];\n    ans = TEN(9);\n    ans = min(ans, calc(b+1, b)+gt(a, b+1));\n    ans = min(ans, calc(a, b+1)+gt(b, b+1));\n    return ans;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    for (int i = 0; i < n; i++) {\n\tcin >> k[i]; k[i]--;\n    }\n    sort(k, k+n);\n    for (int i = 0; i < m; i++) {\n\tcin >> s[i];\n    }\n    ssm[0] = 0;\n    for (int i = 0; i < m; i++) {\n\tssm[i+1] = s[i]+ssm[i];\n    }\n    cout << calc(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  100000000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll dp[2010];\nll dst[100100];\nll v[2010];\nint main(){\n\tll n,m,l;\n\tcin >> n >> m >> l;\n\tvector<ll> k(n),s(m);\n\trep(i,n){\n\t\tcin >> k[i];\n\t\tk[i]--;\n\t}\n\trep(i,m){\n\t\tcin >> s[i];\n\t}\n\tsort(k.begin(),k.end());\n\tdst[0] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tdst[i] = dst[i-1] + s[i-1];\n\t}\n\tv[1] = (dst[k[1]+1]-dst[k[0]])/l;\n\tfor (int i=2;i<n;i++){\n\t\tv[i] = v[i-1] + (dst[k[i]+1]-dst[k[i-1]])/l;\n\t}\n\t\n\tdp[n-1] = (dst[k[n-1]+1]-dst[k[n-2]])/l;\n\tfor(int i=n-2;i>0;i--){\n\t\tdp[i] = inf;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(j==(i+1)){\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+dp[j]);\n\t\t\t\tif(j==n-1){\n\t\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i]])/l+(dst[k[j]+1]-dst[k[i-1]])/l);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i-1]])/l+v[j-1]-v[i]+dp[j]);\n\t\t\t\tdp[i] = min(dp[i],(dst[k[j]+1]-dst[k[i]])/l+(dst[k[i+1]+1]-dst[k[i-1]])/l+v[j-1]-v[i+1]+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll mi = inf;\n\tfor(int i=1;i<n;i++){\n\t\tmi = min(mi,dp[i]+(dst[k[i]+1]-dst[k[0]])/l+v[i-1]);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n/** whole range */\n#define whole(xs) (xs).begin(), (xs).end()\n\nnamespace {\n    typedef long long ll;\n    const ll INF = 1LL<<54;\n    const bool debug = false;\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n\n    ll N, M, L;\n    vector<ll> K, S;\n    void input() {\n        cin >> N >> M >> L;\n        K.resize(N);\n        S.resize(M);\n        for (auto i = 0; i < N; i++) {\n            cin >> K[i];\n            K[i]--;\n        }\n        for (auto i = 0; i < M; i++) cin >> S[i];\n    }\n\n    void solve() {\n        ll f[N + 1][N + 1]; {\n            for (auto i = 0; i < N + 1; i++) {\n                for (auto j = 0; j < N + 1; j++) {\n                    f[i][j] = INF;\n                }\n            }\n        }\n        sort(whole(K));\n        vector<ll> cumsum(M + 1, 0); {\n            for (auto i = 0; i < M; i++) {\n                cumsum[i + 1] = cumsum[i] + S[i];\n            }\n        }\n\n        if (debug) {\n            cout << \"cumsum: \" << cumsum << endl;\n        }\n\n        auto g = [&](ll a, ll b) {\n            return (cumsum[K[b] + 1] - cumsum[K[a]]) / L;\n        };\n        f[1][0] = g(0, 1);\n        for (auto k = 0; k < N - 2; k++) {\n            for (auto p = 0; p < k; p++) {\n                f[k + 1][p] = min(f[k + 1][p], f[k][p] + g(k, k + 1));\n                f[k + 1][k] = min(f[k + 1][k], f[k][p] + g(p, k + 1));\n            }\n        }\n\n        if (debug) {\n            cout << endl;\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    cout << f[i][j] << \" \";\n                }\n                cout << endl;\n            }\n        }\n\n        ll ans = INF;\n        auto k = N - 2;\n        for (auto p = 0; p < k; p++) {\n            ans = min(ans, f[k][p] + g(k, N - 1) + g(p, N - 1));\n            //cout << k << \" \" << p << \" -> \" << f[k][p] << \"&\" << g(k, N - 1) << \"&\" << g(p, N - 1) << endl;\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nll dp[2010][2010];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, M, L;\n    cin >> N >> M >> L;\n    vector<ll> K(N), S(M + 1), sum(M + 1, 0);\n    for (int i = 0; i < N; i++)\n        cin >> K[i];\n    for (int i = 1; i <= M; i++)\n    {\n        cin >> S[i];\n        sum[i] = sum[i - 1] + S[i];\n    }\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            dp[i][j] = 1e15;\n    dp[0][0] = 0;\n    sort(K.begin(), K.end());\n    for (int i = 0; i < N - 1; i++)\n    {\n        for (int j = 0; j < N - 1; j++)\n        {\n            int next = max(i, j) + 1;\n            ll lcost = (sum[K[next]] - sum[K[i] - 1]) / L;\n            ll rcost = (sum[K[next]] - sum[K[j] - 1]) / L;\n            dp[next][j] = min(dp[next][j], dp[i][j] + lcost);\n            dp[i][next] = min(dp[i][next], dp[i][j] + rcost);\n        }\n    }\n    ll ret = 1e15;\n    for (int i = 0; i < N - 2; i++)\n    {\n        ll cost = (sum[K[N - 1]] - sum[K[i] - 1]) / L + (sum[K[N - 1]] - sum[K[N - 2] - 1]) / L;\n        ret = min(ret, dp[i][N - 2] + cost);\n        ret = min(ret, dp[N - 2][i] + cost);\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL naive(VI s, vector<LL>& acc, int L){\n  int N = SZ(s);\n  LL res = 1e15;\n  do{\n\tLL sum = 0;\n\tREP(i,N){\n\t  int mx = max(s[i], s[(i+1)%N]);\n\t  int mn = min(s[i], s[(i+1)%N]);\n\t  sum += (acc[mx+1] - acc[mn]) / L;\n\t}\n\tres = min(res, sum);\n  }while(next_permutation(ALL(s)));\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, L; cin >> N >> M >> L;\n  VI ks(N);\n  REP(i,N){\n\tcin >> ks[i]; --ks[i];\n  }\n  vector<LL> s(M), acc(M+1);\n  REP(i,M){\n\tcin >> s[i];\n\tacc[i+1] = acc[i] + s[i];\n  }\n  SORT(ks);\n  LL ans = 0;\n  REP(i,N-1) ans += (acc[ks[i+1]+1] - acc[ks[i]]) / L;\n  ans += (acc[ks.back()+1] - acc[ks[0]]) / L;\n  //cout << ans << endl;\n  //cout << naive(ks, acc, L) << endl;\n\n  FOR(i,1,N-1){\n\tLL sum = 0;\n\tREP(j,i-1) sum += (acc[ks[j+1]+1] - acc[ks[j]]) / L;\n\tsum += (acc[ks[i+1]+1] - acc[ks[i-1]]) / L;\n\tFOR(j,i+1,N-1) sum += (acc[ks[j+1]+1] - acc[ks[j]]) / L;\n\tsum += (acc[ks.back()+1] - acc[ks[i]]) / L;\n\tsum += (acc[ks[i]+1] - acc[ks[0]]) / L;\n\tans = min(ans, sum);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n, m, l;\nint k[2000];\nint s[100000];\nint f[100000];\n\nll *sbuff;\nll *mbuff;\n\nll *sum[2000];\nll *memo[2000];\n\nvoid init(){\n  int nn = n * (n + 1) / 2;\n  sbuff = (ll*)malloc(sizeof(ll) * nn);\n  mbuff = (ll*)malloc(sizeof(ll) * nn);\n\n  REP(i,n) sum[i] = (ll*)&sbuff[i * (i + 1) / 2];\n  REP(i,n) memo[i] = (ll*)&mbuff[i * (i + 1) / 2];\n}\n\nll solve(int l, int r){\n  if(l < r) swap(l, r);\n  if(memo[l][r] != -1) return memo[l][r];\n\n  int next = max(l, r) + 1;\n  ll ret = 0;\n\n  if(next == n){\n    ret = sum[l][r];\n  }else{\n    ret = sum[next][l] + solve(next, r);\n    ret = min(ret, sum[next][r] + solve(l, next));\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &l);\n  REP(i,n){scanf(\"%d\", k+i); k[i]--;}\n  REP(i,m){scanf(\"%d\", s+i);}\n\n  sort(k, k+n);\n\n  init();\n\n  for(int i = 0; i < n; i++){\n    sum[i][i] = s[k[i]];\n    if(i != n - 1){\n      for(int j = k[i]; j <= k[i+1]; j++){\n\tsum[i+1][i] += s[j];\n      }\n    }\n  }\n  for(int len = 2; len < n; len++){\n    for(int i = 0; i + len < n; i++){\n      sum[i+len][i] = sum[i+1][i] + sum[i+len][i+1] - s[k[i+1]];\n    }\n  }\n\n  REP(i,n) REP(j,n) if(i >= j) sum[i][j] /= l;\n\n  // REP(i,n) { REP(j,n) printf(\"%3d \", (int)sum[i][j]); puts(\"\"); }\n  // REP(i,n) printf(\"%d (%d)\\n\", k[i], s[k[i]]);\n\n  REP(i,n) REP(j,n) if(i >= j) memo[i][j] = -1;\n\n  ll ans = solve(0, 0);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, l;\n  cin >> n >> m >> l;\n  VI k(n), s(m);\n  REP(i, n) cin >> k[i], k[i]--;\n  REP(i, m) cin >> s[i];\n\n  FOR(i, 1, m) {\n    s[i] += s[i-1];\n  }\n\n  auto sum = [&](int from, int to) {\n    return s[to] - (from >= 1 ? s[from-1] : 0);\n  };\n\n  sort(ALL(k));\n  int all = 0;\n  FOR(i, 1, n) {\n    int a = k[i-1], b = k[i];\n    if(a > b) swap(a, b);\n    all += sum(a, b)/l;\n  }\n\n  int ans = 0;\n  REP(i, n) FOR(j, i+1, n) {\n    // k[i], sort列, k[j] みたいな列\n    int ret = all;\n    if(i != 0) {\n      // マイナス s[k[i-1]] ~ s[k[i]], s[k[i]] ~ s[k[i+1]]\n      // プラス s[k[0]] ~ s[k[i]], s[k[i-1]] ~ s[k[i+1]]\n      ret -= sum(k[i-1], k[i])/l; ret -= sum(k[i], k[i+1])/l;\n      ret += sum(k[0], k[i])/l; ret += sum(k[i-1], k[i+1])/l;\n    }\n    if(j != n-1) {\n      ret -= sum(k[j-1], k[j])/l; ret -= sum(k[j], k[j+1])/l;\n      ret += sum(k[j], k[n-1])/l; ret += sum(k[j-1], k[j+1])/l; \n    }\n    ret += sum(k[i], k[j])/l;\n    chmax(ans, ret);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 2005;\nconst int MAXM = 100005;\n\nint N, M, L;\nint K[MAXN], S[MAXM];\nint dp[MAXN][MAXN];\n\ninline int sumS(int a, int b) {\n  if(a > b) swap(a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a-1];\n}\n\nint main() {\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n    }\n    for(int i = 1; i <= M; ++i) {\n      cin >> S[i];\n      if(i != 0) S[i] += S[i-1];\n    }\n    sort(K, K+N);\n    fill(dp[0], dp[MAXN], INF);\n    dp[0][0] = 0;\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        int k = max(i,j)+1;\n        if(k == N-1) {\n          dp[k][k] = min(dp[k][k],\n                         dp[i][j] + sumS(K[i],K[k])/L + sumS(K[j],K[k])/L);\n        } else {\n          dp[k][j] = min(dp[k][j], dp[i][j] + sumS(K[i], K[k])/L);\n          dp[i][k] = min(dp[i][k], dp[i][j] + sumS(K[j], K[k])/L);\n        }\n      }\n    }\n    cout << dp[N-1][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst long long inf = 123456789123456789;\nint main() {\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<int> A(N); vector<long long> B(M + 1);\n\tfor (int i = 0; i < N; ++i) cin >> A[i];\n\tfor (int i = 0; i < M; ++i) cin >> B[i + 1], B[i + 1] += B[i];\n\tsort(A.begin(), A.end());\n\tvector<vector<long long> > beauty(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tbeauty[i].resize(i);\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tbeauty[i][j] = (B[A[i]] - B[A[j] - 1]) / L;\n\t\t}\n\t}\n\tvector<long long> dp = { beauty[1][0] };\n\tfor (int i = 2; i < N - 1; ++i) {\n\t\tvector<long long> ndp(i, inf);\n\t\tfor (int j = 0; j < i - 1; ++j) {\n\t\t\tndp[j] = min(ndp[j], dp[j] + beauty[i][i - 1]);\n\t\t\tndp[i - 1] = min(ndp[i - 1], dp[j] + beauty[i][j]);\n\t\t}\n\t\tdp = ndp;\n\t}\n\tlong long ans = inf;\n\tfor (int i = 0; i < N - 2; ++i) {\n\t\tans = min(ans, dp[i] + beauty[N - 1][N - 2] + beauty[N - 1][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 171019.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<int>K(N),S(M);\n\tfor (int i = 0; i < N; i++)cin >> K[i];\n\tfor (int i = 0; i < M; i++)cin >> S[i];\n\tsort(K.begin(), K.end());\n\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint cK = K[i];\n\t\tint nK = K[(i + 1) % N];\n\t\tif (nK < cK)swap(cK, nK);\n\t\tint sum = 0;\n\t\tfor (int j = cK - 1; j < nK; j++) {\n\t\t\tsum += S[j];\n\t\t}\n\n\t\tans += floor(1.*sum/L);\n\t}\n\n\tcout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint calc_power(const vector<int>& ss,const int p,const int n,const int L){\n    if(n < p) return calc_power(ss,n,p,L);\n    return (ss[n] - ss[p-1]) / L;\n}\n\nint solve(int ii,int ui,int di,vector<int>& ss,vector<int>& k,const int L,vector<vector<int>>& memo){\n    if(ui > di) return solve(ii,di,ui,ss,k,L,memo);\n    if(memo[ui][di] >= 0) return memo[ui][di];\n    int u = k[ui];\n    int d = k[di];\n    int i = k[ii];\n    if(ii == k.size()-1){\n        return memo[ui][di] = calc_power(ss,u,i,L) + calc_power(ss,d,i,L);\n    }else{\n        return memo[ui][di] = min(calc_power(ss,u,i,L) + solve(ii+1,ii,di,ss,k,L,memo),\n                                  calc_power(ss,d,i,L) + solve(ii+1,ui,ii,ss,k,L,memo));\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N,M,L;\n    cin >> N >> M >> L;\n\n    vector<int> K(N);\n    vector<int> S(M);\n    vector<vector<int> > memo(N,vector<int>(N,-1));\n    for(int& i : K) cin >> i;\n    sort(all(K));\n    for(int& i : S) cin >> i;\n\n    vector<int> SS(M+1);\n    for(int i=1;i<SS.size();i++){\n        SS[i] = SS[i-1] + S[i-1];\n    }\n    cout << solve(1,0,0,SS,K,L,memo) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nll n, m, l;\nll a[2000];\nll b[100000];\nll s[100010];\nll dp[2000][2000];\n\nll sum(ll i, ll j){\n  return (s[max(i, j) + 1] - s[min(i, j)]) / l;\n}\n\nll dfs(ll i, ll j){\n  if (i == n) return sum(a[i - 1], a[j]);\n  if (~dp[i][j]) return dp[i][j];\n  ll vl = sum(a[i - 1], a[i]) + dfs(i + 1, j);\n  ll vr = sum(a[j], a[i]) + dfs(i + 1, i - 1);\n  return dp[i][j] = min(vl, vr);\n}\n\nint main(){\n  cin >> n >> m >> l;\n  rep(i, n) cin >> a[i], a[i]--;\n  rep(i, m) cin >> b[i];\n  rep(i, m) s[i + 1] = s[i] + b[i];\n  sort(a, a + n);\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(1, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,l;\nvi in,dp;\nvvi mm;\nint f(int a,int b){\n\tif(mm[a][b]+1)return mm[a][b];\n\tif(b==n-1)return mm[a][b]=(dp[in[n-1]]-dp[in[a]-1])/l;\n\treturn mm[a][b]=min(f(a,b+1)+(dp[in[b+1]]-dp[in[b]-1])/l,f(b,b+1)+(dp[in[b+1]]-dp[in[a]-1])/l);\n}\nint main(){\n\tcin>>n>>m>>l;\n\tmm=vvi(n,vi(n,-1));\n\tin=vi(n);\n\tdp=vi(m+1);\n\trep(i,n)cin>>in[i];\n\trep(i,m)cin>>dp[i+1];\n\trep(i,m)dp[i+1]+=dp[i];\n\tsort(all(in));\n\tcout<<f(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1000000000000000000ll;\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        int N, M, L;\n        cin >> N >> M >> L;\n        vector<ll> K(N);\n        for(int i = 0; i < N; ++i){\n                cin >> K[i];\n                --K[i];\n        }\n        sort(K.begin(), K.end());\n        vector<ll> S(M);\n        for(int i = 0; i < M; ++i){ cin >> S[i]; }\n        vector<ll> Si(M + 1);\n        for(int i = 1; i <= M; ++i){ Si[i] = Si[i - 1] + S[i - 1]; }\n        vector< vector<ll> > dp(N + 1, vector<ll>(N + 1, INF));\n        dp[0][0] = 0;\n        for(int i = 0; i < N - 1; ++i){\n                for(int j = 0; j <= i; ++j){\n                        ll head = dp[i][j] + (Si[K[i + 1] + 1] - Si[K[i]]) / L;\n                        dp[i + 1][j] = min(dp[i + 1][j], head);\n                        ll tail = dp[i][j] + (Si[K[i + 1] + 1] - Si[K[j]]) / L;\n                        dp[i + 1][i] = min(dp[i + 1][i], tail);\n                }\n        }\n        ll answer = INF;\n        for(int i = 0; i < N - 1; ++i){\n                answer = min(answer, dp[N - 1][i] + (Si[K[N - 1] + 1] - Si[K[i]]) / L);\n        }\n        cout << answer << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll INF=(1LL<<50);\nint N,M,L;\nint t[2000];\nll u[100005];\nll dp[2001][2001];\n\nll calc(int a,int b){\n  if(a>b)swap(a,b);\n  return (u[b]-u[a-1])/(ll)L;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++)scanf(\"%d\",&t[i]);\n  sort(t,t+N);\n  \n  for(int i=1;i<=M;i++){\n    scanf(\"%lld\",&u[i]);\n    u[i]+=u[i-1];\n  }\n  ll ans=INF;\n  fill(dp[0],dp[2001],INF);\n  dp[0][0]=0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(dp[i][j]==INF)continue;\n      int k=max(i,j)+1;\n      if(k<N){\n        dp[k][j]=min(dp[k][j],dp[i][j]+calc(t[i],t[k]));\n        dp[i][k]=min(dp[k][i],dp[i][j]+calc(t[j],t[k]));\n      }else{\n        ans=min(ans,dp[i][j]+calc(t[N-1],t[min(i,j)]));\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint n, m, l;\nint k[2000];\nll s[100010];\n\nint main()\n{\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> k[i];\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tcin >> s[i];\n\t\ts[i] += s[i - 1];\n\t}\n\t\n\tsort(k, k + n);\n\tll a = k[0], b = k[0], res = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tll u = (s[k[i]] - s[a - 1]) / l;\n\t\tll v = (s[k[i]] - s[b - 1]) / l;\n\t\tif (i == n - 1){\n\t\t\tres += u + v;\n\t\t}\n\t\telse if (u < v){\n\t\t\tres += u;\n\t\t\ta = k[i];\n\t\t}\n\t\telse {\n\t\t\tres += v;\n\t\t\tb = k[i];\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nint64_t F[2001];\nint N,M;\nint64_t L;\n\nint64_t f(int a, int b){\n    return (F[b+1]-F[a])/L;\n}\n\nint main(){\n    cin>>N>>M>>L;\n    vector<int64_t> K(N),S(M);\n    for(auto &k:K)cin>>k;\n    for(auto &s:S)cin>>s;\n    for(int i=0;i<M;i++){\n        F[i+1]=F[i]+S[i];//(a,b)????????????=(F[b+1]-F[a])/L\n    }\n    sort(K.begin(), K.end());\n    for(auto &k:K)k--;\n    int64_t DP[N][N];\n    fill(DP[0],DP[N],100000000);\n    DP[0][0]=0;\n    DP[1][0]=f(K[0],K[1]);\n    for(int i=1;i<N;i++){\n        for(int j=0;j<i-1;j++){\n            DP[i][j]=DP[i-1][j]+f(K[i-1],K[i]);\n        }\n        for(int k=0;k<i-1;k++){\n            DP[i][i-1]=min(DP[i][i-1],DP[i-1][k]+f(K[k],K[i]));\n        }\n    }\n    int64_t ans = 100000000;\n    for(int i=0;i<N-1;i++){\n        ans=min(ans,DP[N-1][i]+f(K[i],K[N-1]));\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[2010];\nint S[2010];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n\n  if(a < 0){\n    cerr << \"a < 0\" << endl;\n    assert(false);\n  }\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n\n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 171019.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<int>K(N),S(M);\n\tfor (int i = 0; i < N; i++)cin >> K[i];\n\tfor (int i = 0; i < M; i++)cin >> S[i];\n\tsort(K.begin(), K.end());\n\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint cK = K[i];\n\t\tint nK = K[(i + 1) % N];\n\t\tif (nK < cK)swap(cK, nK);\n\t\tint sum = 0;\n\t\tfor (int j = cK - 1; j < nK; j++) {\n\t\t\tsum += S[j];\n\t\t}\n\n\t\tans += floor(1.*sum/L);\n\t}\n\n\tcout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <numeric>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1ll<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, l;\n\nint main(){\n\twhile(~scanf(\"%d%d%d\", &n, &m, &l)){\n\t\tvector<ll> K(n), S(m), sum(m+1);\n\t\tREP(i, n) scanf(\"%lld\", &K[i]), K[i]--;\n\t\tREP(i, m) scanf(\"%lld\", &S[i]);\n\t\tsort(ALL(K));\n\t\tK.push_back(K.back()); ++n;\n\t\tpartial_sum(ALL(S), sum.begin()+1);\n\t\tvector<vector<ll>> dp(n+1, vector<ll>(n+1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, n)REP(j, i){\n\t\t\tdp[i][j]   = min(dp[i][j]  , dp[i-1][j] + (sum[K[i]+1] - sum[K[i-1]])/l);\n\t\t\tdp[i][i-1] = min(dp[i][i-1], dp[i-1][j] + (sum[K[i]+1] - sum[K[j]])/l);\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[n-1][n-2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\t//if(vec[a].first > vec[b].first) swap(a, b);\n\t//return (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n\treturn (cum[K[a]] - cum[K[b]-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\t//sort(vec, vec+n);\n\t//reverse(vec, vec+n);\n\tsort(K, K+n);\n\treverse(K, K+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tint h = max(i, j) + 1;\n\t\t\t//dp[i+1][j] = min(dp[j][i+1], dp[i][j] + calc(i, i+1));\n\t\t\t//dp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(j, i+1));\n\t\t\tdp[h][j] = min(dp[j][h], dp[i][j] + (cum[K[i]] - cum[K[h]-1]) / l);\n\t\t\tdp[h][i] = min(dp[h][i], dp[i][j] + (cum[K[j]] - cum[K[h]-1]) / l);\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\t//ans = min(ans, dp[n-1][i] + calc(n-1, i));\n\t\tans = min(ans, dp[n-1][i] + (cum[K[i]] - cum[K[n-1]-1]) / l);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 4005\ntypedef pair<ll,int> P;\nll INF=1000000000000000000LL;\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\n\nll min_cost_flow(int s,int t,int f){\n  ll res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==INF)continue;\n        for(int i=0;i< (int) G[v].size();i++){\n          edge &e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve [e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\n\nint N,M,L;\nint t[2000];\nll u[100005];\n\nll calc(int a,int b){\n  if(a>b)swap(a,b);\n  return (u[b]-u[a-1])/(ll)L;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++)scanf(\"%d\",&t[i]);\n  sort(t,t+N);\n  \n  for(int i=1;i<=M;i++){\n    scanf(\"%lld\",&u[i]);\n    u[i]+=u[i-1];\n  }\n  \n  ll D=10000000000LL;\n  for(int i=1;i<N-1;i++)add_edge(i,N+i,1,-D);\n\n  for(int i=0;i<N;i++){\n    for(int j=i+1;j<N;j++){\n      ll key=calc(t[i],t[j]);\n      add_edge(N+i,j,1,key);\n    }\n  }\n  V=N+N;\n  cout<<min_cost_flow(N,N-1,2)+D*(N-2)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint n, m, l;\nvector<long long> k, imos;\nlong long cost(int i, int j) {\n    return (imos[k[min(j, n)]] - imos[k[max(i, 1)] - 1]) / l;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    k.resize(n + 1);\n    k[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> k[i + 1];\n    }\n    vector<int> s(m);\n    imos.resize(m + 1, 0);\n    for (int i = 0; i < m; ++i) {\n        cin >> s[i];\n        imos[i + 1] = imos[i] + s[i];\n    }\n    sort(k.begin(), k.end());\n    vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, (long long)1e16));\n    vector<long long> mi(n + 1, (long long)1e16);\n    dp[0][0] = cost(1, n);\n    for (int i = 1; i < n; ++i) {\n        dp[0][0] += cost(i, i + 1);\n    }\n    mi[0] = dp[0][0];\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i - 1; ++j) {\n            dp[i][1] = min(dp[i][1], mi[j] - cost(i - 1, i) - cost(i, i + 1) + cost(i - 1, i + 1) - cost(j, n) + cost(j, i) + cost(i, n));\n            mi[i] = min(mi[i], dp[i][1]);\n        }\n        for (int j = 2; j <= i; ++j) {\n            dp[i][j] = dp[i - 1][j - 1] - cost(i - j, i) - cost(i, i + 1) + cost(i - j, i + 1) - cost(i - 1, n) + cost(i - 1, i) + cost(i, n);\n            mi[i] = min(mi[i], dp[i][j]);\n        }\n    }\n    long long ans = mi[0];\n    for (long long i : mi) {\n        ans = min(ans, i);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nll dp[2100][2100];\nll sum[1000100];\nint N, M, L;\nvector<ll> K;\nvector<ll> S;\nconst ll INF = 1e15;\n\nll gauss(ll a, ll l) {\n\treturn a/l;\n}\n\nll solve(int a, int b) {\n\t// a, b ???????????§?????°\n\tif(dp[a][b]+1)\n\t\treturn dp[a][b];\n\tif(a == b)\n\t\treturn dp[a][b] = INF;\n\n\tll res = INF;\n\tif(abs(a-b) == 1) {\n\t\tfor(int i = 1; i < min(a,b); i++) {\n\t\t\tif(a > b)\n\t\t\t\tres = min(res, solve(i,b) + gauss(sum[K[a-1]] - sum[K[i-1]-1], L));\n\t\t\telse\n\t\t\t\tres = min(res, solve(a,i) + gauss(sum[K[b-1]] - sum[K[i-1]-1], L));\n\t\t}\n\t}\n\telse {\n\t\tif(a > b)\n\t\t\tres = min(res, solve(a-1,b) + gauss(sum[K[a-1]]-sum[K[a-2]-1], L));\n\t\telse\n\t\t\tres = min(res, solve(a,b-1) + gauss(sum[K[b-1]]-sum[K[b-2]-1], L));\n//\t\tcout << a << \",\" << b << \" \"<< K[max(a,b)-1] << \",\" << K[max(a,b)-2] << \" \" << res << endl;\n\t}\n\treturn dp[a][b] = res;\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tK.resize(N); S.resize(M);\n\tfor(int i = 0; i < N; i++)\n\t\tcin >> K[i];\n\tfor(int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\n\tfor(int i = 0; i < 2100; i++)\n\t\tfor(int j = 0; j < 2100; j++)\n\t\t\tdp[i][j] = -1;\n\tfor(int i = 0; i < S.size(); i++)\n\t\tsum[i+1] = S[i]+sum[i];\n\n\tll res = INF;\n\tsort(K.begin(), K.end());\n\tdp[1][1] = 0;\n\tdp[1][2] = dp[2][1] = gauss(sum[K[1]]-sum[K[0]-1],L);\n\tfor(int i = 1; i < N; i++) {\n\t\tres = min(res, solve(i,N) + gauss(sum[K[N-1]]-sum[K[i-1]-1],L));\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (bit & (1LL << i))\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<typename T> using VVVV = std::vector<std::vector<std::vector<std::vector<T>>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nclass CumulativeSum {\n\npublic:\n    std::vector<long long> memo1;               // 1次元用の累積和表\n    std::vector<std::vector<long long>> memo2;  // 2次元用の累積和表\n\n    CumulativeSum() {}\n\n    void build(const std::vector<long long> &line) {\n        this->memo1.assign(line.size() + 1, 0);\n\n        for (long long i = 0; i < line.size(); ++i) {\n            this->memo1[i + 1] = this->memo1[i] + line[i];\n        }\n    }\n\n    // 2次元の累積和表を作成\n    void build(const std::vector<std::vector<long long>> &board) {\n        int height = board.size();\n        int width = board[0].size();\n        this->memo2.assign(height + 1, std::vector<long long>(width + 1, 0));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] = board[y][x] + memo2[y + 1][x];\n            }\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] += memo2[y][x + 1];\n            }\n        }\n    }\n\n    long long sum(int left, int right) {\n        assert(left < right);\n        return this->memo1[right] - this->memo1[left];\n    }\n\n    /*\n    (y1, x1)から(y2, x2)の合計を返す．(y2, x2)は含まない\n    座標はmemoを作成したboard準拠\n    (ex, sum(0, 0, 2, 2)なら(0, 0), (0, 1), (1, 0), (1, 1)の合計を返す)\n    */\n    long long sum(int y1, int x1, int y2, int x2) {\n        return this->memo2[y2][x2] - this->memo2[y2][x1] - this->memo2[y1][x2] + this->memo2[y1][x1];\n    }\n};\n\n\nLL dfs(int left, int right, int N, int L, V<int> &K, CumulativeSum &cost, VV<LL> &dp) {\n    int next = max(left, right) + 1;\n\n    if (dp[left][right] != -1) {\n        return dp[left][right];\n    }\n\n    if (next == N - 1) {\n        return (cost.sum(K[left], K[next] + 1) / L) + (cost.sum(K[right], K[next] + 1) / L);\n    }\n\n    LL ans = LONG_LONG_MAX;\n\n    // leftにいれる\n    ans = min(ans, dfs(next, right, N, L, K, cost, dp) + (cost.sum(K[left], K[next] + 1) / L));\n    // rightにいれる\n    ans = min(ans, dfs(left, next, N, L, K, cost, dp) + (cost.sum(K[right], K[next] + 1) / L));\n\n    return dp[left][right] = ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M, L;\n    cin >> N >> M >> L;\n    V<int> K(N);\n    V<LL> S(M);\n    FOR(i, 0, N) {\n        cin >> K[i];\n        K[i]--;\n    }\n    sort(ALL(K));\n\n    FOR(i, 0, M) {\n        cin >> S[i];\n    }\n\n    CumulativeSum cs;\n    cs.build(S);\n\n    VV<LL> dp(N + 1, V<LL>(N + 1, -1));\n    print(dfs(0, 0, N, L, K, cs, dp));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nsigned main() {\n    int n, m, l, inp; cin >> n >> m >> l;\n    int k[100010] = {}, s[100010] = {};\n    vector<pii> v;\n\n    rep(i,0,n) {\n        cin >> inp;\n        s[inp]++;\n    }\n\n    rep(i,0,m) {\n        cin >> k[i+1];\n        v.pb(pii(k[i+1], i+1));\n        k[i+1] += k[i];\n    }\n    sort(v.begin(), v.end(), greater<pii>());\n\n    deque<int> arr;\n    int d = 1;\n    rep(i,0,m) {\n        while(s[ v[i].sc ]) {\n            if(d) arr.pb(v[i].sc);\n            else arr.push_front(v[i].sc);\n            s[ v[i].sc ]--;\n            d = 1 - d;\n        }\n    }\n\n    int ans = 0;\n    rep(i,0,n) {\n        // printf(\"arr[%lld] = %lld\\n\", i, arr[i]);\n        int mi = min(arr[(i+1) % n], arr[i]) - 1;\n        int ma = max(arr[(i+1) % n], arr[i]);\n        // cout << k[ma] - k[mi] << endl;\n        ans += (k[ma] - k[mi]) / l;\n    }\n    cout << ans << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll n,m,L;\nvl a,s;\n\nll f(int l,int r){\n\treturn (s[r]-s[l-1])/L;\n}\n\nint main(){\n\tcin>>n>>m>>L;\n\ta=vl(n);\n\ts=vl(m+1);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>s[i];\n\t\ts[i]+=s[i-1];\n\t}\n\tsort(a.begin(),a.end());\n\tvvl dp(n,vl(n));\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(i!=j){\n\t\tif(abs(i-j)==1){\n\t\t\tll tmp=INF;\n\t\t\tif(i>j){\n\t\t\t\tfor(int k=0;k<i-(i==1?0:1);k++) tmp=min(tmp,dp[k][j]+f(a[k],a[i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int k=0;k<j-(j==1?0:1);k++) tmp=min(tmp,dp[i][k]+f(a[k],a[j]));\n\t\t\t}\n\t\t\tdp[i][j]=tmp;\n\t\t}\n\t\telse{\n\t\t\tif(i>j) dp[i][j]=dp[i-1][j]+f(a[i-1],a[i]);\n\t\t\telse dp[i][j]=dp[i][j-1]+f(a[j-1],a[j]);\n\t\t}\n\t}\n\tll res=INF;\n\tfor(int i=0;i<n-1;i++) res=min(res,dp[n-1][i]+f(a[i],a[n-1]));\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2000;\nconst lli M = 1e5;\nconst lli INF = 1 << 28;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n-2;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\tdp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n, m, l; cin >> n >> m >> l;\n\tvl k(n); REP(i, n) cin >> k[i];\n\tvl s(m); REP(i, m) cin >> s[i];\n\n\tvl sum(m + 1); sum[0] = 0;\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\n\tsort(ALL(k));\n\tvvl dp(2, vl((n - 1) * 2 + 1, TEN(13)));\n\tdp[0][n - 1] = 0;\n\tll ans = TEN(13);\n\tFOR(i, 1, n) {\n\t\tREP(j, (n - 1) * 2 + 1) dp[i % 2][j] = TEN(13);\n\t\tREP(j, (n - 1) * 2 + 1) {\n\t\t\tll j_zero = j - (n - 1);\n\t\t\tll times = abs(j_zero);\n\t\t\tif (times >= i || dp[(i - 1) % 2][j] == TEN(13)) continue;\n\t\t\tif (i == n - 1) {\n\t\t\t\tMINC(\n\t\t\t\t\tans,\n\t\t\t\t\tdp[(i - 1) % 2][j]\n\t\t\t\t\t+ (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t\t\t+ (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tMINC(\n\t\t\t\t\tdp[i % 2][(n - 1) + (j_zero <= 0 ? 1 : -1)],\n\t\t\t\t\tdp[(i - 1) % 2][j] + (sum[k[i]] - sum[k[i - 1 - times] - 1]) / l\n\t\t\t\t); // ???\n\t\t\t\tMINC(\n\t\t\t\t\tdp[i % 2][j + (j_zero <= 0 ? -1 : 1)],\n\t\t\t\t\tdp[(i - 1) % 2][j] + (sum[k[i]] - sum[k[i - 1] - 1]) / l\n\t\t\t\t); // ??£?¶?\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m, l; cin >> n >> m >> l;\n  vi k(n), s(m);\n  for(int i=0;i<n;++i) {\n    cin >> k[i];\n    k[i]--;\n  }\n  sort(k.begin(), k.end());\n  for(int i=0;i<m;++i) {\n    cin >> s[i];\n  }\n  vll su(m+1);\n  for(int i=0;i<m;++i) {\n    su[i+1] = su[i] + s[i];\n  }\n  vvll dp(n, vll(n, LINF));\n  dp[0][0] = 0;\n  for(int i=0;i<n-1;++i) {\n    for(int j=0;j<n;++j) {\n      if(dp[i][j] == INF) continue;\n      dp[i+1][i] = min(dp[i+1][i], dp[i][j] + (su[k[i+1]+1] - su[k[j]]) / l);\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (su[k[i+1]+1] - su[k[i]]) / l);\n    }\n  }\n  ll ans = LINF;\n  for(int i=0;i<n;++i) {\n    ans = min(ans, dp[n-1][i] + (su[k[n-1]+1] - su[k[i]]) / l);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\ntypedef pair< int , Pi > Pii;\nconst int64 INF = 1LL << 53;\n\nint64 N, M, L, K[2000], S[100000];\nint64 dp[2000][2000];\nint64 get_Sum(int a, int b){\n  if(a > b) swap( a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a - 1];\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return get_Sum( K[right], K[left]) / L;\n  if(~dp[right][left]) return dp[right][left];\n  int64 ret = INF;\n  ret = min( ret, rec( idx + 1, idx, left) + get_Sum( K[right], K[idx]) / L);\n  ret = min( ret, rec( idx + 1, right, idx) + get_Sum( K[left], K[idx]) / L);\n  return dp[right][left] = ret;\n}\n\nint main(){\n  fill_n( *dp, 2000 * 2000, -1);\n  scanf(\"%lld %lld %lld\", &N, &M, &L);\n  for(int i = 0; i < N; i++){\n    scanf(\"%lld\", &K[i]); --K[i];\n  }\n  for(int i = 0; i < M; i++){\n    scanf(\"%lld\", &S[i]);\n    if(i) S[i] += S[i - 1];\n  }\n  sort( K, K + N);\n  printf(\"%lld\\n\", rec( 1, 0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef pair<int,int> pii;\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    int64_t l;\n    cin >> n >> m >> l;\n    vector<int64_t> k(n),s(m);\n    vector<int64_t> sum(m);\n    rep(i,0,n){\n        cin >> k[i];\n        --k[i];\n    }\n    rep(i,0,m){\n        cin >> s[i];\n        sum[i]=s[i];\n        if(i>0) sum[i]+=sum[i-1];\n    }\n    sort(k.begin(),k.end());\n\n    auto calc_sum=[&sum](int l,int r){\n        int64_t res=sum[r];\n        if(l>0) res-=sum[l-1];\n        return res;\n    };\n\n    vector<vector<int64_t>> memo(n,vector<int64_t>(n,inf64));\n    vector<vector<bool>> done(n,vector<bool>(n));\n    function<int64_t(int,int)> rec=[&](int p,int q){\n        if(done[p][q]) return memo[p][q];\n        done[p][q]=true;\n        int next=max(p,q)+1;\n        if(next==n-1) return memo[p][q]=calc_sum(k[p],k[n-1])/l+calc_sum(k[q],k[n-1])/l;\n        int64_t res=inf64;\n        if(p<next) res=min(res,rec(next,q)+calc_sum(k[p],k[next])/l);\n        if(q<next) res=min(res,rec(p,next)+calc_sum(k[q],k[next])/l);\n        return memo[p][q]=res;\n    };\n    cout << rec(0,0) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nll n, m, l;\nll a[2000];\nll b[100000];\nll s[100010];\nll dp[2000][2000];\n\nll sum(ll i, ll j){\n  return (s[max(i, j) + 1] - s[min(i, j)]) / l;\n}\n\nll dfs(ll i, ll j){\n  if (i == n) return sum(a[i - 1], j);\n  if (~dp[i][j]) return dp[i][j];\n  ll vl = sum(a[i - 1], a[i]) + dfs(i + 1, j);\n  ll vr = sum(j, a[i]) + dfs(i + 1, a[i - 1]);\n  return dp[i][j] = min(vl, vr);\n}\n\nint main(){\n  cin >> n >> m >> l;\n  rep(i, n) cin >> a[i], a[i]--;\n  rep(i, m) cin >> b[i];\n  rep(i, m) s[i + 1] = s[i] + b[i];\n  sort(a, a + n);\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(1, a[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nint64_t F[100001];\nint N,M;\nint64_t L;\n\nint64_t f(int a, int b){\n    return (F[b+1]-F[a])/L;\n}\n\nint main(){\n    cin>>N>>M>>L;\n    vector<int64_t> K(N),S(M);\n    for(auto &k:K)cin>>k;\n    for(auto &s:S)cin>>s;\n    for(int i=0;i<M;i++){\n        F[i+1]=F[i]+S[i];//(a,b)????????????=(F[b+1]-F[a])/L\n    }\n    sort(K.begin(), K.end());\n    for(auto &k:K)k--;\n    int64_t DP[2][N];\n    fill(DP[0],DP[2],1000000000000);\n    DP[0][0]=0;\n    DP[1][0]=f(K[0],K[1]);\n    for(int i=1;i<N;i++){\n        for(int j=0;j<i-1;j++){\n            DP[i&1][j]=DP[i&1^1][j]+f(K[i-1],K[i]);\n        }\n        for(int k=0;k<i-1;k++){\n            DP[i&1][i-1]=min(DP[i&1][i-1],DP[i&1^1][k]+f(K[k],K[i]));\n        }\n    }\n    int64_t ans = 1000000000000;\n    for(int i=0;i<N-1;i++){\n        ans=min(ans,DP[N&1^1][i]+f(K[i],K[N-1]));\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 2222;\nconst int MAXM = 100100;\nconst ll INF = 1ll<<60;\nint K[MAXN], S[MAXM];\nll sum[MAXM];\n\nll dp[MAXN][MAXN];\nint N, M, L;\n\nll dfs(int lp, int rp) {\n\tll& ret = dp[lp][rp];\n\tif (ret >= 0) return ret;\n\tif (min(lp, rp) == 0) {\n\t\tint maxi = max(lp, rp), mini = min(lp, rp);\n\t\treturn ret = (sum[K[maxi]+1] - sum[K[mini]]) / L;\n\t}\n\tint now = min(lp, rp)-1;\n\tret = (sum[K[lp]+1]-sum[K[now]])/L + dfs(now, rp);\n\tret = min(ret, (sum[K[rp]+1]-sum[K[now]])/L + dfs(lp, now));\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> L;\n    for (int i = 0; i < N; i++) {\n    \tcin >> K[i];\n    \tK[i]--;\n    }\n    sort(K, K+N);\n    for (int i = 0; i < M; i++)\n    \tcin >> S[i];\n    for (int i = 0; i < M; i++) {\n    \tsum[i+1] = sum[i] + S[i];\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << dfs(N-1, N-2) + (sum[K[N-1]+1]-sum[K[N-2]])/L << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int64_t INF = INT64_C(1000000000000000000);\n\nint main() {\n  int n,m,l;\n  cin>>n>>m>>l;\n  vector<int> vk(n);\n  REP(i,n) cin>>vk[i];\n  vector<int64_t> vs(m);\n  REP(i,m) cin>>vs[i];\n  vector<int64_t> pss(m+1);\n  partial_sum(ALL(vs), begin(pss)+1);\n  sort(ALL(vk));\n  vector<vector<int64_t>> dp(n, vector<int64_t>(n, INF));\n  dp[0][0] = 0;\n  REP(i,n-1) {\n    REP(j,max(1,i)) {\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (pss[vk[i+1]] - pss[vk[i]-1])/l);\n      dp[i+1][i] = min(dp[i+1][i], dp[i][j] + (pss[vk[i+1]] - pss[vk[j]-1])/l);\n    }\n  }\n  int64_t res = INF;\n  REP(i,n-1) {\n    res = min(res, dp[n-1][i] + (pss[vk[n-1]] - pss[vk[i]-1])/l);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nint main()\n{\n    ll N, M, L;\n    cin >> N >> M >> L;\n    uniform_int_distribution<ll> kdist{1, M};\n    vector<ll> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n        K[i]--;\n    }\n    vector<ll> S(M);\n    vector<ll> sum(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n        sum[i] = ((i > 0) ? sum[i - 1] : 0) + S[i];\n    }\n    sort(K.begin(), K.end());\n    vector<vector<ll>> dist(N, vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ll l = min(K[i], K[j]);\n            ll r = max(K[i], K[j]);\n            dist[i][j] = (sum[r] - ((l > 0) ? sum[l - 1] : 0)) / L;\n        }\n    }\n    vector<ll> dsum(N);\n    dsum[0] = 0;\n    for (int i = 1; i < N; i++) {\n        dsum[i] = dsum[i - 1] + dist[i - 1][i];\n    }\n    //    show(dist);\n    constexpr ll INF = 1LL << 60;\n    vector<vector<ll>> dp(N, vector<ll>(N, INF));\n    for (int i = 0; i < N; i++) {\n        dp[0][i] = dist[0][i];\n        dp[i][0] = dist[i][0];\n    }\n    for (int i = 1; i < N - 1; i++) {\n        for (int j = 1; j < N - 1; j++) {\n            if (i == j) {\n                continue;\n            }\n            if (j < i) {\n                dp[j][i] = dp[i][j];\n            } else if (i < j) {\n                dp[i][j] = min(dp[i - 1][j] + dist[i - 1][i], dp[i][i - 1] + dist[i - 1][j]);\n            }\n        }\n    }\n    //    show(dp);\n    for (int i = 0; i < N - 2; i++) {\n        dp[N - 1][N - 1] = min(dp[N - 1][N - 1], dp[i][i + 1] + dsum[N - 1] - dsum[i + 1] + dist[i][N - 1]);\n    }\n    cout << dp[N - 1][N - 1] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\nint main(){\n\tint n,m,L; scanf(\"%d%d%d\",&n,&m,&L);\n\tint a[2002];\n\trep(i,n) scanf(\"%d\",a+i), a[i]--;\n\tstatic ll v[100001];\n\trep(i,m) scanf(\"%lld\",v+i+1), v[i+1]+=v[i];\n\n\ta[n]=*min_element(a,a+n); n++;\n\ta[n]=*max_element(a,a+n); n++;\n\tsort(a,a+n);\n\n\tstatic ll dp[2002][2002];\n\trep(i,n) rep(j,n) dp[i][j]=INF;\n\tdp[0][1]=0;\n\trep(i,n-1) rep(j,n-1) if(i!=j) {\n\t\tint next=max(i,j)+1;\n\t\tdp[next][j]=min(dp[next][j],dp[i][j]+abs(v[a[next]+1]-v[a[i]])/L);\n\t\tdp[i][next]=min(dp[i][next],dp[i][j]+abs(v[a[next]+1]-v[a[j]])/L);\n\t}\n\n\tprintf(\"%lld\\n\",dp[n-2][n-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define mz(x,y) x=min(x,y)\ntypedef long long ll;\nint K[2000],S[100000];\nll inf=1e17;\nll dp[2][2001];\nll sum[100001];\nvector<ll> ash;\nint N,M,L;\nll dis(int a,int b){\n\tif(a>b) return inf;\n\treturn (sum[ash[b]+1]-sum[ash[a]])/L;\n}\nint main(){\n\tcin>>N>>M>>L;\n\trep(i,N) cin>>K[i];\n\trep(i,N) K[i]--;\n\trep(i,N) ash.pb(K[i]);\n\tsort(all(ash));\n\tash.erase(unique(all(ash)),ash.end());\n\trep(i,N) K[i]=lower_bound(all(ash),K[i])-ash.begin();\n\trep(i,M) cin>>S[i];\n\trep(i,M) sum[i+1]=sum[i]+S[i];\n\tsort(K,K+N);\n\tM=ash.size();\n\trep(j,M+1) dp[0][j]=inf;\n\tdp[0][0]=0;\n\trep(i,N-1){\n\t\trep(j,M+1) dp[1-i%2][j]=inf; \n\t\trep(j,M){\n\t\t\tmz(dp[1-i%2][j],dp[i%2][j]+dis(K[i],K[i+1]));\n\t\t\tmz(dp[1-i%2][K[i]],dp[i%2][j]+dis(j,K[i+1]));\n\t\t}\n\t}\n\tll ans=inf;\n\trep(j,M) mz(ans,dp[1-N%2][j]+dis(j,K[N-1]));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1LL << 40;\n\nlli n, m, L, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / L;\n}\n\nint main(){\n\tcin >> n >> m >> L;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n-2;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + calc(i+1, i));\n\t\t\tdp[i][i+1] = min(dp[i][i+1], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[j][i] + calc(i+1, j));\n\t\t\tdp[j][i+1] = min(dp[j][i+1], dp[j][i] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-2][i] + calc(n-1, n-2) + calc(n-1, i));\n\t\tans = min(ans, dp[i][n-2] + calc(n-1, i) + calc(n-1, n-2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#define range(i,a,b) assert(a<=i && i<=b)\nusing namespace std;\nint N, M, L;\nvector<int> K, S;\nlong long sumofS(int a, int b){\n\tlong long sum = 0;\n\tfor (int i = a; i < b + 1; i++){\n\t\trange(i,0,M-1);\n\t\tsum += S[i];\n\t}\n\treturn sum;\n}\nlong long solve(int n){\n\tif (n > 0){\n\t\tauto res = solve(n - 1);\n\t\trange(n,1,N-1);\n\t\treturn min((res + sumofS(K[n - 1] + 1, K[n]) / L)*L + sumofS(K[n - 1], K[n]),\n\t\t\tres + sumofS(K[n - 1] + 1, K[n]) + (sumofS(K[n - 1], K[n]) / L)*L);\n\t}\n\telse{\n\t\trange(K[0],0,M-1);\n\t\treturn S[K[0]];\n\t}\n}\nint main(){\n\tcin >> N >> M >> L;\n\tK = vector<int>(N);\n\tS = vector<int>(M);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\tsort(K.begin(), K.end());\n\tauto ans=(solve(N-1)/L);\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 4005\ntypedef pair<ll,int> P;\nll INF=1000000000000000000LL;\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll dist[MAX_V],h[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(ll from,ll to,ll cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\n\nll min_cost_flow(int s,int t,int f){\n  ll res=0;\n  fill(h,h+V,0);\n  fill(dist,dist+V,INF);\n  dist[s]=0;\n  bool update=true;\n  while(update){\n    update=false;\n    for(int v=0;v<V;v++){\n      if(dist[v]==INF)continue;\n      for(int i=0;i< (int) G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n          dist[e.to] = dist[v] + e.cost;\n          prevv[e.to] = v;\n          preve [e.to] = i;\n          update = true;\n        }\n      }\n    }\n  }\n  if(dist[t]==INF)return -1;\n  for(int v=0;v<V;v++)h[v]+=dist[v];\n\n  ll d=f;\n  for(int v=t;v!=s;v=prevv[v]){\n    d=min(d,G[prevv[v]][preve[v]].cap);\n  }\n  f-=d;\n  res+=d*dist[t];\n  for(int v=t;v!=s;v=prevv[v]){\n    edge &e = G[prevv[v]][preve[v]];\n    e.cap-=d;\n    G[v][e.rev].cap+=d;\n  }\n\n  while(f>0){\n\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n\n  return res;\n}\n\n\nint N,M,L;\nint t[2000];\nll u[100005];\n\nll calc(int a,int b){\n  if(a>b)swap(a,b);\n  return (u[b]-u[a-1])/(ll)L;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&L);\n  for(int i=0;i<N;i++)scanf(\"%d\",&t[i]);\n  sort(t,t+N);\n  \n  for(int i=1;i<=M;i++){\n    scanf(\"%lld\",&u[i]);\n    u[i]+=u[i-1];\n  }\n  \n  ll D=10000000000LL;\n  for(int i=1;i<N-1;i++)add_edge(i,N+i,1,-D);\n\n  for(int i=0;i<N;i++){\n    for(int j=i+1;j<N;j++){\n      ll key=calc(t[i],t[j]);\n      add_edge(N+i,j,1,key);\n    }\n  }\n  V=N+N;\n  cout<<min_cost_flow(N,N-1,2)+D*(N-2)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nll N,M,L;\nll S[111111];\nll K[111111];\nll rw[111111];\nll dp[2222][2222];\nll solve(int r,int l){\n  ll ret;\n  int no=max(r,l);\n  if(dp[r][l]!=-1) return dp[r][l];\n  if(r==N-1){\n    return dp[r][l]=(rw[K[r]]-rw[K[l]-1])/L;\n  } else if(l==N-1){\n    return dp[r][l]=(rw[K[l]]-rw[K[r]-1])/L;\n  }\n  ret=min(solve(r,no+1)+(rw[K[no+1]]-rw[K[l]-1])/L,\n\t  solve(no+1,l)+(rw[K[no+1]]-rw[K[r]-1])/L);\n  //printf(\"%lld\\n\",ret);\n  return dp[r][l]=ret;\n}\nmain(){\n  scanf(\"%lld %lld %lld\",&N,&M,&L);\n  for(int i=0;i<N;i++){\n    scanf(\"%lld\",&K[i]);\n  }\n  for(int i=0;i<M;i++){\n    scanf(\"%lld\",&S[i]);\n  }\n  memset(dp,-1,sizeof(dp));\n  for(int i=0;i<M;i++)\n    rw[i+1]=rw[i]+S[i];\n  sort(K,K+N);\n  printf(\"%lld\\n\",solve(0,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint64 N, M, L, K[2000], S[100000], dp[2000][2000];\n\nint64 Range(int a, int b) {\n  if(b < a) swap(a, b);\n  if(a == 0) return(S[b]);\n  return(S[b] - S[a - 1]);\n}\n\nint64 rec(int idx, int left, int right)\n{\n  if(idx == N) return(Range(K[left], K[right]) / L);\n  if(~dp[left][right]) return(dp[left][right]);\n  int64 A = rec(idx + 1, idx, right) + Range(K[idx], K[left]) / L;\n  int64 B = rec(idx + 1, left, idx) + Range(K[idx], K[right]) / L;\n  return(dp[left][right] = min(A, B));\n}\n\nint main()\n{\n  fill_n( *dp, 2000 * 2000, -1);\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> K[i];\n    --K[i];\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> S[i];\n    if(i > 0) S[i] += S[i - 1];\n  }\n  cout << rec(1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<int>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\twrite(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 2001;\nconst int MAX_M = 100001;\nint N, M, L, K[MAX_N], S[MAX_M];\n\n// sum[i] := s[i] + s[i+1] + ... + s[m-1];\nint sum[MAX_M] = {0};\n\n// 反発力 (s[a] + s[a+1] + ... + s[b]) / L を返す.\nint power(int a, int b){\n\tif( b < a ) swap(a,b);\n\treturn (sum[a] - sum[b+1]) / L;\n}\n\nint solve(){\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tsum[0] += S[i];\n\t}\n\tfor(int i=1 ; i < M ; i++ ){\n\t\tsum[i] = sum[i-1] - S[i-1];\n\t}\n\tsum[M] = 0;\n\t// sort(K,K+N);\n\tint res = 1e+8;\n\tfor(int k=0 ; k < 3000000 ; k++ ){\n\t\trandom_shuffle(K,K+N);\n\t\tint s = 0;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\ts += power( K[i] , K[(i+1)%N] );\n\t\t}\n\t\tres = min( res , s );\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> N >> M >> L;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor(int i=0 ; i < M ; i++ ){\n\t\tcin >> S[i];\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nint main() {\n    // input\n    int n, m, l; scanf(\"%d%d%d\", &n, &m, &l);\n    vector<int> k(n); repeat (i, n) { scanf(\"%d\", &k[i]); -- k[i]; }\n    vector<int> s(m); repeat (i, m) scanf(\"%d\", &s[i]);\n    // solve\n    sort(whole(k));\n    vector<ll> acc(1); partial_sum(whole(s), back_inserter(acc));\n    ll result = 0;\n    repeat (i, n) {\n        int a = k[i];\n        int b = k[(i + 1) % n];\n        if (a > b) swap(a, b);\n        result += (acc[b + 1] - acc[a]) / l;\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\n\nint N,M,L,v[2001],sum[100001],K[2001],dp[2001][100001];\n\nint func(int n,int p){\n\n  if(dp[n][p]>0)return dp[n][p];\n\n  if(n==N){\n    int b=max(K[p],K[1]);\n    int a=min(K[p],K[1]);\n    return (sum[b]-sum[a-1])/L;\n  }\n\n  int res=1000000000;\n  for(int i=1;i<=N;i++){\n    if(v[i]==0){\n      int a=min(K[i],K[p]),b=max(K[i],K[p]);\n      v[i]=1,res=min(res,func(n+1,K[i])+(sum[b]-sum[a-1])/L),v[i]=0;\n    }\n  }\n  return dp[n][p]=res;\n}\n\nint main(void){\n\n  cin >> N >> M >> L;\n\n  for(int i=1;i<=N;i++)cin >> K[i];\n  \n\n  for(int i=1;i<=M;i++){\n    cin >> sum[i];\n    sum[i]+=sum[i-1];\n  }\n\n  v[1]=1;\n  cout << func(1,K[1]) << endl;;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m, l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = max(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nll l;\nll dp[2222][2222];\nvi k, s, sum;\n\nll solve(int left, int right)\n{\n\tint t = max(left, right);\n\tint res;\n\tif (t == n - 2)\n\t{\n\t\tres = (sum[k[n-1]] - sum[k[left]-1])/l + (sum[k[n-1]] - sum[k[right]-1])/l;\n\t}\n\telse\n\t{\n\t\tres = min(solve(t + 1, right) + (sum[k[t+1]] - sum[k[left]-1]) / l, solve(left, t + 1) + (sum[k[t+1]] - sum[k[right]-1]) / l);\n\t}\n\treturn dp[left][right] = res;\n}\n\nint main()\n{\n\tcin >> n >> m >> l;\n\tk.resize(n), s.resize(m), sum.resize(m+1);\n\tREP(i, n) cin >> k[i];\n\tREP(i, m) cin >> s[i];\n\tsort(ALL(k));\n\tREP(i, m) sum[i + 1] = sum[i] + s[i];\n\tcout << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<int> k(n);\n    for(int i=0;i<n;i++){\n        cin>>k[i];\n        k[i]--;\n    }\n    sort(k.begin(),k.end());\n    vector<ll> s(m);\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    vector<ll> ssum(m+1);\n    ssum[0]=0;\n    for(int i=0;i<m;i++){\n        ssum[i+1]=ssum[i]+s[i];\n    }\n    ll res=0;\n    for(int i=0;i<n-1;i++){\n        res+=(ssum[k[i+1]]-ssum[k[i]]+s[k[i+1]])/l;\n    }\n    res+=(ssum[k[n-1]]-ssum[k[0]]+s[k[n-1]])/l;\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint K[2010];\nint S[2010];\nll dp[2010][2010];\nll SUM[201000];\n\nll sum(int a, int b, int L) {\n  int tmp = a;\n  a = min(a, b);\n  b = max(tmp, b);\n\n  if(a == 0){\n    cerr << \"a < 0\" << endl;\n    assert(false);\n  }\n  return (SUM[b] - SUM[a-1]) / L;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  REP(i, N) cin >> K[i];\n  REP(i, M) cin >> S[i];\n  REP(i, M) SUM[i+1] = SUM[i] + S[i];\n  sort(K, K + N);\n\n  cerr << N << \" \"  << M << \" \" << L << endl;\n  assert(false);\n  if(N == 1){\n    cout << 0 << endl;\n    return 0;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[1][0] = sum(K[0], K[1], L);\n  \n  \n  REP2(i, 1, N - 1){\n    REP(j, N){\n      if(dp[i][j] == -1) continue;\n      ll t1 = dp[i][j] + sum(K[i+1], K[i], L);\n      ll t2 = dp[i][j] + sum(K[i+1], K[j]  , L);\n      \n      if(dp[i+1][j] == -1 || dp[i+1][j] > t1){\n        dp[i+1][j] = t1;\n      }\n      if(dp[i+1][i] == -1 || dp[i+1][i] > t2){\n        dp[i+1][i] = t2;\n      }\n    }\n  }\n\n  ll ans = 1e15;\n  REP(i, N - 1) if(dp[N-1][i] != -1){\n    ans = min(dp[N-1][i] + sum(K[N-1], K[i], L), ans);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nint main()\n{\n    ll N, M, L;\n    cin >> N >> M >> L;\n    uniform_int_distribution<ll> kdist{1, M};\n    vector<ll> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n        K[i]--;\n    }\n    vector<ll> S(M);\n    vector<ll> sum(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n        sum[i] = ((i > 0) ? sum[i - 1] : 0) + S[i];\n    }\n    sort(K.begin(), K.end());\n    vector<vector<ll>> dist(N, vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ll l = min(K[i], K[j]);\n            ll r = max(K[i], K[j]);\n            dist[i][j] = (sum[r] - ((l > 0) ? sum[l - 1] : 0)) / L;\n        }\n    }\n    constexpr ll INF = 1LL << 60;\n\n    vector<ll> prev(N, INF);\n    prev[0] = 0;\n    for (int i = 0; i < N - 1; i++) {\n        vector<ll> dp(N, INF);\n        for (int j = 0; j <= i; j++) {\n            dp[i] = min(dp[i], prev[j] + dist[j][i + 1]);\n            dp[j] = min(dp[j], prev[j] + dist[i][i + 1]);\n        }\n        prev = dp;\n    }\n    ll mini = INF;\n    for (int j = 0; j < N - 1; j++) {\n        mini = min(mini, prev[j] + dist[j][N - 1]);\n    }\n    cout << mini << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate<typename T,std::size_t N>\nstruct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\ntemplate<typename T>\nstruct _v_traits<T,1> {using type = std::vector<T>;};\ntemplate<typename T,std::size_t N=1>\nusing vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nint calc_power(const vector<int>& ss,const int p,const int n,const int L){\n    if(n < p) return calc_power(ss,n,p,L);\n    return (ss[n] - ss[p-1]) / L;\n}\n\nint solve(int i,int u,int d,vector<int>& ss,vector<int>& k,const int L){\n    if(i == k.size()-1){\n        return calc_power(ss,u,k.back(),L) + calc_power(ss,d,k.back(),L);\n    }else{\n        return min(calc_power(ss,u,k[i],L) + solve(i+1,k[i],d,ss,k,L),\n                   calc_power(ss,d,k[i],L) + solve(i+1,u,k[i],ss,k,L));\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N,M,L;\n    cin >> N >> M >> L;\n\n    vector<int> K(N);\n    sort(all(K));\n    vector<int> S(M);\n    for(int& i : K) cin >> i;\n    for(int& i : S) cin >> i;\n\n    vector<int> SS(M+1);\n    for(int i=1;i<SS.size();i++){\n        SS[i] = SS[i-1] + S[i-1];\n    }\n    cout << solve(1,K[0],K[0],SS,K,L) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long sum[100010];\nlong long K[2010];\n\nint N,M,L;\nlong long f(int a,int b){\n\treturn (sum[max(a,b)] - sum[min(a,b)-1]) / L;\n}\nlong long score(){\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < N ; i++) ans += f(K[i],K[(i+1)%N]);\n\treturn ans;\n}\nint main(){\n\tcin >> N >> M >> L;\n\tfor(int i = 0 ; i < N ; i++) cin >> K[i];\n\tfor(int i = 1 ; i <= M ; i++){\n\t\tcin >> sum[i];\n\t\tsum[i] += sum[i-1];\n\t}\n\tlong long ans = 1e18;\n\tfor(int i = 0 ; i < N ; i++){\n\t\treverse(K+i,K+N);\n\t\tans = min(ans,score());\n\t\treverse(K+i,K+N);\n\t\tbreak;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<int>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) -> int { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\tdp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\tminCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\twrite(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M,L;\nint K[2001];\nint S[100001];\npair<int,int> Onpu[2001];\n\nll dp[2001][2001];\nll sums[100001];\n\nll dfs(int a,int b){\n    if(a==N-1||b==N-1){\n        if(a<b)swap(a,b);\n        return (sums[K[a]+1]-sums[K[b]])/L;\n    }\n    else if(dp[a][b]!=-1)return dp[a][b];\n    int nxtIdx=max(a,b)+1;\n    ll tmp=(sums[K[nxtIdx]+1]-sums[K[a]])/L;\n    ll res=dfs(nxtIdx,b)+tmp;\n    res=min(res,dfs(a,nxtIdx)+(sums[K[nxtIdx]+1]-sums[K[b]])/L);\n    return dp[a][b]=res;\n}\nint main(){\n\n    while(cin>>N>>M>>L&&(N|M|L)){\n        for(int i=0;i<N;i++){\n            cin>>K[i];\n            K[i]--;\n        }\n        for(int i=0;i<M;i++){\n            cin>>S[i];\n            sums[i+1]=sums[i]+S[i];\n        }\n        for(int i=0;i<N;i++){\n            Onpu[i].first=S[K[i]];\n            Onpu[i].second=K[i];\n        }\n        sort(Onpu,Onpu+N);\n        for(int i=0;i<N;i++)K[i]=Onpu[i].second;\n        memset(dp,-1,sizeof(dp));\n        ll res=dfs(0,0);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t; write(t2); }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N, M, L);\n\t\tauto K = read<int>(N);\n\t\tauto S = read<long>(M);\n\t\tpartial_sum(allof(S), S.begin());\n\t\tS.insert(S.begin(), 0);\n\t\tauto deltaS = [&](int a, int b) { return (S[max(a, b)] - S[min(a, b) - 1]) / L; };\n\t\tsort(allof(K));\n\n\t\tvevector<long> dp(N, N, LINF);\n\t\tdp[0][0] = 0;\n\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tREP(j, i + 1)\n\t\t\t{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + deltaS(K[i], K[i + 1]));\n\t\t\t\tdp[i][i + 1] = min(dp[i][i + 1], dp[i][j] + deltaS(K[j], K[i + 1]));\n\n\t\t\t\tdp[i + 1][i] = min(dp[i + 1][i], dp[j][i] + deltaS(K[j], K[i + 1]));\n\t\t\t\tdp[j][i + 1] = min(dp[j][i + 1], dp[j][i] + deltaS(K[i], K[i + 1]));\n\n\t\t\t}\n\t\t}\n\n\t\tlong minCost = LINF;\n\t\tREP(i, N - 1)\n\t\t{\n\t\t\tminCost = min(minCost, dp[N - 1][i] + deltaS(K[N - 1], K[i]));\n\t\t\tminCost = min(minCost, dp[i][N - 1] + deltaS(K[N - 1], K[i]));\n\t\t}\n\t\twrite(minCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nll dp[2010][2010];\nll s[100010];\nint L;\n\nll sum(int a,int b){\n\tif(a>b) swap(a,b);\n\tll ret = s[b];\n\tif(a) ret-=s[a-1];\n\t// cout<<\"sum \"<<a<<\" \"<<b<<\" \"<<ret<<\" \"<<ret/L<<endl;\n\treturn ret/L;\n}\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tsort(ALL(v));\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\trep(i,m){\n\t\tif(!i){\n\t\t\ts[i]=w[i];\n\t\t}\n\t\telse{\n\t\t\ts[i]=s[i-1]+w[i];\n\t\t}\n\t}\n\trep(i,2010) rep(j,2010) dp[i][j]=INFL;\n\tdp[0][0] = 0;\n\tdp[1][0] = sum(v[0],v[1]);\n\trep(i,n-1){\n\t\trep(j,i){\n\t\t\tmins(dp[i+1][j],dp[i][j]+sum(v[i],v[i+1]));\n\t\t\tmins(dp[i+1][i],dp[i][j]+sum(v[j],v[i+1]));\n\t\t}\n\t}\n\t// rep(i,n){\n\t// \trep(j,n){\n\t// \t\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t// \t}\n\t// }\n\tll ans = INFL;\n\trep(i,n){\n\t\tmins(ans,dp[n-1][i]+sum(v[i],v[n-1]));\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll S[150000];\nvector<ll> K;\nll Ssum[150000];\nll dp[2050][2050];\n\nvoid chmin(ll &a, ll b) {\n    a = min(a, b);\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M, L;\n    cin >> N >> M >> L;\n    K.resize(N);\n    for(int i = 0; i < N; i++) cin >> K[i];\n    K.push_back(-1);\n    sort(K.begin(), K.end());\n    for(int i = 1; i <= M; i++) {\n        cin >> S[i];\n        Ssum[i] = Ssum[i-1] + S[i];\n    }\n    //dp[1][1] = 0;\n    dp[2][1] = (Ssum[K[2]] - Ssum[K[1] - 1]) / L;\n    for(int num = 3; num <= N; num++) {\n        for(int after = 1; after <= num - 2; after++) {\n            dp[num][after] = 1e18;\n            chmin(dp[num][after], dp[num-1][after] + (Ssum[K[num]] - Ssum[K[num-1]-1]) / L);\n            //cerr << num << \" \" << after << \" \" << dp[num][after] << endl;\n        }\n        dp[num][num-1] = 1e18;\n        for(int after = 1; after <= num - 2; after++) {\n            chmin(dp[num][num-1], dp[num-1][after] + (Ssum[K[num]] - Ssum[K[after]-1]) / L);\n        }\n        //cerr << num << \" \" << num-1 << \" \" << dp[num][num-1] << endl;\n    }\n    ll ans = 1e18;\n    for(int i = 1; i < N; i++) {\n        chmin(ans, dp[N][i] + (Ssum[K[N]] - Ssum[K[i]-1]) / L);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 2005;\nconst lli M = 100005;\nconst lli INF = 1e12;\n\nlli n, m, l, K[N], S[M+1], dp[N][N], cum[M+1];\nP vec[N];\n\nlli calc(lli a, lli b){\n\tif(vec[a].first > vec[b].first) swap(a, b);\n\treturn (cum[vec[b].second] - cum[vec[a].second-1]) / l;\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\tfor(lli i=0;i<n;i++) cin >> K[i];\n\tfor(lli i=1;i<=m;i++) cin >> S[i];\n\tcum[0] = 0;\n\tfor(lli i=1;i<=m;i++) cum[i] = cum[i-1] + S[i];\n\tfor(lli i=0;i<n;i++) vec[i] = make_pair(S[K[i]], K[i]);\n\tsort(vec, vec+n);\n\treverse(vec, vec+n);\n\tfill(dp[0], dp[N], INF);\n\tdp[0][0] = 0;\n\tfor(lli i=0;i<n;i++){\n\t\tfor(lli j=0;j<=i;j++){\n\t\t\tif(dp[i][j] >= INF) continue;\n\t\t\tdp[i+1][i] = min(dp[i+1][i], dp[i][j] + calc(i+1, j));\n\t\t\tdp[i+1][j] = min(dp[j][i+1], dp[i][j] + calc(i+1, i));\n\t\t}\n\t}\n\tlli ans = INF;\n\tfor(lli i=0;i<n;i++){\n\t\tans = min(ans, dp[n-1][i] + calc(n-1, i));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAX = 2010;\n\nint N, M, L;\nll memo[MAX][MAX];\nvector<ll> K, sum;\n\nll calc(int l, int r)\n{\n    return (sum[K[r] + 1] - sum[K[l]]) / L;\n}\n\nll solve(int l, int r)\n{    \n    ll& res = memo[l][r];\n    if (res != -1) return res;\n\n    int n = max(l, r) + 1;\n    if (n == N - 1) {\n        return calc(l, n) + calc(r, n);\n    }\n    res = min(solve(n, r) + calc(l, n),\n              solve(l, n) + calc(r, n));    \n    return res;\n}\n\nint main()\n{    \n    cin >> N >> M >> L;\n    K.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i]; K[i]--;\n    }\n    sort(K.begin(), K.end());\n    \n    vector<int> S(M);\n    for (int i = 0; i < M; i++) {\n        cin >> S[i];\n    }\n    \n    sum.resize(M + 1);\n    for (int i = 0; i < M; i++) {\n        sum[i + 1] = sum[i] + S[i];\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    cout << solve(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct State{\n  int low, high;\n  ll cost;\n  State(int low, int high, ll cost) : low(low), high(high), cost(cost) {}\n  bool operator < (const State& s) const {\n    return cost > s.cost; // reversed!!!\n  };\n};\nll get_cost(int from, int to, int L, const vector<ll>& accumulation){\n  ll sum = accumulation[to] - accumulation[from - 1];\n  return sum / L;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    vector<int> K(N);\n    vector<int> S(M);\n    REP(i, N) cin >> K[i];\n    REP(i, M) cin >> S[i];\n\n    vector<ll> accumulation(M + 1);\n    REP(i, M) accumulation[i + 1] = accumulation[i] + S[i];\n\n    sort(K.begin(), K.end());\n    priority_queue<State> que;\n    static ll dist[2000][2000];\n    REP(i, N)REP(j, N) dist[i][j] = LONG_LONG_MAX;\n    que.push(State(0, 1, get_cost(K[0], K[1], L, accumulation)));\n    dist[0][1] = get_cost(K[0], K[1], L, accumulation);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(dist[s.low][s.high] < s.cost) continue;\n      if(s.high + 1 == N){\n        cout << s.cost << endl;\n        break;\n      }else if(s.high + 1 == N - 1){\n        ll cost1 = get_cost(K[s.low], K[s.high + 1], L, accumulation);\n        ll cost2 = get_cost(K[s.high], K[s.high + 1], L, accumulation);\n        State next(s.high + 1, s.high + 1, s.cost + cost1 + cost2);\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n      }else{\n        State next(s.low, s.high + 1,\n            s.cost + get_cost(K[s.high], K[s.high + 1], L, accumulation));\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n        next = State(s.high, s.high + 1,\n            s.cost + get_cost(K[s.low], K[s.high + 1], L, accumulation));\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n  int N,M,L;\n  vector<int>K,S;\n  long long int ans=LLONG_MAX;\n  cin>>N>>M>>L;\n  K.resize(N);\n  S.resize(M);\n  for(int i=0;i<N;i++)cin>>K[i];\n  for(int i=0;i<M;i++)cin>>S[i];\n  sort(K.begin(),K.end());\n  do{\n    long long int sum=0;\n    for(int i=0;i<N;i++){\n      long long int tmp=0;\n      int a=K[i],b=K[(i+1)%N];\n      if(a>b)swap(a,b);\n      for(int j=a;j<=b;j++){tmp+=S[j-1];}\n      tmp/=L;\n      sum+=tmp;\n    }\n    ans=ans<sum?ans:sum;\n  }while(next_permutation(K.begin(),K.end()));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define mins(x,y) x=min(x,y)\n\nll dp[2010][2010];\nll s[100010];\nint L;\n\nll sum(int a,int b){\n\treturn (s[b]-(a?s[a-1]:0))/L;\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tsort(ALL(v));\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\trep(i,m){\n\t\tif(!i){\n\t\t\ts[i]=w[i];\n\t\t}\n\t\telse{\n\t\t\ts[i]=s[i-1]+w[i];\n\t\t}\n\t}\n\trep(i,2010) rep(j,2010) dp[i][j]=INFL;\n\tdp[0][0] = 0;\n\tdp[1][0] = sum(v[0],v[1]);\n\trep(i,n-1){\n\t\trep(j,i){\n\t\t\tmins(dp[i+1][j],dp[i][j]+sum(v[i],v[i+1]));\n\t\t\tmins(dp[i+1][i],dp[i][j]+sum(v[j],v[i+1]));\n\t\t}\n\t}\n\tll ans = INFL;\n\trep(i,n){\n\t\tmins(ans,dp[n-1][i]+sum(v[i],v[n-1]));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, M, L;\nll K[2048];\nll Sum[100001];\nll memo[2048][2048];\n\nll pls(int r, int l)\n{\n\treturn ((SSum[r] - SSum[l]) / (ll)L);\n}\n\nll saveSayaka(int l, int r)\n{\n\tint next = max(l, r) + 1;\n\t\n\tif (memo[l][r] >= 0){\n\t\treturn (memo[l][r]);\n\t}\n\t\n\tif (next == N - 1){\n\t\treturn (pls(K[next], K[l] - 1) + pls(K[next], K[r] - 1));\n\t}\n\t\n\tll left = saveSayaka(next, r) + pls(K[next], K[l] - 1);\n\tll right = saveSayaka(l, next) + pls(K[next], K[r] - 1);\n\t\n\treturn (memo[l][r] = min(left, right));\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &N, &M, &L);\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &K[i]);\n\t}\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tSSum[i + 1] = SSum[i] + s;\n\t}\n\t\n\tsort(K, K + N);\n\tmemset(memo, -1, sizeof(memo));\n\t\n\tprintf(\"%lld\\n\", saveSayaka(0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll dp[2222][2222];\nvector<ll> k;\nvector<ll> s;\nint n,m,l;\n\nll get_imos(int a, int b){\n\tll ret = s[b];\n\tif(a > 0)ret -= s[a-1];\n\treturn ret / l;\n}\n\nint main(){\n\n\tREP(i,2222){\n\t\tREP(j,2222){\n\t\t\tdp[i][j] = LLINF;\n\t\t}\n\t}\n\n\tcin >> n >> m >> l;\n\tREP(i,n){\n\t\tint tmp;cin >> tmp;tmp--;\n\t\tk.PB(tmp);\n\t}\n\tsort(ALL(k));\n\tll sum = 0;\n\tREP(i,m){\n\t\tint tmp;cin >> tmp;\n\t\tsum += tmp;\n\t\ts.PB(sum);\n\t}\n\n\tdp[0][1] = get_imos(k[0], k[1]);\n\n\tREP(i,n-1){\n\t\tREP(j,n-1)if(dp[i][j] != LLINF && i < j){\n\t\t\tdp[i][j+1] = min(dp[i][j+1],dp[i][j] + get_imos(k[j],k[j+1]));\n\t\t\tdp[j][j+1] = min(dp[j][j+1],dp[i][j] + get_imos(k[i],k[j+1]));\n\t\t}\n\t}\n\n\tll ans = LLINF;\n\tREP(i,n)if(dp[i][n-1] != LLINF){\n\t\tans = min(ans, dp[i][n-1] + get_imos(k[i],k[n-1]));\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nll dp[2010][2010];\nll s[2010];\nint L;\n\nll sum(int a,int b){\n\tif(a>b) swap(a,b);\n\tll ret = s[b];\n\tif(a) ret-=s[a-1];\n\treturn ret/L;\n}\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m>>L;\n\tvint v(n);\n\trep(i,n) cin>>v[i],v[i]--;\n\tsort(ALL(v));\n\tvint w(m);\n\trep(i,m) cin>>w[i];\n\trep(i,m){\n\t\tif(!i){\n\t\t\ts[i]=v[i];\n\t\t}\n\t\telse{\n\t\t\ts[i]=s[i-1]+w[i];\n\t\t}\n\t}\n\trep(i,2010) rep(j,2010) dp[i][j]=INFL;\n\tdp[0][0] = 0;\n\tdp[1][0] = sum(v[0],v[1]);\n\trep(i,n-1){\n\t\trep(j,i){\n\t\t\tmins(dp[i+1][j],dp[i][j]+sum(v[i],v[i+1]));\n\t\t\tmins(dp[i+1][i],dp[i][j]+sum(v[j],v[i+1]));\n\t\t}\n\t}\n\t// rep(i,n){\n\t// \trep(j,n){\n\t// \t\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t// \t}\n\t// }\n\tll ans = INFL;\n\trep(i,n){\n\t\tmins(ans,dp[n-1][i]+sum(v[i],v[n-1]));\n\t}\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst ll INF = 1LL<<60;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct State{\n  int low, high;\n  ll cost;\n  State(int low, int high, ll cost) : low(low), high(high), cost(cost) {}\n  bool operator < (const State& s) const {\n    return cost > s.cost; // reversed!!!\n  };\n};\nll get_cost(int from, int to, int L, const vector<ll>& accumulation){\n  ll sum = accumulation[to] - accumulation[from - 1];\n  return sum / L;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N >> M >> L && N){\n    vector<int> K(N);\n    vector<int> S(M);\n    REP(i, N) cin >> K[i];\n    REP(i, M) cin >> S[i];\n\n    vector<ll> accumulation(M + 1);\n    REP(i, M) accumulation[i + 1] = accumulation[i] + S[i];\n\n    sort(K.begin(), K.end());\n    priority_queue<State> que;\n    static ll dist[2000][2000];\n    REP(i, N)REP(j, N) dist[i][j] = INF;\n    que.push(State(0, 1, get_cost(K[0], K[1], L, accumulation)));\n    dist[0][1] = get_cost(K[0], K[1], L, accumulation);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(dist[s.low][s.high] < s.cost) continue;\n      if(s.high + 1 == N){\n        cout << s.cost << endl;\n        break;\n      }else if(s.high + 1 == N - 1){\n        ll cost1 = get_cost(K[s.low], K[s.high + 1], L, accumulation);\n        ll cost2 = get_cost(K[s.high], K[s.high + 1], L, accumulation);\n        State next(s.high + 1, s.high + 1, s.cost + cost1 + cost2);\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n      }else{\n        State next(s.low, s.high + 1,\n            s.cost + get_cost(K[s.high], K[s.high + 1], L, accumulation));\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n        next = State(s.high, s.high + 1,\n            s.cost + get_cost(K[s.low], K[s.high + 1], L, accumulation));\n        if(dist[next.low][next.high] > next.cost){\n          dist[next.low][next.high] = next.cost;\n          que.push(next);\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int n, m, l;\n    cin >> n >> m >> l;\n\n    vector<int> k(n);\n    for(int i=0; i<n; ++i){\n        cin >> k[i];\n        -- k[i];\n    }\n    sort(k.begin(), k.end());\n\n    vector<int> sum(m+1, 0);\n    for(int i=1; i<=m; ++i){\n        cin >> sum[i];\n        sum[i] += sum[i-1];\n    }\n\n    vector<long long> dp(1);\n    dp[0] = (sum[k[1]+1] - sum[k[0]]) / l;\n    for(int i=2; i<n; ++i){\n        vector<long long> nextDp(i, LLONG_MAX);\n        for(int j=0; j<i-1; ++j){\n            nextDp[i-1] = min(nextDp[i-1], dp[j] + (sum[k[i]+1] - sum[k[j]]) / l);\n            nextDp[j] = min(nextDp[j], dp[j] + (sum[k[i]+1] - sum[k[i-1]]) / l);\n        }\n        dp.swap(nextDp);\n    }\n\n    long long ret = LLONG_MAX;\n    for(int i=0; i<n-1; ++i)\n        ret = min(ret, dp[i] + (sum[k[n-1]+1] - sum[k[i]]) / l);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 2020;\nconst int ML = 100100;\nint n, m, l;\nint k[MN];\nint s[ML], ssm[ML];\n\nint gt(int a, int b) {\n    return (ssm[k[b]+1]-ssm[k[a]])/l;\n}\n\n\nint calc(int a, int b) {\n    if (a > b) return calc(b, a);\n    if (b == n-1) {\n        return gt(a, n-1);\n    }\n    static int dp[MN][MN];\n    static bool used[MN][MN];\n    if (used[a][b]) return dp[a][b];\n    used[a][b] = true;\n    int &ans = dp[a][b];\n    ans = TEN(9);\n    ans = min(ans, calc(b+1, b)+gt(a, b+1));\n    ans = min(ans, calc(a, b+1)+gt(b, b+1));\n    return ans;\n}\n\nint main() {\n    cin >> n >> m >> l;\n    for (int i = 0; i < n; i++) {\n\tcin >> k[i]; k[i]--;\n    }\n    sort(k, k+n);\n    for (int i = 0; i < m; i++) {\n\tcin >> s[i];\n    }\n    ssm[0] = 0;\n    for (int i = 0; i < m; i++) {\n\tssm[i+1] = s[i]+ssm[i];\n    }\n    cout << calc(0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, L; cin >> N >> M >> L;\n  VI ks(N);\n  REP(i,N){\n\tcin >> ks[i]; --ks[i];\n  }\n  vector<LL> s(M), acc(M+1);\n  REP(i,M){\n\tcin >> s[i];\n\tacc[i+1] = acc[i] + s[i];\n  }\n  SORT(ks);\n  LL ans = 0;\n  REP(i,N-1) ans += (acc[ks[i+1]+1] - acc[ks[i]]) / L;\n  ans += (acc[ks.back()+1] - acc[ks[0]]) / L;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#define range(i,a,b) assert(a<=i && i<=b)\nusing namespace std;\nint N, M, L;\nvector<int> K, S;\nlong long sumofS(int a, int b){\n\tlong long sum = 0;\n\tfor (int i = a; i < b + 1; i++){\n\t\trange(i,0,M-1);\n\t\tsum += S[i];\n\t}\n\treturn sum;\n}\nlong long solve(int n){\n\tif (n > 0){\n\t\tauto res = solve(n - 1);\n\t\trange(n,1,N-1);\n\t\treturn min((res + sumofS(K[n - 1] + 1, K[n]) / L)*L + sumofS(K[n - 1], K[n]),\n\t\t\tres + sumofS(K[n - 1] + 1, K[n]) + (sumofS(K[n - 1], K[n]) / L)*L);\n\t}\n\telse{\n\t\trange(K[0],0,M-1);\n\t\treturn S[K[0]];\n\t}\n}\nint main(){\n\tcin >> N >> M >> L;\n\tK = vector<int>(N);\n\tS = vector<int>(M);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> K[i];\n\t\tK[i]--;\n\t}\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> S[i];\n\tsort(K.begin(), K.end());\n\tauto ans=(solve(N-1)/L);\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nll l;\nint k[2001];\nll s[1000001];\nll sum[2002];\nll dp[2002];\n\nint main(void){\n\tscanf(\"%d%d%lld\",&n,&m,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%lld\",&s[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tsum[i+1]=sum[i]+s[i];\n\t}\n\tsort(k,k+n);\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF*20000LL;\n\t}\n\tdp[0]=(sum[k[1]]-sum[k[0]-1])/l;\n\tfor(int i=2;i<n;i++){\n\t\tfor(int j=0;j<i-1;j++){\n\t\t\tdp[i-1]=min(dp[i-1],dp[j]+(sum[k[i]]-sum[k[j]-1])/l);\n\t\t}\n\t\tfor(int j=0;j<i-1;j++){\n\t\t\tdp[j]=dp[j]+(sum[k[i]]-sum[k[i-1]-1])/l;\n\t\t}\n\t}\n\tll res=INF*20000LL;\n\tfor(int i=0;i<n-1;i++){\n\t\tres=min(res,dp[i]+(sum[k[n-1]]-sum[k[i]-1])/l);\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int64 , int64 > Pi;\ntypedef pair< int , Pi > Pii;\nconst int64 INF = 1LL << 53;\n\nint64 N, M, L, K[2000], S[100000];\nint64 dp[2000];\nint64 get_Sum(int a, int b){\n  if(a > b) swap( a, b);\n  if(a == 0) return S[b];\n  else return S[b] - S[a - 1];\n}\n\nint64 rec(int idx, int right, int left){\n  if(idx == N) return get_Sum( K[right], K[left]) / L;\n  if(~dp[idx]) return dp[idx];\n  int64 ret = INF;\n  ret = min( ret, rec( idx + 1, idx, left) + get_Sum( K[right], K[idx]) / L);\n  ret = min( ret, rec( idx + 1, right, idx) + get_Sum( K[left], K[idx]) / L);\n  return dp[idx] = ret;\n}\n\nint main(){\n  fill_n( dp, 2000, -1);\n  scanf(\"%lld %lld %lld\", &N, &M, &L);\n  for(int i = 0; i < N; i++){\n    scanf(\"%lld\", &K[i]); --K[i];\n  }\n  for(int i = 0; i < M; i++){\n    scanf(\"%lld\", &S[i]);\n    if(i) S[i] += S[i - 1];\n  }\n  sort( K, K + N);\n  printf(\"%lld\\n\", rec( 1, 0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,l;\nvi in,dp;\nmap<pii,ll>ma;\nint f(int a,int b){\n\tif(ma.count({a,b}))return ma[{a,b}];\n\tif(b==n-1)return ma[{a,b}]=(dp[in[n-1]]-dp[in[a]-1])/l;\n\treturn ma[{a,b}]=min(f(a,b+1)+(dp[in[b+1]]-dp[in[b]-1])/l,f(b,b+1)+(dp[in[b+1]]-dp[in[a]-1])/l);\n}\nint main(){\n\tcin>>n>>m>>l;\n\tin=vi(n);\n\tdp=vi(m+1);\n\trep(i,n)cin>>in[i];\n\trep(i,m)cin>>dp[i+1];\n\trep(i,m)dp[i+1]+=dp[i];\n\tsort(all(in));\n\tcout<<f(0,0)<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long int w[100010]={0};\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,l,t,i,j,d[2100],s[2100],min,max;\n  scanf(\"%d %d %d\",&n,&m,&l);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&t);\n    for(j=i;j;j--){\n      if(d[j-1]>t)d[j]=d[j-1];\n      else break;\n    }\n    d[j]=t;\n  }\n  for(i=0;i<n;i+=2)s[i/2]=d[i];\n  for(;n+n-i-1>0;i+=2)s[i/2]=d[n+n-i-1];\n  //for(i=0;i<n;i++)printf(\"%d \",s[i]);printf(\"\\n\");\n  for(i=0;i<m;i++){\n    scanf(\"%d\",&t);\n    w[i+1]=w[i]+t;//printf(\"%lld \",w[i+1]);\n  }//printf(\"\\n\");\n  for(i=t=0;i<n;i++){\n    min=MIN(s[i],s[(i+1)%n])-1;\n    max=s[i]+s[(i+1)%n]-min-1;//printf(\"%d %d\\n\",min,max);\n    t+=(w[max]-w[min])/l;//,printf(\"%d\\n\",t);\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2312\nTitle: Magical Girl Sayaka-chan\n@kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n//Global data section\nint N,M,L;\nint K[2000],S[100000];\n//\nint compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\n\nmain()\n{\n        int i,j,sum;\n        scanf(\"%d %d %d\",&N,&M,&L);\n\n        for(i=0;i<N;i++)\n        {\n                scanf(\"%d\\n\",&K[i]);\n        }\n        for(i=0;i<M;i++)\n                scanf(\"%d\\n\",&S[i]);\n        sum=0;\n        i=j=0;\n        qsort(K,N,sizeof(int),compare);\n               \n        for(i=0;i<N-1;i++)\n        {\n                for(j=K[i];j<=K[i+1];j++)\n                {\n                        //printf(\"%d %d\\n\",j,S[j-1]);\n                        sum += S[j-1];\n                        //printf(\"S:%d\\n\",sum);\n                                \n                }\n        }\n        for(i=K[0];i<=K[N-1];i++)\n                sum += S[i-1];\n\n        //printf(\"%d\\n\",sum);\n        //printf(\"S[0]=%d K[0]=%d %d\\n\",S[0],K[0],K[1]);\n\n        printf(\"%d\\n\",sum/L);\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2312: Magical Girl Sayaka-chan\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint N, M, L;\nint k[2001];\nint s[100001];\nlong long sum[100002];\nlong long memo[2001][2001];\n\nchar buf[700001], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nlong long kpart(int r, int l) { return (sum[r]-sum[l]) / L; }\n\nlong long calc(int l, int r)\n{\n\tint i;\n\tlong long ll, rr;\n  \n    if (memo[l][r] >= 0) return (memo[l][r]);\n\ti = r; if (i < l) i = l;\n\tif (++i == N - 1) return kpart(k[i], k[l]-1) + kpart(k[i], k[r]-1);\n     \n    ll = calc(i, r) + kpart(k[i], k[l] - 1);\n    rr = calc(l, i) + kpart(k[i], k[r] - 1);\n\tif (ll > rr) ll = rr;\n    return memo[l][r] = ll;\n}\n\nint main()\n{\n\tint i;\n\n\tfgets(p=buf, 30, stdin);\n\tN = getint(), p++, M = getint(), p++, L = getint();\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (i = 0; i < N; i++) k[i] = getint(), p++;\n\tqsort(k, N, sizeof(int), cmp);\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (sum[0] = 0, i = 0; i < M; i++) {\n\t\ts[i] = getint(), p++;\n\t\tsum[i+1] = sum[i] + s[i];\n\t}\n\tmemset(memo, -1, sizeof(memo));\n\tprintf(\"%lld\\n\", calc(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong long int w[100000]={0};\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,l,t,i,j,d[2100],s[2100],min,max;\n  scanf(\"%d %d %d\",&n,&m,&l);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&t);\n    for(j=i;j;j--){\n      if(d[j-1]>t)d[j]=d[j-1];\n      else break;\n    }\n    d[j]=t;\n  }\n  for(i=0;i<n;i+=2)s[i/2]=d[i];\n  for(;n+n-i-1>0;i+=2)s[i/2]=d[n+n-i-1];\n  //for(i=0;i<n;i++)printf(\"%d \",s[i]);printf(\"\\n\");\n  for(i=0;i<m;i++){\n    scanf(\"%d\",&t);\n    w[i+1]=w[i]+t;//printf(\"%lld \",w[i+1]);\n  }//printf(\"\\n\");\n  for(i=t=0;i<n;i++){\n    min=MIN(s[i],s[(i+1)%n])-1;\n    max=s[i]+s[(i+1)%n]-min-1;//printf(\"%d %d\\n\",min,max);\n    t+=(w[max]-w[min])/l;//,printf(\"%d\\n\",t);\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tlong[] accum;\n\tlong[] S;\n\tint N, M, L;\n\tint[] K;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tL = sc.nextInt();\n\t\tK = new int[N];\n\t\tS = new long[M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\taccum = new long[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tfor (int i = 0; i < 2010; i++) {\n\t\t\tfor (int j = 0; j < 2010; j++) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dfs(-1, -1));\n\n\t}\n\n\tlong dfs(int l, int r) {\n\t\tif (l > r) {\n\t\t\tint tmp = l;\n\t\t\tl = r;\n\t\t\tr = tmp;\n\t\t}\n\t\tint t = Math.max(l, r) + 1;\n\t\tif (t == N - 1) {\n\t\t\treturn cost(l, t) + cost(r, t);\n\t\t}\n\t\tif (l != -1 && r != -1 && memo[l][r] != -1)\n\t\t\treturn memo[l][r];\n\t\tlong tmp = Math.min(dfs(t, r) + cost(l, t), dfs(l, t) + cost(r, t));\n\t\tif (l != -1 && r != -1)\n\t\t\tmemo[l][r] = tmp;\n\t\treturn tmp;\n\t}\n\n\tlong cost(int l, int r) {\n\t\tif (l == -1) {\n\t\t\treturn accum[r];\n\t\t} else if (r == -1) {\n\t\t\treturn accum[l];\n\t\t}\n\t\tl = K[l];\n\t\tr = K[r];\n\t\treturn Math.abs(accum[r] - accum[l] + S[l]);\n\t}\n\n\tlong[][] memo = new long[2010][2010];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tlong[] accum;\n\tlong[] S;\n\tint N, M, L;\n\tint[] K;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tL = sc.nextInt();\n\t\tK = new int[N];\n\t\tS = new long[M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\taccum = new long[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tfor (int i = 0; i < 2010; i++) {\n\t\t\tfor (int j = 0; j < 2010; j++) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dfs(0, 0));\n\n\t}\n\n\tlong dfs(int l, int r) {\n\t\tif (l > r) {\n\t\t\tint tmp = l;\n\t\t\tl = r;\n\t\t\tr = tmp;\n\t\t}\n\t\tint t = Math.max(l, r) + 1;\n\t\tif (t == N - 1) {\n\t\t\treturn cost(t, l) + cost(t, r);\n\t\t}\n\t\tif (memo[l][r] != -1)\n\t\t\treturn memo[l][r];\n\t\treturn memo[l][r] = Math.min(cost(t, l) + dfs(t, r), dfs(l, t) + cost(t, r));\n\t}\n\n\tlong cost(int l, int r) {\n\t\tl = K[l];\n\t\tr = K[r];\n\t\treturn Math.abs((accum[r] - accum[l] + S[l]) / L);\n\t}\n\n\tlong[][] memo = new long[2010][2010];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), M = sc.nextInt(), L = sc.nextInt();\n\t\tint[] K = new int[N];\n\t\tlong[] S = new long[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\tlong[] accum = new long[N];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i != N - 1) {\n\t\t\t\tif (K[i] == K[i + 1]) {\n\t\t\t\t\tans += S[K[i]] / L;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += Math.abs((accum[K[i + 1]] - accum[K[i]] + S[K[i]]) / L);\n\t\t\t} else {\n\t\t\t\tans += Math.abs((accum[K[N - 1]] - accum[K[0]] + S[K[0]]) / L);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), M = sc.nextInt(), L = sc.nextInt();\n\t\tint[] K = new int[N];\n\t\tlong[] S = new long[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\tlong[] accum = new long[N];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tif (K[i] == K[i + 1])\n\t\t\t\tans += S[K[i]];\n\t\t\telse if (i != N) {\n\t\t\t\tans += Math.abs((accum[K[i + 1]] - accum[K[i]] + S[K[i]]) / L);\n\t\t\t} else {\n\t\t\t\tans += Math.abs((accum[K[N - 1]] - accum[K[0]] + S[K[0]]) / L);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tlong[] accum;\n\tlong[] S;\n\tint N, M, L;\n\tint[] K;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tL = sc.nextInt();\n\t\tK = new int[N];\n\t\tS = new long[M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\taccum = new long[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tfor (int i = 0; i < 2010; i++) {\n\t\t\tfor (int j = 0; j < 2010; j++) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dfs(0, 0));\n\n\t}\n\n\tlong dfs(int l, int r) {\n\t\tif (l > r) {\n\t\t\tint tmp = l;\n\t\t\tl = r;\n\t\t\tr = tmp;\n\t\t}\n\t\tint t = Math.max(l, r) + 1;\n\t\tif (t == N - 1) {\n\t\t\treturn cost(t, l) + cost(t, r);\n\t\t}\n\t\tif (memo[l][r] != -1)\n\t\t\treturn memo[l][r];\n\t\treturn memo[l][r] = Math.min(cost(t, l) + dfs(t, r), dfs(l, t) + cost(t, r));\n\t}\n\n\tlong cost(int l, int r) {\n\t\tl = K[l];\n\t\tr = K[r];\n\t\tif (r < l) {\n\t\t\tint tmp = r;\n\t\t\tr = l;\n\t\t\tl = tmp;\n\t\t}\n\t\treturn Math.abs((accum[r] - accum[l] + S[l]) / L);\n\t}\n\n\tlong[][] memo = new long[2010][2010];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), M = sc.nextInt(), L = sc.nextInt();\n\t\tint[] K = new int[N];\n\t\tlong[] S = new long[M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\tlong[] accum = new long[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i != N - 1) {\n\t\t\t\tif (K[i] == K[i + 1]) {\n\t\t\t\t\tans += S[K[i]] / L;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += Math.abs((accum[K[i + 1]] - accum[K[i]] + S[K[i]]) / L);\n\t\t\t} else {\n\t\t\t\tans += Math.abs((accum[K[N - 1]] - accum[K[0]] + S[K[0]]) / L);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), M = sc.nextInt(), L = sc.nextInt();\n\t\tint[] K = new int[N];\n\t\tlong[] S = new long[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tK[i] = sc.nextInt() - 1;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tS[i] = sc.nextLong();\n\t\t}\n\t\tlong[] accum = new long[N];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (i >= 1)\n\t\t\t\taccum[i] += accum[i - 1];\n\t\t\taccum[i] += S[i];\n\t\t}\n\t\tArrays.sort(K);\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i != N - 1) {\n\t\t\t\tif (K[i] == K[i + 1]) {\n\t\t\t\t\tans += S[K[i]] / L;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += Math.abs((accum[K[i + 1]] - accum[K[i]] + S[K[i]]) / L);\n\t\t\t} else {\n\t\t\t\tans += Math.abs((accum[K[N - 1]] - accum[K[0]] + S[K[0]]) / L);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**5)\n\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n\n    N, M, L = map(int, readline().split())\n    *K, = map(int, readline().split())\n    *S, = map(int, readline().split())\n    su = [0]*(M+1)\n    r = 0\n    for i in range(M):\n        su[i+1] = r = r + S[i]\n    K.sort()\n    memo = [[-1]*N for i in range(N)]\n    def calc(a, b):\n        sa = K[a]; sb = K[b]\n        if not sa < sb:\n            sa, sb = sb, sa\n        return (su[sb] - su[sa-1]) // L\n    def dfs(i, a, b):\n        if i == N:\n            return calc(a, b)\n        if memo[a][b] != -1:\n            return memo[a][b]\n        r = min(dfs(i+1, a, i) + calc(b, i), dfs(i+1, b, i) + calc(a, i))\n        memo[a][b] = r\n        return r\n    write(\"%d\\n\" % dfs(1, 0, 0))\nsolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m,l):\n        k = sorted(LI())\n        s = LI()\n        wam = [0] * (m+1)\n        for i in range(m):\n            wam[i+1] = wam[i] + s[i]\n        wa = [0] * n\n        wb = [0] * n\n        for i in range(n):\n            wa[i] = wam[k[i]]\n            wb[i] = wam[k[i]-1]\n\n        fm = {}\n        fm[(0,0)] = 0\n        fm[(0,1)] = (wa[1] - wb[0]) // l\n        def _f(i,j):\n            key = (i,j)\n            if key in fm:\n                return fm[key]\n            r = inf\n            if i == j-1:\n                for k in range(i):\n                    t = _f(k,i) + (wa[j] - wb[k]) // l\n                    if r > t:\n                        r = t\n            else:\n                t = _f(i,j-1) + (wa[j] - wb[j-1]) // l\n                if r > t:\n                    r = t\n            fm[key] = r\n            return r\n\n        r = inf\n        for i in range(1,n-1):\n            t = _f(i,n-1)\n            u = (wa[n-1] - wb[i]) // l\n            if r > t + u:\n                r = t + u\n\n        return r\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  }
]