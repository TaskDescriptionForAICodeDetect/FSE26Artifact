[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\nint N, M, L;\nint K[MAX_N];\nint S[MAX_M + 1];\nint prefix[MAX_M + 1];\nint dp[MAX_N][MAX_N];\n\nvoid compute_prefix() {\n    prefix[0] = 0;\n    for (int i = 1; i <= M; i++) {\n        prefix[i] = prefix[i - 1] + S[i];\n    }\n}\n\nint sum(int a, int b) {\n    if (a <= b) {\n        return prefix[b] - prefix[a - 1];\n    } else {\n        return prefix[M] - prefix[a - 1] + prefix[b];\n    }\n}\n\nint repulsive(int a, int b) {\n    if (a > b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n    int s = sum(a, b);\n    return s / L;\n}\n\nint solve() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j] = INT_MAX;\n        }\n        dp[i][(i + 1) % N] = repulsive(K[i], K[(i + 1) % N]);\n    }\n\n    for (int length = 2; length < N; length++) {\n        for (int i = 0; i < N; i++) {\n            int j = (i + length) % N;\n            for (int k = 1; k < length; k++) {\n                int m = (i + k) % N;\n                int cost = dp[i][m] + dp[m][j] + repulsive(K[i], K[j]);\n                if (cost < dp[i][j]) {\n                    dp[i][j] = cost;\n                }\n            }\n        }\n    }\n\n    int min_energy = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        int j = (i + N - 1) % N;\n        if (dp[i][j] < min_energy) {\n            min_energy = dp[i][j];\n        }\n    }\n    return min_energy;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &L);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &K[i]);\n    }\n    for (int i = 1; i <= M; i++) {\n        scanf(\"%d\", &S[i]);\n    }\n\n    compute_prefix();\n    int result = solve();\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<int> S(M + 1);\n    for (int i = 1; i <= M; ++i) {\n        cin >> S[i];\n    }\n    vector<int> K(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> K[i];\n    }\n\n    // Precompute prefix sums\n    vector<int> prefix(M + 2, 0);\n    for (int i = 1; i <= M; ++i) {\n        prefix[i] = prefix[i - 1] + S[i];\n    }\n\n    // Precompute repulsive force between all pairs a <= b\n    vector<vector<int>> repulse(M + 1, vector<int>(M + 1, 0));\n    for (int a = 1; a <= M; ++a) {\n        for (int b = a; b <= M; ++b) {\n            int sum = prefix[b] - prefix[a - 1];\n            repulse[a][b] = sum / L;\n        }\n    }\n\n    // Since the notes are in a circle, we can fix the first note to break the symmetry\n    // We will try all possible first notes and find the minimal TSP\n    int min_energy = INT_MAX;\n    vector<int> perm = K;\n    sort(perm.begin(), perm.end());\n\n    do {\n        int energy = 0;\n        for (int i = 0; i < N; ++i) {\n            int a = perm[i];\n            int b = perm[(i + 1) % N];\n            if (a <= b) {\n                energy += repulse[a][b];\n            } else {\n                energy += repulse[b][a];\n            }\n        }\n        if (energy < min_energy) {\n            min_energy = energy;\n        }\n    } while (next_permutation(perm.begin(), perm.end()));\n\n    cout << min_energy << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int L = Integer.parseInt(st.nextToken());\n\n        int[] S = new int[M + 1];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= M; i++) {\n            S[i] = Integer.parseInt(st.nextToken());\n        }\n\n        int[] K = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            K[i] = Integer.parseInt(st.nextToken());\n        }\n\n        int[][] sum = new int[M + 1][M + 1];\n        for (int i = 1; i <= M; i++) {\n            int currentSum = 0;\n            for (int j = i; j <= M; j++) {\n                currentSum += S[j];\n                sum[i][j] = currentSum / L;\n            }\n        }\n\n        int[][] dp = new int[N][M + 1];\n        for (int i = 0; i < N; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n\n        for (int j = 1; j <= M; j++) {\n            if (K[0] == j) {\n                dp[0][j] = 0;\n            }\n        }\n\n        for (int i = 1; i < N; i++) {\n            for (int prev = 1; prev <= M; prev++) {\n                if (dp[i - 1][prev] == Integer.MAX_VALUE) continue;\n                for (int curr = 1; curr <= M; curr++) {\n                    if (K[i] != curr) continue;\n                    int a = Math.min(prev, curr);\n                    int b = Math.max(prev, curr);\n                    int cost = sum[a][b];\n                    if (dp[i][curr] > dp[i - 1][prev] + cost) {\n                        dp[i][curr] = dp[i - 1][prev] + cost;\n                    }\n                }\n            }\n        }\n\n        int minEnergy = Integer.MAX_VALUE;\n        for (int j = 1; j <= M; j++) {\n            if (dp[N - 1][j] == Integer.MAX_VALUE) continue;\n            if (K[0] == j) {\n                int a = Math.min(j, K[N - 1]);\n                int b = Math.max(j, K[N - 1]);\n                int cost = sum[a][b];\n                minEnergy = Math.min(minEnergy, dp[N - 1][j] + cost);\n            }\n        }\n\n        System.out.println(minEnergy);\n    }\n}",
    "timestamp": "2025-08-05 21:26:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MagicalGirlSolution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int M = scanner.nextInt();\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        \n        int[] S = new int[M + 1];\n        for (int i = 1; i <= M; i++) {\n            S[i] = scanner.nextInt();\n        }\n        \n        int[] K = new int[N];\n        for (int i = 0; i < N; i++) {\n            K[i] = scanner.nextInt();\n        }\n        \n        int minEnergy = Integer.MAX_VALUE;\n        \n        for (int[] permutation : generatePermutations(K)) {\n            int energy = calculateEnergy(permutation, S, L);\n            minEnergy = Math.min(minEnergy, energy);\n        }\n        \n        System.out.println(minEnergy);\n        \n        scanner.close();\n    }\n    \n    private static int calculateEnergy(int[] arrangement, int[] S, int L) {\n        int energy = 0;\n        int N = arrangement.length;\n        \n        for (int i = 0; i < N; i++) {\n            int a = arrangement[i];\n            int b = arrangement[(i + 1) % N];\n            \n            int start = Math.min(a, b);\n            int end = Math.max(a, b);\n            \n            int sum = 0;\n            for (int j = start; j <= end; j++) {\n                sum += S[j];\n            }\n            \n            energy += Math.floor((double) sum / L);\n        }\n        \n        return energy;\n    }\n    \n    private static List<int[]> generatePermutations(int[] arr) {\n        List<int[]> permutations = new ArrayList<>();\n        generatePermutationsHelper(arr, 0, permutations);\n        return permutations;\n    }\n    \n    private static void generatePermutationsHelper(int[] arr, int start, List<int[]> permutations) {\n        if (start == arr.length - 1) {\n            permutations.add(arr.clone());\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, start, i);\n            generatePermutationsHelper(arr, start + 1, permutations);\n            swap(arr, start, i);\n        }\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
    "timestamp": "2025-08-05 21:26:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_M 100\n\nint main() {\n    int N, M, L;\n    int S[MAX_M + 1];\n    int K[MAX_N];\n    \n    scanf(\"%d %d %d\", &N, &M, &L);\n    \n    for (int i = 1; i <= M; i++) {\n        scanf(\"%d\", &S[i]);\n    }\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &K[i]);\n    }\n    \n    int min_energy = INT_MAX;\n    \n    for (int start = 0; start < N; start++) {\n        int current_energy = 0;\n        \n        for (int j = 0; j < N; j++) {\n            int curr_note = (start + j) % N;\n            int next_note = (start + j + 1) % N;\n            \n            int a = K[curr_note];\n            int b = K[next_note];\n            \n            int sum_beauty = 0;\n            if (a <= b) {\n                for (int k = a; k <= b; k++) {\n                    sum_beauty += S[k];\n                }\n            } else {\n                for (int k = b; k <= a; k++) {\n                    sum_beauty += S[k];\n                }\n            }\n            \n            current_energy += sum_beauty / L;\n        }\n        \n        min_energy = (current_energy < min_energy) ? current_energy : min_energy;\n    }\n    \n    printf(\"%d\\n\", min_energy);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n\n    vector<int> S(M + 1);\n    for (int i = 1; i <= M; i++) {\n        cin >> S[i];\n    }\n\n    vector<int> K(N);\n    for (int i = 0; i < N; i++) {\n        cin >> K[i];\n    }\n\n    vector<int> prefixSum(M + 1, 0);\n    for (int i = 1; i <= M; i++) {\n        prefixSum[i] = prefixSum[i-1] + S[i];\n    }\n\n    int minEnergy = INT_MAX;\n    \n    vector<int> order(N);\n    for (int i = 0; i < N; i++) {\n        order[i] = i;\n    }\n\n    do {\n        int currentEnergy = 0;\n        for (int i = 0; i < N; i++) {\n            int a = K[order[i]];\n            int b = K[order[(i + 1) % N]];\n            \n            int start = min(a, b);\n            int end = max(a, b);\n            \n            int rangeSum = prefixSum[end] - prefixSum[start - 1];\n            currentEnergy += rangeSum / L;\n        }\n        \n        minEnergy = min(minEnergy, currentEnergy);\n    } while (next_permutation(order.begin(), order.end()));\n\n    cout << minEnergy << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef minimum_mental_energy(N, M, L, P, S):\n    def repulsive_force(a, b):\n        if a > b:\n            a, b = b, a\n        return sum(S[a-1:b]) // L\n\n    pitches_permutations = itertools.permutations(P)\n    min_energy = float('inf')\n\n    for perm in pitches_permutations:\n        current_energy = 0\n        for i in range(N):\n            a = perm[i]\n            b = perm[(i + 1) % N]\n            current_energy += repulsive_force(a, b)\n        \n        min_energy = min(min_energy, current_energy)\n    \n    return min_energy\n\n# Example usage\nN = 4\nM = 5\nL = 3\nP = [1, 3, 2, 5]\nS = [3, 1, 9, 7, 5]\n\nprint(minimum_mental_energy(N, M, L, P, S))",
    "timestamp": "2025-08-13 06:19:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class MagicalCircle {\n    public static int findMinEnergy(int[] S, int L, int[] K) {\n        int n = K.length;\n        int m = S.length;\n\n        int[][] beautySum = new int[m + 1][m + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = i; j <= m; j++) {\n                beautySum[i][j] = beautySum[i][j - 1] + S[j - 1];\n            }\n        }\n\n        int[][] dp = new int[n][m + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < n; i++) {\n            dp[i][K[i]] = 0;\n        }\n\n        for (int len = 2; len <= n; len++) {\n            int[][] newDp = new int[n][m + 1];\n            for (int[] row : newDp) {\n                Arrays.fill(row, Integer.MAX_VALUE);\n            }\n\n            for (int i = 0; i < n; i++) {\n                int prevIndex = (i - 1 + n) % n;\n                for (int k = 1; k <= m; k++) {\n                    int energy = dp[prevIndex][k];\n                    for (int j = 1; j <= m; j++) {\n                        if (newDp[i][j] > energy + beautySum[Math.min(k, j)][Math.max(k, j)] / L) {\n                            newDp[i][j] = energy + beautySum[Math.min(k, j)][Math.max(k, j)] / L;\n                        }\n                    }\n                }\n            }\n\n            dp = newDp;\n        }\n\n        int minEnergy = Integer.MAX_VALUE;\n        for (int k = 1; k <= m; k++) {\n            minEnergy = Math.min(minEnergy, dp[0][k]);\n        }\n\n        return minEnergy;\n    }\n\n    public static void main(String[] args) {\n        int[] S = {3, 1, 4, 1};\n        int L = 3;\n        int[] K = {1, 2, 3, 4, 2};\n        System.out.println(findMinEnergy(S, L, K)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 06:20:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint main() {\n    int N, M, L;\n    scanf(\"%d %d %d\", &N, &M, &L);\n    \n    int S[M+1];\n    for (int i = 1; i <= M; ++i) {\n        scanf(\"%d\", &S[i]);\n    }\n    \n    int K[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &K[i]);\n    }\n    \n    int prefixSum[M+1];\n    prefixSum[0] = 0;\n    for (int i = 1; i <= M; ++i) {\n        prefixSum[i] = prefixSum[i-1] + S[i];\n    }\n    \n    int minEnergy = 0x7FFFFFFF;\n    for (int start = 0; start < N; ++start) {\n        int energy = 0;\n        for (int i = 0; i < N; ++i) {\n            int a = K[i];\n            int b = K[(i+1)%N];\n            if (a > b) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            energy += (prefixSum[b] - prefixSum[a-1]) / L;\n        }\n        if (energy < minEnergy) {\n            minEnergy = energy;\n        }\n        \n        // Rotate the notes arrangement\n        int firstNote = K[0];\n        for (int i = 0; i < N-1; ++i) {\n            K[i] = K[i+1];\n        }\n        K[N-1] = firstNote;\n    }\n    \n    printf(\"%d\\n\", minEnergy);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:20:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_magical_circle(N, M, L, S):\n    min_energy = float('inf')\n    \n    # Generate all possible permutations of notes\n    from itertools import permutations\n    \n    for perm in permutations(range(1, M+1), N):\n        current_energy = 0\n        \n        # Calculate energy for this arrangement\n        for i in range(N):\n            left = perm[i]\n            right = perm[(i+1) % N]\n            \n            # Ensure left <= right for calculation\n            if left > right:\n                left, right = right, left\n            \n            # Calculate repulsive force\n            subarray_sum = sum(S[j-1] for j in range(left, right+1))\n            current_energy += subarray_sum // L\n        \n        # Update minimum energy\n        min_energy = min(min_energy, current_energy)\n    \n    return min_energy\n\n# Input handling\ndef main():\n    N, M, L = map(int, input().split())\n    S = list(map(int, input().split()))\n    \n    result = solve_magical_circle(N, M, L, S)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:20:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M, L = map(int, input[ptr:ptr+3])\n    ptr +=3\n    S = list(map(int, input[ptr:ptr+M]))\n    ptr +=M\n    K = list(map(int, input[ptr:ptr+N]))\n    ptr +=N\n    \n    # Precompute prefix sums\n    prefix = [0]*(M+2)\n    for i in range(1, M+1):\n        prefix[i] = prefix[i-1] + S[i-1]\n    \n    # Precompute repulsive forces between a and b (a <= b)\n    repulse = [[0]*(M+1) for _ in range(M+1)]\n    for a in range(1, M+1):\n        for b in range(a, M+1):\n            total = prefix[b] - prefix[a-1]\n            repulse[a][b] = total // L\n    \n    # Since the circle is undirected, we can model this as a graph where we need to find a minimum spanning tree-like structure,\n    # but since it's a cycle, it's more like finding a minimum weight Hamiltonian cycle, which is NP-hard.\n    # However, given the constraints (M=200, N=200), we need a smarter approach.\n    \n    # We can model this as a problem where we need to select N edges (with possible duplicates) that form a cycle, minimizing the total weight.\n    # The optimal arrangement is to use the same note for all positions, but since N can be 1, but in that case, the repulsive force is zero.\n    # However, if N >=2, the minimal energy is to choose the note with minimal repulse[a][a] * N.\n    \n    # But this is not always the case. For example, if repulse[a][b] + repulse[b][a] is less than 2*repulse[a][a], then alternating a and b is better.\n    # So the minimal energy is min between:\n    # 1. All notes are the same: N * repulse[a][a]\n    # 2. Alternating two notes a and b: (repulse[a][b] + repulse[b][a]) * (N // 2) + (repulse[a][a] if N is odd)\n    \n    min_single = min(repulse[a][a] for a in range(1, M+1))\n    option1 = min_single * N\n    \n    # Find minimal pair a <= b, then repulse[a][b] + repulse[b][a] is minimized\n    min_pair_sum = float('inf')\n    for a in range(1, M+1):\n        for b in range(1, M+1):\n            x, y = min(a, b), max(a, b)\n            current_sum = repulse[x][y] + repulse[min(b, a)][max(b, a)]\n            if current_sum < min_pair_sum:\n                min_pair_sum = current_sum\n    \n    if N == 1:\n        print(0)\n        return\n    \n    if N % 2 == 0:\n        option2 = (min_pair_sum) * (N // 2)\n    else:\n        option2 = (min_pair_sum) * (N // 2) + min_single\n    \n    total_min = min(option1, option2)\n    print(total_min)\n\nsolve()",
    "timestamp": "2025-08-13 06:20:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<int> S(M + 1);\n    for (int i = 1; i <= M; ++i) {\n        cin >> S[i];\n    }\n    \n    vector<int> K(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> K[i];\n    }\n\n    // Precompute cumulative sums\n    vector<int> accumulatedS(M + 1, 0);\n    for (int i = 1; i <= M; ++i) {\n        accumulatedS[i] = accumulatedS[i - 1] + S[i];\n    }\n\n    auto computeEnergy = [&](int a, int b) {\n        if (a > b) swap(a, b);\n        return (accumulatedS[b] - accumulatedS[a - 1]) / L; \n    };\n\n    int minEnergy = INT_MAX;\n    vector<int> P(N);\n\n    // We can use next_permutation to try each permutation to find the minimum energy\n    for (int i = 0; i < N; ++i) {\n        P[i] = i;\n    }\n\n    do {\n        int currentEnergy = 0;\n        for (int i = 0; i < N; ++i) {\n            int a = K[P[i]];\n            int b = K[P[(i + 1) % N]];\n            currentEnergy += computeEnergy(a, b);\n        }\n        minEnergy = min(minEnergy, currentEnergy);\n    } while (next_permutation(P.begin(), P.end()));\n\n    cout << minEnergy << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:28"
  }
]