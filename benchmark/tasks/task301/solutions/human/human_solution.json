[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 2+ amax, cp.mp[nowx] + 2+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, int> P;\n\ninline LL eval(P p, const vector<LL>& sum, LL C) {\n    return p.first + sum[p.second] - C;\n}\ninline int lower_bound(LL l, const deque<P>& s, const vector<LL>& sum, LL C) {\n    int lb = -1, ub = s.size();\n    while(ub - lb > 1) {\n        int k = (lb + ub) / 2;\n        if(eval(s[k], sum, C) >= l) {\n            ub = k;\n        } else {\n            lb = k;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int Q;\n    LL L;\n    while(cin >> Q >> L && Q > 0) {\n        LL C = 0;\n        vector<LL> sum(Q);\n        deque<P> s;\n        for(int i = 0; i < Q; i++) {\n            int type;\n            scanf(\"%d\", &type);\n\n            if(type == 0) {\n                s.push_back(P(L, i));\n            } else if(type == 1) {\n                LL D;\n                scanf(\"%lld\", &D);\n                C += D;\n                int ans = 0;\n                while(s.size()) {\n                    P p = s.front();\n                    if(eval(p, sum, C) <= 0) {\n                        ans++;\n                        s.pop_front();\n                    } else {\n                        break;\n                    }\n                }\n                if(ans > 0) {\n                    cout << \"damage \";\n                    cout << ans << endl;\n                }\n            } else if(type == 2) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    s.erase(s.begin() + k);\n                    cout << \"hit\" << endl;\n                } else {\n                    cout << \"miss\" << endl;\n                }\n            } else if(type == 3) {\n                LL x, r;\n                scanf(\"%lld %lld\", &x, &r);\n                LL a = x - r, b = x + r; // [a, b]\n                //cout << \"[\" << a << \", \" << b << \"]\" << endl;\n                int begin = lower_bound(a, s, sum, C);\n                auto it = s.begin() + begin;\n                int ans = 0;\n                while(it != s.end()) {\n                    auto dist = eval(*it, sum, C);\n                    if(dist > b) break;\n                    ans++;\n                    assert(dist >= a);\n                    it = s.erase(it);\n                }\n                cout << \"bomb \" << ans << endl;\n            } else if(type == 4) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    cout << \"distance \";\n                    cout << eval(s[k], sum, C) << endl;\n                } else {\n                    cout << \"distance -1\" << endl;\n                }\n            }\n\n            sum[i] = C;\n        }\n        cout << \"end\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\n/* typedef */\n\nstruct Treap {\n  struct Node {\n    int key, fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%d, fix=%d, size=%d\\n\",\n\t     this->left->size + k, key, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode;\n  node buf, buf0;\n  \n  Treap() {\n    buf = buf0 = (node)malloc(sizeof(Node) * (MAX_Q + 1));\n    nullnode = new Node;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->size = 0;\n    root = nullnode;\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n  \n  void rot_l(node& k1) {\n    node k2;\n    k2 = k1->right;\n    k1->right = k2->left;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->left = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2;\n    k2 = k1->left;\n    k1->left = k2->right;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->right = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void insert(node& t, int x) {\n    if (t == nullnode) {\n      t = buf++;\n      t->left = t->right = nullnode;\n      t->key = x;\n      t->fix = rand();\n      t->size = 1;\n    }\n    else {\n      if (t->key == x) return;\n      else {\n\tt->size++;\n\tif (x < t->key) {\n\t  insert(t->left, x);\n\t  if (t->left->fix > t->fix) rot_r(t);\n\t}\n\telse {\n\t  insert(t->right, x);\n\t  if (t->right->fix > t->fix) rot_l(t);\n\t}\n      }\n    }\n  }\n  void insert(int x) { insert(root, x); }\n\n  void remove(node& t, int x) {\n    if (t == nullnode) return;\n    \n    t->size--;\n    if (x > t->key) remove(t->right, x);\n    else if (x < t->key) remove(t->left, x);\n    else {\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove(t->left, x);\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove(t->right, x);\n\t}\n      }\n    }\n  }  \n  void remove(int x) { remove(root, x); }\n\n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 < 0 || t->size < r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    t->size = 1 + t->left->size + t->right->size;\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove_range(t->left, t->left->size - 1, t->left->size);\n\t  t->size = 1 + t->left->size + t->right->size;\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove_range(t->right, 0, 1);\n\t  t->size = 1 + t->left->size + t->right->size;\n\t}\n      }\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n  \n  node find(int x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  int findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return -1;\n  }\n\n  int upper_bound(int x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n  \n  void inorder(node ptr, int k) {\n    if (ptr == nullnode) return;\n    if (ptr != NULL) {\n      inorder(ptr->left, k);\n      ptr->print(k + ptr->left->size);\n      inorder(ptr->right, k + ptr->left->size + 1);\n    }\n  }\n  void inorder() { inorder(root, 0); }\n};\n\n/* global variables */\n\nint qn, ln;\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    int cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tint d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tif (i > 0) {\n\t  int n = trp.remove_range(0, i);\n\t  if (n > 0)\n\t    printf(\"damage %d\\n\", n);\n\t}\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\t\n\tint n = trp.remove_range(k - 1, k);\n\tcout << ((n > 0) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tint x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\t\n\tint x = trp.findat(k - 1);\n\tprintf(\"distance %d\\n\", x - cpos);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  int Q, L;\n  while(scanf(\"%d %d\", &Q, &L) && (Q|L)) {\n    vector<int> v;\n    while(Q--) {\n      int op;\n      scanf(\"%d\", &op);\n      if(0) {\n      } else if(op == 0) {\n        v.push_back(L);\n      } else if(op == 1) {\n        int d;\n        scanf(\"%d\", &d);\n        int damage = 0;\n        for(vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n          *it -= d;\n          if(*it <= 0) {\n            ++damage;\n            v.erase(it);\n            --it;\n          }\n        }\n        if(damage) printf(\"damage %d\\n\", damage);\n      } else if(op == 2) {\n        int k;\n        scanf(\"%d\", &k);\n        if(k <= v.size()) {\n          printf(\"hit\\n\");\n          v.erase(v.begin()+k-1);\n        } else {\n          printf(\"miss\\n\");\n        }\n      } else if(op == 3) {\n        int x, r;\n        scanf(\"%d %d\", &x, &r);\n        vector<int>::iterator begin, end;\n        begin = lower_bound(v.begin(), v.end(), x-r);\n        end = upper_bound(v.begin(), v.end(), x+r);\n        printf(\"bomb %d\\n\", end-begin);\n        v.erase(begin, end);\n      } else if(op == 4) {\n        int k;\n        scanf(\"%d\", &k);\n        if(k <= v.size()) {\n          printf(\"distance %d\\n\", v[k-1]);\n        } else {\n          printf(\"distance -1\\n\");\n        }\n      }\n    }\n    printf(\"end\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, int> P;\n\ninline LL eval(P p, const vector<LL>& sum, LL C) {\n    return p.first + sum[p.second] - C;\n}\ninline int lower_bound(LL l, const deque<P>& s, const vector<LL>& sum, LL C) {\n    int lb = -1, ub = s.size();\n    while(ub - lb > 1) {\n        int k = (lb + ub) / 2;\n        if(eval(s[k], sum, C) >= l) {\n            ub = k;\n        } else {\n            lb = k;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int Q;\n    LL L;\n    while(cin >> Q >> L) {\n        LL C = 0;\n        vector<LL> sum(Q);\n        deque<P> s;\n        for(int i = 0; i < Q; i++) {\n            int type;\n            scanf(\"%d\", &type);\n\n            if(type == 0) {\n                s.push_back(P(L, i));\n            } else if(type == 1) {\n                LL D;\n                scanf(\"%lld\", &D);\n                C += D;\n                int ans = 0;\n                while(s.size()) {\n                    P p = s.front();\n                    if(eval(p, sum, C) <= 0) {\n                        ans++;\n                        s.pop_front();\n                    } else {\n                        break;\n                    }\n                }\n                if(ans > 0) {\n                    cout << \"damage \";\n                    cout << ans << endl;\n                }\n            } else if(type == 2) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    s.erase(s.begin() + k);\n                    cout << \"hit\" << endl;\n                } else {\n                    cout << \"miss\" << endl;\n                }\n            } else if(type == 3) {\n                LL x, r;\n                scanf(\"%lld %lld\", &x, &r);\n                LL a = x - r, b = x + r; // [a, b]\n                //cout << \"[\" << a << \", \" << b << \"]\" << endl;\n                int begin = lower_bound(a, s, sum, C);\n                auto it = s.begin() + begin;\n                int ans = 0;\n                while(it != s.end()) {\n                    auto dist = eval(*it, sum, C);\n                    if(dist > b) break;\n                    ans++;\n                    assert(dist >= a);\n                    it = s.erase(it);\n                }\n                cout << \"bomb \" << ans << endl;\n            } else if(type == 4) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    cout << \"distance \";\n                    cout << eval(s[k], sum, C) << endl;\n                } else {\n                    cout << \"distance -1\" << endl;\n                }\n            }\n\n            sum[i] = C;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int Add;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\ninline int Dist(Node *t)\n{\n  if(t == (Node *)NULL) return(-1);\n  else return(t -> Value + t -> Add);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  if(t -> Lch != (Node *)NULL) t -> Lch -> Add += t -> Add;\n  if(t -> Rch != (Node *)NULL) t -> Rch -> Add += t -> Add;\n  t -> Value += t -> Add;\n  t -> Add = 0;\n\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  Update(l), Update(r);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  Update(t);\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  Update(root);\n  if(root == (Node *)NULL) return(0);\n  if(Value < root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nint main()\n{\n  int Q, L;\n  char buff[32];\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%d %d\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    while(Q--) {\n      //    Dump(root);\n      //puts(\"\");\n\n      int type;\n      scanf(\"%d\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L), L);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%d\", &d);\n        if(root != (Node *)NULL) {\n          root -> Add -= d;\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %d\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%d\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%d %d\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, x - r - 1));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, x + r));\n        printf(\"%d %d %d\\n\", Count(S.first), Count(T.first), Count(T.second));\n\n        printf(\"bomb %d\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%d\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = Dist(T.first);\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %d\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\nconst long long INF = 1LL << 60;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key, minkey;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, minkey=%lld, fix=%d, size=%d\\n\",\n\t     k, key, minkey, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[2 * MAX_Q], buf1;\n  \n  Treap() {\n    nullnode = &buf1;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->key = nullnode->minkey = INF;\n    nullnode->fix = nullnode->size = 0;\n    clear();\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n\n  void update(node& t) {\n    t->size = 1 + t->left->size + t->right->size;\n    t->minkey = t->key;\n    if (t->minkey > t->left->minkey) t->minkey = t->left->minkey;\n    if (t->minkey > t->right->minkey) t->minkey = t->right->minkey;\n  }\n\n  node gen_node(ll x) {\n    node t = buf++;\n    t->left = t->right = nullnode;\n    t->key = t->minkey = x;\n    t->fix = rand();\n    t->size = 1;\n    return t;\n  }\n  \n  void rot_l(node& k1) {\n    node k2 = k1->right;\n    k1->right = k2->left;\n    k2->left = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2 = k1->left;\n    k1->left = k2->right;\n    k2->right = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void append(node& t, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      append(t->right, x);\n      update(t);\n      if (t->right->fix > t->fix) rot_l(t);\n    }\n  }\n  void append(ll x) { append(root, x); }\n  \n  void insert(node& t, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else if (x < t->key) {\n      insert(t->left, x);\n      update(t);\n      if (t->left->fix > t->fix) rot_r(t);\n    }\n    else if (x > t->key) {\n      insert(t->right, x);\n      update(t);\n      if (t->right->fix > t->fix) rot_l(t);\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void insertat(node& t, int i, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tappend(t->left, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else if (i < lsize) {\n\tinsertat(t->left, i, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else {\n\tinsertat(t->right, i - (lsize + 1), x);\n\tupdate(t);\n\tif (t->right->fix > t->fix) rot_l(t);\n      }\n    }\n  }\n  void insertat(int i, ll x) { insertat(root, i, x); }\n\n  void set(node& t, int i, ll x) {\n    if (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tt->key = t->minkey = x;\n\tupdate(t);\n      }\n      else if (i < lsize) {\n\tset(t->left, i, x);\n\tupdate(t);\n      }\n      else {\n\tset(t->right, i - (lsize + 1), x);\n\tupdate(t);\n      }\n    }\n  }\n  void set(int i, ll x) { set(root, i, x); }\n  \n  void remove_node(node& t) {\n    if (t == nullnode) return;\n    if (t->left == nullnode || t->right == nullnode) {\n      if (t->left == nullnode)\n\tt = t->right;\n      else\n\tt = t->left;\n    }\n    else {\n      if (t->left->fix < t->right->fix) {\n\trot_l(t);\n\tremove_node(t->left);\n\tupdate(t);\n      }\n      else {\n\trot_r(t);\n\tremove_node(t->right);\n\tupdate(t);\n      }\n    }\n  }\n\n  ll removeat(node& t, int i) {\n    ll ret = INF;\n\n    if (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tret = t->key;\n\tremove_node(t);\n      }\n      else if (i < lsize) {\n\tret = removeat(t->left, i);\n\tupdate(t);\n      }\n      else {\n\tret = removeat(t->right, i - (lsize + 1));\n\tupdate(t);\n      }\n    }\n\n    return ret;\n  }\n  ll removeat(int i) { return removeat(root, i); }\n  \n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 <= 0 || t->size <= r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    update(t);\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      remove_node(t);\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n\n  ll min_range(node& t, int r0, int r1) {\n    if (t == nullnode) return INF;\n    if (r1 <= 0 || t->size <= r0) return INF;\n    \n    if (r0 <= 0 && t->size <= r1) return t->minkey;\n\n    int lsize = t->left->size;\n    ll minval = INF;\n\n    if (r0 <= lsize && lsize < r1)\n      minval = t->key;\n    if (r0 <= lsize) {\n      ll minl = min_range(t->left, r0, r1);\n      if (minval > minl) minval = minl;\n    }\n    if (lsize + 1 < r1) {\n      ll minr = min_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n      if (minval > minr) minval = minr;\n    }\n\n    return minval;\n  }\n  ll min_range(int r0, int r1) { return min_range(root, r0, r1); }\n\n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return INF;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n\n  \n  void print(node t, int k, int indent) {\n    if (t == nullnode) return;\n    if (t != NULL) {\n      for (int i = 0; i < indent; i++) cout << \"  \";\n      t->print(k + t->left->size);\n      print(t->left, k, indent + 1);\n      print(t->right, k + t->left->size + 1, indent + 1);\n    }\n  }\n  void print() { print(root, 0, 0); }\n\n  void inorder(node t) {\n    if (t != nullnode && t != NULL) {\n      inorder(t->left);\n      cout << t->key << ' ';\n      inorder(t->right);\n    }\n  }\n  void inorder() {\n    inorder(root);\n    cout << endl;\n  }\n};\n\n/* global variables */\n\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  srand(time(NULL));\n\n  for (;;) {\n    int qn;\n    ll ln;\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tint n = trp.remove_range(0, i);\n\tif (n > 0)\n\t  printf(\"damage %d\\n\", n);\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\tk--;\n\t\n\tll x = trp.removeat(k);\n\tcout << ((x < INF) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\tk--;\n\t\n\tll x = trp.findat(k);\n\tprintf(\"distance %lld\\n\", (x < INF) ? x - cpos : -1);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 1+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tif (damage) {\n\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 1+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(max(cp.mp[nowx]+2,cp.mp[q.a] + 1), cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, fix=%d, size=%d\\n\",\n\t     this->left->size + k, key, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode;\n  node buf, buf0;\n  \n  Treap() {\n    buf = buf0 = (node)malloc(sizeof(Node) * (MAX_Q + 1));\n    nullnode = new Node;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->size = 0;\n    root = nullnode;\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n  \n  void rot_l(node& k1) {\n    node k2;\n    k2 = k1->right;\n    k1->right = k2->left;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->left = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2;\n    k2 = k1->left;\n    k1->left = k2->right;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->right = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void insert(node& t, ll x) {\n    if (t == nullnode) {\n      t = buf++;\n      t->left = t->right = nullnode;\n      t->key = x;\n      t->fix = rand();\n      t->size = 1;\n    }\n    else {\n      if (t->key == x) return;\n      else {\n\tt->size++;\n\tif (x < t->key) {\n\t  insert(t->left, x);\n\t  if (t->left->fix > t->fix) rot_r(t);\n\t}\n\telse {\n\t  insert(t->right, x);\n\t  if (t->right->fix > t->fix) rot_l(t);\n\t}\n      }\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void remove(node& t, ll x) {\n    if (t == nullnode) return;\n    \n    t->size--;\n    if (x > t->key) remove(t->right, x);\n    else if (x < t->key) remove(t->left, x);\n    else {\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove(t->left, x);\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove(t->right, x);\n\t}\n      }\n    }\n  }  \n  void remove(ll x) { remove(root, x); }\n\n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 < 0 || t->size < r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    t->size = 1 + t->left->size + t->right->size;\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove_range(t->left, t->left->size - 1, t->left->size);\n\t  t->size = 1 + t->left->size + t->right->size;\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove_range(t->right, 0, 1);\n\t  t->size = 1 + t->left->size + t->right->size;\n\t}\n      }\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n  \n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return -1;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n  \n  void inorder(node ptr, int k) {\n    if (ptr == nullnode) return;\n    if (ptr != NULL) {\n      inorder(ptr->left, k);\n      ptr->print(k + ptr->left->size);\n      inorder(ptr->right, k + ptr->left->size + 1);\n    }\n  }\n  void inorder() { inorder(root, 0); }\n};\n\n/* global variables */\n\nint qn, ln;\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tif (i > 0) {\n\t  int n = trp.remove_range(0, i);\n\t  if (n > 0)\n\t    printf(\"damage %d\\n\", n);\n\t}\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\t\n\tint n = trp.remove_range(k - 1, k);\n\tcout << ((n > 0) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\t\n\tll x = trp.findat(k - 1);\n\tprintf(\"distance %lld\\n\", x - cpos);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\n\nusing Tree = tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int Q, L;\n    while(cin >> Q >> L) {\n        if(Q == 0 && L == 0) break;\n        Tree st;\n\n        ll cur = 0LL;\n\n        rep(i, Q) {\n\n            // cout << i << \" cur \" << cur << \" st[\";\n            // for(auto&& j : st) cout << j << \", \";\n            //     cout << \"]\" << endl;\n\n            int query;\n            cin >> query;\n            if (query == 0) {\n                st.insert(L + cur);\n            } else if (query == 1) {\n                ll d;\n                cin >> d;\n                cur += d;\n                int cnt = 0;\n                while (st.size() > 0 && *st.begin() <= cur) {\n                    cnt++;\n                    st.erase(st.begin());\n                }\n                if(cnt > 0 ) cout << \"damage \" << cnt << '\\n';\n            } else if (query == 2) {\n                int k;\n                cin >> k;\n                auto it = st.find_by_order(k - 1);\n                if (it == st.end()) cout << \"miss\" << '\\n';\n                else {\n                    cout << \"hit\" << '\\n';\n                    st.erase(it);\n                }\n            } else if (query == 3) {\n                ll x, r;\n                cin >> x >> r;\n                ll L = cur + x - r, R = cur + x + r;\n                int cnt = 0;\n                auto it = st.lower_bound(L);\n                while (it != st.end() && *it <= R) {\n                    ++cnt;\n                    it = st.erase(it);\n                }\n                cout << \"bomb \" << cnt << endl;\n            } else {\n                int k;\n                cin >> k;\n                auto it = st.find_by_order(k - 1);\n                if (it == st.end()) cout << \"distance -1\" << '\\n';\n                else {\n                    cout << \"distance \" << (*it) - cur << '\\n';\n                }\n            }\n        }\n        cout << \"end\" << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int Add;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\ninline int Dist(Node *t)\n{\n  if(t == (Node *)NULL) return(-1);\n  else return(t -> Value + t -> Add);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  if(t -> Lch != (Node *)NULL) t -> Lch -> Add += t -> Add;\n  if(t -> Rch != (Node *)NULL) t -> Rch -> Add += t -> Add;\n  t -> Value += t -> Add;\n  t -> Add = 0;\n\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  Update(l), Update(r);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  Update(t);\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  Update(root);\n  if(root == (Node *)NULL) return(0);\n  if(Value < root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nint main()\n{\n  int Q, L;\n  char buff[32];\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%d %d\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    while(Q--) {\n      //    Dump(root);\n      //puts(\"\");\n\n      int type;\n      scanf(\"%d\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L), L);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%d\", &d);\n        if(root != (Node *)NULL) {\n          root -> Add -= d;\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %d\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%d\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%d %d\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, x - r - 1));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, x + r));\n        printf(\"bomb %d\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%d\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = Dist(T.first);\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %d\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\tfor (auto&q : qs) {\n\t\t\t\tif (q.type == 1) {\n\t\t\t\t}\n\t\t\t\telse if (q.type == 3) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tif (damage) {\n\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + amax, cp.mp[nowx] + amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[nowx + amax] - cp.revmp[nowx];\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tif (damage) {\n\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 1+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint l;\nlong long base;\nvector<long long> invaders;\n\nvoid appearance() {\n\tinvaders.push_back(l + base);\n}\n\nvoid move() {\n\tint d;\n\tscanf(\"%d\", &d);\n\n\tbase += d;\n\n\tvector<long long>::iterator en = upper_bound(invaders.begin(), invaders.end(), base);\n\n\tif(invaders.begin() != en) {\n\t\tprintf(\"damage %d\\n\", (int)(en - invaders.begin()));\n\t\tinvaders.erase(invaders.begin(), en);\n\t}\n}\n\nvoid rifle() {\n\tint k;\n\tscanf(\"%d\", &k);\n\n\tif(invaders.size() >= k) {\n\t\tinvaders.erase(invaders.begin() + (k - 1));\n\t\tputs(\"hit\");\n\t}\n\telse\n\t\tputs(\"miss\");\n}\n\nvoid grenade() {\n\tint r;\n\tlong long x;\n\tscanf(\"%lld %d\", &x, &r);\n\n\tx += base;\n\tvector<long long>::iterator it = lower_bound(invaders.begin(), invaders.end(), x - r);\n\n\tint cnt = 0;\n\twhile(it != invaders.end() && *it <= x + r) {\n\t\t++cnt;\n\t\tit = invaders.erase(it);\n\t}\n\n\tprintf(\"bomb %d\\n\", cnt);\n}\n\nvoid distance() {\n\tint k;\n\tscanf(\"%d\", &k);\n\n\tif(invaders.size() >= k)\n\t\tprintf(\"distance %lld\\n\", invaders[k - 1] - base);\n\telse\n\t\tprintf(\"distance -1\\n\");\n}\n\nint main() {\n\tvoid (*operation[5])() = {&appearance, &move, &rifle, &grenade, &distance};\n\n\tfor(int q; scanf(\"%d %d\", &q, &l), q;) {\n\t\tbase = 0;\n\t\tinvaders.clear();\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint in;\n\t\t\tscanf(\"%d\", &in);\n\t\t\t(*operation[in])();\n\t\t}\n\n\t\tputs(\"end\");\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 0, int b = -1) {\n\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b <= l || r <= a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L], cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx], cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 2+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a], cp.mp[q.b] + 1, make_pair(1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 2, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r)?????´??°??????. ?????????0-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r)?????????????????¨?????????????????????. ?????????0-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L], cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx], cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 2+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a], cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a], cp.mp[q.b] + 1, make_pair(1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, int> P;\n\ninline LL eval(P p, const vector<LL>& sum, LL C) {\n    return p.first + sum[p.second] - C;\n}\ninline int lower_bound(LL l, const deque<P>& s, const vector<LL>& sum, LL C) {\n    int lb = -1, ub = s.size();\n    while(ub - lb > 1) {\n        int k = (lb + ub) / 2;\n        if(eval(s[k], sum, C) >= l) {\n            ub = k;\n        } else {\n            lb = k;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int Q;\n    LL L;\n    while(cin >> Q >> L) {\n        LL C = 0;\n        vector<LL> sum(Q);\n        deque<P> s;\n        for(int i = 0; i < Q; i++) {\n            int type;\n            scanf(\"%d\", &type);\n\n            if(type == 0) {\n                s.push_back(P(L, i));\n            } else if(type == 1) {\n                LL D;\n                scanf(\"%lld\", &D);\n                C += D;\n                int ans = 0;\n                while(s.size()) {\n                    P p = s.front();\n                    if(eval(p, sum, C) <= 0) {\n                        ans++;\n                        s.pop_front();\n                    } else {\n                        break;\n                    }\n                }\n                if(ans > 0) {\n                    cout << \"damage \";\n                    cout << ans << endl;\n                }\n            } else if(type == 2) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    s.erase(s.begin() + k);\n                    cout << \"hit\" << endl;\n                } else {\n                    cout << \"miss\" << endl;\n                }\n            } else if(type == 3) {\n                LL x, r;\n                scanf(\"%lld %lld\", &x, &r);\n                LL a = x - r, b = x + r; // [a, b]\n                //cout << \"[\" << a << \", \" << b << \"]\" << endl;\n                int begin = lower_bound(a, s, sum, C);\n                auto it = s.begin() + begin;\n                int ans = 0;\n                while(it != s.end()) {\n                    auto dist = eval(*it, sum, C);\n                    if(dist > b) break;\n                    ans++;\n                    assert(dist >= a);\n                    it = s.erase(it);\n                }\n                cout << \"bomb \" << ans << endl;\n            } else if(type == 4) {\n                int k;\n                scanf(\"%d\", &k);\n                if(s.size() >= k) {\n                    k--;\n                    cout << \"distance \";\n                    cout << eval(s[k], sum, C) << endl;\n                } else {\n                    cout << \"distance -1\" << endl;\n                }\n            }\n\n            sum[i] = C;\n        }\n        cout << \"end\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n#define int long long\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int Add;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\ninline int Dist(Node *t)\n{\n  if(t == (Node *)NULL) return(-1);\n  else return(t -> Value + t -> Add);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  if(t -> Lch != (Node *)NULL) t -> Lch -> Add += t -> Add;\n  if(t -> Rch != (Node *)NULL) t -> Rch -> Add += t -> Add;\n  t -> Value += t -> Add;\n  t -> Add = 0;\n\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  Update(l), Update(r);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  Update(t);\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  Update(root);\n  if(root == (Node *)NULL) return(0);\n  if(Value <= root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nsigned main()\n{\n  int Q, L;\n  char buff[32];\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%lld %lld\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    while(Q--) {\n      int type;\n      scanf(\"%lld\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L), L);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%lld\", &d);\n        if(root != (Node *)NULL) {\n          root -> Add -= d;\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %lld\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%lld\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%lld %lld\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, x - r));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, x + r + 1));\n        printf(\"bomb %lld\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%lld\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = Dist(T.first);\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %lld\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\tfor (auto&q : qs) {\n\t\t\t\tif (q.type == 1) {\n\t\t\t\t}\n\t\t\t\telse if (q.type == 3) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tif (damage) {\n\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + amax, cp.mp[nowx] + amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] + amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ELM;\n\nclass RMQ {\nprivate:\n  int n;\n  ELM *dat;\npublic:\n  RMQ(int _n, ELM v = 0) {\n    n = 1;\n    while(n < _n) n *= 2;\n    dat = new ELM[2*n-1];\n    for(int i = 0; i < 2*n-1; ++i) dat[i] = v;\n  }\n\n  ~RMQ() {\n    delete[] dat;\n  }\n\n  ELM at(int index) const {\n    return dat[index+n-1];\n  }\n\n  void update(int k, ELM a, bool flag = false) {\n    k += n-1;\n    dat[k] = a;\n    if(dat[k] >= 0) ; else {\n      cerr << \"dat[\" << k << \"]=\" << dat[k] << endl;\n      assert(false);\n    }\n    while(k) {\n      k = (k-1)/2;\n      dat[k] = dat[k*2+1] + dat[k*2+2];\n      assert(dat[k] >= 0);\n    }\n  }\n\n  // sum of A of [a, b)\n  ELM query(const int &a, const int &b,\n            int k = 0, int l = 0, int r = 0) const {\n    if(k == 0) r = n;\n\n    if(r <= a || b <= l) return 0;\n\n    if(a <= l && r <= b) {\n      return dat[k];\n    } else {\n      ELM vl = query(a, b, k*2+1, l, (l+r)/2);\n      ELM vr = query(a, b, k*2+2, (l+r)/2, r);\n      return vl + vr;\n    }\n  }\n\n  // sum of A of [a, b) with erase\n  ELM queryE(const int &a, const int &b,\n             int k = 0, int l = 0, int r = 0) {\n    if(k == 0) r = n;\n\n    if(r <= a || b <= l) return 0;\n\n    if(dat[k] == 0) return 0;\n\n    if(k >= n-1) {\n      if(a <= l && r <= b) {\n        ELM tmp = dat[k];\n        dat[k] = 0;\n        return tmp;\n      } else {\n        return 0;\n      }\n    }\n    ELM vl = queryE(a, b, k*2+1, l, (l+r)/2);\n    ELM vr = queryE(a, b, k*2+2, (l+r)/2, r);\n    dat[k] -= (vl + vr);\n    return vl + vr;\n  }\n\n  int lower_bound(const ELM &v) const {\n    int l = 0;\n    int r = n;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(query(0, m+1) < v) {\n        l = m+1;\n      } else {\n        r = m;\n      }\n    }\n    return l;\n  }\n\n  int upper_bound(const ELM &v) const {\n    int l = 0;\n    int r = n;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(query(0, m+1) <= v) {\n        l = m+1;\n      } else {\n        r = m;\n      }\n    }\n    return l;\n  }\n\n};\n\nint main() {\n  int Q;\n  ELM L;\n  while(1) {\n    assert(cin >> Q >> L);\n    if(Q == 0 && L == 0) break;\n    RMQ pos(Q), enemy(Q);\n    int size = 0;\n\n    while(Q--) {\n      int op;\n      ELM x, r;\n      assert(cin >> op);\n      assert(0 <= op && op <= 4);\n      if(0) { // dumy\n\n      } else if(op == 0) { // add enemy\n\n        ELM p = L - pos.query(0, size);\n        assert(p >= 0); //!\n        assert(!(size != 0 && p == 0 && enemy.at(size-1) != 0));\n        pos.update(size, p);\n        enemy.update(size, 1);\n        size += 1;\n\n      } else if(op == 1) { // move enemys\n        assert(cin >> x);\n        assert(1LL <= x && x <= 1000000000LL);\n        int end = min(pos.upper_bound(x), size);\n        ELM num = enemy.queryE(0, end);\n        x -= pos.queryE(0, end);\n        int head = pos.lower_bound(1);\n        if(head < size) {\n          ELM nextPos = pos.at(head) - x;\n          assert(nextPos > 0); //!\n          pos.update(head, nextPos);\n        }\n        if(num) cout << \"damage \" << num << endl;\n\n      } else if(op == 2) { // attack x(th) enemy\n        assert(cin >> x);\n        assert(1LL <= x && x <= 1000000000LL);\n        if(enemy.query(0, size) >= x) {\n          int p = enemy.lower_bound(x);\n          enemy.queryE(p, p+1);\n          cout << \"hit\" << endl;\n        } else {\n          cout << \"miss\" << endl;\n        }\n\n      } else if(op == 3) { // bomb enemys at x with range of r\n        assert(cin >> x >> r);\n        assert(0LL <= x && x <= L);\n        assert(0LL <= r && r <= 1000000000LL);\n        int begin = pos.lower_bound(x-r);\n        int end = pos.upper_bound(x+r);\n        ELM num = enemy.queryE(begin, end);\n        cout << \"bomb \" << num << endl;\n\n      } else if(op == 4) { // print the position of x(th) enemy\n        assert(cin >> x);\n        assert(1LL <= x && x <= 1000000000LL);\n        if(enemy.query(0, size) >= x) {\n          int p = enemy.lower_bound(x);\n          cout << \"distance \" << pos.query(0, p+1) << endl;\n        } else {\n          cout << \"distance \" << -1 << endl;\n        }\n\n      }\n    }\n    cout << \"end\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n#define int long long\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int Add;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\ninline int Dist(Node *t)\n{\n  if(t == (Node *)NULL) return(-1);\n  else return(t -> Value + t -> Add);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  if(t -> Lch != (Node *)NULL) t -> Lch -> Add += t -> Add;\n  if(t -> Rch != (Node *)NULL) t -> Rch -> Add += t -> Add;\n  t -> Value += t -> Add;\n  t -> Add = 0;\n\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  Update(l), Update(r);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  Update(t);\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  Update(root);\n  if(root == (Node *)NULL) return(0);\n  if(Value <= root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nsigned main()\n{\n  int Q, L;\n  char buff[32];\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%lld %lld\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    while(Q--) {\n      int type;\n      Dump(root);\n      puts(\"\");\n\n\n      scanf(\"%lld\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L), L);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%lld\", &d);\n        if(root != (Node *)NULL) {\n          root -> Add -= d;\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %lld\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%lld\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%lld %lld\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, x - r));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, x + r + 1));\n        printf(\"bomb %lld\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%lld\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = Dist(T.first);\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %lld\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate< typename T >\nclass Treap {\nprivate: // parts\n\tunsigned int rnd() {\n\t\tstatic unsigned int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\t\tunsigned int t = (x ^ (x << 11));\n\t\tx = y; y = z; z = w;\n\t\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n\t}\n\t\n\tstruct Node {\n\t\tT val, data, add;\n\t\tNode *lch, *rch;\n\t\tint pri, cnt;\n\t\tbool rev;\n\t\t\n\t\tNode(T v, int p) : val(v), data(v), add(T(0)), pri(p), cnt(1), rev(false) { lch = rch = nullptr; }\n\t};\n\t\n\tNode *root;\n\t\nprivate: // main function\n\tint count(Node* t) { return t ? t->cnt : 0; }\n\tT data(Node* t) { return t ? t->data : T(1e9); }\t\n\t\n\tvoid push(Node* t) {\n\t\tif (t && t->rev) {\n\t\t\tswap(t->lch, t->rch);\n\t\t\tif (t->lch) t->lch->rev ^= true;\n\t\t\tif (t->rch) t->rch->rev ^= true;\n\t\t\tt->rev = false;\n\t\t}\n\t\t\n\t\tif (t && t->add != 0) {\n\t\t\tt->val += t->add;\n\t\t\tif (t->lch) t->lch->add += t->add;\n\t\t\tif (t->rch) t->rch->add += t->add;\n\t\t\tt->add = 0;\n\t\t}\n\t}\n\t\n\tNode* update(Node *t) {\n\t\tif (!t) return t;\n\t\tt->cnt = count(t->lch) + count(t->rch) + 1;\n\t\t//t->data = calc(calc(data(t->lch), data(t->rch)), t->val);\n\t\treturn t;\n\t}\n\t\n\tNode* merge(Node* l, Node* r) {\n\t\tpush(l); push(r);\n\t\t\n\t\tif (!l || !r) return l ? l : r;\n\t\n\t\tif (l->pri > r->pri) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn update(l);\n\t\t} else {\n\t\t\tr->lch = merge(l, r->lch);\n\t\t\treturn update(r);\n\t\t}\n\t}\n\t\n\ttypedef pair< Node*, Node* > pnn;\n\t\n\tpnn split(Node* t, int k) {\n\t\tif (!t) return pnn(nullptr, nullptr);\n\t\t\n\t\tpush(t);\n\t\t\n\t\tif (k <= count(t->lch)) {\n\t\t\tpnn s = split(t->lch, k);\n\t\t\tt->lch = s.second;\n\t\t\treturn pnn(s.first, update(t));\n\t\t} else {\n\t\t\tpnn s = split(t->rch, k - count(t->lch) - 1);\n\t\t\tt->rch = s.first;\n\t\t\treturn pnn(update(t), s.second);\n\t\t}\n\t}\n\t\n\tNode* insert(Node* t, int k, T val, int pri) {\n\t\tpnn s = split(t, k);\n\t\tt = merge(s.first, new Node(val, pri));\n\t\tt = merge(t, s.second);\n\t\treturn update(t);\n\t}\n\t\n\tNode* erase(Node* t, int k) {\n\t\tpnn s1 = split(t, k + 1);\n\t\tpnn s2 = split(s1.first, k);\n\t\tt = merge(s2.first, s1.second);\n\t\tdelete s2.second;\n\t\treturn update(t);\n\t}\n\t\n\tNode* find(Node* t, int k) {\n\t\tpush(t);\n\t\tint c = count(t->lch);\n\t\tif (k < c) return find(t->lch, k);\n\t\tif (k > c) return find(t->rch, k - c - 1);\n\t\treturn t;\n\t}\n\t\n\tvoid dump(Node* t, ostream& os) {\n\t\tif (!t) return;\n\t\tos << \"(\";\n\t\tdump(t->lch, os);\n\t\tos << t->val;\n\t\tdump(t->rch, os);\n\t\tos << \")\";\n\t}\n\t\npublic: // public function\n\tTreap() : root(nullptr) {}\n\t\n\tvoid insert(int k, T val) { root = insert(root, k, val, rnd()); }\n\tvoid erase(int k) { root = erase(root, k); }\n\tNode* find(int k) { return find(root, k); }\n\tint size() { return count(root); }\n\t\n\tvoid dump(ostream& os) {\n\t\tdump(root, os);\n\t\tos << endl;\n\t}\n\t\n\t~Treap() { while (root) erase(0); }\n};\n\nint Q, L;\n\nvoid run() {\n\tlong long base = 0;\n\tTreap< long long > treap;\n\t\n\tauto upperBound = [&](int x) {\n\t\tint lb = -1, ub = treap.size();\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (treap.find(med)->val <= x) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\treturn ub;\n\t};\n\t\n\tfor (int i=0; i<Q; ++i) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\t\n\t\tif (t == 0) {\n\t\t\ttreap.insert((int)treap.size(), base + L);\n\t\t}\n\t\t\n\t\tif (t == 1) {\n\t\t\tint d;\n\t\t\tscanf(\"%d\\n\", &d);\n\t\t\tbase += d;\n\t\t\tint num = upperBound(base);\n\t\t\tif (num > 0) printf(\"damage %d\\n\", num);\n\t\t\tfor (int i=0; i<num; ++i) treap.erase(0);\n\t\t}\n\t\t\n\t\tif (t == 2) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) puts(\"hit\");\n\t\t\telse puts(\"miss\");\n\t\t\ttreap.erase(k-1);\n\t\t}\n\t\t\n\t\tif (t == 3) {\n\t\t\tint x, r;\n\t\t\tscanf(\"%d %d\\n\", &x, &r);\n\t\t\tint lft = upperBound(base + x - r - 1), rgt = upperBound(base + x + r);\n\t\t\tprintf(\"bomb %d\\n\", rgt - lft);\n\t\t\tfor (int i=0; i<rgt-lft; ++i) treap.erase(lft);\n\t\t}\n\t\t\n\t\tif (t == 4) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) printf(\"distance %d\\n\", (int)(treap.find(k-1)->val - base));\n\t\t\telse puts(\"distance -1\");\n\t\t}\n\t}\n\t\n\tputs(\"end\");\n}\n\nint main() {\n\twhile (cin >> Q >> L, Q) {\n\t\trun();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <ctime>\nusing namespace std;\n\ntemplate <class D, class C = less<D> >\nstruct treap{\n\tstruct node{\n\t\tfriend class treap;\n\n\t\tD data;\n\tprivate:\n\t\tint priority;\n\t\tint count;\n\t\tnode *left, *right;\n\n\t\texplicit node(const D &d)\n\t\t: data(d), priority(rand()), count(1), left(0), right(0)\n\t\t{}\n\t};\n\n\tC comparer;\n\tnode *root;\n\n\texplicit treap(const C &c = C()): comparer(c), root(0) {}\n\n\t~treap(){ destruct(root); }\n\n\tint size(){ return root ? root->count : 0; }\n\t\n\tvoid insert(const D &d){\n\t\troot = insert(root, d);\n\t}\n\n\tvoid erase(const D &d){\n\t\troot = erase(root, d);\n\t}\n\n\tnode *lower_bound(const D &d){\n\t\tnode *ret = 0;\n\t\tnode *next = root;\n\t\twhile(next){\n\t\t\tnode *nd = next;\n\t\t\tif(comparer(nd->data, d)){\n\t\t\t\tnext = nd->right;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = nd;\n\t\t\t\tnext = nd->left;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tnode *find(const D &d){\n\t\tnode *ret = lower_bound(d);\n\t\tif(comparer(ret->data, d) || comparer(d, ret->data)){\n\t\t\tret = 0;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tnode *nth(int n){\n\t\treturn nth(root, n);\n\t}\n\t\n\tnode *min_element(){\n\t\tnode *nd = root, *next = root;\n\t\twhile(next){\n\t\t\tnd = next;\n\t\t\tnext = nd->left;\n\t\t}\n\t\treturn nd;\n\t}\n\nprivate:\n\tvoid destruct(node *nd){\n\t\tif(nd){\n\t\t\tdestruct(nd->left);\n\t\t\tdestruct(nd->right);\n\t\t\tdelete nd;\n\t\t}\n\t}\n\n\tvoid update(node *nd){\n\t\tint l = nd->left ? nd->left->count : 0;\n\t\tint r = nd->right ? nd->right->count : 0;\n\t\tnd->count = l + r + 1;\n\t}\n\t\n\tnode *insert(node *nd, const D &d){\n\t\tif(!nd){ return new node(d); }\n\t\tif(comparer(d, nd->data)){\n\t\t\tnd->left = insert(nd->left, d);\n\t\t\tif(nd->priority > nd->left->priority){\n\t\t\t\tnd = rotate_right(nd);\n\t\t\t}\n\t\t}\n\t\telse if(comparer(nd->data, d)){\n\t\t\tnd->right = insert(nd->right, d);\n\t\t\tif(nd->priority > nd->right->priority){\n\t\t\t\tnd = rotate_left(nd);\n\t\t\t}\n\t\t}\n\t\tupdate(nd);\n\t\treturn nd;\n\t}\n\t\n\tnode *rotate_right(node *nd){\n\t\tnode *lf = nd->left;\n\t\tnd->left = lf->right;\n\t\tlf->right = nd;\n\t\tupdate(nd);\n\t\tupdate(lf);\n\t\treturn lf;\n\t}\n\t\n\tnode *rotate_left(node *nd){\n\t\tnode *rg = nd->right;\n\t\tnd->right = rg->left;\n\t\trg->left = nd;\n\t\tupdate(nd);\n\t\tupdate(rg);\n\t\treturn rg;\n\t}\n\t\n\tnode *erase(node *nd, const D &d){\n\t\tif(nd){\n\t\t\tif(comparer(d, nd->data)){\n\t\t\t\tnd->left = erase(nd->left, d);\n\t\t\t}\n\t\t\telse if(comparer(nd->data, d)){\n\t\t\t\tnd->right = erase(nd->right, d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!nd->left && !nd->right){\n\t\t\t\t\tdelete nd;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!nd->left){\n\t\t\t\t\tnd = rotate_left(nd);\n\t\t\t\t}\n\t\t\t\telse if(!nd->right){\n\t\t\t\t\tnd = rotate_right(nd);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(nd->left->priority < nd->right->priority){\n\t\t\t\t\t\tnd = rotate_right(nd);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnd = rotate_left(nd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnd = erase(nd, d);\n\t\t\t}\n\t\t}\n\t\tupdate(nd);\n\t\treturn nd;\n\t}\n\t\n\tnode *nth(node *nd, int n){\n\t\tif(!nd || n < 0 || n >= nd->count){ return 0; }\n\t\tint cl = nd->left ? nd->left->count : 0;\n\t\tif(n < cl){ return nth(nd->left, n); }\n\t\tif(n > cl){ return nth(nd->right, n - cl - 1); }\n\t\treturn nd;\n\t}\n};\n\n\ntypedef long long LL;\n\nint main(){\n\tsrand(time(0));\n\n\tint q, L, t, d, k, x, r;\n\twhile(scanf(\"%d%d\", &q, &L), q){\n\t\tLL b = 0;\n\t\ttreap<LL> tr;\n\t\ttreap<LL>::node *nd = 0;\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t == 0){\n\t\t\t\ttr.insert(L + b);\n\t\t\t}\n\t\t\telse if(t == 1){\n\t\t\t\tscanf(\"%d\", &d);\n\t\t\t\tb += d;\n\t\t\t\t\n\t\t\t\tint c = 0;\n\t\t\t\twhile(nd = tr.min_element()){\n\t\t\t\t\tif(nd->data > b){ break; }\n\t\t\t\t\t++c;\n\t\t\t\t\ttr.erase(nd->data);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c){ printf(\"damage %d\\n\", c); }\n\t\t\t}\n\t\t\telse if(t == 2){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tnd = tr.nth(k - 1);\n\t\t\t\tif(nd){\n\t\t\t\t\tputs(\"hit\");\n\t\t\t\t\ttr.erase(nd->data);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tputs(\"miss\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(t == 3){\n\t\t\t\tscanf(\"%d%d\", &x, &r);\n\t\t\t\tint c = 0;\n\t\t\t\twhile(nd = tr.lower_bound(b + x - r)){\n\t\t\t\t\tif(nd->data > b + x + r){ break; }\n\t\t\t\t\t++c;\n\t\t\t\t\ttr.erase(nd->data);\n\t\t\t\t}\n\t\t\t\tprintf(\"bomb %d\\n\", c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tnd = tr.nth(k - 1);\n\t\t\t\tprintf(\"distance %lld\\n\", nd ? nd->data - b : -1LL);\n\t\t\t}\n\t\t}\n\t\tputs(\"end\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r)?????´??°??????. ?????????0-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r)?????????????????¨?????????????????????. ?????????0-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L], cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 1, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx], cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 2+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a], cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a], cp.mp[q.b] + 1, make_pair(1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n#define int long long\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  if(root == (Node *)NULL) return(0);\n  if(Value <= root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nsigned main()\n{\n  int Q, L;\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%lld %lld\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    long long D = 0LL;\n    while(Q--) {\n      int type;\n      scanf(\"%lld\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L + D), L + D);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%lld\", &d);\n        D += d;\n        if(root != (Node *)NULL) {\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, D + 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %lld\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%lld\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%lld %lld\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, D + x - r));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, D + x + r + 1));\n        printf(\"bomb %lld\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%lld\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = T.first -> Value - D;\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %lld\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\nconst long long INF = 1LL << 60;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key, minkey;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, minkey=%lld, fix=%d, size=%d\\n\",\n\t     k, key, minkey, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[2 * MAX_Q], buf1;\n  \n  Treap() {\n    nullnode = &buf1;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->key = nullnode->minkey = INF;\n    nullnode->fix = nullnode->size = 0;\n    clear();\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n\n  void update(node& t) {\n    t->size = 1 + t->left->size + t->right->size;\n    t->minkey = t->key;\n    if (t->minkey > t->left->minkey) t->minkey = t->left->minkey;\n    if (t->minkey > t->right->minkey) t->minkey = t->right->minkey;\n  }\n\n  node gen_node(ll x) {\n    node t = buf++;\n    t->left = t->right = nullnode;\n    t->key = t->minkey = x;\n    t->fix = rand();\n    t->size = 1;\n    return t;\n  }\n  \n  void rot_l(node& k1) {\n    node k2 = k1->right;\n    k1->right = k2->left;\n    k2->left = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2 = k1->left;\n    k1->left = k2->right;\n    k2->right = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void append(node& t, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      append(t->right, x);\n      update(t);\n      if (t->right->fix > t->fix) rot_l(t);\n    }\n  }\n  void append(ll x) { append(root, x); }\n  \n  void insert(node& t, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else if (x < t->key) {\n      insert(t->left, x);\n      update(t);\n    }\n    else if (x > t->key) {\n      insert(t->right, x);\n      update(t);\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void insertat(node& t, int i, ll x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tappend(t->left, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else if (i < lsize) {\n\tinsertat(t->left, i, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else {\n\tinsertat(t->right, i - (lsize + 1), x);\n\tupdate(t);\n\tif (t->right->fix > t->fix) rot_l(t);\n      }\n    }\n  }\n  void insertat(int i, ll x) { insertat(root, i, x); }\n\n  void set(node& t, int i, ll x) {\n    if (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tt->key = t->minkey = x;\n\tupdate(t);\n      }\n      else if (i < lsize) {\n\tset(t->left, i, x);\n\tupdate(t);\n      }\n      else {\n\tset(t->right, i - (lsize + 1), x);\n\tupdate(t);\n      }\n    }\n  }\n  void set(int i, ll x) { set(root, i, x); }\n  \n  void remove_node(node& t) {\n    if (t == nullnode) return;\n    if (t->left == nullnode || t->right == nullnode) {\n      if (t->left == nullnode)\n\tt = t->right;\n      else\n\tt = t->left;\n    }\n    else {\n      if (t->left->fix < t->right->fix) {\n\trot_l(t);\n\tremove_node(t->left);\n\tupdate(t);\n      }\n      else {\n\trot_r(t);\n\tremove_node(t->right);\n\tupdate(t);\n      }\n    }\n  }\n\n  ll removeat(node& t, int i) {\n    ll ret = INF;\n\n    if (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) {\n\tret = t->key;\n\tremove_node(t);\n      }\n      else if (i < lsize) {\n\tret = removeat(t->left, i);\n\tupdate(t);\n      }\n      else {\n\tret = removeat(t->right, i - (lsize + 1));\n\tupdate(t);\n      }\n    }\n\n    return ret;\n  }\n  ll removeat(int i) { return removeat(root, i); }\n  \n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 <= 0 || t->size <= r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    update(t);\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      remove_node(t);\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n\n  ll min_range(node& t, int r0, int r1) {\n    if (t == nullnode) return INF;\n    if (r1 <= 0 || t->size <= r0) return INF;\n    \n    if (r0 <= 0 && t->size <= r1) return t->minkey;\n\n    int lsize = t->left->size;\n    ll minval = INF;\n\n    if (r0 <= lsize && lsize < r1)\n      minval = t->key;\n    if (r0 <= lsize) {\n      ll minl = min_range(t->left, r0, r1);\n      if (minval > minl) minval = minl;\n    }\n    if (lsize + 1 < r1) {\n      ll minr = min_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n      if (minval > minr) minval = minr;\n    }\n\n    return minval;\n  }\n  ll min_range(int r0, int r1) { return min_range(root, r0, r1); }\n\n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return INF;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n\n  \n  void print(node t, int k, int indent) {\n    if (t == nullnode) return;\n    if (t != NULL) {\n      for (int i = 0; i < indent; i++) cout << \"  \";\n      t->print(k + t->left->size);\n      print(t->left, k, indent + 1);\n      print(t->right, k + t->left->size + 1, indent + 1);\n    }\n  }\n  void print() { print(root, 0, 0); }\n\n  void inorder(node t) {\n    if (t != nullnode && t != NULL) {\n      inorder(t->left);\n      cout << t->key << ' ';\n      inorder(t->right);\n    }\n  }\n  void inorder() {\n    inorder(root);\n    cout << endl;\n  }\n};\n\n/* global variables */\n\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  srand(time(NULL));\n\n  for (;;) {\n    int qn;\n    ll ln;\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tint n = trp.remove_range(0, i);\n\tif (n > 0)\n\t  printf(\"damage %d\\n\", n);\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\tk--;\n\t\n\tll x = trp.removeat(k);\n\tcout << ((x < INF) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\tk--;\n\t\n\tll x = trp.findat(k);\n\tprintf(\"distance %lld\\n\", (x < INF) ? x - cpos : -1);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate< typename T >\nclass Treap {\nprivate: // parts\n\tunsigned int rnd() {\n\t\tstatic unsigned int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\t\tunsigned int t = (x ^ (x << 11));\n\t\tx = y; y = z; z = w;\n\t\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n\t}\n\t\n\tstruct Node {\n\t\tT val, data, add;\n\t\tNode *lch, *rch;\n\t\tint pri, cnt;\n\t\tbool rev;\n\t\t\n\t\tNode(T v, int p) : val(v), data(v), add(T(0)), pri(p), cnt(1), rev(false) { lch = rch = nullptr; }\n\t};\n\t\n\tNode *root;\n\t\nprivate: // main function\n\tint count(Node* t) { return t ? t->cnt : 0; }\n\tT data(Node* t) { return t ? t->data : T(1e9); }\t\n\t\n\tvoid push(Node* t) {\n\t\tif (t && t->rev) {\n\t\t\tswap(t->lch, t->rch);\n\t\t\tif (t->lch) t->lch->rev ^= true;\n\t\t\tif (t->rch) t->rch->rev ^= true;\n\t\t\tt->rev = false;\n\t\t}\n\t\t\n\t\tif (t && t->add != 0) {\n\t\t\tt->val += t->add;\n\t\t\tif (t->lch) t->lch->add += t->add;\n\t\t\tif (t->rch) t->rch->add += t->add;\n\t\t\tt->add = 0;\n\t\t}\n\t}\n\t\n\tNode* update(Node *t) {\n\t\tif (!t) return t;\n\t\tt->cnt = count(t->lch) + count(t->rch) + 1;\n\t\t//t->data = calc(calc(data(t->lch), data(t->rch)), t->val);\n\t\treturn t;\n\t}\n\t\n\tNode* merge(Node* l, Node* r) {\n\t\tpush(l); push(r);\n\t\t\n\t\tif (!l || !r) return l ? l : r;\n\t\n\t\tif (l->pri > r->pri) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn update(l);\n\t\t} else {\n\t\t\tr->lch = merge(l, r->lch);\n\t\t\treturn update(r);\n\t\t}\n\t}\n\t\n\ttypedef pair< Node*, Node* > pnn;\n\t\n\tpnn split(Node* t, int k) {\n\t\tif (!t) return pnn(nullptr, nullptr);\n\t\t\n\t\tpush(t);\n\t\t\n\t\tif (k <= count(t->lch)) {\n\t\t\tpnn s = split(t->lch, k);\n\t\t\tt->lch = s.second;\n\t\t\treturn pnn(s.first, update(t));\n\t\t} else {\n\t\t\tpnn s = split(t->rch, k - count(t->lch) - 1);\n\t\t\tt->rch = s.first;\n\t\t\treturn pnn(update(t), s.second);\n\t\t}\n\t}\n\t\n\tNode* insert(Node* t, int k, T val, int pri) {\n\t\tpnn s = split(t, k);\n\t\tt = merge(s.first, new Node(val, pri));\n\t\tt = merge(t, s.second);\n\t\treturn update(t);\n\t}\n\t\n\tNode* erase(Node* t, int k) {\n\t\tpnn s1 = split(t, k + 1);\n\t\tpnn s2 = split(s1.first, k);\n\t\tt = merge(s2.first, s1.second);\n\t\tdelete s2.second;\n\t\treturn update(t);\n\t}\n\t\n\tNode* find(Node* t, int k) {\n\t\tpush(t);\n\t\tint c = count(t->lch);\n\t\tif (k < c) return find(t->lch, k);\n\t\tif (k > c) return find(t->rch, k - c - 1);\n\t\treturn t;\n\t}\n\t\n\tvoid dump(Node* t, ostream& os) {\n\t\tif (!t) return;\n\t\tos << \"(\";\n\t\tdump(t->lch, os);\n\t\tos << t->val;\n\t\tdump(t->rch, os);\n\t\tos << \")\";\n\t}\n\t\npublic: // public function\n\tTreap() : root(nullptr) {}\n\t\n\tvoid insert(int k, T val) { root = insert(root, k, val, rnd()); }\n\tvoid erase(int k) { root = erase(root, k); }\n\tNode* find(int k) { return find(root, k); }\n\tint size() { return count(root); }\n\t\n\tvoid dump(ostream& os) {\n\t\tdump(root, os);\n\t\tos << endl;\n\t}\n\t\n\t~Treap() { while (root) erase(0); }\n};\n\nint Q, L;\n\nvoid run() {\n\tlong long base = 0;\n\tTreap< long long > treap;\n\t\n\tauto lowerBound = [&](int x) {\n\t\tint lb = -1, ub = treap.size();\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (treap.find(med)->val < x) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\treturn ub;\n\t};\n\t\n\tauto upperBound = [&](int x) {\n\t\tint lb = -1, ub = treap.size();\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (treap.find(med)->val <= x) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\treturn ub;\n\t};\n\t\n\tfor (int i=0; i<Q; ++i) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\t\n\t\tif (t == 0) {\n\t\t\ttreap.insert((int)treap.size(), base + L);\n\t\t}\n\t\t\n\t\tif (t == 1) {\n\t\t\tint d;\n\t\t\tscanf(\"%d\\n\", &d);\n\t\t\tbase += d;\n\t\t\tint num = upperBound(base);\n\t\t\tif (num > 0) printf(\"damage %d\\n\", num);\n\t\t\tfor (int i=0; i<num; ++i) treap.erase(0);\n\t\t}\n\t\t\n\t\tif (t == 2) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) puts(\"hit\");\n\t\t\telse puts(\"miss\");\n\t\t\ttreap.erase(k-1);\n\t\t}\n\t\t\n\t\tif (t == 3) {\n\t\t\tint x, r;\n\t\t\tscanf(\"%d %d\\n\", &x, &r);\n\t\t\tint lft = lowerBound(base + x - r), rgt = upperBound(base + x + r);\n\t\t\tprintf(\"bomb %d\\n\", rgt - lft);\n\t\t\tfor (int i=0; i<rgt-lft; ++i) treap.erase(lft);\n\t\t}\n\t\t\n\t\tif (t == 4) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) printf(\"distance %d\\n\", (int)(treap.find(k-1)->val - base));\n\t\t\telse puts(\"distance -1\");\n\t\t}\n\t}\n\t\n\tputs(\"end\");\n}\n\nint main() {\n\twhile (cin >> Q >> L, Q) {\n\t\trun();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, fix=%d, size=%d\\n\",\n\t     this->left->size + k, key, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[MAX_Q + 1];\n  \n  Treap() {\n    nullnode = new Node;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->size = 0;\n    clear();\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n  \n  void rot_l(node& k1) {\n    node k2;\n    k2 = k1->right;\n    k1->right = k2->left;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->left = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2;\n    k2 = k1->left;\n    k1->left = k2->right;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->right = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void insert(node& t, ll x) {\n    if (t == nullnode) {\n      t = buf++;\n      t->left = t->right = nullnode;\n      t->key = x;\n      t->fix = rand();\n      t->size = 1;\n    }\n    else {\n      if (t->key == x) return;\n      else {\n\tt->size++;\n\tif (x < t->key) {\n\t  insert(t->left, x);\n\t  if (t->left->fix > t->fix) rot_r(t);\n\t}\n\telse {\n\t  insert(t->right, x);\n\t  if (t->right->fix > t->fix) rot_l(t);\n\t}\n      }\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void remove(node& t, ll x) {\n    if (t == nullnode) return;\n    \n    t->size--;\n    if (x > t->key) remove(t->right, x);\n    else if (x < t->key) remove(t->left, x);\n    else {\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove(t->left, x);\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove(t->right, x);\n\t}\n      }\n    }\n  }  \n  void remove(ll x) { remove(root, x); }\n\n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 < 0 || t->size <= r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    t->size = 1 + t->left->size + t->right->size;\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      if (t->left == nullnode || t->right == nullnode) {\n\tif (t->left == nullnode)\n\t  t = t->right;\n\telse\n\t  t = t->left;\n      }\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove_range(t->left, t->left->size - 1, t->left->size);\n\t  t->size--;\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove_range(t->right, 0, 1);\n\t  t->size--;\n\t}\n      }\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n  \n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return -1;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n  \n  void inorder(node ptr, int k) {\n    if (ptr == nullnode) return;\n    if (ptr != NULL) {\n      inorder(ptr->left, k);\n      ptr->print(k + ptr->left->size);\n      inorder(ptr->right, k + ptr->left->size + 1);\n    }\n  }\n  void inorder() { inorder(root, 0); }\n};\n\n/* global variables */\n\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int qn;\n    ll ln;\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tint n = trp.remove_range(0, i);\n\tif (n > 0)\n\t  printf(\"damage %d\\n\", n);\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\t\n\tint n = trp.remove_range(k - 1, k);\n\tcout << ((n > 0) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\t\n\tll x = trp.findat(k - 1);\n\tprintf(\"distance %lld\\n\", x - cpos);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate< typename T >\nclass Treap {\nprivate: // parts\n\tunsigned int rnd() {\n\t\tstatic unsigned int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\t\tunsigned int t = (x ^ (x << 11));\n\t\tx = y; y = z; z = w;\n\t\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n\t}\n\t\n\tstruct Node {\n\t\tT val, data, add;\n\t\tNode *lch, *rch;\n\t\tint pri, cnt;\n\t\tbool rev;\n\t\t\n\t\tNode(T v, int p) : val(v), data(v), add(T(0)), pri(p), cnt(1), rev(false) { lch = rch = nullptr; }\n\t};\n\t\n\tNode *root;\n\t\nprivate: // main function\n\tint count(Node* t) { return t ? t->cnt : 0; }\n\tT data(Node* t) { return t ? t->data : T(1e9); }\t\n\t\n\tvoid push(Node* t) {\n\t\tif (t && t->rev) {\n\t\t\tswap(t->lch, t->rch);\n\t\t\tif (t->lch) t->lch->rev ^= true;\n\t\t\tif (t->rch) t->rch->rev ^= true;\n\t\t\tt->rev = false;\n\t\t}\n\t\t\n\t\tif (t && t->add != 0) {\n\t\t\tt->val += t->add;\n\t\t\tif (t->lch) t->lch->add += t->add;\n\t\t\tif (t->rch) t->rch->add += t->add;\n\t\t\tt->add = 0;\n\t\t}\n\t}\n\t\n\tNode* update(Node *t) {\n\t\tif (!t) return t;\n\t\tt->cnt = count(t->lch) + count(t->rch) + 1;\n\t\t//t->data = calc(calc(data(t->lch), data(t->rch)), t->val);\n\t\treturn t;\n\t}\n\t\n\tNode* merge(Node* l, Node* r) {\n\t\tpush(l); push(r);\n\t\t\n\t\tif (!l || !r) return l ? l : r;\n\t\n\t\tif (l->pri > r->pri) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn update(l);\n\t\t} else {\n\t\t\tr->lch = merge(l, r->lch);\n\t\t\treturn update(r);\n\t\t}\n\t}\n\t\n\ttypedef pair< Node*, Node* > pnn;\n\t\n\tpnn split(Node* t, int k) {\n\t\tif (!t) return pnn(nullptr, nullptr);\n\t\t\n\t\tpush(t);\n\t\t\n\t\tif (k <= count(t->lch)) {\n\t\t\tpnn s = split(t->lch, k);\n\t\t\tt->lch = s.second;\n\t\t\treturn pnn(s.first, update(t));\n\t\t} else {\n\t\t\tpnn s = split(t->rch, k - count(t->lch) - 1);\n\t\t\tt->rch = s.first;\n\t\t\treturn pnn(update(t), s.second);\n\t\t}\n\t}\n\t\n\tNode* insert(Node* t, int k, T val, int pri) {\n\t\tpnn s = split(t, k);\n\t\tt = merge(s.first, new Node(val, pri));\n\t\tt = merge(t, s.second);\n\t\treturn update(t);\n\t}\n\t\n\tNode* erase(Node* t, int k) {\n\t\tpnn s1 = split(t, k + 1);\n\t\tpnn s2 = split(s1.first, k);\n\t\tt = merge(s2.first, s1.second);\n\t\tdelete s2.second;\n\t\treturn update(t);\n\t}\n\t\n\tNode* find(Node* t, int k) {\n\t\tpush(t);\n\t\tint c = count(t->lch);\n\t\tif (k < c) return find(t->lch, k);\n\t\tif (k > c) return find(t->rch, k - c - 1);\n\t\treturn t;\n\t}\n\t\n\tvoid dump(Node* t, ostream& os) {\n\t\tif (!t) return;\n\t\tos << \"(\";\n\t\tdump(t->lch, os);\n\t\tos << t->val;\n\t\tdump(t->rch, os);\n\t\tos << \")\";\n\t}\n\t\npublic: // public function\n\tTreap() : root(nullptr) {}\n\t\n\tvoid insert(int k, T val) { root = insert(root, k, val, rnd()); }\n\tvoid erase(int k) { root = erase(root, k); }\n\tNode* find(int k) { return find(root, k); }\n\tint size() { return count(root); }\n\t\n\tvoid dump(ostream& os) {\n\t\tdump(root, os);\n\t\tos << endl;\n\t}\n\t\n\t~Treap() { while (root) erase(0); }\n};\n\nint Q, L;\n\nvoid run() {\n\tlong long base = 0;\n\tTreap< long long > treap;\n\t\n\tauto lowerBound = [&](long long x) {\n\t\tint lb = -1, ub = treap.size();\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (treap.find(med)->val < x) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\treturn ub;\n\t};\n\t\n\tauto upperBound = [&](long long x) {\n\t\tint lb = -1, ub = treap.size();\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (treap.find(med)->val <= x) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\treturn ub;\n\t};\n\t\n\tfor (int i=0; i<Q; ++i) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\t\n\t\tif (t == 0) {\n\t\t\ttreap.insert((int)treap.size(), base + L);\n\t\t}\n\t\t\n\t\tif (t == 1) {\n\t\t\tint d;\n\t\t\tscanf(\"%d\\n\", &d);\n\t\t\tbase += d;\n\t\t\tint num = upperBound(base);\n\t\t\tif (num > 0) printf(\"damage %d\\n\", num);\n\t\t\tfor (int i=0; i<num; ++i) treap.erase(0);\n\t\t}\n\t\t\n\t\tif (t == 2) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) puts(\"hit\");\n\t\t\telse puts(\"miss\");\n\t\t\ttreap.erase(k-1);\n\t\t}\n\t\t\n\t\tif (t == 3) {\n\t\t\tint x, r;\n\t\t\tscanf(\"%d %d\\n\", &x, &r);\n\t\t\tint lft = lowerBound(base + x - r), rgt = upperBound(base + x + r);\n\t\t\tprintf(\"bomb %d\\n\", rgt - lft);\n\t\t\tfor (int i=0; i<rgt-lft; ++i) treap.erase(lft);\n\t\t}\n\t\t\n\t\tif (t == 4) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\\n\", &k);\n\t\t\tif ((int)treap.size() >= k) printf(\"distance %d\\n\", (int)(treap.find(k-1)->val - base));\n\t\t\telse puts(\"distance -1\");\n\t\t}\n\t}\n\t\n\tputs(\"end\");\n}\n\nint main() {\n\twhile (cin >> Q >> L, Q) {\n\t\trun();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<long long>H; long long q[110000], a[110000], b[110000], Q, L, S, N, bit[110000];\n\nvoid add(long long x, long long r) { while (x <= N) { bit[x] += r; x += x&-x; } }\nlong long sum(long long r) { long long ret = 0; while (r >= 1) { ret += bit[r]; r -= r&-r; }return ret; }\nint main() {\n\twhile (true) {\n\t\tcin >> Q >> L; H.clear(); if (Q == 0 && L == 0)break; S = 0;\n\t\tfor (int i = 0; i < 110000; i++)bit[i] = 0;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> q[i];\n\t\t\tif (q[i] == 0) { H.push_back(S + L); }\n\t\t\tif (q[i] == 1) { cin >> a[i]; S += a[i]; }\n\t\t\tif (q[i] == 2) { cin >> a[i]; }\n\t\t\tif (q[i] == 3) { cin >> a[i] >> b[i]; }\n\t\t\tif (q[i] == 4) { cin >> a[i]; }\n\t\t}\n\t\tH.push_back(0); sort(H.begin(), H.end()); S = 0; N = 109500;\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tif (q[i] == 0) {\n\t\t\t\tint pos1 = lower_bound(H.begin(), H.end(), S + L) - H.begin();\n\t\t\t\tadd(pos1, 1);\n\t\t\t}\n\t\t\tif (q[i] == 1) {\n\t\t\t\tint pos1 = lower_bound(H.begin(), H.end(), S + 1) - H.begin();\n\t\t\t\tS += a[i];\n\t\t\t\tint pos2 = lower_bound(H.begin(), H.end(), S + 1) - H.begin();\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tfor (int i = pos1; i < pos2; i++) {\n\t\t\t\t\tif (sum(i) - sum(i - 1) >= 1) {\n\t\t\t\t\t\tadd(i, -1); cnt1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt1 >= 1)cout << \"damage \" << cnt1 << endl;\n\t\t\t}\n\t\t\tif (q[i] == 2) {\n\t\t\t\tint L = 0, R = 109000, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint pos1 = sum(M), pos2 = sum(M - 1);\n\t\t\t\t\tif (pos1 >= a[i] && pos2 < a[i]) { cout << \"hit\" << endl; add(M, -1); break; }\n\t\t\t\t\tif (pos1 < a[i]) {\n\t\t\t\t\t\tif (M == 108999) { cout << \"miss\" << endl; break; }\n\t\t\t\t\t\telse { L = M; }\n\t\t\t\t\t}\n\t\t\t\t\tif (pos2 >= a[i])R = M;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (q[i] == 3) {\n\t\t\t\tint pos1 = lower_bound(H.begin(), H.end(), S + a[i] - b[i]) - H.begin();\n\t\t\t\tint pos2 = lower_bound(H.begin(), H.end(), S + a[i] + b[i] + 1) - H.begin();\n\t\t\t\tint J = pos1 - 1; bool OK = true;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (J < pos2) {\n\t\t\t\t\tint L = J, R = 109000, M;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\t\tint pos3 = sum(M) - sum(J), pos4 = sum(M - 1) - sum(J);\n\t\t\t\t\t\tif (pos3 >= 1 && pos4 < 1) {\n\t\t\t\t\t\t\tJ = M; if (J < pos2) { cnt++; add(J, -1); } break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos3 < 1) {\n\t\t\t\t\t\t\tif (M == 108999) { OK = false; break; }\n\t\t\t\t\t\t\telse { L = M; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos4 >= 1)R = M;\n\t\t\t\t\t}\n\t\t\t\t\tif (OK == false)break;\n\t\t\t\t}\n\t\t\t\tcout << \"bomb \" << cnt << endl;\n\t\t\t}\n\t\t\tif (q[i] == 4) {\n\t\t\t\tint L = 0, R = 109000, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint pos1 = sum(M), pos2 = sum(M - 1);\n\t\t\t\t\tif (pos1 >= a[i] && pos2 < a[i]) { cout << \"distance \" << H[M] - S << endl; break; }\n\t\t\t\t\tif (pos1 < a[i]) {\n\t\t\t\t\t\tif (M == 108999) { cout << \"distance -1\" << endl; break; }\n\t\t\t\t\t\telse { L = M; }\n\t\t\t\t\t}\n\t\t\t\t\tif (pos2 >= a[i])R = M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\t//-------------end of the simulate------------\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, fix=%d, size=%d\\n\",\n\t     this->left->size + k, key, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[MAX_Q + 1];\n  \n  Treap() {\n    nullnode = new Node;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->size = 0;\n    clear();\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n  \n  void rot_l(node& k1) {\n    node k2;\n    k2 = k1->right;\n    k1->right = k2->left;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->left = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2;\n    k2 = k1->left;\n    k1->left = k2->right;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->right = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void insert(node& t, ll x) {\n    if (t == nullnode) {\n      t = buf++;\n      t->left = t->right = nullnode;\n      t->key = x;\n      t->fix = rand();\n      t->size = 1;\n    }\n    else {\n      if (t->key == x) return;\n      else {\n\tt->size++;\n\tif (x < t->key) {\n\t  insert(t->left, x);\n\t  if (t->left->fix > t->fix) rot_r(t);\n\t}\n\telse {\n\t  insert(t->right, x);\n\t  if (t->right->fix > t->fix) rot_l(t);\n\t}\n      }\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void remove(node& t, ll x) {\n    if (t == nullnode) return;\n    \n    t->size--;\n    if (x > t->key) remove(t->right, x);\n    else if (x < t->key) remove(t->left, x);\n    else {\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove(t->left, x);\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove(t->right, x);\n\t}\n      }\n    }\n  }  \n  void remove(ll x) { remove(root, x); }\n\n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 <= 0 || t->size <= r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    t->size = 1 + t->left->size + t->right->size;\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      if (t->left == nullnode || t->right == nullnode) {\n\tif (t->left == nullnode)\n\t  t = t->right;\n\telse\n\t  t = t->left;\n      }\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove_range(t->left, t->left->size - 1, t->left->size);\n\t  t->size--;\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove_range(t->right, 0, 1);\n\t  t->size--;\n\t}\n      }\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n  \n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return -1;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n  \n  void inorder(node ptr, int k) {\n    if (ptr == nullnode) return;\n    if (ptr != NULL) {\n      inorder(ptr->left, k);\n      ptr->print(k + ptr->left->size);\n      inorder(ptr->right, k + ptr->left->size + 1);\n    }\n  }\n  void inorder() { inorder(root, 0); }\n};\n\n/* global variables */\n\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int qn;\n    ll ln;\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tint n = trp.remove_range(0, i);\n\tif (n > 0)\n\t  printf(\"damage %d\\n\", n);\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\t\n\tint n = trp.remove_range(k - 1, k);\n\tcout << ((n > 0) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\t\n\tll x = trp.findat(k - 1);\n\tprintf(\"distance %lld\\n\", x - cpos);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_Q = 100000;\nconst int MAX_L = 1000000000;\n\n/* typedef */\n\ntypedef long long ll;\n\nstruct Treap {\n  struct Node {\n    ll key;\n    int fix, size;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, fix=%d, size=%d\\n\",\n\t     this->left->size + k, key, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[MAX_Q + 1];\n  \n  Treap() {\n    nullnode = new Node;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->size = 0;\n    clear();\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n  \n  void rot_l(node& k1) {\n    node k2;\n    k2 = k1->right;\n    k1->right = k2->left;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->left = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2;\n    k2 = k1->left;\n    k1->left = k2->right;\n    k1->size = 1 + k1->left->size + k1->right->size;\n    k2->right = k1;\n    k2->size = 1 + k2->left->size + k2->right->size;\n    k1 = k2;\n  }\n\n  void insert(node& t, ll x) {\n    if (t == nullnode) {\n      t = buf++;\n      t->left = t->right = nullnode;\n      t->key = x;\n      t->fix = rand();\n      t->size = 1;\n    }\n    else {\n      if (t->key == x) return;\n      else {\n\tt->size++;\n\tif (x < t->key) {\n\t  insert(t->left, x);\n\t  if (t->left->fix > t->fix) rot_r(t);\n\t}\n\telse {\n\t  insert(t->right, x);\n\t  if (t->right->fix > t->fix) rot_l(t);\n\t}\n      }\n    }\n  }\n  void insert(ll x) { insert(root, x); }\n\n  void remove(node& t, ll x) {\n    if (t == nullnode) return;\n    \n    t->size--;\n    if (x > t->key) remove(t->right, x);\n    else if (x < t->key) remove(t->left, x);\n    else {\n      if (t->left == nullnode && t->right == nullnode)\n\tt = nullnode;\n      else if (t->left == nullnode)\n\tt = t->right;\n      else if (t->right == nullnode)\n\tt = t->left;\n      else {\n\tif (t->left->fix < t->right->fix) {\n\t  rot_l(t);\n\t  remove(t->left, x);\n\t}\n\telse {\n\t  rot_r(t);\n\t  remove(t->right, x);\n\t}\n      }\n    }\n  }  \n  void remove(ll x) { remove(root, x); }\n\n  void remove_node(node& t) {\n    if (t == nullnode) return;\n    if (t->left == nullnode || t->right == nullnode) {\n      if (t->left == nullnode)\n\tt = t->right;\n      else\n\tt = t->left;\n    }\n    else {\n      if (t->left->fix < t->right->fix) {\n\trot_l(t);\n\tremove_node(t->left);\n\tt->size--;\n      }\n      else {\n\trot_r(t);\n\tremove_node(t->right);\n\tt->size--;\n      }\n    }\n  }\n  \n  int remove_range(node& t, int r0, int r1) {\n    if (t == nullnode) return 0;\n    if (r1 <= 0 || t->size <= r0) return 0;\n    \n    if (r0 <= 0 && t->size <= r1) {\n      int n = t->size;\n      t = nullnode;\n      return n;\n    }\n\n    int lsize = t->left->size;\n    int n =\n      remove_range(t->left, r0, r1) +\n      remove_range(t->right, r0 - (lsize + 1), r1 - (lsize + 1));\n    t->size = 1 + t->left->size + t->right->size;\n\n    if (r0 <= lsize && lsize < r1) {\n      n++;\n      remove_node(t);\n    }\n\n    return n;\n  }\n  int remove_range(int r0, int r1) { return remove_range(root, r0, r1); }\n  \n  node find(ll x) {\n    node t = root;\n    while (t != nullnode) {\n      if (t->key == x) return t;\n      if (x < t->key) t = t->left;\n      else t = t->right;\n    }\n    return (node)NULL;\n  }\n\n  ll findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return -1;\n  }\n\n  int upper_bound(ll x) {\n    node t = root;\n    int k = 0;\n\n    while (t != nullnode) {\n      if (t->key <= x) {\n\tk += t->left->size + 1;\n\tt = t->right;\n      }\n      else {\n\tt = t->left;\n      }\n    }\n    return k;\n  }\n  \n  void inorder(node ptr, int k) {\n    if (ptr == nullnode) return;\n    if (ptr != NULL) {\n      inorder(ptr->left, k);\n      ptr->print(k + ptr->left->size);\n      inorder(ptr->right, k + ptr->left->size + 1);\n    }\n  }\n  void inorder() { inorder(root, 0); }\n};\n\n/* global variables */\n\nTreap trp;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int qn;\n    ll ln;\n    cin >> qn >> ln;\n    if (qn == 0) break;\n\n    trp.clear();\n    ll cpos = 0;\n    \n    while (qn--) {\n      int qi;\n      cin >> qi;\n\n      if (qi == 0) {\n\ttrp.insert(cpos + ln);\n\t//trp.inorder();\n      }\n      else if (qi == 1) {\n\tll d;\n\tcin >> d;\n\tcpos += d;\n\n\tint i = trp.upper_bound(cpos);\n\tint n = trp.remove_range(0, i);\n\tif (n > 0)\n\t  printf(\"damage %d\\n\", n);\n      }\n      else if (qi == 2) {\n\tint k;\n\tcin >> k;\n\t\n\tint n = trp.remove_range(k - 1, k);\n\tcout << ((n > 0) ? \"hit\" : \"miss\") << endl;\n      }\n      else if (qi == 3) {\n\tll x, r;\n\tcin >> x >> r;\n\n\tint i0 = trp.upper_bound(cpos + x - r - 1);\n\tint i1 = trp.upper_bound(cpos + x + r);\n\tint n = trp.remove_range(i0, i1);\n\tprintf(\"bomb %d\\n\", n);\n      }\n      else {\n\tint k;\n\tcin >> k;\n\t\n\tll x = trp.findat(k - 1);\n\tprintf(\"distance %lld\\n\", x - cpos);\n      }\n    }\n\n    cout << \"end\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a + 1);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 1, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m + 1, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\tfor (auto&q : qs) {\n\t\t\t\tif (q.type == 1) {\n\t\t\t\t}\n\t\t\t\telse if (q.type == 3) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L] + 1, cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 1, cp.mp[nowx + q.a] + 1);\n\t\t\t\tif (damage) {\n\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + amax, cp.mp[nowx] + amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a] + 1, cp.mp[q.b] + 1, make_pair(1, -1));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 1 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[nowx + amax] - cp.revmp[nowx];\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\nstruct Node\n{\n  int Value;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int Add;\n  Node(int V):Value(V), SubTreeSize(1) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\ninline int Dist(Node *t)\n{\n  if(t == (Node *)NULL) return(-1);\n  else return(t -> Value + t -> Add);\n}\n\ninline Node *Update(Node *t)\n{\n  if(t == (Node *)NULL) return((Node *)NULL);\n  if(t -> Lch != (Node *)NULL) t -> Lch -> Add += t -> Add;\n  if(t -> Rch != (Node *)NULL) t -> Rch -> Add += t -> Add;\n  t -> Value += t -> Add;\n  t -> Add = 0;\n\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  return(t);\n}\n  \ninline Node *MakeRoot(int value)\n{\n  return(new Node(value));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  Update(l), Update(r);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  Update(t);\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value)\n{\n  Node *p = MakeRoot(value);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n \nNode *Erase(Node *root, int pos)\n{\n  pair< Node *, Node *> s = Split(root, pos);\n  pair< Node *, Node *> t = Split(s.second, 1);\n  delete t.first;\n  return(Merge(s.first, t.second));\n}\nvoid EraseALL(Node *root)\n{\n  if(root        == (Node *)NULL) return;\n  if(root -> Lch != (Node *)NULL) EraseALL(root -> Lch);\n  if(root -> Rch != (Node *)NULL) EraseALL(root -> Rch);\n  delete root;\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  Update(root);\n  if(root == (Node *)NULL) return(0);\n  if(Value <= root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n\nvoid Dump(Node *root)\n{\n  Update(root);\n  if(root == (Node *)NULL) return;\n  cout << \"(\";\n  Dump(root -> Lch);\n  cout << \"\" << root -> Value << \"\";\n  Dump(root -> Rch);\n  cout << \")\";\n} \n\n\nint main()\n{\n  int Q, L;\n  char buff[32];\n  Node *root = (Node *)NULL;\n\n  while(true) {\n    scanf(\"%d %d\", &Q, &L);\n    if(Q == 0 && L == 0) break;\n    while(Q--) {\n      //    Dump(root);\n      //puts(\"\");\n\n      int type;\n      scanf(\"%d\", &type);\n      if(type == 0) {\n        root = Insert(root, Lower_Bound(root, L), L);\n      } else if(type == 1) {\n        int d;\n        scanf(\"%d\", &d);\n        if(root != (Node *)NULL) {\n          root -> Add -= d;\n          pair< Node*, Node* > S = Split(root, Lower_Bound(root, 1));\n          if(Count(S.first) > 0) {\n            printf(\"damage %d\\n\", Count(S.first));\n            EraseALL(S.first);\n          }\n          root = S.second;\n        }\n      } else if(type == 2) {\n        int k;\n        scanf(\"%d\", &k);\n        if(Count(root) >= k) {\n          root = Erase(root, --k);\n          puts(\"hit\");\n        } else {\n          puts(\"miss\");\n        }\n      } else if(type == 3) {\n        int x, r;\n        scanf(\"%d %d\", &x, &r);\n        pair< Node*, Node* > S = Split(root, Lower_Bound(root, x - r));\n        pair< Node*, Node* > T = Split(S.second, Lower_Bound(S.second, x + r + 1));\n        printf(\"bomb %d\\n\", Count(T.first));\n        EraseALL(T.first);\n        root = Merge(S.first, T.second);\n      } else {\n        int k;\n        scanf(\"%d\", &k);\n        int dist = -1;\n        if(Count(root) >= k) {\n          pair< Node*, Node* > S = Split(root, --k);\n          pair< Node*, Node* > T = Split(S.second, 1);\n          dist = Dist(T.first);\n          S.second = Merge(T.first, T.second);\n          root = Merge(S.first, S.second);\n        }\n        printf(\"distance %d\\n\", dist);\n      }\n    }\n    EraseALL(root);\n    root = (Node *)NULL;\n    puts(\"end\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntypedef int Value1;\ntypedef pair<bool,int>Value2;\nconst Value1 Zero1(0);\nconst Value2 Zero2(make_pair(false, 0));\n\nstruct Node {\n\tValue1 sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tValue2 lazy;\t//?????¶???????????????????????????????????????\n\tNode() :sum(Zero1) {\n\t\tlazy = Zero2;\n\t}\n};\nstruct lazy_segtree {\n\tint N;\n\tvector<Node>dat;\n\tlazy_segtree(int n) :N(1) {\n\t\twhile (N < n) N *= 2;\n\t\tdat.resize(2 * N);\n\t}\n\n\tValue2 lazy_connect(const Value2 l, const Value2 r) {\n\t\tif (l.first || r.first)return make_pair(1, -1);\n\t\telse {\n\t\t\treturn make_pair(0, l.second + r.second);\n\t\t}\n\t}\n\n\tvoid lazy_func(const int k, const int a, const int b) {\n\t\tif (dat[k].lazy.first)dat[k].sum = 0;\n\t\telse {\n\t\t\tdat[k].sum += dat[k].lazy.second*(b - a);\n\t\t}\n\t}\n\n\tValue1 connect(const Value1 l, const Value1 r) {\n\t\treturn l + r;\n\n\t}\n\n\t// inline??????????????¨??§???????????¨????????????!(??????)\n\tinline void lazy_evaluate_node(int k, int a, int b) {\n\t\tlazy_func(k, a, b);\n\t\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\t\tdat[2 * k].lazy = lazy_connect(dat[2 * k].lazy, dat[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\t\tdat[2 * k + 1].lazy = lazy_connect(dat[2 * k + 1].lazy, dat[k].lazy);\n\t\t}\n\t\tdat[k].lazy = Zero2;\n\t}\n\n\tinline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\t\tdat[k].sum = connect(dat[2 * k].sum, dat[2 * k + 1].sum);\n\n\t}\n\n\t// update(l,r,v) := [l,r)?????´??°??????. ?????????0-indexed.\n\tvoid update(int l, int r, Value2 v, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\tif (l < 0 || r < 0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn;\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\tdat[k].lazy = lazy_connect(dat[k].lazy, v);\n\t\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\t\treturn;\n\t\t}\n\n\t\tint m = (a + b) / 2;\n\t\tupdate(l, r, v, 2 * k, a, m);\n\t\tupdate(l, r, v, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t}\n\t//get(l,r) := [l,r)?????????????????¨?????????????????????. ?????????0-indexed.\n\tValue1 get(int l, int r, int k = 1, int a = 0, int b = -1) {\n\t\tif (b == -1)b = N;\n\t\n\t\tif (l < 0 || r<0)assert(false);\n\t\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\t\n\t\tif (b <= l || r <= a) //[a,b)??¨[l,r)???????????????????????´???\n\t\t\treturn Zero1;\n\t\n\t\tif (l <= a && b <= r) { // [l,r)???[a,b)????????¨???????????§????????´???\n\t\t\treturn dat[k].sum;\n\t\t}\n\t\n\t\tint m = (a + b) / 2;\n\t\tValue1 vl = get(l, r, 2 * k, a, m);\n\t\tValue1 vr = get(l, r, 2 * k + 1, m, b);\n\t\tupdate_node(k);\n\t\treturn connect(vl, vr);\n\t}\n};\n\nstruct query {\n\tint type;\n\tlong long int a;\n\tlong long int b;\n};\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\n\nint main() {\n\tint Q;\n\twhile (cin>>Q,Q) {\n\n\n\t\tlong long int L; cin >> L;\n\t\tCompress<long long int> cp;\n\t\tvector<query>qs;\n\t\t{\n\n\t\t\tvector<long long int>xs;\n\t\t\txs.push_back(0);\n\t\t\tlong long int nowdis = 0;\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tif (a == 0) {\n\t\t\t\t\txs.push_back(nowdis + L);\n\t\t\t\t\tqs.push_back(query{ a,-1,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 1) {\n\t\t\t\t\tint d; cin >> d;\n\t\t\t\t\tnowdis += d;\n\t\t\t\t\txs.push_back(nowdis);\n\t\t\t\t\tqs.push_back(query{ a,d,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 2) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t\telse if (a == 3) {\n\t\t\t\t\tint x, r; cin >> x >> r;\n\t\t\t\t\txs.push_back(nowdis + x + r);\n\t\t\t\t\txs.push_back(nowdis + x - r);\n\t\t\t\t\tqs.push_back(query{ a,nowdis + x - r,nowdis + x + r });\n\t\t\t\t}\n\t\t\t\telse if (a == 4) {\n\t\t\t\t\tint k; cin >> k;\n\t\t\t\t\tqs.push_back(query{ a,k,-1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp.setmp(xs);\n\t\t\t\n\t\t}\n\t\tlazy_segtree seg(cp.mp.size());\n\t\tlong long int nowx = 0;\n\t\tfor (auto q : qs) {\n\t\t\tswitch (q.type) {\n\t\t\tcase 0:\n\t\t\t\tseg.update(cp.mp[nowx + L], cp.mp[nowx + L] + 1, make_pair(0, 1));\n\t\t\t\tbreak;\n\t\t\tcase 1: {\n\n\t\t\t\tint damage = seg.get(cp.mp[nowx] + 2, cp.mp[nowx + q.a] + 1);\n\t\t\t\tseg.update(cp.mp[nowx], cp.mp[nowx + q.a] + 1, make_pair(1, 0));\n\t\t\t\tif (damage) {\n\t\t\t\t\tcout << \"damage\" << \" \" << damage << endl;\n\t\t\t\t}\n\t\t\t\tnowx += q.a;\n\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tcout << \"hit\" << endl;\n\t\t\t\t\tseg.update(cp.mp[nowx] + 1+ amax, cp.mp[nowx] + 2+ amax, make_pair(0, -1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"miss\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t{\n\n\t\t\t\tint bomb = seg.get(cp.mp[q.a] + 1, cp.mp[q.b] + 1);\n\t\t\t\tcout << \"bomb \" << bomb << endl;\n\t\t\t\tseg.update(cp.mp[q.a], cp.mp[q.b] + 1, make_pair(1, 0));\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tint amin = -1;\n\t\t\t\tint amax = 3e5;\n\t\t\t\twhile (amin + 1 != amax) {\n\t\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\t\tif (seg.get(cp.mp[nowx] + 1, cp.mp[nowx] + 2 + amid) >= q.a) {\n\t\t\t\t\t\tamax = amid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin = amid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (amax != 3e5) {\n\t\t\t\t\tlong long int dis = cp.revmp[cp.mp[nowx] +1+ amax] - nowx;\n\t\t\t\t\tcout << \"distance \" << dis << endl;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"distance -1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"end\" << endl;\n\t\tassert(cp.mp.size() == cp.revmp.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1515 The Humans Braving the Invaders\n// 2019.4.1 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n//// 高速入出力\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()  // 非負整数の入力\n{\n\tint n = 0, c = gc();\n//\twhile (isspace(c)) c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)  // 整数の表示\n{\n\tint i;\n\tchar b[30];\n\n\tif (!n) pc('0');\n\telse {\n//\t\tif (n < 0) n = -n, pc('-');\n\t\ti = 0; while (n) b[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(b[i]);\n\t}\n}\n\nvoid outs(char *s) { while (*s) pc(*s++); }    // 文字列の表示\n\n\n//// fenwick_tree_set\n// 空間加算\n#define MAXB 100005\nint bit1_data[MAXB + 5];\nint bit2_data[MAXB + 5];\nint bit_n, bit_cnt;\n\nvoid bit_init(int sz) {\n\tbit_n = sz, bit_cnt = 0;\n\tmemset(bit1_data, 0, sizeof(bit1_data));\n\tmemset(bit2_data, 0, sizeof(bit2_data));\n}\nint bit_query(int p) {   // 1-index\n\tint sum = 0;\n\twhile (p) sum += bit1_data[p], p -= p & -p;\n\treturn sum;\n}\nvoid bit_add(int p, int v) { while (p <= bit_n) bit1_data[p] += v, p += p & -p; }\n\nvoid range_add(int l, int r, int v) { // 空間[l,r]にv加算\n\tbit_add(l, v);\n\tbit_add(r + 1, -v);\n}\n\n// k番目IDの取得\nvoid add(int p, int x) { p++; while (p <= bit_n) bit2_data[p] += x, p += p & -p; }\nvoid insert(int val) { add(val, 1), bit_cnt++; }\nvoid erase(int val) { add(val, -1), bit_cnt--; }\nint _clzsi2(unsigned x) {\n\tunsigned y;\tint n = 32;\n\ty = x >> 16; if (y != 0) { n = n - 16; x = y; }\n\ty = x >> 8;  if (y != 0) { n = n - 8;  x = y; }\n\ty = x >> 4;  if (y != 0) { n = n - 4;  x = y; }\n\ty = x >> 2;  if (y != 0) { n = n - 2;  x = y; }\n\ty = x >> 1;  if (y != 0) return n - 2;\n\treturn n - x;\n}\nint kth_element(int k) {      // 0-index\n\tint p = 1 << (32 - _clzsi2(bit_n));\n\tint ans = 0;\n\twhile (p >>= 1) if (ans + p <= bit_n && bit2_data[ans + p] <= k)\n\t\tk -= bit2_data[ans + p], ans += p;\n\treturn ans;\n};\n\n\n//// 本問題関連\n#define MAX 100010\nchar f[MAX];           // そのIDのインベーダーが現存しているかどうか\nint top;               // 生存中インベーダー集団の先頭\nint id;                // 個体につけるID（１から）\nint L;\nint cnt;               // 生存しているインベーダーの数\n\n// バイナリサーチ\nint bsch_upper(int x)\n{\n\tint m, l, r;\n\n\tl = top, r = id + 1;\n\twhile (l < r) {\n\t\tm = (l + r) >> 1;\n\t\tif (bit_query(m) < x) l = m + 1; else r = m;\n\t}\n\treturn l;\n}\n\nint bsch_lower(int x)\n{\n\tint m, l, r;\n\n\tl = top, r = id + 1;\n\twhile (l < r) {\n\t\tm = (l + r) >> 1;\n\t\tif (bit_query(m) <= x) l = m + 1; else r = m;\n\t}\n\treturn l-1;\n}\n\nint main()\n{\n\tint i, Q, c, k, s, a, b;\n\tint x, r, d;\n\n\twhile (Q = in()) {\n\t\tL = in();\n\n\t\t// 初期化\n\t\tid = 0;                      // IDは1から\n\t\tbit_init(MAXB);              // bit木の初期化\n\t\tmemset(f, 0, sizeof(f));\n\t\ttop = 1, cnt = 0;\n\n\t\t// 各種クエリを時系列順に処理\n\t\twhile (Q--) {\n\t\t\tc = in();      // query id\n\t\t\tif (c == 0) {          // インベーダーが出現\n\t\t\t\tinsert(++id);      // IDをk番目ID取得用BIT木に登録\n\t\t\t\trange_add(id, id, L);\n\t\t\t\tif (top > id) top = id;\n\t\t\t\tf[id] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse if (c == 1) {     // インベーダーが距離dだけ移動\n\t\t\t\td = -in();\n\t\t\t\tif (cnt == 0) continue;\n\t\t\t\trange_add(top, id, d);\n\t\t\t\ti = bsch_lower(0);\n\t\t\t\tif (i < top) i = top;\n\t\t\t\tif (i > id) i = id;\n\t\t\t\tif (bit_query(i) <= 0) {\n\t\t\t\t\ts = 0;\n\t\t\t\t\twhile (top <= i) {\n\t\t\t\t\t\tif (f[top]) s++, erase(top), f[top] = 0;\n\t\t\t\t\t\ttop++;\n\t\t\t\t\t}\n\t\t\t\t\tif (s > 0) outs(\"damage \"), out(s), pc('\\n'), cnt -= s;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == 2) {   // k番目のインベーダーを撃墜\n\t\t\t\tk = in();\n\t\t\t\tif (k > cnt) outs(\"miss\\n\");\n\t\t\t\telse {\n\t\t\t\t\ti = kth_element(k - 1); // BIT木から(x-1)番目のIDを取得\n\t\t\t\t\tf[i] = 0, cnt--, erase(i);\n\t\t\t\t\touts(\"hit\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == 3) {  // 広範囲にインベーダーを攻撃\n\t\t\t\tx = in(), r = in();\n\t\t\t\tif (cnt == 0) { outs(\"bomb 0\\n\"); continue; }\n\t\t\t\tif (x - r <= 0) a = top;\n\t\t\t\telse a = bsch_upper(x - r);\n\t\t\t\tif (x + r >= L) b = id;\n\t\t\t\telse b = bsch_lower(x + r);\n\t\t\t\tif (a < top) a = top;\n\t\t\t\twhile (a < id) {\n\t\t\t\t\tif (bit_query(a) >= x - r) break;\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif (b > id) b = id;\n\t\t\t\twhile (a <= b) {\n\t\t\t\t\tif (bit_query(b) <= x + r) break;\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t\ts = 0;  while (a <= b) {\n\t\t\t\t\tif (f[a]) s++, erase(a), f[a] = 0;\n\t\t\t\t\tif (top == a) top++;\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\touts(\"bomb \"), out(s), pc('\\n'), cnt -= s;\n\t\t\t}\n\t\t\telse {              // 距離の報告\n\t\t\t\tk = in();\n\t\t\t\tif (k > cnt) outs(\"distance -1\\n\");\n\t\t\t\telse {\n\t\t\t\t\ti = kth_element(k - 1); // BIT木から(x-1)番目のIDを取得\n\t\t\t\t\touts(\"distance \"), out(bit_query(i)), pc('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\touts(\"end\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define BIT_MAX 100000\n\nint bit_table[BIT_MAX];\n\nvoid bit_init() {\n\tint i;\n\tfor(i=0;i<BIT_MAX;i++)bit_table[i]=0;\n}\n\nvoid bit_add(int pos,int value) {\n\tpos++;\n\twhile(pos<=BIT_MAX) {\n\t\tbit_table[pos-1]+=value;\n\t\tpos+=pos & (-pos);\n\t}\n}\n\nint bit_sum(int pos) {\n\tint sum=0;\n\tpos++;\n\twhile(pos>0) {\n\t\tsum+=bit_table[pos-1];\n\t\tpos-=pos & (-pos);\n\t}\n\treturn sum;\n}\n\nlong long invader_table[BIT_MAX];\nlong long invader_offset;\nint invader_count;\nint realtime_invader_count;\n\nint getInvader(int id) {\n\tint left,right,mid;\n\tleft=0;right=BIT_MAX-1;\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(bit_sum(mid)>=id+1)right=mid-1;\n\t\telse left=mid+1;\n\t}\n\tif(left>=BIT_MAX)return -1;\n\treturn right+1;\n}\n\nint main(void) {\n\tint Q;\n\tlong long L;\n\tint query,p1,p2;\n\tint query_count;\n\tint left,right,mid;\n\tint start_invader,next_invader;\n\tint count;\n\twhile(scanf(\"%d%lld\",&Q,&L)==2 && (Q|L)!=0) {\n\t\tbit_init();\n\t\tinvader_offset=0;\n\t\tinvader_count=0;\n\t\trealtime_invader_count=0;\n\t\tfor(query_count=0;query_count<Q;query_count++) {\n\t\t\tscanf(\"%d\",&query);\n\t\t\tswitch(query) {\n\t\t\t\tcase 0:\n\t\t\t\t\tinvader_table[invader_count]=L-invader_offset;\n\t\t\t\t\tbit_add(invader_count,1);\n\t\t\t\t\tinvader_count++;\n\t\t\t\t\trealtime_invader_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tscanf(\"%d\",&p1);\n\t\t\t\t\tinvader_offset-=p1;\n\t\t\t\t\tcount=0;\n\t\t\t\t\twhile(1) {\n\t\t\t\t\t\tnext_invader=getInvader(0);\n\t\t\t\t\t\tif(next_invader<0)break;\n\t\t\t\t\t\tif(invader_table[next_invader]+invader_offset<=0) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tbit_add(next_invader,-1);\n\t\t\t\t\t\t\trealtime_invader_count--;\n\t\t\t\t\t\t} else break;\n\t\t\t\t\t}\n\t\t\t\t\tif(count>0)printf(\"damage %d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tscanf(\"%d\",&p1);\n\t\t\t\t\tnext_invader=getInvader(p1-1);\n\t\t\t\t\tif(next_invader>=0) {\n\t\t\t\t\t\tbit_add(next_invader,-1);\n\t\t\t\t\t\trealtime_invader_count--;\n\t\t\t\t\t\tputs(\"hit\");\n\t\t\t\t\t} else puts(\"miss\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tscanf(\"%d%d\",&p1,&p2);\n\t\t\t\t\tif(realtime_invader_count>0) {\n\t\t\t\t\t\tleft=0;right=realtime_invader_count-1;\n\t\t\t\t\t\twhile(left<=right) {\n\t\t\t\t\t\t\tmid=(left+right)/2;\n\t\t\t\t\t\t\tif(p1-p2<=invader_table[getInvader(mid)]+invader_offset) {\n\t\t\t\t\t\t\t\tright=mid-1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft=mid+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstart_invader=right+1;\n\t\t\t\t\t\tleft=0;right=realtime_invader_count-1;\n\t\t\t\t\t\twhile(left<=right) {\n\t\t\t\t\t\t\tmid=(left+right)/2;\n\t\t\t\t\t\t\tif(p1+p2<invader_table[getInvader(mid)]+invader_offset) {\n\t\t\t\t\t\t\t\tright=mid-1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft=mid+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext_invader=right+1;\n\t\t\t\t\t\tfor(count=start_invader;count<next_invader;count++) {\n\t\t\t\t\t\t\tbit_add(getInvader(start_invader),-1);\n\t\t\t\t\t\t\trealtime_invader_count--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"bomb %d\\n\",next_invader-start_invader);\n\t\t\t\t\t} else puts(\"bomb 0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tscanf(\"%d\",&p1);\n\t\t\t\t\tnext_invader=getInvader(p1-1);\n\t\t\t\t\tif(next_invader>=0) {\n\t\t\t\t\t\tprintf(\"distance %lld\\n\",invader_table[next_invader]+invader_offset);\n\t\t\t\t\t} else puts(\"distance -1\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tputs(\"end\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1515\n  Title:The Humans Braving the Invaders\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define min(x,y) (((x)<(y))?(x):(y))\n#define max(x,y) (((x)>(y))?(x):(y))\n\nint Q,L;\n\nint inv[100000];\nint inv_last,inv_cnt;\nint order,arg1,arg2;\n\n\nint get_nth_inv_no(int n)\n{\n  int i,c;\n\n  for(i=0,c=0;i<inv_last;i++)\n    if(inv[i]>0)\n      {\n\tc++;\n\tif(c==n)\n\t  return(i);\n      }\n  return(-1);\n}\n\nvoid execute(int order,int arg1,int arg2)\n{\n  int i,damage,c,ret;\n  if(order==0)\n    {\n      inv[inv_last++]=L;\n      inv_cnt++;\n    }\n  if(order==1)\n    {\n      for(i=damage=0;i<inv_last;i++)\n\t{\n\t  if(inv[i]>arg1)\n\t    inv[i]-=arg1;\n\t  else if(inv[i] > 0)\n\t    {\n\t      inv[i]=-1;\n\t      inv_cnt--;\n\t      damage++;\n\t    }\n\t}\n      if(damage)\n\tprintf(\"damage %d\\n\",damage);\n    }\n  if(order==2)\n    if(inv_cnt>=arg1)\n      {\n\tret=get_nth_inv_no(arg1);\n\tinv[ret]=-1;\n\tinv_cnt--;\n\tprintf(\"hit\\n\");\n      }\n    else\n      printf(\"miss\\n\");\n  \n  if(order==3)\n    {\n      for(i=c=0;i<inv_last;i++)\n\t{\n\t  if(inv[i] >= max(0,arg1-arg2) && inv[i] <= min(L,arg1+arg2))\n\t    {\n\t      inv_cnt--;\n\t      c++;\n\t      inv[i]=-1;\n\t    }\n\t}\n      printf(\"bomb %d\\n\",c);\n    }\n  \n  if(order==4)\n    {\n      ret=get_nth_inv_no(arg1);\n      if(ret>=0)\n\t printf(\"distance %d\\n\",inv[ret]);\n      else\n\tprintf(\"distance -1\\n\");\n    }\n}\n\nvoid dump()\n{\n  int i;\n\n  for(i=0;i<inv_last;i++)\n    printf(\"%d|\",inv[i]);\n\t   printf(\"\\n\");\n}\n\nmain()\n{\n  int i,ret;\n\n  while(scanf(\"%d %d\",&Q,&L)  && (Q||L))\n    {\n      memset(inv,-1,sizeof(inv));\n      inv_cnt=0;\n      for(i=0;i<Q;i++)\n\t{\n\t  scanf(\"%d\",&order);\n\t  if(order == 1||order==2||order==4)\n\t    scanf(\"%d\",&arg1);\n\t  else if (order==3)\n\t    scanf(\"%d %d\",&arg1,&arg2);\n\t  execute(order,arg1,arg2);\n#ifdef DEBUG\n\t  dump();\n#endif\n\t}\n      printf(\"end\\n\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace aizu\n{\n    class OnlineJudge\n    {\n        private static List<bool> invader = null;\n        static void Main()\n        {\n            Action<string>[] query = new Action<string>[] {\n                Query0, Query1, Query2, Query3, Query4\n            };\n            int[] data;\n            while(((data = Console.ReadLine().Split().Select(p => int.Parse(p)).ToArray())[0] | data[1]) != 0) {\n                invader = Enumerable.Repeat(false, data[1]).ToList();\n                for(int i=0; i < data[0]; ++i) {\n                    var input = Console.ReadLine();\n                    query[int.Parse(input.Split()[0])](input);\n                }\n                Console.WriteLine(\"end\");\n            }\n        }\n        static void Query0(string msg)\n        {\n            invader[invader.Count - 1] = true;\n        }\n        static void Query1(string msg)\n        {\n            int d = int.Parse(msg.Split()[1]);\n            int damage = 0;\n            for(int i=0; i < d; ++i) {\n                if(invader[0]) {\n                    ++damage;\n                }\n                invader.RemoveAt(0);\n                invader.Add(false);\n            }\n            if(damage != 0) {\n                Console.WriteLine(\"damage {0}\", damage);\n            }\n        }\n        static void Query2(string msg)\n        {\n            int s = int.Parse(msg.Split()[1]);\n            int count = 0;\n            for(int i=0; i < invader.Count; ++i) {\n                if(invader[i]) {\n                    ++count;\n                }\n                if(count == s) {\n                    invader[i] = false;\n                    Console.WriteLine(\"hit\");\n                    count = -1;\n                    break;\n                }\n            }\n            if(count != -1) {\n                Console.WriteLine(\"miss\");\n            }\n        }\n        static void Query3(string msg)\n        {\n            int[] g = msg.Split().Select(p => int.Parse(p)).ToArray();\n            int count = 0;\n            for(int i=0; i <= g[2]; ++i) {\n                if(invader[g[1] - 1 + i]) {\n                    ++count;\n                    invader[g[1] - 1 + i] = false;\n                }\n                if(i != 0 && g[1] - 1 - i >= 0 && invader[g[1] - 1 - i]) {\n                    ++count;\n                    invader[g[1] - 1 - i] = false;\n                }\n            }\n            Console.WriteLine(\"bomb {0}\", count);\n        }\n        static void Query4(string msg)\n        {\n            int d = int.Parse(msg.Split()[1]);\n            int count = 0;\n            int first = -1;\n            for(int i=0; i < invader.Count; ++i) {\n                if(invader[i]) {\n                    if(first == -1) {\n                        first = i + 1;\n                    }\n                    ++count;\n                }\n                if(count == d) {\n                    break;\n                }\n            }\n            Console.WriteLine(\"distance {0}\", count == d ? first : -1);\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1515\n\nfor i in range(3):\n\tfirstInput = input()\n\tif firstInput == \"0 0\":\n\t\tbreak\n\telse:\n\t\tinvader = []\n\t\tQ = int(firstInput.split(\" \")[0])\n\t\tL = int(firstInput.split(\" \")[1])\n\t\tfor j in range(Q):\n\t\t\totherInput = input()\n\t\t\tinputList = []\n\t\t\tfor k in range(len(otherInput.split(\" \"))):\n\t\t\t\tinputList.append(int(otherInput.split(\" \")[k]))\n\n\t\t\tif inputList[0] == 0:\n\t\t\t\tinvader.append(L)\n\n\t\t\telif inputList[0] == 1:\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tinvader[l] -= inputList[1]\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] <= 0:\n\t\t\t\t\t\ta += 1\n\t\t\t\tif a > 0:\n\t\t\t\t\tfor l in range(a):\n\t\t\t\t\t\tdel invader[0]\n\t\t\t\t\tprint(\"damage \" + str(a))\n\n\t\t\telif inputList[0] == 2:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"miss\")\n\t\t\t\telse:\n\t\t\t\t\tdel invader[inputList[1]-1]\n\t\t\t\t\tprint(\"hit\")\n\n\t\t\telif inputList[0] == 3:\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] > inputList[1]:\n\t\t\t\t\t\tif invader[l] - inputList[1] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif inputList[1] - invader[l] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t#print(b)\n\t\t\t\tfor l in range(len(b)):\n\t\t\t\t\tdel invader[b[0]]\n\t\t\t\tprint(\"bomb \" + str(a))\n\n\t\t\telif inputList[0] == 4:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"distance -1\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"distance \"+str(invader[inputList[1]-1]))\n\n\t\t\t#print(invader)\n\t\tprint(\"end\")"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1515\n\nfor i in range(3):\n\tfirstInput = input()\n\tif firstInput == \"0 0\":\n\t\tbreak\n\telse:\n\t\tinvader = []\n\t\tQ = int(firstInput.split(\" \")[0])\n\t\tL = int(firstInput.split(\" \")[1])\n\t\tfor j in range(Q):\n\t\t\totherInput = input()\n\t\t\tinputList = []\n\t\t\tfor k in range(len(otherInput.split(\" \"))):\n\t\t\t\tinputList.append(int(otherInput.split(\" \")[k]))\n\t\t\tif inputList[0] == 0:\n\t\t\t\tinvader.append(L)\n\t\t\telif inputList[0] == 1:\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tinvader[l] -= inputList[1]\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] <= 0:\n\t\t\t\t\t\ta += 1\n\t\t\t\tfor l in range(a):\n\t\t\t\t\tdel invader[0]\n\t\t\t\tif a > 0:\n\t\t\t\t\tprint(\"damage \" + str(a))\n\t\t\telif inputList[0] == 2:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"miss\")\n\t\t\t\telse:\n\t\t\t\t\tdel invader[inputList[1]-1]\n\t\t\t\t\tprint(\"hit\")\n\t\t\telif inputList[0] == 3:\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] > inputList[1]:\n\t\t\t\t\t\tif invader[l] - inputList[1] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif inputList[1] - invader[l] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\tprint(b)\n\t\t\t\tfor l in range(len(b)):\n\t\t\t\t\tdel invader[b[0]]\n\t\t\t\tprint(\"bomb \" + str(a))\n\t\t\telif inputList[0] == 4:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"distance -1\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"distance \"+str(invader[inputList[1]-1]))\n\t\t\tprint(invader)\n\t\tprint(\"end\")"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1515\n\nfor i in range(3):\n\tfirstInput = input()\n\tif firstInput == \"0 0\":\n\t\tbreak\n\telse:\n\t\tinvader = []\n\t\tQ = int(firstInput.split(\" \")[0])\n\t\tL = int(firstInput.split(\" \")[1])\n\t\tfor j in range(Q):\n\t\t\totherInput = input()\n\t\t\tinputList = []\n\t\t\tfor k in range(len(otherInput.split(\" \"))):\n\t\t\t\tinputList.append(int(otherInput.split(\" \")[k]))\n\t\t\tif inputList[0] == 0:\n\t\t\t\tinvader.append(L)\n\t\t\telif inputList[0] == 1:\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tinvader[l] -= inputList[1]\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] <= 0:\n\t\t\t\t\t\ta += 1\n\t\t\t\tfor l in range(a):\n\t\t\t\t\tdel invader[0]\n\t\t\t\tif a > 0:\n\t\t\t\t\tprint(\"damage \" + str(a))\n\t\t\telif inputList[0] == 2:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"miss\")\n\t\t\t\telse:\n\t\t\t\t\tdel invader[inputList[1]-1]\n\t\t\t\t\tprint(\"hit\")\n\t\t\telif inputList[0] == 3:\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] > inputList[1]:\n\t\t\t\t\t\tif invader[l] - inputList[1] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif inputList[1] - invader[l] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\tprint(b)\n\t\t\t\tfor l in range(len(b)):\n\t\t\t\t\tdel invader[b[0]]\n\t\t\t\tprint(\"bomb \" + str(a))\n\t\t\telif inputList[0] == 4:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"distance -1\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"distance \"+str(invader[inputList[1]-1]))\n\t\t\t#print(invader)\n\t\tprint(\"end\")"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1515\n\nfor i in range(3):\n\tfirstInput = input()\n\tif firstInput == \"0 0\":\n\t\tbreak\n\telse:\n\t\tinvader = []\n\t\tQ = int(firstInput.split(\" \")[0])\n\t\tL = int(firstInput.split(\" \")[1])\n\t\tfor j in range(Q):\n\t\t\totherInput = input()\n\t\t\tinputList = []\n\t\t\tfor k in range(len(otherInput.split(\" \"))):\n\t\t\t\tinputList.append(int(otherInput.split(\" \")[k]))\n\t\t\tif inputList[0] == 0:\n\t\t\t\tinvader.append(L)\n\t\t\telif inputList[0] == 1:\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tinvader[l] -= inputList[1]\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] <= 0:\n\t\t\t\t\t\ta += 1\n\t\t\t\tfor l in range(a):\n\t\t\t\t\tdel invader[0]\n\t\t\t\tif a > 0:\n\t\t\t\t\tprint(\"damage \" + str(a))\n\t\t\telif inputList[0] == 2:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"miss\")\n\t\t\t\telse:\n\t\t\t\t\tdel invader[inputList[1]-1]\n\t\t\t\t\tprint(\"hit\")\n\t\t\telif inputList[0] == 3:\n\t\t\t\ta = 0\n\t\t\t\tb = []\n\t\t\t\tfor l in range(len(invader)):\n\t\t\t\t\tif invader[l] > inputList[1]:\n\t\t\t\t\t\tif invader[l] - inputList[1] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif inputList[1] - invader[l] <= inputList[2]:\n\t\t\t\t\t\t\ta += 1\n\t\t\t\t\t\t\tb.append(l)\n\t\t\t\t#print(b)\n\t\t\t\tfor l in range(len(b)):\n\t\t\t\t\tdel invader[b[0]]\n\t\t\t\tprint(\"bomb \" + str(a))\n\t\t\telif inputList[0] == 4:\n\t\t\t\tif len(invader) < inputList[1]:\n\t\t\t\t\tprint(\"distance -1\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"distance \"+str(invader[inputList[1]-1]))\n\t\t\t#print(invader)\n\t\tprint(\"end\")"
  }
]