[
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint n, m;\n\nint bingo[4][4][4];\nint hit[4][4];\nint nums[4 * 4];\nint ans;\n\nvector<pair<int, pair<int, int> > > memo[100];\n\nbool bingoCheck(int hit[4]){\n  // tate\n  REP(i,m){\n    if(hit[i] == (1 << m) - 1) return true;\n  }\n  // yoko\n  int tmp = (1 << m) - 1;\n  REP(i,m){\n    tmp &= hit[i];\n  }\n  if(tmp != 0) return true;\n\n  {\n    // naname1\n    int cnt = 0;\n    REP(i,m) cnt += (hit[i] & (1 << i)) != 0;\n    if(cnt == m) return true;\n  }\n  {\n    // naname2\n    int cnt = 0;\n    REP(i,m) cnt += (hit[i] & (1 << (m - i - 1))) != 0;\n    if(cnt == m) return true;\n  }\n  return false;\n}\n\nvoid bingoGo(int num, bool which){\n  REP(c, memo[num].size()){\n    int i = memo[num][c].first;\n    int j = memo[num][c].second.first;\n    int k = memo[num][c].second.second;\n\n    if(which)\n      hit[i][j] |= (1 << k);\n    else\n      hit[i][j] &= ~(1 << k);\n  }\n}\n\nbool dp[1<<12];\nint nn[4 * 4];\nint ns;\n\nbool cango(int flag){\n  if(flag == (1 << ns) - 1) return true;\n  if(dp[flag]) return false;\n  dp[flag] = true;\n\n  REP(i,ns) if((flag & (1 << i)) == 0){\n    bingoGo(nn[i], true);\n\n    int ff = 0;\n    REP(j,n) if(bingoCheck(hit[j])) ff |= (1 << j);\n\n    bool ok = true;\n    REP(j,n-1) if((ff & (1 << j)) == 0 && (ff & (1 << (j + 1))) != 0){\n      ok = false;\n      break;\n    }\n\n    if(ok && cango(flag ^ (1 << i)))\n      return true;\n\n    bingoGo(nn[i], false);\n  }\n  return false;\n}\n\nbool check(){\n  REP(i,(n - 1) * m) nn[i] = nums[i];\n  sort(nn, nn + (n - 1) * m);\n  ns = unique(nn, nn + (n - 1) * m) - nn;\n  memset(dp, 0, 1 << ns);\n  return cango(0);\n}\n\nint restMin(){\n  set<int> s(nums, nums + (n - 1) * m);\n  vector<int> v(s.begin(), s.end());\n\n  REP(i,n) REP(j,m) hit[i][j] = 0;\n  REP(i,v.size()){\n    bingoGo(v[i], true);\n  }\n\n  int ret = 1000;\n  int *hh = hit[n - 1];\n\n  // tate\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) if(hh[j] & (1 << i))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  // yoko\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) if(hh[i] & (1 << j))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  //naname1\n  {\n    int cnt = 0;\n    REP(i,m) if(hh[i] & (1 << i))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  //naname2\n  {\n    int cnt = 0;\n    REP(i,m) if(hh[i] & (1 << (m - i - 1)))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  return ret;\n}\n\nvoid solve(int pos){\n  if(pos == n - 1){\n    int tmp = set<int>(nums, nums + (n - 1) * m).size()\n      + restMin();\n\n    if(tmp < ans){\n      REP(i,n) REP(j,m) hit[i][j] = 0;\n      if(check()) ans = tmp;\n    }\n    return;\n  }\n\n  // tate\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][j][i];\n    }\n    solve(pos + 1);\n  }\n\n  // yoko\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][i][j];\n    }\n    solve(pos + 1);\n  }\n\n  // naname1\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][i][i];\n  }\n  solve(pos + 1);\n\n  // naname2\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][m - i - 1][i];\n  }\n  solve(pos + 1);\n}\n\nint main(){\n  while(true){\n    n = getInt();\n    m = getInt();\n\n    if(n + m == 0) break;\n\n    REP(i,100) memo[i] = vector<pair<int, pair<int, int> > >();\n\n    REP(i,n){\n      REP(j,m) REP(k,m){\n\tbingo[i][j][k] = getInt();\n\tmemo[bingo[i][j][k]].push_back(make_pair(i, make_pair(j, k)));\n      }\n    }\n\n    ans = 1000;\n    solve(0);\n    if(ans == 1000) ans = 0;\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nbool ischoosed[100];\nint  check[100];\nint bingo[4][4][4];\n\nbool isbingo(int n,int p,bool *used){\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][i][j]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][j][i]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  bool isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][i]])isbingo=false;\n  }\n \n  if (isbingo)return true;\n  isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][n-1-i]])isbingo = false;\n  }\n  return false;\n}\n\nbool check_valid(int n,int player,bool *used){\n  bool isok=true;\n  rep(i,player){\n    if (isbingo(n,i,used)){\n      if (!isok)return false;\n    }else isok=false;\n  }\n  return true;\n}\n\nint ans;\n\nbool is_complete(int n,int player,bool *used){\n  rep(i,player-1){\n    if (!isbingo(n,i,used))return false;\n  }\n  return true;\n}\n\nint num[3][10][4];\nvoid make_table(int n,int p){\n  int total=0;\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][i][j];\n    total++;\n  }\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][j][i];\n    total++;\n  }\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][i];\n  }\n  total++;\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][n-1-i];\n  }\n  total++;\n}\n\nint require_last(int n ,int p,bool *used){\n  int mini=100;\n  int lim=n==3?8:10;\n  rep(i,lim){\n    int tmp=0;\n    rep(j,n){\n      if (!used[num[p][i][j]])tmp++;\n    }\n    mini=min(tmp,mini);\n  }\n  return mini;\n}\n\nbool search(int n,int player,int size,int *array,int cnt,bool *used){\n  if (cnt >= ans)return false;\n  if (!check_valid(n,player,used))return false;\n  if (is_complete(n,player,used)){\n    //    cout << ans <<\" \" << cnt << endl;\n    //rep(i,size)cout << used[i];\n    //    cout << endl;\n    //    cout << ans <<\" \" << cnt <<\" \"<< require_last(n,player-1,used)<<endl;\n    ans=min(ans,cnt+require_last(n,player-1,used));\n    return true;\n  }\n\n  rep(i,size){\n    if (used[array[i]])continue;\n    used[array[i]]=true;\n    if (search(n,player,size,array,cnt+1,used)){\n      used[array[i]]=false;\n      return true;\n    }\n    used[array[i]]=false;\n  }\n  return false;\n}\n\nint array[100];\nbool used[200];\nvoid search2(int n,int player,int now){\n  if (now+1 == player){\n    int p=0;\n    rep(i,100){\n      if (ischoosed[i]){\n\tarray[p++]=i;\n\tused[i]=false;\n      }\n    }\n\n    /*\n    cout <<\"size \"<< p << endl;\n    rep(i,p){\n      cout << array[i] <<\" \";\n    }\n    cout << endl;\n    */\n    search(n,player,p,array,0,used);\n    return;\n  }\n\n  int lim = n==3?8:10;\n  rep(i,lim){\n    rep(j,n){\n      if (check[num[now][i][j]] == -1){\n\tischoosed[num[now][i][j]]=true;\n\tcheck[num[now][i][j]]=now;\n      }\n    }\n    \n    search2(n,player,now+1);\n    \n    rep(j,n){\n      if (check[num[now][i][j]] == now){\n\tcheck[num[now][i][j]]=-1;\n\tischoosed[num[now][i][j]]=false;\n      }\n    }\n  }\n  return;\n}\n\n\n\nmain(){\n  int player,n;\n  while(cin>>player>>n && player){\n    map<int,int> M;\n    rep(k,player){\n      rep(i,n){\n\trep(j,n){\n\t  cin>>bingo[k][i][j];\n\t  M[bingo[k][i][j]]++;\n\t}\n      }\n    }\n    rep(i,100){\n      ischoosed[i]=false;\n      check[i]=-1;\n    }\n\n    \n    rep(k,player){\n      make_table(n,k);\n    }\n    \n    ans = 100;\n    search2(n,player,0);\n    if (ans == 100)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nstruct pt {\n   int c, x, y;\n};\n\nint c[4][4][4], N;\nbool s[100];\n\nint check(int card, int x, int y) {\n\tint i;\n\n   for (i=0; i<N; i++) if (s[c[card][x][i]] == false) break;\n\tif (i == N) return x;\n\n   for (i=0; i<N; i++) if (s[c[card][i][y]] == false) break;\n\tif (i == N) return N + y;\n\n\tif (x == y) {\n\t   for (i=0; i<N; i++) if (s[c[card][i][i]] == false) break;\n\t\tif (i == N) return 2*N;\n\t}\n\n\tif (N-1-x == y) {\n\t\tfor (i=0; i<N; i++) if (s[c[card][N-1-i][i]] == false) break;\n\t\tif (i == N) return 2*N+1;\n\t}\n\treturn -1;\n}\n\nint main() {\n\nint C, i, j, k, S, tmp, cur, BESTS, D, tmpi, d[4];\nbool num[100], flag;\nvector<int> v;\nvector<pt> pos[100];\npt tmppt;\n\nsrand(time(0));\n\ncin >> C;\ncin >> N;\n\ndo {\n\nfor (i=0; i<100; i++) pos[i].clear();\nmemset(num, false, sizeof(num)); v.clear();\nfor (k=0; k<C; k++) {\n   for (i=0; i<N; i++) {\n\t\tfor (j=0; j<N; j++) {\n\t\t\tcin >> c[k][i][j];\n\t\t\ttmppt.c = k; tmppt.x = i; tmppt.y = j;\n\t\t\tpos[c[k][i][j]].push_back(tmppt);\n\t\t\tif (num[c[k][i][j]] == false) {\n\t\t\t\tnum[c[k][i][j]] = true;\n\t\t\t\tv.push_back(c[k][i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBESTS = 101;\nfor (j=0; j<10000; j++) {\n\n\tS = D = 0; flag = true;\n\tmemset(s, false, sizeof(s));\n\tmemset(d, -1, sizeof(d));\n\n\twhile (1) {\n   \ttmp = rand()%(v.size()-S);\n\t   cur = v[tmp]; s[cur] = true;\n   \ttmpi = v[v.size()-S-1];\n\t\tv[v.size()-S-1] = v[tmp];\n\t\tv[tmp] = tmpi;\n\t\tS++;\n\n//\t\tcout << \"salio el \" << cur; for (i=0; i<C; i++) cout << ' ' << d[i]; cout << endl;\n\n\t\tfor (i=0; i<pos[cur].size(); i++) {\n\t\t\tif (d[pos[cur][i].c] == -1) {\n\t\t\t\td[pos[cur][i].c] = check(pos[cur][i].c, pos[cur][i].x, pos[cur][i].y);\n\t\t\t\tif (d[pos[cur][i].c] != -1) {\n\t\t\t\t\tD++;\n\t\t\t\t\tif (D == 4) break;\n\t\t\t\t\telse if (pos[cur][i].c > 0 && d[pos[cur][i].c-1] == -1) {flag = false; break;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i<pos[cur].size()) {\n\t\t\tif (flag == true) {\n\t\t\t\tmemset(s, false, sizeof(s)); S = 0;\n//\t\t\t\tcout << \"SALIERON \";\n//\t\t\t\tfor (i=0; i<C; i++) cout << d[i] << ' ';\n//\t\t\t\tcout << \" CON LOS NUMEROS \";\n\t\t\t\tfor (i=0; i<C; i++) {\n\t\t\t\t\tfor (k=0; k<N; k++) {\n\t\t\t\t\t\tif (d[i] < N) tmp = c[i][d[i]][k];\n\t\t\t\t\t\telse if (d[i] < 2*N) tmp = c[i][k][d[i]-N];\n\t\t\t\t\t\telse if (d[i] == 2*N) tmp = c[i][k][k];\n\t\t\t\t\t\telse tmp = c[i][N-1-k][k];\n\t\t\t\t\t\tif (s[tmp] == false) {\n//\t\t\t\t\t\t\tcout << tmp << ' ';\n\t\t\t\t\t\t\ts[tmp] = true;\n\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tcout << endl;\n\t\t\t\tif (BESTS > S) BESTS = S;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n//\tcout << \"sacamos \" << S << \" numeros y el resultado fue \" << flag << endl << endl;\n\n}\nif (BESTS < 101) cout << BESTS << endl;\nelse cout << 0 << endl;\n\ncin >> C;\ncin >> N;\n\n} while (N!=0 || C!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nbool ischoosed[100];\nint  check[100];\nint bingo[4][4][4];\n\nbool isbingo(int n,int p,bool *used){\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][i][j]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][j][i]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  bool isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][i]])isbingo=false;\n  }\n  if (isbingo)return true;\n  \n  isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][n-1-i]])isbingo = false;\n  }\n  if (isbingo)return true;\n  return false;\n}\n\nbool check_valid(int n,int player,bool *used){\n  bool isok=true;\n  rep(i,player){\n    if (isbingo(n,i,used)){\n      if (!isok)return false;\n    }else isok=false;\n  }\n  return true;\n}\n\nint ans;\n\nbool is_complete(int n,int player,bool *used){\n  rep(i,player-1){\n    if (!isbingo(n,i,used))return false;\n  }\n  return true;\n}\n\nint num[4][10][4];\nvoid make_table(int n,int p){\n  int total=0;\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][i][j];\n    total++;\n  }\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][j][i];\n    total++;\n  }\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][i];\n  }\n  total++;\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][n-1-i];\n  }\n  total++;\n}\n\nint require_last(int n ,int p,bool *used){\n  int mini=n;\n  int lim=n==3?8:10;\n  rep(i,lim){\n    int tmp=0;\n    rep(j,n){\n      if (!used[num[p][i][j]])tmp++;\n    }\n    mini=min(tmp,mini);\n  }\n  return mini;\n}\n\nbool search(int n,int player,int size,int *array,int cnt,bool *used){\n  if (!check_valid(n,player,used)){\n    return false;\n  }\n  if (is_complete(n,player,used)){\n    //    cout << ans <<\" \" << cnt << endl;\n    //rep(i,size)cout << used[i];\n    //    cout << endl;\n    //cout << ans <<\" \" << cnt <<\" \"<< require_last(n,player-1,used)<<endl;\n    ans=min(ans,cnt+require_last(n,player-1,used));\n    return true;\n  }\n\n  rep(i,size){\n    if (used[array[i]])continue;\n    used[array[i]]=true;\n    if (search(n,player,size,array,cnt+1,used)){\n      used[array[i]]=false;\n      return true;\n    }\n    used[array[i]]=false;\n  }\n  return false;\n}\n\nint array[100];\nbool used[200];\nvoid search2(int n,int player,int now){\n  if (now+1 == player){\n    int p=0;\n    rep(i,100){\n      if (ischoosed[i]){\n\tarray[p++]=i;\n\tused[i]=false;\n      }\n    }\n    \n    /*    \n      cout <<\"size \"<< p << endl;\n      rep(i,p){\n\tcout << array[i] <<\" \";\n      }\n      cout << endl;\n    */\n    \n    search(n,player,p,array,0,used);\n    return;\n  }\n\n  int lim = n==3?8:10;\n  rep(i,lim){\n    rep(j,n){\n      if (check[num[now][i][j]] == -1){\n\tischoosed[num[now][i][j]]=true;\n\tcheck[num[now][i][j]]=now;\n      }\n    }\n    \n    search2(n,player,now+1);\n    \n    rep(j,n){\n      if (check[num[now][i][j]] == now){\n\tcheck[num[now][i][j]]=-1;\n\tischoosed[num[now][i][j]]=false;\n      }\n    }\n  }\n  return;\n}\n\n\n\nmain(){\n  int player,n;\n  while(cin>>player>>n && player){\n    rep(k,player){\n      rep(i,n){\n\trep(j,n){\n\t  cin>>bingo[k][i][j];\n\t}\n      }\n    }\n\n    rep(i,100){\n      ischoosed[i]=false;\n      check[i]=-1;\n    }\n\n    rep(k,player){\n      make_table(n,k);\n    }\n\n    ans = 100;\n    search2(n,player,0);\n    if (ans == 100)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint n, m;\n\nint bingo[4][4][4];\nint hit[4][4];\nint nums[4 * 4];\nint ans;\n\nvector<pair<int, pair<int, int> > > memo[100];\n\nbool bingoCheck(int hit[4]){\n  // tate\n  REP(i,m){\n    if(hit[i] == (1 << m) - 1) return true;\n  }\n  // yoko\n  int tmp = (1 << m) - 1;\n  REP(i,m){\n    tmp &= hit[i];\n  }\n  if(tmp != 0) return true;\n\n  {\n    // naname1\n    int cnt = 0;\n    REP(i,m) cnt += (hit[i] & (1 << i)) != 0;\n    if(cnt == m) return true;\n  }\n  {\n    // naname2\n    int cnt = 0;\n    REP(i,m) cnt += (hit[i] & (1 << (m - i - 1))) != 0;\n    if(cnt == m) return true;\n  }\n  return false;\n}\n\nvoid bingoGo(int num, bool which){\n  REP(c, memo[num].size()){\n    int i = memo[num][c].first;\n    int j = memo[num][c].second.first;\n    int k = memo[num][c].second.second;\n\n    if(which)\n      hit[i][j] |= (1 << k);\n    else\n      hit[i][j] &= ~(1 << k);\n  }\n}\n\nbool dp[1<<16];\nint nn[4 * 4];\nint ns;\n\nbool cango(int flag){\n  if(flag == (1 << ns) - 1) return true;\n  if(dp[flag]) return false;\n  dp[flag] = true;\n\n  REP(i,ns) if((flag & (1 << i)) == 0){\n    bingoGo(nn[i], true);\n\n    int ff = 0;\n    REP(j,n) if(bingoCheck(hit[j])) ff |= (1 << j);\n\n    bool ok = true;\n    REP(j,n-1) if((ff & (1 << j)) == 0 && (ff & (1 << (j + 1))) != 0){\n      ok = false;\n      break;\n    }\n\n    if(ok && cango(flag ^ (1 << i)))\n      return true;\n\n    bingoGo(nn[i], false);\n  }\n  return false;\n}\n\nbool check(){\n  memset(dp, 0, sizeof(dp));\n  REP(i,(n - 1) * m) nn[i] = nums[i];\n  sort(nn, nn + (n - 1) * m);\n  ns = unique(nn, nn + (n - 1) * m) - nn;\n  return cango(0);\n}\n\nint restMin(){\n  set<int> s(nums, nums + (n - 1) * m);\n  vector<int> v(s.begin(), s.end());\n\n  REP(i,n) REP(j,m) hit[i][j] = 0;\n  REP(i,v.size()){\n    bingoGo(v[i], true);\n  }\n\n  int ret = 1000;\n  int *hh = hit[n - 1];\n\n  // tate\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) if(hh[j] & (1 << i))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  // yoko\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) if(hh[i] & (1 << j))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  //naname1\n  {\n    int cnt = 0;\n    REP(i,m) if(hh[i] & (1 << i))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  //naname2\n  {\n    int cnt = 0;\n    REP(i,m) if(hh[i] & (1 << (m - i - 1)))\n      cnt++;\n    ret = min(ret, m - cnt);\n  }\n  return ret;\n}\n\nvoid solve(int pos){\n  if(pos == n - 1){\n    int tmp = set<int>(nums, nums + (n - 1) * m).size()\n      + restMin();\n\n    if(tmp < ans){\n      REP(i,n) REP(j,m) hit[i][j] = 0;\n      if(check()) ans = tmp;\n    }\n    return;\n  }\n\n  // tate\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][j][i];\n    }\n    solve(pos + 1);\n  }\n\n  // yoko\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][i][j];\n    }\n    solve(pos + 1);\n  }\n\n  // naname1\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][i][i];\n  }\n  solve(pos + 1);\n\n  // naname2\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][m - i - 1][i];\n  }\n  solve(pos + 1);\n}\n\nint main(){\n  while(true){\n    n = getInt();\n    m = getInt();\n\n    if(n + m == 0) break;\n\n    REP(i,100) memo[i] = vector<pair<int, pair<int, int> > >();\n\n    REP(i,n){\n      REP(j,m) REP(k,m){\n\tbingo[i][j][k] = getInt();\n\tmemo[bingo[i][j][k]].push_back(make_pair(i, make_pair(j, k)));\n      }\n    }\n\n    ans = 1000;\n    solve(0);\n    if(ans == 1000) ans = 0;\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nint p, m;\nvector<vector<vector<int> > > card;\n\nbool isBingo(int curr, const vector<int>& use)\n{\n    for(int i=0; i<2*m+2; ++i){\n        bool ok = true;\n        for(int j=0; j<m; ++j){\n            if(!use[card[curr][i][j]])\n                ok = false;\n        }\n        if(ok)\n            return true;\n    }\n    return false;\n}\n\nint solve(int curr, vector<int>& use)\n{\n    if(curr == p)\n        return 0;\n    if(isBingo(curr, use))\n        return solve(curr+1, use);\n\n    int ret = INF;\n    for(int i=0; i<2*m+2; ++i){\n        int cost = 0;\n        for(int j=0; j<m; ++j){\n            if(++ use[card[curr][i][j]] == 1)\n                ++ cost;\n        }\n\n        bool ok = false;\n        for(int j=0; j<m; ++j){\n            if(use[card[curr][i][j]] > 1)\n                continue;\n            -- use[card[curr][i][j]];\n\n            if(!isBingo(curr, use)){\n                bool ng = false;\n                bool prev = true;\n                for(int k=curr+1; k<p; ++k){\n                    if(isBingo(k, use)){\n                        if(!prev)\n                            ng = true;\n                    }else{\n                        prev = false;\n                    }\n                }\n                if(!ng)\n                    ok = true;\n            }\n\n            ++ use[card[curr][i][j]];\n        }\n\n        if(ok)\n            ret = min(ret, cost + solve(curr+1, use));\n\n        for(int j=0; j<m; ++j)\n            -- use[card[curr][i][j]];\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        cin >> p >> m;\n        if(p == 0)\n            return 0;\n\n        card.assign(p, vector<vector<int> >(2*m+2, vector<int>(m)));\n        for(int i=0; i<p; ++i){\n            for(int j=0; j<m; ++j){\n                for(int k=0; k<m; ++k){\n                    cin >> card[i][j][k];\n                    card[i][m+k][j] = card[i][j][k];\n                }\n            }\n\n            for(int j=0; j<m; ++j){\n                card[i][2*m][j] = card[i][j][j];\n                card[i][2*m+1][j] = card[i][m-1-j][j];\n            }\n        }\n\n        vector<int> use(100, 0);\n        int ret = solve(0, use);\n\n        if(ret < INF)\n            cout << ret << endl;\n        else\n            cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nstruct pt {\n   int c, x, y;\n};\n\nint c[4][4][4], N;\nbool s[100];\n\nint check(int card, int x, int y) {\n\tint i;\n\n   for (i=0; i<N; i++) if (s[c[card][x][i]] == false) break;\n\tif (i == N) return x;\n\n   for (i=0; i<N; i++) if (s[c[card][i][y]] == false) break;\n\tif (i == N) return N + y;\n\n\tif (x == y) {\n\t   for (i=0; i<N; i++) if (s[c[card][i][i]] == false) break;\n\t\tif (i == N) return 2*N;\n\t}\n\n\tif (N-1-x == y) {\n\t\tfor (i=0; i<N; i++) if (s[c[card][N-1-i][i]] == false) break;\n\t\tif (i == N) return 2*N+1;\n\t}\n\treturn -1;\n}\n\nint main() {\n\nint C, i, j, k, S, tmp, cur, BESTS, D, tmpi, d[4];\nbool num[100], flag;\nvector<int> v;\nvector<pt> pos[100];\npt tmppt;\n\nsrand(time(0));\n\ncin >> C;\ncin >> N;\n\ndo {\n\nfor (i=0; i<100; i++) pos[i].clear();\nmemset(num, false, sizeof(num)); v.clear();\nfor (k=0; k<C; k++) {\n   for (i=0; i<N; i++) {\n\t\tfor (j=0; j<N; j++) {\n\t\t\tcin >> c[k][i][j];\n\t\t\ttmppt.c = k; tmppt.x = i; tmppt.y = j;\n\t\t\tpos[c[k][i][j]].push_back(tmppt);\n\t\t\tif (num[c[k][i][j]] == false) {\n\t\t\t\tnum[c[k][i][j]] = true;\n\t\t\t\tv.push_back(c[k][i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nBESTS = 101;\nfor (j=0; j<10000; j++) {\n\n\tS = D = 0; flag = true;\n\tmemset(s, false, sizeof(s));\n\tmemset(d, -1, sizeof(d));\n\n\twhile (1) {\n   \ttmp = rand()%(v.size()-S);\n\t   cur = v[tmp]; s[cur] = true;\n   \ttmpi = v[v.size()-S-1];\n\t\tv[v.size()-S-1] = v[tmp];\n\t\tv[tmp] = tmpi;\n\t\tS++;\n\n//\t\tcout << \"salio el \" << cur; for (i=0; i<C; i++) cout << ' ' << d[i]; cout << endl;\n\n\t\tfor (i=0; i<pos[cur].size(); i++) {\n\t\t\tif (d[pos[cur][i].c] == -1) {\n\t\t\t\td[pos[cur][i].c] = check(pos[cur][i].c, pos[cur][i].x, pos[cur][i].y);\n\t\t\t\tif (d[pos[cur][i].c] != -1) {\n\t\t\t\t\tD++;\n\t\t\t\t\tif (D == 4) break;\n\t\t\t\t\telse if (pos[cur][i].c > 0 && d[pos[cur][i].c-1] == -1) {flag = false; break;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i<pos[cur].size()) {\n\t\t\tif (flag == true) {\n\t\t\t\tmemset(s, false, sizeof(s)); S = 0;\n//\t\t\t\tcout << \"SALIERON \";\n//\t\t\t\tfor (i=0; i<C; i++) cout << d[i] << ' ';\n//\t\t\t\tcout << \" CON LOS NUMEROS \";\n\t\t\t\tfor (i=0; i<C; i++) {\n\t\t\t\t\tfor (k=0; k<N; k++) {\n\t\t\t\t\t\tif (d[i] < N) tmp = c[i][d[i]][k];\n\t\t\t\t\t\telse if (d[i] < 2*N) tmp = c[i][k][d[i]-N];\n\t\t\t\t\t\telse if (d[i] == 2*N) tmp = c[i][k][k];\n\t\t\t\t\t\telse tmp = c[i][N-1-k][k];\n\t\t\t\t\t\tif (s[tmp] == false) {\n//\t\t\t\t\t\t\tcout << tmp << ' ';\n\t\t\t\t\t\t\ts[tmp] = true;\n\t\t\t\t\t\t\tS++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tcout << endl;\n\t\t\t\tif (BESTS > S) BESTS = S;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n//\tcout << \"sacamos \" << S << \" numeros y el resultado fue \" << flag << endl << endl;\n\n}\nif (BESTS < 101) cout << BESTS << endl;\nelse cout << 0 << endl;\n\ncin >> C;\ncin >> N;\n\n} while (N!=0 || C!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nbool ischoosed[100];\nint  check[100];\nint bingo[4][4][4];\n\nbool isbingo(int n,int p){\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!ischoosed[bingo[p][i][j]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  \n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!ischoosed[bingo[p][j][i]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  \n  bool isbingo=true;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][i]])isbingo=false;\n  }\n \n  if (isbingo)return true;\n  isbingo=true;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][n-1-i]])isbingo = false;\n  }\n  return false;\n}\n\nbool check_valid(int n,int player){\n  bool isok=true;\n  rep(i,player){\n    if (isbingo(n,i)){\n      if (!isok)return false;\n    }else isok=false;\n  }\n  return true;\n}\n\nint ans;\n\nbool is_complete(int n,int player){\n  rep(i,player){\n    if (!isbingo(n,i))return false;\n  }\n  return true;\n}\n\nint need_for_single_bingo(int n,int k){\n\n}\n\nint require(int n,int p){\n\n}\n\nbool search(int n,int player,vector<int> &num,int cnt){\n  if (!check_valid(n,player))return false;\n  if (is_complete(n,player)){\n    ans=min(ans,cnt);\n    return true;\n  }\n\n  //if (require(n,player)+cnt > ans)return false;\n  if (cnt == ans)return false;\n  \n  rep(i,num.size()){\n    if (ischoosed[num[i]])continue;\n    ischoosed[num[i]]=true;\n    if (check_valid(n,player)){\n      if (search(n,player,num,cnt+1))return true;\n    }\n    ischoosed[num[i]]=false;\n  }\n  return false;\n}\n\n\nmain(){\n  int player,n;\n  while(cin>>player>>n && player){\n    map<int,int> M;\n    rep(k,player){\n      rep(i,n){\n\trep(j,n){\n\t  cin>>bingo[k][i][j];\n\t  M[bingo[k][i][j]]++;\n\t}\n      }\n    }\n    rep(i,100){\n      ischoosed[i]=false;\n      check[i]=-1;\n    }\n\n    vector<pair<int,int> > tmp;\n    map<int,int>::iterator itr = M.begin();\n    while(itr != M.end()){\n      pair<int,int> a;\n      a.first=(*itr).second;\n      a.second=(*itr).first;\n      tmp.pb(a);\n      itr++;\n    }\n    \n    vector<int> num;\n    sort(ALL(tmp),greater<pair<int,int> >());\n    rep(i,tmp.size()){\n      num.pb(tmp[i].second);\n    }\n    \n    //ans = n*player;\n    ans =0;\n    rep(i,n*player+1){\n      if (search(n,player,num,0)){\n\tbreak;\n      }\n      ans++;\n    }\n    if (ans == n*player+1)cout << 0 << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nbool ischoosed[100];\nint  check[100];\nint bingo[4][4][4];\n\nbool isbingo(int n,int p,bool *used){\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][i][j]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!used[bingo[p][j][i]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  bool isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][i]])isbingo=false;\n  }\n  if (isbingo)return true;\n  \n  isbingo=true;\n  rep(i,n){\n    if (!used[bingo[p][i][n-1-i]])isbingo = false;\n  }\n  if (isbingo)return true;\n  return false;\n}\n\nbool check_valid(int n,int player,bool *used){\n  bool isok=true;\n  rep(i,player){\n    if (isbingo(n,i,used)){\n      if (!isok)return false;\n    }else isok=false;\n  }\n  return true;\n}\n\nint ans;\n\nbool is_complete(int n,int player,bool *used){\n  rep(i,player-1){\n    if (!isbingo(n,i,used))return false;\n  }\n  return true;\n}\n\nint num[4][10][4];\nvoid make_table(int n,int p){\n  int total=0;\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][i][j];\n    total++;\n  }\n  rep(i,n){\n    rep(j,n)num[p][total][j]=bingo[p][j][i];\n    total++;\n  }\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][i];\n  }\n  total++;\n  rep(i,n){\n    num[p][total][i]=bingo[p][i][n-1-i];\n  }\n  total++;\n}\n\nint require_last(int n ,int p,bool *used){\n  int mini=n;\n  int lim=n==3?8:10;\n  rep(i,lim){\n    int tmp=0;\n    rep(j,n){\n      if (!used[num[p][i][j]])tmp++;\n    }\n    mini=min(tmp,mini);\n  }\n  return mini;\n}\n\nbool search(int n,int player,int size,int *array,int cnt,bool *used,\n\t    bool *visited,int state){\n  if (visited[state])return false;\n  visited[state]=true;\n  if (!check_valid(n,player,used)){\n    return false;\n  }\n\n  if (is_complete(n,player,used)){\n    //    cout << ans <<\" \" << cnt << endl;\n    //rep(i,size)cout << used[i];\n    //    cout << endl;\n    //cout << ans <<\" \" << cnt <<\" \"<< require_last(n,player-1,used)<<endl;\n    ans=min(ans,cnt+require_last(n,player-1,used));\n    return true;\n  }\n\n  rep(i,size){\n    if (used[array[i]])continue;\n    used[array[i]]=true;\n    if (search(n,player,size,array,cnt+1,used,visited,state|(1<<i))){\n      used[array[i]]=false;\n      return true;\n    }\n    used[array[i]]=false;\n  }\n  return false;\n}\n\nint array[100];\nbool used[200];\nbool visited[(1<<16)];\nvoid search2(int n,int player,int now){\n  if (now+1 == player){\n    int p=0;\n    rep(i,100){\n      if (ischoosed[i]){\n\tarray[p++]=i;\n\tused[i]=false;\n      }\n    }\n\n    //    cout << p << endl;\n    rep(i,(1<<p))visited[i]=false;\n    \n    /*\n    rep(i,p){\n      used[array[i]]=true;\n    }\n    if (p + require_last(n,player-1,used)> ans)return;\n    rep(i,p){\n      used[array[i]]=false;\n    }\n    */\n\n    /*    \n      cout <<\"size \"<< p << endl;\n      rep(i,p){\n\tcout << array[i] <<\" \";\n      }\n      cout << endl;\n    */\n    \n    search(n,player,p,array,0,used,visited,0);\n    return;\n  }\n\n  int lim = n==3?8:10;\n  rep(i,lim){\n    rep(j,n){\n      if (check[num[now][i][j]] == -1){\n\tischoosed[num[now][i][j]]=true;\n\tcheck[num[now][i][j]]=now;\n      }\n    }\n    \n    search2(n,player,now+1);\n    \n    rep(j,n){\n      if (check[num[now][i][j]] == now){\n\tcheck[num[now][i][j]]=-1;\n\tischoosed[num[now][i][j]]=false;\n      }\n    }\n  }\n  return;\n}\n\n\n\nmain(){\n  int player,n;\n  while(cin>>player>>n && player){\n    rep(k,player){\n      rep(i,n){\n\trep(j,n){\n\t  cin>>bingo[k][i][j];\n\t}\n      }\n    }\n\n    rep(i,100){\n      ischoosed[i]=false;\n      check[i]=-1;\n    }\n\n    rep(k,player){\n      make_table(n,k);\n    }\n\n    ans = 100;\n    search2(n,player,0);\n    if (ans == 100)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nbool ischoosed[100];\nint  check[100];\nint bingo[4][4][4];\n\nbool isbingo(int n,int p){\n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!ischoosed[bingo[p][i][j]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  \n  rep(i,n){\n    bool isbingo=true;\n    rep(j,n){\n      if (!ischoosed[bingo[p][j][i]])isbingo=false;\n    }\n    if (isbingo)return true;\n  }\n  \n  bool isbingo=true;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][i]])isbingo=false;\n  }\n \n  if (isbingo)return true;\n  isbingo=true;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][n-1-i]])isbingo = false;\n  }\n  return false;\n}\n\nbool check_valid(int n,int player){\n  bool isok=true;\n  rep(i,player){\n    if (isbingo(n,i)){\n      if (!isok)return false;\n    }else isok=false;\n  }\n  return true;\n}\n\nint ans;\n\nbool is_complete(int n,int player){\n  rep(i,player){\n    if (!isbingo(n,i))return false;\n  }\n  return true;\n}\n\nint need_for_single_bingo(int n,int p){\n  int maxi=0;\n  rep(i,n){\n    int tmp=0;\n    rep(j,n){\n      if (!ischoosed[bingo[p][i][j]])tmp++;\n    }\n    maxi=max(tmp,maxi);\n  }\n  \n  rep(i,n){\n    int tmp=0;\n    rep(j,n){\n      if (!ischoosed[bingo[p][j][i]])tmp++;\n    }\n    maxi=max(tmp,maxi);\n  }\n  \n  int tmp=0;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][i]])tmp++;\n  }\n  maxi=max(tmp,maxi);\n\n  tmp=0;\n  rep(i,n){\n    if (!ischoosed[bingo[p][i][n-1-i]])tmp++;\n  }\n  maxi=max(tmp,maxi);\n  return maxi;\n}\n\nint require(int n,int player){\n  int maxi=0;\n  rep(i,player){\n    maxi=max(maxi,need_for_single_bingo(n,i));\n  }\n  return maxi;\n}\n\nbool search(int n,int player,vector<int> &num,int cnt){\n  if (!check_valid(n,player))return false;\n  if (is_complete(n,player)){\n    ans=min(ans,cnt);\n    return true;\n  }\n\n  //if (require(n,player)+cnt > ans)return false;\n  if (cnt == ans)return false;\n  \n  rep(i,num.size()){\n    if (ischoosed[num[i]])continue;\n    ischoosed[num[i]]=true;\n    if (check_valid(n,player)){\n      if (search(n,player,num,cnt+1))return true;\n    }\n    ischoosed[num[i]]=false;\n  }\n  return false;\n}\n\n\nmain(){\n  int player,n;\n  while(cin>>player>>n && player){\n    map<int,int> M;\n    rep(k,player){\n      rep(i,n){\n\trep(j,n){\n\t  cin>>bingo[k][i][j];\n\t  M[bingo[k][i][j]]++;\n\t}\n      }\n    }\n    rep(i,100){\n      ischoosed[i]=false;\n      check[i]=-1;\n    }\n\n    vector<pair<int,int> > tmp;\n    map<int,int>::iterator itr = M.begin();\n    while(itr != M.end()){\n      pair<int,int> a;\n      a.first=(*itr).second;\n      a.second=(*itr).first;\n      tmp.pb(a);\n      itr++;\n    }\n    \n    vector<int> num;\n    sort(ALL(tmp),greater<pair<int,int> >());\n    rep(i,tmp.size()){\n      num.pb(tmp[i].second);\n    }\n    \n    //ans = n*player;\n    ans =0;\n    rep(i,n*player+1){\n      if (search(n,player,num,0)){\n\tbreak;\n      }\n      ans++;\n    }\n    if (ans == n*player+1)cout << 0 << endl;\n    else cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint n, m;\n\nint bingo[4][4][4];\nbool hit[4][4][4];\nint nums[4 * 4];\nint ans;\n\nbool bingoCheck(bool hit[4][4]){\n  // tate\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) cnt += hit[j][i];\n    if(cnt == m) return true;\n  }\n  // yoko\n  REP(i,m){\n    int cnt = 0;\n    REP(j,m) cnt += hit[i][j];\n    if(cnt == m) return true;\n  }\n  {\n    // naname1\n    int cnt = 0;\n    REP(i,m) cnt += hit[i][i];\n    if(cnt == m) return true;\n  }\n  {\n    // naname2\n    int cnt = 0;\n    REP(i,m) cnt += hit[i][m - i - 1];\n    if(cnt == m) return true;\n  }\n  return false;\n}\n\nvoid bingoGo(int num, bool which){\n  REP(i,n) REP(j,m) REP(k,m) if(bingo[i][j][k] == num)\n    hit[i][j][k] = which;\n}\n\nvoid check(){\n  set<int> s;\n\n  REP(p,n) sort(&nums[p * m], &nums[(p + 1) * m]);\n\n  REP(p,n){\n    bool ok = false;\n\n    do{\n      REP(i,m) if(s.count(nums[p * m + i]) == 0){\n\tbingoGo(nums[p * m + i], true);\n\n\tREP(j,n - 1) if(!bingoCheck(hit[j]) && bingoCheck(hit[j + 1])){\n\t  REP(k, i + 1)\n\t    bingoGo(nums[p * m + k], false);\n\t  goto next;\n\t}\n      }\n      ok = true;\n      break;\n    next:;\n    }while(next_permutation(&nums[p * m], &nums[(p + 1) * m]));\n\n    if(!ok) return;\n    REP(i,m) s.insert(nums[p * m + i]);\n  }\n\n  ans = min<int>(ans, s.size());\n}\n\nvoid solve(int pos){\n  if(pos == n){\n    // REP(i,n*m) printf(\"%d \", nums[i]); puts(\"\");\n    check();\n    return;\n  }\n\n  // tate\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][j][i];\n    }\n    solve(pos + 1);\n  }\n\n  // yoko\n  REP(i,m){\n    REP(j,m){\n      nums[pos * m + j] = bingo[pos][i][j];\n    }\n    solve(pos + 1);\n  }\n\n  // naname1\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][i][i];\n  }\n  solve(pos + 1);\n\n  // naname2\n  REP(i,m){\n    nums[pos * m + i] = bingo[pos][m - i - 1][i];\n  }\n  solve(pos + 1);\n}\n\nint main(){\n  while(true){\n    n = getInt();\n    m = getInt();\n\n    if(n + m == 0) break;\n\n    REP(i,n){\n      REP(j,m) REP(k,m)\n\tbingo[i][j][k] = getInt();\n    }\n\n\n    ans = 1000;\n    solve(0);\n    if(ans == 1000) ans = 0;\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bingo\npublic class Main{\n\n\tint P, M, res, N;\n\tint[][][] a;\n\tint[][][] nums;\n\tint[] s, num;\n\tboolean[] used;\n\t\n\tboolean enableCheck(int i){\n\t\tint r = 0;\n\t\tfor(int j=i+1;j<P;j++){\n\t\t\tboolean hit = false;\n\t\t\tfor(int y=0;y<2*(M+1);y++){\n\t\t\t\tboolean e = true;\n\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\tboolean exist = false;\n\t\t\t\t\tfor(int l=0;l<M;l++)if(nums[i][s[i]][k]==nums[j][y][l])exist = true;\n\t\t\t\t\tif(!exist)e = false;\n\t\t\t\t}\n\t\t\t\tif(e){\n\t\t\t\t\thit = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(r==0 && !hit)r = 1;\n\t\t\telse if(r==1 && hit)r = 2;\n\t\t}\n//\t\tSystem.out.println(\"R:\"+r);\n\t\treturn r!=2;\n\t}\n\t\n\tvoid select(int k){\n\t\tif(k==P){\n\t\t\tN = 0;\n\t\t\tArrays.fill(used, false);\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++){\n\t\t\t\tint x = nums[i][s[i]][j];\n\t\t\t\tif(!used[x]){\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tnum[N++] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res<=N)return;\n//\t\t\tdebug(s);\n\t\t\tif(P==4 && !enableCheck(0)){\n//\t\t\t\tSystem.out.println(\"Cut\");\n//\t\t\t\treturn;\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\t\t\tif(f(0))res = N;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<2*(M+1);i++){\n\t\t\ts[k] = i;\n\t\t\tselect(k+1);\n\t\t}\n\t}\n\t\n\tint state(){\n\t\tint r = 0;\n\t\tfor(int i=0;i<P;i++){\n\t\t\tboolean b = bingo(i);\n\t\t\tif(r==0 && !b)r = 1;\n\t\t\telse if(r==1 && b)r = 2;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tboolean bingo(int i){\n\t\tfor(int j=0;j<2*(M+1);j++){\n\t\t\tboolean ok = true;\n\t\t\tfor(int k=0;k<M;k++)if(!used[nums[i][j][k]])ok = false;\n\t\t\tif(ok)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean f(int k){\n\t\tif(k==N){\n\t\t\treturn true;\n\t\t}\n\t\tif(state()==2)return false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(used[num[i]])continue;\n\t\t\tused[num[i]] = true;\n\t\t\tif(f(k+1))return true;\n\t\t\tused[num[i]] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tused = new boolean[100];\n\t\tnum = new int[20];\n\t\ts = new int[4];\n\t\tfor(;;){\n\t\t\tP = sc.nextInt(); M = sc.nextInt();\n\t\t\tif((P|M)==0)break;\n\t\t\ta = new int[P][M][M];\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)a[i][j][k]=sc.nextInt();\n\t\t\tnums = new int[P][2*(M+1)][M];\n\t\t\tfor(int i=0;i<P;i++){\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\t\tnums[i][j][k] = a[i][k][j];\n\t\t\t\t\t\tnums[i][j+M][k] = a[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][2*M][j] = a[i][j][j];\n\t\t\t\t\tnums[i][2*M+1][j] = a[i][j][M-1-j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 100;\n\t\t\tselect(0);\n\t\t\tSystem.out.println(res%100);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bingo\npublic class Main{\n\n\tint P, M, res, N;\n\tint[][][] a;\n\tint[][][] nums;\n\tint[] s, num;\n\tboolean[] used;\n\t\n\tboolean enableCheck(int i){\n\t\tint r = 0;\n\t\tfor(int j=i+1;j<P;j++){\n\t\t\tboolean hit = false;\n\t\t\tfor(int y=0;y<2*(M+1);y++){\n\t\t\t\tboolean e = true;\n\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\tboolean exist = false;\n\t\t\t\t\tfor(int l=0;l<M;l++)if(nums[i][s[i]][k]==nums[j][y][l])exist = true;\n\t\t\t\t\tif(!exist)e = false;\n\t\t\t\t}\n\t\t\t\tif(e){\n\t\t\t\t\thit = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(r==0 && !hit)r = 1;\n\t\t\telse if(r==1 && hit)r = 2;\n\t\t}\n//\t\tSystem.out.println(\"R:\"+r);\n\t\treturn r!=2;\n\t}\n\t\n\tvoid select(int k){\n\t\tif(k==P){\n\t\t\tN = 0;\n\t\t\tArrays.fill(used, false);\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++){\n\t\t\t\tint x = nums[i][s[i]][j];\n\t\t\t\tif(!used[x]){\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tnum[N++] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res<=N)return;\n//\t\t\tdebug(s);\n\t\t\tif(!enableCheck(0) || P==4&&!enableCheck(1)){\n//\t\t\t\tSystem.out.println(\"Cut\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\t\t\tif(f(0))res = N;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<2*(M+1);i++){\n\t\t\ts[k] = i;\n\t\t\tselect(k+1);\n\t\t}\n\t}\n\t\n\tint state(){\n\t\tint r = 0;\n\t\tfor(int i=0;i<P;i++){\n\t\t\tboolean b = bingo(i);\n\t\t\tif(r==0 && !b)r = 1;\n\t\t\telse if(r==1 && b)r = 2;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tboolean bingo(int i){\n\t\tfor(int j=0;j<2*(M+1);j++){\n\t\t\tboolean ok = true;\n\t\t\tfor(int k=0;k<M;k++)if(!used[nums[i][j][k]])ok = false;\n\t\t\tif(ok)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean f(int k){\n\t\tif(k==N){\n\t\t\treturn true;\n\t\t}\n\t\tif(state()==2)return false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(used[num[i]])continue;\n\t\t\tused[num[i]] = true;\n\t\t\tif(f(k+1))return true;\n\t\t\tused[num[i]] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tused = new boolean[100];\n\t\tnum = new int[20];\n\t\ts = new int[4];\n\t\tfor(;;){\n\t\t\tP = sc.nextInt(); M = sc.nextInt();\n\t\t\tif((P|M)==0)break;\n\t\t\ta = new int[P][M][M];\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)a[i][j][k]=sc.nextInt();\n\t\t\tnums = new int[P][2*(M+1)][M];\n\t\t\tfor(int i=0;i<P;i++){\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\t\tnums[i][j][k] = a[i][k][j];\n\t\t\t\t\t\tnums[i][j+M][k] = a[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][2*M][j] = a[i][j][j];\n\t\t\t\t\tnums[i][2*M+1][j] = a[i][j][M-1-j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 100;\n\t\t\tselect(0);\n\t\t\tSystem.out.println(res%100);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bingo\npublic class Main{\n\n\tint p, m, min;\n\tint[][] a;\n\tint[][] m3 = {{0,1,2}, {3,4,5},{6,7,8},{0,3,6},{1,4,7},{2,5,8},{0,4,8},{2,4,6}};\n\tint[][] m4 = {{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15},{0,4,8,12},{1,5,9,13},{2,6,10,14},{3,7,11,15},{0,5,10,15},{3,6,9,12}};\n\tint mask3[] = {0x0007, 0x0038, 0x01c0, 0x0049, 0x0092, 0x0124, 0x0111, 0x0054};\n\tint mask4[] = {0x000f, 0x00f0, 0x0f00, 0xf000, 0x1111, 0x2222, 0x4444, 0x8888, 0x8421, 0x1248};\n\tint[] order, last;\n\t\n\tboolean bingo(int k){\n\t\tint res = 0;\n\t\tfor(int i=0;i<m*m;i++)if(mark[a[k][i]])res|=1<<i;\n\t\tif(m==3){\n\t\t\tfor(int i=0;i<mask3.length;i++)if((res&mask3[i])==mask3[i])return true;\n\t\t}\n\t\telse {\n\t\t\tfor(int i=0;i<mask4.length;i++)if((res&mask4[i])==mask4[i])return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean[] mark;\n\t\n\tboolean f(int k){\n\t\tif(k==p){\n\t\t\tArrays.fill(mark, false);\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tif(m==3){\n\t\t\t\t\tfor(int j=0;j<m;j++)if(last[i]!=m3[order[i]][j])mark[a[i][m3[order[i]][j]]]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=0;j<m;j++)if(last[i]!=m4[order[i]][j])mark[a[i][m4[order[i]][j]]]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<p;i++)if(bingo(i))return false;\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tmark[a[i][last[i]]] = true;\n\t\t\t\tfor(int j=i+1;j+1<p;j++)if(!bingo(j)&&bingo(j+1))return false;;\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tfor(boolean x:mark)if(x)c++;\n\t\t\tmin = Math.min(min, c);\n//\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tlast[k] = m==3?m3[order[k]][i]:m4[order[k]][i];\n\t\t\tif(f(k+1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid dfs(int k){\n\t\tif(k==p){\n\t\t\tf(0);\n\t\t\treturn;\n\t\t}\n\t\tif(m==3)for(int i=0;i<m3.length;i++){\n\t\t\torder[k] = i; \n\t\t\tdfs(k+1);\n\t\t}\n\t\telse for(int i=0;i<m4.length;i++){\n\t\t\torder[k] = i;\n\t\t\tdfs(k+1);\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tp = sc.nextInt(); m = sc.nextInt();\n\t\t\tif((p|m)==0)break;\n\t\t\ta = new int[p][m*m];\n\t\t\tfor(int i=0;i<p;i++)for(int j=0;j<m*m;j++)a[i][j]=sc.nextInt();\n\t\t\torder = new int[p];\n\t\t\tlast = new int[p];\n\t\t\tmin = 1<<29;\n\t\t\tmark = new boolean[101];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(min==1<<29?0:min);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Bingo\npublic class Main{\n\n\tint P, M, res, N;\n\tint[][][] a;\n\tint[][][] nums;\n\tint[] s, num;\n\tboolean[] used;\n\t\n\tboolean enableCheck(int i){\n\t\tint r = 0;\n\t\tfor(int j=i+1;j<P;j++){\n\t\t\tboolean hit = false;\n\t\t\tfor(int y=0;y<2*(M+1);y++){\n\t\t\t\tboolean e = true;\n\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\tboolean exist = false;\n\t\t\t\t\tfor(int l=0;l<M;l++)if(nums[i][s[i]][k]==nums[j][y][l])exist = true;\n\t\t\t\t\tif(!exist)e = false;\n\t\t\t\t}\n\t\t\t\tif(e){\n\t\t\t\t\thit = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(r==0 && !hit)r = 1;\n\t\t\telse if(r==1 && hit)r = 2;\n\t\t}\n//\t\tSystem.out.println(\"R:\"+r);\n\t\treturn r!=2;\n\t}\n\t\n\tvoid select(int k){\n\t\tif(k==P){\n\t\t\tN = 0;\n\t\t\tArrays.fill(used, false);\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++){\n\t\t\t\tint x = nums[i][s[i]][j];\n\t\t\t\tif(!used[x]){\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tnum[N++] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res<=N)return;\n//\t\t\tdebug(s);\n\t\t\tif(!enableCheck(0)){\n//\t\t\t\tSystem.out.println(\"Cut\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tArrays.fill(used, false);\n\t\t\tif(f(0))res = N;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<2*(M+1);i++){\n\t\t\ts[k] = i;\n\t\t\tselect(k+1);\n\t\t}\n\t}\n\t\n\tint state(){\n\t\tint r = 0;\n\t\tfor(int i=0;i<P;i++){\n\t\t\tboolean b = bingo(i);\n\t\t\tif(r==0 && !b)r = 1;\n\t\t\telse if(r==1 && b)r = 2;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tboolean bingo(int i){\n\t\tfor(int j=0;j<2*(M+1);j++){\n\t\t\tboolean ok = true;\n\t\t\tfor(int k=0;k<M;k++)if(!used[nums[i][j][k]])ok = false;\n\t\t\tif(ok)return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean f(int k){\n\t\tif(k==N){\n\t\t\treturn state()==0;\n\t\t}\n\t\tif(state()==2)return false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(used[num[i]])continue;\n\t\t\tused[num[i]] = true;\n\t\t\tif(f(k+1))return true;\n\t\t\tused[num[i]] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tused = new boolean[100];\n\t\tnum = new int[20];\n\t\ts = new int[4];\n\t\tfor(;;){\n\t\t\tP = sc.nextInt(); M = sc.nextInt();\n\t\t\tif((P|M)==0)break;\n\t\t\ta = new int[P][M][M];\n\t\t\tfor(int i=0;i<P;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)a[i][j][k]=sc.nextInt();\n\t\t\tnums = new int[P][2*(M+1)][M];\n\t\t\tfor(int i=0;i<P;i++){\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\t\tnums[i][j][k] = a[i][k][j];\n\t\t\t\t\t\tnums[i][j+M][k] = a[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t\tnums[i][2*M][j] = a[i][j][j];\n\t\t\t\t\tnums[i][2*M+1][j] = a[i][j][M-1-j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 100;\n\t\t\tselect(0);\n\t\t\tSystem.out.println(res%100);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from itertools import product\n    from sys import stdin\n    f_i = stdin\n    \n    while True:\n        P, M = map(int, f_i.readline().split())\n        if P == 0:\n            break\n        \n        bingo = []\n        for i in range(P):\n            b = []\n            card = list(map(int, f_i.readline().split()))\n            d1 = [] # diagonally\n            d2 = [] # diagonally\n            for i in range(M):\n                b.append(card[i::M]) # vertically\n                b.append(card[i*M:i*M+M]) # horizontally\n                d1.append(card[i*M+i])\n                d2.append(card[(M-1)*(i+1)])\n            \n            b += [d1, d2]\n            bingo.append(set(frozenset(b_i) for b_i in b))\n        if P == 2:\n            ans = min(len(t1 | t2) for t1, t2 in product(*bingo))\n        elif P == 3:\n            ans = P * M + 1\n            c0, c1, c2 = bingo\n            for b0 in c0:\n                if b0 in c2:\n                    for b1 in c1:\n                        if b1.intersection(b0):\n                            break\n                    else:\n                        continue\n                \n                for b1 in c1:\n                    b01 = b0.union(b1)\n                    last = set(b for b in c2 if b.issubset(b01))\n                    if last:\n                        if not b1.intersection(*last):\n                            continue\n                    for b2 in c2:\n                        tmp = len(b2.union(b01))\n                        if tmp < ans:\n                            ans = tmp\n            if ans == P * M + 1:\n                ans = 0\n        else:\n            ans = P * M + 1\n            c0, c1, c2, c3 = bingo\n            for b0 in c0:\n                if b0 in c2:\n                    for b1 in c1:\n                        if b1.intersection(b0):\n                            break\n                    else:\n                        continue\n                \n                if b0 in c3:\n                    for b1, b2 in product(c1, c2):\n                        if b0.intersection(b1, b2):\n                            break\n                    else:\n                        continue\n                for b1 in c1:\n                    b01 = b0.union(b1)\n                    third = set(b2 for b2 in c2 if b2.issubset(b01))\n                    if third:\n                        if not b1.intersection(*third):\n                            continue\n                    \n                    last = set(b3 for b3 in c3 if b3.issubset(b01))\n                    if last:\n                        if not b1.intersection(*last):\n                            continue\n                    \n                    if third and last:\n                        if not b1.intersection(*third, *last):\n                            continue\n                    \n                    if not third and last:\n                        for b2, b3 in product(c2, last):\n                            if b1.intersection(b2, b3):\n                                break\n                        else:\n                            continue\n                    for b2 in c2:\n                        b012 = b0.union(b1, b2)\n                        last = set(b for b in c3 if b.issubset(b012))\n                        if last:\n                            last_num = b2.intersection(*last)\n                            if not last_num:\n                                continue\n                            \n                            first = set(b for b in c0 if b.issubset(b012))\n                            if first.issubset(last):\n                                sec = set(b for b in c1 if b.issubset(b012))\n                                if not last_num.intersection(*sec):\n                                    continue\n                        for b3 in c3:\n                            tmp = len(b012.union(b3))\n                            if tmp < ans:\n                                ans = tmp\n            if ans == P * M + 1:\n                ans = 0\n        \n        print(ans)\n\nsolve()\n"
  }
]