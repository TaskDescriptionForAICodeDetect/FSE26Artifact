[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_M 10\n#define MAX_PLAYERS 100\n\ntypedef struct {\n    int card[MAX_M][MAX_M];\n    int size;\n} BingoCard;\n\nint check_bingo(BingoCard *card, int *called, int called_size) {\n    int size = card->size;\n    int row_count, col_count, diag1 = 1, diag2 = 1;\n    \n    for (int i = 0; i < size; i++) {\n        row_count = 1;\n        col_count = 1;\n        for (int j = 0; j < size; j++) {\n            int found_row = 0, found_col = 0;\n            for (int k = 0; k < called_size; k++) {\n                if (card->card[i][j] == called[k]) found_row = 1;\n                if (card->card[j][i] == called[k]) found_col = 1;\n            }\n            if (!found_row) row_count = 0;\n            if (!found_col) col_count = 0;\n        }\n        if (row_count || col_count) return 1;\n    }\n    \n    for (int i = 0; i < size; i++) {\n        int found1 = 0, found2 = 0;\n        for (int k = 0; k < called_size; k++) {\n            if (card->card[i][i] == called[k]) found1 = 1;\n            if (card->card[i][size - 1 - i] == called[k]) found2 = 1;\n        }\n        if (!found1) diag1 = 0;\n        if (!found2) diag2 = 0;\n    }\n    if (diag1 || diag2) return 1;\n    \n    return 0;\n}\n\nvoid find_min_sequence(BingoCard *cards, int num_players, int *min_sequence, int *min_length) {\n    int called[MAX_M * MAX_M * MAX_PLAYERS];\n    int called_size = 0;\n    *min_length = INT_MAX;\n    \n    for (int i = 0; i < num_players; i++) {\n        for (int j = 0; j < cards[i].size; j++) {\n            for (int k = 0; k < cards[i].size; k++) {\n                called[called_size++] = cards[i].card[j][k];\n                int valid = 1;\n                for (int p = 0; p < num_players; p++) {\n                    int bingo = check_bingo(&cards[p], called, called_size);\n                    if ((p < i && !bingo) || (p > i && bingo)) {\n                        valid = 0;\n                        break;\n                    }\n                }\n                if (valid && called_size < *min_length) {\n                    *min_length = called_size;\n                    for (int m = 0; m < called_size; m++) {\n                        min_sequence[m] = called[m];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    BingoCard cards[MAX_PLAYERS];\n    \n    for (int i = 0; i < N; i++) {\n        cards[i].size = M;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k < M; k++) {\n                scanf(\"%d\", &cards[i].card[j][k]);\n            }\n        }\n    }\n    \n    int min_sequence[MAX_M * MAX_M * MAX_PLAYERS];\n    int min_length;\n    \n    find_min_sequence(cards, N, min_sequence, &min_length);\n    \n    printf(\"%d\\n\", min_length);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <unordered_map>\nusing namespace std;\n\nbool isBingo(const vector<vector<int>>& card, const set<int>& punched, int M) {\n    // Check rows\n    for (int i = 0; i < M; ++i) {\n        bool complete = true;\n        for (int j = 0; j < M; ++j) {\n            if (punched.find(card[i][j]) == punched.end()) {\n                complete = false;\n                break;\n            }\n        }\n        if (complete) return true;\n    }\n\n    // Check columns\n    for (int j = 0; j < M; ++j) {\n        bool complete = true;\n        for (int i = 0; i < M; ++i) {\n            if (punched.find(card[i][j]) == punched.end()) {\n                complete = false;\n                break;\n            }\n        }\n        if (complete) return true;\n    }\n\n    // Check main diagonal\n    bool complete = true;\n    for (int i = 0; i < M; ++i) {\n        if (punched.find(card[i][i]) == punched.end()) {\n            complete = false;\n            break;\n        }\n    }\n    if (complete) return true;\n\n    // Check anti-diagonal\n    complete = true;\n    for (int i = 0; i < M; ++i) {\n        if (punched.find(card[i][M - 1 - i]) == punched.end()) {\n            complete = false;\n            break;\n        }\n    }\n    if (complete) return true;\n\n    return false;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<vector<int>>> players(N, vector<vector<int>>(M, vector<int>(M)));\n    unordered_map<int, vector<pair<int, int>>> numToPlayerPos;\n\n    for (int p = 0; p < N; ++p) {\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < M; ++j) {\n                cin >> players[p][i][j];\n                numToPlayerPos[players[p][i][j]].emplace_back(p, i * M + j);\n            }\n        }\n    }\n\n    vector<set<int>> playerNumbers(N);\n    vector<vector<bool>> punched(N, vector<bool>(M * M, false));\n    vector<bool> hasBingo(N, false);\n    set<int> sequence;\n\n    for (int p = 0; p < N; ++p) {\n        bool found = false;\n        for (const auto& entry : numToPlayerPos) {\n            int num = entry.first;\n            for (const auto& pos : entry.second) {\n                int current_p = pos.first;\n                if (current_p == p) {\n                    sequence.insert(num);\n                    punched[current_p][pos.second] = true;\n                }\n            }\n            set<int> tempPunched;\n            for (int num : sequence) {\n                tempPunched.insert(num);\n            }\n            if (isBingo(players[p], tempPunched, M)) {\n                hasBingo[p] = true;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            // If not found, need to cover all numbers in the player's card\n            for (int i = 0; i < M; ++i) {\n                for (int j = 0; j < M; ++j) {\n                    sequence.insert(players[p][i][j]);\n                }\n            }\n            hasBingo[p] = true;\n        }\n    }\n\n    cout << sequence.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BingoGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        scanner.nextLine();\n\n        List<int[][]> players = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int[][] card = new int[M][M];\n            for (int j = 0; j < M; j++) {\n                for (int k = 0; k < M; k++) {\n                    card[j][k] = scanner.nextInt();\n                }\n                scanner.nextLine();\n            }\n            players.add(card);\n        }\n\n        Map<Integer, List<int[]>> numberToPositions = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            int[][] card = players.get(i);\n            for (int row = 0; row < M; row++) {\n                for (int col = 0; col < M; col++) {\n                    int num = card[row][col];\n                    numberToPositions.computeIfAbsent(num, k -> new ArrayList<>()).add(new int[]{i, row, col});\n                }\n            }\n        }\n\n        int[] rowCount = new int[N * M];\n        int[] colCount = new int[N * M];\n        int[] diag1Count = new int[N * M];\n        int[] diag2Count = new int[N * M];\n        boolean[] hasBingo = new boolean[N];\n        int bingoCount = 0;\n        int sequenceLength = 0;\n\n        List<Integer> sequence = new ArrayList<>();\n        for (int num : numberToPositions.keySet()) {\n            sequence.add(num);\n        }\n\n        for (int num : sequence) {\n            sequenceLength++;\n            for (int[] pos : numberToPositions.get(num)) {\n                int player = pos[0];\n                int row = pos[1];\n                int col = pos[2];\n                if (hasBingo[player]) continue;\n\n                int playerRow = player * M + row;\n                rowCount[playerRow]++;\n                if (rowCount[playerRow] == M) {\n                    hasBingo[player] = true;\n                    bingoCount++;\n                }\n\n                int playerCol = player * M + col;\n                colCount[playerCol]++;\n                if (colCount[playerCol] == M) {\n                    hasBingo[player] = true;\n                    bingoCount++;\n                }\n\n                if (row == col) {\n                    int playerDiag1 = player * M;\n                    diag1Count[playerDiag1]++;\n                    if (diag1Count[playerDiag1] == M) {\n                        hasBingo[player] = true;\n                        bingoCount++;\n                    }\n                }\n\n                if (row + col == M - 1) {\n                    int playerDiag2 = player * M + 1;\n                    diag2Count[playerDiag2]++;\n                    if (diag2Count[playerDiag2] == M) {\n                        hasBingo[player] = true;\n                        bingoCount++;\n                    }\n                }\n            }\n\n            boolean correctOrder = true;\n            for (int i = 0; i < N; i++) {\n                if (!hasBingo[i]) {\n                    for (int j = i + 1; j < N; j++) {\n                        if (hasBingo[j]) {\n                            correctOrder = false;\n                            break;\n                        }\n                    }\n                    if (!correctOrder) break;\n                }\n            }\n\n            if (correctOrder && bingoCount == N) {\n                System.out.println(sequenceLength);\n                return;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:49:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BingoGame {\n    public static int findMinSequenceLength(int[][] players) {\n        int m = players[0].length;\n        int n = players.length;\n        int[][] positions = new int[n][m * m + 1];\n        \n        for (int p = 0; p < n; p++) {\n            for (int r = 0; r < m; r++) {\n                for (int c = 0; c < m; c++) {\n                    positions[p][players[p][r * m + c]] = r * m + c;\n                }\n            }\n        }\n        \n        int[] minSequence = new int[n];\n        Arrays.fill(minSequence, Integer.MAX_VALUE);\n        \n        for (int sequence = 1; sequence <= m * m; sequence++) {\n            for (int p = 0; p < n; p++) {\n                boolean hasBingo = checkBingo(players[p], positions[p], sequence);\n                \n                if (hasBingo) {\n                    for (int j = 0; j < p; j++) {\n                        if (minSequence[j] > sequence) {\n                            return -1;\n                        }\n                    }\n                    minSequence[p] = sequence;\n                    break;\n                }\n            }\n        }\n        \n        return minSequence[n - 1];\n    }\n    \n    private static boolean checkBingo(int[] card, int[] positions, int sequence) {\n        int m = (int) Math.sqrt(card.length);\n        boolean[] marked = new boolean[card.length];\n        \n        for (int i = 0; i < card.length; i++) {\n            if (positions[card[i]] < sequence) {\n                marked[i] = true;\n            }\n        }\n        \n        // Check horizontal lines\n        for (int r = 0; r < m; r++) {\n            boolean lineComplete = true;\n            for (int c = 0; c < m; c++) {\n                if (!marked[r * m + c]) {\n                    lineComplete = false;\n                    break;\n                }\n            }\n            if (lineComplete) return true;\n        }\n        \n        // Check vertical lines\n        for (int c = 0; c < m; c++) {\n            boolean lineComplete = true;\n            for (int r = 0; r < m; r++) {\n                if (!marked[r * m + c]) {\n                    lineComplete = false;\n                    break;\n                }\n            }\n            if (lineComplete) return true;\n        }\n        \n        // Check main diagonal\n        boolean mainDiagonalComplete = true;\n        for (int i = 0; i < m; i++) {\n            if (!marked[i * m + i]) {\n                mainDiagonalComplete = false;\n                break;\n            }\n        }\n        if (mainDiagonalComplete) return true;\n        \n        // Check anti-diagonal\n        boolean antiDiagonalComplete = true;\n        for (int i = 0; i < m; i++) {\n            if (!marked[i * m + (m - 1 - i)]) {\n                antiDiagonalComplete = false;\n                break;\n            }\n        }\n        return antiDiagonalComplete;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int[][] players = {\n            {1, 2, 3, 4, 5, 6, 7, 8, 9},\n            {9, 8, 7, 6, 5, 4, 3, 2, 1}\n        };\n        \n        int result = findMinSequenceLength(players);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 20:50:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PLAYERS 10\n#define MAX_BOARD_SIZE 10\n\nint m, n;  // m is board size, n is number of players\nint boards[MAX_PLAYERS][MAX_BOARD_SIZE][MAX_BOARD_SIZE];\nint minSequenceLength = 0;\n\nbool checkBingo(int player) {\n    // Check horizontal lines\n    for (int row = 0; row < m; row++) {\n        bool lineComplete = true;\n        for (int col = 0; col < m; col++) {\n            if (boards[player][row][col] != -1) {\n                lineComplete = false;\n                break;\n            }\n        }\n        if (lineComplete) return true;\n    }\n\n    // Check vertical lines\n    for (int col = 0; col < m; col++) {\n        bool lineComplete = true;\n        for (int row = 0; row < m; row++) {\n            if (boards[player][row][col] != -1) {\n                lineComplete = false;\n                break;\n            }\n        }\n        if (lineComplete) return true;\n    }\n\n    // Check main diagonal\n    bool mainDiagonalComplete = true;\n    for (int i = 0; i < m; i++) {\n        if (boards[player][i][i] != -1) {\n            mainDiagonalComplete = false;\n            break;\n        }\n    }\n    if (mainDiagonalComplete) return true;\n\n    // Check anti-diagonal\n    bool antiDiagonalComplete = true;\n    for (int i = 0; i < m; i++) {\n        if (boards[player][i][m-1-i] != -1) {\n            antiDiagonalComplete = false;\n            break;\n        }\n    }\n    if (antiDiagonalComplete) return true;\n\n    return false;\n}\n\nvoid markNumber(int number) {\n    for (int player = 0; player < n; player++) {\n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < m; col++) {\n                if (boards[player][row][col] == number) {\n                    boards[player][row][col] = -1;\n                }\n            }\n        }\n    }\n}\n\nvoid solve() {\n    scanf(\"%d %d\", &m, &n);\n\n    // Read player boards\n    for (int player = 0; player < n; player++) {\n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < m; col++) {\n                scanf(\"%d\", &boards[player][row][col]);\n            }\n        }\n    }\n\n    // Read available numbers\n    int numbers[m * m * 2];\n    int k;\n    scanf(\"%d\", &k);\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    // Try different sequence lengths\n    for (int seqLen = 1; seqLen <= k; seqLen++) {\n        // Reset board\n        int tempBoards[MAX_PLAYERS][MAX_BOARD_SIZE][MAX_BOARD_SIZE];\n        memcpy(tempBoards, boards, sizeof(boards));\n\n        bool possible = true;\n        for (int winPlayer = 0; winPlayer < n; winPlayer++) {\n            bool playerWon = false;\n            \n            // Mark numbers in sequence\n            for (int numIndex = 0; numIndex < seqLen; numIndex++) {\n                markNumber(numbers[numIndex]);\n            }\n\n            // Check if current player won\n            if (checkBingo(winPlayer)) {\n                playerWon = true;\n\n                // Check previous players didn't win\n                for (int prevPlayer = 0; prevPlayer < winPlayer; prevPlayer++) {\n                    if (checkBingo(prevPlayer)) {\n                        possible = false;\n                        break;\n                    }\n                }\n            }\n\n            // Reset board for next iteration\n            memcpy(boards, tempBoards, sizeof(boards));\n\n            if (!possible) break;\n            if (!playerWon) break;\n        }\n\n        if (possible) {\n            minSequenceLength = seqLen;\n            break;\n        }\n    }\n\n    printf(\"%d\\n\", minSequenceLength);\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass BingoGame {\nprivate:\n    int M;\n    int N;\n\n    bool checkBingo(const vector<vector<int>>& card) {\n        // Check horizontal lines\n        for (int row = 0; row < M; row++) {\n            bool lineComplete = true;\n            for (int col = 0; col < M; col++) {\n                if (card[row][col] != -1) {\n                    lineComplete = false;\n                    break;\n                }\n            }\n            if (lineComplete) return true;\n        }\n\n        // Check vertical lines\n        for (int col = 0; col < M; col++) {\n            bool lineComplete = true;\n            for (int row = 0; row < M; row++) {\n                if (card[row][col] != -1) {\n                    lineComplete = false;\n                    break;\n                }\n            }\n            if (lineComplete) return true;\n        }\n\n        // Check main diagonal\n        bool mainDiagonal = true;\n        for (int i = 0; i < M; i++) {\n            if (card[i][i] != -1) {\n                mainDiagonal = false;\n                break;\n            }\n        }\n        if (mainDiagonal) return true;\n\n        // Check anti-diagonal\n        bool antiDiagonal = true;\n        for (int i = 0; i < M; i++) {\n            if (card[i][M-1-i] != -1) {\n                antiDiagonal = false;\n                break;\n            }\n        }\n        if (antiDiagonal) return true;\n\n        return false;\n    }\n\npublic:\n    BingoGame(int m, int n) : M(m), N(n) {}\n\n    int findMinSequence(vector<vector<vector<int>>>& cards) {\n        vector<bool> bingoStatus(cards.size(), false);\n        vector<int> bingoOrder;\n\n        for (int len = 1; len <= N * N; len++) {\n            for (int playerIndex = 0; playerIndex < cards.size(); playerIndex++) {\n                if (!bingoStatus[playerIndex]) {\n                    for (int row = 0; row < M; row++) {\n                        for (int col = 0; col < M; col++) {\n                            if (cards[playerIndex][row][col] == len) {\n                                cards[playerIndex][row][col] = -1;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (checkBingo(cards[playerIndex])) {\n                        bingoStatus[playerIndex] = true;\n                        bingoOrder.push_back(playerIndex);\n                    }\n                }\n            }\n\n            if (bingoOrder.size() == cards.size()) {\n                return len;\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    int M, N, K;\n    cin >> M >> N >> K;\n\n    vector<vector<vector<int>>> cards(K, vector<vector<int>>(M, vector<int>(M)));\n\n    for (int i = 0; i < K; i++) {\n        for (int row = 0; row < M; row++) {\n            for (int col = 0; col < M; col++) {\n                cin >> cards[i][row][col];\n            }\n        }\n    }\n\n    BingoGame game(M, N);\n    int result = game.findMinSequence(cards);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def get_bingo_sequence(cards):\n    def is_bingo(card):\n        # Check rows and columns\n        for i in range(len(card)):\n            if all(card[i][j] == 'X' for j in range(len(card))) or \\\n               all(card[j][i] == 'X' for j in range(len(card))):\n                return True\n        # Check diagonals\n        if all(card[i][i] == 'X' for i in range(len(card))) or \\\n           all(card[i][len(card) - 1 - i] == 'X' for i in range(len(card))):\n            return True\n        return False\n    \n    def punch_number(card, num):\n        for i in range(len(card)):\n            for j in range(len(card[i])):\n                if card[i][j] == num:\n                    card[i][j] = 'X'\n                    return card\n        return card\n\n    m = len(cards[0])\n    n = len(cards)\n    available_numbers = set()\n    for card in cards:\n        for row in card:\n            for num in row:\n                available_numbers.add(num)\n    \n    sequence = []\n    punching_order = []\n    \n    while len(sequence) < m * n * m:\n        for i in range(n):\n            if i in punching_order:\n                continue\n            temp_card = [row[:] for row in cards[i]]\n            for num in available_numbers:\n                punch_number(temp_card, num)\n                if is_bingo(temp_card):\n                    sequence.append(num)\n                    card_numbers = set(num for row in cards[i] for num in row)\n                    available_numbers -= card_numbers.intersection(set(sequence))\n                    punching_order.append(i)\n                    break\n    \n    return sequence\n\n# Example usage (you can replace with real card inputs):\ncards = [\n    [\n        ['1', '2', '3'],\n        ['4', '5', '6'],\n        ['7', '8', '9']\n    ],\n    [\n        ['9', '5', '1'],\n        ['3', '6', '8'],\n        ['7', '2', '4']\n    ]\n    # more cards...\n]\n\nprint(get_bingo_sequence(cards))",
    "timestamp": "2025-08-13 03:31:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BingoGame {\n    public static int findMinimumSequenceLength(int M, int N, int[][][] cards) {\n        List<Set<Integer>> numbersForEachPlayer = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            numbersForEachPlayer.add(new HashSet<>());\n        }\n        \n        for (int player = 0; player < N; player++) {\n            int[][] card = cards[player];\n            for (int i = 0; i < M; i++) {\n                // Check rows\n                Set<Integer> rowSet = new HashSet<>();\n                for (int j = 0; j < M; j++) {\n                    rowSet.add(card[i][j]);\n                }\n                numbersForEachPlayer.get(player).addAll(rowSet);\n\n                // Check columns\n                Set<Integer> colSet = new HashSet<>();\n                for (int j = 0; j < M; j++) {\n                    colSet.add(card[j][i]);\n                }\n                numbersForEachPlayer.get(player).addAll(colSet);\n            }\n            \n            // Check diagonals\n            Set<Integer> diagonal1 = new HashSet<>();\n            Set<Integer> diagonal2 = new HashSet<>();\n            for (int i = 0; i < M; i++) {\n                diagonal1.add(card[i][i]);\n                diagonal2.add(card[i][M - 1 - i]);\n            }\n            numbersForEachPlayer.get(player).addAll(diagonal1);\n            numbersForEachPlayer.get(player).addAll(diagonal2);\n        }\n        \n        Set<Integer> announcedNumbers = new HashSet<>();\n        int sequenceLength = 0;\n        \n        for (Set<Integer> numberSet : numbersForEachPlayer) {\n            for (int number : numberSet) {\n                if (!announcedNumbers.contains(number)) {\n                    sequenceLength++;\n                    announcedNumbers.add(number);\n                }\n            }\n        }\n        \n        return sequenceLength;\n    }\n\n    public static void main(String[] args) {\n        int M = 3; \n        int N = 2;\n\n        int[][][] cards = {\n            {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9}\n            },\n            {\n                {1, 4, 7},\n                {2, 5, 8},\n                {3, 6, 9}\n            }\n        };\n\n        System.out.println(findMinimumSequenceLength(M, N, cards));\n    }\n}",
    "timestamp": "2025-08-13 03:32:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PLAYERS 10\n#define MAX_M 10\n\ntypedef struct {\n    int numbers[MAX_M][MAX_M];\n    bool punched[MAX_M][MAX_M];\n    int bingo_position[3];\n} BingoCard;\n\nint M;\nint player_count;\nBingoCard players[MAX_PLAYERS];\n\nbool check_bingo(int player_index) {\n    for (int i = 0; i < M; ++i) {\n        bool row_bingo = true, col_bingo = true;\n        for (int j = 0; j < M; ++j) {\n            if (!players[player_index].punched[i][j]) row_bingo = false;\n            if (!players[player_index].punched[j][i]) col_bingo = false;\n        }\n        if (row_bingo || col_bingo) return true;\n    }\n    \n    bool diag1_bingo = true, diag2_bingo = true;\n    for (int i = 0; i < M; ++i) {\n        if (!players[player_index].punched[i][i]) diag1_bingo = false;\n        if (!players[player_index].punched[i][M - i - 1]) diag2_bingo = false;\n    }\n    \n    return diag1_bingo || diag2_bingo;\n}\n\nint play_until_bingo(int player_index) {\n    bool finished[MAX_PLAYERS] = { false };\n    int sequence_length = 0;\n\n    while (true) {\n        for (int p = 0; p <= player_index; ++p) {\n            if (!finished[p]) {\n                for (int i = 0; i < M; ++i) {\n                    for (int j = 0; j < M; ++j) {\n                        if (!players[p].punched[i][j]) {\n                            players[p].punched[i][j] = true;\n                            ++sequence_length;\n                            if (check_bingo(p)) {\n                                finished[p] = true;\n                                if (p == player_index) return sequence_length;\n                            }\n                            goto next_turn;\n                        }\n                    }\n                }\n            }\n\n        next_turn:;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &player_count, &M);\n    for (int p = 0; p < player_count; ++p) {\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < M; ++j) {\n                scanf(\"%d\", &players[p].numbers[i][j]);\n                players[p].punched[i][j] = false;\n            }\n        }\n    }\n\n    int total_sequence_length = 0;\n    for (int p = 0; p < player_count; ++p) {\n        total_sequence_length += play_until_bingo(p);\n    }\n\n    printf(\"%d\\n\", total_sequence_length);\n    return 0;\n}",
    "timestamp": "2025-08-13 03:32:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_bingo_sequence(M, N):\n    def check_bingo(card):\n        # Check horizontal lines\n        for row in card:\n            if all(x == 1 for x in row):\n                return True\n        \n        # Check vertical lines\n        for col in range(M):\n            if all(card[row][col] == 1 for row in range(M)):\n                return True\n        \n        # Check diagonals\n        if all(card[i][i] == 1 for i in range(M)):\n            return True\n        if all(card[i][M-1-i] == 1 for i in range(M)):\n            return True\n        \n        return False\n\n    def backtrack(players, called_numbers):\n        # Check if all previous players have Bingo\n        for p in range(len(players) - 1):\n            if not check_bingo(players[p]):\n                return float('inf')\n        \n        # Check if current player has Bingo\n        if check_bingo(players[-1]):\n            return len(called_numbers)\n        \n        # Try calling each uncalled number\n        min_length = float('inf')\n        for num in range(1, N*M*M + 1):\n            if num not in called_numbers:\n                # Simulate calling the number\n                new_called_numbers = called_numbers | {num}\n                new_players = [\n                    [[1 if cell == num else row[cell] for cell in range(M)] \n                     for row in player] \n                    for player in players\n                ]\n                \n                # Recursively find minimum sequence\n                min_length = min(min_length, \n                    backtrack(new_players, new_called_numbers))\n        \n        return min_length\n\n    # Initialize players with their Bingo cards\n    initial_players = [\n        [[0 for _ in range(M)] for _ in range(M)] \n        for _ in range(N)\n    ]\n    \n    return backtrack(initial_players, set())",
    "timestamp": "2025-08-13 03:32:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    players = []\n    for _ in range(N):\n        card = []\n        for _ in range(M):\n            row = list(map(int, data[idx:idx+M]))\n            idx += M\n            card.append(row)\n        players.append(card)\n    \n    # For each player, create a dictionary: number -> (row, col)\n    player_maps = []\n    for card in players:\n        num_map = {}\n        for i in range(M):\n            for j in range(M):\n                num = card[i][j]\n                num_map[num] = (i, j)\n        player_maps.append(num_map)\n    \n    # For each player, track the count of punched numbers in each row, column, and diagonal\n    rows = [[0]*M for _ in range(N)]\n    cols = [[0]*M for _ in range(N)]\n    diag1 = [0]*N  # top-left to bottom-right\n    diag2 = [0]*N  # top-right to bottom-left\n    \n    # We need to process numbers in an order that ensures player i wins before player j if i < j\n    # So for each number, we process it in the order of players 0 to N-1\n    \n    # Collect all numbers from all players, but process in order of players\n    # So first all numbers from player 0, then player 1, etc.\n    # But we need to find the minimal sequence where the condition is met\n    \n    # The approach is to simulate the calling of numbers, and for each player, track when they get a bingo\n    # The sequence must be such that player i's bingo is before player j's if i < j\n    \n    # We can model this by processing numbers in the order they appear in the sequence, and for each player,\n    # check if adding the number completes a line\n    \n    # The minimal sequence is the sequence up to the point where player N-1 gets a bingo, with all previous players\n    # having gotten their bingos in order\n    \n    # To find the minimal sequence, we can simulate the calling of numbers in the order they appear in any player's card,\n    # but ensuring that for each player, their numbers are called before others' numbers if they haven't bingo'd yet\n    \n    # This is similar to merging the numbers from all players, but prioritizing earlier players\n    \n    # We can represent the sequence as the union of all numbers from all players, ordered in a way that for any player i,\n    # their numbers appear before player j's numbers (i < j) unless player i has already bingo'd\n    \n    # The minimal sequence length is the minimal number of calls needed to satisfy the condition\n    \n    # To find this, we can simulate the calling process:\n    # Initialize for each player their row, col, diag counts\n    # For each number in the sequence (in the order that prioritizes earlier players), update the counts for all players that have that number\n    # Check after each update if any player gets a bingo\n    # The sequence must ensure that player i's bingo comes before player j's if i < j\n    \n    # The minimal sequence is found by processing numbers in the order that allows earlier players to bingo first\n    \n    # To implement this, we can process numbers in the order they appear in the sequence, but for each number, we process it for all players in order\n    \n    # The sequence is built by taking numbers from players in order, but skipping numbers from players that have already bingo'd\n    \n    # We can represent the sequence as follows:\n    # For each player in order, add their numbers to the sequence, but only if the player hasn't bingo'd yet\n    # Once a player bingos, their numbers are no longer added to the sequence\n    \n    # The sequence is built by interleaving numbers from players in order, prioritizing earlier players\n    \n    # The minimal sequence length is the point at which the last player (N-1) gets a bingo\n    \n    # To simulate this, we can process numbers in the order of the sequence, and for each number, update all players that have it\n    \n    # The sequence is constructed by taking numbers from players in order, but only those that haven't bingo'd\n    \n    # The minimal sequence is the sequence constructed this way up to the point where the last player bingos\n    \n    # To implement this, we can use a list to keep track of the sequence, and for each number in the sequence, update the counts for all players that have it\n    \n    # Initialize bingo flags for each player\n    bingoed = [False] * N\n    bingo_order = []\n    \n    # We need to process numbers in an order that allows earlier players to bingo first\n    # The sequence is built by taking numbers from players in order, but skipping those from players that have bingo'd\n    \n    # Collect all numbers from all players, grouped by player\n    player_numbers = []\n    for i in range(N):\n        nums = []\n        for row in players[i]:\n            for num in row:\n                nums.append(num)\n        player_numbers.append(nums)\n    \n    # The sequence is built by interleaving numbers from players in order, skipping those from bingo'd players\n    # We can simulate this by processing numbers in the order they appear in the sequence\n    \n    # To find the minimal sequence, we can simulate the calling process by processing numbers in the order that allows earlier players to bingo first\n    \n    # Initialize a pointer for each player's numbers\n    pointers = [0] * N\n    sequence = []\n    \n    while not all(bingoed):\n        # Iterate through players in order\n        for i in range(N):\n            if bingoed[i]:\n                continue\n            # Take the next number from player i's numbers\n            if pointers[i] < M*M:\n                num = player_numbers[i][pointers[i]]\n                sequence.append(num)\n                pointers[i] += 1\n                # Update all players that have this number\n                for j in range(N):\n                    if bingoed[j]:\n                        continue\n                    if num in player_maps[j]:\n                        row, col = player_maps[j][num]\n                        rows[j][row] += 1\n                        cols[j][col] += 1\n                        if row == col:\n                            diag1[j] += 1\n                        if row + col == M - 1:\n                            diag2[j] += 1\n                        # Check if player j has bingo\n                        if (rows[j][row] == M or cols[j][col] == M or diag1[j] == M or diag2[j] == M):\n                            if not bingoed[j]:\n                                bingoed[j] = True\n                                bingo_order.append(j)\n                                # Ensure that the bingo order is correct\n                                if len(bingo_order) > 1 and bingo_order[-2] > bingo_order[-1]:\n                                    # This should not happen because we process players in order\n                                    pass\n            else:\n                # No more numbers for this player, but they haven't bingo'd yet\n                # This shouldn't happen because every player must have a bingo\n                pass\n    \n    print(len(sequence))\n\nsolve()",
    "timestamp": "2025-08-13 03:33:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\nbool checkBingo(vector<vector<bool>>& punched) {\n    int M = punched.size();\n    // Check rows\n    for (int i = 0; i < M; ++i) {\n        bool rowBingo = true;\n        for (int j = 0; j < M; ++j) {\n            if (!punched[i][j]) {\n                rowBingo = false;\n                break;\n            }\n        }\n        if (rowBingo) return true;\n    }\n    // Check columns\n    for (int j = 0; j < M; ++j) {\n        bool colBingo = true;\n        for (int i = 0; i < M; ++i) {\n            if (!punched[i][j]) {\n                colBingo = false;\n                break;\n            }\n        }\n        if (colBingo) return true;\n    }\n    // Check diagonals\n    bool diagBingo1 = true, diagBingo2 = true;\n    for (int i = 0; i < M; ++i) {\n        if (!punched[i][i]) diagBingo1 = false;\n        if (!punched[i][M - 1 - i]) diagBingo2 = false;\n    }\n    return diagBingo1 || diagBingo2;\n}\n\nint main() {\n    int P, M;\n    cin >> P >> M;\n    \n    vector<vector<vector<int>>> cards(P, vector<vector<int>>(M, vector<int>(M)));\n    vector<unordered_map<int, pair<int, int>>> numberMap(P);\n\n    // Reading input\n    for (int p = 0; p < P; ++p) {\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < M; ++j) {\n                cin >> cards[p][i][j];\n                numberMap[p][cards[p][i][j]] = {i, j};\n            }\n        }\n    }\n\n    vector<vector<bool>> punched(P, vector<vector<bool>>(M, vector<bool>(M, false)));\n    vector<int> bingos(P, 0);\n    int completed = 0;\n    int sequenceLength = 0;\n\n    // List all numbers on all cards (no duplicates per card)\n    unordered_set<int> allNumbers;\n    for (const auto& playerMap : numberMap) {\n        for (const auto& numPair : playerMap) {\n            allNumbers.insert(numPair.first);\n        }\n    }\n\n    // Simulate the game\n    for (int num : allNumbers) {\n        ++sequenceLength;\n        for (int p = 0; p < P; ++p) {\n            if (bingos[p] == 0 && numberMap[p].count(num)) {\n                auto position = numberMap[p][num];\n                punched[p][position.first][position.second] = true;\n                \n                if (checkBingo(punched[p])) {\n                    bingos[p] = sequenceLength;\n                    ++completed;\n                }\n            }\n        }\n\n        if (completed == P) break;\n    }\n\n    cout << sequenceLength << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:26"
  }
]