[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_NODES * 2];\nint head[MAX_NODES];\nint edge_count;\nint visited[MAX_NODES];\nint max_length;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int node, int length) {\n    if (length > max_length) {\n        max_length = length;\n    }\n    visited[node] = 1;\n    for (int i = head[node]; i != -1; i = edges[i].next) {\n        int next_node = edges[i].to;\n        if (!visited[next_node]) {\n            dfs(next_node, length + 1);\n        }\n    }\n    visited[node] = 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n    max_length = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n    \n    for (int i = 1; i < MAX_NODES; i++) {\n        if (head[i] != -1) {\n            memset(visited, 0, sizeof(visited));\n            dfs(i, 1);\n        }\n    }\n    \n    printf(\"%d\\n\", max_length);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxChainLength(int[][] strings) {\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n        \n        // Build graph\n        for (int[] str : strings) {\n            for (int ring : str) {\n                graph.putIfAbsent(ring, new HashSet<>());\n            }\n            \n            for (int i = 0; i < str.length - 1; i++) {\n                graph.get(str[i]).add(str[i + 1]);\n                graph.get(str[i + 1]).add(str[i]);\n            }\n        }\n        \n        Set<Integer> visited = new HashSet<>();\n        int maxChainLength = 0;\n        \n        for (int ring : graph.keySet()) {\n            if (!visited.contains(ring)) {\n                Set<Integer> chainRings = new HashSet<>();\n                dfs(graph, ring, visited, chainRings);\n                maxChainLength = Math.max(maxChainLength, chainRings.size());\n            }\n        }\n        \n        return maxChainLength;\n    }\n    \n    private void dfs(Map<Integer, Set<Integer>> graph, int current, \n                     Set<Integer> visited, Set<Integer> chainRings) {\n        visited.add(current);\n        chainRings.add(current);\n        \n        for (int neighbor : graph.get(current)) {\n            if (!visited.contains(neighbor)) {\n                dfs(graph, neighbor, visited, chainRings);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:46:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nunordered_map<int, vector<pair<int, int>>> graph;\nunordered_set<int> visited;\n\nint dfs(int node) {\n    visited.insert(node);\n    int max_depth = 0;\n    for (auto& edge : graph[node]) {\n        int neighbor = edge.first;\n        if (visited.find(neighbor) == visited.end()) {\n            max_depth = max(max_depth, edge.second + dfs(neighbor));\n        }\n    }\n    visited.erase(node);\n    return max_depth;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    unordered_set<int> nodes;\n\n    for (int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].emplace_back(b, 1);\n        graph[b].emplace_back(a, 1);\n        nodes.insert(a);\n        nodes.insert(b);\n    }\n\n    int max_chain = 0;\n    for (int node : nodes) {\n        visited.clear();\n        max_chain = max(max_chain, dfs(node) + 1);\n    }\n\n    cout << max_chain << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STRINGS 1000\n#define MAX_LENGTH 100\n\ntypedef struct {\n    int rings[MAX_LENGTH];\n    int length;\n} String;\n\nint findMaxChainLength(String* strings, int n) {\n    int graph[MAX_STRINGS][MAX_STRINGS] = {0};\n    int visited[MAX_STRINGS] = {0};\n    \n    // Build adjacency graph\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int x = 0; x < strings[i].length; x++) {\n                for (int y = 0; y < strings[j].length; y++) {\n                    if (strings[i].rings[x] == strings[j].rings[y]) {\n                        graph[i][j] = graph[j][i] = 1;\n                        break;\n                    }\n                }\n                if (graph[i][j]) break;\n            }\n        }\n    }\n    \n    // DFS to find max chain\n    int maxChainLen = 0;\n    \n    for (int start = 0; start < n; start++) {\n        if (visited[start]) continue;\n        \n        int currentChain[MAX_STRINGS];\n        int chainLen = 0;\n        \n        currentChain[chainLen++] = start;\n        visited[start] = 1;\n        \n        while (1) {\n            int found = 0;\n            for (int next = 0; next < n; next++) {\n                if (!visited[next] && graph[currentChain[chainLen-1]][next]) {\n                    currentChain[chainLen++] = next;\n                    visited[next] = 1;\n                    found = 1;\n                    break;\n                }\n            }\n            \n            if (!found) break;\n        }\n        \n        // Count unique rings\n        int uniqueRings[MAX_STRINGS * MAX_LENGTH] = {0};\n        int uniqueCount = 0;\n        \n        for (int i = 0; i < chainLen; i++) {\n            for (int j = 0; j < strings[currentChain[i]].length; j++) {\n                int ring = strings[currentChain[i]].rings[j];\n                int exists = 0;\n                for (int k = 0; k < uniqueCount; k++) {\n                    if (uniqueRings[k] == ring) {\n                        exists = 1;\n                        break;\n                    }\n                }\n                if (!exists) {\n                    uniqueRings[uniqueCount++] = ring;\n                }\n            }\n        }\n        \n        maxChainLen = (uniqueCount > maxChainLen) ? uniqueCount : maxChainLen;\n    }\n    \n    return maxChainLen;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    String strings[MAX_STRINGS];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &strings[i].length);\n        for (int j = 0; j < strings[i].length; j++) {\n            scanf(\"%d\", &strings[i].rings[j]);\n        }\n    }\n    \n    int result = findMaxChainLength(strings, n);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestChain(vector<vector<int>>& strings) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n        unordered_set<int> uniqueRings;\n        \n        // Build graph and collect unique rings\n        for (const auto& str : strings) {\n            graph[str[0]].push_back({str[1], str[2]});\n            graph[str[1]].push_back({str[0], str[2]});\n            uniqueRings.insert(str[0]);\n            uniqueRings.insert(str[1]);\n        }\n        \n        int maxChainLength = 0;\n        \n        // Try starting chain from each unique ring\n        for (int start : uniqueRings) {\n            unordered_set<int> visited;\n            int chainLength = dfs(graph, start, visited);\n            maxChainLength = max(maxChainLength, chainLength);\n        }\n        \n        return maxChainLength;\n    }\n    \nprivate:\n    int dfs(unordered_map<int, vector<pair<int, int>>>& graph, int current, unordered_set<int>& visited) {\n        visited.insert(current);\n        int maxLength = 1;\n        \n        for (const auto& neighbor : graph[current]) {\n            if (visited.count(neighbor.first) == 0) {\n                int subChainLength = 1 + dfs(graph, neighbor.first, visited);\n                maxLength = max(maxLength, subChainLength);\n            }\n        }\n        \n        visited.erase(current);\n        return maxLength;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<int>> strings = {{1, 3, 4}, {2, 3, 5}, {4, 6, 1}};\n    cout << sol.longestChain(strings) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxChainLength {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<int[]> strings = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            strings.add(new int[]{a, b});\n        }\n        \n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int[] str : strings) {\n            int a = str[0], b = str[1];\n            graph.putIfAbsent(a, new ArrayList<>());\n            graph.putIfAbsent(b, new ArrayList<>());\n            graph.get(a).add(new int[]{a, b});\n            graph.get(b).add(new int[]{b, a});\n        }\n        \n        Set<Integer> visited = new HashSet<>();\n        int maxLength = 0;\n        for (int node : graph.keySet()) {\n            if (!visited.contains(node)) {\n                maxLength = Math.max(maxLength, dfs(node, graph, visited));\n            }\n        }\n        System.out.println(maxLength);\n    }\n    \n    private static int dfs(int node, Map<Integer, List<int[]>> graph, Set<Integer> visited) {\n        visited.add(node);\n        int maxDepth = 0;\n        for (int[] edge : graph.get(node)) {\n            int neighbor = edge[1];\n            if (!visited.contains(neighbor)) {\n                maxDepth = Math.max(maxDepth, dfs(neighbor, graph, visited));\n            }\n        }\n        visited.remove(node);\n        return maxDepth + 1;\n    }\n}",
    "timestamp": "2025-08-05 18:47:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef dfs(graph, start, visited, path):\n    stack = [(start, path)]\n    longest_path = path\n    while stack:\n        current, path = stack.pop()\n        visited.add(current)\n        if len(path) > len(longest_path):\n            longest_path = path\n        for neighbor in graph[current]:\n            if neighbor not in path:\n                stack.append((neighbor, path + [neighbor]))\n    return longest_path\n\ndef max_chain_length(strings):\n    graph = defaultdict(list)\n    \n    for a, b in strings:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    max_length = 0\n    visited = set()\n    \n    for node in graph:\n        if node not in visited:\n            longest_path = dfs(graph, node, visited, [node])\n            max_length = max(max_length, len(set(longest_path)))\n    \n    return max_length\n\n# Example usage:\nstrings = [[1, 3], [3, 4], [2, 3], [3, 5], [4, 6], [6, 1]]\nprint(max_chain_length(strings))  # Output the maximum length of any chain",
    "timestamp": "2025-08-13 00:53:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxChainLength {\n\n    private static class UnionFind {\n        private Map<Integer, Integer> parent = new HashMap<>();\n        private Map<Integer, Integer> rank = new HashMap<>();\n        private Map<Integer, Set<Integer>> components = new HashMap<>();\n\n        public int find(int x) {\n            if (!parent.containsKey(x)) {\n                parent.put(x, x);\n                rank.put(x, 1);\n                Set<Integer> newComponent = new HashSet<>();\n                newComponent.add(x);\n                components.put(x, newComponent);\n            } else if (parent.get(x) != x) {\n                int originalParent = parent.get(x);\n                parent.put(x, find(originalParent));\n            }\n            return parent.get(x);\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX != rootY) {\n                if (rank.get(rootX) > rank.get(rootY)) {\n                    parent.put(rootY, rootX);\n                    components.get(rootX).addAll(components.get(rootY));\n                    components.remove(rootY);\n                } else if (rank.get(rootX) < rank.get(rootY)) {\n                    parent.put(rootX, rootY);\n                    components.get(rootY).addAll(components.get(rootX));\n                    components.remove(rootX);\n                } else {\n                    parent.put(rootY, rootX);\n                    rank.put(rootX, rank.get(rootX) + 1);\n                    components.get(rootX).addAll(components.get(rootY));\n                    components.remove(rootY);\n                }\n            }\n        }\n\n        public int getMaxComponentSize() {\n            int maxSize = 0;\n            for (Set<Integer> component : components.values()) {\n                maxSize = Math.max(maxSize, component.size());\n            }\n            return maxSize;\n        }\n    }\n\n    public static int maxLengthOfChain(List<int[]> strings) {\n        UnionFind uf = new UnionFind();\n\n        for (int[] str : strings) {\n            int start = str[0];\n            int end = str[1];\n            uf.union(start, end);\n        }\n\n        return uf.getMaxComponentSize();\n    }\n\n    public static void main(String[] args) {\n        List<int[]> strings = Arrays.asList(\n            new int[]{1, 3},\n            new int[]{3, 4},\n            new int[]{4, 6},\n            new int[]{6, 1}\n        );\n\n        System.out.println(\"Maximum length of any chain: \" + maxLengthOfChain(strings));\n    }\n}",
    "timestamp": "2025-08-13 00:54:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_RINGS 1000\n\ntypedef struct {\n    int a, b;\n} String;\n\n// Find function for disjoint set union\nint find(int parent[], int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\n// Union function for disjoint set union\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    if (rootX != rootY) {\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\n// DFS to calculate chain length\nvoid dfs(int node, int adj[][MAX_RINGS], bool visited[], int *currentLength) {\n    visited[node] = true;\n    (*currentLength)++;\n    for (int i = 0; i < MAX_RINGS; i++) {\n        if (adj[node][i] > 0 && !visited[i]) {\n            dfs(i, adj, visited, currentLength);\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    String strings[n];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &strings[i].a, &strings[i].b);\n    }\n\n    int parent[MAX_RINGS];\n    int rank[MAX_RINGS] = {0};\n\n    for (int i = 0; i < MAX_RINGS; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n; i++) {\n        unionSet(parent, rank, strings[i].a, strings[i].b);\n    }\n\n    int adj[MAX_RINGS][MAX_RINGS] = {0};\n    for (int i = 0; i < n; i++) {\n        adj[strings[i].a][strings[i].b]++;\n        adj[strings[i].b][strings[i].a]++;\n    }\n\n    bool visited[MAX_RINGS] = {false};\n    int maxLength = 0;\n\n    for (int i = 0; i < MAX_RINGS; i++) {\n        if (find(parent, i) == i) {\n            int currentLength = 0;\n            for (int j = 0; j < MAX_RINGS; j++) {\n                if (find(parent, j) == i && !visited[j]) {\n                    dfs(j, adj, visited, &currentLength);\n                }\n            }\n            if (currentLength > maxLength) {\n                maxLength = currentLength;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", maxLength);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:54:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_chain_length(strings):\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n    \n    def union(parent, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px != py:\n            parent[px] = py\n    \n    # Extract all unique numbers from strings\n    numbers = set()\n    for s in strings:\n        numbers.update(s)\n    \n    # Create parent mapping for disjoint set\n    parent = {num: num for num in numbers}\n    \n    # Connect strings with shared rings\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            shared = set(strings[i]) & set(strings[j])\n            if shared:\n                for num in shared:\n                    union(parent, strings[i][0], strings[j][0])\n    \n    # Count max chain length\n    chains = {}\n    for s in strings:\n        root = find(parent, s[0])\n        length = len(set(s))\n        chains[root] = max(chains.get(root, 0), length)\n    \n    return max(chains.values()) if chains else 0",
    "timestamp": "2025-08-13 00:54:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef max_chain_length(strings):\n    graph = defaultdict(list)\n    for a, b in strings:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    max_len = 0\n    visited = set()\n    \n    for node in graph:\n        if node not in visited:\n            queue = deque()\n            queue.append((node, 1))\n            visited.add(node)\n            current_max = 1\n            \n            while queue:\n                current, length = queue.popleft()\n                current_max = max(current_max, length)\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, length + 1))\n            \n            max_len = max(max_len, current_max)\n    \n    return max_len\n\n# Example usage:\n# strings = [[1, 3], [3, 4], [2, 3, 5], [4, 6, 1]]\n# print(max_chain_length(strings))",
    "timestamp": "2025-08-13 00:54:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\n// Function to add edge to the graph\nvoid addEdge(unordered_map<int, vector<int>>& graph, int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\n// Function to perform BFS and find the maximum length of a chain\nint bfs(unordered_map<int, vector<int>>& graph, int start) {\n    unordered_set<int> visited;\n    queue<int> q;\n    q.push(start);\n    visited.insert(start);\n    int length = 0;\n\n    while (!q.empty()) {\n        int nodeCount = q.size();\n        for (int i = 0; i < nodeCount; ++i) {\n            int node = q.front(); q.pop();\n            for (int neighbor : graph[node]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    visited.insert(neighbor);\n                    q.push(neighbor);\n                }\n            }\n        }\n        length++;\n    }\n    \n    return length;\n}\n\nint findMaxLengthChain(vector<pair<int, int>>& strings) {\n    unordered_map<int, vector<int>> graph;\n\n    // Building the graph\n    for (auto& p : strings) {\n        addEdge(graph, p.first, p.second);\n    }\n\n    // Finding the maximum chain length\n    int maxLength = 0;\n    unordered_set<int> visitedNodes;\n\n    for (auto& entry : graph) {\n        if (visitedNodes.find(entry.first) == visitedNodes.end()) {\n            int currentLength = bfs(graph, entry.first);\n            maxLength = max(maxLength, currentLength);\n            visitedNodes.insert(entry.first);\n            for (int neighbor : graph[entry.first]) {\n                visitedNodes.insert(neighbor);\n            }\n        }\n    }\n\n    return maxLength;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> strings(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> strings[i].first >> strings[i].second;\n    }\n\n    cout << findMaxLengthChain(strings) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:45"
  }
]