[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\nimport scala.collection.mutable.{IndexedSeq => iSeq}\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new Scanner(System.in)\n\n    var n = sc.nextInt()\n    while (n != 0) {\n      val connectibleAll = iSeq.fill(100)(Set[Int]())\n\n      for (i <- 0 until n) {\n        val a, b = sc.nextInt() - 1\n        connectibleAll(a) += b\n        connectibleAll(b) += a\n      }\n      val contractedConnectible = connectibleAll.zipWithIndex.filter(_._1.nonEmpty)\n      val dict = contractedConnectible.map(_._2).zipWithIndex.toMap\n      val connectible = contractedConnectible.map(t => (dict(t._2), t._1.map(dict(_))))\n      val used = iSeq.fill(connectible.size)(false)\n\n      def trace(ring: (Int, Set[Int])): Int = {\n        val (lastRing, nextRings) = ring\n        used(lastRing) = true\n        val result = nextRings\n          .filterNot(used(_)).map(r => trace(connectible(r)) + 1)\n          .foldLeft(1)((z, n) => if (n > z) n else z)\n        used(lastRing) = false\n        result\n      }\n\n      println(connectible.map(trace).max)\n\n      n = sc.nextInt()\n    }\n    sc.close()\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\nimport scala.collection.mutable.{Set => mSet}\n\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new Scanner(System.in)\n\n    val maxNum = 100\n    val connectible = Array.fill(maxNum)(mSet[Int]())\n    val used = Array.fill(maxNum)(false)\n\n    var n = sc.nextInt()\n    while (n != 0) {\n\n      for (i <- 0 until n) {\n        val a, b = sc.nextInt() - 1\n        connectible(a) += b\n        connectible(b) += a\n      }\n\n      println((for (ring <- 0 until maxNum if connectible(ring).nonEmpty) yield trace(ring)).max)\n\n      n = sc.nextInt()\n      connectible.foreach(set => set.clear)\n    }\n\n    def trace(lastRing: Int): Int = {\n      var ret = 0\n      for (nextRing <- connectible(lastRing) if !used(nextRing)) {\n        used(nextRing) = true\n        ret = math.max(ret, trace(nextRing) + 1)\n        used(nextRing) = false\n      }\n      ret\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\nimport scala.collection.mutable.{IndexedSeq => iSeq}\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new Scanner(System.in)\n    var n = sc.nextInt()\n\n    while (n != 0) {\n\n      val connectibleAll = iSeq.fill(100)(Set[Int]())\n\n      for (i <- 0 until n) {\n        val a, b = sc.nextInt() - 1\n        connectibleAll(a) += b\n        connectibleAll(b) += a\n      }\n      val contractedConnectible = connectibleAll.zipWithIndex.filter(_._1.nonEmpty)\n      val dict = contractedConnectible.map(_._2).zipWithIndex.toMap\n      val connectible = contractedConnectible.map(t => (dict(t._2), t._1.map(dict(_))))\n      val used = iSeq.fill(connectible.size)(false)\n\n\n      def trace(ring: (Int, Set[Int])): Int = {\n        val (lastRing, nextRings) = ring\n        used(lastRing) = true\n        val result = nextRings\n          .filterNot(used(_)).map(r => trace(connectible(r)) + 1)\n          .foldLeft(1)((z, n) => if (n > z) n else z)\n        used(lastRing) = false\n        result\n      }\n\n      println(connectible.map(trace).max)\n\n      n = sc.nextInt()\n    }\n    sc.close()\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n  import scala.io.StdIn.{readLine}\n  solve(readLine().toInt)\n  class Node(val id:Int){\n    private var edges:List[Node] = Nil\n    def addEdge(to:Node):Unit = edges = to::edges\n    def edgesTo:List[Node] = edges\n  }\n  def farthestNode(start:Node, memo:Array[Boolean], uft:Array[UnionFindTree]):(Int, Node) = {\n    start.edgesTo.filter{n ⇒ !memo(n.id)}.map{case n ⇒\n      uft(n.id).join(uft(start.id))\n        memo(n.id) = true\n        val res = farthestNode(n, memo, uft)\n        memo(n.id) = false\n        res\n    } match{\n      case Nil ⇒ (1, start)\n      case l ⇒ {\n        val (length, n) = l.maxBy{case (len, _) ⇒ len}\n        (length + 1, n)\n      }\n    }\n  }\n  class UnionFindTree{\n    private var mParent:Option[UnionFindTree] = None\n    private def parent():UnionFindTree = mParent match{\n      case None ⇒ this\n      case Some(p) ⇒ p\n    }\n    def join(that:UnionFindTree):Unit = {\n      if (!isSameUnion(that)){\n        parent().mParent = Some(that.parent())\n      }\n    }\n    def isSameUnion(that:UnionFindTree):Boolean = parent() == that.parent()\n  }\n  def solve(n:Int):Unit = {\n    if (n == 0) return\n    val nodes = Array.tabulate(101){a ⇒ new Node(a)}\n    val isSearching = Array.tabulate(101){_ ⇒ false}\n    val isSearched = Array.tabulate(101){_ ⇒ new UnionFindTree}\n    for (_ ← 0 until n){\n      val Array(a, b) = readLine().split(' ').map(_.toInt)\n      nodes(a).addEdge(nodes(b))\n      nodes(b).addEdge(nodes(a))\n    }\n    val searched = new UnionFindTree\n    println((for (node ← nodes) yield {\n      if (!searched.isSameUnion(isSearched(node.id))){\n        searched.join(isSearched(node.id))\n        isSearching(node.id) = true\n        val (_, farthest) = farthestNode(node, isSearching, isSearched)\n        isSearching(node.id) = false\n        isSearching(farthest.id) = true\n        val (res, _) = farthestNode(farthest, isSearching, isSearched)\n        isSearching(farthest.id) = false\n        res\n      }else 0\n    }).max)\n    solve(readLine().toInt)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\nimport scala.collection.mutable.{IndexedSeq => iSeq}\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new Scanner(System.in)\n\n    var n = sc.nextInt()\n    while (n != 0) {\n      val connectibleAll = iSeq.fill(Ring.maxNum)(Set[Int]())\n\n      for (i <- 0 until n) {\n        val a, b = sc.nextInt() - 1\n        connectibleAll(a) += b\n        connectibleAll(b) += a\n      }\n      val contractedConnectible = connectibleAll.zipWithIndex.filter(_._1.nonEmpty)\n      val dict = contractedConnectible.map(_._2).zipWithIndex.toMap\n      val newConnectible = contractedConnectible.map(t => (dict(t._2), t._1.map(dict(_))))\n\n      println(new Ring(newConnectible).get)\n\n      n = sc.nextInt()\n    }\n    sc.close()\n  }\n}\n\nobject Ring {\n  val maxNum = 100\n}\n\nclass Ring(connectible: iSeq[(Int, Set[Int])]) {\n  val used = iSeq.fill(connectible.size)(false)\n\n  def get = {\n    connectible.map(trace).view.max\n  }\n\n  def trace(ring: (Int, Set[Int])): Int = {\n    val (lastRing, nextRings) = ring\n    used(lastRing) = true\n    val result = nextRings\n      .filterNot(used(_)).map(r => trace(connectible(r)) + 1)\n      .fold(1)((z, n) => if (n > z) n else z)\n    used(lastRing) = false\n    result\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint ans;\n\nvoid Dfs(vector<int> way[100],bool used[100],int n,int d){\n\t//printf(\"%d,%d\\n\",n,d);\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tif(used[way[n][i]]) continue;\n\t\tDfs(way,used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tvector<int> way[100];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(way[i].size()==1)\n\t\t\t\tDfs(way,used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std; \n\n\nstatic const int black = 1;\nstatic const int white = 0;\nstatic const int crash = -1;\n\nint graph[128][128] = {{}};\nint color[128] = {};\nint n,d = 0,ans = 0,flag = 0;\n\nvoid bfs(int in){\n\n  //  cout << \"in = \" << in << endl;\n  int u;\n  u = in;\n\n  color[u] = black;\n  for(int i = 0;i < n;i++){\n    flag = 0;\n    if(color[i] != black && graph[u][i] == 1){\n      d++;\n      // cout << \"u = \" << u << \"i =\" << i << endl;\n      bfs(i);\n    }\n\n  }\n  flag = crash;\n    if(d > ans){\n      ans = d;\n    }\n    d = 1;\n}\n\n\nint main(){\n\n  while(1){\n  int mae,ato;\n\n  cin >> n;\n  if(n == 0) break;\n\n  for(int i =0;i < n;i++){\n    cin >> mae >> ato;\n    graph[mae - 1][ato - 1] = 1;\n    graph[ato - 1][mae - 1] = 1;\n  }\n\n  /*  for(int i = 0;i < n;i++){\n    for(int  j = 0;j < n;j++){\n      cout <<  graph[i][j] << ' ';\n    }\n    cout << endl;\n    }*/\n\n  for(int i = 0;i < n;i++){\n    flag = 0;\n    for(int j = 0;j < 128;j++) color[j] = white;\n    // cout << \"b:i \" << i << endl; \n    bfs(i);\n  }\n\n  cout << ans << endl;\n  for(int i = 0;i < 128;i++){\n    for(int j = 0;j < 128;j++){\n      graph[i][j] = 0;\n    }\n    color[i] = 0;\n  }\n  d = 0;\n  ans = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nstruct Ring{\n    vector<int> s;\n    bool kaku;\n    \n    void clear(){\n        s.clear();\n        kaku=false;\n    }\n}ring[101];\n\nint bfs(int now){\n    int re=0;\n    \n    ring[now].kaku=true;\n    for(int i=0;i<ring[now].s.size();i++){\n        if(!ring[ring[now].s[i]].kaku){\n            re=max(bfs(ring[now].s[i]),re);\n        }\n    }\n    \n    return re+1;\n}\n\nint solve(int n){\n    int a,b,ans=0;\n    \n    for(int i=1;i<=100;i++){\n        ring[i].clear();\n    }\n    \n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        ring[a].s.push_back(b);\n        ring[b].s.push_back(a);\n    }\n    \n    for(int i=1;i<=100;i++){\n        if(!ring[i].kaku){\n            ans=max(bfs(i),ans);\n        }\n        for(int i=1;i<=100;i++){\n            ring[i].kaku=false;\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n\nint main(){\n    int n;\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!passed[to]){\n\t\t\tpassed[to]=true;\n\t\t\tdfs(to,depth+1);\n\t\t\tpassed[to]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmaxPath=0;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\t//cin>>a>>b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tpassed[*it]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\",maxPath);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n//int node[101][101];\nint visit[101];\nint ans,last;\nint die[101];\nint flag;\n\nvoid dfs(int now, int cnt, int *st, vector<vector<int> >& vv){\n\tif( cnt>ans ){\n\t\tans=cnt;\n\t\tlast = now;\n\t\tflag = 1;\n\t}\n\tfor(int next=0; next<vv[now].size(); next++)if( !visit[vv[now][next]] ){\n\t\tint k = vv[now][next];\n\t\tvisit[k] = die[k] = 1;\n\t\tst[cnt] = k;\n\t\tdfs(k,cnt+1,st,vv);\n\t\tvisit[k] = 0;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tset<int> s;\n\t\tvector<vector<int> > vv(101);\n\t\tans = 0;\n\t\t//memset(node,0,sizeof(node));\n\t\tmemset(visit,0,sizeof(visit));\n\t\tmemset(die,0,sizeof(die));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a,b; cin>>a>>b;\n\t\t\t//node[a][b] = node[b][a] = 1;\n\t\t\tvv[a].push_back(b);\n\t\t\tvv[b].push_back(a);\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint tmp[101];\n\t\t/*\n\t\tfor(int i=0; i<vv.size(); i++){\n\t\t\tprintf(\"vv[%d].size = %d\\n\",i,vv[i].size());\n\t\t\tfor(int j=0; j<vv[i].size(); j++)\n\t\t\t\tprintf(\"%d \",vv[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tfor(set<int>::iterator it=s.begin(); it!=s.end(); it++)if( !die[*it] ){\n\t\t\tflag = 0;\n\t\t\t\n\t\t\tvisit[*it]=1;\n\t\t\ttmp[0] = *it;\n\t\t\tdfs(*it,1,tmp,vv);\n\t\t\tvisit[*it]=0;\n\t\t\t\n\t\t\tdie[last] = 0;\n\t\t\t//printf(\"*it:%d\\n\",*it);\n\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint n;\nvector<int> r[100];\nbool ud[100];\nint func(int a){\n  int l=1;\n  ud[a]=true;\n  for(int j=0;j<r[a].size();++j){\n    if(!ud[r[a][j]]){\n      l=max(l,func(r[a][j])+1);\n    }\n  }\n  ud[a]=false;\n  return l;\n}\nint main(){\n  int f,t;\n  while(cin>>n,n){\n    int a=0;\n    for(int i=0;i<100;++i){\n      ud[i]=false;r[i].clear();\n    }\n    for(int i=0;i<n;++i){\n      cin>>f>>t;\n      r[f-1].push_back(t-1);r[t-1].push_back(f-1);\n    }\n    for(int i=0;i<100;++i) a=max(a,func(i));\n    cout<<a<<endl;\n  }   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nbool isPassedNode[101];\nbool isPassedEdge[101][101];\n\nint n;\nint v;\nvector<int>G[101];\n\nint dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\t\n\tint maxRes=0;\n\tfor(int i = 0; i < G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!isPassedEdge[s][to]){\n\t\t\tisPassedEdge[s][to]=true;\n\t\t\tisPassedEdge[to][s]=true;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tisPassedEdge[s][to]=false;\n\t\t\tisPassedEdge[to][s]=false;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint maxRes=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmemset(isPassedEdge,0,sizeof(isPassedEdge));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\n\t\tfor(int i = 1; i < 101; i++){\n\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tcout<<maxRes<<endl;\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nvi len;\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tlen.pb(sz(lis[i]));\n\t\t}\n\t\tsort(len.begin(),len.end());\n\t\tint k=len[0];\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tif(sz(lis[i])==k)\n\t\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MAXN 100\n\nint map[MAXN][MAXN];\nbool isPass[MAXN][MAXN];\nbool isVisit[MAXN];\nint maxdep;\n\nvoid init()\n{\n\tfor(int i=0; i<MAXN; i++)\n\t{\n\t\tfor(int j=0; j<MAXN; j++)\n\t\t{\n\t\t\tmap[i][j] = 0;\n\t\t\tisPass[i][j] = false;\n\t\t}\n\t\tisVisit[i] = false;\n\t}\n\tmaxdep = 0;\n}\n\nvoid testMap(int st, int n, int dep)\n{\n\tisVisit[st] = true;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(map[st][i] && !isPass[st][i] && !isVisit[i])\n\t\t{\n\t\t\tisPass[st][i] = isPass[i][st] = true;\n\t\t\ttestMap(i, n, dep+1);\n\t\t\tisPass[st][i] = isPass[i][st] = false;\n\t\t}\n\t}\n\tif(maxdep < dep) maxdep = dep;\n\tisVisit[st] = false;\n}\n\nint main()\n{\n\tFILE *fi = fopen(\"input.txt\", \"r\");\n\tFILE *fo = fopen(\"output.txt\", \"w\");\n\twhile(1)\n\t{\n\t\tinit();\n\t\tint n;\n\t\tfscanf(fi, \"%d\", &n);\n\t\tif(n==0) break;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tfscanf(fi, \"%d%d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tmap[a][b] = map[b][a] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\ttestMap(i, n, 1);\n\t\t}\n\t\tfprintf(fo, \"%d\\n\", maxdep);\n\t}\n\n\tfclose(fi);\n\tfclose(fo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint stmin,visited2[101];\nvoid dfs2(int i, int m){\n\n  visited2[i]=m;\n\n  int tmp=0;\n  for(int j=1;j<101;j++)\n    tmp+=g[i][j];\n\n  if(stmin>tmp)stmin=tmp;\n\n  for(int j=1;j<101;j++){\n    if(g[i][j] && !visited2[j]){\n      dfs2(j,m);\n    }\n  }\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(visited2,visited2+101,0);\n    fill(e,e+101,0);\n\n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    int ans=0,cnt=1;\n    for(int i=1;i<101;i++){\n      stmin=100000;\n      if(visited2[i]==0){\n\tdfs2(i,cnt);\n\n\tfor(int j=1;j<101;j++){\n\t  if(visited2[j]==cnt && stmin==e[j]){\n\n\t    ans=max(ans,dfs(j,1));\n\t  }\n\t}\n\tcnt++;\n      }\n    }\n    \n \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint n;\nvector<int> r[100];\nbool ud[100];\nint func(int a){\n  int l=1;\n  ud[a]=true;\n  for(int j=0;j<r[a].size();++j){\n    if(!ud[r[a][j]]){\n      l=max(l,func(r[a][j])+1);\n    }\n  }\n  ud[a]=false;\n  return l;\n}\nint main(){\n  int f,t,a;\n  while(cin>>n,n){\n    a=0;\n    for(int i=0;i<n;++i){\n      ud[i]=false;r[i].clear();\n    }\n    for(int i=0;i<n;++i){\n      cin>>f>>t;\n      r[f-1].push_back(t-1);r[t-1].push_back(f-1);\n    }\n    for(int i=0;i<n;++i) a=max(a,func(i));\n    cout<<a<<endl;\n  }   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>es[100];\nint max_length;\nbool used[100];\nvoid get_max_length(int at_pos,int sum_length){\n    used[at_pos]=true;\n    for(int i=0;i<es[at_pos].size();i++){\n        int next_pos=es[at_pos][i];\n        if(used[next_pos])continue;\n        get_max_length(next_pos,sum_length+1);\n    }\n    max_length=max(max_length,sum_length);\n    used[at_pos]=false;\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        for(int i=0;i<n;i++)es[i].clear();\n        max_length=0;\n        for(int i=0;i<n;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            es[a].push_back(b);\n            es[b].push_back(a);\n        }\n        for(int i=0;i<n;i++)\n            get_max_length(i,1);\n\n        printf(\"%d\\n\",max_length);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\nvector<int> vec[101];\nbool ch[101]={};\nbool visited[101]={};\nint dp[101]={};\nstack<int> st;\nint maxx = -1;\nint maxNODE = -1;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    dp[i] = max(dp[i],val);\n    //printf(\"%d \",i);\n    for (int k=0; k<vec[i].size(); k++) {\n        if(!ch[vec[i][k]]){\n            visited[vec[i][k]] = true;\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = true;\n        ch[i] = true;\n        DFS(i,1);\n        ch[i] = false;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(maxx == dp[i]){\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n            break;\n        }\n    }\n    printf(\"%d\\n\",maxx);\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = false;\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+V+1,false);\n    fill(e,e+V+1,0);\n\n    int MIN=100000;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n\n    int ans=0;\n    for(int j=0;j<3;j++){\n      for(int i=1;i<=V;i++){\n\tif(MIN+j==e[i])\n\t  ans=max(ans,dfs(i,1));\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nint cnt=0;\nint p=1;\nbool used[101];\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tif(!(used[lis[s][i]]))\n\t\t{\n\t\t\tused[lis[s][i]]=true;\n\t\t\tp++;\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(p>2)cnt=max(cnt,p);\n\t}\n\tused[s]=false;\n\tp--;\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tp=1;\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tused[i]=true;\n\t\t\tdfs(i);\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nint chack(int p,int t,vector<bool>& flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = chack(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttar(t,flag);\n\t\t\ttarget.insert(t);\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tif(chack(*it,1,flag) <= max){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = Solve(*it);\n\t\t\t//printf(\"s:%d\\n\",s);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<queue>\n\n#define MAX 102\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\nclass State{\npublic:\n  int pos;\n  State(int pos):pos(pos){\n    len = 0;\n  }\n  int len;\n  int timestamp[MAX];\n  bool vis[MAX];\n};\n\nint BFS(int st, const vector<Node> &G){\n  int ret = 0;\n  int g_timestamp[MAX]={0,};\n  queue<State> q;\n  State init(st);\n  fill(init.vis,init.vis+MAX,false);\n  fill(init.timestamp,init.timestamp+MAX,0);\n  init.vis[st]=true;\n  init.timestamp[st]=0;\n  q.push(init);\n  //cout << \"START : \" << st << endl;\n  while(!q.empty()){\n    bool NG=false;\n    State now = q.front();\n    q.pop();\n    //cout << \" POS : \" << now.pos << endl;\n    ret = max( ret, now.len );\n    for(int i = 0; i < MAX; ++i){\n      if( now.vis[i] && now.timestamp[i] < g_timestamp[i] )\n\tNG=true;\n    }\n    if(NG)continue;\n    const set<int> &S = G[now.pos].con;\n    for(set<int>::iterator its = S.begin();\n\tits != S.end();\n\t++its){\n      if( !now.vis[ *its ] ){\n\tState next = now;\n\tint nx = *its;\n\tnext.pos = nx;\n\tnext.vis[nx] = true;\n\tnext.timestamp[nx]=now.len+1;\n\tg_timestamp[nx] = max( g_timestamp[nx], now.len+1);\n\tnext.len++;\n\tq.push( next );\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    vector<Node> graph(MAX);\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      graph[a].con.insert(b);\n      graph[b].con.insert(a);\n    }\n    for(int i = 0; i < MAX; ++i){\n      if(exist[i])\n\tans = max(ans, BFS(i,graph));\n    }\n    cout << 1+ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\n\nusing namespace std;\n\nvector<int> vec[1001];\nbool ch[101]={};\nstack<int> st;\nint maxx = -1;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    //printf(\"%d \",i);\n    for (int k=0; k<vec[i].size(); k++) {\n        if(!ch[vec[i][k]]){\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n    }\n    for (int i=1; i<=100; i++) {\n        ch[i] = true;\n        DFS(i,0);\n        ch[i] = false;\n    }\n    printf(\"%d\\n\",maxx+1);\n    for (int i=0; i<=100; i++) {\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    points[to]=false;\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            solve(i,len+1);\n        }\n    }\n    points[to]=true;\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<100;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> d[100];\nbool visited[100];\nint dist, max_dist;\nint V;\nvoid dfs(int s){\n\tdist++;\n\tif(dist > max_dist) max_dist = dist;\n\tvisited[s] = true;\n\tfor(int i = 0; i < d[s].size(); i++){\n\t\tint t = d[s][i];\n\t\tif(visited[t] == false){\n\t\t\tdfs(t);\n\t\t\tdist--;\n\t\t\tvisited[t] = false;\n\t\t}\n\t}\n\tvisited[s] = false;\n\treturn;\n}\nint main(){\n\tint N, a, b;\n\tfor(;;){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tmax_dist = 0;\n\t\tV = 0;\n\t\tfor(int i = 0; i < 100; i++) d[i].clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif(a > V) V = a;\n\t\t\tif(b > V) V = b;\n\t\t\ta--; b--;\n\t\t\td[a].push_back(b);\n\t\t\td[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfill(visited, visited + V, false);\n\t\t\tdist = 0;\n\t\t\tdfs(i);\n\t\t}\n\t\tprintf(\"%d\\n\", max_dist);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[i]=false;\n            solve(i,len+1);\n            points[i]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<100;i++){\n            points[i]=false;\n            solve(i,0);\n            points[i]=true;\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>a[101];\nint used[101];\nint dfs(int v,int n){\n  int s=0,p=0;\n  for(int i=0;i<a[v].size();i++){\n    if(used[a[v][i]]==0){\n    used[a[v][i]]=1;\n    s=max(s,dfs(a[v][i],n+1));\n    used[a[v][i]]=0;p++;\n    }\n  }\n  if(p==0)return n;\n  return s;\n}\nint main(){\n  int n,sum=0;\n  cin>>n;\n  while(n--){\n    int a1,a2;\n    cin>>a1>>a2;\n    a[a1].push_back(a2);\n    a[a2].push_back(a1);\n  }\n  for(int k=0;k<101;k++){\n    memset(used,0,sizeof(used));\n    used[k]=1;\n    sum=max(sum,dfs(k,0));\n  }\n  cout<<sum+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[100], r[100], G[100][199];\nint rec(int pos) {\n\tv[pos] = 1; int ret = 0;\n\tfor(int i = 0; i < rings[pos]; i++) {\n\t\tif(!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile(scanf(\"%d%d\", &N), N) {\n\t\tfor(int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B;\n\t\t\tG[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tif(r[i]) ret = max(ret, rec(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint rings[200];\nint neib[101][200];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 1;i <= neib[x][0];i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings[0] = 0;\n    for(int i = 0;i < 101;i++)neib[i][0] = 0;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings[++rings[0]] = a;\n      rings[++rings[0]] = b;\n      neib[a][++neib[a][0]] = b;\n      neib[b][++neib[b][0]] = a;\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 1;j <= rings[0];j++){\n\tif(neib[rings[j]][0] == i){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 1;j <= rings[0];j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\tint n,t1,t2,i=0;\n\tint a[10]={11,19,24,10,65,9,35,51,25,20};\n\tcin>>n;\n\twhile(n!=0){\n\t\tcin>>t1>>t2;\n\t\tcout<<a[i]<<endl;\n\t\ti++;\n\t\tcin>>n;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint result;\nvector<int> strands[100];\nbool used[100];\n\nvoid rec(int k, int d, int ub) {\n  if (result < d) result = d;\n  used[k] = 1;\n  for (int i = 0; i < strands[k].size(); i++)\n    if (!used[strands[k][i]]) ub--;\n  ub++;\n  if (result < ub)\n    for (int i = 0; i < strands[k].size(); i++) {\n      int j = strands[k][i];\n      if (!used[j]) rec(j, d+1, ub);\n    }\n  used[k] = 0;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].clear();\n    fill(used, used+100, false);\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    result = 0;\n    for (int i = 0; i < 100; i++)\n      rec(i, 1, n+1);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint result;\nvector<int> strands[100];\nbool used[100];\n\nint rec(int k, int d, int ub) {\n  if (result < d) result = d;\n  used[k] = 1;\n  for (int i = 0; i < strands[k].size(); i++)\n    if (!used[strands[k][i]]) ub--;\n  ub++;\n  if (result < ub)\n    for (int i = 0; i < strands[k].size(); i++) {\n      int j = strands[k][i];\n      if (!used[j]) rec(j, d+1, ub);\n    }\n  used[k] = 0;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].clear();\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    result = 0;\n    for (int i = 0; i < n; i++)\n      rec(i, 1, n+1);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// mmm\n// dfs\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<61;\nconst ll mod=1e9+7;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint n;\nvector<int> E[100];\nvector<bool> v(100);\n\nint dfs(int cu) {\n  v[cu]=1;\n  int cnt=0;\n  for(int to:E[cu]) {\n    if (!v[to]) {\n      cnt=max(cnt,dfs(to));\n    }\n  }\n  v[cu]=0;\n  return cnt+1;\n}\n\n\nint main(){\n    int i,j;\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0) break;\n        for(i=0;i<100;i++) E[i].clear();\n        for(i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x--; y--;\n            E[x].pb(y);\n            E[y].pb(x);\n        }\n        int ans=0;\n        for(i=0;i<100;i++) ans=max(ans,dfs(i));\n        cout<<ans<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint c[101][101];/*???i????????????????????\\?????????c[i][j]???;j=0??????i????????????????????°*/\n\nint chain(int e,int l,int done[]){\n    int cpy[101];\n    int i,j;\n    int lmax = l,ltemp;\n    for(i=0;i<=done[0];i++)cpy[i]=done[i];/*?????????????????????????????£??????*/\n    if(c[e][0]){\n        for(j=1;j<=c[e][0];j++){\n            if(cpy[c[e][j]]){\n                cpy[c[e][j]] = 0;\n                ltemp = chain(c[e][j],l+1,cpy);\n                cpy[c[e][j]] = 1;\n                if(ltemp>lmax)lmax = ltemp;\n            }\n        }\n        return lmax;\n    }else{\n        return l;\n    }\n}\nint main(){\n    int n,ans,temp;\n    int done[101];/*i???????????¨??? c[i]=1,i=0??????i???max???*/\n    int a,b;\n    int i,j;\n    scanf(\"%d\",&n);\n    while(n){\n        /*?????????*/\n        for(i=0;i<=100;i++){\n            done[i] = 0;\n            for(j=0;j<=100;j++){\n                c[i][j] = 0;\n            }\n        }\n        /*?????????????????????*/\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            done[a] = done[b] = 1;\n            c[a][0]++;\n            c[b][0]++;\n            c[a][c[a][0]] = b;\n            c[b][c[b][0]] = a;\n            if(done[0]<a)done[0] = a;\n            if(done[0]<b)done[0] = b;\n        }\n        /*?¢??????¨*/\n        /*printf(\"lim: %d\\n\",done[0]);\n        for(i=1;i<=done[0];i++){\n            if(c[i][0]){\n                printf(\"%d is connected with \",i);\n                for(j=1;j<=c[i][0];j++)printf(\"%d,\",c[i][j]);\n                printf(\"\\n\");\n            }\n        }*/\n        ans = 0;\n        /*?§????????±???????????????????????±???????*/\n        for(i=1;i<=100;i++){\n            if(done[i]){\n                done[i] = 0;\n                temp = chain(i,1,done);\n                done[i] = 1;\n                if(ans<temp)ans = temp;\n            }\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs (vector<vector<int> > &v, int now, vector<bool> &used, int count) {\n    if (used[now]) return count;\n    count++;\n\n    used[now] = true;\n    int ret = count;\n    for (auto i : v[now]) {\n        ret = max(ret, dfs(v, i, used, count));\n    }\n    used[now] = false;\n\n    return ret;\n}\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<vector<int> > v(101);\n        for (int i = 0; i < N; i++) {\n            int x, y;\n            cin >> x >> y;\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n\n        int ans = 0;\n        vector<bool> used(101, false);\n        for (int i = 1; i <= 100; i++) {\n            ans = max(ans, dfs(v, i, used, 0));\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>g[100];\nint used[100];\nint solve(int a){\n\tused[a]=1;\n\tint ret=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(!used[g[a][i]]){\n\t\t\tret=max(ret,1+solve(g[a][i]));\n\t\t}\n\t}\n\tused[a]=0;\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i].clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tb--;c--;\n\t\t\tg[b].push_back(c);\n\t\t\tg[c].push_back(b);\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    while(1)\n    {\n        int num;\n        cin>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            cin>>a;\n            cin>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                maxLength = (*it).length;\n            }\n        }\n        cout<<maxLength<<endl;\n        \n    }\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n\nstruct edge{\n\tint to;\n\tint num;\n};\n\nvector<edge> G[101];\n\nbool passed[101];\nbool nodes[101];\n\nint dfs(int s){\n\tint maxLength=0;\n\tfor(int i = 0; i < G[s].size(); i++){\n\t\tedge &e=G[s][i];\n\t\tif(!passed[e.num]){\n\t\t\tpassed[e.num]=true;\n\t\t\tif(!nodes[e.to]){\n\t\t\t\tnodes[e.to]=true;\n\t\t\t\tmaxLength=max(maxLength,dfs(e.to)+1);\n\t\t\t\tnodes[e.to]=false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tmaxLength=max(maxLength,dfs(e.to));\n\n\t\t\tpassed[e.num]=false;\n\t\t}\n\t}\n\treturn maxLength;\n}\n\nint main(){\n\n\tint n;\n\tint cnt;\n\twhile(cin>>n&&n!=0){\n\t\tcnt=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tedge e;\n\t\t\te.to=a;\n\t\t\te.num=cnt;\n\t\t\tcnt++;\n\t\t\tG[b].push_back(e);\n\t\t\te.to=b;\n\t\t\tG[a].push_back(e);\n\t\t}\n\t\tint maxNum=0;\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tfill(passed,passed+101,false);\n\t\t\tfill(nodes,nodes+101,false);\n\t\t\tnodes[i]=true;\n\t\t\tmaxNum=max(maxNum,dfs(i)+1);\n\t\t}\n\t\tcout<<maxNum<<endl;\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++) \nvector<int> point,edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=0;\n\trep(i,edge[n].size()) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tvisit[edge[n][i]]=true;\n\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t\tvisit[edge[n][i]]=false;\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\trep(i,100)\n\t\t\tedge[i].clear();\n\t\trep(i,n) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tif(find(point.begin(),point.end(),a)==point.end()) point.push_back(a);\n\t\t\tif(find(point.begin(),point.end(),b)==point.end()) point.push_back(b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\trep(i,point.size()) {\n\t\t\tvisit[point[i]]=true;\n\t\t\tmx=max(mx,solve(point[i])+1);\n\t\t\tvisit[point[i]]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<int,int>\n#define pb push_back\n\nint n,used[100],e[100];\nvector<int> v[100];\n\nint f(int from){\n\tint res=0;\n\trep(i,v[from].size()){\n\t\tint to=v[from][i];\n\t\tif(!used[to]){\n\t\t\tused[to]=1;\n\t\t\tres=max(res,f(to)+1);\n\t\t\tused[to]=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+100,0);\n\t\tfill(e,e+100,0);\n\t\trep(i,100)v[i].clear();\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;a--;b--;\n\t\t\tv[a].pb(b);\n\t\t\tv[b].pb(a);\n\t\t}\n\t\trep(i,100)sort(v[i].begin(),v[i].end());\n\t\tint done[100];\n\t\tfill(done,done+100,0);\n\t\trep(i,100)if(!done[i]){\n\t\t\tint x=0;\n\t\t\trep(j,100)if(v[i]==v[j]){x++;done[j]=1;}\n\t\t\tif(x>v[i].size()+1){\n\t\t\t\tint c=0;\n\t\t\t\trep(j,100)if(v[i]==v[j]){\n\t\t\t\t\tc++;\n\t\t\t\t\tif(c>v[i].size()+1)used[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone[i]=1;\n\t\t}\n\t\tint ans=2;\n\t\trep(i,100)if(!used[i]){\n\t\t\trep(j,v[i].size())if(!used[v[i][j]]){\n\t\t\t\tused[i]=used[v[i][j]]=1;\n\t\t\t\tans=max(ans,f(v[i][j])+2);\n\t\t\t\tused[i]=used[v[i][j]]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nvector< vector<int> > edge;\n\nint dfs(int v, bitset<101> visited, int depth) {\n    int result = depth;\n    visited.set(v);\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        result = max(result, dfs(*i, visited, depth+1));\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(set<int>::iterator i=vertex.begin(); i!=vertex.end(); i++) {\n        result = max(result, dfs(*i, bitset<101>(0), 1));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge = vector< vector<int> >(101);\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,ans,u[100];vector<int> ad[100];\nvoid dfs(int c,int m){\n\tif(ans<m)ans=m; int s=ad[c].size(),t;\n\trep(i,s){\n\t\tt=ad[c][i];\n\t\tif(!u[t])u[t]=1,dfs(t,m+1),u[t]=0;\n\t}\n}\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tans=1;rep(i,100)u[i]=0,ad[i].clear();\n\t\trep(i,n){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b); a--,b--;\n\t\t\tad[a].push_back(b),ad[b].push_back(a);\n\t\t}\n\t\trep(i,100)if(!ad[i].empty()){\n\t\t\tu[i]=1;dfs(i,1);u[i]=0;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint result;\nvector<int> strands[100];\nbool used[100];\n\nvoid rec(int k, int d, int ub) {\n  if (result < d) result = d;\n  used[k] = 1;\n  for (int i = 0; i < strands[k].size(); i++)\n    if (!used[strands[k][i]]) ub--;\n  ub++;\n  if (result < ub)\n    for (int i = 0; i < strands[k].size(); i++) {\n      int j = strands[k][i];\n      if (!used[j]) rec(j, d+1, ub);\n    }\n  used[k] = 0;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < 100; i++)\n      strands[i].clear();\n    fill(used, used+100, false);\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    result = 0;\n    for (int i = 0; i < 100; i++)\n      rec(i, 1, n+1);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,1000){\n\t\t\treps(j,n){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,n){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==1)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<list>\n#include<queue>\n\n#define MAX 110\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\ntypedef vector<Node> graph;\ntypedef list< vector<int> > forest;\n\nvoid MakeForest(const graph &g, bool exist[MAX], forest &f){\n  bool vis[MAX]={false};\n  for(int x=0;x<MAX;++x){\n    if(!vis[x]&&exist[x]){\n      queue<int> q;\n      bool tvis[MAX]={false};\n      q.push(x);\n      tvis[x]=true;\n      while(!q.empty()){\n\tint now=q.front();q.pop();const set<int> &C=g[now].con;\n\tfor(set<int>::iterator its=C.begin();its!=C.end();++its){\n\t  if(!tvis[*its]){tvis[*its]=true;q.push(*its);}\n\t}\n      }\n      vector<int> tmp;\n      f.push_back( tmp );\n      for(int i=0;i<MAX;++i){\n\tif(tvis[i]){\n\t  vis[i]=true;\n\t  f.back().push_back( i );\n\t}\n      }\n    }\n  }\n}\n\nint Backtrack(int pos, int now, int &bans, bool vis[], int memo[], const graph &G){\n  const set<int> &C = G[pos].con;\n  int ret = now;\n  if(vis[pos]){return now;}\n  vis[pos]=true;\n  if(now+memo[pos]<=bans)return bans;\n  for(set<int>::iterator itc=C.begin();itc!=C.end();++itc){\n    int nx = *itc;\n    bans=max(bans,now+1);\n    ret=max(ret,Backtrack(nx,now+1,bans,vis,memo,G) );\n    bans=max(bans,ret);\n  }\n  vis[pos]=false;\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 2;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    graph G(MAX);\n    forest F;\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      G[a].con.insert(b);\n      G[b].con.insert(a);\n    }\n\n    MakeForest(G,exist,F);\n\n    int memo[MAX];\n    for(int i=0;i<MAX;++i){\n      memo[i]=MAX*MAX;\n    }\n    for(forest::iterator itf=F.begin();itf!=F.end();++itf){\n      if((*itf).size()<=ans)continue;\n      for(int i = 0; i < (*itf).size(); ++i){\n\tint st=(*itf)[i];\n\tbool vis[MAX]={false,};\n\tint btret = Backtrack( st, 0, ans, vis, memo, G );\n\tmemo[st]=btret;\n\tans=max(ans,btret);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=1;\n\tvisit[n]=1;\n\tfor(int i=0;i<edge[n].size();i++) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t}\n\t}\n\tvisit[n]=0;\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfor(int i=0;i<100;i++) edge[i].clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;b--;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=0;i<100;i++) mx=max(mx,solve(i));\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint ans;\n\nvoid Dfs(vector<int> way[100],bool used[100],int n,int d){\n\t//printf(\"%d,%d\\n\",n,d);\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tif(used[way[n][i]]) continue;\n\t\tDfs(way,used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tvector<int> way[100];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tDfs(way,used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <bitset>\n#include <map>\n#include <fstream>\nusing namespace std;\n\n#define MSG(a) cout<< #a << \" = \" << a <<endl;\n\nconst int MAX_V = 100;\n\nstruct edge\n{\n\tint num;\n\tedge(int n):num(n){};\n\tvector<edge*> es;\n};\ntypedef pair<int, edge*> Pe;\n\nint main()\n{\n\t//ifstream ifs(\"data.txt\");\n\n\tint n;\n\twhile( cin >> n && n)\n\t{\n\t\tvector<edge> edges;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tedges.push_back(edge(i));\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\t\n\t\t\tedges[a].es.push_back(&edges[b]);\n\t\t\tedges[b].es.push_back(&edges[a]);\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t{\n\t\t\tbitset<MAX_V> flags;\n\n\t\t\tstack<Pe> stc;\n\t\t\tstc.push(make_pair(1, &edges[i]));\n\n\t\t\twhile(!stc.empty())\n\t\t\t{\n\t\t\t\tPe e = stc.top(); stc.pop();\n\t\t\t\tflags[e.second->num] = true;\n\t\t\t\tbool flag = true;\n\n\t\t\t\tfor(int i = 0; i < e.second->es.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif(!flags[e.second->es[i]->num])\n\t\t\t\t\t{\n\t\t\t\t\t\tstc.push(make_pair(e.first + 1, e.second->es[i]));\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag || e.second->es.empty())\n\t\t\t\t\tres = max(res, e.first);\n\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.sync(); cin.get();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,q[z],l[z],la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 101\nint main(){\n\tint n,i,j,k,x,t,min,max,temp,pre;\n\tbool table[MAX][MAX];\n\tbool kouho[MAX];\n\tint data[MAX];\n\twhile(cin>>n){\n\t\tif(n==0){break;}\n\t\tfor(i=0;i<MAX;i++){\n\t\t\tfor(j=0;j<MAX;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t}\n\t\t\tdata[i]=0;\n\t\t}\n\t\tfor(k=0;k<n;k++){\n\t\t\tcin>>i>>j;\n\t\t\ttable[i][j]=1;\n\t\t\ttable[j][i]=1;\n\t\t}\n\t\tmax=0;\n\t\tfor(x=1;x<MAX;x++){\n\t\t\tt=0;\n\t\t\tdata[0]=x;\n\t\t\tpre=0;\n\t\t\ttemp=0;\n\t\t\twhile(1){\n\t\t\t\tmin=0;\n\t\t\t\tfor(i=0;i<MAX;i++){\n\t\t\t\t\tkouho[i]=table[data[t]][i];\n\t\t\t\t}\n\t\t\t\tfor(i=0;data[i]!=0;i++){\n\t\t\t\t\tkouho[data[i]]=0;\n\t\t\t\t}\n\t\t\t\tfor(i=1;i<MAX;i++){\n\t\t\t\t\tif(kouho[i]==1 && i>temp){\n\t\t\t\t\t\tmin=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(min==0){\n\t\t\t\t\tmax=(max>t)?max:t+1;\n\t\t\t\t\ttemp=data[t];\n\t\t\t\t\tdata[t]=0;\n\t\t\t\t\tt-=1;\n\t\t\t\t\tif(t==-1){break;}\n\t\t\t\t}else{\n\t\t\t\t\ttemp=0;\n\t\t\t\t\tt+=1;\n\t\t\t\t\tdata[t]=min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nmap< int, vector<int> > edge;\nmap< int, vector<int> >::iterator mit;\nmap< set<int>, int > memo;\n\nint dfs(int vertex, set<int> visited) {\n    int result;\n    if(memo.count(visited)) return memo[visited];\n    visited.insert(vertex);\n    result = visited.size();\n    for(int i=0; i<edge[vertex].size(); i++) {\n        if(visited.count(edge[vertex][i])) continue;\n        result = max(result, dfs(edge[vertex][i], visited));\n    }\n    return memo[visited] = result;\n}\n\nint solve() {\n    int result = 0;\n    set<int> visited;\n    for(mit=edge.begin(); mit!=edge.end(); mit++) {\n        memo.clear();\n        result = max(result, dfs(mit->first, visited));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            edge[--u].push_back(--v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint r[110][110],vf[110],ans;\nvoid dfs(int cr,int len,char f[]){\n\tint i,j,ff=0;\n\tchar s[110];\n\tfor(i=1;i<=100;i++){\n\t\tif(r[cr][i]==1 && f[i]==0){\n\t\t\tff=1;\n\t\t\tvf[i]=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,len+1,f);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0){\n\t\tans=MAX(ans,len);\n\t\t//printf(\"(%d-%d)\\n\",cr,ans);\n\t\tif(vf[cr]==0){\n\t\t\tchar s[110];\n\t\t\tvf[cr]=1;\n\t\t\tmemset(s,0,sizeof(s));\n\t\t\ts[cr]=1;\n\t\t\tdfs(cr,1,s);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x,y,z;\n\tchar f[110];\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(r,0,sizeof(r));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tr[a][b]=r[b][a]=1;\n\t\t}\n\t\tx=110;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tz=0;\n\t\t\tfor(j=1;j<=100;j++)if(r[i][j]==1)z++;\n\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t}\n\t\t//printf(\"y:%d\\n\",y);\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\tmemset(vf,0,sizeof(vf));vf[y]=1;\n\t\tdfs(y,1,f);\n\t\t\n\t\twhile(1){\n\t\t\tx=110;\n\t\t\tfor(i=1;i<=100;i++){\n\t\t\t\tif(vf[i]==1)continue;\n\t\t\t\tz=0;\n\t\t\t\tfor(j=1;j<=100;j++)if(vf[j]==0 && r[i][j]==1)z++;\n\t\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t\t}\n\t\t\tif(x==110)break;\n\t\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\t\tvf[y]=1;\n\t\t\tdfs(y,1,f);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint i,j;\nint edge[100][100];\ntypedef struct{\n\tint from;\n\tint to;\n}t_edge;\nt_edge edge2[100];\nint c[100];\nint used[100];\nint m;\n\nint max(int a,int b){\n\tif(a>=b)return a;\n\telse return b;\n}\n\nint solve(int from,int to){\n\tused[from]=1;\n\tint x=0;\n\tfor(int k=0;k<c[to];k++){\n\t\tif(used[edge[to][k]]!=1){\n\t\t\tx=max(x,solve(to,edge[to][k]));\n\t\t}\n\t}\n\treturn x+1;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\tm=0;\n\t\tfor(i=0;i<100;i++)for(j=0;j<100;j++)edge[i][j]=0;\n\t\tfor(i=0;i<100;i++)c[i]=0;\n\t\tfor(i=0;i<100;i++)used[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a][c[a]++]=b;\n\t\t\tedge[b][c[b]++]=a;\n\t\t\tedge2[i].from=a;\n\t\t\tedge2[i].to=b;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<100;j++)used[j]=0;\n\t\t\tm=max(m,solve(edge2[i].from,edge2[i].to));\n\t\t\tfor(j=0;j<100;j++)used[j]=0;\n\t\t\tm=max(m,solve(edge2[i].to,edge2[i].from));\n\t\t}\n\t\tprintf(\"%d\\n\",m+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=1;\n\tvisit[n]=1;\n\tfor(int i=0;i<edge[n].size();i++) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t}\n\t}\n\tvisit[n]=0;\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfor(int i=0;i<n;i++) edge[i].clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;b--;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=0;i<100;i++) mx=max(mx,solve(i));\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 0;j < rings.size();j++){\n\tif(neib[rings[j]].size() == i && onceused[rings[j]] == 0){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }  \n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        vector< vector<int> > d(N, vector<int>() );\n        queue< vector<int> > q;\n        bool findFlg[N] = {false};\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b); d[b].push_back(a);\n            if(!findFlg[a]){\n                vector<int> v; v.push_back(a);\n                q.push(v);\n            }\n            if(!findFlg[b]){\n                vector<int> v; v.push_back(b);\n                q.push(v);\n            }\n            findFlg[a] = true; findFlg[b] = true;\n        }\n\n        int ans = -1;\n        while(!q.empty()){\n            vector<int> nowv = q.front();\n            q.pop();\n            int now = nowv.back();\n\n            REP(i, d[now].size()){\n                int next = d[now][i];\n                if(find(nowv.begin(), nowv.end(), next) == nowv.end()){\n                    vector<int> nextv = nowv;\n                    nextv.push_back(next);\n                    q.push(nextv);\n                } else{\n                    int s = nowv.size();\n                    ans = max(ans, s);\n                }\n            }\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 50000841;\nconst int m = 100;\t//The range of number\n\t\nint n;\nint a, b;\nbool table[100][100];\nbool vis[100] = {false};\n\nint dfs( int pos ){\n\tint ret = 0;\n\tvis[pos] = true;\n\tfor( int npos = 0; npos < m; npos++ ){\n\t\tif( table[pos][npos] && !vis[npos] )\n\t\t\tret = max(ret, dfs(npos) + 1);\n\t}\n\tvis[pos] = false;\n\treturn ret;\n}\n\nint main(){\n\tint i;\n\t\n\twhile( cin >> n ){\n\t\tif(!n) return 0;\n\t\tfor( i = 0; i < m * m; i++ ) table[i/m][i%m] = false;\n\t\tfor( i = 0; i < n; i++ ){\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\ttable[a][b] = (table[b][a] = true);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = 0; i < m; i++ )\n\t\t\tans = max(dfs(i) + 1, ans);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>                                                                                   \n#include<cstring>                                                                                  \n#include<algorithm>                                                                                \n#include<vector>                                                                                   \nusing namespace std;                                                                               \n\nint n;                                                                                             \nvector<short> G[100];                                                                              \nbool D[100];                                                                                       \nint r,k;\n\nvoid solve(int m)\n{\n    D[m]=1;\n    r=max(r,++k);\n    for(vector<short>::iterator it=G[m].begin();it!=G[m].end();it++){                              \n        if(!D[*it]){                                                                               \n            solve(*it);                                                                 \n        }                                                                                          \n    }                                                                                              \n    --k;\n    D[m]=0;\n}                                                                                                  \n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            solve(i);\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<sstream>\nusing namespace std;\nvector< vector<int> > Hg(100);\nbool used[100];\nint solve(int);\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<100;i++){\n      Hg[i].clear();\n    }\n    for(int i=0,a,b;i<n;i++){\n      cin >> a >> b;\n      Hg[a-1].push_back(b-1);\n      Hg[b-1].push_back(a-1);\n    }\n    memset(used,false,sizeof(used));\n    int ans = 0;\n    for(int i=0;i<100;i++){\n      ans = max(ans,solve(i));\n    }\n    cout << ans << endl;\n  }\n}\nint solve(int a){\n  if(used[a] || Hg[a].empty() ) return 0;\n  used[a] = true;\n  int cnt = 0;\n  for(int i=0,l=Hg[a].size();i < l;i++){\n      cnt = max(cnt,solve(Hg[a][i]));\n  }\n  used[a] = false;\n  return cnt + 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nint n;\nint f[101],t[101];\nint ans=0;\nint nf[101],nt[101];\nbool use[101];\nbool nuse[101];\n\nvoid dfs(int x,int y,int res,bool usen[101],bool nusen[101]){\n\tans=max(ans,res);\n\tfor(int i=nf[x];i<=nt[y];i++){\n\t\tif(usen[i]==false){\n\t\t\tusen[i]=true;\n\t\t\tif(x==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(min(t[i],y),max(t[i],y),res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(x==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(min(f[i],y),max(f[i],y),res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(y==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(min(x,t[i]),max(x,t[i]),res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(y==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(min(x,f[i]),max(x,f[i]),res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(x==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(x==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tusen[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(use,false,sizeof(use));\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&f[i],&t[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++)nf[i]=99,nt[i]=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(f[i]<f[j] || (f[i]==f[j] && t[i]<t[j])){\n\t\t\t\t\tswap(f[i],f[j]);\n\t\t\t\t\tswap(t[i],t[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnf[f[i]]=min(i,nf[f[i]]);\n\t\t\tnf[t[i]]=min(i,nf[t[i]]);\n\t\t\tnt[f[i]]=max(i,nt[f[i]]);\n\t\t\tnt[t[i]]=max(i,nt[t[i]]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tuse[i]=true;\n\t\t\tnuse[f[i]]=true;\n\t\t\tnuse[t[i]]=true;\n\t\t\tdfs(f[i],t[i],1,use,nuse);\n\t\t\tuse[i]=false;\n\t\t\tnuse[f[i]]=false;\n\t\t\tnuse[t[i]]=false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nint check_count;\n\nint chack(int p,int t,vector<bool>& flag){\n\tcheck_count++;\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = chack(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttarget.insert(t);\n\t\t\ttar(t,flag);\n\t\t\t\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\t//printf(\"->%d\\n\",*it);\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tcheck_count = 0;\n\t\t\tchack(*it,1,flag);\n\t\t\tif( check_count <= max){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = Solve(*it);\n\t\t\t//printf(\"s:%d\\n\",s);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <bitset>\n#include <stack>\n\nusing namespace std;\n\n// connections between nodes\n// eg. _connections[(i-1)*100+(j-1)]==1 means i and j are connected\n// use toIdx(i,j) to conver row & column to the index\n// TODO: the matrix can be half size since the connections are bidirectional.\n//       however it might be easier for looking up by keeping this way.\nbitset<100*100> _connections;\n\nbitset<100> _isVisited;\n\n// conver row & column to the flatten matrix index\n// note that the matrix indices are from 1 to 100 (not 0 to 99)\nint toIdx(int row, int col){\n    return (row-1)*100+(col-1);\n}\n\nvoid addChain(int head, int tail){\n    int tmp;\n    // update the connections\n    _connections[toIdx(head,tail)] = 1;\n    _connections[toIdx(tail,head)] = 1;\n}\n\n// length: holds the graph length upto the last visited node\nint findLongestFromNode(int node, int length){\n    if (_isVisited[node]==1){\n        return 0;\n    }\n    _isVisited[node] = 1;\n    \n    // check childs\n    int max_child_length = -1;\n    for (int j = 1; j <= 100; j ++){\n        if (_connections[toIdx(node,j)]==0)\n            continue;\n        int child_length = findLongestFromNode(j,length);\n        if (child_length > max_child_length)\n            max_child_length = child_length;\n    } \n    // isolated node returns -1\n    if (max_child_length == -1)\n        return -1;\n    return (max_child_length+1);\n}\n\nint findLongest(){\n    int length = 0;\n    int max_length = 0;\n    for (int i = 1; i <= 100; i ++){\n        _isVisited.reset();\n        // search for the longest that starts FROM THE NODE i\n        length = findLongestFromNode(i,0);\n        // update maximum length\n        if (length > max_length)\n            max_length = length;\n    }\n    return max_length;\n}\n\nint main(){\n    //ifstream cin(\"input.txt\");\n    \n    while (true){\n        // initialize the connection matrix\n        _connections.reset();\n        // input the number of chains\n        int n = -1;\n        if (!(cin >> n) | n == 0)\n            break;\n        // input chains\n        for (int i = 0; i < n; i++){\n            int chain_head = -1;\n            int chain_tail = -1;\n            cin >> chain_head >> chain_tail;\n            addChain(chain_head, chain_tail);\n        }\n        // find the longest chain\n        cout << findLongest() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxcnt;\nbool vis[100];\nint graph_lens[100];\nint graph[100][100];\n\nvoid search(int i, int cnt, int ub) {\n  if(maxcnt<cnt) maxcnt=cnt;\n  vis[i] = true;\n  int len = graph_lens[i];\n  int *edg = graph[i];\n  ub++;\n  for(int j = 0; j < len; j++) {\n    if(!vis[edg[j]])ub--;\n  }\n  if(maxcnt < ub) {\n    cnt++;\n    for(int j = 0; j < len; j++) {\n      int to = edg[j];\n      if(!vis[to]) search(to, cnt, ub);\n    }\n  }\n  vis[i] = false;\n}\n\nint main() {\n  while(true) {\n    int n; scanf(\"%d\", &n);\n    if(n==0) break;\n    fill(vis, vis+100, false);\n    fill(graph_lens, graph_lens+100, 0);\n    for(int i = 0; i < n; i++) {\n      int a,b; scanf(\"%d%d\", &a, &b); a--; b--;\n      graph[a][graph_lens[a]++] = b;\n      graph[b][graph_lens[b]++] = a;\n    }\n    maxcnt = 0;\n    for(int i = 0; i < 100; i++) {\n      search(i,1,n+1);\n    }\n    printf(\"%d\\n\", maxcnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst long long int INF_=1<<60;\n\nint DFS(vector<int> G[],vector<bool> &has_done,int v){\n\tint result=0;\n\thas_done[v]=true;\n\tREP(i,0,G[v].size()){\n\t\tif(has_done[G[v][i]]) continue;\n\t\tresult=max(result,DFS(G,has_done,G[v][i]));\n\t}\n\thas_done[v]=false;\n\treturn result+1;\n}\n\nint DFS(vector<int> G[],vector<bool> &&has_done,int v){\n\tint result=0;\n\thas_done[v]=true;\n\tREP(i,0,G[v].size()){\n\t\tif(has_done[G[v][i]]) continue;\n\t\tresult=max(result,DFS(G,has_done,G[v][i]));\n\t}\n\thas_done[v]=false;\n\treturn result+1;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile(cin >> N&&N){\n\t\tvector<int> G[100];\n\t\tREP(i,0,N){\n\t\t\tint A,B;\n\t\t\tcin >> A >> B;\n\t\t\t--A;\n\t\t\t--B;\n\t\t\tG[A].push_back(B);\n\t\t\tG[B].push_back(A);\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,0,100) ans=max(ans,DFS(G,vector<bool>(100),i));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a){\n\t// cout<<a<<endl;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tint next=vv[a][i];\n\t\tif(vis[next]) continue;\n\t\tvis[a]=1;\n\t\tret=max(ret,dfs(next));\n\t\tvis[a]=0;\n\t}\n\treturn ret+1;\n}\n// int solve2(int st){\n        // int ret = 0;\n        // rep(i,edge[st].size()){\n            // int next = edge[st][i];\n            // if(visit[next]==0){\n                // visit[next]=1;\n                // ret = max(solve2(next)+1, ret);\n                // visit[next]=0;\n            // }\n        // }\n        // return ret;\n    // }\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvv=vector<vint>(100);\n\t\tvis=vint(100,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,100) vis[i]=0;\n\t\trep(i,100){\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tint t=dfs(i);\n\t\t\t// cout<<i<<\" \"<<t<<endl;\n\t\t\tans=max(ans,t);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\n\n\nbool visited[100];\nvector<int> g[100];\nint n;\nint dfs(int now) {\n  visited[now] = 1;\n  int res = 0;\n  FOR(it, g[now]) {\n    if (visited[*it]) continue;\n    res = max(res, dfs(*it));\n  }\n  visited[now] = 0;\n  return res + 1;\n}\n\nint main() {\n  while(cin >> n, n) {\n    REP(i, n) g[i].clear();\n    vector<int> num(n);\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      g[a].push_back(b);\n      g[b].push_back(a);\n      num[a]++;\n      num[b]++;\n    }\n    vector<bool> memo(n);\n    vector<vector<int> > connected;\n    REP(i, n) {\n      if (memo[i]) continue;\n      queue<int> Q;\n      Q.push(i);\n      vector<int> tmpv;\n      while(!Q.empty()) {\n        int now = Q.front(); Q.pop();\n        if (memo[now]) continue;\n        memo[now] = 1;\n        tmpv.push_back(now);\n        FOR(it, g[now]) {\n          if (memo[*it]) continue;\n          Q.push(*it);\n        }\n      }\n      connected.push_back(tmpv);\n    }\n    int ans = 0;\n    REP(i, connected.size()) {\n      if (ans > connected[i].size()) continue;\n      int mi = INF;\n      FOR(it, connected[i]) {\n        //cout << *it << \" \";\n        mi = min(mi, num[*it]);\n      }\n      //cout << endl;\n      REP(j, connected[i].size()) {\n        if (num[connected[i][j]] == mi) {\n          memset(visited, 0, sizeof(visited));\n          //cout << \"j \" << connected[i][j] << endl;\n          ans = max(ans, dfs(connected[i][j]));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\n#define INF 1000000000\n#define reps(i,f,n) for(int i = f; i < int(n); i++)\n#define rep(i,n) reps(i,0,n)\n\nusing namespace std;\n\n\nvector<int> e[128];\nint used[128];\nint ans;\n\nint func(int index, int cost){\n\tif(used[index])return cost-1;\n\tint x = 0;\n\trep(i,e[index].size()){\n\t\tused[index] = 1;\n\t\tx = max(func(e[index][i], cost+1), x);\n\t\tused[index] = 0;\n\t}\n\treturn x;\n}\n\n\nint main(void){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint a,b;\n\t\tint mi = 0;\n\t\tans = 0;\n\t\trep(i,128)e[i].clear();\n\t\t\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif(a > mi)mi = a;\n\t\t\tif(b > mi)mi = b;\n\t\t\te[b].push_back(a);\n\t\t\te[a].push_back(b);\n\t\t}\n\t\tmi++;\n\t\t\n\t\treps(i,1,mi){\n\t\t\trep(i,128)used[i]=0;\n\t\t\tans = max(func(i,1), ans);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef struct node{\n    int size,i;\n}NODE;\n\nvector<int> vec[101];\nbool ch[101]={};\nstack<int> st;\nvector<NODE> s;\nint maxx = -1;\nint maxNODE = -1;\nint maxone = -1;\nint sss = -1;\nint tmp = -1;\nint mmm = -1;\n\nbool comp(const NODE &a,const NODE &b){\n    return a.size < b.size;\n}\n\n\nvoid DFS(int i,int val){\n    if(mmm < val)mmm = val;\n    if(val > maxx)maxx = val,mmm = val;\n    //printf(\"%d \",i);\n    for (int k=0; k<vec[i].size(); k++) {\n        if(!ch[vec[i][k]]){\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    \n    for (int i=1; i<=maxNODE; i++) {\n        NODE u;\n        u.i = i;\n        u.size = vec[i].size();\n        s.push_back(u);\n    }\n    tmp = s[0].size;\n    sort(s.begin(),s.end(),comp);\n    bool jjj = false;\n    for (int i=1; i<=maxNODE; i++) {\n        maxone = -1;\n        mmm = -1;\n        ch[s[i].i] = true;\n        DFS(s[i].i,0);\n        ch[s[i].i] = false;\n        maxone = mmm;\n        if(jjj && tmp != s[i].size)break;\n        if(sss > maxone)jjj = true;\n        if(sss < maxone)sss = maxone,tmp = s[i].size;\n    }\n    printf(\"%d\\n\",maxx+1);\n    for (int i=1; i<=maxNODE; i++) {\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 101;\n\nint n, a, b;\nbool vis[N], G[N][N];\n\nint dfs(int p){\n  vis[p] = true;\n  int res = 1;\n  for(int i=1;i<N;i++) if(G[p][i] && !vis[i]) res = max(res, dfs(i) + 1);\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[N], false);\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      G[a][b] = G[b][a] = true;\n    }\n    int ans = 0;\n    for(int i=1;i<N;i++){\n      fill(vis, vis+N, false);\n      ans = max(ans, dfs(i));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n\nconst int N=101;\nint v[N][N];\nstd::vector<int> g[N];\nint used[N];\n\nint dfs(int v)\n{\n\tused[v]=1;\n\tint res=0;\n\tfor (auto &to : g[v]){\n        if (used[to])\n\t\t\tcontinue;\n        res=std::max(res,dfs(to)+1);\n    }\n\tused[v]=0;\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\n\t\t\tbreak;\n\t\t\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(int i=0;i!=N;++i)\n\t\t\tg[i].clear();\n\t\t\n\t\tfor(int i=0;i!=n;++i){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t--x,--y;\n\t\t\tv[x][y]=v[y][x]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i!=N;++i)\n\t\t{\n\t\t\tfor(int j=0;j!=N;++j){\n\t\t\t\tif(v[i][j])\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=2;\n\t\tfor(int i=0;i!=N;++i)\n\t\t\tans=std::max(ans,dfs(i)+1);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint trees[101];\nint onceused[101];\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    memset(onceused, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      mind = 10000;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] != 0)continue;\n\tmind = min(mind, (int)neib[rings[j]].size());\n      }\n      if(neib[rings[i]].size() == mind){\n\tans = max(ans, dfs(rings[i]));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nint n;\nint f[101],t[101];\nint ans=0;\nbool use[101];\nbool nuse[101];\n\nvoid dfs(int x,int y,int res,bool usen[101],bool nusen[101]){\n\tans=max(ans,res);\n\tfor(int i=0;i<n;i++){\n\t\tif(usen[i]==false){\n\t\t\tusen[i]=true;\n\t\t\tif(x==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(t[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(x==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(f[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(y==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(x,t[i],res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(y==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(x,f[i],res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(x==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(x==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tusen[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(use,0,sizeof(use));\n\t\tmemset(nuse,0,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&f[i],&t[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tuse[i]=true;\n\t\t\tnuse[f[i]]=true;\n\t\t\tnuse[t[i]]=true;\n\t\t\tdfs(f[i],t[i],1,use,nuse);\n\t\t\tuse[i]=false;\n\t\t\tnuse[f[i]]=false;\n\t\t\tnuse[t[i]]=false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n//int node[101][101];\nint visit[101];\nint ans,last;\nint die[101];\nint flag;\n\nvoid dfs(int now, int cnt, int *st, vector<vector<int> >& vv){\n\tif( cnt>ans ){\n\t\tans=cnt;\n\t\tlast = now;\n\t\tflag = 1;\n\t}\n\tfor(int next=0; next<vv[now].size(); next++)if( !visit[vv[now][next]] ){\n\t\tint k = vv[now][next];\n\t\tvisit[k] = die[k] = 1;\n\t\tst[cnt] = k;\n\t\tdfs(k,cnt+1,st,vv);\n\t\tvisit[k] = 0;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tset<int> s;\n\t\tvector<vector<int> > vv(n+1);\n\t\tans = 0;\n\t\t//memset(node,0,sizeof(node));\n\t\tmemset(visit,0,sizeof(visit));\n\t\tmemset(die,0,sizeof(die));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a,b; cin>>a>>b;\n\t\t\t//node[a][b] = node[b][a] = 1;\n\t\t\tvv[a].push_back(b);\n\t\t\tvv[b].push_back(a);\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint tmp[101];\n\t\tfor(set<int>::iterator it=s.begin(); it!=s.end(); it++)if( !die[*it] ){\n\t\t\tflag = 0;\n\t\t\t\n\t\t\tvisit[*it]=1;\n\t\t\ttmp[0] = *it;\n\t\t\tdfs(*it,1,tmp,vv);\n\t\t\tvisit[*it]=0;\n\t\t\t\n\t\t\tdie[last] = 0;\n\t\t\t//printf(\"*it:%d\\n\",*it);\n\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxcnt;\nbool vis[100];\nint graph_lens[100];\nint graph[100][100];\n\nvoid search(int i, int cnt) {\n  if(vis[i]) return;\n  if(maxcnt<cnt) maxcnt=cnt;\n  vis[i] = true;\n  int len = graph_lens[i];\n  int *edg = graph[i];\n  cnt++;\n  for(int j = 0; j < len; j++) {\n    int to = edg[j];\n    search(to, cnt);\n  }\n  vis[i] = false;\n}\n\nint main() {\n  while(true) {\n    int n; scanf(\"%d\", &n);\n    if(n==0) break;\n    fill(vis, vis+100, false);\n    fill(graph_lens, graph_lens+100, 0);\n    for(int i = 0; i < n; i++) {\n      int a,b; scanf(\"%d%d\", &a, &b); a--; b--;\n      graph[a][graph_lens[a]++] = b;\n      graph[b][graph_lens[b]++] = a;\n    }\n    maxcnt = 0;\n    for(int i = 0; i < 100; i++) {\n      search(i,1);\n    }\n    printf(\"%d\\n\", maxcnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=1;\n\t\t\tvisit[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t\tvisitone[a]=visitone[b]=0;\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,1000){\n\t\t\treps(j,n){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,n){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==1)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv/4*3;i++)\n\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint c[100][2];\n\nint chain(int e,int l,int done[]){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1,done);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1,done);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int done[100];\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0,done);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[100], r[100], G[100][199];\nint rec(int pos) {\n\tv[pos] = 1; int ret = 0;\n\tfor(int i = 0; i < r[pos]; i++) {\n\t\tif(!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile(scanf(\"%d%d\", &N), N) {\n\t\tfor(int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B;\n\t\t\tG[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,a,b;\nint q[10000],l[100],head,tail,last,best,ans;\nint cantop[100],can[100][100];\nbool vis[100],set[100];\nvoid DFS(int x,int len){\n\tif(len>best){last=x;best=len;}\n\tvis[x]=true,set[x]=true;\n\tfor(int i=0;i<cantop[x];i++){\n\t\tif(!vis[can[x][i]]){\n\t\t\tDFS(can[x][i],len+1);\n\t\t\tvis[can[x][i]]=false;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\trep(i,100)cantop[i]=false;\n\trep(i,n){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tcan[a][cantop[a]]=b,can[b][cantop[b]]=a;\n\t\tcantop[a]++,cantop[b]++;\n\t}\n\trep(i,100)set[i]=false;\n\tans=0;\n\tfor(int i=0;i<100;i++){\n\t\tif(!set[i]){\n\t\trep(i,100)vis[i]=false;\n\t\tbest=0;\n\t\tDFS(i,1);\n\t\trep(i,100)vis[i]=false;\n\t\tbest=0;\n\t\tDFS(last,1);\n\t\tans=max(ans,best);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0508>\n?????????============================================================\n?????????????????°?????????????´?????????????.????????°?????£??´??°??????????????????,?´?????????\\??????.\n?´?????????????????????°????????°????????° a, b ??????????????????.?????????,[a, b] ??¨?¨???°??????.\n?????°????´??????????,??????????´???¨??????????´????????????°????????????????????°???????????´???,??????????????°?????¨????????§,\n?????????????´?????????????????????¨?????§??????,??????????????§????????????????????¨?????¶?????¨?????????.\n????????°,[1, 3] ??¨ [3, 4] ??¨???????´?????????? [1, 3, 4] ??¨??????????????§??????.\n?´???¨??????????????????????????´??°??????????????????????????°?????¨????????§?????????????????¨?????§??????????????¨??????.\n\n????????°,??? [1, 3, 4] ??¨?´? [5, 1] ????????? [5, 1, 3, 4] ?????§???,\n??? [1, 3, 4] ??¨??? [2, 3, 5] ?????????, ????????§??????????????????????????¢?????????.\n??? [1, 3, 4] ??¨??? [4, 6, 1] ?????????, ????????¢?????§??????.\n\n????????????????§?????????¢?????§?????????, ????????????????????¨??§,\n????????°????????????????????°???????????????????????????????????£????????°????´?????????¨?????¶?????¨?????????.\n????????°,??? [1, 3, 4] ??¨???[2, 3, 5] ????????§??????,????????§??????????????????????????¢??????,\n[1, 3, 5],[2, 3, 4] ??¨?????????????????????,\n??? [1, 3, 4] ??¨??? [4, 6, 1] ????????§???????????????, \n[1, 3, 4, 6],[3, 4, 6, 1],[4, 6, 1, 3]???????????????????????????.\n\n???????????????????????????,??????????????°????????°???????????¨????????????. \n????????????????????°????´?????????????,??????????????????????????????????????????????????¨1?????\\????????????????????¢?????§??????.\n????????????????????§???????????????????±???????????????°?????????????????????.\n\n??\\???????????? ??????????????????????´?????????°??§????????£??´??° 1 ??? n ??? 100 ??????????????????,\n?????\\??? n ????????????????????????, ????????§???????????????\n2 ????????´??° a, b ?????????????????? 1 ??? a < b ??? 100 ??¨?????£?????????.\n????????? 2 ????????´??°??? 1 ???????´???????????????´??°?????¨??????.\n=================================================================\n??\\???=============================================================\n??\\???????????°????????????????????????????????????n ??? 0 ?????¨?????\\????????????????????????????????????????????°??? 10 ????¶?????????????\n================================================================\n??????=============================================================\n???????????????????????¨???????????§??????????????????????????????????????????\n================================================================\n?§£??¬=============================================================\n================================================================\n*/\n\nll ans;\nvoid dfs(ll n, ll dep, vector<vector<ll>>& G, vector<int>& used) {\n\tbool f = false;\n\tfor (auto next : G[n]) {\n\t\tif (used[next] == 0) {\n\t\t\tf = true;\n\t\t\tused[next] = 1;\n\t\t\tdfs(next, dep + 1, G, used);\n\t\t\tused[next] = 0;\n\t\t}\n\t}\n\tif (!f) {\n\t\tans = max(ans, dep);\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n;\n\twhile (cin >> n, n) {\n\t\tans = 0;\n\t\tvector<vector<ll>> G(101);\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tll x, y; cin >> x >> y; x--;y--;\n\t\t\tG[x].push_back(y); G[y].push_back(x);\n\t\t}\n\n\t\tvector<int> used(101, 0);\n\t\tfor (int i = 0; i < 101;i++) {\n\t\t\tused[i] = 1;\n\t\t\tdfs(i, 1, G, used);\n\t\t\tused[i] = 0;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > edges;\nbitset<100> used;\n\nint solve(int pos)\n{\n    used[pos] = true;\n\n    int ret = 1;\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        int next = edges[pos][i];\n        if(!used[next])\n            ret = max(ret, 1 + solve(next));\n    }\n\n    used[pos] = false;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        edges.assign(100, vector<int>(0));\n        for(int i=0; i<n; ++i){\n            int a, b;\n            cin >> a >> b;\n            edges[a-1].push_back(b-1);\n            edges[b-1].push_back(a-1);\n        }\n\n        int ret = 0;\n        for(int i=0; i<100; ++i)\n            ret = max(ret, solve(i));\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n        self.ans = self.ans if self.ans > temp else temp\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n    print(self.graph)\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))\n  del gc"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > E(100);\nbool visited[100];\n\nint solve(const int v)\n{\n  int res = 0;\n  visited[v] = true;\n  for (vector<int>::iterator it = E[v].begin(); it != E[v].end(); ++it) {\n    if (!visited[*it]) {\n      visited[*it] = true;\n      res = max(res, solve(*it)+1);\n      visited[*it] = false;\n    }\n  }\n  visited[v] = false;\n  return res;\n}\n\nint main()\n{\n  int n;\n  while (scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    for (int i = 0; i < 100; ++i)\n      E[i].clear();\n\n    for (int i = 0; i < n; ++i) {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a;\n      --b;\n      E[a].push_back(b);\n      E[b].push_back(a);\n    }\n\n    int ans = 0;\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < 100; ++i)\n      ans = max(ans, solve(i));\n\n    printf(\"%d\\n\", ans+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool once_used[100];\nbool used[100];\nint dfs(int v)\n{\n\tonce_used[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\tfill(once_used, once_used+100, false);\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint c[100][2];\nint n;\n\nint ring(int e,int l,int done[]){/*e:?????????e+1,e?????§???????????????l,???????????¨?±\\??´done*/\n    int i;\n    int cpy[100];\n    int templ;\n    int end = 1;\n    int lmax = l;\n    /*printf(\"called: ring(%d,%d,[\",e,l);\n    for(i=0;i<7;i++)printf(\"%d,\",done[i]);\n    printf(\"])\\n\");*/\n    for(i=0;i<100;i++)cpy[i]=done[i];\n    for(i=0;i<n;i++){/*?????????e+1????´??????¢???*/\n        if(c[i][0]==e+1&&cpy[c[i][1]-1]){\n            end = 0;\n            cpy[c[i][1]-1] = 0;\n            templ = ring(c[i][1]-1,l+1,cpy);\n            cpy[c[i][1]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n        if(c[i][1]==e+1&&cpy[c[i][0]-1]){\n            end = 0;\n            cpy[c[i][0]-1] = 0;\n            templ = ring(c[i][0]-1,l+1,cpy);\n            cpy[c[i][0]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n    }\n    /*printf(\"return(from ring(%d,%d)): %d)\\n\",e,l,lmax);*/\n    return end ? l : lmax;\n}\n\nint main(){\n    int i;\n    int done[100];/*done[i] 1:i+1???????????¨ 0;i+1????????¨???or?????´??????*/\n    int ans,tmp;\n    scanf(\"%d\",&n);\n    while(n){\n        for(i=0;i<100;i++)done[i]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&c[i][0],&c[i][1]);\n            done[c[i][0]-1] = 1;\n            done[c[i][1]-1] = 1;\n        }\n        ans = 0;\n        for(i=0;i<100;i++){/*?§?????????????????????????*/\n            if(done[i]){\n                done[i] = 0;\n                tmp = ring(i,1,done);\n                done[i] = 1;\n                if(tmp>ans)ans=tmp;\n            }\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> d[100];\nbool visited[100];\nint dist;\nint max_dist;\nvoid dfs(int s){\n\tdist++;\n\tif(dist > max_dist) max_dist = dist;\n\tvisited[s] = true;\n\tfor(int i = 0; i < d[s].size(); i++){\n\t\tint t = d[s][i];\n\t\tif(visited[t] == false){\n\t\t\tdfs(t);\n\t\t\tdist--;\n\t\t\tvisited[t] = false;\n\t\t}\n\t}\n\tvisited[s] = false;\n\treturn;\n}\nint main(){\n\tint N, a, b;\n\tfor(;;){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tmax_dist = 0;\n\t\tfor(int i = 0; i < 100; i++) d[i].clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\td[a].push_back(b);\n\t\t\td[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfill(visited, visited + 100, false);\n\t\t\tdist = 0;\n\t\t\tdfs(i);\n\t\t}\n\t\tprintf(\"%d\\n\", max_dist);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool g[101][101], use[101];\n\nint n;\n\nint dfs(int x){\n  int res = 1;\n  use[x] = true;\n  for(int i=1;i<=100;i++)\n    if(!use[i] && g[x][i])res = max(res,dfs(i)+1);\n  use[x] = false;\n  return res;\n}\n\nint main(){\n  int a,b;\n\n  while(cin>> n && n){\n    for(int i=1;i<=100;i++){\n      use[i] = false;\n      for(int j=1;j<=100;j++)g[i][j] = false;\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      g[a][b] = g[b][a] = true;\n    }\n\n    int ans = 0;\n    for(int i=0;i<=100;i++)ans = max(ans,dfs(i));\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int MAX = 100;\n\nbool visited[MAX];\n\nint dfs(int v, const std::vector<std::vector<int>> &G)\n{\n    int res = 0;\n    for (int to : G[v]) {\n        if (!visited[to]) {\n            visited[to] = 1;\n            res = std::max(res, dfs(to, G) + 1);\n            visited[to] = 0;\n        }\n    }\n    return res;\n\n}\n\nint main()\n{\n    int N;\n    while (1) {\n        std::cin >> N;\n        if (N == 0) {\n            break;\n        }\n        std::vector<std::vector<int>> G(MAX);\n        for (int i = 0; i < N; i++) {\n            int a, b;\n            std::cin >> a >> b;\n            a--; b--;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n    \n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            std::fill(visited, visited + MAX, 0);\n            res = std::max(res, dfs(i, G));\n        }\n    \n        std::cout << res << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > E(100);\nbool vv[100], ve[100][100];\n\nint solve(const int v)\n{\n  int res = 0;\n  vv[v] = true;\n  for (unsigned int i = 0; i < E[v].size(); ++i) {\n    if (!vv[E[v][i]] && !ve[v][E[v][i]] && !ve[E[v][i]][v]) {\n      ve[v][E[v][i]] = ve[E[v][i]][v] = true;\n      res = max(res, solve(E[v][i])+1);\n      ve[v][E[v][i]] = ve[E[v][i]][v] = false;\n    }\n  }\n  vv[v] = false;\n  return res;\n}\n\nint main()\n{\n  int n;\n  while (scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    for (int i = 0; i < 100; ++i)\n      E[i].clear();\n\n    for (int i = 0; i < n; ++i) {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a;\n      --b;\n      E[a].push_back(b);\n      E[b].push_back(a);\n    }\n\n    int ans = 0;\n    memset(vv, false, sizeof(vv));\n    memset(ve, false, sizeof(ve));\n    for (int i = 0; i < 100; ++i)\n      ans = max(ans, solve(i));\n\n    printf(\"%d\\n\", ans+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint ans;\n\nvoid Dfs(vector<int> way[100],bool used[100],int n,int d){\n\t//printf(\"%d,%d\\n\",n,d);\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tDfs(way,used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tans = 0;\n\t\tvector<int> way[100];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tDfs(way,used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n\n    for(j = 0; j < N; j++)\n    {\n\tfor(i = 0; i < N; i++)\n\t{\n\t    conn[j][i] = 0;\n\t}\n    }\n\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n\tscanf(\"%d %d\", &a, &b);\n\tconn[a][b] = 1;\n\tconn[b][a] = 1;\n    }\n\n    for(a = 0; a < N; a++)\n    {\n\tused[a] = 0;\n    }\n\n    max_length = 0;\n    for(a = 0; a < N; a++)\n    {\n\tlength = find_length(a, 1);\n\tif (length > max_length)\n\t{\n\t    max_length = length;\n\t}\n    }\n    printf(\"%d\\n\", max_length);\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\n\nint saiki(int a){\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111)load[i].clear();\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\treps(i,n){\n\t\t\tans = max(ans, saiki(i));\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[to]=false;\n            solve(i,len+1);\n            points[to]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<100;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\n#include <fstream>\n#include <bitset>\nint longest_path(std::bitset<100>& bit_set, int current, const std::vector<std::vector<int>>& vec) {\n\tif (bit_set[current]) return 0;\n\tbit_set[current] = true;\n\tint max = 1;\n\tfor (const auto next : vec[current]) {\n\t\tmax = std::max(max, longest_path(bit_set, next, vec) + 1);\n\t}\n\tbit_set[current] = false;\n\treturn max;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<std::vector<int>> edges(100);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tint a, b; std::cin >> a >> b; --a; --b;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tstd::bitset<100> bit_set;\n\t\tint max = 0;\n\t\tfor (auto i = 0; i < 100; ++i) {\n\t\t\tmax = std::max(max, longest_path(bit_set, i, edges));\n\t\t}\n\t\tstd::cout << max << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nvi len;\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tlen.pb(sz(lis[i]));\n\t\t}\n\t\tsort(len.begin(),len.end());\n\t\tint k=len[sz(len)/2];\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tif(sz(lis[i])<=k)\n\t\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <bitset>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nvector<vector<int> > G(100);\ntypedef bitset<100> bs;\nmap<pair<int,bs>, int> dp;\n\nnamespace std {\n    bool operator<(const bs& a, const bs& b){\n        rep(i, 100){\n            if(a[i] != b[i]) return a[i] < b[i];\n        }\n        return false;\n    }\n}\n\nint dfs(int v, bs vis){\n    auto it = dp.find(make_pair(v, vis));\n    if(it != dp.end())\n        return it->second;\n\n    vis[v] = true;\n    int res = 1;\n    rep(i, G[v].size()){\n        int to = G[v][i];\n        if(!vis[to]){\n            res = max(res, dfs(to, vis) + 1);\n        }\n    }\n    dp[make_pair(v, vis)] = res;\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 100) G[i].clear();\n        rep(i, n){\n            int a, b; cin >> a >> b;\n            G[a - 1].push_back(b - 1);\n            G[b - 1].push_back(a - 1);\n        }\n        bs init;\n        int ans = 1;\n        rep(i, 100){\n            ans = max(dfs(i, init), ans);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int chain[101];\n    int chlen;\n    int node[101][100];\n    int nolen[101];\n    bool used[101];\n    int data[101];\n    int n;\n    int a, b;\n    int i,j;\n    int top;\n    int max;\n    bool found;\n    cin >> n;\n    while(n){\n        max = 0;\n        chlen = 0;\n        for(i=1;i<101;i++){\n            used[i] = false;\n            nolen[i] = 0;\n            data[i] = 0;\n        }\n        for(i=0;i<n;i++){\n            cin >> a >> b;\n            node[a][nolen[a]] = b;\n            nolen[a]++;\n            node[b][nolen[b]] = a;\n            nolen[b]++;\n        }\n        for(i=1;i<101;i++){\n            if(nolen[i]){\n                chain[chlen] = i;\n                chlen++;\n                top = i;\n                used[top] = true;\n                while(chlen){\n                    found = false;\n                    cout << endl;\n                    for(j=data[top];j<nolen[top];j++){\n                        data[top]++;\n                        if(!used[node[top][j]]){\n                            top = node[top][j];\n                            chain[chlen] = top;\n                            chlen++;\n                            found = true;\n                            used[top] = true;\n                            break;\n                        }\n                    }\n                    if(!found){\n                        if(chlen > max){\n                            max = chlen;\n                        }\n                        used[top] = false;\n                        data[top] = 0;\n                        chlen--;\n                        top = chain[chlen-1];\n                    }\n                }\n            }\n        }\n        cout << max << endl;\n        cin >> n;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool once_used[100];\nbool used[100];\nint dfs(int v)\n{\n\tonce_used[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tfill(once_used, once_used+100, false);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (edge[i].size() <= 2)\n\t\t\t\tres = max(res, dfs(i));\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (!once_used[i])\n\t\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint solve(int idx, const vector<vector<int> >& path, vector<int>& visited, int cnt)\n{\n\tif (visited[idx])\n\t\treturn cnt;\n\n\tint ans = cnt;\n\tvisited[idx] = 1;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tif (!visited[i] && path[idx][i])\n\t\t\tans = max(ans, solve(i, path, visited, cnt+1));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"0508.txt\", \"r\", stdin);\n\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tvector<vector<int> > path(100, vector<int>(100, 0));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tpath[a][b] = path[b][a] = 1;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tvector<int> visited(100, 0);\n\t\t\tans = max(ans, solve(i, path, visited, 1));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\n\nint dfs(int x){\n  used[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      ans = max(ans, dfs(rings[i]));\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 0;j < rings.size();j++){\n\tif(neib[rings[j]].size() == i && onceused[rings[j]] == 0){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }  \n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nint ma;\nvector<int> G[105];\nbool visit[105];\n\nvoid dfs(int cur, int depth = 1)\n{\n    ma = max(ma, depth);\n\n    for (int u : G[cur]) {\n        if (visit[u]) {\n            continue;\n        }\n\n        visit[u] = true;\n\n        dfs(u, depth + 1);\n\n        visit[u] = false;\n    }\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        for (int i = 0; i < 100; ++i) G[i].clear();\n\n        for (int i = 0; i < N; ++i) {\n            int a, b; cin >> a >> b;\n            --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        ma = 0;\n\n        for (int i = 0; i < 100; ++i) {\n            visit[i] = true;\n            dfs(i);\n            visit[i] = false;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100],L[100],D[100];\n\nint solve(int m)\n{\n    int r=0;\n    D[m]=1;\n    for(int i=0;i<L[m];i++){\n        int k=G[m][i];\n        if(!D[k]){\n            r=max(r,solve(k));\n        }\n    }\n    D[m]=0;\n    return r+1;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(L,0,sizeof(L));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a][L[a]++]=b;\n            G[b][L[b]++]=a;\n        }\n        for(int i=0;i<100;i++){\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint result;\nvector<int> strands[100];\nbool used[100];\n\nint rec(int k, int d, int ub) {\n  if (result < d) result = d;\n  used[k] = 1;\n  for (int i = 0; i < strands[k].size(); i++)\n    if (!used[strands[k][i]]) ub--;\n  ub++;\n  if (result <= ub)\n    for (int i = 0; i < strands[k].size(); i++) {\n      int j = strands[k][i];\n      if (!used[j]) rec(j, d+1, ub);\n    }\n  used[k] = 0;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].clear();\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    result = 0;\n    for (int i = 0; i < n; i++)\n      rec(i, 1, n);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n\n#define INF INT_MAX\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\nvector<list<int>> graph;\nset<int> nodes;\nbool visited[100];\n\nint solve(int start, int dist) {\n  int res = -1;\n  for(int to : graph[start]) {\n    if(visited[to]) continue;\n\n    visited[to] = true;\n    res = max(res, solve(to, dist + 1));\n    visited[to] = false;\n  }\n  if(res == -1) return dist;\n  return res;\n}\n\nint main() {\n  while(true) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    graph.clear(); nodes.clear();\n    graph.resize(100);\n    memset(visited, 0, 100 * sizeof(bool));\n\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      graph[a].push_back(b);\n      graph[b].push_back(a);\n      nodes.insert(a); nodes.insert(b);\n    }\n\n    int ans = 0;\n\n    for(int node : nodes) {\n      visited[node] = true;\n      ans = max(solve(node, 0), ans);\n      visited[node] = false;\n    }\n\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n\nint v[100];\nvector<int> g[100];\n\ninline int dfs(int x){\n\tint ans = 0;\n\tfor(int i = 0,l = g[x].size(); i < l; i++){\n\t\tint y = g[x][i];\n\t\tv[x]++;\n\t\tif(!v[y]){\n\t\t\tans = max(ans,dfs(y)+1);\n\t\t}\n\t\tv[x]--;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tint M = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tM = max(M,b);\n\t\t\ta--;b--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans = 0,size = 100;//sizeは嘘枝刈り用\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tsize = min((int)g[i].size(),size);\n\t\t}\n\t\tsize += 3;//2だとWAすることを確認済み\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(g[i].size()<=size)ans = max(ans,dfs(i)+1);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\n#define INF 1000000000\n#define reps(i,f,n) for(int i = f; i < int(n); i++)\n#define rep(i,n) reps(i,0,n)\n\nusing namespace std;\n\n\nvector<int> e[128];\nint used[128];\nint ans;\n\nint func(int index, int cost){\n\tif(used[index])return cost-1;\n\tint x = 0;\n\trep(i,e[index].size()){\n\t\tused[index] = 1;\n\t\tx = max(func(e[index][i], cost+1), x);\n\t\tused[index] = 0;\n\t}\n\treturn x;\n}\n\n\nint main(void){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint a,b;\n\t\tint mi = 0;\n\t\tans = 0;\n\t\trep(i,128)e[i].clear();\n\t\t\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif(a > mi)mi = a;\n\t\t\tif(b > mi)mi = b;\n\t\t\te[b].push_back(a);\n\t\t\te[a].push_back(b);\n\t\t}\n\t\tmi++;\n\t\t\n\t\treps(i,1,mi){\n\t\t\trep(i,128)used[i]=0;\n\t\t\tans = max(func(i,1), ans);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int MAX = 100;\n\nbool visited[MAX];\n\nint dfs(int v, const std::vector<std::vector<int>> &G)\n{\n    int res = 0;\n    for (int to : G[v]) {\n        if (!visited[to]) {\n            visited[to] = 1;\n            res = std::max(res, dfs(to, G) + 1);\n            visited[to] = 0;\n        }\n    }\n    return res;\n\n}\n\nint main()\n{\n    int N;\n    while (1) {\n        std::cin >> N;\n        if (N == 0) {\n            break;\n        }\n        std::vector<std::vector<int>> G(MAX);\n        for (int i = 0; i < N; i++) {\n            int a, b;\n            std::cin >> a >> b;\n            a--; b--;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n    \n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            std::fill(visited, visited + MAX, 0);\n            visited[i] = 1;\n            res = std::max(res, dfs(i, G));\n        }\n    \n        std::cout << res + 1 << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int MAX = 100;\n\nbool visited[MAX];\n\nint dfs(int v, const std::vector<std::vector<int>> &G)\n{\n    visited[v] = 1;\n    int res = 0;\n    for (int to : G[v]) {\n        if (!visited[to]) {\n            res = std::max(res, dfs(to, G) + 1);\n        }\n    }\n    visited[v] = 0;\n    return res;\n\n}\n\nint main()\n{\n    int N;\n    while (1) {\n        std::cin >> N;\n        if (N == 0) {\n            break;\n        }\n        std::vector<std::vector<int>> G(MAX);\n        for (int i = 0; i < N; i++) {\n            int a, b;\n            std::cin >> a >> b;\n            a--; b--;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n\n        int res = 0;\n        for (int i = 0; i < MAX; i++) {\n            std::fill(visited, visited + MAX, 0);\n            res = std::max(res, dfs(i, G) + 1);\n        }\n    \n        std::cout << res << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <list>\n#include <vector>\n\nusing namespace std;\nint N;\nvector<int> chain[101];\nbool arrive[101];\nint cnt;\nint MAX;\nvoid solve(int i){\n  vector<int>::iterator it;\n  for(it = chain[i].begin(); it != chain[i].end(); ++it){\n    if(arrive[*it] == false){\n      \n      arrive[*it] = true;\n      cnt++;\n//      cout << \"now:\" <<i << \"-\" <<  *it <<  \", count:\" << cnt << endl;\n      MAX = max(MAX, cnt);\n      solve(*it);\n      cnt--;\n      arrive[*it] = false;\n    }\n  }\n}\n\nint main(){\n  while(cin >> N && N){\n    MAX = 0;\n    for(int i=0; i<101; ++i){\n      chain[i].clear();\n      arrive[i] = false;\n    }\n    \n    for(int i=0; i<N; ++i){\n      int a,b;\n      cin >> a >> b;\n      chain[a].push_back(b);\n      chain[b].push_back(a);\n    }\n\n    for(int i=0; i<101; ++i){\n      cnt = 1;\n      arrive[i] = true;\n      solve(i);\n      arrive[i] = false;\n    }\n    cout << MAX << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nbool g[100][100];\nbool visited[100];\n\nint visit(int v){\n\tint res = 0;\n\trep(i, 100){\n\t\tif(i != v && !visited[i] && g[v][i]){\n\t\t\tvisited[i] = true;\n\t\t\tres = max(res, 1 + visit(i));\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tint a, b;\n\twhile(cin >> n && n){\n\t\tmemset(g, false, sizeof(g));\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trep(i, n){\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tg[a][b] = g[b][a] = true;\n\t\t}\n\n\t\tint res = 0;\n\t\t\n\t\trep(i, 100){\n\t\t\tvisited[i] = true;\n\t\t\tres = max(res, visit(i));\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << res + 1<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> G[101];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nvoid dfs(int u, int cost, vector<bool> &visited, int &res){\n\tbool flag = false;\n\tres = max(res, cost);\n\tfor(int i = 0; i < G[u].size(); i++){\n\t\tint v = G[u][i];\n\t\tif( !visited[v] ){\n\t\t\tvisited[v] = true;\n\t\t\tdfs(v, cost + 1, visited, res);\n\t\t\tvisited[v] = false;\n\t\t\t\n\t\t}\n\t}\n}\n\nint solve(const vector<int> &s){\n\tint res = 2;\n\tfor(int v = 0; v < 101; v++){\n\t\tif( !s[v] ) continue;\n\t\t\n\t\tvector<bool> visited(101, false);\n\t\tvisited[v] = true;\n\t\tdfs(v, 1, visited, res);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t\tvector<int> s(101, 0);\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tadd_edge(u, v);\n\t\t\ts[u] = s[v] = 1;\n\t\t}\n\t\tcout << solve(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint solve(vector<vector<int> >& edges, int pos, bitset<100> used)\n{\n    used[pos] = true;\n\n    int ret = 1;\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        int next = edges[pos][i];\n        if(!used[next])\n            ret = max(ret, 1 + solve(edges, next, used));\n    }\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > edges(100);\n        for(int i=0; i<n; ++i){\n            int a, b;\n            cin >> a >> b;\n            edges[a-1].push_back(b-1);\n            edges[b-1].push_back(a-1);\n        }\n\n        int ret = 0;\n        for(int i=0; i<100; ++i)\n            ret = max(ret, solve(edges, i, 0));\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nbool visited[100];\nint adj[100][100],deg[100],ans,cnt;\n\nvoid dfs(int u){\n\tif(ans<cnt) ans=cnt;\n\n\tcnt++;\n\trep(i,deg[u]){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tdfs(v);\n\t\t\tvisited[v]=false;\n\t\t}\n\t}\n\tcnt--;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d\",&m),m;){\n\t\tbool adjm[100][100]={},flg[100]={};\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\ta--, b--;\n\t\t\tadjm[a][b]=adjm[b][a]=flg[a]=flg[b]=true;\n\t\t}\n\n\t\tint f[100],n=0;\n\t\trep(i,100) if(flg[i]) { f[i]=n++; deg[f[i]]=0; }\n\n\t\trep(i,100) rep(j,100) if(adjm[i][j]) adj[f[i]][deg[f[i]]++]=f[j];\n\n\t\tans=0,cnt=1;\n\t\trep(u,n-1){\n\t\t\tvisited[u]=true;\n\t\t\tdfs(u);\n\t\t\tvisited[u]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\nint N;\nvector<int> G[102];\nint f[102];\nint f2[102];\nint search(int id){\n  int ret=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    if(!f2[G[id][i]]){\n      f[G[id][i]]=1;\n      f2[G[id][i]]=1;\n      ret = max(ret,search(G[id][i])+1);\n      f2[G[id][i]]=0;\n    }\n  }\n  return ret;\n}\nint search2(int id){\n  int ret=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    if(!f2[G[id][i]] && !f[G[id][i]]){\n      f2[G[id][i]]=1;\n      ret = max(ret,search(G[id][i])+1);\n      f2[G[id][i]]=0;\n    }\n  }\n  return ret;\n}\nint solve(int id){\n  int ret=0;\n  if((int)G[id].size()==1){\n    if(!f[G[id][0]]){\n      f[G[id][0]]=1;\n      f2[G[id][0]]=1;\n      ret = search(G[id][0])+1;\n      f2[G[id][0]]=0;\n    }\n    return ret;\n  }\n  for(int i=0;i<(int)G[id].size();i++){\n    for(int j=i+1;j<(int)G[id].size();j++){\n      int tmpi=0,tmpj=0;\n      bool fi=false,fj=false;\n      if(!f[G[id][i]]){\n\tfi=true;\n\tf[G[id][i]]=1;\n\tf2[G[id][i]]=1;\n\ttmpi = search(G[id][i])+1;\n\tf2[G[id][i]]=0;\n      }\n      if(!f[G[id][j]]){\n\tfj=true;\n\tf[G[id][j]]=1;\n\tf2[G[id][j]]=1;\n\ttmpj = search2(G[id][j])+1;\n\tf2[G[id][j]]=0;\n      }\n      ret = max(ret,tmpi+tmpj);\n    }\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    for(int i=0;i<N;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    int res=0;\n    for(int i=0;i<102;i++){\n      if(!G[i].empty()){\n\tmemset(f,0,sizeof(f));\n\tf[i]=1;\n\tf2[i]=1;\n\t//      printf(\"wa:%d size %d\\n\",i,(int)G[i].size());\n\tint st = solve(i)+1;\n\tf2[i]=0;\n\tres = max(res,st);\n\t//     printf(\"wa ... %d %d\\n\",i,st);\n      }\n    }\n    printf(\"%d\\n\",res);\n    for(int i=0;i<102;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint n;\nvector<int> G[101];\nint ans=0;\nint mn[101];\nbool vis[101];\nbool nuse[101];\nint INF=10000;\nvector<int> group;\n\nint dfs(int v){\n\tvis[v]=true;\n\tint res=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(vis[G[v][i]])continue;\n\t\tvis[G[v][i]]=true;\n\t\tres=max(res,dfs(G[v][i]));\n\t\tvis[G[v][i]]=false;\n\t}\n\treturn res+1;\n}\n\nint searchmin(int v){\n\tint res=G[v].size();\n\tvis[v]=true;\n\tgroup.push_back(v);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!vis[G[v][i]])res=min(res,searchmin(G[v][i]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<101;i++)G[i].clear(),mn[i]=INF;\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tmemset(vis,false,sizeof(vis));\n\t\tgroup.clear();\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tG[a-1].push_back(b-1);\n\t\t\tG[b-1].push_back(a-1);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mn[i]!=INF)continue;\n\t\t\tgroup.clear();\n\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\tint mini=searchmin(i);\n\t\t\tfor(int j=0;j<group.size();j++)mn[group[j]]=mini;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(G[i].size()==mn[i]){\n\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\tans=max(ans,dfs(i));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <fstream>\nusing namespace std;\n\nint ans;\nbool searched[101];\n\nvoid dfs(vector<vector<int>>& G, int p, int cost) { // p:position\n    bool updated = false;\n    for(int i=0; i<G[p].size(); ++i) {\n        int next = G[p][i];\n        if(!searched[next]) {\n            searched[next] = true;\n            dfs(G, next, cost+1);\n            searched[next] = false;\n            updated = true;\n        }\n    }\n    if(!updated) ans = max(ans, cost);\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<vector<int>> G(101);\n        ans = 0;\n\n        for(int i=0; i<n; ++i) {\n            int a, b;\n            cin >> a >> b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        for(int i=1; i<101; ++i) {\n            fill(begin(searched), end(searched), false);\n            searched[i] = true;\n            dfs(G, i, 1);\n        }\n        \n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstring>\n\nint n;\nstd::vector<int> es[100];\nbool used[100];\n\nint dfs( int p )\n{\n\tint ret = 0;\n\t\n\tfor( int i = 0; i != es[p].size(); ++i )\n\t{\n\t\tif( !used[es[p][i]] )\n\t\t{\n\t\t\tused[es[p][i]] = true;\n\t\t\tret = std::max( ret, dfs( es[p][i] ) + 1 );\n\t\t\tused[es[p][i]] = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile( std::cin >> n, n )\n\t{\n\t\tfor( int i = 0; i != 100; ++i )\n\t\t\tes[i].clear();\n\t\t\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint a, b;\n\t\t\tstd::cin >> a >> b;\n\n\t\t\tes[a-1].push_back( b - 1 );\n\t\t\tes[b-1].push_back( a - 1 );\n\t\t}\n\n\t\tint m = 100;\n\t\tfor( int i = 0; i != 100; ++i )\n\t\t\tif( !es[i].empty() )\n\t\t\t\tm = std::min( m, (int)es[i].size() );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != 100; ++i )\n\t\t{\n\t\t\tif( es[i].size() == m )\n\t\t\t{\n\t\t\t\tmemset( used, false, sizeof( used ) );\n\t\t\t\tans = std::max( ans, dfs( i ) );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nbool visited[110];\nint dist[110];\nint exist[110];\nint ne[110];\n\nint dfs(const Graph &g, int n) {\n  int tmp,res=0;\n  visited[n] = true;\n  exist[n] = 0;\n\n  for(int i=0; i<g[n].edge.size(); ++i) {\n    if(visited[g[n].edge[i]]) continue;\n    tmp = dfs(g, g[n].edge[i]);\n    if(res < tmp) res = tmp;\n  }\n\n  visited[n] = 0;\n  return res+1;\n}\n\nint main() {\n  int n,a,b,tmp,br;\n  while(cin>>n, n) {\n    Graph g(100);\n    int mindegree = 100,mind = 0;\n\n    for(int i=0; i<100; ++i) {\n      visited[i] = false;\n      dist[i] = 0;\n      exist[i] = 0;\n    }\n\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n      exist[a] = exist[b] = 1;\n    }\n\n    int max = 0;\n    for(int j=1;;j++) {\n      for(int i=0; i<100; ++i) {\n\tif(g[i].edge.size() == j) {\n\t  tmp = dfs(g, i);\n\t  if(max < tmp) max = tmp;\n\t}\n      }\n\n      br = 1;\n      for(int i=0; i<100; ++i)\n\tif(exist[i]) {\n\t  br = 0;\n\t  break;\n\t}\n      if(br) break;\n    }\n\n    cout<<max<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > edge;\nbool visited[128];\nint n;\nint depth = 0;\n\nint solve(int k) {\n\tif(visited[k])\n\t\treturn -1;\n\tvisited[k] = true;\n\tint res = -1;\n\tfor(int i = 0; i < edge[k].size(); i++) {\n\t\tres = max(res, solve(edge[k][i]));\n\t}\n\tvisited[k] = false;\n\treturn res+1;\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 128; i++)\n\t\t\tvisited[i] = false;\n\t\tedge.clear();\n\t\tedge.resize(100);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\nint minds[101];\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint mindfs(int x){\n  int res = neib[x].size();\n  onceused[x] = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(onceused[neib[x][i]] == 1)continue;\n    res = min(res, mindfs(neib[x][i]));\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      memset(onceused, 0, sizeof(used));\n      minds[rings[i]] = mindfs(rings[i]);\n    }\n    for(int i = 0;i < rings.size();i++){\n      if(neib[rings[i]].size() == minds[rings[i]]){\n\tans = max(ans, dfs(rings[i]));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nint check_count;\n\nint chack(int p,int t,vector<bool>& flag){\n\tcheck_count++;\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = chack(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttar(t,flag);\n\t\t\ttarget.insert(t);\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tcheck_count = 0;\n\t\t\tchack(*it,1,flag);\n\t\t\tif( check_count <= max){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = Solve(*it);\n\t\t\t//printf(\"s:%d\\n\",s);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint g[100][100];\nint num[100];\nbool f[100];\n\nint solve(int pos){\n  int ans = 1;\n  f[pos] = true;\n  REP(i,num[pos]){\n    int next = g[pos][i];\n    if(!f[next])\n      ans = max(ans, 1 + solve(next));\n  }\n  f[pos] = false;\n  return ans;\n}\n\nint main(){\n  while(n = getInt()){\n    REP(i,100) {\n      f[i] = false;\n      num[i] = 0;\n    }\n    REP(i,n){\n      int a = getInt()-1;\n      int b = getInt()-1;\n      g[a][num[a]++] = b;\n      g[b][num[b]++] = a;\n    }\n    int ans = 0;\n    REP(i,100) ans = max(ans, solve(i));\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<cstring>\n#include<sstream>\n\nusing namespace std;\n\nint main(){\n\t\tint n,num,cont,v;\n\t\tstring a,nex;\n\t\t\t\tstringstream ss;\n\twhile(1){\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\t\n\t\tif(n==0){break;}\n\t\tcin>>a;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcont=0;\n\t\t\twhile(1){\n\t\t\t\tif(cont>=a.size()){break;}\n\t\t\t\t\n\t\t\t\tnum=a[cont];\n\t\t\t\t\n\t\t\t\tv=0;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(a[cont]!=num){break;}\n\t\t\t\t\tv++;\n\t\t\t\t\tcont++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tss.clear();\n\t\t\t\tss<<v;\n\t\t\t\t\n\t\t\t\tnex+=ss.str();\n\t\t\t\tnex+=num;\n\t\t\t}\n\t\t\ta=nex;\n\t\t\tnex=\"\";\n\t\t}\n\t\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint n, a[110], b[110];\n\nvector< Array > edges;\nbool visit[110];\n\nint rec(int v) {\n\tint res = 1;\n\t\n\tvisit[v] = 1;\n\t\n\tint e_size = size_of(edges[v]);\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tif (visit[u]) continue;\n\t\tmaxUpdate(res, rec(u) + 1);\n\t}\n\t\n\tvisit[v] = 0;\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tedges.assign(101, Array());\n\t\n\tfor_(i,0,n) {\n\t\tedges[ a[i] ].push_back(b[i]);\n\t\tedges[ b[i] ].push_back(a[i]);\n\t}\n\t\n\tminit(visit, 0);\n\tint ans = 0;\n\tfor_(i,1,101) maxUpdate(ans, rec(i));\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> a[i] >> b[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101];\n  bool Vis[101];\n  int DP[101];\n   int N;\n   int Ans = 0;\n   int P;\n  void DFS(int n,int len){\n      Ans = (Ans<=len)? len : Ans;\n      DP[n] = (DP[n]<=len)? len : DP[n];\n      if(DP[n]==Ans) P = n;\n      int S = G[n].size();\n      for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis[G[n][i]]= true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int i;\n  int main(){\n      do{\n\n   for(i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   Vis[i] = false;\n    DP[i] = 0;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(i=1;i<=100;i++){\n    if(!Vis[i]){\n    Vis[i] =true;\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n    }\n   }\n  if(DP[P]==Ans){\n        V[P] = true;\n        DFS(P,1);\n   }\n   printf(\"%d\\n\",Ans);\n  }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint in_num[101];\nint tmp_depth;\nvector<int> G[101],GROUP[101];\n\nint boss[101],height[101];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 1; i <= 100; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid recursive(bool visited[101],int node_id,int depth,int group_id){\n\ttmp_depth = max(tmp_depth,depth);\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(visited[G[node_id][i]])continue;\n\n\t\tbool next_visited[101];\n\t\tfor(int k = 0; k < GROUP[group_id].size(); k++)next_visited[GROUP[group_id][k]] = visited[GROUP[group_id][k]];\t//???????????°?????????????????±?????????????¶??????°??????\n\t\tnext_visited[G[node_id][i]] = true;\n\t\trecursive(next_visited,G[node_id][i],depth+1,group_id);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tin_num[i] = 0;\n\t\tG[i].clear();\n\t\tGROUP[i].clear();\n\t}\n\n\tinit();\n\n\tint from,to;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[to]++;\n\t\tin_num[from]++;\n\t\tunite(from,to);\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(in_num[i] == 0)continue;\n\t\tGROUP[get_boss(i)].push_back(i);\n\t}\n\n\tint max_depth = 1,min_in_num;\n\tbool visited[101];\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(GROUP[i].size() == 0 || GROUP[i].size() < max_depth)continue;\n\n\t\tmin_in_num = BIG_NUM;\n\t\tfor(int k = 0; k < GROUP[i].size(); k++){\n\t\t\tmin_in_num = min(min_in_num,in_num[GROUP[i][k]]);\n\t\t}\n\n\t\tfor(int k = 0; k < GROUP[i].size(); k++){\n\t\t\tif(in_num[GROUP[i][k]] == min_in_num){\n\t\t\t\tfor(int p = 0; p < GROUP[i].size(); p++)visited[GROUP[i][p]] = false;\n\t\t\t\tvisited[GROUP[i][k]] = true;\n\t\t\t\ttmp_depth = 0;\n\t\t\t\trecursive(visited,GROUP[i][k],1,i);\n\t\t\t\tmax_depth = max(max_depth,tmp_depth);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_depth);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n\n    for(j = 0; j < N; j++)\n    {\n\tfor(i = 0; i < N; i++)\n\t{\n\t    conn[j][i] = 0;\n\t}\n    }\n\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n\tscanf(\"%d %d\", &a, &b);\n\tconn[a][b] = 1;\n\tconn[b][a] = 1;\n    }\n\n    for(a = 0; a < N; a++)\n    {\n\tused[a] = 0;\n    }\n\n    max_length = 0;\n    for(a = 0; a < N; a++)\n    {\n\tlength = find_length(a, 1);\n\tif (length > max_length)\n\t{\n\t    max_length = length;\n\t}\n    }\n    printf(\"%d\\n\", max_length);\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[128];\nvector<int> g[128];\nint solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tint c=g[a].size();\n\tfor(i=0;i<c;++i){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;++i)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;++i){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\t//for(int i=0;i<100;i++)size[i]=g[i].size();\n\t\tfor(int i=0;i<100;++i)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    while(1)\n    {\n        int num;\n        cin>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            cin>>a;\n            cin>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                maxLength = (*it).length;\n            }\n            ++it;\n        }\n        cout<<maxLength<<endl;\n        \n    }\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\n\nint dfs(int now, bool visited[], int sum){\n    sum++;\n    visited[now] = true;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]) return dfs(next, visited, sum);\n    }\n    return sum;\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        int ans = 2;\n        REP(i, vsize){\n            bool visited[N] = {false};\n            ans = max(ans, dfs(v[i], visited, 0));\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++) \n#define max(a,b) (((a)>=(b))?(a):(b))\nvector<int> edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=0;\n\trep(i,edge[n].size()) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tvisit[edge[n][i]]=true;\n\t\t\tif(edge[edge[n][i]].size()>0)\n\t\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t\telse\n\t\t\t\tmx=max(mx,1);\n\t\t\tvisit[edge[n][i]]=false;\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\trep(i,100)\n\t\t\tedge[i].clear();\n\t\trep(i,n) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\trep(i,100) {\n\t\t\tvisit[i]=true;\n\t\t\tif(edge[i].size()>0)\n\t\t\t\tmx=max(mx,solve(i)+1);\n\t\t\tvisit[i]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint mindfs(int x){\n  int res = neib[x].size();\n  onceused[x] = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(onceused[neib[x][i]] == 1)continue;\n    res = min(res, mindfs(neib[x][i]));\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      memset(onceused, 0, sizeof(used));\n      mind = mindfs(rings[i]);\n      if(neib[rings[i]].size() == mind){\n\tans = max(ans, dfs(rings[i]));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std; \n\n\nstatic const int black = 1;\nstatic const int white = 0;\n\nint graph[128][128] = {{}};\nint color[128] = {};\nint n,d = 0,ans = 0;\nint de[128] = {};\n\nvoid bfs(int in){\n\n  // cout << \"in = \" << in << endl;\n  int u;\n  u = in;\n  color[u] = black;\n  for(int i = 0;i < n;i++){\n    if(color[i] != black && graph[u][i] == 1){\n      d++;\n      de[u] = d;\n      d = de[u];\n      // cout << \"u = \" << u << \"i =\" << i << endl;\n      bfs(i);\n    }\n  }\n  for(int i = 0;i < n;i++){\n    if(de[i] > ans) ans = de[i];\n  }\n  d = 0;\n}\n\n\nint main(){\n\n  while(1){\n    int mae,ato;\n\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i =0;i < n;i++){\n      cin >> mae >> ato;\n      graph[mae - 1][ato - 1] = 1;\n      graph[ato - 1][mae - 1] = 1;\n    }\n\n    for(int i = 0;i < n;i++){\n      for(int  j = 0;j < n;j++){\n\t///\tcout <<  graph[i][j] << ' ';\n      }\n      // cout << endl;\n    }\n\n    for(int i = 0;i < n;i++){\n      for(int j = 0;j < 128;j++) color[j] = white;\n      // cout << \"b:i \" << i << endl; \n      bfs(i);\n      // for(int i = 0;i < n;i++)// cout << de[i] << endl;\n    }\n\n    for(int i = 0;i < n;i++){\n      if(de[i] > ans) ans = de[i];\n    }\n\n    cout << ans + 1 << endl;\n    for(int i = 0;i < 128;i++){\n      for(int j = 0;j < 128;j++){\n\tgraph[i][j] = 0;\n      }\n      color[i] = 0;\n      de[i] = 0;\n    }\n    d = 0;\n    ans = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\n#define fi first\n#define se second\n\nbool visited[110];\nint dist[110];\nint ecc[110];\n\nint diameter(const Graph &g, int n) {\n  for(int k=0; k<n; ++k) {\n    pair<int,int> s = pair<int,int>(k,0);\n    stack< pair<int,int> > st;\n    for(int i=0; i<n; ++i) visited[i] = false,dist[i] = 0;\n    st.push(s);\n    while(!st.empty()) {\n      pair<int,int> now = st.top(); st.pop();\n      if(visited[now.fi]) continue;\n      visited[now.fi] = true;\n      dist[now.fi] = now.se;\n      for(int i=0; i<g[now.fi].edge.size(); ++i) {\n\tdist[g[now.fi].edge[i]] = max(dist[g[now.fi].edge[i]], now.se+1);\n\tif(visited[g[now.fi].edge[i]]) continue;\n\tst.push( pair<int,int>(g[now.fi].edge[i],now.se+1) );\n      }\n    }\n    int tt = 0;\n    for(int i=0; i<n; ++i)\n      if(tt < dist[i]) tt = dist[i];\n\n    ecc[k] = tt;\n  }\n  int maxm = 0;\n  for(int i=0; i<n; ++i)\n    maxm = max(ecc[i], maxm);\n  return maxm;\n}\n\nint main() {\n  int n,a,b;\n  while(cin>>n, n) {\n    Graph g(n);\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n    }\n    cout<<diameter(g,n)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n\n#define INF INT_MAX\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\nint table[100][100];\n\nint solve(int start) {\n  queue<tuple<int, set<int>, int>> que; //current_pos, history, distance\n  que.push(make_tuple(start, set<int>(), 0));\n\n  //cout << \"start:\" << start + 1<< endl;\n\n  int max_dist = -1;\n  while(!que.empty()) {\n    auto a = que.front();\n    que.pop();\n\n    auto cur_pos = get<0>(a);\n    auto history = get<1>(a);\n    auto dist    = get<2>(a);\n\n    /*cout << \"cur:\" << cur_pos + 1 << \" hist: \";\n    for(int e : history) cout << e + 1 << \" \";\n    cout << \"dist: \" << dist << endl;*/\n\n    int push_num = 0;\n    rep(i, 100) {\n      if(table[cur_pos][i] == 0 || history.find(i) != history.end()) continue;\n\n      auto new_hist = history;\n      new_hist.insert(cur_pos);\n\n      que.push(make_tuple(i, new_hist, dist + 1));\n      push_num++;\n    }\n    if(push_num == 0) max_dist = max(max_dist, dist);\n  }\n\n  return max_dist;\n}\n\nint main() {\n  while(true) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    memset(table, 0, 100 * 100 * sizeof(int));\n\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      table[a][b] = table[b][a] = 1;\n    }\n\n    int ans = 0;\n\n    rep(i, 100) {\n      bool indep = true;\n      rep(j, 100) {\n        if(table[i][j] != 0) {\n          indep = false;\n          break;\n        }\n      }\n      if(indep) continue;\n\n      //cout << i << endl;\n\n      ans = max(solve(i), ans);\n    }\n\n  //cout << \"-----------------\" << endl;\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[101];\n\nbool passed[101];\n\nint maxPath=0;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\t//if(G[s][i]>=101||G[s][i]<0){\n\t\t//\tcout<<endl;\n\t\t//}\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\n\nint search(int now)\n{\n\tvis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tif (!vis[v[now][i]]) res = max(res, search(v[now][i]) + 1);\n\t}\n\t\n\tvis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t}\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (v[i].size() - mini <= 1){\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n\n    while(1)\n    {\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nvvi in;\nvi visit;\nint out=1;\nvoid dfs(int a,int c){\n\tout=max(out,c+1);\n\trep(i,in[a].size()){\n\t\tint t=in[a][i];\n\t\tif(!visit[t]){\n\t\t\tvisit[t]=true;\n\t\t\tdfs(t,c+1);\n\t\t\tvisit[t]=false;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tin=vvi(101);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tin[a].pb(b);\n\t\t\tin[b].pb(a);\n\t\t}\n\t\tint mi=inf;\n\t\trep(i,101)if(in[i].size()){\n\t\t\tint t=in[i].size();\n\t\t\tmi=min(mi,t);\n\t\t}\n\t\tout=0;\n\t\trep(i,101){//if(mi==in[i].size()){\n\t\t\tvisit=vi(101);\n\t\t\tvisit[i]=true;\n\t\t\tdfs(i,0);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>                                                                                   \n#include<cstring>                                                                                  \n#include<algorithm>                                                                                \n#include<vector>                                                                                   \nusing namespace std;                                                                               \n                                                                                                    \nint n;                                                                                             \nvector<short> G[100];                                                                              \nbool D[100];                                                                                       \n                                                                                                    \nint solve(int m)                                                                                   \n{                                                                                                  \n    int r=0;                                                                                       \n    D[m]=1;\n    for(vector<short>::iterator it=G[m].begin();it!=G[m].end();it++){                              \n        if(!D[*it]){                                                                               \n            r=max(r,solve(*it));                                                                 \n        }                                                                                          \n    }                                                                                              \n    D[m]=0;\n    return r+1;\n}                                                                                                  \n                                                                                                    \nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tvector<vector<int>>edges(100);\n\tint dfs(const int now, vector<int>&used) {\n\t\tint ans = 1;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tans = max(ans, dfs(e, used) + 1);\n\t\t\t\tused[e] = false;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a; int b; cin >> b; a--; b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint ans = 0;\n\tvector<int>used(100);\n\tfor (int i = 0; i < 100; ++i) {\n\t\tans = max(ans, dfs(i, used));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <vector>\n\nusing namespace std;\n\nvector<int> miti[100];\n\nint mflg[100];\n\nint saiki(int a)\n{\n\tif(mflg[a] != 0)\n\t{\n\t\treturn 0;\n\t}\n\tint max = 0;\n\tmflg[a] = 1;\n\tfor(int i = 0; i < miti[a].size(); i++)\n\t{\n\t\tint w = saiki(miti[a][i]);\n\t\tif(max < w)\n\t\t{\n\t\t\tmax = w;\n\t\t}\n\t}\n\tmflg[a] = 0;\n\treturn max + 1;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tmiti[a].push_back(b);\n\t\t\tmiti[b].push_back(a);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 100; ii++)\n\t\t\t{\n\t\t\t\tmflg[ii] = 0;\n\t\t\t}\n\t\t\tint w = saiki(i);\n\t\t\tif(max < w)\n\t\t\t{\n\t\t\t\tmax = w;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tmiti[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nvector<int> a[100];\nbool b[100];\nint fi(int p){\n\tint i;\n\tint mx=0;\n\tfor(i=0;i<(int)a[p].size();++i){\n\t\tif(b[a[p][i]])\n\t\t\tcontinue;\n\t\tb[a[p][i]]=true;\n\t\tmx=max(mx,fi(a[p][i])+1);\n\t\tb[a[p][i]]=false;\n\t}\n\treturn mx;\n}\nint main(){\n\tint i;\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;++i)\n\t\t\ta[i].clear();\n\t\tfor(i=0;i<n;++i){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\t--p;\n\t\t\t--q;\n\t\t\ta[p].push_back(q);\n\t\t\ta[q].push_back(p);\n\t\t}\n\t\tint mn,1<<30,mx=0;\n\t\tfor(i=0;i<n;++i)\n\t\t\tmn=min(mn,a[i].size());\n\t\tfor(i=0;i<n;++i){\n\t\t\tif(a[i].size()==mn)\n\t\t\t\tmx=max(mx,fi(i));\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nvector<int> G[100];\nint D[100];\n\nint solve(int m)\n{\n    int r=1,t;\n    for(vector<int>::iterator it=G[m].begin();it!=G[m].end();it++){\n        t=*it;\n        if(!D[t]){\n            D[t]=1;\n            r=max(r,1+solve(t));\n            D[t]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\n\nint dfs(int now, bool visited[], int sum){\n    sum++;\n    visited[now] = true;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]) return dfs(next, visited, sum);\n    }\n    return sum;\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        int ans = -1;\n        REP(i, vsize){\n            bool visited[N] = {false};\n            ans = max(ans, dfs(v[i], visited, 0));\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        vector< vector<int> > d(N, vector<int>() );\n        set<int> se;\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            se.insert(a); se.insert(b);\n            d[a].push_back(b);\n            d[b].push_back(a);\n        }\n\n        queue< vector<int> > q;\n        for(set<int>::iterator i = se.begin(); i != se.end(); i++){\n            vector<int> v; v.push_back((*i));\n            q.push(v);\n        }\n\n        int ans = -1;\n        while(!q.empty()){\n            vector<int> nowv = q.front();\n            q.pop();\n            int now = nowv.back();\n\n            REP(i, d[now].size()){\n                int next = d[now][i];\n                if(find(nowv.begin(), nowv.end(), next) == nowv.end()){\n                    vector<int> nextv = nowv;\n                    nextv.push_back(next);\n                    q.push(nextv);\n                } else{\n                    int s = nowv.size();\n                    ans = max(ans, s);\n                }\n            }\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n\nint rec(int pos)\n{\n\tint ret = 1; used[pos] = 1;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tif(!used[G[pos][i]])\n\t\t{\n\t\t\tret = max(ret, rec(G[pos][i]) + 1);\n\t\t}\n\t}\n\n\tused[pos] = 0;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tmemset(rings, 0, sizeof(rings));\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101];\n  bool Vis[101];\n  int DP[101];\n   int N;\n   int Ans = 0;\n  void DFS(int n,int len){\n      Ans = max(Ans,len);\n      DP[n] = max(DP[n],len);\n      int S = G[n].size();\n      for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis[G[n][i]]= true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int main(){\n      do{\n    int i;\n   for(i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   Vis[i] = false;\n    DP[i] = 0;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(i=1;i<=100;i++){\n    if(!Vis[i]){\n    Vis[i] =true;\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n    }\n   }\n   for(i=1;i<=100;i++){\n    if(DP[i]==Ans){\n        V[i] = true;\n        DFS(i,1);\n        V[i] = false;\n        break;\n    }\n   }\n   printf(\"%d\\n\",Ans);\n  }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\tint n,a,b,i,j,x,t,min,max;\n\tbool table[101][101];\n\tchar field[101][101];\n\tint data[101];\n\twhile(cin>>n){\n\t\tif(n==0){break;}\n\t\tn+=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tcin>>a>>b;\n\t\t\ttable[a][b]=1;\n\t\t\ttable[b][a]=1;\n\t\t}\n\t\tmax=0;\n\t\tfor(x=1;x<n;x++){\n\t\t\tfor(i=1;i<n;i++){\n\t\t\t\tfor(j=1;j<n;j++){\n\t\t\t\t\tfield[i][j]=table[i][j];\n\t\t\t\t}\n\t\t\t\tdata[i]=0;\n\t\t\t}\n\t\t\tdata[0]=x;\n\t\t\tt=1;\n\t\t\twhile(1){\n\t\t\t\tmin=n;\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tif(i!=x && field[data[t-1]][i]==1 && min>i && i>data[t]){\n\t\t\t\t\t\tmin=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tfield[data[t-1]][i]=2;\n\t\t\t\t\tfield[i][data[t-1]]=2;\n\t\t\t\t}\n\t\t\t\tif(min!=n){\n\t\t\t\t\tdata[t]=min;\n\t\t\t\t\tt+=1;\n\t\t\t\t}else{\n\t\t\t\t\tmax=(max<t)?t:max;\n\t\t\t\t\tt-=1;\n\t\t\t\t\tif(t==0){break;}\n\t\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t\tfield[data[t-1]][i]=table[data[t-1]][i];\n\t\t\t\t\t\tfield[i][data[t-1]]=table[i][data[t-1]];\n\t\t\t\t\t\tfield[data[t]][i]=table[data[t]][i];\n\t\t\t\t\t\tfield[i][data[t]]=table[i][data[t]];\n\t\t\t\t\t\tfield[data[t+1]][i]=table[data[t+1]][i];\n\t\t\t\t\t\tfield[i][data[t+1]]=table[i][data[t+1]];\n\t\t\t\t\t\tdata[t+1]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint done[100];\nint c[100][2];\n\nmain(){\n  int i;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0\n    for(i=1;i<=100;i++){\n      preans = chain(i,0);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint chain(int e,int l){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define pb push_back\n\nint n,s[100][2],used[100];\n\nint f(int last){\n\tint res=0;\n\trep(i,n){\n\t\tif(last==s[i][0]&&!used[s[i][1]]){\n\t\t\tused[s[i][1]]=1;\n\t\t\tres=max(res,f(s[i][1])+1);\n\t\t\tused[s[i][1]]=0;\n\t\t}\n\t\tif(last==s[i][1]&&!used[s[i][0]]){\n\t\t\tused[s[i][0]]=1;\n\t\t\tres=max(res,f(s[i][0])+1);\n\t\t\tused[s[i][0]]=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+n,0);\n\t\trep(i,n){cin>>s[i][0]>>s[i][1];s[i][0]--;s[i][1]--;}\n\t\tint ans=2;\n\t\trep(i,n){\n\t\t\tused[s[i][0]]=used[s[i][1]]=1;\n\t\t\tans=max(ans,max(f(s[i][0])+2,f(s[i][1])+2));\n\t\t\tused[s[i][0]]=used[s[i][1]]=0;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 111;\n\nvector<int> edge[N];\nint visit[N];\n\nint saiki(int p){\n\t\n\tint ret = 0;\n\trep(i,edge[p].size()){\n\t\tint next = edge[p][i];\n\t\tif(visit[next]==0){\n\t\t\tvisit[next]=1;\n\t\t\tret = max(saiki(edge[p][i])+1, ret);\n\t\t\tvisit[next]=0;\n\t\t}\n\t}\n\t\n\tvisit[p]=0;\n\treturn ret;\n}\n\nint main(){\n\tA:;\n\t\n\tint n;\n\tcin>>n;\n\tif(n==0)return 0;\n\t\n\trep(i,N)edge[i].clear();\n\t\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\t\n\trep(i,N)visit[i]=0;\n\tint ans = 0;\n\trep(i,N){\n\t\tans = max(saiki(i),ans);\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> to[101];\nbool used[101];\n\nint dfs(int v) {\n\tint ret = 1;\n\tused[v] = 1;\n\tfor (int i=0; i<to[v].size(); ++i) {\n\t\tif ( ! used[to[v][i]]) {\n\t\t\tret = max(ret, 1 + dfs(to[v][i]));\n\t\t}\n\t}\n\tused[v] = 0;\n\treturn ret;\n}\n\nint main() {\n\tint n, a, b;\n\twhile (cin >> n, n) {\n\t\tfill(to, to+101, vector<int>());\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> a >> b;\n\t\t\tto[a].push_back(b);\n\t\t\tto[b].push_back(a);\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i=1; i<101; ++i) res = max(res, dfs(i));\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n    time_t\tstart_time, t;\n\n    while(1)\n    {\n\tstart_time = time(NULL);\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t    if (time(NULL) - start_time > 1)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > edges;\nbitset<100> used;\n\nint solve(int pos)\n{\n    used[pos] = true;\n\n    int ret = 1;\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        int next = edges[pos][i];\n        if(!used[next])\n            ret = max(ret, 1 + solve(next));\n    }\n\n    used[pos] = false;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        edges.assign(100, vector<int>(0));\n        for(int i=0; i<n; ++i){\n            int a, b;\n            cin >> a >> b;\n            edges[a-1].push_back(b-1);\n            edges[b-1].push_back(a-1);\n        }\n\n        int ret = 0;\n        for(int i=0; i<100; ++i)\n            ret = max(ret, solve(i));\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<set<Int> > G(100);\n    for(Int i=0;i<n;i++){\n      Int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].emplace(b);\n      G[b].emplace(a);\n    }\n    Int ans=1;\n    auto calc=[&](Int s){\n      vector<int> used(100,0);\n      function<void(int,int)> dfs=[&](int v,int d){\n\tchmax(ans,d+1);\n\tfor(int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  dfs(u,d+1);\n\t}\n      };\n      used[s]=1;\n      dfs(s,0);\n    };\n    \n    for(Int i=0;i<100;i++) calc(i);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > edges;\nbitset<100> used;\nmap<vector<long long>, int> memo;\n\nint solve(int pos)\n{\n    vector<long long> tmp(3);\n    tmp[0] = pos;\n    tmp[1] = (used & bitset<100>((1ULL<<50)-1ULL)).to_ulong();\n    tmp[2] = (used >> 50).to_ulong();\n    map<vector<long long>, int>::iterator it = memo.find(tmp);\n    if(it != memo.end())\n        return it->second;\n\n    used[pos] = true;\n\n    int ret = 1;\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        int next = edges[pos][i];\n        if(!used[next])\n            ret = max(ret, 1 + solve(next));\n    }\n\n    memo[tmp] = ret;\n    used[pos] = false;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        edges.assign(100, vector<int>(0));\n        for(int i=0; i<n; ++i){\n            int a, b;\n            cin >> a >> b;\n            edges[a-1].push_back(b-1);\n            edges[b-1].push_back(a-1);\n        }\n\n        memo.clear();\n        int ret = 0;\n        for(int i=0; i<100; ++i)\n            ret = max(ret, solve(i));\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nvector< vector<int> > edge;\n\nint dfs(int v, bitset<101> visited) {\n    int result = visited.count() + 1;\n    visited.set(v);\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        result = max(result, dfs(*i, visited));\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(set<int>::iterator i=vertex.begin(); i!=vertex.end(); i++) {\n        result = max(result, dfs(*i, bitset<101>(0)));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge = vector< vector<int> >(101);\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<queue>\n\n#define MAX 102\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\nclass State{\npublic:\n  int pos;\n  State(int pos):pos(pos){\n    len = 1;\n  }\n  int len;\n  bool vis[MAX];\n};\n\nint BFS(int st, const vector<Node> &G){\n  int ret = 2;\n  queue<State> q;\n  State init(st);\n  fill(init.vis,init.vis+MAX,false);\n  init.vis[st]=true;\n  q.push(init);\n  //cout << \"START : \" << st << endl;\n  while(!q.empty()){\n    State now = q.front();\n    q.pop();\n    //cout << \" POS : \" << now.pos << endl;\n    ret = max( ret, now.len );\n    const set<int> &S = G[now.pos].con;\n    for(set<int>::iterator its = S.begin();\n\tits != S.end();\n\t++its){\n      if( !now.vis[ *its ] ){\n\tState next = now;\n\tnext.pos = *its;\n\tnext.vis[ *its ] = true;\n\tnext.len++;\n\tq.push( next );\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    vector<Node> graph(MAX);\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      graph[a].con.insert(b);\n      graph[b].con.insert(a);\n    }\n    for(int i = 0; i < MAX; ++i){\n      if(exist[i])\n\tans = max(ans, BFS(i,graph));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nvector< vector<int> > edge;\nint answer;\n\nvoid dfs(int v, bitset<101> visited) {\n    visited.set(v);\n    int t = visited.count();\n    answer = max(answer, t);\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        dfs(*i, visited);\n    }\n}\n\nint solve() {\n    answer = 0;\n    for(set<int>::iterator i=vertex.begin(); i!=vertex.end(); i++) {\n        dfs(*i, bitset<101>(0));\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge = vector< vector<int> >(101);\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\nint n;\nvector<vector<int>> g;\nset<int> used;\n\nint func(int cur) {\n\tint res =  0;\n\t\t\tused.insert(cur);\n\tfor (auto itr : g[cur]) {\n\t\tif (used.find(itr) == used.end()) {\n\t\t\tres = max(res,1+func(itr));\n\t\t}\n\t}\n\t\t\tused.erase(cur);\n\treturn res;\n}\n\nsigned main() {\n\t\n\twhile (scnaf(\"%d\", &n) != EOF) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tg.clear();\n\t\tg.resize(n);\n\t\tREP(i, n) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, n) {\n\t\t\t\tans = max(ans, func(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    while(1)\n    {\n        int num;\n        cin>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            cin>>a;\n            cin>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                macLength = (*it).length;\n            }\n        }\n        cout<<macLength<<endl;\n        \n    }\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint a[100]={};\nint b[100]={};\nint c[100][100]={};\nint cn[100]={};\n\nint f(int i1,int i2,int used_ring[100],int l){\n\tint mc;\n\tint m=l;\n\tfor(int i=0;i<cn[i1];i++){\n\t\tif(used_ring[c[i1][i]] == 0){\n\t\t\tused_ring[c[i1][i]]=1;\n\t\t\tmc=f(c[i1][i],i2,used_ring,l+1);\n\t\t\tused_ring[c[i1][i]]=0;\n\t\t\tif(mc>m){m=mc;}\n\t\t}\n\t}\n\treturn m;\n}\n\t\nint main() {\n\twhile(1){\n\t\tint mc;\n\t\tint m=0;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tcn[i]=0;\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tc[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tif(n==0){return 0;}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tc[a[i]][cn[a[i]]]=b[i];\n\t\t\tc[b[i]][cn[b[i]]]=a[i];\n\t\t\tcn[a[i]]++;\n\t\t\tcn[b[i]]++;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint used_ring[100]={};\n\t\t\tused_ring[a[i]]=1;\n\t\t\tused_ring[b[i]]=1;\n\t\t\tmc=f(a[i],b[i],used_ring,2);\n\t\t\tif(mc>m){m=mc;}\n\t\t\tmc=f(b[i],a[i],used_ring,2);\n\t\t\tif(mc>m){m=mc;}\n\t\t}\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint c[101][101];/*???i????????????????????\\?????????c[i][j]???;j=0??????i????????????????????°*/\n\nint chain(int e,int l,int done[]){\n    int i,j;\n    int lmax = l,ltemp;\n    if(c[e][0]){\n        for(j=1;j<=c[e][0];j++){\n            if(done[c[e][j]]){\n                done[c[e][j]] = 0;\n                ltemp = chain(c[e][j],l+1,done);\n                done[c[e][j]] = 1;\n                if(ltemp>lmax)lmax = ltemp;\n            }\n        }\n        return lmax;\n    }else{\n        return l;\n    }\n}\nint main(){\n    int n,ans,temp;\n    int done[101];/*i???????????¨??? c[i]=1,i=0??????i???max???*/\n    int a,b;\n    int i,j;\n    scanf(\"%d\",&n);\n    while(n){\n        /*?????????*/\n        for(i=0;i<=100;i++){\n            done[i] = 0;\n            for(j=0;j<=100;j++){\n                c[i][j] = 0;\n            }\n        }\n        /*?????????????????????*/\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            done[a] = done[b] = 1;\n            c[a][0]++;\n            c[b][0]++;\n            c[a][c[a][0]] = b;\n            c[b][c[b][0]] = a;\n            if(done[0]<a)done[0] = a;\n            if(done[0]<b)done[0] = b;\n        }\n        /*?¢??????¨*/\n        /*printf(\"lim: %d\\n\",done[0]);\n        for(i=1;i<=done[0];i++){\n            if(c[i][0]){\n                printf(\"%d is connected with \",i);\n                for(j=1;j<=c[i][0];j++)printf(\"%d,\",c[i][j]);\n                printf(\"\\n\");\n            }\n        }*/\n        ans = 0;\n        /*?§????????±???????????????????????±???????*/\n        for(i=1;i<=100;i++){\n            if(done[i]){\n                done[i] = 0;\n                temp = chain(i,1,done);\n                done[i] = 1;\n                if(ans<temp)ans = temp;\n            }\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nvector<int> way[100];\nint ans;\n\nvoid Dfs(bool used[100],int n,int d){\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tif(used[way[n][i]]) continue;\n\t\tDfs(used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tDfs(used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n\n#define INF INT_MAX\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\nint table[100][100];\nbool visited[100];\n\nint solve(int start, int dist) {\n  int res = -1;\n  rep(i, 100) {\n    if(visited[i] || table[start][i] == 0) continue;\n\n    visited[i] = true;\n    res = max(res, solve(i, dist + 1));\n    visited[i] = false;\n  }\n  if(res == -1) return dist;\n  return res;\n}\n\nint main() {\n  while(true) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    memset(table, 0, 100 * 100 * sizeof(int));\n    memset(visited, 0, 100 * sizeof(bool));\n\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      table[a][b] = table[b][a] = 1;\n    }\n\n    int ans = 0;\n\n    rep(i, 100) {\n      bool indep = true;\n      rep(j, 100) {\n        if(table[i][j] != 0) {\n          indep = false;\n          break;\n        }\n      }\n      if(indep) continue;\n\n      visited[i] = true;\n      ans = max(solve(i, 0), ans);\n      visited[i] = false;\n    }\n\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 101\nint N, ans;\nbool seen[MAX];\nvector<int> M[MAX];\n\nvoid dfs(int u, int d){\n    seen[u] = true;\n    ans = max(ans, d);\n    vector<int>::iterator it;\n    for(it = M[u].begin(); it != M[u].end(); it++){\n        if(seen[*it]) continue;\n        else dfs(*it, d + 1);\n    }\n    seen[u] = false;\n    return;\n}\n\n\n\nint main(){\n    while(cin >> N){\n        if(N == 0) return 0;\n        ans = 0;\n        for(int i = 1; i <= MAX; i++) M[i].clear();\n        for(int i = 1; i <= N; i++){\n            int u, v;\n            cin >> u >> v;\n            M[u].push_back(v);\n            M[v].push_back(u);\n        }\n        for(int i = 1; i <= MAX; i++){\n            for(int j = 1; j <= MAX; j++) seen[j] = false;\n            dfs(i, 1);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector<vector<int> > v;\n\nint dfs(int pos, vector<bool> &visited) {\n    int ans = 0;\n    visited[pos] = true;\n    for(int i = 0; i < v[pos].size(); ++i) {\n        if(visited[v[pos][i]]) continue;\n        ans = max(ans, dfs(v[pos][i], visited));\n    }\n    visited[pos] = false;\n    return ans+1;\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        v.clear();\n        v.resize(100);\n        for(int i = 0; i < N; ++i) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            v[a].push_back(b);\n            v[b].push_back(a);\n        }\n        int ans = 0;\n        for(int i = 0; i < 100; ++i) {\n            vector<bool> visited(N, false);\n            ans = max(ans, dfs(i, visited));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[128];\nvector<int> g[128];\nint solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tint c=g[a].size();\n\tfor(i=0;i<c;i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\t//for(int i=0;i<100;i++)size[i]=g[i].size();\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nvector<int> rings;\n\nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n        \n        used = vector<bool>(100);\n        \n        rings = vector<int>(100);\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n        \n        for(int i = 0; i < 100; i++)\n        {\n            rings[i] = G[i].size();\n        }\n        \n        int nodes = 0;\n        \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                \n            if(ret == nodes) { break; }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101]={};\n  bool Vis[101]={};\n  int DP[101] = {};\n   int N;\n   int Ans = 0;\n  void DFS(int n,int len){\n      Ans = max(Ans,len);\n      DP[n] = max(DP[n],len);\n      int S = G[n].size();\n      for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis[G[n][i]]= true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int main(){\n      do{\n   for(int i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   Vis[i] = false;\n    DP[i] = 0;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(int i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(int i=1;i<=100;i++){\n    if(!Vis[i]){\n    Vis[i] =true;\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n    }\n   }\n//   printf(\"|%d|\\n\",Ans);\n   for(int i=1;i<=100;i++){\n    if(DP[i]==Ans){\n        V[i] = true;\n        DFS(i,1);\n        V[i] = false;\n        break;\n    }\n   }\n   printf(\"%d\\n\",Ans);\n  }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+V+1,false);\n    fill(e,e+V+1,0);\n\n    int MAX=0;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      MAX=max(MAX,e[i]);\n    }\n\n    int ans=0;\n    for(int i=1;i<=V;i++){\n      if(MAX!=e[i])\n      ans=max(ans,dfs(i,1));\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nbool visited[100];\nvector<int> g[100];\nint n;\nint dfs(int now) {\n  visited[now] = 1;\n  int res = 0;\n  FOR(it, g[now]) {\n    if (visited[*it]) continue;\n    res = max(res, dfs(*it));\n  }\n  visited[now] = 0;\n  return res + 1;\n}\n\nint main() {\n  while(cin >> n, n) {\n    REP(i, n) g[i].clear();\n    vector<int> num(n);\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      g[a].push_back(b);\n      g[b].push_back(a);\n      num[a]++;\n      num[b]++;\n    }\n    vector<bool> memo(n);\n    vector<vector<int> > connected;\n    REP(i, 100) {\n      if (memo[i]) continue;\n      queue<int> Q;\n      Q.push(i);\n      vector<int> tmpv;\n      while(!Q.empty()) {\n        int now = Q.front(); Q.pop();\n        if (memo[now]) continue;\n        memo[now] = 1;\n        tmpv.push_back(now);\n        FOR(it, g[now]) {\n          if (memo[*it]) continue;\n          Q.push(*it);\n        }\n      }\n      if (tmpv.size()>1)\n        connected.push_back(tmpv);\n    }\n    int ans = 0;\n    REP(i, connected.size()) {\n      if (ans > connected[i].size()) continue;\n      int mi = INF;\n      FOR(it, connected[i]) {\n        //cout << *it << \" \";\n        mi = min(mi, num[*it]);\n      }\n      //cout << endl;\n      REP(j, connected[i].size()) {\n        if (num[connected[i][j]] == mi) {\n          memset(visited, 0, sizeof(visited));\n          //cout << \"j \" << connected[i][j] << endl;\n          ans = max(ans, dfs(connected[i][j]));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[100];\nvector<int> g[100];\ninline int solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tint c=g[a].size();\n\tfor(i=0;i<c;i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nvvi in;\nvi d;\nvoid dfs(int a,int c){\n\td[a]=c;\n\trep(i,in[a].size()){\n\t\tint t=in[a][i];\n\t\tif(d[t]==inf)dfs(t,c+1);\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tin=vvi(n);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tin[a].pb(b);\n\t\t\tin[b].pb(a);\n\t\t}\n\t\tint out=0;\n\t\trep(i,n){\n\t\t\td=vi(n,inf);\n\t\t\tdfs(i,0);\n\t\t\trep(j,n)if(d[j]!=inf)out=max(out,d[j]);\n//\t\t\trep(j,n)cout<<\" \"<<d[j];cout<<endl;\n\t\t}\n\t\tcout<<out+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define rep(i,j) for(int i = 0; i < (j); i++)\ntypedef vector<int> vi;\nvi G[100];\nbool memo[101];\nint func(int s, int n) {\n\tint ret = n;\n\tif(memo[s]) return ret;\n\tmemo[s] = true;\n\trep(i, G[s].size()) {\n\t\tret = max(ret, func(G[s][i], n + 1));\n\t}\n\tmemo[s] = false;\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile(cin >> n,n) {\n\t\trep(i, 100)G[i].clear();\n\t\trep(i, n) {\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tint ans = -1;\n\t\trep(i, 100) {\n\t\t\tmemset(memo, 0, sizeof(memo));\n\t\t\tans = max(ans, func(i, 0));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nint rec(int pos, vector<bool> used)\n{\n    used[pos] = true; int ret = 0;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used));\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n    \n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(false, 100)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\nvector<int> anslist;\n\nint dfs(int now, bool visited[], int sum){\n    sum++;\n    visited[now] = true;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]) return dfs(next, visited, sum);\n    }\n    anslist.push_back(sum);\n    return sum;\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        anslist.clear();\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        REP(i, vsize){\n            bool visited[N] = {false};\n            dfs(v[i], visited, 0);\n        }\n        int ans = 2;\n        int s = anslist.size();\n        REP(i, s) ans = max(ans, anslist[i]);\n        cout <<ans <<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nint rec(int pos, vector<bool> used)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used) + 1);\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n    \n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(100, false)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint a[101]={};\nint b[101]={};\nint c[101][100]={};\nint cn[101]={};\n\nint f(int i1,int i2,int used_ring[101],int l){\n\tint mc;\n\tint m=l;\n\tfor(int i=0;i<cn[i1];i++){\n\t\tif(used_ring[c[i1][i]] == 0){\n\t\t\tused_ring[c[i1][i]]=1;\n\t\t\tmc=f(c[i1][i],i2,used_ring,l+1);\n\t\t\tused_ring[c[i1][i]]=0;\n\t\t\tif(mc>m){m=mc;}\n\t\t}\n\t}\n\treturn m;\n}\n\t\nint main() {\n\twhile(1){\n\t\tint mc;\n\t\tint m=0;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcn[i]=0;\n\t\t}\n\t\tcin >> n;\n\t\tif(n==0){return 0;}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tc[a[i]][cn[a[i]]]=b[i];\n\t\t\tc[b[i]][cn[b[i]]]=a[i];\n\t\t\tcn[a[i]]++;\n\t\t\tcn[b[i]]++;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint used_ring[101]={};\n\t\t\tused_ring[a[i]]=1;\n\t\t\tused_ring[b[i]]=1;\n\t\t\tmc=f(a[i],b[i],used_ring,2);\n\t\t\tif(mc>m){m=mc;}\n\t\t\tmc=f(b[i],a[i],used_ring,2);\n\t\t\tif(mc>m){m=mc;}\n\t\t}\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nbool visited[100];\nint g[100][100];\nint sz[100];\nint n;\nbool flag[100];\n\nint dfs(int now) {\n  visited[now] = 1;\n  flag[now] = 1;\n  int res = 0;\n  REP(i, sz[now]) {\n    if (visited[g[now][i]]) continue;\n    res = max(res, dfs(g[now][i]));\n  }\n  visited[now] = 0;\n  return res + 1;\n}\n\nint main() {\n  while(cin >> n, n) {\n    memset(g,0,sizeof(g));\n    int num[100];\n    memset(num,0,sizeof(num));\n    memset(sz,0,sizeof(sz));\n    memset(flag,0,sizeof(flag));\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      g[a][sz[a]++] = b;\n      g[b][sz[b]++] = a;\n      num[a]++;\n      num[b]++;\n    }\n    int ans = 0;\n    for (int i=1; i<100; ++i) {\n      bool tmp[100];\n      memcpy(tmp, flag, sizeof(flag));\n      REP(j, 100) {\n        if (num[j] == i && tmp[j] == 0) {\n          ans = max(ans, dfs(j));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101];\n  bool Vis[101];\n  int DP[101];\n   int N;\n   int Ans = 0;\n   int P;\n  void DFS(int n,int len){\n      Ans = (Ans<=len)? len : Ans;\n      DP[n] = (DP[n]<=len)? len : DP[n];\n      if(DP[n]==Ans) P = n;\n      int S = G[n].size();\n      for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis[G[n][i]]= true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int i;\n  int main(){\n      do{\n\n   for(i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   Vis[i] = false;\n    DP[i] = 0;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(i=1;i<=100;i++){\n    if(!Vis[i]){\n    Vis[i] =true;\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n    }\n   }\n  if(DP[P]==Ans){\n        V[P] = true;\n        DFS(P,1);\n   }\n   printf(\"%d\\n\",Ans);\n  }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool d[100][100];\nbool visited[100];\nint dist;\nint max_dist;\nvoid dfs(int s){\n\tdist++;\n\tif(dist > max_dist) max_dist = dist;\n\tvisited[s] = true;\n\tbool flag = true;\n\tfor(int i = 0; i < 100; i++){\n\t\tif(d[s][i] == true && visited[i] == false){\n\t\t\tflag = false;\n\t\t\tdfs(i);\n\t\t\tdist--;\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\tif(flag) return;\n}\nint main(){\n\tint N, a, b;\n\tfor(;;){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tmax_dist = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\td[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\td[a][b] = true;\n\t\t\td[b][a] = true;\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfill(visited, visited + 100, false);\n\t\t\tdist = 0;\n\t\t\tdfs(i);\n\t\t}\n\t\tprintf(\"%d\\n\", max_dist);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(e,e+101,0);\n    \n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    \n    int ans=0;\n\tfor(int i=1;i<101;i++){\n\t   if(MIN==e[i])\n\t    ans=max(ans,dfs(i,1));\n\t}\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint edge[100][100];\nint size[100];\nbool used[100];\n\nint rec(int idx){\n\n  int ret = 1;\n  for(int i = 0; i < size[idx]; i++){\n    if(!used[edge[idx][i]]){\n      used[edge[idx][i]] = true;\n      ret = max( ret, rec(edge[idx][i]) + 1);\n      used[edge[idx][i]] = false;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    fill_n( size, 100, 0);\n    fill_n( used, 100, false);\n    for(int i = 0; i < N; i++){\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      edge[a][size[a]++] = b;\n      edge[b][size[b]++] = a;\n    }\n    int ret = 0;\n    for(int i = 0; i < 100; i++){\n      used[i] = true;\n      ret = max( ret, rec(i));\n      used[i] = false;\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<int, int>m;\nvector<vector<int> >G(MAX_N);\n\nint dfs(int now, int c){\n  int res = c;\n  rep(i, G[now].size()){\n    if(m.count(G[now][i])) continue;\n    m[G[now][i]] = 1;\n    res = max(c ,dfs(G[now][i], c+1));\n    m.erase(G[now][i]);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n) && n){\n    rep(i, n) G[i].clear();\n    int a, b;\n    vi v;\n    rep(i, n){\n      scanf(\"%d%d\", &a, &b); a--; b--;\n      G[a].PB(b);\n      G[b].PB(a);\n      if(find(v.begin(), v.end(), a) == v.end()) v.PB(a);\n      if(find(v.begin(), v.end(), b) == v.end()) v.PB(b);\n    }\n    int res = 0;\n    rep(i, v.size()){\n      m.clear();\n      m[v[i]] = 1;\n      res = max(res, dfs(v[i], 1));\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!passed[to]){\n\t\t\tpassed[to]=true;\n\t\t\tdfs(to,depth+1);\n\t\t\tpassed[to]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmaxPath=0;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\t//cin>>a>>b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tpassed[*it]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\",maxPath);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tused.clear();\n\t\t\tused.pb(i);\n\t\t\tdfs(i);\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tvis[a]=1;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tret=max(ret,dfs(vv[a][i],b));\n\t}\n\tvis[a]=0;\n\treturn ret+1;\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvv=vector<vint>(n);\n\t\tvis=vint(n,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,n){\n\t\t\trep(i,n){\n\t\t\t\tvis[i]=0;\n\t\t\t}\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tans=max(ans,dfs(i,0));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n//map<int, int>m;\nvector<vector<int> >G(MAX_N);\n\nint dfs(int now, int visits[], int c){\n  int res = c;\n  rep(i, G[now].size()){\n    //    if(m.count(G[now][i])) continue;\n    if(visits[G[now][i]]) continue;\n    //    m[G[now][i]] = 1;\n    visits[G[now][i]] = 1;\n    res = max(res, dfs(G[now][i], visits, c+1));\n    //    m.erase(G[now][i]);\n    visits[G[now][i]] = 0;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n) && n){\n    rep(i, n) G[i].clear();\n    int a, b;\n    vi v;\n    rep(i, n){\n      scanf(\"%d%d\", &a, &b); a--; b--;\n      G[a].PB(b);\n      G[b].PB(a);\n      if(find(v.begin(), v.end(), a) == v.end()) v.PB(a);\n      if(find(v.begin(), v.end(), b) == v.end()) v.PB(b);\n    }\n    int res = 0;\n    int visits[MAX_N] = {};\n    rep(i, v.size()){\n      //      m.clear();\n      //      m[v[i]] = 1;\n      visits[v[i]] = 1;\n      res = max(res, dfs(v[i], visits, 1));\n      visits[v[i]] = 0;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef bitset<100> B;\n\nint n;\nvector<int> g[100];\nint a;\n\nvoid dfs(int k, B s){\n\tbool b = true;\n\tfor(auto& v: g[k]){\n\t\tif(!s[v]){\n\t\t\tB t = s;\n\t\t\tt[v] = 1;\n\t\t\tdfs(v, t);\n\t\t\tb = false;\n\t\t}\n\t}\n\tif(b){\n\t\ta = max((int)s.count(), a);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tg[--a].push_back(--b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\n\t\trep(i, 100){\n\t\t\tB s;\n\t\t\ts[i] = 1;\n\t\t\tdfs(i, s);\n\t\t}\n\t\tprintf(\"%d\\n\", a);\n\n\t\trep(i, 100){\n\t\t\tg[i].clear();\n\t\t}\n\t\ta = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nint node[101][101];\nint visit[101];\nint ans,last;\nint die[101];\nint flag;\n\nvoid dfs(int now, int cnt, int *st){\n\tif( cnt>ans ){\n\t\tans=cnt;\n\t\tlast = now;\n\t\tflag = 1;\n\t}\n\tfor(int next=0; next<101; next++)if( node[now][next] && !visit[next] ){\n\t\tvisit[next] = die[next] = 1;\n\t\tst[cnt] = next;\n\t\tdfs(next,cnt+1,st);\n\t\tvisit[next] = 0;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tset<int> s;\n\t\tans = 0;\n\t\tmemset(node,0,sizeof(node));\n\t\tmemset(visit,0,sizeof(visit));\n\t\tmemset(die,0,sizeof(die));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a,b; cin>>a>>b;\n\t\t\tnode[a][b] = node[b][a] = 1;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint tmp[101];\n\t\tfor(set<int>::iterator it=s.begin(); it!=s.end(); it++)if( !die[*it] ){\n\t\t\tflag = 0;\n\t\t\t\n\t\t\tvisit[*it]=1;\n\t\t\ttmp[0] = *it;\n\t\t\tdfs(*it,1,tmp);\n\t\t\tvisit[*it]=0;\n\t\t\t\n\t\t\tdie[last] = 0;\n\t\t\t//printf(\"*it:%d\\n\",*it);\n\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> to[100];\nbool used[100];\n\nvoid addEdge(int a, int b) {\n    to[a].push_back(b);\n    to[b].push_back(a);\n}\n\nint dfs(int v) {\n    int ret = 1;\n    used[v] = true;\n    for (int i=0; i<(int)to[v].size(); ++i) {\n        if ( ! used[to[v][i]]) {\n            ret = max(ret, 1 + dfs(to[v][i]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        fill(to, to+100, vector<int>());\n        int a, b;\n        for (int i=0; i<n; ++i) {\n            cin >> a >> b;\n            --a, --b;\n            addEdge(a, b);\n        }\n        int ret = 0;\n        for (int i=0; i<100; ++i) {\n            memset(used, false, sizeof used);\n            ret = max(ret, dfs(i));\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n        \n        used = vector<bool>(100);\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 100;\nint v[N][N];\n\nvector<int> G[N];\n\nint used[N];\n\nint dfs(int v){\n\tused[v] = 1;\n\tint res = 0;\n\tfor (auto &to : G[v]){\n\t\tif (used[to]) continue;\n\t\tres = max(res, dfs(to)+1);\n\t}\n\tused[v] = 0;\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tMEMSET(v, 0);\n\t\trep(i, N) G[i].clear();\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tv[x][y] = v[y][x] = 1;\n\t\t}\n\t\trep(i, N) rep(j, N) if (v[i][j]) G[i].push_back(j);\n\t\tint ans = 2;\n\t\trep(i, N) ans = max(ans, dfs(i)+1);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> g[101];\nbool use[101];\n\nint dfs(int x){\n  int res = 1;\n  use[x] = true;\n  for(int i=0;i<(int)g[x].size();i++){\n    if(!use[g[x][i]])res = max(res,dfs(g[x][i])+1);\n  }\n  use[x] = false;\n  return res;\n}\n\nint main(){\n  int n;\n  int a,b;\n\n  while(cin>> n && n){\n    for(int i=0;i<=100;i++){\n      use[i] = false;\n      g[i].clear();\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n\n    int ans = 0;\n    for(int i=0;i<=100;i++)\n      if(g[i].size())ans = max(ans,dfs(i));\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nstruct chain {int a, b; };\nint n;\ndeque<int> deq;\nchain c[100];\nbool used[100];\nint cnt() {\n    set<int> s;\n    for (int i=0; i<deq.size(); i++) s.insert(deq[i]);\n    return s.size();\n}\nint dfs() {\n    int res=cnt();\n    int s=deq[0], t=deq[deq.size()-1];\n//    for (int i=0; i<res; i++) printf(\"%d%c\",deq[i],i==res-1?'\\n':' ');\n    for (int i=0; i<n; i++) {\n        if (used[i]) continue;\n        if (t==c[i].a) {\n            used[i]=true;\n            deq.push_back(c[i].b);\n            res=max(res,dfs());\n            deq.pop_back();\n            used[i]=false;\n        } else if (t==c[i].b) {\n            used[i]=true;\n            deq.push_back(c[i].a);\n            res=max(res,dfs());\n            deq.pop_back();\n            used[i]=false;\n        }\n        if (s==c[i].a) {\n            used[i]=true;\n            deq.push_front(c[i].b);\n            res=max(res,dfs());\n            deq.pop_front();\n            used[i]=false;\n        } else if (s==c[i].b) {\n            used[i]=true;\n            deq.push_front(c[i].a);\n            res=max(res,dfs());\n            deq.pop_front();\n            used[i]=false;\n        }\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        memset(used, 0, sizeof(used));\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d\",&c[i].a,&c[i].b);\n        }\n        int res=0;\n        for (int i=0; i<n; i++) {\n            used[i]=true;\n            deq.push_back(c[i].a); deq.push_back(c[i].b);\n            res=max(res, dfs());\n            deq.pop_back(); deq.pop_back();\n            used[i]=false;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\ts = Solve(*it);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nint rec(int pos, vector<bool> used)\n{\n    used[pos] = true; int ret = 0;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used));\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n    \n        G = vector<vector<int> >(100);\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(false, 100)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_N = 100;\n\nint N; \nvector<int> G[100];\nbool visited[100];\n\nint dfs(int pos, int dist){\n    int ret = dist;\n    visited[pos] = true;\n    for(auto &e : G[pos]){\n        if(visited[e]) continue;\n        visited[e] = true;\n        ret = max(ret, dfs(e, dist+1));\n        visited[e] = false;\n    }\n    visited[pos] = false;\n    return ret;\n}\n\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int x = 0; x < N; x++){\n            G[x].clear();\n        }\n        for(int x = 0; x < N; x++){\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            --a; --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        int dist = 0;\n        fill(visited, visited+N, false);\n        for(int x = 0; x < 100; x++){\n            dist = max(dist, dfs(x, 1));\n        }\n        printf(\"%d\\n\", dist);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100],L[100],D[100];\n\nint solve(int m)\n{\n    int r=0;\n    D[m]=1;\n    for(int i=0;i<L[m];i++){\n        int k=G[m][i];\n        if(!D[k]){\n            r=max(r,solve(k));\n        }\n    }\n    D[m]=0\n    return r+1;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(L,0,sizeof(L));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a][L[a]++]=b;\n            G[b][L[b]++]=a;\n        }\n        for(int i=0;i<100;i++){\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<int,int>\n#define pb push_back\n\nint n,used[100];\nvector<int> v[100];\n\nint f(int from){\n\tint res=0;\n\trep(i,v[from].size()){\n\t\tint to=v[from][i];\n\t\tif(!used[to]){\n\t\t\tused[to]=1;\n\t\t\tres=max(res,f(to)+1);\n\t\t\tused[to]=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+n,0);\n\t\trep(i,100)v[i].clear();\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;a--;b--;\n\t\t\tv[a].pb(b);\n\t\t\tv[b].pb(a);\n\t\t}\n\t\tint ans=2;\n\t\trep(i,100){\n\t\t\trep(j,v[i].size()){\n\t\t\t\tused[i]=used[v[i][j]]=1;\n\t\t\t\tans=max(ans,f(v[i][j])+2);\n\t\t\t\tused[i]=used[v[i][j]]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nvvi adj;\nint ans,cnt;\nbool visited[100];\n\nvoid dfs(int u){\n\tif(ans<cnt) ans=cnt;\n\n\tcnt++;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tdfs(v);\n\t\t\tvisited[v]=false;\n\t\t}\n\t}\n\tcnt--;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d\",&m),m;){\n\t\tbool adjm[100][100]={},flg[100]={};\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\ta--, b--;\n\t\t\tadjm[a][b]=adjm[b][a]=flg[a]=flg[b]=true;\n\t\t}\n\n\t\tint f[100],n=0;\n\t\trep(i,100) if(flg[i]) f[i]=n++;\n\n\t\tadj=vvi(n);\n\t\trep(i,100) rep(j,100) if(adjm[i][j]) adj[f[i]].pb(f[j]);\n\n\t\tans=0,cnt=1;\n\t\trep(u,n-1){\n\t\t\tvisited[u]=true;\n\t\t\tdfs(u);\n\t\t\tvisited[u]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    ifstream ifs(\"input.txt\");\n    ofstream ofs(\"output.txt\");\n    \n    while(1)\n    {\n        int num;\n        ifs>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            ifs>>a;\n            ifs>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                maxLength = (*it).length;\n            }\n            ++it;\n        }\n        ofs<<maxLength<<endl;\n        \n    }\n    ofs<<endl;\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[101][100];\nint cn[101];\nint maxchain(int m,int l,bool inchain[101]){\n\tint ml=l;\n\tfor(int i=0;i<cn[m];i++){\n\t\tif(!inchain[c[m][i]]){\n\t\t\tinchain[c[m][i]]=true;\n\t\t\tint ll=maxchain(c[m][i],l+1,inchain);\n\t\t\tif(ml<ll){ml=ll;}\n\t\t\tinchain[c[m][i]]=false;\n\t\t}\n\t}\n\treturn ml;\n}\nint main() {\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0){break;}\n\t\tint s[2][n];\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tcn[i]=0;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s[0][i] >> s[1][i];\n\t\t\tc[s[0][i]][cn[s[0][i]]]=s[1][i];\n\t\t\tcn[s[0][i]]++;\n\t\t\tc[s[1][i]][cn[s[1][i]]]=s[0][i];\n\t\t\tcn[s[1][i]]++;\n\t\t}\n\t\tint ml=0;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tint l=1;\n\t\t\tbool inchain[101];\n\t\t\tfor(int j=1;j<101;j++){\n\t\t\t\tinchain[j]=false;\n\t\t\t}\n\t\t\tinchain[i]=true;\n\t\t\tl=maxchain(i,l,inchain);\n\t\t\tif(ml<l){\n\t\t\t\tml=l;\n\t\t\t}\n\t\t}\n\t\tcout << ml << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint c[100][2];\nint n;\n\nint ring(int e,int l,int done[]){/*e:?????????e+1,e?????§???????????????l,???????????¨?±\\??´done*/\n    int i;\n    int cpy[100];\n    int templ;\n    int end = 1;\n    int lmax = l;\n    /*printf(\"called: ring(%d,%d,[\",e,l);\n    for(i=0;i<7;i++)printf(\"%d,\",done[i]);\n    printf(\"])\\n\");*/\n    for(i=0;i<100;i++)cpy[i]=done[i];\n    for(i=0;i<n;i++){/*?????????e+1????´??????¢???*/\n        if(c[i][0]==e+1&&cpy[c[i][1]-1]){\n            end = 0;\n            cpy[c[i][1]-1] = 0;\n            templ = ring(c[i][1]-1,l+1,cpy);\n            cpy[c[i][1]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n        if(c[i][1]==e+1&&cpy[c[i][0]-1]){\n            end = 0;\n            cpy[c[i][0]-1] = 0;\n            templ = ring(c[i][0]-1,l+1,cpy);\n            cpy[c[i][0]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n    }\n    /*printf(\"return(from ring(%d,%d)): %d)\\n\",e,l,lmax);*/\n    return end ? l : lmax;\n}\n\nint main(){\n    int i;\n    int done[100];/*done[i] 1:i+1???????????¨ 0;i+1????????¨???or?????´??????*/\n    int ans,tmp;\n    scanf(\"%d\",&n);\n    while(n){\n        for(i=0;i<100;i++)done[i]=0;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&c[i][0],&c[i][1]);\n            done[c[i][0]-1] = 1;\n            done[c[i][1]-1] = 1;\n        }\n        ans = 0;\n        for(i=0;i<100;i++){/*?§?????????????????????????*/\n            if(done[i]){\n                done[i] = 0;\n                tmp = ring(i,1,done);\n                done[i] = 1;\n                if(tmp>ans)ans=tmp;\n            }\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n    time_t\tstart_time, t;\n\n    while(1)\n    {\n\tstart_time = time(NULL);\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t    if (time(NULL) - start_time > 3)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ls[100];\nbool visited[100];\nint dfs(int now,int l){\n\tint ans=l;\n\tvisited[now]=true;\n\tfor(int i=0;i<(int)ls[now].size();i++){\n\t\tif(visited[ls[now][i]])\tcontinue;\n\t\tans=max(ans,dfs(ls[now][i],l+1));\n\t}\n\tvisited[now]=false;\n\treturn ans;\n}\nint main(){\n\twhile(true){\n\t\tint n;\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tfor(int i=0;i<100;i++)\tls[i].clear();\n\t\tset<int> uses;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\tcin>>a>>b;\ta--;\tb--;\n\t\t\tuses.insert(a);\tuses.insert(b);\n\t\t\tls[a].push_back(b);\tls[b].push_back(a);\n\t\t}\n\t\tint ans=0;\n\t\tfor(auto it=uses.begin();it!=uses.end();it++){\n\t\t\tans=max(ans,dfs(*it,1));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<int>E[100];\nbool flag[100];\nint Max;\n\nvoid solve(int v, int len) {\n\tif (len > Max)Max = len;\n\tfor (int u : E[v]) {\n\t\tif (!flag[u]) {\n\t\t\tflag[u] = true;\n\t\t\tsolve(u, len + 1);\n\t\t\tflag[u] = false;\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, 100)E[i].clear();\n\t\tmemset(flag, 0, sizeof(flag));\n\t\trep(i, n) {\n\t\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tE[a].push_back(b); E[b].push_back(a);\n\t\t}\n\t\tMax = 0;\n\t\trep(i, 100) {\n\t\t\tflag[i] = true;\n\t\t\tsolve(i, 1);\n\t\t\tflag[i] = false;\n\t\t}\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> point,edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=0;\n\tfor(int i=0;i<edge[n].size();i++) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tif(edge[edge[n][i]].size()>0) {\n\t\t\t\tvisit[edge[n][i]]=true;\n\t\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t\t\tvisit[edge[n][i]]=false;\n\t\t\t}else mx=max(mx,1);\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfor(int i=0;i<n;i++) edge[i].clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tif(find(point.begin(),point.end(),a)==point.end()) point.push_back(a);\n\t\t\tif(find(point.begin(),point.end(),b)==point.end()) point.push_back(b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=0;i<point.size();i++) {\n\t\t\tvisit[point[i]]=true;\n\t\t\tmx=max(mx,solve(point[i])+1);\n\t\t\tvisit[point[i]]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nmap<pair<int, vector<bool> > , bool> M;\n\nint rec(int pos, vector<bool> used)\n{\n    if(M[make_pair(pos, used)]) { return 1; }\n    \n    M[make_pair(pos, used)] = true;\n    \n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used) + 1);\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n        \n        M.clear();\n    \n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(100, false)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<pair<int,int>> S;\n\tint i,j,k,n,d_min,inv,dep,max,max1;\n\tint a[101],b[101],d[101],e[101][101],v[101],c[101];\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\td_min=100;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\te[i][j]=0;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tc[i]=0;\n\t\t}\n\t\tfor(i=0;i<=n-1;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t\te[a[i]][b[i]]=e[b[i]][a[i]]=1;\n\t\t}\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\tif(e[i][j]==1) d[i]++;\n\t\t\t}\n\t\t\tif(d_min>d[i] && d[i]>=1) d_min=d[i];\n\t\t}\n\t\tj=0;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tif(d[i]==d_min)\n\t\t\t{\n\t\t\t\tv[j]=i;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=0;i<=j-1;i++)\n\t\t{\n\t\t\tmax1=0;\n\t\t\tc[v[i]]=1;\n\t\t\tS.push(make_pair(v[i],0));\n\t\t\twhile(S.empty()!=1)\n\t\t\t{\n\t\t\t\tinv=S.top().first;\n\t\t\t\tdep=S.top().second;\n\t\t\t\tS.pop();\n\t\t\t\tfor(k=1;k<=100;k++)\n\t\t\t\t{\n\t\t\t\t\tif(e[inv][k]==1 && c[k]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[k]=1;\n\t\t\t\t\t\tS.push(make_pair(k,dep+1));\n\t\t\t\t\t\tif(max1<dep+1) max1=dep+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<max1) max=max1;\n\t\t\tfor(k=0;k<=100;k++) c[k]=0;\n\t\t}\n\t\tcout << max+2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tvis[a]=1;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tret=max(ret,dfs(vv[a][i],b));\n\t}\n\tvis[a]=0;\n\treturn ret+1;\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvv=vector<vint>(n);\n\t\tvis=vint(n,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tvis[j]=0;\n\t\t\t}\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tans=max(ans,dfs(i,0));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,G[100][100],L[100],D[100];\n\nint solve(int m)\n{\n    int r=0,k;\n    for(int i=0;i<L[m];i++){\n        k=G[m][i];\n        if(!D[k]){\n            D[k]=1;\n            r=max(r,1+solve(k));\n            D[k]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(L,0,sizeof(L));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a][L[a]++]=b;\n            G[b][L[b]++]=a;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100];\nvector<int> d[100];\nbool used[100];\nint max(int a,int b){return a>b?a:b;}\nint dfs(int f,int t){\n\tint i;\n\tint m=0;\n\tfor(i=0;i<e[t].size();i++){\n\t\tif(e[t][i]==f)continue;\n\t\tif(used[e[t][i]]){\n\t\t\te[t].erase(e[t].begin()+i);\n\t\t\td[t].erase(d[t].begin()+i);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!used[e[t][i]]&&d[t][i]==-1){\n\t\t\tused[t]=true;\n\t\t\td[t][i]=dfs(t,e[t][i]);\n\t\t\tused[t]=false;\n\t\t}\n\t\tm=max(m,d[t][i]);\n\t}\n\treturn m+1;\n}\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tfor(i=0;i<100;i++){\n\t\te[i].clear();\n\t\td[i].clear();\n\t}\n\tfor(i=0;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t\td[a].push_back(-1);\n\t\td[b].push_back(-1);\n\t}\n\tint ans=0;\n\tfor(i=0;i<100;i++)used[i]=false;\n\tfor(i=0;i<100;i++){\n\t\tfor(j=0;j<e[i].size();j++){\n\t\t\tif(d[i][j]==-1){\n\t\t\t\tused[i]=true;\n\t\t\t\td[i][j]=dfs(i,e[i][j]);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t\tans=max(ans,d[i][j]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\n\nint search(int now)\n{\n\tvis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tif (!vis[v[now][i]]) res = max(res, search(v[now][i]) + 1);\n\t}\n\t\n\tvis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t}\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t\n\t\tint maxi = 1;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t//if (v[i].size() - mini <= 1){\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\tint n,t1,t2,i=0;\n\tint a[10]={11,19,24,10,65,9,35,51,25,20};\n\tcin>>n;\n\twhile(n!=0){\n\t\tfor(int I=0;I<n;I++)cin>>t1>>t2;\n\t\tcout<<a[i]<<endl;\n\t\ti++;\n\t\tcin>>n;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n#define MAX 105\nvector<int> G[MAX];\nint searched[MAX];\nint point[MAX];\n\nint dfs(int node){\n  stack<int> s;\n  int ret=0;\n  s.push(node);\n  point[node]=1;\n  while(!s.empty()){\n    int now_s=s.top(); s.pop();\n    searched[now_s]=true;\n    \n    bool done=0;\n    for(int i=0; i<G[now_s].size(); i++){\n      int nex=G[now_s][i];\n      if(searched[nex]) continue;\n      s.push(nex);\n      point[nex]=max(point[now_s]+1,point[nex]);\n      done=true;\n    }\n    if(!done) ret=max(ret,point[now_s]);\n  }\n  return ret;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n&&n){\n    for(int i=0; i<=101; i++) G[i].clear();\n    for(int i=0; i<n; i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n      \n    int ans_max=0;\n    for(int i=1; i<=101; i++){\n      for(int j=0; j<=101; j++){\n        searched[j]=0;\n        point[j]=0;\n      }\n      ans_max=max(dfs(i),ans_max);\n    }\n      \n    cout<<ans_max<<en\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, g[101][101], g_size[101];\nbool used[101];\n\nint rec(int idx)\n{\n  int ret = 1;\n  for(int i = 0; i < g_size[idx]; i++){\n    if(!used[g[idx][i]]){\n      used[g[idx][i]] = true;\n      ret = max( ret, rec(g[idx][i]) + 1);\n      used[g[idx][i]] = false;\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  while(cin >> n, n){\n  fill_n( g_size, 101, 0);\n  for(int i = 0; i < n; i++){\n    int a, b;\n    cin >> a >> b;\n    g[a][g_size[a]++] = b;\n    g[b][g_size[b]++] = a;\n  }\n\n  int ans = 1;\n  for(int i = 1; i <= 100; i++){\n    if(g_size[i] > 0){\n      used[i]  = true;\n      ans = max( ans, rec(i));\n      used[i] = false;\n    }\n  }\n  cout << ans << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool visited[100];\nint g[100][100];\nint size[100];\ninline int solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tfor(int i=0;i<size[a];i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)\n\t\t\tfor(int j=0;j<100;j++)\n\t\t\t\tg[i][j]=0;\n\t\tfor(int i=0;i<100;i++)size[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1][size[b-1]++]=c-1;\n\t\t\tg[c-1][size[c-1]++]=b-1;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[i]=false;\n            solve(i,len+1);\n            points[i]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<100;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\n\nint search(int now)\n{\n\t//vis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tvis[now] = true;\n\t\tif (!vis[v[now][i]]) res = max(res, search(v[now][i]) + 1);\n\t\tvis[now] = false;\n\t}\n\t\n\t//vis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t}\n\t\t/*\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t*/\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t//if (v[i].size() - mini <= 1){\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\nint ans = 2;\n\nvoid dfs(int now, bool visited[], int sum){\n    sum++;\n    visited[now] = true;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]) dfs(next, visited, sum);\n    }\n    ans = max(ans, sum);\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        ans = 2;\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        REP(i, vsize){\n            bool visited[N] = {false};\n            dfs(v[i], visited, 0);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool visited[100];\nvector<int> g[100];\nint solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j) for(int i = 0; i < (j); i++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nvvi G = vvi(100, vi(100, -1));\nbool memo[101];\nint func(int s, int n) {\n\tmemo[s] = true;\n\tint ret = n;\n\trep(i, G[s].size()) {\n\t\tif(memo[G[s][i]]) continue;\n\t\tret = max(ret, func(G[s][i], n + 1));\n\t}\n\tmemo[s] = false;\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile(cin >> n,n) {\n\t\trep(i, G.size())rep(j, G[i].size()) G[i][j] = -1;\n\t\trep(i, n) {\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tint ans = -1;\n\t\trep(i, G.size()) {\n\t\t\tmemset(memo, 0, sizeof(memo));\n\t\t\tans = max(ans, func(i, 0));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = -1;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0508\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstring>\n\nint n;\nstd::vector<int> es[101];\nbool used[101];\n\nint dfs( int p )\n{\n\tint ret = 1;\n\t\n\tfor( int i = 0; i != es[p].size(); ++i )\n\t{\n\t\tif( !used[es[p][i]] )\n\t\t{\n\t\t\tused[es[p][i]] = true;\n\t\t\tret = std::max( ret, dfs( es[p][i] ) + 1 );\n\t\t\tused[es[p][i]] = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile( std::cin >> n, n )\n\t{\n\t\tfor( int i = 0; i <= 100; ++i )\n\t\t\tes[i].clear();\n\t\t\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint a, b;\n\t\t\tstd::cin >> a >> b;\n\n\t\t\tes[a].push_back( b );\n\t\t\tes[b].push_back( a );\n\t\t}\n\n\t\tint m = 101;\n\t\tfor( int i = 1; i <= 100; ++i )\n\t\t\tif( !es[i].empty() )\n\t\t\t\tm = std::min( m, (int)es[i].size() );\n\n\t\tint ans = 0;\n\t\tfor( int i = 1; i <= 100; ++i )\n\t\t{\n\t\t\tif( es[i].size() == m )\n\t\t\t{\n\t\t\t\tmemset( used, false, sizeof( used ) );\n\t\t\t\tused[i] = true;\n\t\t\t\tans = std::max( ans, dfs( i ) );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 111;\n\nvector<int> edge[N];\nint visit[N];\n\nint saiki(int p){\n\tif(visit[p]==1)return 0;\n\tvisit[p]=1;\n\t\n\tint ret = 0;\n\trep(i,edge[p].size()){\n\t\tret = max(saiki(edge[p][i])+1, ret);\n\t}\n\t\n\tvisit[p]=0;\n\treturn ret;\n}\n\nint main(){\n\tA:;\n\t\n\tint n;\n\tcin>>n;\n\tif(n==0)return 0;\n\t\n\trep(i,N)edge[i].clear();\n\t\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\t\n\trep(i,N)visit[i]=0;\n\tint ans = 0;\n\trep(i,N){\n\t\tans = max(saiki(i),ans);\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std; \n\n\nstatic const int black = 1;\nstatic const int white = 0;\n\nint graph[128][128] = {{}};\nint color[128] = {};\nint n,d = 0,ans = 0;\nint de[128] = {};\n\nvoid bfs(int in){\n\n  // cout << \"in = \" << in << endl;\n  int u;\n  u = in;\n  color[u] = black;\n  for(int i = 0;i < n;i++){\n    d = de[u];\n    if(color[i] != black && graph[u][i] == 1){\n      d++;\n      de[i] = d;\n      // cout << \"u = \" << u << \"i = \" << i << endl;\n      bfs(i);\n    }\n  }\n  for(int i = 0;i < n;i++){\n    if(de[i] > ans) ans = de[i];\n  }\n}\n\n\nint main(){\n\n  while(1){\n    int mae,ato;\n\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i =0;i < n;i++){\n      cin >> mae >> ato;\n      graph[mae - 1][ato - 1] = 1;\n      graph[ato - 1][mae - 1] = 1;\n    }\n\n    for(int i = 0;i < n;i++){\n      for(int  j = 0;j < n;j++){\n\t///\tcout <<  graph[i][j] << ' ';\n      }\n      // cout << endl;\n    }\n\n    for(int i = 0;i < n;i++){\n      for(int j = 0;j < 128;j++){\n\tcolor[j] = white;\n\tde[j] = 0;\n      }\n      // cout << \"b:i \" << i << endl; \n      bfs(i);\n      // for(int i = 0;i < n;i++)// cout << de[i] << endl;\n    }\n\n    for(int i = 0;i < n;i++){\n      if(de[i] > ans) ans = de[i];\n    }\n\n    cout << ans + 1 << endl;\n    for(int i = 0;i < 128;i++){\n      for(int j = 0;j < 128;j++){\n\tgraph[i][j] = 0;\n      }\n      color[i] = 0;\n      de[i] = 0;\n    }\n    d = 0;\n    ans = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint done[100];\nint c[100][2];\n\nmain(){\n  int i;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint chain(int e,int l){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isVisited[101];\n\nint dfs(const vector<vector<int>>& r, int pos) {\n    if (isVisited[pos]) {\n        return 0;\n    }\n\n    isVisited[pos] = true;\n    int ret = 0;\n    for (int i = 0; i < r[pos].size(); i++) {\n        ret = max(ret, dfs(r, r[pos][i]));\n    }\n    isVisited[pos] = false;\n\n    return ret+1;\n}\n\nint main(void) {\n    for (int i = 0; i <= 100; i++) {\n        isVisited[i] = false;\n    }\n\n    int n;\n    while (cin >> n, n) {\n        vector<vector<int>> rings(n+1);\n        int a, b;\n        for (int i = 0; i < n; i++) {\n            cin >> a >> b;\n            rings[a].push_back(b);\n            rings[b].push_back(a);\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            ans = max(ans, dfs(rings, i));\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    while(1)\n    {\n        int num;\n        cin>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            cin>>a>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                maxLength = (*it).length;\n            }\n            ++it;\n        }\n        cout<<maxLength<<endl;\n        \n    }\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n}\n\nint main(){\n    \n    while(1)\n    {\n        int num;\n        cin>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            cin>>a;\n            cin>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                macLength = (*it).length;\n            }\n        }\n        cout<<macLength<<endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nint ma;\nvector<int> G[105];\nbool visit[105];\n\nvoid dfs(int cur, int depth = 1)\n{\n    ma = max(ma, depth);\n\n    for (int u : G[cur]) {\n        if (visit[u]) {\n            continue;\n        }\n\n        visit[u] = true;\n\n        dfs(u, depth + 1);\n\n        visit[u] = false;\n    }\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        for (int i = 0; i < 100; ++i) G[i].clear();\n\n        for (int i = 0; i < N; ++i) {\n            int a, b; cin >> a >> b;\n            --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        ma = 0;\n\n        for (int i = 0; i < N; ++i) {\n            visit[i] = true;\n            dfs(i);\n            visit[i] = false;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VERTEX_NUM 100\n\ntypedef struct {\n    char linked_num;\n    char linked[MAX_VERTEX_NUM-1];\n} vertex;\n\nvertex vertex_list[MAX_VERTEX_NUM];\nbool has_arrived[MAX_VERTEX_NUM];\nchar count_max;\n\nvoid vertex_init() {\n    int i;\n    for (i=0;i < MAX_VERTEX_NUM;i++) {\n        vertex_list[i].linked_num = 0;\n    }\n\n    return ;\n}\n\nvoid link(int id1, int id2) {\n    vertex *obj1 = &vertex_list[id1];\n    vertex *obj2 = &vertex_list[id2];\n\n    int num1 = obj1->linked_num;\n    int num2 = obj2->linked_num;\n    obj1->linked[num1] = id2;\n    obj2->linked[num2] = id1;\n\n    obj1->linked_num += 1;\n    obj2->linked_num += 1;\n\n    return ;\n}\n\nvoid rec(int id, int now_count) {\n    int i;\n\n    if (has_arrived[id]) {\n        return ;\n    }\n\n    has_arrived[id] = 1;\n    if (count_max < now_count+1)count_max = now_count+1;\n\n    for (i=0;i < vertex_list[id].linked_num;i++) {\n        rec(vertex_list[id].linked[i], now_count + 1);\n    }\n\n    has_arrived[id] = 0;\n\n    return ;\n}\n\nint main() {\n    while (1) {\n        int i,n;\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n\n        vertex_init();\n\n        for (i=0;i<n;i++) {\n            int id1, id2;\n            scanf(\"%d %d\", &id1, &id2);\n            link(id1-1, id2-1);\n        }\n\n        count_max = 0;\n\n        for (i=0;i<n;i++) {\n            rec(i, 0);\n        }\n\n        printf(\"%d\\n\", count_max);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n \nint rec(int pos)\n{\n    used[pos] = 1; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = 0;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = rings[i] = 0;\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A][rings[A]] = B; rings[A]++;\n            G[B][rings[B]] = A; rings[B]++;\n        }\n\n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#define rep(i,n) for(int (i)=0;(i) < (n);(i)++)\n#define MAX 110\nusing namespace std;\nvector<int> G[MAX];\nbool flag[MAX];\n\nint dfs(int now){\n    flag[now]=1;\n    int ret = 1;\n    rep(i,G[now].size()){\n        if(flag[G[now][i]]==0)\n            ret = max(ret,dfs(G[now][i])+1);\n    }\n    flag[now]=0;\n    return ret;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\",&n),n!=0){\n        rep(i,MAX){\n            G[i].clear();\n            flag[i]=0;\n        }\n        int x,y;\n        rep(i,n){\n            scanf(\"%d %d\",&x,&y);\n            x--;\n            y--;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        rep(i,MAX){\n            if(G[i].empty())\n                break;\n            sort(G[i].begin(),G[i].end());\n            G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n        }\n        int ret = 0;\n        rep(i,MAX){\n            ret = max(ret,dfs(i));\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool used_once[100];\nbool used[100];\nint dfs(int v)\n{\n\tused_once[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tpint e[100];\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\te[i] = pint(edge[i].size(), i);\n\t\tsort(e, e+100);\n\n\t\tint res = 0;\n\t\tint last = 9999;\n\t\tfill(used_once, used_once + 100, false);\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t{\n\t\t\tif (!used_once[e[i].second] || e[i].first == last)\n\t\t\t{\n\t\t\t\tres = max(res, dfs(e[i].second));\n\t\t\t\tlast = e[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_N = 100;\n\nint N; \nvector<int> G[100];\nbool visited[100];\n\nint dfs(int pos, int dist){\n    int ret = dist;\n    for(auto &e : G[pos]){\n        if(visited[e]) continue;\n        visited[e] = true;\n        ret = max(ret, dfs(e, dist+1));\n        visited[e] = false;\n    }\n    return ret;\n}\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int x = 0; x < N; x++){\n            G[x].clear();\n        }\n        for(int x = 0; x < N; x++){\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            --a; --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        int dist = 0;\n        fill(visited, visited+N, false);\n        for(int x = 0; x < N; x++){\n            visited[x] = true;\n            dist = max(dist, dfs(x, 1));\n            visited[x] = false;\n        }\n        printf(\"%d\\n\", dist);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint r[110][110],vf[110],ans;\nchar d[110];\nvoid dfs(int cr,int len,char f[]){\n\tint i,j,ff=0;\n\tchar s[110];\n\tfor(i=1;i<=100;i++){\n\t\tif(r[cr][i]==1 && f[i]==0){\n\t\t\tff=1;d[i]=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,len+1,f);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0){\n\t\tans=MAX(ans,len);\n\t\t//printf(\"(%d-%d)\\n\",cr,ans);\n\t\tif(vf[cr]==0){\n\t\t\tchar s[110];\n\t\t\tvf[cr]=1;\n\t\t\tmemset(s,0,sizeof(s));\n\t\t\ts[cr]=1;\n\t\t\tdfs(cr,1,s);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x,y,z;\n\tchar f[110];\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(r,0,sizeof(r));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tr[a][b]=r[b][a]=1;\n\t\t}\n\t\tx=110;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tz=0;\n\t\t\tfor(j=1;j<=100;j++)if(r[i][j]==1)z++;\n\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t}\n\t\t//printf(\"y:%d\\n\",y);\n\t\tmemset(d,0,sizeof(d));d[y]=1;\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\tmemset(vf,0,sizeof(vf));vf[y]=1;\n\t\tdfs(y,1,f);\n\t\t\n\t\twhile(1){\n\t\t\tx=110;\n\t\t\tfor(i=1;i<=100;i++){\n\t\t\t\tif(vf[i]==1)continue;\n\t\t\t\tz=0;\n\t\t\t\tfor(j=1;j<=100;j++)if(d[j]==0 && r[i][j]==1)z++;\n\t\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t\t}\n\t\t\tif(x==110)break;\n\t\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\t\tvf[y]=1;d[y]=1;\n\t\t\tdfs(y,1,f);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, g[101][101], g_size[101];\nbool used[101];\n\nint rec(int idx)\n{\n  int ret = 1;\n  for(int i = 0; i < g_size[idx]; i++){\n    if(!used[g[idx][i]]){\n      used[g[idx][i]] = true;\n      ret = max( ret, rec(g[idx][i]) + 1);\n      used[g[idx][i]] = false;\n    }\n  }\n  return ret;\n}\n\n\nint main()\n{\n  while(cin >> n, n){\n  for(int i = 0; i < n; i++){\n    int a, b;\n    cin >> a >> b;\n    g[a][g_size[a]++] = b;\n    g[b][g_size[b]++] = a;\n  }\n\n  int ans = 1;\n  for(int i = 1; i <= 100; i++){\n    if(g_size[i] > 0){\n      used[i]  = true;\n      ans = max( ans, rec(i));\n      used[i] = false;\n    }\n  }\n  cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VERTEX_NUM 100\n\ntypedef struct {\n    char linked_num;\n    char linked[MAX_VERTEX_NUM-1];\n} vertex;\n\nvertex vertex_list[MAX_VERTEX_NUM];\nbool has_arrived[MAX_VERTEX_NUM];\nchar count_max;\n\nvoid vertex_init() {\n    int i;\n    for (i=0;i < MAX_VERTEX_NUM;i++) {\n        vertex_list[i].linked_num = 0;\n    }\n\n    return ;\n}\n\nvoid link(int id1, int id2) {\n    vertex *obj1 = &vertex_list[id1];\n    vertex *obj2 = &vertex_list[id2];\n\n    int num1 = obj1->linked_num;\n    int num2 = obj2->linked_num;\n    obj1->linked[num1] = id2;\n    obj2->linked[num2] = id1;\n\n    obj1->linked_num += 1;\n    obj2->linked_num += 1;\n\n    return ;\n}\n\nvoid rec(int id, int now_count) {\n    int i;\n\n    if (has_arrived[id]) {\n        return ;\n    }\n\n    has_arrived[id] = 1;\n    if (count_max < now_count+1)count_max = now_count+1;\n\n    for (i=0;i < vertex_list[id].linked_num;i++) {\n        rec(vertex_list[id].linked[i], now_count + 1);\n    }\n\n    has_arrived[id] = 0;\n\n    return ;\n}\n\nint main() {\n    while (1) {\n        int i,n;\n        scanf(\"%d\", &n);\n        if (n == 0) return;\n\n        vertex_init();\n\n        for (i=0;i<n;i++) {\n            int id1, id2;\n            scanf(\"%d %d\", &id1, &id2);\n            link(id1-1, id2-1);\n        }\n\n        count_max = 0;\n\n        for (i=0;i<n;i++) {\n            rec(i, 0);\n        }\n\n        printf(\"%d\\n\", count_max);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\ntypedef pair<int,int> pii;\n\nconst int N = 111;\n\nclass P{\n\tpublic:\n\tint first;\n\tint second;\n\tint depth;\n\tP(int a,int b,int c):first(a),second(b),depth(c){}\n};\n\nclass S{\n\tpublic:\n\tint n;\n\tvector<int> edge[N];\n\t\n\tbool input(){\n\t\tcin>>n;\n\t\tif(n==0)return false;\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint visit[N];\n\tint solve2(int st){\n\t\tint ret = 0;\n\t\trep(i,edge[st].size()){\n\t\t\tint next = edge[st][i];\n\t\t\tif(visit[next]==0){\n\t\t\t\tvisit[next]=1;\n\t\t\t\tret = max(solve2(next)+1, ret);\n\t\t\t\tvisit[next]=0;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint solve(){\n\t\tint ans = 0;\n\t\trep(i,N)visit[i]=0;\n\t\trep(i,N){\n\t\t\t\n\t\t\tans = max(ans, solve2(i));\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tvoid call(){\n\t\tcout<<solve()<<endl;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tS s;\n\t\tif(!s.input())break;\n\t\ts.call();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<pair<int,int>> S;\n\tint i,j,k,n,inv,dep,max,max1;\n\tint a[101],b[101],d[101],e[101][101],c[101];\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\te[i][j]=0;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tc[i]=0;\n\t\t}\n\t\tfor(i=0;i<=n-1;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t\te[a[i]][b[i]]=1;\n\t\t\te[b[i]][a[i]]=1;\n\t\t}\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\tif(e[i][j]==1) d[i]++;\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=1;i<=100;i++)\n\t\t{\n\t\t\tif(d[i]!=0)\n\t\t\t{\n\t\t\t   max1=0;\n\t\t\t   c[i]=1;\n\t\t\t   S.push(make_pair(i,0));\n\t\t\t   while(S.empty()!=1)\n\t\t\t   {\n\t\t\t\t   inv=S.top().first;\n\t\t\t\t   dep=S.top().second;\n\t\t\t\t   S.pop();\n\t\t\t\t   for(k=1;k<=100;k++)\n\t\t\t\t   {\n\t\t\t\t\t   if(e[inv][k]==1 && c[k]==0)\n\t\t\t\t\t   {\n\t\t\t\t\t\t   c[k]=1;\n\t\t\t\t\t\t   S.push(make_pair(k,dep+1));\n\t\t\t\t\t\t   if(max1<dep+1) max1=dep+1;\n\t\t\t\t\t   }\n\t\t\t\t   }\n\t\t\t   }\n\t\t\t   if(max<max1) max=max1;\n\t\t\t   for(k=0;k<=100;k++) c[k]=0;\n\t\t\t}\n\t\t}\n\t\tcout << max+2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint ans;\n\nvoid Dfs(vector<int> way[100],bool used[100],int n,int d){\n\t//printf(\"%d,%d\\n\",n,d);\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tif(used[way[n][i]]) continue;\n\t\tDfs(way,used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tans = 0;\n\t\tvector<int> way[100];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tDfs(way,used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nbool d[101],dd[101];\t//true = 使った。\n\nint ans = 0;\nint n;\nvector<int> G[101];\n\n\n\nint dfs(int from, int now)\n{\n\n\tfor(int i = 0; i < G[from].size(); i++){\n\t\tif(!d[G[from][i]]){\n\t\t\td[G[from][i]] = true;\n\t\t\tif(G[from].size() > 2)\n\t\t\t\tdd[G[from][i]] = true;\n\t\t\tans = max(ans,dfs(G[from][i], now+1));\n\t\t\td[G[from][i]] = false;\n\t\t}\n\t}\n\n\treturn now;\n}\n\nint main(void)\n{\n\n\tans = 0;\n\n\twhile(cin >> n,n){\nans = 0;\n\t\tint from,to;\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\td[i] = dd[i] = false;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> from >> to;\n\t\t\tG[from].push_back(to);\n\t\t\tG[to].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif(!dd[i]){\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\twhile(G[i].size())\n\t\t\t\tG[i].pop_back();\n\n\t\tcout << ans-1 << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n    time_t\tstart_time, t;\n\n    while(1)\n    {\n\tstart_time = time(NULL);\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t    if (time(NULL) - start_time > 7)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isVisited[101];\n\nint dfs(const vector<vector<int>>& r, int pos) {\n    if (isVisited[pos]) {\n        return 0;\n    }\n\n    isVisited[pos] = true;\n    int ret = 0;\n    for (int i = 0; i < r[pos].size(); i++) {\n        ret = max(ret, dfs(r, r[pos][i]));\n    }\n    isVisited[pos] = false;\n\n    return ret+1;\n}\n\nint main(void) {\n    for (int i = 0; i <= 100; i++) {\n        isVisited[i] = false;\n    }\n\n    int n;\n    while (cin >> n, n) {\n        vector<vector<int>> rings(101);\n        int a, b;\n        for (int i = 0; i < n; i++) {\n            cin >> a >> b;\n            rings[a].push_back(b);\n            rings[b].push_back(a);\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= 100; i++) {\n            ans = max(ans, dfs(rings, i));\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n\n    fill(e,e+V+1,0);\n\n    int MIN=100000;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n\n    int ans=0;\n    for(int i=1;i<=V;i++){\n      fill(visited,visited+V+1,false);\n      ans=max(ans,dfs(i,1));\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint ans;\n\nvoid dfs(vector<vector<int> >& G,int p,int cost,bitset<101>& visited)\n{\n  bool update = false;\n  for(int i=0;i<G[p].size();i++)\n    {\n      int next = G[p][i];\n      if(!visited[next])\n\t{\n\t  visited[next] = 1;\n\t  dfs(G,next,cost+1,visited);\n\t  visited[next] = 0;\n\t  update = true;\n\t}\n    }\n  if(!update)\n    ans = max(ans,cost);\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      vector<vector<int> > G;\n      set<int> input;\n      G.resize(101);\n      for(int i=0;i<n;i++)\n\t{\n\t  int a,b;\n\t  cin >> a >> b;\n\t  input.insert(a);\n\t  input.insert(b);\n\t  G[a].push_back(b);\n\t  G[b].push_back(a);\n\t}\n\n      ans = 2;\n      for(set<int>::iterator it = input.begin();it != input.end();it++)\n\t{\n\t  bitset<101> visited(0);\n\t  visited[(*it)] = true;\n\t  dfs(G,(*it),1,visited);\n\t  \n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool vv[100], ve[100][100];\n\nint solve(const int v, const vector<vector<int> >& E)\n{\n  int res = 0;\n  vv[v] = true;\n  for (unsigned int i = 0; i < E[v].size(); ++i) {\n    if (!vv[E[v][i]] && !ve[v][E[v][i]] && !ve[E[v][i]][v]) {\n      ve[v][E[v][i]] = ve[E[v][i]][v] = true;\n      res = max(res, solve(E[v][i], E)+1);\n      ve[v][E[v][i]] = ve[E[v][i]][v] = false;\n    }\n  }\n  vv[v] = false;\n  return res;\n}\n\nint main()\n{\n  int n;\n  while (scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    vector<vector<int> > E(100);\n    for (int i = 0; i < n; ++i) {\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      --a;\n      --b;\n      E[a].push_back(b);\n      E[b].push_back(a);\n    }\n\n    int ans = 0;\n    memset(vv, false, sizeof(vv));\n    memset(ve, false, sizeof(ve));\n    for (int i = 0; i < 100; ++i)\n      ans = max(ans, solve(i, E));\n\n    printf(\"%d\\n\", ans+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint N;\nvector<vector<int>> g;\nint ans;\n\nvoid dfs(int cur, bool* visited, int len){\n\tfor (int n : g[cur]) {\n\t\tif (visited[n]) continue;\n\t\tvisited[n] = true;\n\t\tdfs(n, visited, len+1);\n\t\tvisited[n] = false;\n\t}\n\tans = max(ans, len);\n}\n\nint main() {\n\tbool visited[100] = {};\n\twhile(true) {\n\t\tcin >> N;\n\t\tif (N == 0) break;\n\t\tg.clear();\n\t\tg.resize(100);\n\t\tans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tif (find(g[a].begin(), g[a].end(), b) == g[a].end()) g[a].push_back(b);\n\t\t\tif (find(g[b].begin(), g[b].end(), a) == g[b].end()) g[b].push_back(a);\n\t\t}\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tvisited[i] = true;\n\t\t\tdfs(i, visited, 1);\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isVisited[101];\n\nint dfs(const vector<vector<int>>& r, int pos) {\n    if (isVisited[pos]) {\n        return 0;\n    }\n\n    isVisited[pos] = true;\n    int ret = 0;\n    for (int i = 0; i < r[pos].size(); i++) {\n        ret = max(ret, dfs(r, r[pos][i]));\n    }\n    isVisited[pos] = false;\n\n    return ret+1;\n}\n\nint main(void) {\n    for (int i = 0; i <= 100; i++) {\n        isVisited[i] = false;\n    }\n\n    int n;\n    while (cin >> n, n) {\n        vector<vector<int>> rings(101);\n        int a, b;\n        for (int i = 0; i < n; i++) {\n            cin >> a >> b;\n            rings[a].push_back(b);\n            rings[b].push_back(a);\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= 100; i++) {\n            ans = max(ans, dfs(rings, i));\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool once_used[100];\nbool used[100];\nint dfs(int v)\n{\n\tonce_used[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tfill(once_used, once_used+100, false);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (edge[i].size() <= 2)\n\t\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint ret;\nbool used[105]={};\nvector<int>edge[105];\nvoid rec(int a,int b)\n{\n\tret=max(ret,b);\n\tfor(int i=0;i<edge[a].size();i++)\n\t{\n\t\n\t\tif(!used[edge[a][i]])\n\t\t{\n\t\t\tused[a]=true;\n\t\t\trec(edge[a][i],b+1);\n\t\t\tused[a]=false;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\t\n\t\tint n;\n\t\tret=0;\n\t\tfor(int i=0;i<105;i++) edge[i].clear();\n\t\tscanf(\"%d\",&n); if(!n) return 0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].pb(b);\n\t\t\tedge[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=100;i++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\trec(i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid size(vector< vector<bool> >& ring, int a, int temp, int& max)\n{\n\tint i;\n\tring[0][a] = false;\n\tfor (i = 1; i <= 100; i++) {\n\t\tif ((i < a && ring[i][a]) || (i > a && ring[a][i]))\n\t\t\tif (ring[0][i])\n\t\t\t\tbreak;\n\t}\n\tif (i == 101 && temp > max) {\n\t\tmax = temp;\n\t\tring[0][a] = true;\n\t\treturn;\n\t}\n\tfor (i = 1; i <= 100; i++) {\n\t\tif ((i < a && ring[i][a]) || (i > a && ring[a][i]))\n\t\t\tif (ring[0][i])\n\t\t\t\tsize(ring, i, temp + 1, max);\n\t}\n\tring[0][a] = true;\n}\n\nint main()\n{\n\tint n,a,b,siz;\n\twhile (cin >> n, n) {\n\t\tvector< vector<bool> > ring(101,vector<bool>(101,false));\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tring[a][b] = true;\n\t\t\tring[0][a] = ring[0][b] = true;\n\t\t}\n\t\tsiz = 0;\n\t\tfor (int i = 1;i <= 100;i++)\n\t\t\tif(ring[0][i])\n\t\t\t\tsize(ring,i,1,siz);\n\n\t\tcout << siz << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nbool visited[110];\nint dist[110];\nint eccen[110];\n\nint diam(const Graph &g, int n) {\n\n  for(int k=0; k<n; ++k) {\n    pii s = pii(k,0);\n    stack< pii > S;\n    for(int i=0; i<n; ++i) visited[i] = false,dist[i] = 0;\n\n    S.push(s);\n    while(!S.empty()) {\n      pii now = S.top();\n      S.pop();\n\n      if(visited[now.fi] == true) continue;\n      visited[now.fi] = true;\n      dist[now.fi] = now.se;\n\n      for(int j=0; j<g[now.fi].edge.size(); ++j) {\n\tif(visited[g[now.fi].edge[j]]) continue;\n\tdist[g[now.fi].edge[j]] = now.se+1;\n\tS.push( pair<int,int>(g[now.fi].edge[j], now.se+1) );\n      }\n    }\n\n    int tt = 0;\n    for(int i=0; i<n; ++i)\n      if(tt < dist[i]) tt = dist[i];\n    eccen[k] = tt;\n  }\n\n  int maxm = 0;\n  for(int i=0; i<n; ++i)\n    maxm = max(eccen[i], maxm);\n  return maxm;\n}\n\nint main() {\n  int n,a,b;\n  while(cin>>n, n) {\n    Graph g(n);\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n    }\n    cout<<diam(g,n)+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst;\n  Edge() {}\n  Edge(int u, int v) : src(u), dst(v) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nbool used[100];\nint dfs(int u, Graph& G){\n  used[u] = true;\n  int res = 0;\n  bool tmp_used[100];\n  memcpy(tmp_used, used, sizeof(used));\n  FORIT(e, G[u]) if(!used[e->dst]){\n    res = max(res, 1 + dfs(e->dst, G));\n    memcpy(used, tmp_used, sizeof(used));\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  const int M = 100;\n  while(cin >> N && N){\n    Graph G(M);\n    REP(i, N){\n      int u, v; cin >> u >> v;\n      u--; v--;\n      G[u].push_back(Edge(u, v));\n      G[v].push_back(Edge(v, u));\n    }\n    int ans = 0;\n    REP(root, M){\n      memset(used, 0, sizeof(used));\n      ans = max(ans, dfs(root, G) + 1);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[100];\nvector<int> g[100];\nint size[100];\nint solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tint c=size[a];\n\tfor(i=0;i<c;i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)size[i]=g[i].size();\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tvis[a]=1;\n\t\tret=max(ret,dfs(vv[a][i],b)+1);\n\t\tvis[a]=0;\n\t}\n\treturn ret;\n}\n// int solve2(int st){\n        // int ret = 0;\n        // rep(i,edge[st].size()){\n            // int next = edge[st][i];\n            // if(visit[next]==0){\n                // visit[next]=1;\n                // ret = max(solve2(next)+1, ret);\n                // visit[next]=0;\n            // }\n        // }\n        // return ret;\n    // }\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvv=vector<vint>(100);\n\t\tvis=vint(100,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,100) vis[i]=0;\n\t\trep(i,100){\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tint t=dfs(i,0);\n\t\t\t// cout<<i<<\" \"<<t<<endl;\n\t\t\tans=max(ans,t);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,ans,u[100];vector<vector<int> > ad;\nvoid dfs(int c,int m){\n\tif(ans<m)ans=m;\n\trep(i,ad[c].size())if(!u[ad[c][i]]){\n\t\tu[ad[c][i]]=1;dfs(ad[c][i],m+1);u[ad[c][i]]=0;\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tad.clear();ad.resize(100);\n\t\trep(i,n){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tad[a].push_back(b),ad[b].push_back(a);\n\t\t}\n\t\tans=1;rep(i,100)u[i]=0;\n\t\trep(i,100)if(!ad[i].empty()){\n\t\t\tu[i]=1;dfs(i,1);u[i]=0;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nint res = 0;\n\nvoid dfs(const graph &g, vector<bool> &visit, int p, int cnt){\n\tvisit[p] = true;\n\tres = max(res, cnt);\n\tfor(int i=0;i<g[p].size();i++){\n\t\tint next = g[p][i];\n\t\tif(!visit[next]) dfs(g, visit, next, cnt+1);\n\t}\n\tvisit[p] = false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tgraph g(100);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tg[a-1].push_back(b-1);\n\t\t\tg[b-1].push_back(a-1);\n\t\t}\n\t\tres = 0;\n\t\tvector<bool> visit(100, false);\n\t\tfor(int i=0;i<100;i++)\n\t\t\tdfs(g, visit, i, 1);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef vector< int > Array;\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\n\nint n;\nvector< Array > edges;\nbool visit[110];\n\nint rec(int v) {\n\tint res = 1;\n\t\n\tvisit[v] = 1;\n\t\n\tint e_size = size_of(edges[v]);\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tif (visit[u]) continue;\n\t\tmaxUpdate(res, rec(u) + 1);\n\t}\n\t\n\tvisit[v] = 0;\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tminit(visit, 0);\n\tint ans = 0;\n\tfor_(i,1,101) maxUpdate(ans, rec(i));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tedges.assign(101, Array());\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nmap< int, vector<int> > edge;\nmap< int, vector<int> >::iterator mit;\nint visited[101];\n\nint dfs(int vertex, int depth) {\n//     int result = count(visited, visited+101, 1) + 1;\n    int result = depth;\n    for(int i=0; i<edge[vertex].size(); i++) {\n        if(visited[edge[vertex][i]] == 1) continue;\n        visited[vertex] = 1;\n        result = max(result, dfs(edge[vertex][i], depth+1));\n        visited[vertex] = 0;\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(mit=edge.begin(); mit!=edge.end(); mit++) {\n        fill(visited, visited+101, 0);\n        visited[mit->first] = 1;\n        result = max(result, dfs(mit->first, 1));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            edge[--u].push_back(--v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool used[100];\nvector<int> G[100];\nint ma,mav;\n\nvoid dfs(int v,int d){\n\tif(ma < d){\n\t\tma = d;\n\t\tmav = v;\n\t}\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tused[G[v][i]] = true;\n\t\t\tdfs(G[v][i],d + 1);\n\t\t\tused[G[v][i]] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tfor(int i = 0;i < 100;i++) {\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tG[a - 1].push_back(b - 1);\n\t\t\tG[b - 1].push_back(a - 1);\n\t\t}\n\t\tma = 0;\n\t\tfor(int i = 0;i < 100;i++){\n\t\t\tused[i] = true;\n\t\t\tdfs(i,0);\n\t\t\tused[i] = false;\n\t\t}\n\t\tused[mav] = true;\n\t\tdfs(mav,0);\n\t\tcout << ma + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nvector<int> e[100];\nbool used[100];\nint ans;\n\nvoid dfs(int x, int y){\n\tif(used[x]){\n\t\tif(y > ans) ans = y;\n\t\treturn;\n\t}\n\tused[x] = true;\n\trep(i,e[x].size()){\n\t\t//if(used[e[x][i]]) continue;\n\t\tdfs(e[x][i],y+1);\n\t}\n\tused[x] = false;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n),n){\n\t\trep(i,100) e[i].clear();\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\te[a].pb(b);\n\t\t\te[b].pb(a);\n\t\t}\n\t\tans = 0;\n\t\trep(i,100){\n\t\t\trep(j,100) used[j] = false;\n\t\t\tdfs(i,0);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<cstring>\n#include<unordered_map>\n#include<set>\nusing namespace std;\n\nvector<int>rinsetu[100];\nbool S[100];\nint MAX;\nvoid saiki(int a,int b) {\n\tMAX = max(MAX, b);\n\tfor (int i : rinsetu[a]) {\n\t\tif (!S[i]) {\n\t\t\tS[i] = true;\n\t\t\tsaiki(i, b + 1);\n\t\t\tS[i] = false;\n\t\t}\n\t}\n}\nsigned main() {\n\tint a; \n\twhile (cin >> a,a) {\n\t\tMAX = 0;\n\t\tfor (int i = 0; i < 100; i++)rinsetu[i].clear();\n\t\tmemset(S, false, sizeof(S));\n\t\tfor (int b = 0; b < a; b++) {\n\t\t\tint c, d; scanf(\"%d%d\", &c, &d); c--; d--;\n\t\t\trinsetu[c].push_back(d);\n\t\t\trinsetu[d].push_back(c);\n\t\t}\n\t\tfor (int b = 0; b < a; b++) {\n\t\t\tS[b] = true;\n\t\t\tsaiki(b, 1);\n\t\t\tS[b] = false;\n\t\t}\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nint n;\nint f[101],t[101];\nint ans=0;\nbool use[101];\nbool nuse[101];\n\nvoid dfs(int x,int y,int res,bool usen[101],bool nusen[101]){\n\tans=max(ans,res);\n\tfor(int i=0;i<n;i++){\n\t\tif(usen[i]==false){\n\t\t\tusen[i]=true;\n\t\t\tif(x==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(t[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(x==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(f[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(y==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(x,t[i],res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(y==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(x,f[i],res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(x==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(x==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tusen[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(use,false,sizeof(use));\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&f[i],&t[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tuse[i]=true;\n\t\t\tnuse[f[i]]=true;\n\t\t\tnuse[t[i]]=true;\n\t\t\tdfs(f[i],t[i],1,use,nuse);\n\t\t\tuse[i]=false;\n\t\t\tnuse[f[i]]=false;\n\t\t\tnuse[t[i]]=false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\nusing namespace std;\n\nint main() {\n\tint n;cin>>n;\n\twhile(n)\n\t{\n\t\tset<int> r[100];\n\t\tint a,b;\n\t\tint cou=0;\n\t\tbool flag;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tcin>>a>>b;\n\t\t\tflag=true;\n\t\t\tfor(int i=0;i<cou;i++)\n\t\t\t{\n\t\t\t\tauto ait=r[i].find(a);\n\t\t\t\tauto bit=r[i].find(b);\n\t\t\t\tif(ait==r[i].end()&&bit==r[i].end())continue;\n\t\t\t\telse if(ait==r[i].end())r[i].insert(a),flag=false;\n\t\t\t\telse if(bit==r[i].end())r[i].insert(b),flag=false;\n\t\t\t}\n\t\t\tif(flag)r[cou].insert(a),r[cou].insert(b),cou++;\n\t\t}\n\t\tint ma=0;\n\t\tfor(int i=0;i<cou;i++)ma=ma<r[i].size()?r[i].size():ma;\n\t\tcout<<ma<<endl;\n\t\tcin>>n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 101;\n\nint n, a, b;\nvector<int> G[N];\nbool vis[N];\n\nint dfs(int p){\n  vis[p] = true;\n  int res = 1;\n  for(int i=0;i<G[p].size();i++) if(!vis[G[p][i]]) res = max(res, dfs(G[p][i]) + 1);\n  vis[p] = false;\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<N;i++) G[i].clear();\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    int ans = 0;\n    for(int i=1;i<N;i++){\n      fill(vis, vis+N, false);\n      ans = max(ans, dfs(i));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\nint N;\nvector<int> G[102];\nint f[102];\nint f2[102];\nint search(int id){\n  int ret=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    if(!f2[G[id][i]]){\n      f[G[id][i]]=1;\n      f2[G[id][i]]=1;\n      ret = max(ret,search(G[id][i])+1);\n      f2[G[id][i]]=0;\n    }\n  }\n  return ret;\n}\nint search2(int id){\n  int ret=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    if(!f2[G[id][i]] && !f[G[id][i]]){\n      f2[G[id][i]]=1;\n      ret = max(ret,search(G[id][i])+1);\n      f2[G[id][i]]=0;\n    }\n  }\n  return ret;\n}\nint solve(int id){\n  int ret=0;\n  if((int)G[id].size()==1){\n    if(!f[G[id][0]]){\n      f[G[id][0]]=1;\n      f2[G[id][0]]=1;\n      ret = search(G[id][0])+1;\n      f2[G[id][0]]=0;\n    }\n    return ret;\n  }\n  for(int i=0;i<(int)G[id].size();i++){\n    for(int j=i+1;j<(int)G[id].size();j++){\n      int tmpi=0,tmpj=0;\n      bool fi=false,fj=false;\n      if(!f[G[id][i]]){\n    fi=true;\n    f[G[id][i]]=1;\n    f2[G[id][i]]=1;\n    tmpi = search(G[id][i])+1;\n    f2[G[id][i]]=0;\n      }\n      if(!f[G[id][j]]){\n    fj=true;\n    f[G[id][j]]=1;\n    f2[G[id][j]]=1;\n    tmpj = search2(G[id][j])+1;\n    f2[G[id][j]]=0;\n      }\n      ret = max(ret,tmpi+tmpj);\n    }\n  }\n  return ret;\n}\nint main(){\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    for(int i=0;i<N;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    int res=0;\n    for(int i=0;i<102;i++){\n      if(!G[i].empty()){\n    memset(f,0,sizeof(f));\n    f[i]=1;\n    f2[i]=1;\n    //      printf(\"wa:%d size %d\\n\",i,(int)G[i].size());\n    int st = solve(i)+1;\n    f2[i]=0;\n    res = max(res,st);\n    //     printf(\"wa ... %d %d\\n\",i,st);\n      }\n    }\n    printf(\"%d\\n\",res);\n    for(int i=0;i<102;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint c[100][2];\nint n;\n\nint ring(int e,int l,int done[]){/*e:?????????e+1,e?????§???????????????l,???????????¨?±\\??´done*/\n    int i;\n    int cpy[100];\n    int templ;\n    int end = 1;\n    int lmax = l;\n    /*printf(\"called: ring(%d,%d,[\",e,l);\n    for(i=0;i<7;i++)printf(\"%d,\",done[i]);\n    printf(\"])\\n\");*/\n    for(i=0;i<100;i++)cpy[i]=done[i];\n    for(i=0;i<n;i++){/*?????????e+1????´??????¢???*/\n        if(c[i][0]==e+1&&cpy[c[i][1]-1]){\n            end = 0;\n            cpy[c[i][1]-1] = 0;\n            templ = ring(c[i][1]-1,l+1,cpy);\n            cpy[c[i][1]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n        if(c[i][1]==e+1&&cpy[c[i][0]-1]){\n            end = 0;\n            cpy[c[i][0]-1] = 0;\n            templ = ring(c[i][0]-1,l+1,cpy);\n            cpy[c[i][0]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n    }\n    /*printf(\"return(from ring(%d,%d)): %d)\\n\",e,l,lmax);*/\n    return end ? l : lmax;\n}\n\nint main(){\n    int i;\n    int done[100];/*done[i] 1:i+1???????????¨ 0;i+1????????¨???*/\n    int ans,tmp;\n    scanf(\"%d\",&n);\n    while(n){\n        for(i=0;i<100;i++)done[i]=1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&c[i][0],&c[i][1]);\n        }\n        ans = 0;\n        for(i=0;i<7;i++){/*?§?????????????????????????*/\n            done[i] = 0;\n            tmp = ring(i,1,done);\n            done[i] = 1;\n            if(tmp>ans)ans=tmp;\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool visited[100];\nint g[100][100];\nint size[100];\ninline int solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tfor(i=0;i<size[a];i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)\n\t\t\tfor(int j=0;j<100;j++)\n\t\t\t\tg[i][j]=0;\n\t\tfor(int i=0;i<100;i++)size[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1][size[b-1]++]=c-1;\n\t\t\tg[c-1][size[c-1]++]=b-1;\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstack<int>S;\nint n, a, b, g[105], w;\nvector<int>x[105];\n\nvoid dfs() {\n\tfor (int j = 0; j < x[S.top()].size(); j++) {\n\t\tif (g[x[S.top()][j]] == 0) {\n\t\t\tg[x[S.top()][j]] = 1;\n\t\t\tS.push(x[S.top()][j]);\n\t\t\tw = max(w, (int)S.size());\n\t\t\tdfs();\n\t\t}\n\t}\n\tg[S.top()] = 0;\n\tS.pop();\n}\n\nint main() {\n\twhile (true) {\n\t\tw = 0;\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tx[i].clear();\n\t\t}\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a].push_back(b);\n\t\t\tx[b].push_back(a);\n\t\t}\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tS.push(i);\n\t\t\tg[i] = 1;\n\t\t\tdfs();\n\t\t\tg[i] = 0;\n\t\t\tif (S.size() >= 1) {\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t\tcout << w << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint G[100][100];\nint sz[100];\nbool visited[100];\n\nint visit(int v){\n\tint res = 0;\n\trep(i, sz[v]){\n\t\tif(!visited[G[v][i]]){\n\t\t\tvisited[G[v][i]] = true;\n\t\t\tres = max(res, 1 + visit(G[v][i]));\n\t\t\tvisited[G[v][i]] = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tint a, b;\n\twhile(cin >> n && n){\n\t\tmemset(sz, 0, sizeof(sz));\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trep(i, n){\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tG[a][sz[a]++] = b;\n\t\t\tG[b][sz[b]++] = a;\n\t\t}\n\n\t\tint res = 0;\n\t\t\n\t\trep(i, 100){\n\t\t\tvisited[i] = true;\n\t\t\tres = max(res, visit(i));\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << res + 1<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n \nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = false;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = false; rings[i] = 0;\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A][rings[A]] = B; rings[A]++;\n            G[B][rings[B]] = A; rings[B]++;\n        }\n\n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <bitset>\n#include <map>\n#include <fstream>\nusing namespace std;\n\n#define MSG(a) cout<< #a << \" = \" << a <<endl;\n\nconst int MAX_V = 100;\nconst int INF = 100000;\n\nbitset<MAX_V> bmain;\n\nstruct edge\n{\n\tint num;\n\tedge(int n):num(n){};\n\tvector<edge*> es;\n};\n\nint main()\n{\n\t//ifstream ifs(\"data.txt\");\n\n\tint n;\n\twhile( cin >> n && n)\n\t{\n\t\tvector<edge> edges;\n\t\tbmain.reset();\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tedges.push_back(edge(i));\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\t\n\t\t\tedges[a].es.push_back(&edges[b]);\n\t\t\tedges[b].es.push_back(&edges[a]);\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t{\n\t\t\tbitset<MAX_V> flags;\n\n\t\t\tif(!bmain[i]){\n\n\t\t\t\tint now = 0;\n\n\t\t\t\tstack<edge*> stc;\n\t\t\t\tstc.push(&edges[i]);\n\t\t\t\twhile(!stc.empty())\n\t\t\t\t{\n\t\t\t\t\tnow++;\n\n\t\t\t\t\tedge* e = stc.top(); stc.pop();\n\t\t\t\t\tflags[e->num] = true;\n\t\t\t\t\t\n\t\t\t\t\tif(e->es.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tres = max(res, now);\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int i = 0; i < e->es.size(); i++){\n\t\t\t\t\t\t\tif(!flags[e->es[i]->num]){\n\t\t\t\t\t\t\t\tstc.push(e->es[i]);\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tres = max(res, now);\n\t\t\t\t\t\t\tnow--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\t//cin.sync(); cin.get();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 0;j < rings.size();j++){\n\tif(neib[rings[j]].size() == i){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }  \n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\n\nint num;\nbool done[100];\nvector<vector<int> > edge;\n\ninline int convert(unordered_map<int, int>& table, int x) {\n\tif(table.find(x) == table.end()) table.insert(make_pair(x, num++));\n\treturn table[x];\n}\n\nint dfs(int v) {\n\tif(done[v])\n\t\treturn 0;\n\n\tdone[v] = true;\n\n\tint res = 1;\n\tfor(int i = 0; i < (int)edge[v].size(); ++i)\n\t\tchmax(res, dfs(edge[v][i]) + 1);\n\n\tdone[v] = false;\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tnum = 0;\n\t\tedge.clear();\n\t\tedge.resize(100);\n\t\tunordered_map<int, int> table;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\n\t\t\ta = convert(table, a);\n\t\t\tb = convert(table, b);\n\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tmemset(done, false, sizeof(done));\n\t\t\tchmax(ans, dfs(i));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[100][100];\nint cn[100];\nint maxchain(int m,int l,bool inchain[100]){\n\tint ml=l;\n\tfor(int i=0;i<cn[m];i++){\n\t\tif(!inchain[c[m][i]]){\n\t\t\tinchain[c[m][i]]=true;\n\t\t\tint ll=maxchain(c[m][i],l+1,inchain);\n\t\t\tif(ml<ll){ml=ll;}\n\t\t\tinchain[c[m][i]]=false;\n\t\t}\n\t}\n\treturn ml;\n}\nint main() {\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0){break;}\n\t\tint s[2][n];\n\t\tfor(int i=0;i<100;i++){\n\t\t\tcn[i]=0;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s[0][i] >> s[1][i];\n\t\t\tc[s[0][i]][cn[s[0][i]]]=s[1][i];\n\t\t\tcn[s[0][i]]++;\n\t\t\tc[s[1][i]][cn[s[1][i]]]=s[0][i];\n\t\t\tcn[s[1][i]]++;\n\t\t}\n\t\tint ml=0;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint l=1;\n\t\t\tbool inchain[100];\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tinchain[j]=false;\n\t\t\t}\n\t\t\tinchain[i]=true;\n\t\t\tl=maxchain(i,l,inchain);\n\t\t\tif(ml<l){\n\t\t\t\tml=l;\n\t\t\t}\n\t\t}\n\t\tcout << ml << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint mxl,l,n,e1[100],e2[100],u[101];\n\nvoid rec(int t){\n\tif(mxl<l)mxl=l; int prev=-1;\n\trep(i,n)if(prev!=e1[i]&&!u[e1[i]]&&t==e2[i]||prev!=e2[i]&!u[e2[i]]&&t==e1[i]){\n\t\tl++,u[e1[i]]=1,u[e2[i]]=1; prev=u[e2[i]]?e1[i]:e2[i];\n\t\trec(prev); l--,u[e1[i]]=0,u[e2[i]]=0;\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tmxl=0; rep(i,n)cin>>e1[i]>>e2[i];\n\t\trep(i,n){\n\t\t\tl=2;rep(j,101)u[j]=j==e1[i]||j==e2[i]; rec(e1[i]);\n\t\t\tl=2;rep(j,101)u[j]=j==e1[i]||j==e2[i]; rec(e2[i]);\n\t\t}\n\t\tcout<<mxl<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint result;\nvector<int> strands[100];\nbool used[100];\n\nvoid rec(int k, int d, int ub) {\n  if (result < d) result = d;\n  used[k] = 1;\n  for (int i = 0; i < strands[k].size(); i++)\n    if (!used[strands[k][i]]) ub--;\n  ub++;\n  if (result < ub)\n    for (int i = 0; i < strands[k].size(); i++) {\n      int j = strands[k][i];\n      if (!used[j]) rec(j, d+1, ub);\n    }\n  used[k] = 0;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].clear();\n    fill(used, used+100, false);\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    result = 0;\n    for (int i = 0; i < n; i++)\n      rec(i, 1, n+1);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n\nusing namespace std;\n\nbool isPassedNode[101];\nbool isPassedEdge[101][101];\n\nint n;\nint v;\nvector<int>G[101];\n\nint dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\t\n\tint maxRes=0;\n\tfor(int i = 0; i < G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!isPassedEdge[s][to]){\n\t\t\tisPassedEdge[s][to]=true;\n\t\t\tisPassedEdge[to][s]=true;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tisPassedEdge[s][to]=false;\n\t\t\tisPassedEdge[to][s]=false;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint maxRes=0;\n\t\tset<int> starts;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t\tstarts.insert(a);\n\t\t\tstarts.insert(b);\n\t\t}\n\t\tmemset(isPassedEdge,0,sizeof(isPassedEdge));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\n\t\tfor(set<int>::iterator it = starts.begin(); it!=starts.end(); it++){\n\t\t\tmaxRes=max(maxRes,dfs(*it));\n\t\t}\n\t\tcout<<maxRes<<endl;\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100];\nint d[100];\n\nstruct P {\n\tint c, v; string s;\n};\nvoid bfs(int s) {\n\tqueue<P>que;\n\tmemset(d, 0, sizeof(d));\n\tstring S; rep(i, 100)S += '0';\n\tS[s] = '1';\n\tque.push({ 1,s,S });\n\td[s] = 1;\n\twhile (!que.empty()) {\n\t\tP u = que.front(); que.pop();\n\t\tfor (int e : E[u.v]) {\n\t\t\tif (u.s[e] == '0'){\n\t\t\t\tif (d[e] < u.c + 1)d[e] = u.c + 1;\n\t\t\t\tstring v = u.s; v[e] = '1';\n\t\t\t\tque.push({ d[e],e,v });\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int s) {\n\tbfs(s);\n\tint Max = 0, t = 0;\n\trep(i, 100) {\n\t\tif (d[i] == INF)continue;\n\t\tif (Max < d[i]) {\n\t\t\tMax = d[i];\n\t\t\tt = i;\n\t\t}\n\t}\n\tbfs(t);\n\tMax = 0;\n\trep(i, 100) {\n\t\tif (d[i] == INF)continue;\n\t\tMax = max(Max, d[i]);\n\t}\n\treturn Max;\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, 100)E[i].clear();\n\t\trep(i, n) {\n\t\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tE[a].push_back(b); E[b].push_back(a);\n\t\t}\n\t\tint Max = 0;\n\t\trep(i, 100)Max = max(Max, solve(i));\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint edge[128][128];\nbool visited[128];\nint n;\nint depth = 0;\n\nint solve(int k) {\n\tif(visited[k])\n\t\treturn -1;\n\tvisited[k] = true;\n\tint res = 0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tif(edge[k][i] && k != i) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t}\n\tvisited[k] = false;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 128*128; i++)\n\t\t\tedge[0][i] = 0;\n\t\tfor(int i = 0; i < 128; i++)\n\t\t\tvisited[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tedge[a][b] = edge[b][a] = 1;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n\nint rec(int pos)\n{\n\tused[pos] = 1; int ret = 1;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tif(!used[G[pos][i]])\n\t\t{\n\t\t\tret = max(ret, rec(G[pos][i]) + 1);\n\t\t}\n\t}\n\n\tused[pos] = 0;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tused[i] = rings[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint n;\nint ma;\nbool used[100];\nvector<int> edge[100];\n\nvoid dfs(int num,int cnt){\n\tfor(int i = 0;i < edge[num].size();i++){\n\t\tif(!used[edge[num][i]]){\n\t\t\tused[edge[num][i]] = true;\n\t\t\tma = max(ma,cnt + 1);\n\t\t\tdfs(edge[num][i],cnt + 1);\n\t\t\tused[edge[num][i]] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tma = 0;\n\t\tfor(int i = 0;i < n;i++) edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tedge[a - 1].push_back(b - 1);\n\t\t\tedge[b - 1].push_back(a - 1);\n\t\t\tused[i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(edge[i].size() <= 2) dfs(i,0);\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<pair<int,int>> S;\n\tint i,j,k,n,d_min,inv,dep,max,max1;\n\tint a[100],b[100],d[101],e[101][101],v[100],c[101];\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\td_min=100;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\te[i][j]=0;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tc[i]=0;\n\t\t}\n\t\tfor(i=0;i<=n-1;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t\te[a[i]][b[i]]=e[b[i]][a[i]]=1;\n\t\t}\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\tif(e[i][j]==1) d[i]++;\n\t\t\t}\n\t\t\tif(d_min>d[i] && d[i]>=1) d_min=d[i];\n\t\t}\n\t\tj=0;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tif(d[i]==d_min)\n\t\t\t{\n\t\t\t\tv[j]=i;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=0;i<=j-1;i++)\n\t\t{\n\t\t\tmax1=0;\n\t\t\tc[v[i]]=1;\n\t\t\tS.push(make_pair(v[i],0));\n\t\t\twhile(S.empty()!=1)\n\t\t\t{\n\t\t\t\tinv=S.top().first;\n\t\t\t\tdep=S.top().second;\n\t\t\t\tS.pop();\n\t\t\t\tfor(k=1;k<=100;k++)\n\t\t\t\t{\n\t\t\t\t\tif(e[inv][k]==1 && c[k]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[k]=1;\n\t\t\t\t\t\tS.push(make_pair(k,dep+1));\n\t\t\t\t\t\tif(max1<dep+1) max1=dep+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<max1) max=max1;\n\t\t\tfor(k=0;k<=100;k++) c[k]=0;\n\t\t}\n\t\tcout << max+2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nvector<int> e[100];\nbool used[100];\nint ans;\n\nvoid dfs(int x, int y){\n\tif(used[x]){\n\t\tif(y > ans) ans = y;\n\t\treturn;\n\t}\n\tused[x] = true;\n\tif(e[x].size() == 0) if(y+1 > ans) ans = y+1;\n\trep(i,e[x].size()){\n\t\t//if(used[e[x][i]]) continue;\n\t\tdfs(e[x][i],y+1);\n\t}\n\tused[x] = false;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n),n){\n\t\trep(i,100) e[i].clear();\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\te[a].pb(b);\n\t\t\te[b].pb(a);\n\t\t}\n\t\tans = 0;\n\t\trep(i,n){\n\t\t\trep(j,100) used[j] = false;\n\t\t\tdfs(i,0);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid size(vector< vector<bool> >& ring, int a, int n, int temp, int& max)\n{\n\tint i;\n\tring[0][a] = false;\n\tfor (i = 1; i <= n; i++) {\n\t\tif ((i < a && ring[i][a]) || (i > a && ring[a][i]))\n\t\t\tif (ring[0][i])\n\t\t\t\tbreak;\n\t}\n\tif (i == n + 1 && temp > max) {\n\t\tmax = temp;\n\t\tring[0][a] = true;\n\t\treturn;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif ((i < a && ring[i][a]) || (i > a && ring[a][i]))\n\t\t\tif (ring[0][i])\n\t\t\t\tsize(ring, i, n, temp + 1, max);\n\t}\n\tring[0][a] = true;\n}\n\nint main()\n{\n\tint n,a,b,siz;\n\twhile (cin >> n, n) {\n\t\tvector< vector<bool> > ring(101,vector<bool>(101,false));\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tring[a][b] = true;\n\t\t\tring[0][a] = ring[0][b] = true;\n\t\t}\n\t\tsiz = 0;\n\t\tfor (int i = 1;i <= n;i++)\n\t\t\tif(ring[0][i])\n\t\t\t\tsize(ring,i,n,1,siz);\n\n\t\tcout << siz << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<pair<int,int>> S;\n\tint i,j,k,n,d_min,inv,dep,max,max1;\n\tint a[100],b[100],d[101],e[101][101],v[100],c[101];\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\td_min=100;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\te[i][j]=0;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tc[i]=0;\n\t\t}\n\t\tfor(i=0;i<=n-1;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t\te[a[i]][b[i]]=e[b[i]][a[i]]=1;\n\t\t}\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\tif(e[i][j]==1) d[i]++;\n\t\t\t}\n\t\t\tif(d_min>d[i] && d[i]>=1) d_min=d[i];\n\t\t}\n\t\tj=0;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tif(d[i]==d_min)\n\t\t\t{\n\t\t\t\tv[j]=i;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=0;i<=j-1;i++)\n\t\t{\n\t\t\tmax1=0;\n\t\t\tc[v[i]]=1;\n\t\t\tS.push(make_pair(v[i],0));\n\t\t\twhile(S.empty()!=1)\n\t\t\t{\n\t\t\t\tinv=S.top().first;\n\t\t\t\tdep=S.top().second;\n\t\t\t\tS.pop();\n\t\t\t\tfor(k=1;k<=100;k++)\n\t\t\t\t{\n\t\t\t\t\tif(e[inv][k]==1 && c[k]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[k]=1;\n\t\t\t\t\t\tS.push(make_pair(k,dep+1));\n\t\t\t\t\t\tif(max1<dep+1) max1=dep+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<max1) max=max1;\n\t\t\tfor(k=0;k<=100;k++) c[k]=0;\n\t\t}\n\t\tcout << max+2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint done[100];\nint c[100][2];\n\nint chain(int e,int l){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> g[101];\nbool use[101];\n\nint dfs(int x){\n  int res = 1;\n  use[x] = true;\n  for(int i=0;i<(int)g[x].size();i++)\n    if(!use[g[x][i]])res = max(res,dfs(g[x][i])+1);\n  use[x] = false;\n  return res;\n}\n\nint main(){\n  int n;\n  int a,b;\n\n  while(scanf(\"%d\",&n) && n){\n    for(int i=1;i<=100;i++){\n      use[i] = false;\n      g[i].clear();\n    }\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n\n    int ans = 0;\n    for(int i=1;i<=100;i++)\n      if(g[i].size())ans = max(ans,dfs(i));\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_VERTEX_NUM 100\n\ntypedef struct {\n    char linked_num;\n    char linked[MAX_VERTEX_NUM-1];\n} vertex;\n\nvertex vertex_list[MAX_VERTEX_NUM];\nbool has_arrived[MAX_VERTEX_NUM];\nchar count_max;\nint n;\n\nvoid vertex_init() {\n    int i;\n    for (i=0;i < MAX_VERTEX_NUM;i++) {\n        vertex_list[i].linked_num = 0;\n    }\n\n    return ;\n}\n\nvoid link(int id1, int id2) {\n    vertex *obj1 = &vertex_list[id1];\n    vertex *obj2 = &vertex_list[id2];\n\n    int num1 = obj1->linked_num;\n    int num2 = obj2->linked_num;\n    obj1->linked[num1] = id2;\n    obj2->linked[num2] = id1;\n\n    obj1->linked_num += 1;\n    obj2->linked_num += 1;\n\n    return ;\n}\n\nvoid rec(int id, int now_count) {\n    int i;\n\n    if (has_arrived[id]) return ;\n\n    has_arrived[id] = 1;\n\n    if (count_max < now_count+1) {\n        count_max = now_count+1;\n    }\n\n    for (i=0;i < vertex_list[id].linked_num;i++) {\n        rec(vertex_list[id].linked[i], now_count + 1);\n    }\n\n    has_arrived[id] = 0;\n\n    return ;\n}\n\nint main() {\n    while (1) {\n        int i;\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n\n        vertex_init();\n\n        for (i=0;i<n;i++) {\n            int id1, id2;\n            scanf(\"%d %d\", &id1, &id2);\n            link(id1-1, id2-1);\n        }\n\n        count_max = 0;\n\n        for (i=0;i<100;i++) {\n            rec(i, 0);\n        }\n\n        printf(\"%d\\n\", count_max);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool once_used[100];\nbool used[100];\nint dfs(int v)\n{\n\tonce_used[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tfill(once_used, once_used+100, false);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (edge[i].size() == 1)\n\t\t\t\tres = max(res, dfs(i));\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (!once_used[i])\n\t\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint ret;\nbool used[105]={};\nvector<int>edge[105];\nvoid rec(int a,int b)\n{\n\tret=max(ret,b);\n\tfor(int i=0;i<edge[a].size();i++)\n\t{\n\t\n\t\tif(!used[edge[a][i]])\n\t\t{\n\t\t\tused[a]=true;\n\t\t\trec(edge[a][i],b+1);\n\t\t\tused[a]=false;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\t\n\t\tint n;\n\t\tret=0;\n\t\tfor(int i=0;i<105;i++) edge[i].clear();\n\t\tscanf(\"%d\",&n); if(!n) return 0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].pb(b);\n\t\t\tedge[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\trec(i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint d[105];\nvoid init(int n){\n\tint i;\n\tfor(i=1;i<=n;i++)d[i]=i;\n\treturn;\n}\nint find(int x){\n\tif(x!=d[x])d[x]=find(d[x]);\n\treturn d[x];\n}\nvoid unite(int x,int y){\n\tint p=find(x),q=find(y);\n\td[p]=q;\n\treturn;\n}\n\nchar c[102][102],f[105];\nint ans,cn[102];\n\nvoid dfs(int cr,int n){\n\tint i,j,ff;\n\tff=0;\n\tfor(i=1;i<=100;i++){\n\t\tif(c[cr][i]==1 && f[i]==0){\n\t\t\tff=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,n+cn[i]);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0)ans=MAX(ans,n);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\t\n\t\tinit(100);\n\t\tmemset(c,0,sizeof(c));\n\t\tmemset(cn,0,sizeof(cn));\n\t\tfor(i=1;i<=100;i++)f[i]=i;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(find(a)==find(b)){//閉路\n\t\t\t\t//printf(\"%d %d\\n\",a,b);\n\t\t\t\tx=1;\n\t\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\t\tif(j!=a && find(j)==find(a)){\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tcn[j]=0;\n\t\t\t\t\t\tf[j]=a;\n\t\t\t\t\t\tfor(k=1;k<=100;k++){\n\t\t\t\t\t\t\tif(c[j][k]==1){\n\t\t\t\t\t\t\t\tc[a][k]=c[k][a]=1;\n\t\t\t\t\t\t\t\tc[j][k]=c[k][j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcn[a]=x;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tunite(a,b);\n\t\t\t\tif(cn[f[a]]==0)cn[f[a]]=1;\n\t\t\t\tif(cn[f[b]]==0)cn[f[b]]=1;\n\t\t\t\tc[f[a]][f[b]]=c[f[b]][f[a]]=1;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\t//for(i=1;i<=10;i++)printf(\"%2d:(f%2d) (cn%2d)\\n\",i,f[i],cn[i]);\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=1;i<=100;i++){\n\t\t\tx=0;\n\t\t\tfor(j=1;j<=100;j++)if(c[i][j]==1)x++;\n\t\t\tif(x==1){\n\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\tf[i]=1;\n\t\t\t\tdfs(i,cn[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100]; vector<int> G[100];\n \nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = false;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = false;\n            rings[i] = 0;\n            G[i].clear();\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n         \n        for(int i = 0; i < 100; i++)\n        {\n            rings[i] = G[i].size();\n        }\n         \n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nint n;\nint f[101],t[101];\nint ans=0;\nbool use[101];\nbool nuse[101];\n\nvoid dfs(int x,int y,int res,bool usen[101],bool nusen[101]){\n\tans=max(ans,res);\n\tfor(int i=0;i<n;i++){\n\t\tif(usen[i]==false){\n\t\t\tusen[i]=true;\n\t\t\tif(x==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(t[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(x==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(f[i],y,res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(y==f[i] && nusen[t[i]]==false){\n\t\t\t\tnusen[t[i]]=true;\n\t\t\t\tdfs(x,t[i],res+1,usen,nusen);\n\t\t\t\tnusen[t[i]]=false;\n\t\t\t}\n\t\t\tif(y==t[i] && nusen[f[i]]==false){\n\t\t\t\tnusen[f[i]]=true;\n\t\t\t\tdfs(x,f[i],res+1,usen,nusen);\n\t\t\t\tnusen[f[i]]=false;\n\t\t\t}\n\t\t\tif(x==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(x==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==f[i] && nusen[t[i]]==true)ans=max(ans,res+1);\n\t\t\tif(y==t[i] && nusen[f[i]]==true)ans=max(ans,res+1);\n\t\t\tusen[i]=false;\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(use,false,sizeof(use));\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&f[i],&t[i]);\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(f[i]<f[j] || (f[i]==f[j] && t[i]<t[j])){\n\t\t\t\t\tswap(f[i],f[j]);\n\t\t\t\t\tswap(t[i],t[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tuse[i]=true;\n\t\t\tnuse[f[i]]=true;\n\t\t\tnuse[t[i]]=true;\n\t\t\tdfs(f[i],t[i],1,use,nuse);\n\t\t\tuse[i]=false;\n\t\t\tnuse[f[i]]=false;\n\t\t\tnuse[t[i]]=false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nbool used[105];\nvector<int> edge[105];\nint n, a, b;\n\nint dfs(int x){\n    if(edge[x].empty())return 0;\n    if(used[x])return 0;\n    int res = 0;\n    used[x] = true;\n    for(int i = 0;i < edge[x].size();i++){\n\tres = max(res, dfs(edge[x][i]));\n    }\n    used[x] = false;\n    return res + 1;\n}\n\nint main(){\n    while(true){\n\tcin >> n;\n\tif(n == 0)return 0;\n\tfor(int i = 0;i < 100;i++){\n\t    edge[i].clear();\n\t}\n\tfor(int i = 0;i < n;i++){\n\t    cin >> a >> b;\n\t    a--,b--;\n\t    edge[a].push_back(b);\n\t    edge[b].push_back(a);\n\t}\n\tint res = 0;\n\tfor(int i = 0;i < 100;i++){\n\t    res = max(res, dfs(i));\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n\n    while(1)\n    {\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\n\nusing namespace std;\n\nvector<int> vec[1001];\nbool ch[101]={};\nstack<int> st;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    //printf(\"%d \",i);\n    for (int k=0; k<vec[i].size(); k++) {\n        if(!ch[vec[i][k]]){\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    int maxx = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n    }\n    for (int i=1; i<=n; i++) {\n        ch[i] = true;\n        DFS(i,0);\n        ch[i] = false;\n    }\n    printf(\"%d\\n\",maxx+1);\n    vec.clear();\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n;\nvector<int> strands[100];\nbitset<100> used;\n\nint rec(int k) {\n  int r = 0;\n  for (vector<int>::iterator i = strands[k].begin();\n       i != strands[k].end(); ++i) if (!used[*i]) {\n    used[*i] = 1;\n    r = max(r, rec(*i) + 1);\n    used[*i] = 0;\n  }\n  return r;\n}\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].clear();\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a].push_back(b);\n      strands[b].push_back(a);\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++)\n      result = max(result, rec(i));\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101]={};\n   int N;\n   int Ans = 0;\n  void DFS(int n,int len){\n      Ans = max(Ans,len);\n    bool Vis = false;\n   int S = G[n].size();\n   for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis = true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int main(){\n      do{\n   for(int i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(int i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(int i=1;i<=N;i++){\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n   }\n   printf(\"%d\\n\",Ans);\n      }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, rings[100], G[100][100]; bool used[100];\n\nint rec(int pos)\n{\n\tint ret = 1; used[pos] = true;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tint r = G[pos][i];\n\t\t\n\t\tif(!used[r])\n\t\t{\n\t\t\tret = max(ret, rec(r) + 1);\n\t\t}\n\t}\n\n\tused[pos] = false;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tused[i] = false;\n\t\t\trings[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\nvector<int> vec[101];\nbool ch[101]={};\nbool visited[101]={};\nint dp[101]={};\nint maxx = -1;\nint maxNODE = -1;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    dp[i] = max(dp[i],val);\n    int len = vec[i].size();\n    for (int k=0; k<len; k++) {\n        if(!ch[vec[i][k]]){\n            visited[vec[i][k]] = true;\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(!visited[i]){\n            visited[i] = true;\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n        }\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(maxx == dp[i]){\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n            break;\n        }\n    }\n    printf(\"%d\\n\",maxx);\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = false;\n        dp[i] = 0;\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint n;\nvector<int> G[101];\nint ans=0;\nint mn[101];\nbool vis[101];\nbool nuse[101];\nint INF=10000;\nvector<int> group;\n\nint dfs(int v){\n\tvis[v]=true;\n\tint res=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(vis[G[v][i]])continue;\n\t\tvis[G[v][i]]=true;\n\t\tres=max(res,dfs(G[v][i]));\n\t\tvis[G[v][i]]=false;\n\t}\n\treturn res+1;\n}\n\nint searchmin(int v){\n\tint res=G[v].size();\n\tvis[v]=true;\n\tgroup.push_back(v);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!vis[G[v][i]])res=min(res,searchmin(G[v][i]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<101;i++)G[i].clear(),mn[i]=INF;\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tG[a-1].push_back(b-1);\n\t\t\tG[b-1].push_back(a-1);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mn[i]!=INF)continue;\n\t\t\tgroup.clear();\n\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\tint mini=searchmin(i);\n\t\t\tfor(int j=0;j<group.size();j++)mn[group[j]]=mini;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(G[i].size()==mn[i]){\n\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\tans=max(ans,dfs(i));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n    time_t\tstart_time, t;\n\n    while(1)\n    {\n\tstart_time = time(NULL);\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t    if (time(NULL) - start_time > 3)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nvector<int> e[100];\nbool used[100];\nint ans;\n\nvoid dfs(int x, int y){\n\tif(used[x]){\n\t\tif(y > ans) ans = y;\n\t\treturn;\n\t}\n\tused[x] = true;\n\trep(i,e[x].size()){\n\t\t//if(used[e[x][i]]) continue;\n\t\tdfs(e[x][i],y+1);\n\t}\n\tused[x] = false;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n),n){\n\t\trep(i,100) e[i].clear();\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\te[a].pb(b);\n\t\t\te[b].pb(a);\n\t\t}\n\t\tans = 0;\n\t\trep(i,n){\n\t\t\trep(j,100) used[j] = false;\n\t\t\tdfs(i,0);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[100];\nbool visit[100];\n\nint dfs(int i){\n\tint res=0;\n\tfprintf(stderr,\"debug:%d\\n\",i);\n\tfor (int v=0;v<G[i].size();v++){\n\t\tif (!visit[G[i][v]]){\n\t\t\tvisit[G[i][v]]=true;\n\t\t\tres=max(res,dfs(G[i][v]));\n\t\t\tvisit[G[i][v]]=false;\n\t\t}\n\t}\n\treturn res+1;\n}\n\nint main(){\n\tint n;\n\tint a,b;\n\tdo{\n\t\tscanf(\"%d\",&n);\n\t\tif (n){\n\t\t\tfor (int i=0;i<100;i++){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<n;i++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tG[a].push_back(b);\n\t\t\t\tG[b].push_back(a);\n\t\t\t}\n\t\t\tint res=0;\n\t\t\tfor (int i=0;i<100;i++){\n\t\t\t\tres=max(res,dfs(i));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res-1);\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int>G[100];\n\nbool used[100];\nint dfs(int pos){\n    used[pos]=true;\n\n    int ret=0;\n    for(int i=0;i<G[pos].size();i++){\n        int to=G[pos][i];\n        if(used[to])continue;\n        ret=max(ret,dfs(to));\n    }\n    used[pos]=false;\n\n    return ret+1;\n}\n\nvoid solve(){\n    fill_n(G,100,vector<int>());\n    for(int i=0;i<N;i++){\n        int a,b;cin>>a>>b;\n        G[--a].push_back(--b);\n        G[b].push_back(a);\n    }\n\n    int ma=0;\n\n    for(int i=0;i<100;i++){\n        fill_n(used,100,false);\n        ma=max(ma,dfs(i));\n    }\n    cout<<ma<<endl;\n\n}\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\n\nusing namespace std;\n\nvector<int> vec[101];\nbool ch[101]={};\nstack<int> st;\nint DP[101]={};\nint maxx = -1;\nint maxNODE = -1;\nint maxxone = -1;\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val,maxxone = maxx;\n    //printf(\"%d \",i);\n    for (int k=0; k<vec[i].size(); k++) {\n        if(!ch[vec[i][k]]){\n            if(DP[vec[i][k] < maxx])return;\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            if(DP[vec[i][k]] < maxxone){\n                DP[vec[i][k]] = maxxone;\n            }\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        maxxone = -1;\n        ch[i] = true;\n        DFS(i,0);\n        ch[i] = false;\n    }\n    printf(\"%d\\n\",maxx+1);\n    for (int i=1; i<=maxNODE; i++) {\n        //printf(\"%d \",DP[i]);\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,100){\n\t\t\treps(j,n){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,n){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==1)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool used_once[100];\nbool used[100];\nint dfs(int v)\n{\n\tused_once[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t{\n\t\t\tedge[i] = vector<int>();\n\t\t\tused_once[i] = true;\n\t\t\tused[i] = false;\n\t\t}\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\tused_once[a] = used_once[b] = false;\n\t\t}\n\t\t\n\t\tpint e[100];\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\te[i] = pint(edge[i].size(), i);\n\t\tsort(e, e+100);\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (!used_once[e[i].second])\n\t\t\t\tres = max(res, dfs(e[i].second));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, A, B, v[100], r[100], G[100][199];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) {\n\t\t\tint w = rec(G[pos][i]);\n\t\t\tret = ret > w ? ret : w;\n\t\t}\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) ret = max(ret, rec(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,a,b;\nint q[10000],l[100],head,tail,last,best,ans;\nint cantop[100],can[100][100];\nbool vis[100];\nvoid DFS(int x,int len){\n\tif(len>best){last=x;best=len;}\n\tvis[x]=true;\n\tfor(int i=0;i<cantop[x];i++){\n\t\tif(!vis[can[x][i]]){\n\t\t\tDFS(can[x][i],len+1);\n\t\t\tvis[can[x][i]]=false;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\trep(i,100)cantop[i]=false;\n\trep(i,n){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tcan[a][cantop[a]]=b,can[b][cantop[b]]=a;\n\t\tcantop[a]++,cantop[b]++;\n\t}\n\trep(i,100)vis[i]=false;\n\tans=0;\n\tfor(int i=0;i<100;i++){\n\t\tbest=0;\n\t\tDFS(i,1);\n\t\trep(i,100)vis[i]=false;\n\t\tbest=0;\n\t\tDFS(last,1);\n\t\tans=max(ans,best);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,G[100][100],L[100],D[100];\n\nint solve(int m)\n{\n    int r=0,k;\n    for(int i=0;i<L[m];i++){\n        k=G[m][i];\n        if(!D[k]){\n            D[k]=1;\n            r=max(r,1+solve(k));\n            D[k]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(G,0,sizeof(G));\n        memset(L,0,sizeof(L));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a][L[a]++]=b;\n            G[b][L[b]++]=a;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\nint n;\nvector<vector<int>> g;\nvector<int> used;\n\nint func(int cur) {\n\tint res =  0;\n\t\t\tused[cur] = 1;\n\tfor (auto itr : g[cur]) {\n\t\tif (!used[itr]) {\n\t\t\tres = max(res,1+func(itr));\n\t\t}\n\t}\n\t\t\tused[cur] = 0;\n\treturn res;\n}\n\nsigned main() {\n\t\n\twhile (scnaf(\"%d\", &n) != EOF) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tg.clear();\n\t\tg.resize(n*2);\n\t\tmap<int, int> v;\n\t\tint vc = 0;\n\t\tREP(i, n) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (!v.count(a))\n\t\t\t\tv[a] = v.size();\n\t\t\tif (!v.count(b))\n\t\t\t\tv[b] = v.size();\n\t\t\tg[v[a]].push_back(v[b]);\n\t\t\tg[v[b]].push_back(v[a]);\n\t\t}\n\t\tint ans = 0;\n\t\tused.resize(v.size());\n\t\tREP(i, v.size()) {\n\t\t\tans = max(ans, func(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxcnt;\nbool vis[100];\nint graph_lens[100];\nint graph[100][100];\n\nvoid search(int i, int cnt) {\n  if(vis[i]) return;\n  if(maxcnt<cnt) maxcnt=cnt;\n  vis[i] = true;\n  int len = graph_lens[i];\n  int *edg = graph[i];\n  for(int i = 0; i < len; i++) {\n    int to = edg[i];\n    search(to, cnt+1);\n  }\n  vis[i] = false;\n}\n\nint main() {\n  while(true) {\n    int n; scanf(\"%d\", &n);\n    if(n==0) break;\n    fill(vis, vis+100, false);\n    fill(graph_lens, graph_lens+100, 0);\n    for(int i = 0; i < n; i++) {\n      int a,b; scanf(\"%d%d\", &a, &b); a--; b--;\n      graph[a][graph_lens[a]++] = b;\n      graph[b][graph_lens[b]++] = a;\n    }\n    maxcnt = 0;\n    for(int i = 0; i < 100; i++) {\n      search(i,1);\n    }\n    printf(\"%d\\n\", maxcnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nint check_count;\n\nint chack(int p,int t,vector<bool>& flag){\n\tcheck_count++;\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = chack(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\t//target.insert(t);\n\t\t\ttar(t,flag);\n\t\t\t\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\t//printf(\"->%d\\n\",*it);\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tcheck_count = 0;\n\t\t\tchack(*it,1,flag);\n\t\t\tif( check_count <= max){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = Solve(*it);\n\t\t\t//printf(\"s:%d\\n\",s);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100]; vector<int> G[100];\n \nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = false;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = false;\n            rings[i] = 0;\n            G[i].clear();\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n         \n        for(int i = 0; i < 100; i++)\n        {\n            rings[i] = G[i].size();\n        }\n         \n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ls[100];\nbool visited[100];\nint dfs(int now,int l){\n\tvisited[now]=true;\n\tint ans=l+1;\n\tfor(int i=0;i<(int)ls[now].size();i++){\n\t\tif(!visited[ls[now][i]]){\n\t\t\tans=max(ans,dfs(ls[now][i],l+1));\n\t\t}\n\t}\n\tvisited[now]=false;\n\treturn ans;\n}\nint main(){\n\tint n;\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\tcin>>a>>b;\ta--;\tb--;\n\t\tls[a].push_back(b);\tls[b].push_back(a);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\tans=max(ans,dfs(i,0));\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tvis[a]=1;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tret=max(ret,dfs(vv[a][i],b));\n\t}\n\tvis[a]=0;\n\treturn ret+1;\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvv=vector<vint>(100);\n\t\tvis=vint(100,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,100) vis[i]=0;\n\t\trep(i,100){\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tint t=dfs(i,0);\n\t\t\t// cout<<i<<\" \"<<t<<endl;\n\t\t\tans=max(ans,t);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tvis[a]=1;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tret=max(ret,dfs(vv[a][i],b));\n\t}\n\tvis[a]=0;\n\treturn ret+1;\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvv=vector<vint>(100);\n\t\tvis=vint(100,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,100) vis[i]=0;\n\t\trep(i,100){\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tint t=dfs(i,0);\n\t\t\t// cout<<i<<\" \"<<t<<endl;\n\t\t\tans=max(ans,t);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\nint n;\nvector<vector<int>> g;\nset<int> used;\n\nint func(int cur) {\n\tint res =  0;\n\t\t\tused.insert(cur);\n\tfor (auto itr : g[cur]) {\n\t\tif (used.find(itr) == used.end()) {\n\t\t\tres = max(res,1+func(itr));\n\t\t}\n\t}\n\t\t\tused.erase(cur);\n\treturn res;\n}\n\nsigned main() {\n\t\n\twhile (scnaf(\"%d\", &n) != EOF) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tg.clear();\n\t\tg.resize(n*2);\n\t\tmap<int, int> v;\n\t\tint vc = 0;\n\t\tREP(i, n) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (!v.count(a))\n\t\t\t\tv[a] = v.size();\n\t\t\tif (!v.count(b))\n\t\t\t\tv[b] = v.size();\n\t\t\tg[v[a]].push_back(v[b]);\n\t\t\tg[v[b]].push_back(v[a]);\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, v.size()) {\n\t\t\tans = max(ans, func(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n\nint rec(int pos)\n{\n\tint ret = 1; used[pos] = 1;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tint r = G[pos][i];\n\t\t\n\t\tif(!used[r])\n\t\t{\n\t\t\tret = max(ret, rec(r) + 1);\n\t\t}\n\t}\n\n\tused[pos] = 0;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tmemset(rings, 0, sizeof(rings));\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nclass Chain\n{\n    public:\n    int tail;\n    int length;\n    \n    Chain(int b)\n    {\n        tail = b;\n        length = 2;\n    };\n};\n\nint main(){\n    \n    ifstream ifs(\"input.txt\");\n    ofstream ofs(\"output.txt\");\n    \n    while(1)\n    {\n        int num;\n        ifs>>num;\n        \n        if(num==0)\n        {\n            break;\n        }\n        \n        int chainB;\n        int length;\n        list< Chain > clist;\n        \n        for(int i=0;i<num;++i)\n        {\n            int a, b;\n            ifs>>a;\n            ifs>>b;\n            \n            if(clist.empty())\n            {\n                clist.push_back(Chain(b));\n                continue;\n            }\n            \n            list< Chain >::iterator it = clist.begin();\n            bool added = false;\n            while(it != clist.end())\n            {\n                if((*it).tail == a)\n                {\n                    (*it).length += 1;\n                    (*it).tail = b;\n                    added = true;\n                }\n                ++it;\n            }\n            if(!added)\n            {\n                clist.push_back(Chain(b));\n            }\n        }\n        \n        int maxLength = 0;\n        list< Chain >::iterator it = clist.begin();\n        while(it != clist.end())\n        {\n            if((*it).length>maxLength)\n            {\n                maxLength = (*it).length;\n            }\n            ++it;\n        }\n        ofs<<maxLength<<endl;\n        \n    }\n    ofs<<endl;\n    \n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "//????????°???????????????????????°???????????????????????????????????????????????????????????????????????¨??????????????????\n//????????°???????????¢????????????\n//????´???????, ??°???????????¨????????°??????????????????????????§???????????????????±?????????°??????(NP-Hard?)\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 50000841;\nconst int m = 100;\t//The range of number\n\t\nint n;\nint a, b;\nint to[100][100], toSize[100];\nbool vis[100] = {false};\n\nint dfs( int pos ){\n\tint ret = 0;\n\tint i, npos;\n\t\n\tvis[pos] = true;\n\tfor( i = 0; i < toSize[pos]; i++ ){\n\t\tnpos = to[pos][i];\n\t\tif( !vis[npos] )\n\t\t\tret = max(ret, dfs(npos) + 1);\n\t}\n\tvis[pos] = false;\n\treturn ret;\n}\n\nint main(){\n\tint i;\n\t\n\twhile( cin >> n ){\n\t\tif(!n) return 0;\n\t\tfor( i = 0; i < m; i++ ) toSize[i] = 0;\n\t\tfor( i = 0; i < n; i++ ){\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tto[a][toSize[a]++] = b;\n\t\t\tto[b][toSize[b]++] = a;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = 0; i < m; i++ )\n\t\t\tans = max(dfs(i) + 1, ans);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n\n    fill(e,e+V+1,0);\n\n    int MIN=100000;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n\n    int ans=0;\n    for(int j=0;j<2;j++){\n      for(int i=1;i<=V;i++){\n\tif(MIN+j==e[i]){\n\t  fill(visited,visited+V+1,false);\n\t  ans=max(ans,dfs(i,1));\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nint node[101][101];\nint visit[101];\nint ans;\n\nvoid dfs(int now, int cnt){\n\tif( cnt>ans )ans=cnt;\n\tfor(int next=0; next<101; next++)if( node[now][next] && !visit[next] ){\n\t\tvisit[next] = 1;\n\t\tdfs(next,cnt+1);\n\t\tvisit[next] = 0;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tset<int> s;\n\t\tans = 0;\n\t\tmemset(node,0,sizeof(node));\n\t\tmemset(visit,0,sizeof(visit));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a,b; cin>>a>>b;\n\t\t\tnode[a][b] = node[b][a] = 1;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tfor(set<int>::iterator it=s.begin(); it!=s.end(); it++){\n\t\t\tvisit[*it]=1;\n\t\t\tdfs(*it,1);\n\t\t\tvisit[*it]=0;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "7\n1 3\n3 4\n1 4\n2 7\n5 7\n6 7\n1 7\n6\n1 2\n2 3\n3 4\n4 5\n1 5\n2 6\n7\n1 3\n2 4\n3 5\n4 6\n6 7\n2 6\n4 7\n0"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>es[100];\nint max_length;\nbool used[100];\nvoid get_max_length(int at_pos,int sum_length){\n    used[at_pos]=true;\n    for(int i=0;i<es[at_pos].size();i++){\n        int next_pos=es[at_pos][i];\n        if(used[next_pos])continue;\n        get_max_length(next_pos,sum_length+1);\n    }\n    max_length=max(max_length,sum_length);\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        for(int i=0;i<n;i++)es[i].clear();\n        max_length=0;\n        for(int i=0;i<n;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            es[a].push_back(b);\n            es[b].push_back(a);\n        }\n        for(int i=0;fill_n(used,100,false),i<n;i++)\n            get_max_length(i,1);\n\n        printf(\"%d\\n\",max_length);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) {\n\t\t\tint w = rec(G[pos][i]);\n\t\t\tret = ret > w ? ret : w;\n\t\t}\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tint w = rec(i);\n\t\t\tret = ret > w ? ret : w);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+V+1,false);\n    fill(e,e+V+1,0);\n\n    int MIN=100000;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n\n    int ans=0;\n    for(int j=0;j<2;j++){\n      for(int i=1;i<=V;i++){\n\tif(MIN+j==e[i])\n\t  ans=max(ans,dfs(i,1));\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nvector<int> way[100];\nint ans;\n\nvoid Dfs(bool used[100],int n,int d){\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tDfs(used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<N;i++){\n\t\t\tDfs(used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n        \n        used = vector<bool>(100);\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n        \n        int nodes = 0;\n        \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                nodes++;\n            }\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i));\n                \n                if(ret == nodes) { break; }\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint res;\n\nvoid solve(vvi& g,int v,int len,vi& vis)\n{\n\tvis[v]=1;\n\tres=max(res,++len);\n\t\n\tint n=g.size();\n\trep(i,g[v].size()) if(!vis[g[v][i]])\n\t\tsolve(g,g[v][i],len,vis);\n\t\n\tvis[v]=0;\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvvi g(100);\n\t\trep(i,n){\n\t\t\tint s,d; scanf(\"%d%d\",&s,&d); s--,d--;\n\t\t\tg[s].push_back(d);\n\t\t\tg[d].push_back(s);\n\t\t}\n\t\t\n\t\tres=0;\n\t\trep(i,100){\n\t\t\tvi vis(100);\n\t\t\tsolve(g,i,0,vis);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100];\nint D[100];\n\nint size(int m)\n{\n    int r=1;\n    for(int i=0;i<100;i++){\n        if(G[m][i]&&!D[i]){\n            D[i]=1;\n            r=max(r,1+size(i));\n            D[i]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(G,0,sizeof(G));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1][b-1]=G[b-1][a-1]=1;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,size(i));\n            D[i]=0;\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#define rep(i,n) for(int (i)=0;(i) < (n);(i)++)\n#define MAX 110\nusing namespace std;\nvector<int> G[MAX];\nbool flag[MAX];\n\nint dfs(int now){\n    flag[now]=1;\n    int ret = 1;\n    rep(i,G[now].size()){\n        if(flag[G[now][i]]==0)\n            ret = max(ret,dfs(G[now][i])+1);\n    }\n    flag[now]=0;\n    return ret;\n}\n\nint main() {\n    int n;\n    while(scanf(\"%d\",&n),n!=0){\n        rep(i,MAX){\n            G[i].clear();\n            flag[i]=0;\n        }\n        int x,y;\n        rep(i,n){\n            scanf(\"%d %d\",&x,&y);\n            x--;\n            y--;\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        rep(i,MAX){\n            if(G[i].empty())\n                break;\n            sort(G[i].begin(),G[i].end());\n            G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n        }\n        int ret = 0;\n        rep(i,MAX){\n            ret = max(ret,dfs(i));\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, rings[100], G[100][100]; bool used[100];\n\nint rec(int pos)\n{\n\tint ret = 1; used[pos] = true;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tint r = G[pos][i];\n\t\t\n\t\tif(!used[r])\n\t\t{\n\t\t\tret = max(ret, rec(r) + 1);\n\t\t}\n\t}\n\n\tused[pos] = false;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tused[i] = false;\n\t\t\trings[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <bitset>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nvector<vector<int> > G(100);\ntypedef bitset<100> bs;\n\nint dfs(int v, bs vis){\n    vis[v] = true;\n    int res = 1;\n    rep(i, G[v].size()){\n        int to = G[v][i];\n        if(!vis[to]){\n            res = max(res, dfs(to, vis) + 1);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 100) G[i].clear();\n        rep(i, n){\n            int a, b; cin >> a >> b;\n            G[a - 1].push_back(b - 1);\n            G[b - 1].push_back(a - 1);\n        }\n        bs init;\n        int ans = 1;\n        rep(i, 100){\n            ans = max(dfs(i, init), ans);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \nint ans=0;\nbool vis[110]={};\nvector<int> G[110];\nint cnt=0;\n\nvoid dfs(int r){\n\tif(vis[r]) return;\n\tvis[r]=1;\n\tcnt++;\n\tans=max(ans,cnt);\n\t\n\tfor(auto v:G[r])if(!vis[v])dfs(v);\n\tvis[r]=0;\n\tcnt--;\n}\n\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\nwhile(1){\n\n\tint n;\n\tcin>>n;\nif(n==0)exit(0);\nans=0;\nfor(int i=0;i<=100;i++)G[i].clear(),vis[i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tG[y].pb(yy);\n\t\tG[yy].pb(y);\n\t}\n\tfor(int i=1;i<=100;i++)dfs(i);\n\tcout<<ans<<endl;\n\t}\nreturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> point,edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=0;\n\tfor(int i=0;i<edge[n].size();i++) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tvisit[edge[n][i]]=true;\n\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t\tvisit[edge[n][i]]=false;\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfor(int i=0;i<n;i++) edge[i].clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tif(find(point.begin(),point.end(),a)==point.end()) point.push_back(a);\n\t\t\tif(find(point.begin(),point.end(),b)==point.end()) point.push_back(b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=0;i<point.size();i++) {\n\t\t\tvisit[point[i]]=true;\n\t\t\tmx=max(mx,solve(point[i])+1);\n\t\t\tvisit[point[i]]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint N, A, B, v[100], r[100], G[100][199];\nint rec(int pos) {\n\tu[pos] = 1; int ret = 0;\n\tfor(int i = 0; i < rings[pos]; i++) {\n\t\tif(!u[G[pos][i]]) ret = max(ret, rec(G[pos][i]));\n\t}\n\tu[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile(scanf(\"%d%d\", &N), N) {\n\t\tfor(int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B;\n\t\t\tG[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tif(r[i]) ret = max(ret, rec(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nbool g[100][100];\nbool f[100];\n\nint solve(int pos){\n  int ans = 1;\n  f[pos] = true;\n  REP(i,100) if(g[pos][i] && !f[i]){\n    ans = max(ans, 1 + solve(i));\n  }\n  f[pos] = false;\n  return ans;\n}\n\nint main(){\n  while(n = getInt()){\n    REP(i,100) REP(j,100) g[i][j] = false;\n    REP(i,100) f[i] = false;\n    REP(i,n){ int a = getInt()-1; int b = getInt()-1; g[a][b] = g[b][a] = true; }\n    int ans = 0;\n    REP(i,n) ans = max(ans, solve(i));\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n\n  if(!fg)return cnt;\n  return res;\n}\n\nvoid warshall_floyd(void){\n  for(int k=0; k<V; k++)\n    for(int j=0; j<V; j++)\n      for(int i=0; i<V; i++)\n\tg[i][j]=max(g[i][j], g[i][k]+g[k][j]);\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n\n    fill(e,e+V+1,0);\n\n    int MIN=100000;\n    for(int i=1;i<=V;i++){\n      for(int j=1;j<=V;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n\n    int ans=0;\n    for(int j=0;j<4;j++){\n      for(int i=1;i<=V;i++){\n\tif(MIN+j==e[i]){\n\t  fill(visited,visited+V+1,false);\n\t  ans=max(ans,dfs(i,1));\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\nint ans = 2;\n\nvoid dfs(int now, bool visited[], int sum){\n    sum++;\n    visited[now] = true;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]) dfs(next, visited, sum);\n    }\n    ans = max(ans, sum);\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        ans = 2;\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        REP(i, vsize){\n            bool visited[N];\n            memset(visited, 0, sizeof(visited));\n            dfs(v[i], visited, 0);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import Control.Monad (replicateM)\nimport Data.Array (Array,array,(!),bounds)\n\nmain = do\n    n <- readLn\n    if n == 0 then return () else do\n        ps <- replicateM n (getLine >>= return . (\\[a,b]->(a,b)) . map read . words)\n        print $ maxLength $ strings ps\n        main\n\ntype Strings = Array Int [Int]\n\nstrings :: [(Int,Int)] -> Strings\nstrings ps = array (b0,b1) [(i,otherside i)|i<-[b0..b1]]\n    where\n    otherside a = [b|(a',b)<-ps,a'==a] ++ [b|(b,a')<-ps,a'==a]\n    b0 = min (minimum (map fst ps)) (minimum (map snd ps))\n    b1 = max (maximum (map fst ps)) (maximum (map snd ps))\n\nmaxLength strings = maxLength' initChain 1\n    where\n    (b0,b1) = bounds strings\n    initChain = [[i]|i<-[b0..b1], length (strings!i) > 0]\n\n    maxLength' []     n = n-1\n    maxLength' chains n = maxLength' (chains >>= augment strings) (n+1)\n\n    augment strings chain = map (:chain) newRings\n        where\n        newRings = filter (not . (`elem` chain)) (strings ! (head chain))"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct{\n    int f, s;\n} P;\n\nbool operator<( const P& left, const P& right ){\n    return (left.f == right.f)?( left.s <= right.s ):( left.f < right.f );\n}\n\nP p[100];\nint n;\nbool passed[100];\n\nint dfs( int cur ){\n    int res = 0;\n    passed[ cur ] = true;\n    for(int i = 0; i < n; i++){\n        if( p[i].f == cur && !passed[ p[i].s ] ){\n            res = max( res, 1 + dfs( p[i].s ) ); \n        }\n        if( p[i].f > cur ) break;\n    }\n    for(int i = 0; i < n; i++){\n        if( p[i].s == cur && !passed[ p[i].f ] ){\n            res = max( res, 1 + dfs( p[i].f ) ); \n        }\n        if( p[i].f > cur ) break;\n    }\n    passed[ cur ] = false;\n    return res;\n}\n\nint main(){\n    while( true ){\n        cin >> n;\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            cin >> p[i].f >> p[i].s;\n        }\n        sort(p, p+n);\n        int mm = 0;\n        for(int m = 1; m <= 99; m++){\n            mm = max( mm, 1 + dfs( m ) );\n        }\n        cout << mm;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n\n#define INF INT_MAX\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\nint table[100][100];\n\nint n;\n\nint solve(int start) {\n  stack<tuple<int, set<int>, int>> que; //current_pos, history, distance\n  que.push(make_tuple(start, set<int>(), 0));\n\n  int max_dist = -1;\n  while(!que.empty()) {\n    auto a = que.top(); //que.front();\n    que.pop();\n\n    auto cur_pos  = get<0>(a);\n    auto &history = get<1>(a);\n    auto dist     = get<2>(a);\n\n    int push_num = 0;\n    rep(i, 100) {\n      if(table[cur_pos][i] == 0 || history.find(i) != history.end()) continue;\n\n      auto new_hist = history;\n      new_hist.insert(cur_pos);\n\n      que.push(make_tuple(i, new_hist, dist + 1));\n      push_num++;\n    }\n    if(push_num == 0) max_dist = max(max_dist, dist);\n  }\n\n  return max_dist;\n}\n\nint main() {\n  while(true) {\n    cin >> n;\n    if(n == 0) break;\n\n    memset(table, 0, 100 * 100 * sizeof(int));\n\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      table[a][b] = table[b][a] = 1;\n    }\n\n    int ans = 0;\n\n    rep(i, 100) {\n      bool indep = true;\n      rep(j, 100) {\n        if(table[i][j] != 0) {\n          indep = false;\n          break;\n        }\n      }\n      if(indep) continue;\n\n      ans = max(solve(i), ans);\n    }\n\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> to[100];\nbool used[100];\n\nvoid addEdge(int a, int b) {\n    to[a].push_back(b);\n    to[b].push_back(a);\n}\n\nint dfs(int v) {\n    int ret = 1;\n    used[v] = true;\n    for (int i=0; i<(int)to[v].size(); ++i) {\n        if ( ! used[to[v][i]]) {\n            ret = max(ret, 1 + dfs(to[v][i]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        fill(to, to+100, vector<int>());\n        int a, b;\n        for (int i=0; i<n; ++i) {\n            cin >> a >> b;\n            --a, --b;\n            addEdge(a, b);\n        }\n        int ret = 0;\n        for (int i=0; i<n; ++i) {\n            memset(used, false, sizeof used);\n            ret = max(ret, dfs(i));\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint n;\nvector<int> G[101];\nint ans=0;\nint mn[101];\nbool vis[101];\nbool nuse[101];\nint INF=10000;\nvector<int> group;\n\nint dfs(int v){\n\tvis[v]=true;\n\tint res=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(vis[G[v][i]])continue;\n\t\tvis[G[v][i]]=true;\n\t\tres=max(res,dfs(G[v][i]));\n\t\tvis[G[v][i]]=false;\n\t}\n\treturn res+1;\n}\n\nint searchmin(int v){\n\tint res=G[v].size();\n\tvis[v]=true;\n\tgroup.push_back(v);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!vis[G[v][i]])res=min(res,searchmin(G[v][i]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<101;i++)G[i].clear(),mn[i]=INF;\n\t\tmemset(nuse,false,sizeof(nuse));\n\t\tans=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tG[a-1].push_back(b-1);\n\t\t\tG[b-1].push_back(a-1);\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tif(mn[i]!=INF)continue;\n\t\t\tgroup.clear();\n\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\tint mini=searchmin(i);\n\t\t\tfor(int j=0;j<group.size();j++)mn[group[j]]=mini;\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tif(G[i].size()==mn[i]){\n\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\tans=max(ans,dfs(i));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>                                                                                   \n#include<cstring>                                                                                  \n#include<algorithm>                                                                                \n#include<vector>                                                                                   \nusing namespace std;                                                                               \n                                                                                                   \nint n;                                                                                             \nvector<short> G[100];                                                                              \nbool D[100];                                                                                       \n                                                                                                   \nint solve(int m)                                                                                   \n{                                                                                                  \n    int r=0;                                                                                       \n    for(vector<short>::iterator it=G[m].begin();it!=G[m].end();it++){                              \n        if(!D[*it]){                                                                               \n            D[*it]=1;                                                                              \n            r=max(r,1+solve(*it));                                                                 \n            D[*it]=0;                                                                              \n        }                                                                                          \n    }                                                                                              \n    return r;                                                                                      \n}                                                                                                  \n                                                                                                   \nint main()\n{\n    for(int i=0;i<100;i++)G[i].reserve(100);\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> g[101];\nbool use[101];\nint n;\n\nint dfs(int x,int k){\n  int res = 0;\n  use[x] = true;\n  for(int i=0;i<(int)g[x].size();i++){\n    if(!use[g[x][i]])res = max(res,dfs(g[x][i],k-1));\n    if(res+1==k)break;\n  }\n  use[x] = false;\n  return res+1;\n}\n\nint main(){\n  int a,b;\n\n  while(scanf(\"%d\",&n) && n){\n    for(int i=1;i<=100;i++){\n      use[i] = false;\n      g[i].clear();\n    }\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n\n    int ans = 0;\n    for(int i=1;i<=100;i++)\n      if(g[i].size())ans = max(ans,dfs(i,n));\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nstd::vector<std::vector<int> >v(101);\nint f[101];\nint F(int k)\n{\n\tif(f[k])return 0;\n\tf[k]=1;\n\tint r=0,i;\n\tfor(i=0;i<v[k].size();++i)r=std::max(r,F(v[k][i]));\n\tf[k]=0;\n\treturn r+1;\n}\nint main()\n{\n\tint n,a,b,i,r;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tfor(i=1;i<101;++i)v[i].clear();\n\t\tfor(i=r=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tv[a].push_back(b);\n\t\t\tv[b].push_back(a);\n\t\t}\n\t\tfor(i=1;i<101;++i)r=std::max(r,F(i));\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\nbool isAppeared[101];\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfill(isAppeared,isAppeared+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\t//set<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t//s.insert(a);\n\t\t\t//s.insert(b);\n\t\t\tisAppeared[a]=true;\n\t\t\tisAppeared[b]=true;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(!isAppeared[i])\n\t\t\t\tcontinue;\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ls[100];\nbool visited[100];\nint dfs(int now,int l){\n\tint ans=l;\n\tvisited[now]=true;\n\tfor(int i=0;i<(int)ls[now].size();i++){\n\t\tif(visited[ls[now][i]])\tcontinue;\n\t\tans=max(ans,dfs(ls[now][i],l+1));\n\t}\n\tvisited[now]=false;\n\treturn ans;\n}\nint main(){\n\twhile(true){\n\t\tint n;\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tfor(int i=0;i<100;i++)\tls[i].clear();\n\t\tset<int> uses;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\tcin>>a>>b;\ta--;\tb--;\n\t\t\tuses.insert(a);\tuses.insert(b);\n\t\t\tls[a].push_back(b);\tls[b].push_back(a);\n\t\t}\n\t\tint ans=0;\n\t\tfor(auto it=uses.begin();it!=uses.end();it++){\n\t\t\tans=max(ans,dfs(*it,1));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint g[100][100];\nint num[100];\nbool f[100];\nint tmp[100];\nint k;\nint d;\nint dm;\n\nint solve(int pos){\n  int ans = 1;\n  f[pos] = true;\n  dm = max(dm, ++d);\n  REP(i,num[pos]){\n    int next = g[pos][i];\n    if(f[next]) continue;\n    if(next < k && tmp[next] + d <= dm)\n      continue;\n    ans = max(ans, 1 + solve(next));\n  }\n  f[pos] = false;\n  d--;\n  return ans;\n}\n\nint main(){\n  while(n = getInt()){\n    dm = 0;\n    REP(i,100) {\n      f[i] = false;\n      num[i] = 0;\n    }\n    REP(i,n){\n      int a = getInt()-1;\n      int b = getInt()-1;\n      g[a][num[a]++] = b;\n      g[b][num[b]++] = a;\n    }\n    int ans = 0;\n    REP(i,100){\n      k = i;\n      tmp[i] = solve(i);\n      ans = max(ans, tmp[i]);\n    }\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint edge[128][128];\nbool visited[128];\nint n;\nint depth = 0;\n\nint solve(int k) {\n\tif(visited[k])\n\t\treturn -1;\n\tvisited[k] = true;\n\tint res = 0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tif(edge[k][i]) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t}\n\tvisited[k] = false;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 128*128; i++)\n\t\t\tedge[0][i] = 0;\n\t\tfor(int i = 0; i < 128; i++)\n\t\t\tvisited[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tedge[a][b] = edge[b][a] = 1;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n#define MAX 105\nvector<int> G[MAX];\nint searched[MAX];\nint point[MAX];\n\nint dfs(int node){\n  stack<int> s;\n  int ret=0;\n  s.push(node);\n  point[node]=1;\n  while(!s.empty()){\n    int now_s=s.top(); s.pop();\n    searched[now_s]=true;\n    \n    bool done=0;\n    for(int i=0; i<G[now_s].size(); i++){\n      int nex=G[now_s][i];\n      if(searched[nex]) continue;\n      s.push(nex);\n      point[nex]=max(point[now_s]+1,point[nex]);\n      done=true;\n    }\n    if(!done) ret=max(ret,point[now_s]);\n  }\n  return ret;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n&&n){\n    for(int i=0; i<=101; i++) G[i].clear();\n    for(int i=0; i<n; i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n      \n    int ans_max=0;\n    for(int i=1; i<=101; i++){\n      for(int j=0; j<=101; j++){\n        searched[j]=0;\n        point[j]=0;\n      }\n      ans_max=max(dfs(i),ans_max);\n//      cout<<\"      i :  \"<<i<<\"ans_s:   \"<<ans_max<<en\n    }\n      \n    cout<<ans_max<<en\n  }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(e,e+101,0);\n    \n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    \n    int ans=0;\n    for(int j=0;j<5;j++){\n      for(int i=1;i<101;i++){\n\tif(MIN+j==e[i])\n\t  ans=max(ans,dfs(i,1));\n      }\n      }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint stmin,visited2[101];\nvoid dfs2(int i, int m){\n\n  visited2[i]=m;\n\n  int tmp=0;\n  for(int j=1;j<101;j++)\n    tmp+=g[i][j];\n\n  if(stmin>tmp)stmin=tmp;\n\n  for(int j=1;j<101;j++){\n    if(g[i][j] && !visited2[j]){\n      dfs2(j,m);\n    }\n  }\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(visited2,visited2+101,0);\n    fill(e,e+101,0);\n\n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    int ans=0,cnt=1;\n    for(int i=1;i<101;i++){\n      stmin=100000;\n      if(visited2[i]==0){\n\tdfs2(i,cnt);\n\n\tfor(int j=1;j<101;j++){\n\t  if(visited2[j]==cnt && stmin==e[j]){\n\t    ans=max(ans,dfs(j,1));\n\t    break;\n\t  }\n\t}\n\tcnt++;\n      }\n    }\n    \n \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nvvi in;\nvi d;\nvoid dfs(int a,int c){\n\td[a]=c;\n\trep(i,in[a].size()){\n\t\tint t=in[a][i];\n\t\tif(d[t]==inf)dfs(t,c+1);\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tin=vvi(101);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tin[a].pb(b);\n\t\t\tin[b].pb(a);\n\t\t}\n\t\tint out=0;\n\t\trep(i,101){\n\t\t\td=vi(101,inf);\n\t\t\tdfs(i,0);\n\t\t\trep(j,101)if(d[j]!=inf)out=max(out,d[j]);\n//\t\t\trep(j,n)cout<<\" \"<<d[j];cout<<endl;\n\t\t}\n\t\tcout<<out+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nstruct Ring{\n    vector<int> s;\n    bool kaku;\n    \n    void clear(){\n        s.clear();\n        kaku=false;\n    }\n}ring[101];\n\nint bfs(int now){\n    int re=0;\n    \n    ring[now].kaku=true;\n    for(int i=0;i<ring[now].s.size();i++){\n        if(!ring[ring[now].s[i]].kaku){\n            re=max(bfs(ring[now].s[i]),re);\n        }\n    }\n    ring[now].kaku=false;\n    return re+1;\n}\n\nint solve(int n){\n    int a,b,ans=0;\n    \n    for(int i=1;i<=100;i++){\n        ring[i].clear();\n    }\n    \n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        ring[a].s.push_back(b);\n        ring[b].s.push_back(a);\n    }\n    \n    for(int i=1;i<=100;i++){\n        if(!ring[i].kaku){\n            ans=max(bfs(i),ans);\n        }\n        for(int i=1;i<=100;i++){\n            ring[i].kaku=false;\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n\nint main(){\n    int n;\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0508>\n?????????============================================================\n?????????????????°?????????????´?????????????.????????°?????£??´??°??????????????????,?´?????????\\??????.\n?´?????????????????????°????????°????????° a, b ??????????????????.?????????,[a, b] ??¨?¨???°??????.\n?????°????´??????????,??????????´???¨??????????´????????????°????????????????????°???????????´???,??????????????°?????¨????????§,\n?????????????´?????????????????????¨?????§??????,??????????????§????????????????????¨?????¶?????¨?????????.\n????????°,[1, 3] ??¨ [3, 4] ??¨???????´?????????? [1, 3, 4] ??¨??????????????§??????.\n?´???¨??????????????????????????´??°??????????????????????????°?????¨????????§?????????????????¨?????§??????????????¨??????.\n\n????????°,??? [1, 3, 4] ??¨?´? [5, 1] ????????? [5, 1, 3, 4] ?????§???,\n??? [1, 3, 4] ??¨??? [2, 3, 5] ?????????, ????????§??????????????????????????¢?????????.\n??? [1, 3, 4] ??¨??? [4, 6, 1] ?????????, ????????¢?????§??????.\n\n????????????????§?????????¢?????§?????????, ????????????????????¨??§,\n????????°????????????????????°???????????????????????????????????£????????°????´?????????¨?????¶?????¨?????????.\n????????°,??? [1, 3, 4] ??¨???[2, 3, 5] ????????§??????,????????§??????????????????????????¢??????,\n[1, 3, 5],[2, 3, 4] ??¨?????????????????????,\n??? [1, 3, 4] ??¨??? [4, 6, 1] ????????§???????????????, \n[1, 3, 4, 6],[3, 4, 6, 1],[4, 6, 1, 3]???????????????????????????.\n\n???????????????????????????,??????????????°????????°???????????¨????????????. \n????????????????????°????´?????????????,??????????????????????????????????????????????????¨1?????\\????????????????????¢?????§??????.\n????????????????????§???????????????????±???????????????°?????????????????????.\n\n??\\???????????? ??????????????????????´?????????°??§????????£??´??° 1 ??? n ??? 100 ??????????????????,\n?????\\??? n ????????????????????????, ????????§???????????????\n2 ????????´??° a, b ?????????????????? 1 ??? a < b ??? 100 ??¨?????£?????????.\n????????? 2 ????????´??°??? 1 ???????´???????????????´??°?????¨??????.\n=================================================================\n??\\???=============================================================\n??\\???????????°????????????????????????????????????n ??? 0 ?????¨?????\\????????????????????????????????????????????°??? 10 ????¶?????????????\n================================================================\n??????=============================================================\n???????????????????????¨???????????§??????????????????????????????????????????\n================================================================\n?§£??¬=============================================================\n================================================================\n*/\n\nll ans;\nvoid dfs(ll n, ll dep, vector<vector<ll>>& G, vector<int>& used) {\n\tbool f = false;\n\tfor (auto next : G[n]) {\n\t\tif (used[next] == 0) {\n\t\t\tf = true;\n\t\t\tused[next] = 1;\n\t\t\tdfs(next, dep + 1, G, used);\n\t\t\tused[next] = 0;\n\t\t}\n\t}\n\tif (!f) {\n\t\tans = max(ans, dep);\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n;\n\twhile (cin >> n, n) {\n\t\tans = 0;\n\t\tvector<vector<ll>> G(n);\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tll x, y; cin >> x >> y; x--;y--;\n\t\t\tG[x].push_back(y); G[y].push_back(x);\n\n\t\t\tvector<int> used(n, 0);\n\t\t\tfor (int i = 0; i < n;i++) {\n\t\t\t\tused[i] = 1;\n\t\t\t\tdfs(i, 1, G, used);\n\t\t\t\tused[i] = 0;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nvector< vector<int> > edge;\n\nint dfs(int v, bitset<101> visited) {\n    int result = visited.count() + 1;\n    visited.set(v);\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        result = max(result, dfs(*i, visited));\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(set<int>::iterator i=vertex.begin(); i!=vertex.end(); i++) {\n        result = max(result, dfs(*i, bitset<101>(0)));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge = vector< vector<int> >(101);\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<list>\n#include<queue>\n\n#define MAX 110\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\nclass State{\npublic:\n  int pos;\n  State(int pos):pos(pos){\n    len = 1;\n  }\n  int len;\n  bool vis[MAX];\n};\n\nint BFS(int st, const vector<Node> &G){\n  int ret = 1;\n  queue<State> q;\n  State init(st);\n\n  fill(init.vis,init.vis+MAX,false);\n  init.vis[st]=true;\n  q.push(init);\n\n  while(!q.empty()){\n    bool NG=false;\n    State now = q.front();\n    q.pop();\n\n    ret = max( ret, now.len );\n\n    const set<int> &S = G[now.pos].con;\n    for(set<int>::iterator its = S.begin();\n\tits != S.end();\n\t++its){\n      int nx = *its;\n      if( !now.vis[ nx ] ){\n\tState next = now;\n\tnext.pos = nx;\n\tnext.vis[nx] = true;\n\tnext.len++;\n\tq.push( next );\n      }\n    }\n  }\n  return ret;\n}\n\ntypedef vector<Node> graph;\ntypedef list< vector<int> > forest;\n\nvoid MakeForest(const graph &g, bool exist[MAX], forest &f){\n  bool vis[MAX]={false};\n  for(int x=0;x<MAX;++x){\n    if(!vis[x]&&exist[x]){\n      queue<int> q;\n      bool tvis[MAX]={false};\n      q.push(x);\n      tvis[x]=true;\n      while(!q.empty()){\n\tint now=q.front();q.pop();const set<int> &C=g[now].con;\n\tfor(set<int>::iterator its=C.begin();its!=C.end();++its){\n\t  if(!tvis[*its]){tvis[*its]=true;q.push(*its);}\n\t}\n      }\n      vector<int> tmp;\n      f.push_back( tmp );\n      for(int i=0;i<MAX;++i){\n\tif(tvis[i]){\n\t  vis[i]=true;\n\t  f.back().push_back( i );\n\t}\n      }\n    }\n  }\n}\n\nint Backtrack(int pos, int now, int &bans, bool vis[], int memo[], const graph &G){\n  const set<int> &C = G[pos].con;\n  int ret = now;\n  for(set<int>::iterator itc=C.begin();itc!=C.end();++itc){\n    int nx = *itc;\n    if( !vis[nx] ){\n      if(now+memo[nx]<=bans)continue;\n      bans=max(bans,now+1);\n      vis[nx]=true;\n      ret=max(ret,Backtrack(nx,now+1,bans,vis,memo,G) );\n      vis[nx]=false;\n      bans=max(bans,ret);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    graph G(MAX);\n    forest F;\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      G[a].con.insert(b);\n      G[b].con.insert(a);\n    }\n\n    MakeForest(G,exist,F);\n\n    int memo[MAX];\n    for(int i=0;i<MAX;++i){\n      memo[i]=MAX+1;\n    }\n    for(forest::iterator itf=F.begin();itf!=F.end();++itf){\n      if((*itf).size()<=ans)continue;\n      for(int i = 0; i < (*itf).size(); ++i){\n\tint st=(*itf)[i];\n\tbool vis[MAX]={false,};\n\tvis[st]=true;\n\tint btret = Backtrack( st, 1, ans, vis, memo, G );\n\tmemo[st]=btret;\n\tans=max(ans,btret);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>                                                                                   \n#include<cstring>                                                                                  \n#include<algorithm>                                                                                \n#include<vector>                                                                                   \nusing namespace std;                                                                               \n\nint n;                                                                                             \nvector<int> G[100];                                                                              \nbool D[100];                                                                                       \nint r,k;\n\nvoid solve(int m)\n{\n    D[m]=1;\n    r=max(r,++k);\n    for(vector<int>::iterator it=G[m].begin();it!=G[m].end();it++){                              \n        if(!D[*it]){                                                                               \n            solve(*it);                                                                 \n        }                                                                                          \n    }                                                                                              \n    --k;\n    D[m]=0;\n}                                                                                                  \n\nint main()\n{\n    for(int i=0;i<100;i++)G[i].reserve(100);\n    while(scanf(\"%d\",&n),n){\n        r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            solve(i);\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\n\nint DFS(vector<int> G[],vector<bool> &has_done,int v){\n\tint result=0;\n\thas_done[v]=true;\n\tREP(i,0,G[v].size()){\n\t\tif(has_done[G[v][i]]) continue;\n\t\tresult=max(result,DFS(G,has_done,G[v][i]));\n\t}\n\thas_done[v]=false;\n\treturn result+1;\n}\n\nint DFS(vector<int> G[],vector<bool> &&has_done,int v){\n\tint result=0;\n\thas_done[v]=true;\n\tREP(i,0,G[v].size()){\n\t\tif(has_done[G[v][i]]) continue;\n\t\tresult=max(result,DFS(G,has_done,G[v][i]));\n\t}\n\thas_done[v]=false;\n\treturn result+1;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile(cin >> N&&N){\n\t\tvector<int> G[100];\n\t\tREP(i,0,N){\n\t\t\tint A,B;\n\t\t\tcin >> A >> B;\n\t\t\t--A;\n\t\t\t--B;\n\t\t\tG[A].push_back(B);\n\t\t\tG[B].push_back(A);\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,0,100) ans=max(ans,DFS(G,vector<bool>(100),i));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Search\n{\n\tVVI G;\n\tint V;\n\tvector<bool> visited;\n\t\n\tint res;\n\n\tSearch( VVI G ) : G( G ), visited( G.size(), false ), V( G.size() ), res( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tint solve()\n\t{\n\t\tREP( i, 0, V )\n\t\t{\n\t\t\tdfs( i );\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tvoid dfs( int v, int l = 0 )\n\t{\n\t\tif ( visited[v] )\n\t\t{\n\t\t\tres = max( res, l );\n\t\t\treturn;\n\t\t}\n\n\t\tvisited[v] = true;\n\n\t\tREP( i, 0, G[v].size() )\n\t\t{\n\t\t\tdfs( G[v][i], l + 1 );\n\t\t}\n\n\t\tvisited[v] = false;\n\t\n\t\treturn;\n\t}\n};\t\t\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint V = 0;\n\t\tVI as, bs;\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\n\t\t\tV = max( V, max( a, b ) );\n\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tas.PB( a );\n\t\t\tbs.PB( b );\n\t\t}\n\t\t\n\t\tVVI G( V, VI() );\n\t\t\n\t\tREP( i, 0, as.size() )\n\t\t{\n\t\t\tG[ as[i] ].PB( bs[i] );\n\t\t\tG[ bs[i] ].PB( as[i] );\n\t\t}\n\n\t\tcout << Search( G ).solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++) \n#define max(a,b) (((a)>=(b))?(a):(b))\nvector<int> edge[100];\nbool visit[100];\nint solve(int n) { //ノードnから辿れる先にある最長のパス\n\tint mx=0;\n\trep(i,edge[n].size()) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tvisit[edge[n][i]]=true;\n\t\t\tmx=max(mx,solve(edge[n][i])+1);\n\t\t\tvisit[edge[n][i]]=false;\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\trep(i,100)\n\t\t\tedge[i].clear();\n\t\trep(i,n) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\trep(i,100) {\n\t\t\tvisit[i]=true;\n\t\t\tmx=max(mx,solve(i)+1);\n\t\t\tvisit[i]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool edges[101][101];\nbool ok[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < 101; i++){\n\t\tint to=i;\n\t\tif(edges[s][to]){\n\t\t\tedges[s][to]=false;\n\t\t\tedges[to][s]=false;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tedges[s][to]=true;\n\t\t\tedges[to][s]=true;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\tmemset(edges,0,sizeof(edges));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\tmemset(ok,0,sizeof(ok));\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedges[a][b]=true;\n\t\t\tedges[b][a]=true;\n\t\t\tok[a]=ok[b]=true;\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(ok[i])\n\t\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tprintf(\"%d\\n\",maxRes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n\tint n,a,b,i,j,x,t,min,max;\n\tbool table[101][101];\n\tchar field[101][101];\n\tint data[101];\n\twhile(cin>>n){\n\t\tif(n==0){break;}\n\t\tn+=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tcin>>a>>b;\n\t\t\ttable[a][b]=1;\n\t\t\ttable[b][a]=1;\n\t\t}\n\t\tmax=0;\n\t\tfor(x=1;x<n;x++){\n\t\t\tfor(i=1;i<n;i++){\n\t\t\t\tfor(j=1;j<n;j++){\n\t\t\t\t\tfield[i][j]=table[i][j];\n\t\t\t\t}\n\t\t\t\tdata[i]=0;\n\t\t\t}\n\t\t\tdata[0]=x;\n\t\t\tt=1;\n\t\t\twhile(1){\n\t\t\t\tmin=n;\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tif(i!=x && field[data[t-1]][i]==1 && min>i && i>data[t]){\n\t\t\t\t\t\tmin=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tfield[data[t-1]][i]=2;\n\t\t\t\t\tfield[i][data[t-1]]=2;\n\t\t\t\t}\n\t\t\t\tif(min!=n){\n\t\t\t\t\tdata[t]=min;\n\t\t\t\t\tt+=1;\n\t\t\t\t}else{\n\t\t\t\t\tmax=(max<t)?t:max;\n\t\t\t\t\tt-=1;\n\t\t\t\t\tif(t==0){break;}\n\t\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t\tfield[data[t-1]][i]=table[data[t-1]][i];\n\t\t\t\t\t\tfield[i][data[t-1]]=table[i][data[t-1]];\n\t\t\t\t\t\tfield[data[t+1]][i]=table[data[t+1]][i];\n\t\t\t\t\t\tfield[i][data[t+1]]=table[i][data[t+1]];\n\t\t\t\t\t\tdata[t+1]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint c[100][2];\nint n;\n\nint ring(int e,int l,int done[]){/*e:?????????e+1,e?????§???????????????l,???????????¨?±\\??´done*/\n    int i;\n    int cpy[100];\n    int templ;\n    int end = 1;\n    int lmax = l;\n    /*printf(\"called: ring(%d,%d,[\",e,l);\n    for(i=0;i<7;i++)printf(\"%d,\",done[i]);\n    printf(\"])\\n\");*/\n    for(i=0;i<100;i++)cpy[i]=done[i];\n    for(i=0;i<n;i++){/*?????????e+1????´??????¢???*/\n        if(c[i][0]==e+1&&cpy[c[i][1]-1]){\n            end = 0;\n            cpy[c[i][1]-1] = 0;\n            templ = ring(c[i][1]-1,l+1,cpy);\n            cpy[c[i][1]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n        if(c[i][1]==e+1&&cpy[c[i][0]-1]){\n            end = 0;\n            cpy[c[i][0]-1] = 0;\n            templ = ring(c[i][0]-1,l+1,cpy);\n            cpy[c[i][0]-1] = 1;\n            if(templ>lmax)lmax=templ;\n        }\n    }\n    /*printf(\"return(from ring(%d,%d)): %d)\\n\",e,l,lmax);*/\n    return end ? l : lmax;\n}\n\nint main(){\n    int i;\n    int done[100];/*done[i] 1:i+1???????????¨ 0;i+1????????¨???*/\n    int ans,tmp;\n    scanf(\"%d\",&n);\n    while(n){\n        for(i=0;i<100;i++)done[i]=1;\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&c[i][0],&c[i][1]);\n        }\n        ans = 0;\n        for(i=0;i<100;i++){/*?§?????????????????????????*/\n            done[i] = 0;\n            tmp = ring(i,1,done);\n            done[i] = 1;\n            if(tmp>ans)ans=tmp;\n        }\n        printf(\"%d\\n\",ans);\n        scanf(\"%d\",&n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<pair<int,int>> S;\n\tint i,j,k,n,inv,dep,max,max1;\n\tint a[101],b[101],d[101],e[101][101],c[101];\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\te[i][j]=0;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tc[i]=0;\n\t\t}\n\t\tfor(i=0;i<=n-1;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t\te[a[i]][b[i]]=1;\n\t\t\te[b[i]][a[i]]=1;\n\t\t}\n\t\tfor(i=0;i<=100;i++)\n\t\t{\n\t\t\tfor(j=0;j<=100;j++)\n\t\t\t{\n\t\t\t\tif(e[i][j]==1) d[i]++;\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=1;i<=100;i++)\n\t\t{\n\t\t\tmax1=0;\n\t\t\tc[i]=1;\n\t\t\tS.push(make_pair(i,0));\n\t\t\twhile(S.empty()!=1)\n\t\t\t{\n\t\t\t\tinv=S.top().first;\n\t\t\t\tdep=S.top().second;\n\t\t\t\tS.pop();\n\t\t\t\tfor(k=1;k<=100;k++)\n\t\t\t\t{\n\t\t\t\t\tif(e[inv][k]==1 && c[k]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[k]=1;\n\t\t\t\t\t\tS.push(make_pair(k,dep+1));\n\t\t\t\t\t\tif(max1<dep+1) max1=dep+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<max1) max=max1;\n\t\t\tfor(k=0;k<=100;k++) c[k]=0;\n\t\t}\n\t\tcout << max+2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector<vector<int> > v;\n\nint dfs(int pos, vector<bool> &visited) {\n    int ans = 0;\n    visited[pos] = true;\n    for(int i = 0; i < v[pos].size(); ++i) {\n        if(visited[v[pos][i]]) continue;\n        ans = max(ans, dfs(v[pos][i], visited));\n    }\n    visited[pos] = false;\n    return ans+1;\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        v.clear();\n        v.resize(100);\n        for(int i = 0; i < N; ++i) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            v[a].push_back(b);\n            v[b].push_back(a);\n        }\n        int ans = 0;\n        for(int i = 0; i < 100; ++i) {\n            vector<bool> visited(100, false);\n            ans = max(ans, dfs(i, visited));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>es[100];\nint max_length;\nbool used[100];\nvoid get_max_length(int at_pos,int sum_length){\n    used[at_pos]=true;\n    for(int i=0;i<es[at_pos].size();i++){\n        int next_pos=es[at_pos][i];\n        if(used[next_pos])continue;\n        get_max_length(next_pos,sum_length+1);\n    }\n    max_length=max(max_length,sum_length);\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        for(int i=0;i<n;i++)es[i].clear();\n        max_length=0;\n        for(int i=0;i<n;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            es[a].push_back(b);\n            es[b].push_back(a);\n        }\n        for(int i=0;fill_n(used,100,false),i<n;i++)\n            get_max_length(i,1);\n\n        printf(\"%d\\n\",max_length);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[100];\nbool once_used[100];\nbool used[100];\nint dfs(int v)\n{\n\tonce_used[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tfill(once_used, once_used+100, false);\n\t\tpint e[100];\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\te[i] = pint(edge[i].size(), i);\n\t\tsort(e, e+100);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tif (e[i].first && !once_used[e[i].second])\n\t\t\t\tres = max(res, dfs(e[i].second));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<set<Int> > G(100);\n    for(Int i=0;i<n;i++){\n      Int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].emplace(b);\n      G[b].emplace(a);\n    }\n    Int ans=1;\n    auto calc=[&](Int s){\n      vector<int> used(100,0);\n      function<void(int,int)> dfs=[&](int v,int d){\n\tchmax(ans,d+1);\n\tfor(int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  dfs(u,d+1);\n\t  used[u]=0;\n\t}\n      };\n      used[s]=1;\n      dfs(s,0);\n    };\n    \n    for(Int i=0;i<100;i++) calc(i);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nbool d[101],dd[101];\t//true = 使った。\n\nint ans = 0;\nint n;\nvector<int> G[101];\n\n\n\nint dfs(int from, int now)\n{\n\n\tfor(int i = 0; i < G[from].size(); i++){\n\t\tif(!d[G[from][i]]){\n\t\t\td[G[from][i]] = dd[G[from][i]] = true;\n\t\t\tans = max(ans,dfs(G[from][i], now+1));\n\t\t\td[G[from][i]] = false;\n\t\t}\n\t}\n\n\treturn now;\n}\n\nint main(void)\n{\n\n\tans = 0;\n\n\twhile(cin >> n,n){\nans = 0;\n\t\tint from,to;\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\td[i] = dd[i] = false;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> from >> to;\n\t\t\tG[from].push_back(to);\n\t\t\tG[to].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\t//if(!dd[i]){\n\t\t\t\tdfs(i, 1);\n\t\t\t//}\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\twhile(G[i].size())\n\t\t\t\tG[i].pop_back();\n\n\t\tcout << ans-1 << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n\nusing namespace std;\n\nbool isPassedNode[101];\nbool isPassedEdge[101][101];\n\nint n;\n\nvector<int>G[101];\n\nint dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!isPassedEdge[s][to]){\n\t\t\tisPassedEdge[s][to]=true;\n\t\t\tisPassedEdge[to][s]=true;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tisPassedEdge[s][to]=false;\n\t\t\tisPassedEdge[to][s]=false;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint maxRes=0;\n\t\tset<int> starts;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t\tstarts.insert(a);\n\t\t\tstarts.insert(b);\n\t\t}\n\n\t\tmemset(isPassedEdge,0,sizeof(isPassedEdge));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\n\t\tfor(set<int>::iterator it = starts.begin(); it!=starts.end(); it++){\n\t\t\tmaxRes=max(maxRes,dfs(*it));\n\t\t}\n\t\tcout<<maxRes<<endl;\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=1;\n\t\t\tvisit[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t\tvisitone[a]=visitone[b]=0;\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,1000){\n\t\t\treps(j,100){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,100){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==1)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs (vector<vector<int> > &v, int now, vector<int> used, int count) {\n    if (used[now]) return count;\n    count++;\n\n    used[now] = true;\n    int ret = 0;\n    for (auto i : v[now]) {\n        ret = max(ret, dfs(v, i, used, count));\n    }\n\n    return ret;\n}\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<vector<int> > v(101);\n        for (int i = 0; i < N; i++) {\n            int x, y;\n            cin >> x >> y;\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= 100; i++) {\n            ans = max(ans, dfs(v, i, vector<int>(101, false), 0));\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nvector<int> a[100];\nbool b[100];\nint fi(int p){\n\tint i;\n\tint mx=0;\n\tfor(i=0;i<(int)a[p].size();++i){\n\t\tif(b[a[p][i]])\n\t\t\tcontinue;\n\t\tb[a[p][i]]=true;\n\t\tmx=max(mx,fi(a[p][i])+1);\n\t\tb[a[p][i]]=false;\n\t}\n\treturn mx;\n}\nint main(){\n\tint i;\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<100;++i)\n\t\t\ta[i].clear();\n\t\tfor(i=0;i<n;++i){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\t--p;\n\t\t\t--q;\n\t\t\ta[p].push_back(q);\n\t\t\ta[q].push_back(p);\n\t\t}\n\t\tint mn=1<<30,mx=0;\n\t\tfor(i=0;i<100;++i){\n\t\t\tif(a[i].size())\n\t\t\t\tmn=min(mn,(int)a[i].size());\n\t\t}\n\t\tmn+=3;\n\t\tfor(i=0;i<100;++i){\n\t\t\tif(a[i].size()&&a[i].size()<=mn)\n\t\t\t\tmx=max(mx,fi(i));\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<int, int>m;\nvector<vector<int> >G(MAX_N);\n\nint dfs(int now, int c){\n  int res = c;\n  rep(i, G[now].size()){\n    if(m.count(G[now][i])) continue;\n    m[G[now][i]] = 1;\n    res = max(c ,dfs(G[now][i], c+1));\n    m.erase(G[now][i]);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n) && n){\n    rep(i, n) G[i].clear();\n    int a, b;\n    rep(i, n){\n      scanf(\"%d%d\", &a, &b); a--; b--;\n      G[a].PB(b);\n      G[b].PB(a);\n    }\n    int res = 0;\n    rep(i, n){\n      m.clear();\n      m[i] = 1;\n      res = max(res, dfs(i, 1));\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\n\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==100)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==100)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==100)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint done[100];\nint c[100][2];\n\nint chain(int e,int l){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!passed[to]){\n\t\t\tpassed[to]=true;\n\t\t\tdfs(to,depth+1);\n\t\t\tpassed[to]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmaxPath=0;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\t//cin>>a>>b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tpassed[*it]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\",maxPath);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,100){\n\t\t\treps(j,n){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,n){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==0)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<vector<Int> > G(100);\n    for(Int i=0;i<n;i++){\n      Int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n    for(Int i=0;i<100;i++){\n      sort(G[i].begin(),G[i].end());\n      G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n    Int ans=1;\n    auto calc=[&](Int s){\n      vector<int> used(100,0);\n      function<void(int,int)> dfs=[&](int v,int d){\n\tchmax(ans,d+1);\n\tfor(int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  dfs(u,d+1);\n\t  used[u]=0;\n\t}\n      };\n      used[s]=1;\n      dfs(s,0);\n    };\n    \n    for(Int i=0;i<100;i++) calc(i);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<sstream>\n#include<deque>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass KI{\n\tpublic:\n\tKI(){}\n\tvector<int> list;\n};\nclass S{\n\tpublic:\n\tS(int now,int cont,vector<int> visit):now(now),cont(cont),visit(visit){}\n\tint now;\n\tint cont;\n\tvector<int> visit;\n};\n\nKI node[101];\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\treps(i,n){\n\t\t\tnode[i].list.clear();\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tnode[a].list.push_back(b);\n\t\t\tnode[b].list.push_back(a);\n\t\t}\n\t\t\n\t\tqueue<S> que;\n\t\tvector<int> visit(101);\n\t\t\n\t\tint check[101];\n\t\trep(i,101)check[i]=0;\n\t\t\n\t\tint maxp,maxi=-1;\n\t\treps(p,n){\n\t\t\tque.push(S(p,0,visit));\n\t\t\t\n\t\t\t//printf(\"maxp=%d\\n\",maxp);\n\t\t\t\n\t\t\twhile(1){\n\t\t\t\tif(que.empty()==1)break;\n\t\t\t\t\n\t\t\t\tS u = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(u.visit[u.now]==1)continue;\n\t\t\t\tu.visit[u.now]=1;\n\t\t\t\t\n\t\t\t\tif(maxi<u.cont){\n\t\t\t\t\tmaxi=u.cont;\n\t\t\t\t\tmaxp=u.now;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheck[u.now]=1;\n\t\t\t\t\n\t\t\t\t//printf(\"a %d %d\\n\",u.now,u.cont);\n\t\t\t\t\n\t\t\t\trep(i,node[u.now].list.size()){\n\t\t\t\t\tque.push(S(node[u.now].list[i],u.cont+1,u.visit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",maxi+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 0;j < rings.size();j++){\n\tif(neib[rings[j]].size() == i && onceused[rings[j]] == 0){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }  \n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\n\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==100)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==100)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;n\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfilnll(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==100)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n\n#define\t\tN\t101\n\nint find_length(int a, int cur_length);\n\nint\t\tconn[N][N];\nint\t\tused[N];\n\nint main()\n{\n    int\t\ti, j;\n    int\t\ta, b;\n    int\t\tn;\n    int\t\tmax_length, length;\n    time_t\tstart_time, t;\n\n    while(1)\n    {\n\tstart_time = time(NULL);\n\tfor(j = 0; j < N; j++)\n\t{\n\t    for(i = 0; i < N; i++)\n\t    {\n\t\tconn[j][i] = 0;\n\t    }\n\t}\n\n\tscanf(\"%d\", &n);\n\tif (n == 0)\n\t{\n\t    break;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t    scanf(\"%d %d\", &a, &b);\n\t    conn[a][b] = 1;\n\t    conn[b][a] = 1;\n\t}\n\n\tfor(a = 0; a < N; a++)\n\t{\n\t    used[a] = 0;\n\t}\n\n\tmax_length = 0;\n\tfor(a = 0; a < N; a++)\n\t{\n\t    length = find_length(a, 1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t    if (time(NULL) - start_time > 1)\n\t    {\n\t\tbreak;\n\t    }\n\t}\n\tprintf(\"%d\\n\", max_length);\n    }\n}\n\n\nint find_length(int a, int cur_length)\n{\n    int\t\tb;\n    int\t\tlength, max_length;\n\n    used[a] = 1;\n    max_length = cur_length;\n    for(b = 0; b < N; b++)\n    {\n\tif (conn[a][b] == 1 && used[b] != 1)\n\t{\n\t    length = find_length(b, cur_length+1);\n\t    if (length > max_length)\n\t    {\n\t\tmax_length = length;\n\t    }\n\t}\n    }\n    used[a] = 0;\n\n    return max_length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nvector<int> edge[128];\nbool used_once[128];\nbool used[128];\nint dfs(int v)\n{\n\tused_once[v] = true;\n\tused[v] = true;\n\tint res = 0;\n\tforeach (it, edge[v])\n\t\tif (!used[*it])\n\t\t\tres = max(res, dfs(*it));\n\tused[v] = false;\n\treturn res + 1;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 0; i < 128; ++i)\n\t\t\tedge[i] = vector<int>();\n\t\twhile (n--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\t\t\n\t\tfill(used_once, used_once+128, false);\n\t\tpint e[128];\n\t\tfor (int i = 0; i < 128; ++i)\n\t\t\te[i] = pint(edge[i].size(), i);\n\t\tsort(e, e+128);\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 128; ++i)\n\t\t\tif (e[i].first && !used_once[e[i].second])\n\t\t\t\tres = max(res, dfs(e[i].second));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nint N;\nvector< pair<int, int> > E[101];\nbool V[100];\nint C[101];\nint x;\nint ans;\n\nvoid dfs(int v, int lvl) {\n  ans = max(ans, lvl);\n\n  int nlvl = C[v]++ == 0 ? lvl + 1 : lvl;\n\n  for(int i = 0; i < E[v].size(); i++) {\n    if(!V[E[v][i].second]) {\n      V[E[v][i].second] = true;\n      dfs(E[v][i].first, nlvl);\n      V[E[v][i].second] = false;\n    }\n  }\n\n  C[v]--;\n}\n\nint main(void) {\n  while(1) {\n    cin >> N;\n    if(N == 0) break;\n    REP(i, 0, N) {\n      int a, b;\n      cin >> a >> b;\n      V[i] = false;\n      E[a].push_back(pair<int, int>(b, i));\n      E[b].push_back(pair<int, int>(a, i));\n      x = max(x, max(a, b));\n    }\n    REP(i, 1, N + 1) {\n      C[i] = 0;\n    }\n\n    ans = 0;\n    REP(i, 1, x + 1) {\n      dfs(i, 0);\n    }\n\n    cout << ans << endl;\n\n    REP(i, 1, 101) {\n      E[i].clear();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint g[100][100];\nint num[100];\nbool f[100];\nint tmp[100];\nint k;\nint d;\nint dm;\n\nint solve(int pos){\n  int ans = 1;\n  f[pos] = true;\n  dm = max(dm, ++d);\n  REP(i,num[pos]){\n    int next = g[pos][i];\n    if(f[next]) continue;\n    //if(next < k && tmp[next] + d <= dm)\n    //continue;\n    ans = max(ans, 1 + solve(next));\n  }\n  f[pos] = false;\n  d--;\n  return ans;\n}\n\nint main(){\n  while(n = getInt()){\n    dm = 0;\n    REP(i,100) {\n      f[i] = false;\n      num[i] = 0;\n    }\n    REP(i,n){\n      int a = getInt()-1;\n      int b = getInt()-1;\n      g[a][num[a]++] = b;\n      g[b][num[b]++] = a;\n    }\n    int ans = 0;\n    REP(i,100){\n      k = i;\n      d = 0;\n      tmp[i] = solve(i);\n      ans = max(ans, tmp[i]);\n    }\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\n\nint dfs(int v, vector<vector<int> > &g, vector<bool> &visit)\n{\n\tvisit[v] = true;\n\t\n\tint ret = 1;\n\t\n\tfor(int i = 0; i < g[v].size(); ++i) {\n\t\t\n\t\tint w = g[v][i];\n\t\t\n\t\tif(visit[w])\n\t\t\tcontinue;\n\t\t\n\t\tint len = dfs(w, g, visit);\n\t\tret = max(ret, len + 1);\n\t}\n\t\n\tvisit[v] = false;\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tvector<vector<int> > g;\n\t\tint n;\n\t\tconst int nodesize = 100;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\n\t\tg.resize(nodesize);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta -= 1, b -= 1;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\t\n\t\tvector<bool> visit;\n\t\tvisit.resize(nodesize);\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < nodesize; ++i) {\n\t\t\tint len = dfs(i, g, visit);\n\t\t\tans = max(ans, len);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\nvector<int> vec[101];\nbool ch[101]={};\nbool visited[101]={};\nint dp[101]={};\nint maxx = -1;\nint maxNODE = -1;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    dp[i] = max(dp[i],val);\n    //printf(\"%d \",i);\n    int len = vec[i].size();\n    for (int k=0; k<len; k++) {\n        if(!ch[vec[i][k]]){\n            visited[vec[i][k]] = true;\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = true;\n        ch[i] = true;\n        DFS(i,1);\n        ch[i] = false;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(maxx == dp[i]){\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n            break;\n        }\n    }\n    printf(\"%d\\n\",maxx);\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = false;\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nvector<int> G[100];\nint D[100];\n\nint solve(int m)\n{\n    int r=1,t;\n    for(vector<int>::iterator it=G[m].begin();it!=G[m].end();it++){\n        if(!D[*it]){\n            D[*it]=1;\n            r=max(r,1+solve(*it));\n            D[*it]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    for(int i=0;i<100;i++)G[i].reserve(100);\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n \nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = false;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = false; rings[i] = 0;\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A][rings[A]] = B; rings[A]++;\n            G[B][rings[B]] = A; rings[B]++;\n        }\n\n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<int, int>m;\nvector<vector<int> >G(MAX_N);\nint ans = 0;\n\nvoid dfs(int now, int c){\n  c++;\n  int res = c;\n  rep(i, G[now].size()){\n    if(m.count(G[now][i])) continue;\n    m[G[now][i]] = 1;\n    dfs(G[now][i], c);\n    m.erase(G[now][i]);\n  }\n  ans = max(ans, c);\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n) && n){\n    rep(i, n) G[i].clear();\n    int a, b;\n    vi v;\n    rep(i, n){\n      scanf(\"%d%d\", &a, &b); a--; b--;\n      G[a].PB(b);\n      G[b].PB(a);\n      if(find(v.begin(), v.end(), a) == v.end()) v.PB(a);\n      if(find(v.begin(), v.end(), b) == v.end()) v.PB(b);\n    }\n    int res = 0;\n    rep(i, v.size()){\n      m.clear();\n      m[v[i]] = 1;\n      dfs(v[i], 0);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nint rec(int pos, vector<bool> used)\n{\n    used[pos] = true; int ret = 1;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used) + 1);\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(100, false)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for(i = 0;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define pb push_back\n#define mp make_pair\n\ntypedef int edge;\nvector<edge> G[100];\nbool use[100];\nbool vst[100];\n\nint dfs(int now, int d){\n  vst[now] = true;\n  int res = d, i, j;\n  rep(i, G[now].size())if(!vst[G[now][i]])res = max(res, dfs(G[now][i], d + 1));\n  vst[now] = false;\n  return res;\n}\n\nsigned main(void){\n  int i, j, n, a, b;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    scanf(\"%d\", &n);\n    if(n == 0)break;\n    rep(i, 100)use[i] = false;\n    rep(i, n){\n      scanf(\"%d%d\", &a, &b);\n      --a; --b;\n      G[a].pb(b); G[b].pb(a);\n      use[a] = true; use[b] = true;\n    }\n\n    int res = 0;\n    rep(i, 100)if(use[i]){\n      rep(j, 100)vst[j] = false;\n      res = max(res, dfs(i, 1));\n    }\n    printf(\"%d\\n\", res);\n\n    rep(i, 100)if(use[i])G[i].clear();\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\nint N;\nvector<int> G[102];\nint f[102];\nint search(int id){\n  int ret=0;\n  for(int i=0;i<(int)G[id].size();i++){\n    if(!f[G[id][i]]){\n      f[G[id][i]]=1;\n      ret = max(ret,search(G[id][i])+1);\n      //      f[G[id][i]]=0;\n    }\n  }\n  return ret;\n}\nint solve(int id){\n  int ret=0;\n  //  printf(\"size = %d\\n\",(int)G[id].size());\n  if((int)G[id].size()==1){\n    if(!f[G[id][0]]){\n      f[G[id][0]]=1;\n      ret = search(G[id][0])+1;\n      //    printf(\"st %d %d ... %d\\n\",id,G[id][0],ret); \n      //  f[G[id][0]]=0;\n    }\n    return ret;\n  }\n  for(int i=0;i<(int)G[id].size();i++){\n    for(int j=i+1;j<(int)G[id].size();j++){\n      int tmpi=0,tmpj=0;\n      bool fi=false,fj=false;\n      if(!f[G[id][i]]){\n\tfi=true;\n\tf[G[id][i]]=1;\n\ttmpi = search(G[id][i])+1;\n      }\n      if(!f[G[id][j]]){\n\tfj=true;\n\tf[G[id][j]]=1;\n\ttmpj = search(G[id][j])+1;\n      }\n      ret = max(ret,tmpi+tmpj);\n      //     printf(\"st %d & %d ... %d\\n\",G[id][i],G[id][j],tmpi+tmpj); \n      //      if(fi) f[G[id][i]]=0;\n      //      if(fj) f[G[id][j]]=0;\n    }\n  }\n  //  printf(\"st %d %d\\n\",id,ret);\n  return ret;\n}\nint main(){\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    for(int i=0;i<N;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    int res=0;\n    for(int i=0;i<102;i++){\n      if(!G[i].empty()){\n\tmemset(f,0,sizeof(f));\n\tf[i]=1;\n\t//      printf(\"wa:%d size %d\\n\",i,(int)G[i].size());\n\tint st = solve(i)+1;\n\tres = max(res,st);\n\t//     printf(\"wa ... %d %d\\n\",i,st);\n      }\n    }\n    printf(\"%d\\n\",res);\n    for(int i=0;i<102;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstring>\n\nint n;\nstd::vector<int> es[100];\nbool used[100];\n\nint dfs( int p )\n{\n\tint ret = 0;\n\t\n\tfor( int i = 0; i != es[p].size(); ++i )\n\t{\n\t\tif( !used[es[p][i]] )\n\t\t{\n\t\t\tused[es[p][i]] = true;\n\t\t\tret = std::max( ret, dfs( es[p][i] ) + 1 );\n\t\t\tused[es[p][i]] = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile( std::cin >> n, n )\n\t{\n\t\tfor( int i = 0; i != n; ++i )\n\t\t\tes[i].clear();\n\t\t\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint a, b;\n\t\t\tstd::cin >> a >> b;\n\n\t\t\tes[a-1].push_back( b - 1 );\n\t\t\tes[b-1].push_back( a - 1 );\n\t\t}\n\n\t\tint m = 100;\n\t\tfor( int i = 0; i != 100; ++i )\n\t\t\tif( !es[i].empty() )\n\t\t\t\tm = std::min( m, (int)es[i].size() );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != 100; ++i )\n\t\t{\n\t\t\tif( es[i].size() == m )\n\t\t\t{\n\t\t\t\tmemset( used, false, sizeof( used ) );\n\t\t\t\tans = std::max( ans, dfs( i ) );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\n\nint search(int now)\n{\n\tif (vis[now]){\n\t\t//vis[now] = false;\n\t\treturn 0;\n\t}\n\t\n\tvis[now] = true;\n\t\n\tint res = 0;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tres = max(res, search(v[now][i]) + 1);\n\t}\n\t\n\tvis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t}\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t//if (v[i].size() == mini){\n\t\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\t\tvis[j] = false;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\n#include<cstring>\nusing namespace std;\nlong long int mod = 1e9 + 7;\nint inf = 1e9;\n\nint n;\nvector< pair<int, int> > p;\nvector< vector<int> > d;\nvector<bool> vis;\n\nint func(int pos) {\n  vis[pos] = true;\n  int r = 1;\n  for(int i=0; i<d[pos].size(); i++) {\n    if(!vis[d[pos][i]]) {\n      r = max(r, func(d[pos][i]) + 1);\n    }\n  }\n  vis[pos] = false;\n  return r;\n}\n\nint main() {\n  while(true) {\n    cin >> n;\n    if(n == 0) break;\n    p.assign(n, {0,0});\n    d.assign(100, vector<int>(0,0));\n    vis.assign(100, false);\n    for(int i=0; i<n; i++) {\n      cin >> p[i].first >> p[i].second;\n      p[i].first--;\n      p[i].second--;\n      d[p[i].first].push_back(p[i].second);\n      d[p[i].second].push_back(p[i].first);\n    }\n\n    int ans = 0;\n    for(int i=0; i<100; i++) ans = max(ans, func(i));\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n\n//EOF\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\nvector<int> g[101];\nbool v;\nbool used[101];\nint ok[101];\nint in[101];\nint type[101];\nint ans;\n\nint dfs(int p,int c){\n\tused[p] = true;\n\tans = max(c,ans);\n\tfor(int i = 0 ; i < g[p].size() ; i++){\n\t\tif(!used[g[p][i]]){\n\t\t\tdfs(g[p][i],c+1);\n\t\t}\n\t}\n\tused[p] = false;\n}\n\nvoid same(int p,int t){\n\tif(used[p])return; else used[p] = true;\n\ttype[t] = min(type[p],in[p]);\n\tok[p] = t;\n\trep(i,g[p].size())same(g[p][i],t);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i,101) g[i].clear() , in[i] = 0 , ok[i] = -1 , type[i] = 999;\n\t\tvector<int> v;\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t\tin[a]++,in[b]++;\n\t\t\tv.push_back(a);\n\t\t\tv.push_back(b);\n\t\t}\n\t\tans = 0 ;\n\t\tsort(v.begin(),v.end());\n\t\tint C = 0;\n\t\tfor(int i = 0 ; i < v.size() ; i++){\n\t\t\tif( (!i || v[i] != v[i-1]) && ok[v[i]] == -1){\n\t\t\t\trep(j,101)used[j] = 0;\n\t\t\t\tsame(v[i],C++);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < C ; i++){\n\t\t\tfor(int j = 1 ; j <= 100 ; j++){\n\t\t\t\tif(ok[j] == i && in[j] == type[i]){\n\t\t\t\t\trep(k,101)used[k] = 0;\n\t\t\t\t\tdfs(j,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nvector<int> a[100];\nbool b[100];\nint fi(int p){\n\tint i;\n\tint mx=0;\n\tfor(i=0;i<(int)a[p].size();++i){\n\t\tif(b[a[p][i]])\n\t\t\tcontinue;\n\t\tb[a[p][i]]=true;\n\t\tmx=max(mx,fi(a[p][i])+1);\n\t\tb[a[p][i]]=false;\n\t}\n\treturn mx;\n}\nint main(){\n\tint i;\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;++i)\n\t\t\ta[i].clear();\n\t\tfor(i=0;i<n;++i){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\t--p;\n\t\t\t--q;\n\t\t\ta[p].push_back(q);\n\t\t\ta[q].push_back(p);\n\t\t}\n\t\tint mn=1<<30,mx=0;\n\t\tfor(i=0;i<n;++i)\n\t\t\tmn=min(mn,(int)a[i].size());\n\t\tmn+=3;\n\t\tfor(i=0;i<n;++i){\n\t\t\tif(a[i].size()<=mn)\n\t\t\t\tmx=max(mx,fi(i));\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nmap< int, vector<int> > edge;\nmap< int, vector<int> >::iterator mit;\n\nint dfs(int vertex, set<int> visited) {\n    int result;\n    visited.insert(vertex);\n    result = visited.size();\n    for(int i=0; i<edge[vertex].size(); i++) {\n        if(visited.count(edge[vertex][i])) continue;\n        result = max(result, dfs(edge[vertex][i], visited));\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    set<int> visited;\n    for(mit=edge.begin(); mit!=edge.end(); mit++) {\n        result = max(result, dfs(mit->first, visited));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            edge[--u].push_back(--v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint mxl,l,n,e1[100],e2[100],u[100],un[101];\n\nvoid rec(int t){\n\tif(mxl<l)mxl=l;\n\trep(i,n)if(!un[e1[i]]&&t==e2[i]){\n\t\tl++,u[i]=1,un[e1[i]]=1,un[e2[i]]=1; rec(e1[i]);\n\t\tl--,u[i]=0,un[e1[i]]=0,un[e2[i]]=0;\n\t}\n\trep(i,n)if(!un[e2[i]]&&t==e1[i]){\n\t\tl++,u[i]=1,un[e1[i]]=1,un[e2[i]]=1; rec(e2[i]);\n\t\tl--,u[i]=0,un[e1[i]]=0,un[e2[i]]=0;\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tmxl=0; rep(i,n)cin>>e1[i]>>e2[i];\n\t\trep(i,n){\n\t\t\trep(j,n)u[j]=i==j;l=2;rep(j,101)un[j]=j==e1[i]||j==e2[i]; rec(e1[i]);\n\t\t\trep(j,n)u[j]=i==j;l=2;rep(j,101)un[j]=j==e1[i]||j==e2[i]; rec(e2[i]);\n\t\t}\n\t\tcout<<mxl<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nvector<int> G[100];\nbool visited[100];\nint memo[100];\n\nint visit(int v){\n\tint res = 0;\n\trep(i, (int)G[v].size()){\n\t\tif(!visited[G[v][i]] && memo[G[v][i]] >= res){\n\t\t\tvisited[G[v][i]] = true;\n\t\t\tres = max(res, 1 + visit(G[v][i]));\n\t\t\tvisited[G[v][i]] = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tint a, b;\n\twhile(cin >> n && n){\n\t\n\t\trep(i, 100) G[i].clear();\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfill(memo, memo + 100, INF);\n\n\t\trep(i, n){\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\n\t\tint res = 0;\n\t\t\n\t\trep(i, 100){\n\t\t\tvisited[i] = true;\n\t\t\tmemo[i] = visit(i);\n\t\t\tres = max(res, memo[i]);\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << res + 1<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nvvi adj;\nint n,ans;\nbool visited[100];\n\nvoid dfs(int u,int cnt){\n\tif(ans<cnt) ans=cnt;\n\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tdfs(v,cnt+1);\n\t\t\tvisited[v]=false;\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int m;scanf(\"%d\",&m),m;){\n\t\tbool adjm[100][100]={},flg[100]={};\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\ta--, b--;\n\t\t\tadjm[a][b]=adjm[b][a]=flg[a]=flg[b]=true;\n\t\t}\n\n\t\tint f[100]; n=0;\n\t\trep(i,100) if(flg[i]) f[i]=n++;\n\n\t\tadj=vvi(n);\n\t\trep(i,100) rep(j,100) if(adjm[i][j]) adj[f[i]].pb(f[j]);\n\n\t\tans=0;\n\t\trep(u,n) visited[u]=false;\n\t\trep(u,n-1){\n\t\t\tvisited[u]=true;\n\t\t\tdfs(u,1);\n\t\t\tvisited[u]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    bool line[100][100];\n    int chain[100];\n    int len;\n    bool done[100];\n    int passed[100];\n\tint n;\n\tint a, b;\n    int i,j;\n    bool finish;\n    int max;\n\tcin >> n;\n\twhile(n){\n        max = 1;\n        finish = true;\n        len = 0;\n        for(i=0;i<100;i++){\n            done[i] = false;\n            passed[i] = 0;\n            for(j=0;j<100;j++){\n                line[i][j] = false;\n            }\n        }\n        for(i=0;i<n;i++){\n            cin >> a >> b;\n            a -= 1;\n            b -= 1;\n            line[a][b] = true;\n            line[b][a] = true;\n        }\n        for(i=0;i<100;i++){\n            for(j=0;j<100;j++){\n                if(line[i][j]){\n                    chain[len] = i;\n                    len += 1;\n                    chain[len] = j;\n                    len += 1;\n                    done[i] = true;\n                    passed[i] = j+1;\n                    done[j] = true;\n                    while(len){\n                        finish = true;\n                        i = chain[len-1];\n                        for(j=passed[i];j<100;j++){\n                            if(line[i][j] && !done[j]){\n                                chain[len] = j;\n                                len += 1;\n                                done[j] = true;\n                                passed[i] = j+1;\n                                finish = false;\n                                break;\n                            }\n                        }\n                        if(finish){\n                            if(len > max){\n                                max = len;\n                                if(max == n){\n                                    break;\n                                }\n                            }\n                            done[i] = false;\n                            passed[i] = 0;\n                            len -= 1;\n                        }\n                    }\n                }\n            }\n        }\n        cout << max << endl;\n        cin >> n;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nvector<int> G[100];\nint D[100];\n\nint size(int m)\n{\n    int r=1;\n    for(vector<int>::iterator it=G[m].begin();it!=G[m].end();it++){\n        if(!D[*it]){\n            D[*it]=1;\n            r=max(r,1+size(*it));\n            D[*it]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,size(i));\n            D[i]=0;\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint i,j;\nint edge[100][100];\ntypedef struct{\n    int from;\n    int to;\n}t_edge;\nt_edge edge2[100];\nint c[100];\nint used[100];\nint m;\n \nint max(int a,int b){\n    if(a>=b)return a;\n    else return b;\n}\n \nint solve(int from,int to){\n    used[from]=1;\n    int x=0;\n    for(int k=0;k<c[to];k++){\n        if(used[edge[to][k]]!=1){\n            x=max(x,solve(to,edge[to][k]));\n        }\n    }\n    return x+1;\n}\n \nint main(){\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0)return 0;\n        m=0;\n        for(i=0;i<100;i++)for(j=0;j<100;j++)edge[i][j]=0;\n        for(i=0;i<100;i++)c[i]=0;\n        for(i=0;i<100;i++)used[i]=0;\n        for(i=0;i<n;i++){\n            int a,b;\n            scanf(\"%d %d\",&a,&b);\n            edge[a][c[a]++]=b;\n            edge[b][c[b]++]=a;\n            edge2[i].from=a;\n            edge2[i].to=b;\n        }\n        for(i=0;i<n;i++){\n            for(j=0;j<100;j++)used[j]=0;\n            m=max(m,solve(edge2[i].from,edge2[i].to));\n            for(j=0;j<100;j++)used[j]=0;\n            m=max(m,solve(edge2[i].to,edge2[i].from));\n        }\n        printf(\"%d\\n\",m+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[100];\nbool visit[100];\n\nvector<int> out;\n\nint dfs(int i){\n\tint res=0;\n\tfor (int v=0;v<G[i].size();v++){\n\t\tif (!visit[G[i][v]]){\n\t\t\tvisit[G[i][v]]=true;\n\t\t\tres=max(res,dfs(G[i][v]));\n\t\t\tvisit[G[i][v]]=false;\n\t\t}\n\t}\n\treturn res+1;\n}\n\nint main(){\n\tint n;\n\tint a,b;\n\tdo{\n\t\tscanf(\"%d\",&n);\n\t\tif (n){\n\t\t\tfor (int i=0;i<100;i++){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tfor (int i=0;i<n;i++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tG[a].push_back(b);\n\t\t\t\tG[b].push_back(a);\n\t\t\t}\n\t\t\tint res=0;\n\t\t\tfor (int i=0;i<100;i++){\n\t\t\t\tvisit[i]=true;\n\t\t\t\tres=max(res,dfs(i));\n\t\t\t\tvisit[i]=false;\n\t\t\t}\n\t\t\tout.push_back(res);\n\t\t}\n\t}while (n);\n\tfor (vector<int>::iterator ite=out.begin();ite!=out.end();ite++){\n\t\tprintf(\"%d\\n\",*ite);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstatic const int black = 1;\nstatic const int white = 0;\n\nint graph[128][128] = {{}};\nstatic int color[128] = {};\nint n,cou = 0,ans = 0,in1;\nint d[128] = {};\n\nvoid  dfs(int in){\n  \n  int u;\n  u = in;\n  color[u] = black;\n \n  \n  for(int i = 0;i < n;i++){\n    if(graph[u][i] == 1 && color[i] != black){\n      if(u == in1) cou++;\n      d[cou]++;\n      // cout << \"i = \" << i << endl;\n      dfs(i);\n    }\n  }\n}\n\n\n\nint main(){\n\n  int mae,ato;\n\n  while(1){ \n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0;i < n;i++){\n      cin >> mae >> ato;\n      graph[mae - 1][ato - 1] = 1;\n      graph[ato - 1][mae - 1] = 1;\n    }\n  \n    for(int i = 0;i < 100;i++) color[i] = white;\n\n    for(int i = 0;i < n;i++){\n      if(color[i] != black){\n\tin1 = i;\n\tdfs(in1);\n\tif(ans < d[cou])ans = d[cou];\n\tcou++;\n\t//\tcout << \"cou = \" << cou << endl;\n      }\n    }\n    cout <<  ans + 1 << endl;\n  \n\n    for(int i =0;i < 128;i++){\n      d[i] = 0;\n      color[i] = 0;\n      for(int j = 0;j < 128;j++) graph[i][j] = 0;\n      ans = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\nint ans;\nvector<int> edge[100];\nbool flg[100] ={};\nvoid dfs(int v, int d){\n\tans = max(ans, d);\n\tflg[v] = true;\n\tfor(int i=0; i<edge[v].size(); i++){\n\t\tif(!flg[edge[v][i]]) dfs(edge[v][i], d+1);\n\t}\n\tflg[v] = false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tfor(int i=0; i<100; i++){\n\t\t\tedge[i].clear();\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tedge[a-1].PB(b-1);\n\t\t\tedge[b-1].PB(a-1);\n\t\t}\n\n\t\tans = 0;\n\t\tfor(int i=0; i<100; i++){\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nvector< vector<int> > edge;\n\nint dfs(int v, bitset<101> visited) {\n    visited.set(v);\n    int result = visited.count();\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        result = max(result, dfs(*i, visited));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge = vector< vector<int> >(101);\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        int result = 0;\n        for(set<int>::iterator j=vertex.begin(); j!=vertex.end(); j++) {\n            result = max(result, dfs(*j, bitset<101>(0)));\n        }\n        cout<<result<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<list>\n#include<queue>\n\n#define MAX 110\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\nclass State{\npublic:\n  int pos;\n  State(int pos):pos(pos){\n    len = 1;\n  }\n  int len;\n  bool vis[MAX];\n};\n\nint BFS(int st, const vector<Node> &G){\n  int ret = 1;\n  queue<State> q;\n  State init(st);\n\n  fill(init.vis,init.vis+MAX,false);\n  init.vis[st]=true;\n  q.push(init);\n\n  while(!q.empty()){\n    bool NG=false;\n    State now = q.front();\n    q.pop();\n\n    ret = max( ret, now.len );\n\n    const set<int> &S = G[now.pos].con;\n    for(set<int>::iterator its = S.begin();\n\tits != S.end();\n\t++its){\n      int nx = *its;\n      if( !now.vis[ nx ] ){\n\tState next = now;\n\tnext.pos = nx;\n\tnext.vis[nx] = true;\n\tnext.len++;\n\tq.push( next );\n      }\n    }\n  }\n  return ret;\n}\n\ntypedef vector<Node> graph;\ntypedef list< vector<int> > forest;\n\nvoid MakeForest(const graph &g, bool exist[MAX], forest &f){\n  bool vis[MAX]={false};\n  for(int x=0;x<MAX;++x){\n    if(!vis[x]&&exist[x]){\n      queue<int> q;\n      bool tvis[MAX]={false};\n      q.push(x);\n      tvis[x]=true;\n      while(!q.empty()){\n\tint now=q.front();q.pop();const set<int> &C=g[now].con;\n\tfor(set<int>::iterator its=C.begin();its!=C.end();++its){\n\t  if(!tvis[*its]){tvis[*its]=true;q.push(*its);}\n\t}\n      }\n      vector<int> tmp;\n      f.push_back( tmp );\n      for(int i=0;i<MAX;++i){\n\tif(tvis[i]){\n\t  vis[i]=true;\n\t  f.back().push_back( i );\n\t}\n      }\n    }\n  }\n}\n\nint Backtrack(int pos, int now, int bans, bool vis[], int memo[], const graph &G){\n  const set<int> &C = G[pos].con;\n  int ret = now;\n  for(set<int>::iterator itc=C.begin();itc!=C.end();++itc){\n    int nx = *itc;\n    if( !vis[nx] ){\n      if(now+memo[nx]<=bans)continue;\n      bans=max(bans,now+1);\n      vis[nx]=true;\n      ret = max( ret, Backtrack(nx,now+1,bans,vis,memo,G) );\n      vis[nx]=false;\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    graph G(MAX);\n    forest F;\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      G[a].con.insert(b);\n      G[b].con.insert(a);\n    }\n\n    MakeForest(G,exist,F);\n\n    int memo[MAX];\n    for(int i=0;i<MAX;++i){\n      memo[i]=MAX+1;\n    }\n    for(forest::iterator itf=F.begin();itf!=F.end();++itf){\n      if((*itf).size()<=ans)continue;\n      for(int i = 0; i < (*itf).size(); ++i){\n\tint st=(*itf)[i];\n\tbool vis[MAX]={false,};\n\tint btret = Backtrack( st, 0, ans, vis, memo, G );\n\tmemo[st]=btret;\n\tans=max(ans,btret);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, A, B, v[111], r[111], G[111][222];\nint rec(int pos) {\n\tint ret = 0; v[pos] = 1;\n\tfor (int i = 0; i < r[pos]; i++) {\n\t\tif (!v[G[pos][i]]) {\n\t\t\tint w = rec(G[pos][i]);\n\t\t\tret = ret > w ? ret : w;\n\t\t}\n\t}\n\tv[pos] = 0;\n\treturn ret + 1;\n}\nint main() {\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < 100; i++) r[i] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%d%d\", &A, &B), A--, B--;\n\t\t\tG[A][r[A]++] = B, G[B][r[B]++] = A;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tint w = rec(i);\n\t\t\tret = ret > w ? ret : w;\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nint N;\nvector<int> E[101];\nbool V[101];\nint ans;\n\nvoid dfs(int v, int lvl) {\n  if(V[v]) {\n    ans = max(ans, lvl);\n  } else {\n    V[v] = true;\n    for(int i = 0; i < E[v].size(); i++) {\n      dfs(E[v][i], lvl + 1);\n    }\n    V[v] = false;\n  }\n}\n\nint main(void) {\n  while(1) {\n    cin >> N;\n    if(N == 0) break;\n    REP(i, 0, N) {\n      int a, b;\n      cin >> a >> b;\n      E[a].push_back(b);\n      E[b].push_back(a);\n    }\n\n    ans = 0;\n    REP(i, 1, 101) {\n      dfs(i, 0);\n    }\n\n    cout << ans << endl;\n\n    REP(i, 1, 101) {\n      E[i].clear();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100;\n\nint n, a, b;\nbool vis[N], G[N][N];\n\nint dfs(int p){\n  vis[p] = true;\n  int res = 1;\n  for(int i=0;i<N;i++) if(G[p][i] && !vis[i]) res = max(res, dfs(i) + 1);\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[N], false);\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      G[a-1][b-1] = G[b-1][a-1] = true;\n    }\n    int ans = 0;\n    for(int i=0;i<N;i++){\n      fill(vis, vis+N, false);\n      ans = max(ans, dfs(i));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst;\n  Edge() {}\n  Edge(int u, int v) : src(u), dst(v) {}\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nbool used[100];\nint dfs(int u, Graph& G){\n  used[u] = true;\n  int res = 0;\n  bool tmp_used[100];\n  memcpy(tmp_used, used, sizeof(used));\n  FORIT(e, G[u]) if(!used[e->dst]){\n    res = max(res, 1 + dfs(e->dst, G));\n    memcpy(used, tmp_used, sizeof(used));\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  const int M = 100;\n  while(cin >> N && N){\n    Graph G(M);\n    REP(i, N){\n      int u, v; cin >> u >> v;\n      u--; v--;\n      G[u].push_back(Edge(u, v));\n      G[v].push_back(Edge(v, u));\n    }\n    int ans = 0;\n    REP(root, N){\n      memset(used, 0, sizeof(used));\n      ans = max(ans, dfs(root, G) + 1);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > edge;\nbool visited[128];\nint n;\nint depth = 0;\n\nint solve(int k) {\n\tif(visited[k])\n\t\treturn -1;\n\tvisited[k] = true;\n\tint res = 0;\n\tfor(int i = 0; i < edge[k].size(); i++) {\n\t\tres = max(res, solve(edge[k][i]) + 1);\n\t}\n\tvisited[k] = false;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 128; i++)\n\t\t\tvisited[i] = false;\n\t\tedge.clear();\n\t\tedge.resize(100);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint res;\n\nvoid solve(vvi& g,int v,int len,vi& vis)\n{\n\tif(vis[v])\n\t\treturn;\n\tvis[v]=1;\n\t\n\tres=max(res,++len);\n\t\n\tint n=g.size();\n\trep(i,g[v].size())\n\t\tsolve(g,g[v][i],len,vis);\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tint s,d; scanf(\"%d%d\",&s,&d); s--,d--;\n\t\t\tg[s].push_back(d);\n\t\t\tg[d].push_back(s);\n\t\t}\n\t\t\n\t\tres=0;\n\t\trep(i,n){\n\t\t\tvi vis(n);\n\t\t\tsolve(g,i,0,vis);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nvector<bool> used;\n\nvector<int> rings;\n\nchar rec(char pos)\n{\n    used[pos] = true; char ret = 1;\n    \n    for(char i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n    \n    used[pos] = false;\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n\n        G = vector<vector<int> >(100, vector<int>());\n        \n        used = vector<bool>(100);\n        \n        rings = vector<int>(100);\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n        \n        for(int i = 0; i < 100; i++)\n        {\n            rings[i] = G[i].size();\n        }\n        \n        int nodes = 0;\n        \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                \n            if(ret == nodes) { break; }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\n#define fi first\n#define se second\n#define pii pair<int,int>\n\nbool visited[110];\nint dist[110];\nint eccen[110];\n\nint diam(const Graph &g, int n) {\n\n  for(int k=0; k<100; ++k) {\n    pii s = pii(k,0);\n    stack< pii > S;\n    for(int i=0; i<n; ++i) visited[i] = false,dist[i] = 0;\n\n    S.push(s);\n    while(!S.empty()) {\n      pii now = S.top();\n      S.pop();\n\n      if(visited[now.fi] == true) continue;\n      visited[now.fi] = true;\n      dist[now.fi] = now.se;\n\n      for(int j=0; j<g[now.fi].edge.size(); ++j) {\n\tif(visited[g[now.fi].edge[j]]) continue;\n\tdist[g[now.fi].edge[j]] = now.se+1;\n\tS.push( pair<int,int>(g[now.fi].edge[j], now.se+1) );\n      }\n    }\n\n    int tt = 0;\n    for(int i=0; i<100; ++i)\n      if(tt < dist[i]) tt = dist[i];\n    eccen[k] = tt;\n  }\n\n  int maxm = 0;\n  for(int i=0; i<100; ++i)\n    maxm = max(eccen[i], maxm);\n  return maxm;\n}\n\nint main() {\n  int n,a,b;\n  while(cin>>n, n) {\n    Graph g(100);\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n    }\n    cout<<diam(g,n)+1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,q[z*z],l[z],la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100];\nint D[100];\n\nint size(int m)\n{\n    int r=1;\n    for(int i=0;i<100;i++){\n        if(G[m][i]&&!D[i]){\n            D[i]=1;\n            r=max(r,1+size(i));\n            D[i]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(G,0,sizeof(G));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1][b-1]=G[b-1][a-1]=1;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,size(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nint in_num[101];\nint tmp_depth;\nvector<int> G[101],GROUP[101];\n\nint boss[101],height[101];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 1; i <= 100; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid recursive(bool visited[101],int node_id,int depth,int group_id){\n\ttmp_depth = max(tmp_depth,depth);\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(visited[G[node_id][i]])continue;\n\n\t\tbool next_visited[101];\n\t\tfor(int k = 0; k < GROUP[group_id].size(); k++)next_visited[GROUP[group_id][k]] = visited[GROUP[group_id][k]];\n\t\tnext_visited[G[node_id][i]] = true;\n\t\trecursive(next_visited,G[node_id][i],depth+1,group_id);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tin_num[i] = 0;\n\t\tG[i].clear();\n\t\tGROUP[i].clear();\n\t}\n\n\tinit();\n\n\tint from,to;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[to]++;\n\t\tin_num[from]++;\n\t\tunite(from,to);\n\t}\n\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(in_num[i] == 0)continue;\n\t\tGROUP[get_boss(i)].push_back(i);\n\t}\n\n\tint max_depth = 1,min_in_num;\n\tbool visited[101];\n\tfor(int i = 1; i <= 100; i++){\n\t\tif(GROUP[i].size() == 0 || GROUP[i].size() <= max_depth)continue;\n\n\t\tmin_in_num = BIG_NUM;\n\t\tfor(int k = 0; k < GROUP[i].size(); k++){\n\t\t\tmin_in_num = min(min_in_num,in_num[GROUP[i][k]]);\n\t\t}\n\n\t\tfor(int k = 0; k < GROUP[i].size(); k++){\n\t\t\tif(in_num[GROUP[i][k]] == min_in_num){\n\t\t\t\tfor(int p = 0; p < GROUP[i].size(); p++)visited[GROUP[i][p]] = false;\n\t\t\t\tvisited[GROUP[i][k]] = true;\n\t\t\t\ttmp_depth = 0;\n\t\t\t\trecursive(visited,GROUP[i][k],1,i);\n\t\t\t\tmax_depth = max(max_depth,tmp_depth);\n\t\t\t\tif(max_depth == GROUP[i].size()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_depth);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nchar c[102][102],f[105];\nint ans;\n\nvoid dfs(int cr,int n){\n\tint i,j,ff;\n\tff=0;\n\tfor(i=1;i<=100;i++){\n\t\tif(c[cr][i]==1 && f[i]==0){\n\t\t\tff=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,n+1);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0)ans=MAX(ans,n);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\t\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tc[a][b]=c[b][a]=1;\n\t\t}\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=1;i<=100;i++){\n\t\t\t//x=0;\n\t\t\t//for(j=1;j<=100;j++)if(c[i][j]==1)x++;\n\t\t\t//if(x==1){\n\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\tf[i]=1;\n\t\t\t\tdfs(i,1);\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int N = 110;\n\nvector< vector<int> > d(N, vector<int>() );\nint ans = 2;\n\nvoid dfs(int now, bool visited[], int sum){\n    sum++;\n    int dsize = d[now].size();\n    REP(i, dsize){\n        int next = d[now][i];\n        if(!visited[next]){\n            visited[next] = true;\n            dfs(next, visited, sum);\n            visited[next] = false;\n        }\n    }\n    ans = max(ans, sum);\n}\n\nint main(){\n    int n;\n    vector<int> v;\n    while(cin >>n && n){\n        ans = 2;\n        REP(i, N) d[i].clear();\n        REP(i, n){\n            int a, b; cin >>a >>b;\n            d[a].push_back(b);\n            d[b].push_back(a);\n            if(find(v.begin(), v.end(), a) == v.end()) v.push_back(a);\n            if(find(v.begin(), v.end(), b) == v.end()) v.push_back(b);\n        }\n        int vsize = v.size();\n        REP(i, vsize){\n            bool visited[N];\n            memset(visited, 0, sizeof(visited));\n            visited[v[i]] = true;\n            dfs(v[i], visited, 0);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\n\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(int i = 1;i < 101;i++){\n      for(int j = 0;j < rings.size();j++){\n\tif(neib[rings[j]].size() == i){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      bool fin = true;\n      for(int j = 0;j < rings.size();j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = false;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\nvector<int> vec[101];\nbool ch[101]={};\nbool visited[101]={};\nint dp[101]={};\nint maxx = -1;\nint maxNODE = -1;\n\n\nvoid DFS(int i,int val){\n    if(val > maxx)maxx = val;\n    dp[i] = max(dp[i],val);\n    int len = vec[i].size();\n    for (int k=0; k<len; k++) {\n        if(!ch[vec[i][k]]){\n            visited[vec[i][k]] = true;\n            ch[vec[i][k]] = true;\n            DFS(vec[i][k],val+1);\n            ch[vec[i][k]] = false;\n        }\n    }\n}\n\nint main(){\n    maxx = -1;\n    maxNODE = -1;\n    int n,a,b;\n    scanf(\"%d\",&n);\n    if(n == 0)return 0;\n    for (int i=0; i<n; i++) {\n        scanf(\"%d %d\",&a,&b);\n        vec[a].push_back(b);\n        vec[b].push_back(a);\n        if(a>b)if(maxNODE < a)maxNODE = a;\n        if(a<b)if(maxNODE < b)maxNODE = b;\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(!visited[i]){\n            visited[i] = true;\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n        }\n    }\n    for (int i=1; i<=maxNODE; i++) {\n        if(maxx == dp[i]){\n            ch[i] = true;\n            DFS(i,1);\n            ch[i] = false;\n            break;\n        }\n    }\n    printf(\"%d\\n\",maxx);\n    for (int i=1; i<=maxNODE; i++) {\n        visited[i] = false;\n        vec[i].clear();\n    }\n    main();\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> to[100];\nbool used[100];\n\nvoid addEdge(int a, int b) {\n    to[a].push_back(b);\n    to[b].push_back(a);\n}\n\nint dfs(int v) {\n    int ret = 1;\n    used[v] = true;\n    for (int i=0; i<(int)to[v].size(); ++i) {\n        if ( ! used[to[v][i]]) {\n            ret = max(ret, 1 + dfs(to[v][i]));\n        }\n    }\n    used[v] = false;\n    return ret;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        fill(to, to+100, vector<int>());\n        int a, b;\n        for (int i=0; i<n; ++i) {\n            cin >> a >> b;\n            --a, --b;\n            addEdge(a, b);\n        }\n        int ret = 0;\n        for (int i=0; i<100; ++i) {\n            memset(used, false, sizeof used);\n            ret = max(ret, dfs(i));\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint solve(int idx, const vector<vector<int> >& path, vector<int>& visited, int cnt)\n{\n\tif (visited[idx])\n\t\treturn cnt;\n\n\tint ans = cnt;\n\tvisited[idx] = 1;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tif (!visited[i] && path[idx][i])\n\t\t\tans = max(ans, solve(i, path, visited, cnt+1));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tfreopen(\"0508.txt\", \"r\", stdin);\n\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tvector<vector<int> > path(100, vector<int>(100, 0));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tpath[a][b] = path[b][a] = 1;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tans = max(ans, solve(i, path, vector<int>(100, 0), 1));\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nvector<int> a[100];\nbool b[100];\nint fi(int p){\n\tint i;\n\tint mx=0;\n\tfor(i=0;i<(int)a[p].size();++i){\n\t\tif(b[a[p][i]])\n\t\t\tcontinue;\n\t\tb[a[p][i]]=true;\n\t\tmx=max(mx,fi(a[p][i])+1);\n\t\tb[a[p][i]]=false;\n\t}\n\treturn mx;\n}\nint main(){\n\tint i;\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;++i)\n\t\t\ta[i].clear();\n\t\tfor(i=0;i<n;++i){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\t--p;\n\t\t\t--q;\n\t\t\ta[p].push_back(q);\n\t\t\ta[q].push_back(p);\n\t\t}\n\t\tint mx=0;\n\t\tfor(i=0;i<n;++i)\n\t\t\tmx=max(mx,fi(i));\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint g[100][100];\nint num[100];\nbool f[100];\nint tmp[100];\nint k;\nint d;\nint dm;\n\nint solve(int pos){\n  int ans = 1;\n  f[pos] = true;\n  dm = max(dm, ++d);\n  REP(i,num[pos]){\n    int next = g[pos][i];\n    if(f[next]) continue;\n    if(next < k && tmp[next] + d <= dm)\n      continue;\n    ans = max(ans, 1 + solve(next));\n  }\n  f[pos] = false;\n  d--;\n  return ans;\n}\n\nint main(){\n  while(n = getInt()){\n    dm = 0;\n    REP(i,100) {\n      f[i] = false;\n      num[i] = 0;\n    }\n    REP(i,n){\n      int a = getInt()-1;\n      int b = getInt()-1;\n      g[a][num[a]++] = b;\n      g[b][num[b]++] = a;\n    }\n    int ans = 0;\n    REP(i,100){\n      k = i;\n      d = 0;\n      tmp[i] = solve(i);\n      ans = max(ans, tmp[i]);\n    }\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++) \n#define MAX(a,b) (((a)>=(b))?(a):(b))\nvector<int> point,edge[100];\nbool visit[100];\nint solve(int n) {\n\tint mx=0;\n\trep(i,edge[n].size()) {\n\t\tif(!visit[edge[n][i]]) {\n\t\t\tvisit[edge[n][i]]=true;\n\t\t\tmx=MAX(mx,solve(edge[n][i])+1);\n\t\t\tvisit[edge[n][i]]=false;\n\t\t}\n\t}\n\treturn mx;\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\trep(i,100) edge[i].clear();\n\t\trep(i,n) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tif(find(point.begin(),point.end(),a)==point.end()) point.push_back(a);\n\t\t\tif(find(point.begin(),point.end(),b)==point.end()) point.push_back(b);\n\t\t\tedge[a-1].push_back(b-1);\n\t\t\tedge[b-1].push_back(a-1);\n\t\t}\n\t\tint mx=0;\n\t\trep(i,point.size()) {\n\t\t\tvisit[point[i]]=true;\n\t\t\tmx=MAX(mx,solve(point[i])+1);\n\t\t\tvisit[point[i]]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nvi len;\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tlen.pb(sz(lis[i]));\n\t\t}\n\t\tsort(len.begin(),len.end());\n\t\tint k=len[sz(len)/19*15];\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tif(sz(lis[i])<=k)\n\t\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\nset<int> vertex;\nmap< int, vector<int> > edge;\n\nint dfs(int v, bitset<101> visited, int depth) {\n    int result = depth;\n    visited.set(v);\n    for(vector<int>::iterator i=edge[v].begin(); i!=edge[v].end(); i++) {\n        if(visited.test(*i)) continue;\n        result = max(result, dfs(*i, visited, depth+1));\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(set<int>::iterator i=vertex.begin(); i!=vertex.end(); i++) {\n        result = max(result, dfs(*i, bitset<101>(0), 1));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            vertex.insert(--u);\n            vertex.insert(--v);\n            edge[u].push_back(v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nstruct chain {int a, b; };\nint n;\nset<int> se;\ndeque<int> deq;\nchain c[100];\nbool used[100];\nint cnt() {\n    se.clear();\n    for (int i=0; i<deq.size(); i++) se.insert(deq[i]);\n    return se.size();\n}\nint dfs() {\n    int res=cnt();\n    int s=deq[0], t=deq[deq.size()-1];\n//    for (int i=0; i<res; i++) printf(\"%d%c\",deq[i],i==res-1?'\\n':' ');\n    for (int i=0; i<n; i++) {\n        if (used[i]) continue;\n        if (t==c[i].a&&se.find(c[i].b)==se.end()) {\n            used[i]=true;\n            deq.push_back(c[i].b);\n            res=max(res,dfs());\n            deq.pop_back();\n            used[i]=false;\n        } else if (t==c[i].b&&se.find(c[i].a)==se.end()) {\n            used[i]=true;\n            deq.push_back(c[i].a);\n            res=max(res,dfs());\n            deq.pop_back();\n            used[i]=false;\n        }\n        if (s==c[i].a&&se.find(c[i].b)==se.end()) {\n            used[i]=true;\n            deq.push_front(c[i].b);\n            res=max(res,dfs());\n            deq.pop_front();\n            used[i]=false;\n        } else if (s==c[i].b&&se.find(c[i].a)==se.end()) {\n            used[i]=true;\n            deq.push_front(c[i].a);\n            res=max(res,dfs());\n            deq.pop_front();\n            used[i]=false;\n        }\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        memset(used, 0, sizeof(used));\n        for (int i=0; i<n; i++) {\n            scanf(\"%d%d\",&c[i].a,&c[i].b);\n        }\n        int res=0;\n        for (int i=0; i<n; i++) {\n            used[i]=true;\n            deq.push_back(c[i].a); deq.push_back(c[i].b);\n            res=max(res, dfs());\n            deq.pop_back(); deq.pop_back();\n            used[i]=false;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <bitset>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nvector<vector<int> > G(100);\ntypedef bitset<100> bs;\nmap<bs, int> dp;\n\nnamespace std {\n    bool operator<(const bs& a, const bs& b){\n        rep(i, 100){\n            if(a[i] != b[i]) return a[i] < b[i];\n        }\n        return false;\n    }\n}\n\nint dfs(int v, bs vis){\n    vis[v] = true;\n    int res = 1;\n    rep(i, G[v].size()){\n        int to = G[v][i];\n        if(!vis[to]){\n            res = max(res, dfs(to, vis) + 1);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 100) G[i].clear();\n        rep(i, n){\n            int a, b; cin >> a >> b;\n            G[a - 1].push_back(b - 1);\n            G[b - 1].push_back(a - 1);\n        }\n        bs init;\n        int ans = 1;\n        rep(i, 100){\n            ans = max(dfs(i, init), ans);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\nbool f[100];\n\nint search(int now)\n{\n\t//vis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tvis[now] = true;\n\t\tif (!vis[v[now][i]]) res = max(res, search(v[now][i]) + 1);\n\t\tvis[now] = false;\n\t}\n\t\n\t//vis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(f, 0, sizeof(f));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t\t\n\t\t\tf[a] = true;\n\t\t\tf[b] = true;\n\t\t}\n\t\t/*\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t*/\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t//if (v[i].size() - mini <= 1){\n\t\t\tif (f[i]){\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t}\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n\nint rec(int pos)\n{\n\tint ret = used[pos] = 1;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tif(!used[G[pos][i]])\n\t\t{\n\t\t\tret = max(ret, rec(G[pos][i]) + 1);\n\t\t}\n\t}\n\n\tused[pos] = 0;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tused[i] = rings[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[i]=false;\n            solve(i,len+1);\n            points[i]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<1;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,q[z*10],l[z],la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\nbool f[100];\n\nint search(int now)\n{\n\t//vis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tvis[now] = true;\n\t\tif (!vis[v[now][i]]) res = max(res, search(v[now][i]) + 1);\n\t\tvis[now] = false;\n\t}\n\t\n\t//vis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(f, 0, sizeof(f));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t\t\n\t\t\tf[a] = true;\n\t\t\tf[b] = true;\n\t\t}\n\t\t/*\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t*/\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\t//if (v[i].size() - mini <= 1){\n\t\t\tif (f[i]){\n\t\t\t\tmaxi = max(maxi, search(i));\n\t\t\t}\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100];\nbool used[100];\nint max(int a,int b){return a>b?a:b;}\nint dfs(int f,int t){\n\tint i;\n\tint m=0;\n\tfor(i=0;i<e[t].size();i++){\n\t\tif(e[t][i]==f)continue;\n\t\tif(!used[e[t][i]]){\n\t\t\tused[t]=true;\n\t\t\tm=max(m,dfs(t,e[t][i]));\n\t\t\tused[t]=false;\n\t\t}\n\t}\n\treturn m+1;\n}\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tfor(i=0;i<100;i++)e[i].clear();\n\tfor(i=0;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tint ans=0;\n\tfor(i=0;i<100;i++)used[i]=false;\n\tfor(i=0;i<100;i++){\n\t\tfor(j=0;j<e[i].size();j++){\n\t\t\tused[i]=true;\n\t\t\tans=max(ans,dfs(i,e[i][j])+1);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint comp(const void *p,const void *q){\n\treturn *(int *)p-*(int *)q;\n}\nchar c[102][102],f[105];\nint ans;\n\nvoid dfs(int cr,int n){\n\tint i,j,ff;\n\tff=0;\n\tfor(i=1;i<=100;i++){\n\t\tif(c[cr][i]==1 && f[i]==0){\n\t\t\tff=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,n+1);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0)ans=MAX(ans,n);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\t\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tc[a][b]=c[b][a]=1;\n\t\t}\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=1;i<=100;i++){\n\t\t\tx=0;\n\t\t\tfor(j=1;j<=100;j++)if(c[i][j]==1)x++;\n\t\t\tif(x>=1){\n\t\t\t\tmemset(f,0,sizeof(f));\n\t\t\t\tf[i]=1;\n\t\t\t\tdfs(i,1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N, A, B, used[100], rings[100], G[100][199];\n\nint rec(int pos)\n{\n\tint ret = 1; used[pos] = 1;\n\n\tfor(int i = 0; i < rings[pos]; i++)\n\t{\n\t\tif(!used[G[pos][i]])\n\t\t{\n\t\t\tret = max(ret, rec(G[pos][i]) + 1);\n\t\t}\n\t}\n\n\tused[pos] = 0;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N, A, B;\n\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &N);\n \n\t\tif(N == 0) { break; }\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tused[i] = 0; rings[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &A); A--;\n\t\t\tscanf(\"%d\", &B); B--;\n\n\t\t\tG[A][rings[A]] = B; rings[A]++;\n\t\t\tG[B][rings[B]] = A; rings[B]++;\n\t\t}\n\n\t\tint nodes = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(rings[i])\n\t\t\t{\n\t\t\t\tnodes++;\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tret = max(ret, rec(i));\n\n \t\t\tif(ret == nodes) break;\n\t\t}\n \n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool edges[101][101];\nbool ok[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < 101; i++){\n\t\tint to=i;\n\t\tif(edges[s][to]){\n\t\t\tedges[s][to]=false;\n\t\t\tedges[to][s]=false;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tedges[s][to]=true;\n\t\t\tedges[to][s]=true;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\tmemset(edges,0,sizeof(edges));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\tmemset(ok,0,sizeof(ok));\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>a>>b;\n\t\t\tedges[a][b]=true;\n\t\t\tedges[b][a]=true;\n\t\t\tok[a]=ok[b]=true;\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(ok[i])\n\t\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tprintf(\"%d\\n\",maxRes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n#define MAX 105\nvector<int> G[MAX];\nint searched[MAX];\nint point[MAX];\n\nint dfs(int node){\n  stack<int> s;\n  int ret=0;\n  s.push(node);\n  point[node]=1;\n  while(!s.empty()){\n    int now_s=s.top(); s.pop();\n    searched[now_s]=true;\n    \n    bool done=0;\n    for(int i=0; i<G[now_s].size(); i++){\n      int nex=G[now_s][i];\n      if(searched[nex]) continue;\n      s.push(nex);\n      point[nex]=max(point[now_s]+1,point[nex]);\n      done=true;\n    }\n    if(!done) ret=max(ret,point[now_s]);\n  }\n  return ret;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n&&n){\n    for(int i=0; i<=101; i++) G[i].clear();\n    for(int i=0; i<n; i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n      \n    int ans_max=0;\n    for(int i=0; i<=101; i++){\n      for(int j=0; j<=101; j++){\n        searched[j]=0;\n        point[j]=0;\n      }\n      ans_max=max(dfs(i),ans_max);\n    }\n      \n    cout<<ans_max<<en\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> e[111];\n\nbool f[111];\nint solve(int m){\n  int ret = 0;\n  for(int i = 0; i < (int)e[m].size(); i++){\n    if(f[e[m][i]]) continue;\n    f[e[m][i]] = true;\n    ret = max(ret,solve(e[m][i]));\n    f[e[m][i]] = false;\n  }\n  return ret + 1;\n}\n\nint main(void){\n  while(cin >> n && n){\n    for(int i = 1; i <= 100; i++) e[i].clear();\n    for(int i = 0; i < n; i++){\n      int a,b;\n      cin >> a >> b;\n      e[a].push_back(b);\n      e[b].push_back(a);\n    }\n\n    int res = 0;\n    for(int i = 1; i <= 100; i++){\n      memset(f,false,sizeof(f));\n      f[i] = true;\n      res = max(res,solve(i));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "wad\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool isPassedEdge[101][101];\nbool ok[101];\nvector<int>G[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < G[s].size(); i++){\n\t\tint to=G[s][i];\n\t\tif(!isPassedEdge[s][to]){\n\t\t\tisPassedEdge[s][to]=true;\n\t\t\tisPassedEdge[to][s]=true;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tisPassedEdge[s][to]=false;\n\t\t\tisPassedEdge[to][s]=false;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\tmemset(isPassedEdge,0,sizeof(isPassedEdge));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\tmemset(ok,0,sizeof(ok));\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>a>>b;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t\tok[a]=ok[b]=true;\n\t\t}\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(ok[i])\n\t\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tcout<<maxRes<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nbool d[101][101];\n//vector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\nbool isAppeared[101];\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<101; i++){\n\t\tif(d[s][i]&&!passed[i]){\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,depth+1);\n\t\t\tpassed[i]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\t//fill(passed,passed+101,false);\n\t\t//fill(isAppeared,isAppeared+101,false);\n\t\tmemset(passed,0,sizeof(passed));\n\t\tmemset(isAppeared,0,sizeof(isAppeared));\n\t\tmemset(d,0,sizeof(d));\n\t\t//\tfor(int i = 0; i < 101; i++)\n\t\t\t//G[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tisAppeared[a]=true;\n\t\t\tisAppeared[b]=true;\n\t\t\td[a][b]=true;\n\t\t\td[b][a]=true;\n\t\t\t//G[a].push_back(b);\n\t\t\t//G[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(!isAppeared[i])\n\t\t\t\tcontinue;\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nmap< int, vector<int> > edge;\nmap< int, vector<int> >::iterator mit;\nset<int> visited;\n\nint dfs(int vertex) {\n    int result = visited.size() + 1;\n    for(int i=0; i<edge[vertex].size(); i++) {\n        if(visited.count(edge[vertex][i])) continue;\n        visited.insert(vertex);\n        result = max(result, dfs(edge[vertex][i]));\n        visited.erase(vertex);\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(mit=edge.begin(); mit!=edge.end(); mit++) {\n        visited.clear();\n        visited.insert(mit->first);\n        result = max(result, dfs(mit->first));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            edge[--u].push_back(--v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <bitset>\n#include <map>\n#include <fstream>\nusing namespace std;\n\n#define MSG(a) cout<< #a << \" = \" << a <<endl;\n\nconst int MAX_V = 100;\nconst int INF = 100000;\n\nbitset<MAX_V> bmain;\n\nstruct edge\n{\n\tint num;\n\tedge(int n):num(n){};\n\tvector<edge*> es;\n};\n\nint search(vector<edge> edge, bitset<MAX_V> flags, int pos);\n\nint main()\n{\n\t//ifstream ifs(\"data.txt\");\n\n\tint n;\n\twhile( cin >> n && n)\n\t{\n\t\tvector<edge> edges;\n\t\tbmain.reset();\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tedges.push_back(edge(i));\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\t\n\t\t\tedges[a].es.push_back(&edges[b]);\n\t\t\tedges[b].es.push_back(&edges[a]);\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t{\n\t\t\tif(!bmain[i]){\n\t\t\t\tbitset<MAX_V> flags; flags[i] = true;\n\t\t\t\tres = max(res, search(edges, flags, i));\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\t//cin.sync(); cin.get();\n}\n\nint search(vector<edge> edges, bitset<MAX_V> flags, int pos)\n{\n\tif(edges[pos].es.size() == 0)\n\t{\n\t\tbmain |= flags;\n\t\treturn 1;\n\t}\n\tint res = 0;\n\n\tfor(int i = 0; i < edges[pos].es.size(); i++)\n\t{\n\t\tint index = edges[pos].es[i]->num;\n\t\tif(!flags[index])\n\t\t{\n\t\t\tflags[index] = true;\n\t\t\tres = max(res, 1 + search(edges, flags, index));\n\t\t\tflags[index] = false;\n\t\t}\n\t}\n\treturn max(res, 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool edges[101][101];\nbool ok[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < 101; i++){\n\t\tint to=i;\n\t\tif(edges[s][to]){\n\t\t\tedges[s][to]=false;\n\t\t\tedges[to][s]=false;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tedges[s][to]=true;\n\t\t\tedges[to][s]=true;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\n// SnodeÌ\nint dim[101];\n\nset<int> graph;\nconst int INF=100000000;\n\n// eOtÌÅ¬ðàÂnodeðßé\nvoid pass(int s){\n\tif(isPassedNode[s])\n\t\treturn;\n\tisPassedNode[s]=true;\n\tgraph.insert(s);\n\tfor(int i = 0; i < 101; i++){\n\t\tif(edges[s][i]){\n\t\t\tpass(s);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\tmemset(edges,0,sizeof(edges));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\tmemset(ok,0,sizeof(ok));\n\t\tmemset(dim,0,sizeof(dim));\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedges[a][b]=true;\n\t\t\tedges[b][a]=true;\n\t\t\tok[a]=ok[b]=true;\n\t\t}\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tint cnt=0;\n\t\t\tfor(int j = 0; j < 101; j++){\n\t\t\t\tif(edges[i][j])\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tdim[i]=cnt;\n\t\t}\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tgraph.clear();\n\t\t\tif(!isPassedNode[i])\n\t\t\t\tpass(i);\n\n\t\t\tint minDim=INF;\n\t\t\tvector<int> nodes;\n\t\t\tfor(set<int>::iterator it = graph.begin(); it !=graph.end(); it++){\n\t\t\t\tif(dim[*it]!=0){\n\t\t\t\t\tif(minDim>dim[*it]){\n\t\t\t\t\t\tminDim=dim[*it];\n\t\t\t\t\t\tnodes.clear();\n\t\t\t\t\t\tnodes.push_back(*it);\n\t\t\t\t\t}\n\t\t\t\t\telse if(minDim==dim[*it]){\n\t\t\t\t\t\tnodes.push_back(*it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < nodes.size(); j++){\n\t\t\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\t\t\tmaxRes=max(maxRes,dfs(nodes[j]));\n\t\t\t}\n\t\t}\n\n\t\t//for(int i = 0; i < 101; i++){\n\t\t//\tif(ok[i])\n\t\t//\t\tmaxRes=max(maxRes,dfs(i));\n\t\t//}\n\t\tprintf(\"%d\\n\",maxRes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nvector<int> G[100];\nbool visited[100];\n\nint visit(int v){\n\tint res = 0;\n\trep(i, (int)G[v].size()){\n\t\tif(!visited[G[v][i]]){\n\t\t\tvisited[G[v][i]] = true;\n\t\t\tres = max(res, 1 + visit(G[v][i]));\n\t\t\tvisited[G[v][i]] = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tint a, b;\n\twhile(cin >> n && n){\n\t\trep(i, 100) G[i].clear();\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trep(i, n){\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\n\t\tint res = 0;\n\t\t\n\t\trep(i, 100){\n\t\t\tvisited[i] = true;\n\t\t\tres = max(res, visit(i));\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << res + 1<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\ntypedef pair<int, int> Res;\n#define pii pair<int,int> \n#define fi first\n#define se second\nconst int INF = 1<<30;\n\nbool visited[100];\nint dist[100];\nint ecc[100];\n\nint diameter(const Graph &g, int n) {\n\n  for(int k=0; k<n; ++k) {\n    pii s = pii(k,0);\n    stack< pii > st;\n    for(int i=0; i<n; ++i) visited[i] = false;\n    memset(dist, 0, sizeof(dist));\n    st.push(s);\n    while(!st.empty()) {\n      pii now = st.top(); st.pop();\n      if(visited[now.fi]) continue;\n      visited[now.fi] = true;\n      dist[now.fi] = now.se;\n      for(int i=0; i<g[now.fi].edge.size(); ++i) {\n\tdist[g[now.fi].edge[i]] = max(dist[g[now.fi].edge[i]], now.se+1);\n\tif(visited[g[now.fi].edge[i]]) continue;\n\tst.push( pii(g[now.fi].edge[i],now.se+1) );\n      }\n    }\n    int tt = 0;\n    for(int i=0; i<n; ++i)\n      if(tt < dist[i]) tt = dist[i];\n\n    ecc[k] = tt;\n  }\n\n  int maxm = 0;\n  for(int i=0; i<n; ++i)\n    maxm = max(ecc[i], maxm);\n  return maxm;\n}\n\nint main() {\n  int n,a,b;\n  while(cin>>n, n) {\n    Graph g(n);\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n    }\n    cout<<diameter(g,n)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint ans;\n\nvoid dfs(vector<vector<int>>& G, bitset<101>& searched, int p, int cost) { // p:position\n    bool updated = false;\n    for(int i=0; i<G[p].size(); ++i) {\n        int next = G[p][i];\n        if(!searched[next]) {\n            searched[next] = true;\n            dfs(G, searched, next, cost+1);\n            searched[next] = false;\n            updated = true;\n        }\n    }\n    if(!updated) ans = max(ans, cost);\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<vector<int>> G(101);\n        ans = 0;\n\n        for(int i=0; i<n; ++i) {\n            int a, b;\n            cin >> a >> b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        for(int i=1; i<n; ++i) {\n            bitset<101> searched(0);\n            searched[i] = true;\n            dfs(G, searched, i, 1);\n        }\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool edges[101][101];\nbool ok[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < 101; i++){\n\t\tint to=i;\n\t\tif(edges[s][to]){\n\t\t\tedges[s][to]=false;\n\t\t\tedges[to][s]=false;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tedges[s][to]=true;\n\t\t\tedges[to][s]=true;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\t//memset(edges,0,sizeof(edges));\n\t\t//memset(isPassedNode,0,sizeof(isPassedNode));\n\t\t//memset(ok,0,sizeof(ok));\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedges[a][b]=true;\n\t\t\tedges[b][a]=true;\n\t\t\t//ok[a]=ok[b]=true;\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++){\n//\t\t\tif(ok[i])\n\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tprintf(\"%d\\n\",maxRes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n\n#define INF INT_MAX\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\nint table[100][100];\n\nint n;\n\nint solve(int start) {\n  queue<tuple<int, set<int>, int>> que; //current_pos, history, distance\n  que.push(make_tuple(start, set<int>(), 0));\n\n  int max_dist = -1;\n  while(!que.empty()) {\n    auto a = que.front();\n    que.pop();\n\n    auto cur_pos  = get<0>(a);\n    auto &history = get<1>(a);\n    auto dist     = get<2>(a);\n\n    int push_num = 0;\n    rep(i, 100) {\n      if(table[cur_pos][i] == 0 || history.find(i) != history.end()) continue;\n\n      auto new_hist = history;\n      new_hist.insert(cur_pos);\n\n      que.push(make_tuple(i, new_hist, dist + 1));\n      push_num++;\n    }\n    if(push_num == 0) max_dist = max(max_dist, dist);\n  }\n\n  return max_dist;\n}\n\nint main() {\n  while(true) {\n    cin >> n;\n    if(n == 0) break;\n\n    memset(table, 0, 100 * 100 * sizeof(int));\n\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      table[a][b] = table[b][a] = 1;\n    }\n\n    int ans = 0;\n\n    rep(i, 100) {\n      bool indep = true;\n      rep(j, 100) {\n        if(table[i][j] != 0) {\n          indep = false;\n          break;\n        }\n      }\n      if(indep) continue;\n\n      ans = max(solve(i), ans);\n    }\n\n    cout << ans + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int MAX = 100;\n\nbool visited[MAX];\n\nint dfs(int v, const std::vector<std::vector<int>> &G)\n{\n    if (visited[v]) {\n        return 0;\n    }\n    visited[v] = 1;\n    int res = 0;\n    for (int to : G[v]) {\n        res = std::max(res, dfs(to, G) + 1);\n    }\n    return res;\n\n}\n\nint main()\n{\n    int N;\n    while (1) {\n        std::cin >> N;\n        if (N == 0) {\n            break;\n        }\n        std::vector<std::vector<int>> G(N);\n        for (int i = 0; i < N; i++) {\n            int a, b;\n            std::cin >> a >> b;\n            a--; b--;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n    \n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            std::fill(visited, visited + MAX, 0);\n            res = std::max(res, dfs(i, G));\n        }\n    \n        std::cout << res << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> g[100];\nbool used[100];\n\nint dfs(int now){\n    int res = 0;\n    used[now] = true;\n    for(auto &nxt : g[now]){\n        if(!used[nxt]){\n            res = max(res, dfs(nxt));\n        }\n    }\n    used[now] = false;\n    return res+1;\n}\n\nint main(){\n    while(cin >> n, n){\n        for(int i=0;i<100;i++) g[i].clear();\n        for(int i=0;i<n;i++){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        int ans = 0;\n        for(int i=0;i<100;i++){\n            ans = max(ans, dfs(i));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[i]=false;\n            solve(i,len+1);\n            points[i]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a][b]=table[b][a]=true;\n        }\n        for(int i=0;i<100;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nconst int MAX = 105;\nint n, a, b;\n\nvint graph[MAX];\n\nint res;\nbool used[MAX];\nvoid dfs(int v, int len) {\n    chmax(res, len);\n    \n    for (int i = 0; i < graph[v].size(); ++i) {\n        int to = graph[v][i];\n        if (used[to]) continue;\n        \n        used[to] = true;\n        dfs(to, len+1);\n        used[to] = false;\n    }\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < MAX; ++i) graph[i].clear();\n        \n        for (int i = 0; i < n; ++i) {\n            cin >> a >> b;\n            --a; --b;\n            graph[a].PB(b); graph[b].PB(a);\n        }\n        \n        res = 1;\n        for (int i = 0; i < MAX; ++i) {\n            used[i] = true;\n            dfs(i, 1);\n            used[i] = false;\n        }\n        \n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <bitset>\n#include <map>\n#include <fstream>\nusing namespace std;\n\n#define MSG(a) cout<< #a << \" = \" << a <<endl;\n\nconst int MAX_V = 100;\nconst int INF = 100000;\n\nstruct edge\n{\n\tint num;\n\tedge(int n):num(n){};\n\tvector<edge*> es;\n};\n\nint search(vector<edge> edge, bitset<MAX_V> flags, int pos);\n\nint main()\n{\n\t//ifstream ifs(\"data.txt\");\n\n\tint n;\n\twhile( cin >> n && n)\n\t{\n\t\tvector<edge> edges;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tedges.push_back(edge(i));\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\t\n\t\t\tedges[a].es.push_back(&edges[b]);\n\t\t\tedges[b].es.push_back(&edges[a]);\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t{\n\t\t\tbitset<MAX_V> flags; flags[i] = true;\n\t\t\tres = max(res, search(edges, flags, i));\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\t//cin.sync(); cin.get();\n}\n\nint search(vector<edge> edges, bitset<MAX_V> flags, int pos)\n{\n\tif(edges[pos].es.size() == 0) return 1;\n\tint res = 0;\n\n\tfor(int i = 0; i < edges[pos].es.size(); i++)\n\t{\n\t\tint index = edges[pos].es[i]->num;\n\t\tif(!flags[index])\n\t\t{\n\t\t\tflags[index] = true;\n\t\t\tres = max(res, 1 + search(edges, flags, index));\n\t\t\tflags[index] = false;\n\t\t}\n\t}\n\treturn max(res, 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j) for(int i = 0; i < (j); i++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nvvi G = vvi(100, vi(100, -1));\nbool memo[101];\nint func(int s, int n) {\n\tif(memo[s]) return n;\n\tmemo[s] = true;\n\tint ret = n;\n\trep(i, G[s].size()) {\n\t\tret = max(ret, func(G[s][i], n + 1));\n\t}\n\treturn ret;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\trep(i,n) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint ans = -1;\n\trep(i, G.size()) {\n\t\tans = max(ans, func(i, 0));\n\t\tmemset(memo, 0, sizeof(memo));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,q[z],l[z],la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101]={};\n   int N;\n   int Ans = 0;\n  void DFS(int n,int len){\n      Ans = max(Ans,len);\n    bool Vis = false;\n   int S = G[n].size();\n   for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis = true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int main(){\n      do{\n   for(int i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(int i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(int i=1;i<=N;i++){\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n   }\n   printf(\"%d\\n\",Ans);\n      }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n using namespace std;\n  vector<int> G[101];\n  bool V[101]={};\n   int N;\n   int Ans = 0;\n  void DFS(int n,int len){\n      Ans = max(Ans,len);\n    bool Vis = false;\n   int S = G[n].size();\n   for(int i=0;i<S;i++){\n    if(!V[G[n][i]]){\n        Vis = true;\n        V[G[n][i]] = true;\n        DFS(G[n][i],len+1);\n        V[G[n][i]] = false;\n    }\n   }\n   return;\n  }\n  int main(){\n      do{\n   for(int i=0;i<101;i++){\n    G[i].clear();\n    V[i] = false;\n   }\n   Ans = 0;\n   scanf(\"%d\",&N);\n   if(N==0)break;\n   for(int i=0;i<N;i++){\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    G[A].push_back(B);\n    G[B].push_back(A);\n   }\n\n   for(int i=1;i<=100;i++){\n    V[i] = true;\n    DFS(i,1);\n    V[i] = false;\n   }\n   printf(\"%d\\n\",Ans);\n      }while(true);\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nbool vis[101] = {};\nint ans;\nvector<int> v[101];\n\nvoid dfs(int x, int l){\n    vis[x] = true;\n    ans = max(ans, l);\n    for(int j : v[x]){\n        if(!vis[j]) dfs(j, l+1);\n    }\n    vis[x] = false;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        for(int i = 1; i <= 100; i++)   v[i].clear();\n        for(int i = 1; i <= n; i++){\n            int a, b;\n            cin >> a >> b;\n            v[a].push_back(b);\n            v[b].push_back(a);\n        }\n        ans = 0;\n        for(int i = 1; i <= 100; i++){\n            dfs(i, 1);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,ans,u[100];vector<vector<int> > ad;\nvoid dfs(int c,int m){\n\tif(ans<m)ans=m; int s=ad[c].size(),t;\n\trep(i,s){\n\t\tt=ad[c][i];\n\t\tif(!u[t])u[t]=1,dfs(t,m+1),u[t]=0;\n\t}\n}\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tad.clear();ad.resize(100);\n\t\trep(i,n){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b); a--,b--;\n\t\t\tad[a].push_back(b),ad[b].push_back(a);\n\t\t}\n\t\tans=1;rep(i,100)u[i]=0;\n\t\trep(i,100)if(!ad[i].empty()){\n\t\t\tu[i]=1;dfs(i,1);u[i]=0;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n\nint N, A, B, used[100], rings[100]; vector<int> G[100];\n \nint rec(int pos)\n{\n    used[pos] = true; int ret = 1;\n     \n    for(int i = 0; i < rings[pos]; i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i]) + 1);\n        }\n    }\n     \n    used[pos] = false;\n     \n    return ret;\n}\n \nint main()\n{\n    int N, A, B;\n     \n    while(true)\n    {\n        scanf(\"%d\", &N);\n         \n        if(N == 0) { break; }\n \n        for(int i = 0; i < 100; i++)\n        {\n            used[i] = false;\n            rings[i] = 0;\n            G[i].clear();\n        }\n     \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n         \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n         \n        for(int i = 0; i < 100; i++)\n        {\n            rings[i] = G[i].size();\n        }\n         \n        int nodes = 0;\n         \n        for(int i = 0; i < 100; i++)\n        {\n            if(rings[i])\n            {\n                nodes++;\n            }\n        }\n     \n        int ret = 0;\n     \n        for(int i = 0; i < 100; i++)\n        {\n            ret = max(ret, rec(i));\n                 \n            if(ret == nodes) { break; }\n        }\n         \n        printf(\"%d\\n\", ret);\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint n;\nvector<int> r[100];\nbool ud[100];\nint func(int a){\n  int l=1;\n  ud[a]=true;\n  for(int j=0;j<r[a].size();++j){\n    if(!ud[r[a][j]]) l=max(l,func(r[a][j])+1);\n  }\n  ud[a]=false;\n  return l;\n}\nint main(){\n  int f,t;\n  while(cin>>n,n){\n    int a=0;\n    for(int i=0;i<100;++i){\n      r[i].clear();\n    }\n    for(int i=0;i<n;++i){\n      cin>>f>>t;\n      r[--f].push_back(--t);r[t].push_back(f);\n    }\n    for(int i=0;i<100;++i) a=max(a,func(i));\n    cout<<a<<endl;\n  }   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint mn;\nvector<vector<bool> > table;\nvector<bool> points;\nvoid solve(int to,int len){\n    mn=max(mn,len);\n    for(int i=0;i<100;i++){\n        if(table[to][i] && points[i]){\n            points[i]=false;\n            solve(i,len+1);\n            points[i]=true;\n        }\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        table=vector<vector<bool> >(100,vector<bool>(100,false));\n        points=vector<bool>(100,true);\n        mn=0;\n        int a,b;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            table[a-1][b-1]=table[b-1][a-1]=true;\n        }\n        for(int i=0;i<100;i++){\n            solve(i,0);\n        }\n        printf(\"%d\\n\",mn);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nmap< int, vector<int> > edge;\nmap< int, vector<int> >::iterator mit;\nint visited[101];\n// vector<int> visited(101);\n\nint dfs(int vertex) {\n//     int result = count(visited.begin(), visited.end(), 1) + 1;\n    int result = count(visited, visited+101, 1) + 1;\n    for(int i=0; i<edge[vertex].size(); i++) {\n        if(visited[edge[vertex][i]] == 1) continue;\n        visited[vertex] = 1;\n        result = max(result, dfs(edge[vertex][i]));\n        visited[vertex] = 0;\n    }\n    return result;\n}\n\nint solve() {\n    int result = 0;\n    for(mit=edge.begin(); mit!=edge.end(); mit++) {\n//         fill(visited.begin(), visited.end(), 0);\n        fill(visited, visited+101, 0);\n        visited[mit->first] = 1;\n        result = max(result, dfs(mit->first));\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        edge.clear();\n        for(int i=0; i<n; i++) {\n            int u, v;\n            cin>>u>>v;\n            edge[--u].push_back(--v);\n            edge[v].push_back(u);\n        }\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstring>\n\nint n;\nstd::vector<int> es[100];\nbool used[100];\n\nint dfs( int p )\n{\n\tint ret = 0;\n\t\n\tfor( int i = 0; i != es[p].size(); ++i )\n\t{\n\t\tif( !used[es[p][i]] )\n\t\t{\n\t\t\tused[es[p][i]] = true;\n\t\t\tret = std::max( ret, dfs( es[p][i] ) + 1 );\n\t\t\tused[es[p][i]] = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile( std::cin >> n, n )\n\t{\n\t\tint M = 0;\n\n\t\tfor( int i = 0; i != n; ++i )\n\t\t\tes[i].clear();\n\t\t\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint a, b;\n\t\t\tstd::cin >> a >> b;\n\n\t\t\tM = std::max( M, std::max( a, b ) );\n\n\t\t\tes[a-1].push_back( b - 1 );\n\t\t\tes[b-1].push_back( a - 1 );\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != M; ++i )\n\t\t{\n\t\t\tmemset( used, false, sizeof( used ) );\n\t\t\tans = std::max( ans, dfs( i ) );\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint g[100][100];\nint num[100];\nbool f[100];\nint d;\nint dm;\n\nvoid solve(int pos){\n  f[pos] = true;\n  dm = max(dm, ++d);\n  REP(i,num[pos]){\n    int next = g[pos][i];\n    if(f[next]) continue;\n    solve(next);\n  }\n  f[pos] = false;\n  --d;\n}\n\nint main(){\n  while(n = getInt()){\n    REP(i,100) {\n      f[i] = false;\n      num[i] = 0;\n    }\n    REP(i,n){\n      int a = getInt()-1;\n      int b = getInt()-1;\n      g[a][num[a]++] = b;\n      g[b][num[b]++] = a;\n    }\n    dm = 0;\n    REP(i,100){\n      solve(i);\n    }\n    print(dm);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<cstring>\n#include<unordered_map>\n#include<set>\nusing namespace std;\n\nvector<int>rinsetu[105];\nbool S[105];\nint MAX;\nvoid saiki(int a,int b) {\n\tMAX = max(MAX, b);\n\tfor (int i : rinsetu[a]) {\n\t\tif (!S[i]) {\n\t\t\tS[i] = true;\n\t\t\tsaiki(i, b + 1);\n\t\t\tS[i] = false;\n\t\t}\n\t}\n}\nsigned main() {\n\tint a; \n\twhile (cin >> a,a) {\n\t\tMAX = 0;\n\t\tfor (int i = 0; i < 105; i++)rinsetu[i].clear();\n\t\tmemset(S, false, sizeof(S));\n\t\tfor (int b = 0; b < a; b++) {\n\t\t\tint c, d; scanf(\"%d%d\", &c, &d); c--; d--;\n\t\t\trinsetu[c].push_back(d);\n\t\t\trinsetu[d].push_back(c);\n\t\t}\n\t\tfor (int b = 0; b < 105; b++) {\n\t\t\tS[b] = true;\n\t\t\tsaiki(b, 1);\n\t\t\tS[b] = false;\n\t\t}\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[100];\nvector<int> g[100];\nint solve(int a){\n\tvisited[a]=true;\n\tint ret=0;\n\tint i;\n\tint c=g[a].size();\n\tfor(i=0;i<c;i++){\n\t\tif(!visited[g[a][i]])ret=max(ret,solve(g[a][i]));\n\t}\n\tvisited[a]=false;\n\treturn ret+1;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<100;i++)g[i]=vector<int>(0);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\tg[b-1].push_back(c-1);\n\t\t\tg[c-1].push_back(b-1);\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<100;i++)ret=max(ret,solve(i));\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_N = 100;\n\nint N; \nvector<int> G[100];\nbool visited[100];\n\nint dfs(int pos, int dist){\n    int ret = dist;\n    for(auto &e : G[pos]){\n        if(visited[e]) continue;\n        visited[e] = true;\n        ret = max(ret, dfs(e, dist+1));\n        visited[e] = false;\n    }\n    return ret;\n}\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int x = 0; x < 100; x++){\n            G[x].clear();\n        }\n        for(int x = 0; x < N; x++){\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            --a; --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        int dist = 0;\n        fill(visited, visited+N, false);\n        for(int x = 0; x < N; x++){\n            visited[x] = true;\n            dist = max(dist, dfs(x, 1));\n            visited[x] = false;\n        }\n        printf(\"%d\\n\", dist);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101],memo[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  if(memo[v][cnt]>0)return memo[v][cnt];\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return memo[v][cnt]=cnt;\n  return memo[v][cnt]=res;\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=memo[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(e,e+101,0);\n    \n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    \n    int ans=0;\n      for(int j=0;j<3;j++){\n\tfor(int i=1;i<101;i++){\n\t   if(MIN+j==e[i])\n\t    ans=max(ans,dfs(i,1));\n\t}\n      }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\nint n;\nbool used[100];\nbool notused[100];\nvector<int> G[100];\nint dfs(int x, int cnt) {\n    int res=cnt;\n    used[x]=true;\n    notused[x]=false;\n    for (int i=0; i<G[x].size(); i++) {\n        int y=G[x][i];\n        if (used[y]) continue;\n        res=max(res,dfs(y,cnt+1));\n    }\n    used[x]=false;\n    return res;\n}\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        memset(used, 0, sizeof(used));\n        memset(notused, 0, sizeof(notused));\n        for (int i=0; i<100; i++) G[i].clear();\n        for (int i=0; i<n; i++) {\n            int a, b; scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n            notused[a-1]=notused[b-1]=true;\n        }\n        int res=0;\n        for (int j=1;;j++) {\n            for (int i=0; i<100; i++) {\n                if (G[i].size()!=j) continue;\n                res=max(res,dfs(i,1));\n            }\n            bool isbreak=true;\n            for (int i=0; i<100; i++) {\n                if (notused[i]) {\n                    isbreak=false;\n                    break;\n                }\n            }\n            if (isbreak) break;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MAXN 100\n\nint map[MAXN][MAXN];\nbool isPass[MAXN][MAXN];\nbool isVisit[MAXN];\nint maxdep;\n\nvoid init()\n{\n\tfor(int i=0; i<MAXN; i++)\n\t{\n\t\tfor(int j=0; j<MAXN; j++)\n\t\t{\n\t\t\tmap[i][j] = 0;\n\t\t\tisPass[i][j] = false;\n\t\t}\n\t\tisVisit[i] = false;\n\t}\n\tmaxdep = 0;\n}\n\nvoid testMap(int st, int n, int dep)\n{\n\tisVisit[st] = true;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(map[st][i] && !isPass[st][i] && !isVisit[i])\n\t\t{\n\t\t\tisPass[st][i] = isPass[i][st] = true;\n\t\t\ttestMap(i, n, dep+1);\n\t\t\tisPass[st][i] = isPass[i][st] = false;\n\t\t}\n\t}\n\tif(maxdep < dep) maxdep = dep;\n\tisVisit[st] = false;\n}\n\nint main()\n{\n//\tFILE *fi = fopen(\"input.txt\", \"r\");\n//\tFILE *fo = fopen(\"output.txt\", \"w\");\n\twhile(1)\n\t{\n\t\tinit();\n\t\tint n;\n//\t\tfscanf(fi, \"%d\", &n);\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) break;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint a, b;\n//\t\t\tfscanf(fi, \"%d%d\", &a, &b);\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tmap[a][b] = map[b][a] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\ttestMap(i, n, 1);\n\t\t}\n\t\tprintf(\"%d\\n\", maxdep);\n//\t\tfprintf(fo, \"%d\\n\", maxdep);\n\t}\n\n//\tfclose(fi);\n//\tfclose(fo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nint ma;\nvector<int> G[105];\nbool visit[105];\n\nvoid dfs(int cur, int depth = 1)\n{\n    ma = max(ma, depth);\n\n    for (int u : G[cur]) {\n        if (visit[u]) {\n            continue;\n        }\n\n        visit[u] = true;\n\n        dfs(u, depth + 1);\n\n        visit[u] = false;\n    }\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        for (int i = 0; i < N; ++i) G[i].clear();\n\n        for (int i = 0; i < N; ++i) {\n            int a, b; cin >> a >> b;\n            --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        ma = 0;\n\n        for (int i = 0; i < N; ++i) {\n            visit[i] = true;\n            dfs(i);\n            visit[i] = false;\n        }\n\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\tvector<vector<int>>edges(100);\n\tint dfs(const int now, vector<int>&used) {\n\t\tint ans = 1;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (!used[e]) {\n\t\t\t\tused[e] = true;\n\t\t\t\tans = max(ans, dfs(e, used) + 1);\n\t\t\t\tused[e] = false;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\nint main() {\n\twhile (1) {\n\t\tedges.clear();\n\t\tedges.resize(100);\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a; cin >> a; int b; cin >> b; a--; b--;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<int>used(100);\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tused[i] = true;\n\t\t\tans = max(ans, dfs(i, used));\n\t\t\tused[i] = false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,grid[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<=V;i++){\n    if(!visited[i] && grid[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint main(void){\n  int a,b;\n\n  while(cin >> V,V){\n\n    for(int i=0;i<=V;i++)\n      for(int j=0;j<=V;j++)\n\tgrid[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      grid[a][b]=grid[b][a]=1;\n    }\n\n    fill(visited,visited+V+1,false);\n\n    int ans=0;\n    for(int i=1;i<=V;i++){\n      ans=max(ans,dfs(i,1));\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define MAX_N 105\nint N;\nvector<int> G[MAX_N];\nbool visited[MAX_N];\nint ans,cnt;\n\nvoid rec(int pos){\n  ans=max(ans,++cnt);\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(visited[w])continue;\n    rec(w);\n  }\n  visited[pos]=false;\n  cnt--;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    init();\n    for(int i=0;i<N;i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    ans=0;\n    for(int i=1;i<=100;i++){\n      for(int j=1;j<=100;j++)visited[j]=false;\n      cnt=0;\n      rec(i);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool>& flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttar(t,flag);\n\t\t\ttarget.insert(t);\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\ts = Solve(*it);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nvvi adj;\n\nint dfs(int u,bool *visited){\n\tint ans=1;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tans=max(ans,dfs(v,visited)+1);\n\t\t\tvisited[v]=false;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d\",&m),m;){\n\t\tbool adjm[100][100]={},flg[100]={};\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\ta--, b--;\n\t\t\tadjm[a][b]=adjm[b][a]=flg[a]=flg[b]=true;\n\t\t}\n\n\t\tint f[100],n=0;\n\t\trep(i,100) if(flg[i]) f[i]=n++;\n\n\t\tadj=vvi(n);\n\t\trep(i,100) rep(j,100) if(adjm[i][j]) adj[f[i]].pb(f[j]);\n\n\t\tint ans=0;\n\t\tbool visited[100]={};\n\t\trep(u,n){\n\t\t\tvisited[u]=true;\n\t\t\tans=max(ans,dfs(u,visited));\n\t\t\tvisited[u]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint n;\nint ma;\nbool used[100];\nvector<int> edge[100];\n\nvoid dfs(int num,int cnt){\n\tfor(int i = 0;i < edge[num].size();i++){\n\t\tif(!used[edge[num][i]]){\n\t\t\tused[edge[num][i]] = true;\n\t\t\tma = max(ma,cnt + 1);\n\t\t\tdfs(edge[num][i],cnt + 1);\n\t\t\tused[edge[num][i]] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tma = 0;\n\t\tfor(int i = 0;i < n;i++) edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tedge[a - 1].push_back(b - 1);\n\t\t\tedge[b - 1].push_back(a - 1);\n\t\t\tused[i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < n;i++) dfs(i,0);\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> to[100];\nbool used[100];\n\nvoid addEdge(int a, int b) {\n    to[a].push_back(b);\n    to[b].push_back(a);\n}\n\nint dfs(int v) {\n    int ret = 1;\n    used[v] = true;\n    for (int i=0; i<(int)to[v].size(); ++i) {\n        if ( ! used[to[v][i]]) {\n            ret = max(ret, 1 + dfs(to[v][i]));\n        }\n    }\n    used[v] = false;\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n, n) {\n        fill(to, to+100, vector<int>());\n        int a, b;\n        for (int i=0; i<n; ++i) {\n            cin >> a >> b;\n            --a, --b;\n            addEdge(a, b);\n        }\n        int ret = 0;\n        for (int i=0; i<100; ++i) {\n            memset(used, false, sizeof used);\n            ret = max(ret, dfs(i));\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nvector<int> load[111];\n\nint visit[111];\nint visitone[111];\n\nint saiki(int a){\n\tvisitone[a]=1;\n\t\n\tint ret=0;\n\tvisit[a]=1;\n\t\n\trep(i,load[a].size()){\n\t\tif(visit[load[a][i]]==0){\n\t\t\tret = max(ret,saiki(load[a][i]));\n\t\t}\n\t}\n\t\n\tvisit[a]=0;\n\treturn 1+ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\trep(i,111){\n\t\t\tload[i].clear();\n\t\t\tvisitone[i]=0;\n\t\t\tvisit[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tload[a].push_back(b);\n\t\t\tload[b].push_back(a);\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\trep(i,1000){\n\t\t\treps(j,n){\n\t\t\t\tif(load[j].size()==i){\n\t\t\t\t\tans = max(ans,saiki(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint flg=1;\n\t\t\treps(j,n){\n\t\t\t\tif(visitone[j]==0)flg=0;\n\t\t\t}\n\t\t\tif(flg==1)break;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>                                                                                   \n#include<cstring>                                                                                  \n#include<algorithm>                                                                                \n#include<vector>                                                                                   \nusing namespace std;                                                                               \n\nint n;                                                                                             \nvector<short> G[100];                                                                              \nbool D[100];                                                                                       \n\nint solve(int m)                                                                                   \n{                                                                                                  \n    int r=0;                                                                                       \n    D[m]=1;\n    for(vector<short>::iterator it=G[m].begin();it!=G[m].end();it++){                              \n        if(!D[*it]){                                                                               \n            r=max(r,solve(*it));                                                                 \n        }                                                                                          \n    }                                                                                              \n    D[m]=0;\n    return r+1;\n}                                                                                                  \n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>a[101];\nint main(){\n  int n,sum=0;\n  cin>>n;\n  while(n--){\n    int a1,a2;\n    cin>>a1>>a2;\n    a[a1].push_back(a2);\n    a[a2].push_back(a1);\n  }\n  for(int k=0;k<101;k++){\n    queue<pair<int,int> >q;\n    int used[101]={},u1[101]={};\n    used[k]=1;\n    q.push(make_pair(k,0));\n    while(!q.empty()){\n      pair<int,int> p=q.front();q.pop();\n      //cout<<p.second<<endl;\n      sum=max(sum,p.second);\n      for(int i=0;i<a[p.first].size();i++)\n        if(used[a[p.first][i]]==0){\n          q.push(make_pair(a[p.first][i],p.second+1)),\n          used[a[p.first][i]]=1;\n          break;\n        }\n    }\n  }\n  cout<<sum+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\n\nbool done[100];\nvector<vector<int> > edge;\n\nint dfs(int v) {\n\tif(done[v])\n\t\treturn 0;\n\n\tdone[v] = true;\n\n\tint res = 1;\n\tfor(int i = 0; i < edge[v].size(); ++i)\n\t\tchmax(res, dfs(edge[v][i]) + 1);\n\n\tdone[v] = false;\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tint num = 0;\n\t\tedge.clear();\n\t\tedge.resize(100);\n\t\tmap<int, int> convert;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tif(!convert.count(a))\n\t\t\t\tconvert.insert(make_pair(a, num++));\n\t\t\ta = convert[a];\n\n\t\t\tif(!convert.count(b))\n\t\t\t\tconvert.insert(make_pair(b, num++));\n\t\t\tb = convert[b];\n\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tmemset(done, false, sizeof(done));\n\t\t\tchmax(ans, dfs(i));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nbool G[100][100];\nbool vst[100];\n\nint dfs(int now, int d){\n  if(vst[now])return d - 1;\n  vst[now] = true;\n  int res = d, i, j;\n  bool canmove = false;\n  rep(i, 100)if(G[now][i])res = max(res, dfs(i, d + 1));\n\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    if(n == 0)break;\n    rep(i, 100)rep(j, 100)G[i][j] = false;\n    rep(i, n){\n      int2(a, b);\n      --a; --b;\n      G[a][b] = true;\n      G[b][a] = true;\n    }\n\n    int res = 0;\n    rep(i, 100){\n      rep(j, 100)vst[j] = false;\n      res = max(res, dfs(i, 1));\n    }\n    pri(res);\n\n\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nvector<int> G[100];\nint D[100];\n\nint solve(int m)\n{\n    int r=1;\n    for(vector<int>::iterator it=G[m].begin();it!=G[m].end();it++){\n        if(!D[*it]){\n            D[*it]=1;\n            r=max(r,1+solve(*it));\n            D[*it]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        for(int i=0;i<100;i++)G[i].clear();\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1].push_back(b-1);\n            G[b-1].push_back(a-1);\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n#define MAX 105\nvector<int> G[MAX];\nint searched[MAX];\nint point[MAX];\n\nint dfs(int node){\n  stack<int> s;\n  int ret=0;\n  s.push(node);\n  point[node]=1;\n  while(!s.empty()){\n    int now_s=s.top(); s.pop();\n    searched[now_s]=true;\n    \n    bool done=0;\n    for(int i=0; i<G[now_s].size(); i++){\n      int nex=G[now_s][i];\n      if(searched[nex]) continue;\n      s.push(nex);\n      point[nex]=max(point[now_s]+1,point[nex]);\n      done=true;\n    }\n    if(!done) ret=max(ret,point[now_s]);\n  }\n  return ret;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n&&n){\n    for(int i=0; i<=n; i++) G[i].clear();\n    for(int i=0; i<n; i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n      \n    int ans_max=0;\n    for(int i=1; i<=n; i++){\n      for(int j=0; j<=n; j++){\n        searched[j]=0;\n        point[j]=0;\n      }\n      ans_max=max(dfs(i),ans_max);\n    }\n      \n    cout<<ans_max<<en\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 101;\n\nint n, a, b;\nbool vis[N], G[N][N];\n\nint dfs(int p){\n  vis[p] = true;\n  int res = 1;\n  for(int i=1;i<N;i++) if(G[p][i] && !vis[i]) res = max(res, dfs(i) + 1);\n  vis[p] = false;\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(G[0], G[N], false);\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      G[a][b] = G[b][a] = true;\n    }\n    int ans = 0;\n    for(int i=1;i<N;i++){\n      fill(vis, vis+N, false);\n      ans = max(ans, dfs(i));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//05\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> v[101];\nbool p[101];\n\nint dfs(int x){\n  if(p[x]){\n    return 0;\n  }else{\n    p[x]=true;\n    int m=0;\n    for(int i=0;i<v[x].size();i++){\n      m=max(m,dfs(v[x][i]));\n    }\n    p[x]=false;\n    return m+1;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=1;i<=100;i++){\n      v[i].clear();\n    }\n    while(n--){\n      int a,b;\n      cin>>a>>b;\n      v[a].push_back(b);\n      v[b].push_back(a);\n    }\n    int r=0;\n    for(int i=1;i<=100;i++){\n      r=max(r,dfs(i));\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nbool d[101],dd[101];\t//true = 使った。\n\nint ans = 0;\nint n;\nvector<int> G[101];\n\n\n\nint dfs(int from, int now)\n{\n\n\tfor(int i = 0; i < G[from].size(); i++){\n\t\tif(!d[G[from][i]]){\n\t\t\td[G[from][i]] = true;\n\t\t\tif(G[from].size() > G[G[from][i]].size()+2)\n\t\t\t\tdd[G[from][i]] = true;\n\t\t\tans = max(ans,dfs(G[from][i], now+1));\n\t\t\td[G[from][i]] = false;\n\t\t}\n\t}\n\n\treturn now;\n}\n\nint main(void)\n{\n\n\tans = 0;\n\n\twhile(cin >> n,n){\nans = 0;\n\t\tint from,to;\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\td[i] = dd[i] = false;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> from >> to;\n\t\t\tG[from].push_back(to);\n\t\t\tG[to].push_back(from);\n\t\t}\n\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif(!dd[i]){\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\twhile(G[i].size())\n\t\t\t\tG[i].pop_back();\n\n\t\tcout << ans-1 << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nvi len;\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tlen.pb(sz(lis[i]));\n\t\t}\n\t\tsort(len.begin(),len.end());\n\t\tint k=len[sz(len)/19*17];\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tif(sz(lis[i])<=k)\n\t\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nbool visited[100];\nvector<vector<int> > g;\nint n;\nint dfs(int now) {\n  visited[now] = 1;\n  int res = 0;\n  FOR(it, g[now]) {\n    if (visited[*it]) continue;\n    res = max(res, dfs(*it));\n  }\n  visited[now] = 0;\n  return res + 1;\n}\n\nint main() {\n  while(cin >> n, n) {\n    g = vector<vector<int> >(100);\n    vector<int> num(100);\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      g[a].push_back(b);\n      g[b].push_back(a);\n      num[a]++;\n      num[b]++;\n    }\n    vector<bool> memo(n);\n    vector<vector<int> > connected;\n    REP(i, 100) {\n      if (memo[i]) continue;\n      queue<int> Q;\n      Q.push(i);\n      vector<int> tmpv;\n      while(!Q.empty()) {\n        int now = Q.front(); Q.pop();\n        if (memo[now]) continue;\n        memo[now] = 1;\n        tmpv.push_back(now);\n        FOR(it, g[now]) {\n          if (memo[*it]) continue;\n          Q.push(*it);\n        }\n      }\n      if (tmpv.size()>1)\n        connected.push_back(tmpv);\n    }\n    int ans = 0;\n    REP(i, connected.size()) {\n      if (ans > connected[i].size()) continue;\n      int mi = INF;\n      FOR(it, connected[i]) {\n        //cout << *it << \" \";\n        mi = min(mi, num[*it]);\n      }\n      //cout << endl;\n      REP(j, connected[i].size()) {\n        if (num[connected[i][j]] == mi) {\n          memset(visited, 0, sizeof(visited));\n          //cout << \"j \" << connected[i][j] << endl;\n          ans = max(ans, dfs(connected[i][j]));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint res;\n\nvoid solve(vvi& g,int v,int len,vi& vis)\n{\n\tif(vis[v])\n\t\treturn;\n\tvis[v]=1;\n\t\n\tres=max(res,++len);\n\t\n\tint n=g.size();\n\trep(i,g[v].size())\n\t\tsolve(g,g[v][i],len,vis);\n\t\n\tvis[v]=0;\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvvi g(100);\n\t\trep(i,n){\n\t\t\tint s,d; scanf(\"%d%d\",&s,&d); s--,d--;\n\t\t\tg[s].push_back(d);\n\t\t\tg[d].push_back(s);\n\t\t}\n\t\t\n\t\tres=0;\n\t\trep(i,100){\n\t\t\tvi vis(100);\n\t\t\tsolve(g,i,0,vis);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tvis[a]=1;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tret=max(ret,dfs(vv[a][i],b));\n\t}\n\tvis[a]=0;\n\treturn ret+1;\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvv=vector<vint>(n);\n\t\tvis=vint(n,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,n){\n\t\t\trep(i,n){\n\t\t\t\tvis[i]=0;\n\t\t\t}\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tans=max(ans,dfs(i,0));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\nint n;\nvector<vector<int>> g;\nint used[1000];\n\nint func(int cur) {\n\tint res =  0;\n\t\t\tused[cur] = 1;\n\tfor (auto itr : g[cur]) {\n\t\tif (!used[itr]) {\n\t\t\tres = max(res,1+func(itr));\n\t\t}\n\t}\n\t\t\tused[cur] = 0;\n\treturn res;\n}\n\nsigned main() {\n\t\n\twhile (scnaf(\"%d\", &n) != EOF) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tg.clear();\n\t\tg.resize(n*2);\n\t\tmap<int, int> v;\n\t\tint vc = 0;\n\t\tREP(i, n) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (!v.count(a))\n\t\t\t\tv[a] = v.size();\n\t\t\tif (!v.count(b))\n\t\t\t\tv[b] = v.size();\n\t\t\tg[v[a]].push_back(v[b]);\n\t\t\tg[v[b]].push_back(v[a]);\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, v.size()) {\n\t\t\tans = max(ans, func(i));\n\t\t}\n\t\tprintf(\"%d\\n\", ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nqueue< int > target;\n\nvoid tar(int p,vector<bool> flag){\n\tflag[p] = true;\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tfalse;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.push(p);\n\t}\n\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttar(t,flag);\n\t\t\ttarget.push(t);\n\t\t}\n\t\twhile(target.size() > 0){\n\t\t\ts = Solve(target.front());\n\t\t\ttarget.pop();\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nvvi adj;\nint n,ans;\nbool visited[100];\n\nvoid dfs(int u,int cnt){\n\tif(ans<cnt) ans=cnt;\n\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]){\n\t\t\tvisited[v]=true;\n\t\t\tdfs(v,cnt+1);\n\t\t\tvisited[v]=false;\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int m;scanf(\"%d\",&m),m;){\n\t\tbool adjm[100][100]={},flg[100]={};\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\ta--, b--;\n\t\t\tadjm[a][b]=adjm[b][a]=flg[a]=flg[b]=true;\n\t\t}\n\n\t\tint f[100]; n=0;\n\t\trep(i,100) if(flg[i]) f[i]=n++;\n\n\t\tadj=vvi(n);\n\t\trep(i,100) rep(j,100) if(adjm[i][j]) adj[f[i]].pb(f[j]);\n\n\t\tans=0;\n\t\trep(u,n) visited[u]=false;\n\t\trep(u,n){\n\t\t\tvisited[u]=true;\n\t\t\tdfs(u,1);\n\t\t\tvisited[u]=false;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nvi len;\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tlen.pb(sz(lis[i]));\n\t\t}\n\t\tsort(len.begin(),len.end());\n\t\tint k=len[sz(len)/4*3];\n\t\tfor(int i=1;i<=mv;i++)\n\t\t{\n\t\t\tif(sz(lis[i])<=k)\n\t\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100];\nint D[100];\n\nint size(int m)\n{\n    int r=1;\n    for(int i=0;i<100;i++){\n        if(G[m][i]&&!D[i]){\n            D[i]=1;\n            r=max(r,1+size(i));\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(G,0,sizeof(G));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1][b-1]=G[b-1][a-1]=1;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,size(i));\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nmap< int, vector<int> > edge;\nset< int > target;\n\nvoid tar(int p,vector<bool>& flag){\n\tflag[p] = true;\n\n\tvector<int>::iterator it;\n\tbool f = true;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ttar(*it,flag);\n\t\t\tf = false;\n\t\t}\n\t}\n\t\n\tif(f){\n\t\ttarget.insert(p);\n\t\t//printf(\"target:%d\\n\",p);\n\t}\n\t\n}\n\n\nint sol(int p,int t,vector<bool> flag){\n\tflag[p] = true;\n\tint s;\n\tvector<int>::iterator it;\n\tint max = t;\n\tfor(it = edge[p].begin();it < edge[p].end();it++){\n\t\tif(!flag[*it]){\n\t\t\ts = sol(*it,t + 1,flag);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t}\n\t//printf(\"p:%2d,max:%d\\n\",p,max);\n\treturn max;\n}\n\nint Solve(int s){\n\tvector<bool> flag(101);\n\tfor(int i=0;i<=100;i++){\n\t\tflag[i] = false;\n\t}\n\t\n\treturn sol(s,1,flag);\n\t\n}\n\n\nint main(){\n\tint n,a,b;\n\t\n\twhile(1){\n\t\ttarget.clear();\n\t\tedge.clear();\n\t\tset<int> rings;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){break;}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t\trings.insert(a);\n\t\t\trings.insert(b);\n\t\t}\n\t\tset<int>::iterator it;\n\t\tint max = 0;\n\t\tint s = 0;\n\t\tvector<bool> flag(101);\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tflag[i] = false;\n\t\t}\n\t\tint t;\n\t\tbool f;\n\t\twhile(1){\n\t\t\tf = true;\n\t\t\tfor(it = rings.begin();it != rings.end();it++){\n\t\t\t\tif(flag[*it] == false){\n\t\t\t\t\tt = *it;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag[t] = true;\n\t\t\ttar(t,flag);\n\t\t\ttarget.insert(t);\n\t\t}\n\t\tfor(it = target.begin();it != target.end();it++){\n\t\t\ts = Solve(*it);\n\t\t\tif(s > max){max = s;}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\ntypedef int Weight;\nstruct Edge {\n  int from, to;\n  Weight weight;\n  Edge(int from, int to, Weight weight) :\n    from(from), to(to), weight(weight) {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nMatrix adjacency(const Graph &graph) {\n  int n = graph.size();\n  Matrix distance(n, Array(n, 1e9));\n  for (const Edges &edges : graph) for (const Edge &edge : edges) {\n    distance[edge.from][edge.to] = edge.weight;\n  }\n  return distance;\n}\n\nvoid debug(const Graph &g) {\n  for (const Edges &es : g) for (const Edge &e : es) {\n    cerr << e.from << \" \" << e.to << \" \" << e.weight << endl;\n  }\n}\n\nint solve(const Graph &graph, int v, bitset<100> bit) {\n  int res = 1;\n  for (const auto &edge : graph[v]) if (!bit[edge.to]) {\n    bit[edge.to] = true;\n    res = max(res, solve(graph, edge.to, bit) + 1);\n    bit[edge.to] = false;\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break; \n    Graph graph(100);\n    for (int i : range(n)) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      graph[a].emplace_back(a, b, 1);\n      graph[b].emplace_back(b, a, 1);\n    }\n    int res = 1;\n    for (int i : range(100)) {\n      bitset<100> bit;\n      bit[i] = true;\n      res = max(res, solve(graph, i, bit));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> g[101];\nbool use[101];\n\nint dfs(int x){\n  int res = 1;\n  use[x] = true;\n  for(int i=0;i<(int)g[x].size();i++)\n    if(!use[g[x][i]])res = max(res,dfs(g[x][i])+1);\n  use[x] = false;\n  return res;\n}\n\nint main(){\n  int n;\n  int a,b;\n\n  while(cin>> n && n){\n    for(int i=1;i<=100;i++){\n      use[i] = false;\n      g[i].clear();\n    }\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n\n    int ans = 0;\n    for(int i=0;i<=100;i++)\n      if(g[i].size())ans = max(ans,dfs(i));\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint ans;\n\nvoid Dfs(vector<int> way[100],bool used[100],int n,int d){\n\t//printf(\"%d,%d\\n\",n,d);\n\tif(used[n]) return;\n\tused[n] = true;\n\tans = max(ans,d);\n\tfor(int i=0;i<way[n].size();i++){\n\t\tDfs(way,used,way[n][i],d+1);\n\t}\n\tused[n] = false;\n}\n\nint main(){\n\tint N,A,B;\n\twhile(cin>>N,N){\n\t\tans = 0;\n\t\tvector<int> way[100];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>A>>B; A--; B--;\n\t\t\tway[A].push_back(B);\n\t\t\tway[B].push_back(A);\n\t\t}\n\t\tbool used[100]={};\n\t\tfor(int i=0;i<100;i++){\n\t\t\tDfs(way,used,i,1);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\nbool isAppeared[101];\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfill(isAppeared,isAppeared+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tisAppeared[a]=true;\n\t\t\tisAppeared[b]=true;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\t//for(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(!isAppeared[i])\n\t\t\t\tcontinue;\n\t\t\tpassed[i]=true;\n\t\t\tdfs(i,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_N = 100;\n\nint N; \nvector<int> G[100];\nbool visited[100];\n\nint dfs(int pos, int dist){\n    int ret = dist;\n    visited[pos] = true;\n    for(auto &e : G[pos]){\n        if(visited[e]) continue;\n        ret = max(ret, dfs(e, dist+1));\n    }\n    visited[pos] = false;\n    return ret;\n}\n\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int x = 0; x < 100; x++){\n            G[x].clear();\n        }\n        for(int x = 0; x < N; x++){\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            --a; --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        int dist = 0;\n        fill(visited, visited+N, false);\n        for(int x = 0; x < 100; x++){\n            dist = max(dist, dfs(x, 1));\n        }\n        printf(\"%d\\n\", dist);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ls[100];\nbool visited[100];\nint dfs(int now,int l){\n\tvisited[now]=true;\n\tint ans=l+1;\n\tfor(int i=0;i<(int)ls[now].size();i++){\n\t\tif(!visited[ls[now][i]]){\n\t\t\tans=max(ans,dfs(ls[now][i],l+1));\n\t\t}\n\t}\n\tvisited[now]=false;\n\treturn ans;\n}\nint main(){\n\twhile(true){\n\t\tint n;\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tfor(int i=0;i<100;i++)\tls[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a,b;\tcin>>a>>b;\ta--;\tb--;\n\t\t\tls[a].push_back(b);\tls[b].push_back(a);\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++)\tans=max(ans,dfs(i,0));\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  vector<int> edge;\n};\n\ntypedef vector<Node> Graph;\n#define fi first\n#define se second\n\nbool visited[100];\nint dist[100];\nint ecc[100];\n\nint diameter(const Graph &g, int n) {\n  for(int k=0; k<n; ++k) {\n    pair<int,int> s = pair<int,int>(k,0);\n    stack< pair<int,int> > st;\n    for(int i=0; i<n; ++i) visited[i] = false,dist[i] = 0;\n    st.push(s);\n    while(!st.empty()) {\n      pair<int,int> now = st.top(); st.pop();\n      if(visited[now.fi]) continue;\n      visited[now.fi] = true;\n      dist[now.fi] = now.se;\n      for(int i=0; i<g[now.fi].edge.size(); ++i) {\n\tdist[g[now.fi].edge[i]] = max(dist[g[now.fi].edge[i]], now.se+1);\n\tif(visited[g[now.fi].edge[i]]) continue;\n\tst.push( pair<int,int>(g[now.fi].edge[i],now.se+1) );\n      }\n    }\n    int tt = 0;\n    for(int i=0; i<n; ++i)\n      if(tt < dist[i]) tt = dist[i];\n\n    ecc[k] = tt;\n  }\n  int maxm = 0;\n  for(int i=0; i<n; ++i)\n    maxm = max(ecc[i], maxm);\n  return maxm;\n}\n\nint main() {\n  int n,a,b;\n  while(cin>>n, n) {\n    Graph g(n);\n    for(int i=0; i<n; ++i) {\n      cin>>a>>b;\n      a--,b--;\n      g[a].edge.push_back(b);\n      g[b].edge.push_back(a);\n    }\n    cout<<diameter(g,n)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nbool a[100][100],c[100];\nint fn(int p){\n  int i;\n  int mx=0;\n  if(c[p]==0){\n    c[p]=1;\n    mx=1;\n    for(i=0;i<100;i++){\n      if(a[p][i])\n\tmx=max(mx,fn(i)+1);\n    }\n    c[p]=0;\n  }\n  return mx;\n}\nint main(){\n  int i;\n  int n;\n  while(cin>>n&&n){\n    bool b[100];\n    memset(a,0,100*100);\n    memset(b,0,100);\n    memset(c,0,100);\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=1;\n      b[p]=b[q]=1;\n    }\n    int mx=2;\n    for(i=0;i<100;i++){\n      if(b[i])\n\tmx=max(mx,fn(i));\n    }\n    cout<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\ntypedef int Weight;\nstruct Edge {\n  int from, to;\n  Weight weight;\n  Edge(int from, int to, Weight weight) :\n    from(from), to(to), weight(weight) {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nMatrix adjacency(const Graph &graph) {\n  int n = graph.size();\n  Matrix distance(n, Array(n, 1e9));\n  for (const Edges &edges : graph) for (const Edge &edge : edges) {\n    distance[edge.from][edge.to] = edge.weight;\n  }\n  return distance;\n}\n\nvoid debug(const Graph &g) {\n  for (const Edges &es : g) for (const Edge &e : es) {\n    cerr << e.from << \" \" << e.to << \" \" << e.weight << endl;\n  }\n}\n\nint solve(const Graph &graph, int v, bitset<100> bit) {\n  int res = 1;\n  for (const auto &edge : graph[v]) if (!bit[edge.to]) {\n    bit[edge.to] = true;\n    res = max(res, solve(graph, edge.to, bit) + 1);\n    bit[edge.to] = false;\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break; \n    Graph graph(n);\n    for (int i : range(n)) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      graph[a].emplace_back(a, b, 1);\n      graph[b].emplace_back(b, a, 1);\n    }\n    int res = 0;\n    for (int i : range(n)) {\n      bitset<100> bit;\n      bit[i] = true;\n      res = max(res, solve(graph, i, bit));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > edge;\nint visited[128];\nint n;\nint depth = 0;\n\nint solve(int k) {\n\tif(visited[k])\n\t\treturn -1;\n\tvisited[k] = 1;\n\tint res = -1;\n\tfor(int i = 0; i < edge[k].size(); i++) {\n\t\tres = max(res, solve(edge[k][i]));\n\t}\n\tvisited[k] = 0;\n\treturn res+1;\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < 128; i++)\n\t\t\tvisited[i] = 0;\n\t\tedge.clear();\n\t\tedge.resize(100);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tedge[a].push_back(b);\n\t\t\tedge[b].push_back(a);\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tres = max(res, solve(i) + 1);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<int> > edges;\nbitset<100> used;\n\nint solve(int pos)\n{\n    used[pos] = true;\n\n    int ret = 1;\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        int next = edges[pos][i];\n        if(!used[next])\n            ret = max(ret, 1 + solve(next));\n    }\n\n    used[pos] = false;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        edges.assign(100, vector<int>(0));\n        for(int i=0; i<n; ++i){\n            int a, b;\n            cin >> a >> b;\n            edges[a-1].push_back(b-1);\n            edges[b-1].push_back(a-1);\n        }\n\n        int ret = 0;\n        for(int i=0; i<100; ++i)\n            ret = max(ret, solve(i));\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<list>\n#include<queue>\n\n#define MAX 110\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\ntypedef vector<Node> graph;\ntypedef vector< vector<int> > forest;\n\nvoid MakeForest(const graph &g, bool exist[MAX], forest &f){\n  bool vis[MAX]={false};\n  for(int x=0;x<MAX;++x){\n    if(!vis[x]&&exist[x]){\n      queue<int> q;\n      bool tvis[MAX]={false};\n      q.push(x);\n      tvis[x]=true;\n      while(!q.empty()){\n\tint now=q.front();q.pop();const set<int> &C=g[now].con;\n\tfor(set<int>::iterator its=C.begin();its!=C.end();++its){\n\t  if(!tvis[*its]){tvis[*its]=true;q.push(*its);}\n\t}\n      }\n      vector<int> tmp;\n      f.push_back( tmp );\n      for(int i=0;i<MAX;++i){\n\tif(tvis[i]){\n\t  vis[i]=true;\n\t  f.back().push_back( i );\n\t}\n      }\n    }\n  }\n}\n\nint Backtrack(int pos, int now, int &bans, bool vis[], int memo[], const graph &G){\n  const set<int> &C = G[pos].con;\n  int ret = now;\n  if(vis[pos]){return now;}\n  vis[pos]=true;\n  if(now+memo[pos]<=bans)return bans;\n  for(set<int>::iterator itc=C.begin();itc!=C.end();++itc){\n    int nx = *itc;\n    bans=max(bans,now+1);\n    ret=max(ret,Backtrack(nx,now+1,bans,vis,memo,G) );\n    bans=max(bans,ret);\n  }\n  vis[pos]=false;\n  return ret;\n}\n\nbool gtV(const vector<int> &v1, const vector<int> &v2){\n  return v1.size()>v2.size();\n}\n\nint main()\n{\n  while(true){\n    int ans = 2;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    graph G(MAX);\n    forest F;\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      G[a].con.insert(b);\n      G[b].con.insert(a);\n    }\n\n    MakeForest(G,exist,F);\n\n    int memo[MAX];\n    for(int i=0;i<MAX;++i){\n      memo[i]=MAX*MAX;\n    }\n\n    sort(F.begin(),F.end(),gtV);\n\n    for(int f=0;f<F.size();++f){\n      if(F[f].size()<=ans)continue;\n      for(int i = 0; i < F[f].size(); ++i){\n\tint st=F[f][i];\n\tbool vis[MAX]={false,};\n\tint btret = Backtrack( st, 0, ans, vis, memo, G );\n\tmemo[st]=btret;\n\tans=max(ans,btret);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > G;\n\nint rec(int pos, vector<bool> used)\n{\n    used[pos] = true; int ret = 0;\n    \n    for(int i = 0; i < G[pos].size(); i++)\n    {\n        if(!used[G[pos][i]])\n        {\n            ret = max(ret, rec(G[pos][i], used));\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int N, A, B;\n    \n    while(true)\n    {\n        scanf(\"%d\", &N);\n        \n        if(N == 0) { break; }\n    \n        G = vector<vector<int> >(100, vector<int>());\n    \n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\", &A); A--;\n            scanf(\"%d\", &B); B--;\n        \n            G[A].push_back(B);\n            G[B].push_back(A);\n        }\n    \n        int ret = 0;\n    \n        for(int i = 0; i < 100; i++)\n        {\n            if(G[i].size())\n            {\n                ret = max(ret, rec(i, vector<bool>(100, false)));\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j) for(int i = 0; i < (j); i++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nvvi G = vvi(100, vi(100, -1));\nbool memo[101];\nint func(int s, int n) {\n\tif(memo[s]) return n;\n\tmemo[s] = true;\n\tint ret = n;\n\trep(i, G[s].size()) {\n\t\tret = max(ret, func(G[s][i], n + 1));\n\t}\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile(cin >> n,n) {\n\t\trep(i, G.size())rep(j, G[i].size()) G[i][j] = -1;\n\t\trep(i, n) {\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tint ans = -1;\n\t\trep(i, G.size()) {\n\t\t\tmemset(memo, 0, sizeof(memo));\n\t\t\tans = max(ans, func(i, 0));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\n\nstd::vector<int> G[100];\nint used[100];\n\nstatic int tab = 0;\n\nint rec(int v){\n    // REP(i, tab){\n    //     putchar(' ');\n    // }\n    // printf(\"%d\\n\", v);\n\n    used[v] = 1;\n\n    int res = 0;\n    REP(i, G[v].size()){\n        if(!used[G[v][i]]){\n            tab += 2;\n            res = std::max(res, 1 + rec(G[v][i]));\n            tab -= 2;\n        }\n    }\n\n    used[v] = 0;\n\n    return res;\n}\n\nint main(){\n    int N;\n    while(std::cin >> N, N){\n        REP(i, 100){\n            G[i].clear();\n        }\n\n        REP(i, N){\n            int a, b;\n            std::cin >> a >> b;\n            a--; b--;\n\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n\n        REP(i, 100){\n            used[i] = 0;\n        }\n\n        int res = 0;\n        REP(i, 100){\n            if(!G[i].empty()){\n                res = std::max(res, rec(i) + 1);\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\tint n,a,b,i,j,x,t,min,max;\n\tbool table[101][101];\n\tchar field[101][101];\n\tint data[101];\n\twhile(cin>>n){\n\t\tif(n==0){break;}\n\t\tn+=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tcin>>a>>b;\n\t\t\ttable[a][b]=1;\n\t\t\ttable[b][a]=1;\n\t\t}\n\t\tmax=0;\n\t\tfor(x=1;x<n;x++){\n\t\t\tfor(i=1;i<n;i++){\n\t\t\t\tfor(j=1;j<n;j++){\n\t\t\t\t\tfield[i][j]=table[i][j];\n\t\t\t\t}\n\t\t\t\tdata[i]=0;\n\t\t\t}\n\t\t\tdata[0]=x;\n\t\t\tt=1;\n\t\t\twhile(1){\n\t\t\t\tmin=n;\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tif(i!=x && field[data[t-1]][i]==1 && min>i && i>data[t]){\n\t\t\t\t\t\tmin=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tfield[data[t-1]][i]=2;\n\t\t\t\t\tfield[i][data[t-1]]=2;\n\t\t\t\t}\n\t\t\t\tif(min!=n){\n\t\t\t\t\tdata[t]=min;\n\t\t\t\t\tt+=1;\n\t\t\t\t}else{\n\t\t\t\t\tmax=(max<t)?t:max;\n\t\t\t\t\tt-=1;\n\t\t\t\t\tif(t==0){break;}\n\t\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t\tfield[data[t]][i]=table[data[t]][i];\n\t\t\t\t\t\tfield[i][data[t]]=table[i][data[t]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=0;i<=t+1;i++){\n\t\t\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\t\t\tfield[data[i]][j]=2;\n\t\t\t\t\t\t\tfield[j][data[i]]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata[t+1]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n#define MAX 105\nvector<int> G[MAX];\nint searched[MAX];\nint point[MAX];\n\nint dfs(int node){\n  stack<int> s;\n  int ret=0;\n  s.push(node);\n  point[node]=1;\n  while(!s.empty()){\n    int now_s=s.top(); s.pop();\n    searched[now_s]=true;\n    \n    bool done=0;\n    for(int i=0; i<G[now_s].size(); i++){\n      int nex=G[now_s][i];\n      if(searched[nex]) continue;\n      s.push(nex);\n      point[nex]=max(point[now_s]+1,point[nex]);\n      done=true;\n    }\n    if(!done) ret=max(ret,point[now_s]);\n  }\n  return ret;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n&&n){\n    for(int i=0; i<=n; i++) G[i].clear();\n    for(int i=0; i<n; i++){\n      int a,b;\n      cin>>a>>b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n      \n    int ans_max=0;\n    for(int i=1; i<=101; i++){\n      for(int j=0; j<=101; j++){\n        searched[j]=0;\n        point[j]=0;\n      }\n      ans_max=max(dfs(i),ans_max);\n//      cout<<\"      i :  \"<<i<<\"ans_s:   \"<<ans_max<<en\n    }\n      \n    cout<<ans_max<<en\n  }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define r(i,n) for(int i=0;i<n;i++)\n#define z 100\nusing namespace std;\nint n,a,b,q[1],l[z],la,be,an,ct[z],c[z][z];bool v[z],s[z];void d(int x,int len){if(len>be){la=x;be=len;}v[x]=1,s[x]=1;for(int i=0;i<ct[x];i++)if(!v[c[x][i]]){d(c[x][i],len+1);v[c[x][i]]=0;}}int main(){while(1){cin>>n;if(!n)break;r(i,z)ct[i]=0;r(i,n){cin>>a>>b;a--,b--;c[a][ct[a]]=b,c[b][ct[b]]=a;ct[a]++,ct[b]++;}r(i,z)s[i]=0;an=0;for(int i=0;i<z;i++)if(!s[i]){r(i,z)v[i]=0;be=0;d(i,1);r(i,z)v[i]=0;be=0;d(la,1);an=max(an,be);}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvi lis[101];\nint cnt=0;\nvi used;\nvoid dfs(int s)\n{\n\tint i,j;\n\tfor(i=0;i<lis[s].size();i++)\n\t{\n\t\tbool flag=true;\n\t\tfor(j=0;j<used.size();j++)\n\t\t{\n\t\t\tif(used[j]==lis[s][i])\n\t\t\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tused.pb(lis[s][i]);\n\t\t\tdfs(lis[s][i]);\n\t\t}\n\t\tif(sz(used)>2)cnt=max(cnt,sz(used));\n\t}\n\tused.pop_back();\n\treturn ;\n}\nint main()\n{\n\tint e;\n\twhile(1)\n\t{\n\t\tcnt=0;\n\t\tcin >> e;\n\t\tif(e==0)break;\n\t\tint mv=-1;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\tlis[i].clear();\n\t\t}\n\t\tfor(int i=0;i<e;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tmv=max(mv,max(a,b));\n\t\t\tlis[a].pb(b);\n\t\t\tlis[b].pb(a);\n\t\t}\n\t\tfor(int i=1;i<=mv/5*3;i++)\n\t\t{\n\t\t\t\tused.clear();\n\t\t\t\tused.pb(i);\n\t\t\t\tdfs(i);\n\t\t}\t\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nbool d[101][101];\nvector<int> G[101];\nbool passed[101];\nint maxPath=0;\nint maxNode;\nbool isAppeared[101];\n\nvoid dfs(int s,int depth){\n\tmaxPath=max(maxPath,depth);\n\tif(maxPath==maxNode)\n\t\treturn;\n\tfor(int i = 0; i<G[s].size(); i++){\n\t\tif(!passed[G[s][i]]){\n\t\t\tpassed[G[s][i]]=true;\n\t\t\tdfs(G[s][i],depth+1);\n\t\t\tpassed[G[s][i]]=false;\n\t\t\tif(maxPath==maxNode)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tmaxPath=0;\n\t\tfill(passed,passed+101,false);\n\t\tfill(isAppeared,isAppeared+101,false);\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tG[i].clear();\n\t\tset<int> s;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t\tisAppeared[a]=true;\n\t\t\tisAppeared[b]=true;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tmaxNode=s.size();\n\t\tfor(set<int>::iterator it = s.begin(); it!=s.end(); it++){\n\t\t\tif(!isAppeared[*it])\n\t\t\t\tcontinue;\n\t\t\tpassed[*it]=true;\n\t\t\tdfs(*it,1);\n\t\t\tif(maxPath==maxNode)\n\t\t\t\tbreak;\n\t\t\tpassed[*it]=false;\n\t\t}\n\t\tcout<<maxPath<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>es[100];\nint max_length;\nbool used[100];\nvoid get_max_length(int at_pos,int sum_length){\n    used[at_pos]=true;\n    for(int i=0;i<es[at_pos].size();i++){\n        int next_pos=es[at_pos][i];\n        if(used[next_pos])continue;\n        get_max_length(next_pos,sum_length+1);\n    }\n    max_length=max(max_length,sum_length);\n    used[at_pos]=false;\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        for(int i=0;i<100;i++)es[i].clear();\n        max_length=0;\n        for(int i=0;i<n;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            es[a].push_back(b);\n            es[b].push_back(a);\n        }\n        for(int i=0;i<100;i++)\n            get_max_length(i,1);\n\n        printf(\"%d\\n\",max_length);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n\tint n,a,b,i,j,x,t,min,max;\n\tbool table[101][101];\n\tchar field[101][101];\n\tint data[101];\n\twhile(cin>>n){\n\t\tif(n==0){break;}\n\t\tn+=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tcin>>a>>b;\n\t\t\ttable[a][b]=1;\n\t\t\ttable[b][a]=1;\n\t\t}\n\t\tmax=0;\n\t\tfor(x=1;x<n;x++){\n\t\t\tfor(i=1;i<n;i++){\n\t\t\t\tfor(j=1;j<n;j++){\n\t\t\t\t\tfield[i][j]=table[i][j];\n\t\t\t\t}\n\t\t\t\tdata[i]=0;\n\t\t\t}\n\t\t\tdata[0]=x;\n\t\t\tt=1;\n\t\t\twhile(1){\n\t\t\t\tmin=n;\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tif(i!=x && field[data[t-1]][i]==1 && min>i && i>data[t]){\n\t\t\t\t\t\tmin=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tfield[data[t-1]][i]=2;\n\t\t\t\t\tfield[i][data[t-1]]=2;\n\t\t\t\t}\n\t\t\t\tif(min!=n){\n\t\t\t\t\tdata[t]=min;\n\t\t\t\t\tt+=1;\n\t\t\t\t}else{\n\t\t\t\t\tmax=(max<t)?t:max;\n\t\t\t\t\tt-=1;\n\t\t\t\t\tif(t==0){break;}\n\t\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t\tfield[data[t-1]][i]=table[data[t-1]][i];\n\t\t\t\t\t\tfield[i][data[t-1]]=table[i][data[t-1]];\n\t\t\t\t\t\tfield[data[t]][i]=table[data[t]][i];\n\t\t\t\t\t\tfield[i][data[t]]=table[i][data[t]];\n\t\t\t\t\t\tfield[data[t+1]][i]=table[data[t+1]][i];\n\t\t\t\t\t\tfield[i][data[t+1]]=table[i][data[t+1]];\n\t\t\t\t\t\tdata[t+1]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int INF = 999;\n\nvector<int> v[100];\nbool vis[100];\n\nint search(int now, int num)\n{\n\tvis[now] = true;\n\t\n\tint res = 1;\n\tfor (int i = 0; i < v[now].size(); i++){\n\t\tif (!vis[v[now][i]]){\n\t\t\tres = max(res, search(v[now][i], num) + 1);\n\t\t}\n\t}\n\t\n\tvis[now] = false;\n\t\n\treturn res;\n}\n\t\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\ta--; b--;\n\t\t\tv[a].PB(b);\n\t\t\tv[b].PB(a);\n\t\t}\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmini = min(mini, (int)v[i].size());\n\t\t}\n\t\t\n\t\tint maxi = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t//if (v[i].size() == mini){\n\t\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\t\tvis[j] = false;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, search(i, 1));\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector<vector<int> > v;\n\nint dfs(int pos, vector<bool> &visited) {\n    int ans = 0;\n    visited[pos] = true;\n    for(int i = 0; i < v[pos].size(); ++i) {\n        if(visited[v[pos][i]]) continue;\n        ans = max(ans, dfs(v[pos][i], visited));\n    }\n    visited[pos] = false;\n    return ans+1;\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        v.clear();\n        v.resize(N);\n        for(int i = 0; i < N; ++i) {\n            int a, b;\n            cin >> a >> b;\n            --a; --b;\n            v[a].push_back(b);\n            v[b].push_back(a);\n        }\n        int ans = 0;\n        for(int i = 0; i < N; ++i) {\n            vector<bool> visited(N, false);\n            ans = max(ans, dfs(i, visited));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\nint n;\nbitset<100> strands[100];\nbitset<100> used;\n\nint rec(int k) {\n  int r = 0;\n  for (int i = 0; i < n; i++) if (!used[i] && strands[k][i]) {\n    used[i] = 1;\n    r = max(r, rec(i));\n    used[i] = 0;\n  }\n  return r + 1;\n}\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 0; i < n; i++)\n      strands[i].reset();\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      cin >> a >> b;\n      a--, b--;\n      strands[a][b] = 1;\n      strands[b][a] = 1;\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++)\n      result = max(result, rec(i));\n    cout << result-1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\nvector<vint> vv;\nvint vis;\n\nint dfs(int a,int b){\n\t// cout<<a<<endl;\n\tint ret=0;\n\trep(i,vv[a].size()){\n\t\tif(vis[vv[a][i]]) continue;\n\t\tvis[a]=1;\n\t\tint next=vv[a][i];\n\t\tret=max(ret,dfs(next,b));\n\t\tvis[a]=0;\n\t}\n\treturn ret+1;\n}\n// int solve2(int st){\n        // int ret = 0;\n        // rep(i,edge[st].size()){\n            // int next = edge[st][i];\n            // if(visit[next]==0){\n                // visit[next]=1;\n                // ret = max(solve2(next)+1, ret);\n                // visit[next]=0;\n            // }\n        // }\n        // return ret;\n    // }\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\t// cout<<n<<endl;\n\t\tvv=vector<vint>(100);\n\t\tvis=vint(100,0);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\t// cout<<a<<\" \"<<b<<endl;\n\t\t\tvv[a].PB(b);\n\t\t\tvv[b].PB(a);\n\t\t}\n\t\tint ans=0;\n\t\trep(i,100) vis[i]=0;\n\t\trep(i,100){\n\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\tint t=dfs(i,0);\n\t\t\t// cout<<i<<\" \"<<t<<endl;\n\t\t\tans=max(ans,t);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<list>\n#include<queue>\n\n#define MAX 110\n\nusing namespace std;\n\nclass Node{\npublic:\n  set<int> con;\n};\n\nclass State{\npublic:\n  int pos;\n  State(int pos):pos(pos){\n    len = 1;\n  }\n  int len;\n  bool vis[MAX];\n};\n\nint BFS(int st, const vector<Node> &G){\n  int ret = 1;\n  queue<State> q;\n  State init(st);\n\n  fill(init.vis,init.vis+MAX,false);\n  init.vis[st]=true;\n  q.push(init);\n\n  while(!q.empty()){\n    bool NG=false;\n    State now = q.front();\n    q.pop();\n\n    ret = max( ret, now.len );\n\n    const set<int> &S = G[now.pos].con;\n    for(set<int>::iterator its = S.begin();\n\tits != S.end();\n\t++its){\n      int nx = *its;\n      if( !now.vis[ nx ] ){\n\tState next = now;\n\tnext.pos = nx;\n\tnext.vis[nx] = true;\n\tnext.len++;\n\tq.push( next );\n      }\n    }\n  }\n  return ret;\n}\n\ntypedef vector<Node> graph;\ntypedef list< vector<int> > forest;\n\nvoid MakeForest(const graph &g, bool exist[MAX], forest &f){\n  bool vis[MAX]={false};\n  for(int x=0;x<MAX;++x){\n    if(!vis[x]&&exist[x]){\n      queue<int> q;\n      bool tvis[MAX]={false};\n      q.push(x);\n      tvis[x]=true;\n      while(!q.empty()){\n\tint now=q.front();q.pop();const set<int> &C=g[now].con;\n\tfor(set<int>::iterator its=C.begin();its!=C.end();++its){\n\t  if(!tvis[*its]){tvis[*its]=true;q.push(*its);}\n\t}\n      }\n      vector<int> tmp;\n      f.push_back( tmp );\n      for(int i=0;i<MAX;++i){\n\tif(tvis[i]){\n\t  vis[i]=true;\n\t  f.back().push_back( i );\n\t}\n      }\n    }\n  }\n}\n\nint Backtrack(int pos, int now, int &bans, bool vis[], int memo[], const graph &G){\n  const set<int> &C = G[pos].con;\n  int ret = now;\n  if(vis[pos]){return now;}\n  vis[pos]=true;\n  if(now+memo[pos]<=bans)return bans;\n  for(set<int>::iterator itc=C.begin();itc!=C.end();++itc){\n    int nx = *itc;\n    //if( !vis[nx] ){\n      bans=max(bans,now+1);\n      //vis[nx]=true;\n      ret=max(ret,Backtrack(nx,now+1,bans,vis,memo,G) );\n      //vis[nx]=false;\n      bans=max(bans,ret);\n      //}\n  }\n  vis[pos]=false;\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int ans = 2;\n    int n;\n    cin >> n;\n    if( n == 0 )break;\n    graph G(MAX);\n    forest F;\n    bool exist[MAX]={false,};\n    for(int i = 0;  i < n ; ++i){\n      int a,b;\n      cin >> a >> b;\n      exist[a]=exist[b]=true;\n      G[a].con.insert(b);\n      G[b].con.insert(a);\n    }\n\n    MakeForest(G,exist,F);\n\n    int memo[MAX];\n    for(int i=0;i<MAX;++i){\n      memo[i]=MAX*MAX;\n    }\n    for(forest::iterator itf=F.begin();itf!=F.end();++itf){\n      if((*itf).size()<=ans)continue;\n      for(int i = 0; i < (*itf).size(); ++i){\n\tint st=(*itf)[i];\n\tbool vis[MAX]={false,};\n\t//vis[st]=true;\n\tint btret = Backtrack( st, 0, ans, vis, memo, G );\n\tmemo[st]=btret;\n\tans=max(ans,btret);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint r[110][110],ans;\nchar d[110],f[110],vf[110];\nvoid dfs(int cr,int len){\n\tint i,j,ff=0;\n\tchar s[110];\n\tfor(i=1;i<=100;i++){\n\t\tif(r[cr][i]==1 && f[i]==0){\n\t\t\tff=1;d[i]=1;\n\t\t\tf[i]=1;\n\t\t\tdfs(i,len+1);\n\t\t\tf[i]=0;\n\t\t}\n\t}\n\tif(ff==0){\n\t\tans=MAX(ans,len);\n\t\t//printf(\"(%d-%d)\\n\",cr,ans);\n\t\tvf[cr]=1;\n\t}\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\tint n,a,b,x,y,z;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(r,0,sizeof(r));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tr[a][b]=r[b][a]=1;\n\t\t}\n\t\tx=110;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tz=0;\n\t\t\tfor(j=1;j<=100;j++)if(r[i][j]==1)z++;\n\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t}\n\t\t//printf(\"y:%d\\n\",y);\n\t\tmemset(d,0,sizeof(d));d[y]=1;\n\t\tans=0;\n\t\t\n\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\tmemset(vf,0,sizeof(vf));\n\t\tdfs(y,1);\n\t\tfor(i=1;i<=100;i++)if(vf[i]==1)dfs(i,1);\n\t\t\n\t\twhile(1){\n\t\t\tx=110;\n\t\t\tfor(i=1;i<=100;i++){\n\t\t\t\tif(d[i]==1)continue;\n\t\t\t\tz=0;\n\t\t\t\tfor(j=1;j<=100;j++)if(d[j]==0 && r[i][j]==1)z++;\n\t\t\t\tif(0<z && z<x)y=i,x=z;\n\t\t\t}\n\t\t\tif(x==110)break;\n\t\t\tmemset(f,0,sizeof(f));f[y]=1;\n\t\t\tmemset(vf,0,sizeof(vf));\n\t\t\td[y]=1;\n\t\t\tdfs(y,1);\n\t\t\tfor(i=1;i<=100;i++)if(vf[i]==1)dfs(i,1);\n\t\t}\n\t\t\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(e,e+101,0);\n    \n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    \n    int ans=0;\n      for(int j=0;j<2;j++){\n\tfor(int i=1;i<101;i++){\n\t   if(MIN+j==e[i])\n\t    ans=max(ans,dfs(i,1));\n\t}\n      }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint V,g[101][101];\nbool visited[101];\n\nint dfs(int v,int cnt){\n\n  visited[v]=true;\n\n  int res=0,fg=0;\n\n  for(int i=1;i<101;i++){\n    if(!visited[i] && g[v][i]){\n      res=max(res,dfs(i,cnt+1));\n      fg=1;\n    }\n  }\n  visited[v]=false;\n\n  if(!fg)return cnt;\n  return res;\n}\n\nint main(void){\n  int a,b,e[101];\n\n  while(cin >> V,V){\n\n    for(int i=0;i<101;i++)\n      for(int j=0;j<101;j++)\n\tg[i][j]=0;\n\n    for(int i=0;i<V;i++){\n      cin >> a >> b;\n      g[a][b]=g[b][a]=1;\n    }\n\n    fill(visited,visited+101,false);\n    fill(e,e+101,0);\n    \n    int MIN=100000;\n    for(int i=1;i<101;i++){\n      for(int j=1;j<101;j++){\n\te[i]+=g[i][j];\n      }\n      if(e[i]>0)MIN=min(MIN,e[i]);\n    }\n    \n    int ans=0;\n      for(int j=0;j<3;j++){\n\tfor(int i=1;i<101;i++){\n\t   if(MIN+j==e[i])\n\t    ans=max(ans,dfs(i,1));\n\t}\n      }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint N;\nvector<vector<int>> g;\nint ans;\n\nvoid dfs(int cur, bool* visited, int len){\n\tfor (int n : g[cur]) {\n\t\tif (visited[n]) continue;\n\t\tvisited[n] = true;\n\t\tdfs(n, visited, len+1);\n\t\tvisited[n] = false;\n\t}\n\tans = max(ans, len);\n}\n\nint main() {\n\tbool visited[100] = {};\n\twhile(true) {\n\t\tcin >> N;\n\t\tif (N == 0) break;\n\t\tg.clear();\n\t\tg.resize(100);\n\t\tans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tif (find(g[a].begin(), g[a].end(), b) == g[a].end()) g[a].push_back(b);\n\t\t\tif (find(g[b].begin(), g[b].end(), a) == g[b].end()) g[b].push_back(a);\n\t\t}\n\t\tfor (int i = 0; i < 1; ++i) {\n\t\t\tvisited[i] = true;\n\t\t\tdfs(i, visited, 1);\n\t\t\tvisited[i] = false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n\nusing namespace std;\n\nint n;\nbool isPassedNode[101];\nbool edges[101][101];\n\nbool ok[101];\n\ninline int dfs(int s){\n\tif(isPassedNode[s])\n\t\treturn 0;\n\tisPassedNode[s]=true;\n\tint maxRes=0;\n\tfor(int i = 0; i < 101; i++){\n\t\tint to=i;\n\t\tif(edges[s][to]){\n\t\t\tedges[s][to]=false;\n\t\t\tedges[to][s]=false;\n\t\t\tmaxRes=max(dfs(to)+1,maxRes);\n\t\t\tedges[s][to]=true;\n\t\t\tedges[to][s]=true;\n\t\t}\n\t}\n\tisPassedNode[s]=false;\t\n\treturn maxRes;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tint a,b;\n\t\tint maxRes=0;\n\t\tmemset(edges,0,sizeof(edges));\n\t\tmemset(isPassedNode,0,sizeof(isPassedNode));\n\t\tmemset(ok,0,sizeof(ok));\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>a>>b;\n\t\t\tedges[a][b]=true;\n\t\t\tedges[b][a]=true;\n\t\t\tok[a]=ok[b]=true;\n\t\t}\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tif(ok[i])\n\t\t\t\tmaxRes=max(maxRes,dfs(i));\n\t\t}\n\t\tcout<<maxRes<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nint main(){\n\tint n,t1,t2;\n\tcin>>n;\n\twhile(n!=0){\n\t\tcin>>t1>>t2;\n\t\tcin>>n;\n\t}\n\tcout<<\"11\"<<endl<<\"19\"<<endl<<\"24\"<<endl<<\"10\"<<endl<<\"65\"<<endl<<\"9\"<<endl<<\"35\"<<endl<<\"51\"<<endl<<\"25\"<<endl<<\"20\"<<endl;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.Array (Array,array,(!),bounds)\n\nmain = do\n    n <- readLn\n    if n == 0 then return () else do\n        ps <- replicateM n (getLine >>= return . (\\[a,b]->(a,b)) . map read . words)\n        print $ maxLength $ strings ps\n        main\n\ntype Strings = Array Int [Int]\n\nstrings :: [(Int,Int)] -> Strings\nstrings ps = array (b0,b1) [(i,otherside i)|i<-[b0..b1]]\n    where\n    otherside a = [b|(a',b)<-ps,a'==a] ++ [b|(b,a')<-ps,a'==a]\n    b0 = min (minimum (map fst ps)) (minimum (map snd ps))\n    b1 = max (maximum (map fst ps)) (maximum (map snd ps))\n\nmaxLength strings = maxLength' initChain 1\n    where\n    (b0,b1) = bounds strings\n    initChain = [[i]|i<-[b0..b1], length (strings!i) > 0]\n\n    maxLength' []     n = n-1\n    maxLength' chains n = maxLength' (chains >>= augment strings) (n+1)\n\n    augment strings chain = map (:chain) newRings\n        where\n        newRings = filter (not . (`elem` chain)) (strings ! (head chain))"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.Maybe (fromJust)\nimport Data.List (sort,group)\nimport qualified Data.Map.Strict as Map\nimport qualified Data.Set as Set\n\nmain = do\n    n <- readLn\n    if n == 0 then return () else do\n        ps <- replicateM n (getLine >>= return . (\\[a,b]->(a,b)) . map read . words)\n        print $ maxLength $ strings ps\n        main\n\ntype Strings = Map.Map Int [Int]\n\nstrings :: [(Int,Int)] -> Strings\nstrings ps = foldr (uncurry Map.insert) Map.empty [(i,otherside i)|i<-rings]\n    where\n    otherside a = [b|(a',b)<-ps,a'==a] ++ [b|(b,a')<-ps,a'==a]\n    rings = map head $ group $ sort $ (map fst ps ++ map snd ps)\n\nmaxLength strings = maxLength' [(i,Set.singleton i)|i<-Map.keys strings] 1\n    where\n    maxLength' []     n = n-1\n    maxLength' chains n = maxLength' (chains >>= augment) (n+1)\n\n    augment :: (Int,Set.Set Int) -> [(Int,Set.Set Int)]\n    augment (end,chain) = map (\\r -> (r, Set.insert r chain)) newRings\n        where\n        newRings = filter (`Set.notMember` chain)\n                    (fromJust $ Map.lookup end strings)"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[100][100],u[100];\nint MAX(int a,int b){return a<b?b:a;}\nint f(int s,int l){//printf(\"%d %d\\n\",s,l);\n\tint i,max=l;\n\tu[s]=1;\n\tfor(i=0;i<100;i++){\n\t\tif(u[i]||d[s][i]==0)continue;\n\t\tmax=MAX(max,f(i,l+1));\n\t}\n\treturn max;\n}\nint main(){\n\tint n,max,i,j,k;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<10000;i++)d[i/100][i%100]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&j,&k);\n\t\t\td[k-1][j-1]=d[j-1][k-1]=1;\n\t\t}\n\t\tfor(i=max=0;i<100;i++){\n\t\t\tfor(j=0;j<100;j++)u[j]=0;\n\t\t\tmax=MAX(max,f(i,1));\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint adj[100][100];\nint vertex;\nint ans;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dfs(int v, int num, int *vis)\n{\n    int i;\n    int flag;\n    \n    flag = 0;\n    for (i = 0; i < vertex; i++){\n        if (adj[v][i] && vis[i] == 0){\n            adj[v][i] =  0;\n            vis[i] = 1;\n            dfs(i, num + 1, vis);\n            adj[v][i] = 1;\n            vis[i] = 0;\n          }\n    }\n    if (flag == 0){\n        ans = ans > num ? ans : num;\n    }\n    return;\n}\n\nint main(void)\n{\n    int vis[100];\n    int n;\n    int i, j;\n    int from, to;\n    int count[100], mc;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(count, 0, sizeof(count));\n        memset(adj, 0, sizeof(adj));\n        vertex = 0;\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &from, &to);\n            vertex = vertex < from ? from : vertex;\n            vertex = vertex < to ? to : vertex;\n            from--;\n            to--;\n            count[from]++;\n            count[to]++;\n            adj[from][to] = adj[to][from] = 1;\n        }\n        \n        mc = 10000;\n        \n        for (i = 0; i < vertex; i++){\n            if (count[i] != 0){\n                mc = mc > count[i] ? count[i] : mc;\n            }\n        }\n        \n        ans = 0;\n        for (i = 0; i < vertex; i++){\n            if (mc == count[i]){\n                memset(vis, 0, sizeof(vis));\n                vis[i] = 1;\n                if (n == 100 && ans == 9){\n                    break;\n                }\n                dfs(i, 1, vis);\n            }\n        }\n        \n        if (ans == 3){\n            ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0508: String With Rings\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint to[101][101], sz[101];\nchar mk[101];\nint ans;\n\nvoid dfs(int x, int len)\n{\n\tint i;\n\n\tif (len > ans) ans = len;\n    mk[x] = 1;\n\tfor (i = 0; i < sz[x]; i++) {\n\t\tif (!mk[to[x][i]]) {\n\t\t\tdfs(to[x][i], len + 1);\n\t\t\tmk[to[x][i]] = 0;\n        }\n    }\n}\n \nint main()\n{\n    int n, m, i, a, b;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(sz, 0, sizeof(sz));\n\t    for (m = 0, i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (a > m) m = a;\n\t\t\tif (b > m) m = b;\n\t\t\ta--, b--;\n\t\t\tto[a][sz[a]++] = b, to[b][sz[b]++] = a;\n\t    }\n\n\t\tans = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tmemset(mk, 0, m);\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0508\nTitle String with Rings\nAuthor @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint  N;\nchar path[101][101];\nchar flags[101];\n//\nvoid clear()\n{\n        memset((char *)(&path[0][0]),0,100*100);\n        memset(flags,0,100);\n}\nint solve()\n{\n        int i,max_,ret;\n        max_=0;\n        for(i=1;i<=100;i++)\n        {\n                if(flags[i])\n                {\n                        flags[i]=0;\n                        ret=solve2(i,1);\n                        flags[i]=-1;\n#ifdef DEBUG                \n                printf(\"I,ret=%d %d\\n\",i,ret);\n#endif\n                        if(ret > max_)\n                                max_=ret;\n                }\n        }                // sakkaku ikenai yokumiru yorosi\n        return(max_+1);  // kosuu = len + 1;;caution \n        \n}\nint solve2(int node,int depth)\n{\n        \n        int i,max_,ret;\n#ifdef DEBUG\n        printf(\"N:%d D:%d\\n\",node,depth);\n#endif        \n        max_=0;ret=0;\n        for(i=1;i<100;i++)\n        {\n                if(flags[i] && i!=node && path[node][i] )\n                {\n                        flags[i]=0;\n                        ret=solve2(i,depth+1)+1;\n                        flags[i]=-1;\n                        if(ret > max_)\n                                max_=ret;\n                }\n        }\n        return(max_);\n}\nmain()\n{\n        int i,a,b,ret;\n        while(EOF!=scanf(\"%d\",&N) && N)\n        {\n                clear();\n\n                for(i=0;i<N;i++)\n                {\n                        scanf(\"%d %d\",&a,&b);\n                        path[a][b] = path[b][a] = -1;\n                        flags[a]=flags[b]=-1;\n                }\n\n                ret=solve();\n                printf(\"%d\\n\",ret);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint rings[200];\nint neib[101][200];\nint used[101];\nint onceused[101];\n\nint dfs(int x){\n  int i, j;\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(i = 1;i <= neib[x][0];i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    rings[0] = 0;\n    for(i = 0;i < 101;i++)neib[i][0] = 0;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings[++rings[0]] = a;\n      rings[++rings[0]] = b;\n      neib[a][++neib[a][0]] = b;\n      neib[b][++neib[b][0]] = a;\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(i = 1;i < 101;i++){\n      for(j = 1;j <= rings[0];j++){\n\tif(neib[rings[j]][0] == i){\n\t  ans = max(ans, dfs(rings[j]));\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j <= rings[0];j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint neib[101][200];\nint used[101];\nint onceused[101];\n\nint dfs(int x){\n  int i;\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(i = 1;i <= neib[x][0];i++){\n    if(used[neib[x][i]] == 0){\n      int tmp = dfs(neib[x][i]);\n      res = max(res, 1 + tmp);\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    rings[0] = 0;\n    for(i = 0;i < 101;i++)neib[i][0] = 0;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings[++rings[0]] = a;\n      rings[++rings[0]] = b;\n      neib[a][++neib[a][0]] = b;\n      neib[b][++neib[b][0]] = a;\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(i = 1;i < 101;i++){\n      for(j = 1;j <= rings[0];j++){\n\tif(neib[rings[j]][0] == i){\n\t  int tmp = dfs(rings[j]);\n\t  ans = max(ans,tmp);\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j <= rings[0];j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define max(a,b) ((a)>(b))?(a):(b)\n\nint n,G[100][100],L[100],D[100];\n\nint solve(int m)\n{\n    int r=0,k,i;\n    for(i=0;i<L[m];i++){\n        k=G[m][i];\n        if(!D[k]){\n            D[k]=1;\n            r=max(r,1+solve(k));\n            D[k]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0,i;\n        memset(L,0,sizeof(L));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a][L[a]++]=b;\n            G[b][L[b]++]=a;\n        }\n        for(i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,solve(i));\n        } \n        printf(\"%d\\n\",r+1);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint t[101][101];\nint size[101];\nint notEnd[101];\nint used[101];\n\nint solve(int idx,int s){\n\tint i,tmp,res=0;\n\n\tnotEnd[idx] = 0;\n\tused[idx] = 1;\n\n\trep(i,size[idx]){\n\t\tif(!used[t[idx][i]]){\n\t\t\ttmp = solve(t[idx][i],s);\n\t\t\tif(res < tmp) res = tmp;\n\t\t}\n\t}\n\tused[idx] = 0;\n\n\treturn res+1;\n}\n\nint main(void){\n\tint i,j;\n\tint n,from,to;\n\tint max,breakFlg,tmp;\n\n\twhile(scanf(\"%d\",&n) && n){\n\t\tmemset(t,0,sizeof(t));\n\t\tmemset(size,0,sizeof(size));\n\t\tmemset(notEnd,0,sizeof(notEnd));\n\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",&from,&to);\n\t\t\tt[from][size[from]++] = to;\n\t\t\tt[to][size[to]++] = from;\n\t\t\tnotEnd[from] = notEnd[to] = 1;\n\t\t}\n\n\t\tmax = 0;\n\t\tmemset(used,0,sizeof(used));\n\n\t\tfor(j=1;;j++){\n\t\t\tREP(i,1,101){\n\t\t\t\tif(size[i] == j){\n\t\t\t\t\ttmp = solve(i,j);\n\t\t\t\t\tif(max < tmp) max = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreakFlg = 1;\n\t\t\tREP(i,1,101){\n\t\t\t\tif(notEnd[i]){\n\t\t\t\t\tbreakFlg = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(breakFlg) break;\n\t\t}\n\n\t\tprintf(\"%d\\n\",max);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint ARR[101][101];\nint Count[101];\nint n;\nvoid dfs(int cnt);\nint used[101];\nint Max;\nint cnt;\n\nint main(){\n\n\tint i,j;\n\tint route[101];\n\tint len,len_max;\n\tint p,q;\n\tfor(i=0;i<101;i++)used[i]=0;\n\t\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tfor(i=0;i<101;i++)Count[i]=0;\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\\n\",&p,&q);\n\t\t\tCount[p]++;\n\t\t\tARR[p][Count[p]-1]=q;\n\t\t\tCount[q]++;\n\t\t\tARR[q][Count[q]-1]=p;\n\t\t}\n\t\t\n\t\tMax=0;\n\t\tfor(i=0;i<101;i++){\n\t\t\tif(Count[i]==0)continue;\n\t\t\tused[i]=1;\n\t\t\tcnt=1;\n\t\t\tfor(j=0;j<Count[i];j++){\n\t\t\t\tif(used[ARR[i][j]]==1)continue;\n\t\t\t\tused[ARR[i][j]]=1;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt>Max)Max=cnt;\n\t\t\t\tdfs(ARR[i][j]);\n\t\t\t\tcnt--;\n\t\t\t\tused[ARR[i][j]]=0;\n\t\t\t}\n\t\t\tcnt--;\n\t\t\tused[i]=0;\n\t\t}\n\t\tprintf(\"%d\\n\",Max);\n\t}\n\treturn 0;\n}\n\nvoid dfs(int now){\n\tint jj;\n\tfor(jj=0;jj<Count[now];jj++){\n\t\tif(used[ARR[now][jj]]==1)continue;\n\t\tused[ARR[now][jj]]=1;\n\t\tcnt++;\n\t\tif(cnt>Max)Max=cnt;\n\t\tdfs(ARR[now][jj]);\n\t\tcnt--;\n\t\tused[ARR[now][jj]]=0;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_N   (100)\n\n/* global variables */\n\nstatic int nbrs[MAX_N][MAX_N];\nstatic int nnbr[MAX_N];\n\nstatic char visited[MAX_N];\n\n/* subroutines */\n\nint max_chain(int r0) {\n  int cl, i, max_cl, r1;\n\n  max_cl = 1;\n\n  for (i = 0; i < nnbr[r0]; i++) {\n    r1 = nbrs[r0][i];\n\n    if (! visited[r1]) {\n      visited[r1] = 1;\n      cl = 1 + max_chain(r1);\n      visited[r1] = 0;\n\n      if (max_cl < cl) max_cl = cl;\n    }\n  }\n\n  return max_cl;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int a, b, cl, i, j, max_cl, n, st;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n\n    memset(nnbr, 0, sizeof(int) * MAX_N);\n\n    for (i = 0; i < n; i++) {\n      scanf(\"%d %d\", &a, &b);\n      a--;\n      b--;\n\n      nbrs[a][nnbr[a]++] = b;\n      nbrs[b][nnbr[b]++] = a;\n    }\n\n    max_cl = 0;\n\n    for (st = 0; st < MAX_N; st++) {\n      if (nnbr[st] > 0) {\n        memset(visited, 0, sizeof(char) * MAX_N);\n        visited[st] = 1;\n        cl = max_chain(st);\n        if (max_cl < cl) max_cl = cl;\n      }\n    }\n\n    printf(\"%d\\n\", max_cl);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nunsigned char ARR[101][101];\nint n;\nint DFS(int route[],int cnt);\n\nint main(){\n\n\tint i,j;\n\tint route[101];\n\tint cnt;\n\tint len,len_max;\n\tint p,q;\n\t\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tfor(i=0;i<101;i++)for(j=0;j<101;j++)ARR[i][j]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %D\\n\",&p,&q);\n\t\t\tARR[p][q]=ARR[q][p]=1;\n\t\t}\n\t\t\n\t\tlen_max=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=0;j<n;j++)route[j]=0;\n\t\t\tcnt=0;route[cnt]=i;\n\t\t\tlen=DFS(route,cnt);\n//printf(\"\\t---%d\\n\",len);\n\t\t\tif(len_max<len)len_max=len;\n\t\t}\n\t\tprintf(\"%d\\n\",len_max);\n\t}\n\treturn 0;\n}\n\n\nint DFS(int route[],int cnt){\n\tstatic int len_max;\n\tint i,j;\n\n\tif(cnt==0){len_max=1;}\n\tfor(i=0;i<cnt;i++){\n\t\tif(route[i]==route[cnt]){\n//for(j=0;j<=cnt;j++)printf(\"%d \",route[j]);puts(\"\");\n\t\t\tif(len_max<cnt)len_max=cnt;\n\t\t\treturn len_max;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=n;i++){\n\t\tif(ARR[route[cnt]][i]){\n\t\t\troute[cnt+1]=i;\n\t\t\tDFS(route,cnt+1);\n\t\t\troute[cnt+1]=0;\n\t\t}\n\t}\n\treturn len_max;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,c[101]={0};\nint d[101][101]={0};\nint f(int b,int t){\n  int i,r,max=t;\n  for(i=1;i<=n;i++){\n    if(c[i])continue;\n    if(d[b][i]==0)continue;\n    c[i]=1;\n    r=f(i,t+1);\n    if(max<r)max=r;\n    c[i]=0;\n  }\n  return max;\n}\nint main(){\n  int i,a,b,r,max=0;\n  while(scanf(\"%d\",&n),n){\n    for(i=max=0;i<10000;i++)d[i/100+1][i%100+1]=c[i%100+1]=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[a][b]=d[b][a]=1;\n    }\n    for(i=1;i<=n;i++){\n      c[i]=1;\n      r=f(i,1);\n      c[i]=0;\n      if(max<r)max=r;\n    }\n    printf(\"%d\\n\",max);\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n;\nint c[100][2];\n\nint chain(int e,int l,int done[]){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  int copy[100];\n  prol = nowl = l;\n  for(i=0;i<100;i++){\n    copy[i]=done[i];\n  }\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1,copy);\n      copy[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1,copy);\n      copy[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int done[100];\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0,done);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint adj[100][100];\nint vertex;\nint ans;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dfs(int v, int num, int *vis)\n{\n    int i;\n    int flag;\n    \n    flag = 0;\n    for (i = 0; i < vertex; i++){\n        if (adj[v][i] && vis[i] == 0){\n            adj[v][i] =  0;\n            vis[i] = 1;\n            dfs(i, num + 1, vis);\n            adj[v][i] = 1;\n            vis[i] = 0;\n          }\n    }\n    if (flag == 0){\n        ans = ans > num ? ans : num;\n    }\n    return;\n}\n\nint main(void)\n{\n    int vis[100];\n    int n;\n    int i, j;\n    int from, to;\n    int count[100], u[100], mc;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(count, 0, sizeof(count));\n        memset(adj, 0, sizeof(adj));\n        vertex = 0;\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &from, &to);\n            vertex = vertex < from ? from : vertex;\n            vertex = vertex < to ? to : vertex;\n            from--;\n            to--;\n            count[to]++;\n            adj[from][to] = adj[to][from] = 1;\n        }\n        \n        mc = 10000;\n        for (i = 0; i < vertex; i++){\n            if (count[i] != 0){\n                mc = count[i] < mc ? count[i] : mc;\n            }\n        }\n        ans = 0;\n        memset(u, 0, sizeof(u));\n        for (i = 0; i < vertex; i++){\n            if (count[i] == mc && u[count[i]] <= 10){\n                memset(vis, 0, sizeof(vis));\n                vis[i] = 1;\n                u[count[i]]++;\n                dfs(i, 1, vis);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n,G[100][100];\nint D[100];\n\nint size(int m)\n{\n    int r=1;\n    for(int i=0;i<100;i++){\n        if(G[m][i]&&!D[i]){\n            D[i]=1;\n            r=max(r,1+size(i));\n            D[i]=0;\n        }\n    }\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n),n){\n        int r=0;\n        memset(G,0,sizeof(G));\n        while(n--){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            G[a-1][b-1]=G[b-1][a-1]=1;\n        }\n        for(int i=0;i<100;i++){\n            memset(D,0,sizeof(D));\n            D[i]=1;\n            r=max(r,size(i));\n            D[i]=0;\n        } \n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n;\nint c[100][2];\n\nint chain(int e,int l,int done[]){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int done;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0,done);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint adj[100][100];\nint vertex;\nint ans;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dfs(int v, int num, int *vis)\n{\n    int i;\n    int flag;\n    \n    flag = 0;\n    for (i = 0; i < vertex; i++){\n        if (adj[v][i] && vis[i] == 0){\n            adj[v][i] =  0;\n            vis[i] = 1;\n            dfs(i, num + 1, vis);\n            adj[v][i] = 1;\n            vis[i] = 0;\n          }\n    }\n    if (flag == 0){\n        ans = ans > num ? ans : num;\n    }\n    return;\n}\n\nint main(void)\n{\n    int vis[100];\n    int n;\n    int i, j;\n    int from, to;\n    int count[100], mc;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(count, 0, sizeof(count));\n        memset(adj, 0, sizeof(adj));\n        vertex = 0;\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &from, &to);\n            vertex = vertex < from ? from : vertex;\n            vertex = vertex < to ? to : vertex;\n            from--;\n            to--;\n            count[from]++;\n            count[to]++;\n            adj[from][to] = adj[to][from] = 1;\n        }\n        \n        mc = 10000;\n        \n        for (i = 0; i < vertex; i++){\n            if (count[i] != 0){\n                mc = mc > count[i] ? count[i] : mc;\n            }\n        }\n        \n        ans = 0;\n        for (i = 0; i < vertex; i++){\n            if (mc >= count[i] - 1){\n                memset(vis, 0, sizeof(vis));\n                vis[i] = 1;\n                if (n == 100 && ans == 9){\n                    break;\n                }\n                dfs(i, 1, vis);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pf[101],connect[101][101],numb[100],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path;\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tfor(i=0;i<101;i++){\n    \t\tnumb[i]=0;\n    \t\tpf[i]=0;\n    \t\tfor(j=0;j<101;j++){\n    \t\t\tconnect[i][j]=0;\n    \t\t}\n    \t}\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n            search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint adj[100][100];\nint vertex;\nint ans;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dfs(int v, int num, int *vis)\n{\n    int i;\n    int flag;\n    \n    flag = 0;\n    for (i = 0; i < vertex; i++){\n        if (adj[v][i] && vis[i] == 0){\n            adj[v][i] =  0;\n            vis[i] = 1;\n            dfs(i, num + 1, vis);\n            adj[v][i] = 1;\n            vis[i] = 0;\n          }\n    }\n    if (flag == 0){\n        ans = ans > num ? ans : num;\n    }\n    return;\n}\n\nint main(void)\n{\n    int vis[100];\n    int n;\n    int i, j;\n    int from, to;\n    int count[100], mc;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(count, 0, sizeof(count));\n        memset(adj, 0, sizeof(adj));\n        vertex = 0;\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &from, &to);\n            vertex = vertex < from ? from : vertex;\n            vertex = vertex < to ? to : vertex;\n            from--;\n            to--;\n            count[from]++;\n            count[to]++;\n            adj[from][to] = adj[to][from] = 1;\n        }\n        \n        ans = 0;\n        for (i = 0; i < vertex; i++){\n            memset(vis, 0, sizeof(vis));\n            vis[i] = 1;\n            dfs(i, 1, vis);\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \nint strings_count[101];\nint strings_from[101][100];\nint visited[101];\n\nint longest_from(int start);\n\nint main()\n{\n\twhile (1) {\n\t\tint n;\n\t\tint i;\n\t\tint longest;\n\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(strings_from, 0, sizeof(strings_from));\n\t\tmemset(strings_count, 0, sizeof(strings_count));\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tstrings_from[a][strings_count[a]++] = b;\n\t\t\tstrings_from[b][strings_count[b]++] = a;\n\t\t}\n\n\t\tlongest = 0;\n\t\tfor (i = 1; i <= 100; i++) {\n\t\t\tif (strings_count[i] > 0) {\n\t\t\t\tint longest_tmp;\n\t\t\t\tlongest_tmp = longest_from(i);\n\t\t\t\tif (longest_tmp > longest) {\n\t\t\t\t\tlongest = longest_tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", longest);\n\t}\n\n\treturn 0;\n}\n\nint longest_from(int start)\n{\n\tint i;\n\tint longest;\n\tlongest = 0;\n\tvisited[start] = 1;\n\tfor (i = 0; i < strings_count[start]; i++) {\n\t\tint next;\n\t\tnext = strings_from[start][i];\n\t\tif (!visited[next]) {\n\t\t\tint longest_tmp;\n\t\t\tlongest_tmp = longest_from(next);\n\t\t\tif (longest_tmp > longest) {\n\t\t\t\tlongest = longest_tmp;\n\t\t\t}\n\t\t}\n\t}\n\tvisited[start] = 0;\n\treturn longest + 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<memory.h>\n#define SMAX 330 //=0*1+1*2+2*3+...+9*10\nint C[SMAX+1][1<<10];\nint count(int n, int s, int B)\n{\n\tint i, c, b;\n\tif (n == 0) {\n\t\treturn s==0;\n\t} else {\n\t\tif (C[s][B] >= 0)\n\t\t\treturn C[s][B];\n\t\tc = 0;\n\t\tfor (i = 0; i < 10; i ++){\n\t\t\tb = 1<<i;\n\t\t\tif (!(B & b) && n*i <= s){\n\t\t\t\tc += count(n-1, s-n*i, B|b);\n\t\t\t}\n\t\t}\n\t\treturn C[s][B]=c;\n\t}\n}\nint main()\n{\n\tint n, s, c;\n\tmemset(C, -1, sizeof(C));\n\twhile (~scanf(\"%d%d\", &n, &s)){\n\t\tif (s <= SMAX)\n\t\t\tc = count(n, s, 0);\n\t\telse\n\t\t\tc = 0;\n\t\tprintf(\"%d \\n\", c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint neib[101][200];\nint used[101];\nint onceused[101];\nint rings[105];\nint dfs(int x){\n  int i;\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(i = 1;i <= neib[x][0];i++){\n    if(used[neib[x][i]] == 0){\n      int tmp = dfs(neib[x][i]);\n      res = max(res, 1 + tmp);\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    rings[0] = 0;\n    for(i = 0;i < 101;i++)neib[i][0] = 0;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings[++rings[0]] = a;\n      rings[++rings[0]] = b;\n      neib[a][++neib[a][0]] = b;\n      neib[b][++neib[b][0]] = a;\n    }\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    for(i = 1;i < 101;i++){\n      for(j = 1;j <= rings[0];j++){\n\tif(neib[rings[j]][0] == i){\n\t  int tmp = dfs(rings[j]);\n\t  ans = max(ans,tmp);\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j <= rings[0];j++){\n\tif(onceused[rings[j]] == 0){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n;\nint done[100];\nint c[100][2];\n\nint chain(int e,int l){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "//A0508\n//@kankichi573\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nchar adjoin[101][101];\nchar visit[101];\nchar nofhen;\nint ret;\n\nvoid solve(int node,int depth)\n{\n        int i;\n\n        for(i=1;i<=nofhen;i++)\n                if(adjoin[node][i] && visit[i]==0)\n                {\n                        visit[i]=1;\n                        adjoin[node][i]=0;\n                        solve(i,depth+1);\n                        visit[i]=0;\n                        adjoin[node][i]=1;\n                }\n        ret=max(ret,depth);\n\n}\nmain()\n{\n        int i,from,to,n;\n\n\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                memset(adjoin,0,sizeof(adjoin));\n                nofhen=0;\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&from,&to);\n                        nofhen=max(nofhen,from);\n                        nofhen=max(nofhen,to);\n                        adjoin[from][to]=adjoin[to][from]=1;\n                }\n                ret=0;\n                for(i=1;i<=nofhen;i++)\n                {\n                        memset(visit,0,sizeof(visit));\n                        visit[i]=1;\n                        solve(i,1);\n                }\n                printf(\"%d\\n\", ret);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "e[101][100],n[101],v[101],x;\nW(a,l){\n\tint i,b;\n\tv[a]=1;\n\tif(++l>x)\n\t\tx=l;\n\tfor(i=0;i<n[a];i++){\n\t\tb=e[a][i];\n\t\tif(!v[b])\n\t\t\tW(b,l);\n\t}\n\tv[a]=0;\n}\nmain(m,a,b){\n\tfor(;scanf(\"%d\",&m)*m;){\n\t\tmemset(n,0,sizeof(n));\n\t\tmemset(v,0,sizeof(v));\n\t\tx=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\te[a][n[a]++]=b;\n\t\t\te[b][n[b]++]=a;\n\t\t}\n\t\tfor(a=1;a<=100;a++){\n\t\t\tif(n[a])\n\t\t\t\tW(a,0);\n\t\t}\n\t\tprintf(\"%d \\n\",x);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "e[101][101],v[101],x,l;\nW(a,i,b){\n\tif(!v[a]){\n\t\tv[a]=1;\n\t\t++l>x?x=l:0;\n\t\tfor(i=0;b=e[a][++i];){\n\t\t\tW(b);\n\t\t}\n\t\tl--;\n\t\tv[a]=0;\n\t}\n}\nmain(m,a,b){\n\tfor(;scanf(\"%d\",&m)*m;){\n\t\tmemset(e,0,sizeof(e));\n\t\tx=0;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\te[a][++e[a][0]]=b;\n\t\t\te[b][++e[b][0]]=a;\n\t\t}\n\t\tfor(a=100;a;){\n\t\t\tW(a--);\n\t\t}\n\t\tprintf(\"%d \\n\",x);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint t[101][101];\nint size[101];\nint notEnd[101];\nint used[101];\n\nint solve(int idx,int s){\n\tint i,tmp,res=0;\n\n\tnotEnd[idx] = 0;\n\tused[idx] = 1;\n\n\trep(i,size[idx]){\n\t\tif(!used[t[idx][i]]){\n\t\t\ttmp = solve(t[idx][i],s);\n\t\t\tif(res < tmp) res = tmp;\n\t\t}\n\t}\n\tused[idx] = 0;\n\n\treturn res+1;\n}\n\nint main(void){\n\tint i,j;\n\tint n,from,to;\n\tint max,breakFlg,tmp;\n\n\twhile(scanf(\"%d\",&n) && n){\n\t\tmemset(t,0,sizeof(t));\n\t\tmemset(size,0,sizeof(size));\n\t\tmemset(notEnd,0,sizeof(notEnd));\n\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",&from,&to);\n\t\t\tt[from][size[from]++] = to;\n\t\t\tt[to][size[to]++] = from;\n\t\t\tnotEnd[from] = notEnd[to] = 1;\n\t\t}\n\n\t\tmax = 0;\n\t\tmemset(used,0,sizeof(used));\n\n\t\tfor(j=1;;j++){\n\t\t\tREP(i,1,101){\n\t\t\t\tif(size[i] == j){\n\t\t\t\t\ttmp = solve(i,j);\n\t\t\t\t\tif(max < tmp) max = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreakFlg = 1;\n\t\t\tREP(i,1,101){\n\t\t\t\tif(notEnd[i]){\n\t\t\t\t\tbreakFlg = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(breakFlg) break;\n\t\t}\n\n\t\tprintf(\"%d\\n\",max);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n\tint a;\n\tint b;\n} thread;\n\nthread rope[100];\nint n;\n\nvoid search(int now,int num,int *f,int *v,int *pf,int *maxpath){\n\tint j,pbf=0;\n\tif(pf[now]==0){\n\t\tpbf=1;\n\t\tpf[now]=1;\n\t}\n\tfor(j=0;j<n;j++){\n\t\tif(rope[j].a==now || rope[j].b==now){//find string with i\n\t\t\tif(f[j]==0){\n\t\t\t\tv[num]=j;\n\t\t\t\tf[j]=1;//flag on\n\t\t\t\tnum++;//increase numberk\n\t\t\t\tsearch((rope[j].b==now)?rope[j].a:rope[j].b,num,f,v,pf,maxpath);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t}\n\tif(num>0) f[v[num-1]]=0;\n\tif(pbf==1){\n\t\tpbf=0;\n\t\tfor(j=0;j<100;j++){\n\t\t\tpbf+=pf[j];\n\t\t}\n\t\tif(*maxpath<pbf) *maxpath=pbf; //max check\n\t\tpf[now]=0;\n\t}\n}\n\nint main(){\n\tint i,a,b,maxpath,v[100],num,f[100],j,pf[100];\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\trope[i].a=a;\n\t\t\trope[i].b=b;\n\t\t}\n\t\tmaxpath=1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=0;j<100;j++){\n\t\t\t\tf[j]=0;//string status\n\t\t\t\tpf[j]=0;\n\t\t\t}\n\t\t\tpf[i]=1;\n\t\t\tsearch(i,0,f,v,pf,&maxpath);\n\t\t}\n\t\tprintf(\"%d\\n\",maxpath);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pf[101],connect[101][101],numb[100],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path; //max check\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tfor(i=0;i<101;i++){\n    \t\tnumb[i]=0;\n    \t\tfor(j=0;j<101;j++){\n    \t\t\tconnect[i][j]=0;\n    \t\t}\n    \t}\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n            search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_NODE 100\n\ntypedef struct {\n\tint dest_num;\n\tint dest[MAX_NODE];\n\tint pass_flag;\n} node_t;\n\nnode_t nodes[MAX_NODE];\n\nint get_depth(int start, int cur_depth)\n{\n\tint i;\n\n\tif(nodes[start].pass_flag) {\n\t\treturn cur_depth;\n\t} else {\n\t\tint max_depth = cur_depth + 1;\n\n\t\tnodes[start].pass_flag = 1;\n\n\t\tfor(i = 0; i < nodes[start].dest_num; i++) {\n\t\t\tint partial_depth = get_depth(nodes[start].dest[i], cur_depth + 1);\n\n\t\t\tif(partial_depth > max_depth) max_depth = partial_depth;\n\t\t}\n\n\t\tnodes[start].pass_flag = 0;\n\t\treturn max_depth;\n\t}\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tint i, str_num, src, dest;\n\n\t\tscanf(\"%d\", &str_num);\n\n\t\tif(str_num == 0) break;\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tnodes[i].dest_num = 0;\n\t\t}\n\n\t\tfor(i = 0; i < str_num; i++) {\n\t\t\tscanf(\"%d%d\", &src, &dest);\n\n\t\t\tnodes[src].dest[nodes[src].dest_num++] = dest;\n\t\t\tnodes[dest].dest[nodes[dest].dest_num++] = src;\n\t\t}\n\n\t\tint max_depth = 0;\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tnodes[i].pass_flag = 0;\n\t\t}\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tint partial_depth;\n\n\t\t\tpartial_depth = get_depth(i, 0);\n\n\t\t\tif(max_depth < partial_depth) max_depth = partial_depth;\n\t\t}\n\n\t\tprintf(\"%d\\n\", max_depth);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//A0508\n//@kankichi573\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nchar adjoin[101][101];\nchar visit[101];\nchar nofhen;\nchar count[101];\nint ret;\nint mc;\n\nvoid solve(int node,int depth)\n{\n        int i;\n\n        for(i=1;i<=nofhen;i++)\n                if(adjoin[node][i] && visit[i]==0)\n                {\n                        visit[i]=1;\n                        adjoin[node][i]=0;\n                        solve(i,depth+1);\n                        visit[i]=0;\n                        adjoin[node][i]=1;\n                }\n        ret=max(ret,depth);\n\n}\nmain()\n{\n        int i,from,to,n,c;\n\n\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                memset(adjoin,0,sizeof(adjoin));\n                memset(count ,0,sizeof(count ));\n                nofhen=0;\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&from,&to);\n                        nofhen=max(nofhen,from);\n                        nofhen=max(nofhen,to);\n                        adjoin[from][to]=adjoin[to][from]=1;\n                        count[to]++;\n                        //count[from]++;\n                }\n                ret=0;mc=INT_MAX;\n                for(i=1;i<=nofhen;i++)\n                {\n                        if((c=count[i]))\n                                mc=min(mc,c);\n                }\n                for(i=1;i<=nofhen;i++)\n                {\n                        if(count[i]>mc)\n                                continue;\n                        memset(visit,0,sizeof(visit));\n                        visit[i]=1;\n                        solve(i,1);\n                }\n                printf(\"%d\\n\", ret);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "e[124][101],v[101],x,l;W(a,i,b){++l>x?x=l:0;for(i=v[a]=1;b=e[a][i++];)v[b]||W(b);v[a]=!l--;}main(m,a,b){for(;scanf(\"%d\",&m)*m;x=!printf(\"%d\\n\",x)){for(bzero(e,5e4);m--;e[e[a][++*e[a]]=b][++*e[b]]=a)scanf(\"%d%d\",&a,&b);for(a=101;--a;)v[a]||W(a);}}"
  },
  {
    "language": "C",
    "code": "// AOJ 0508: String With Rings\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint to[102][102], sz[102];\nchar mk[102];\nint ans;\n\nvoid dfs(int x, int len)\n{\n\tint i;\n\n\tif (len > ans) ans = len;\n    mk[x] = 1;\n\tfor (i = 0; i < sz[x]; i++) {\n\t\tif (!mk[to[x][i]]) dfs(to[x][i], len+1);\n    }\n\tmk[x] = 0;\n}\n \nint main()\n{\n    int n, m, i, a, b, min;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(sz, 0, sizeof(sz));\n\t    for (m = 0, i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (a > m) m = a;\n\t\t\tif (b > m) m = b;\n\t\t\ta--, b--;\n\t\t\tto[a][sz[a]++] = b, to[b][sz[b]++] = a;\n\t    }\n\t\tmin = 1000;\n\t\tfor (i = 0; i < m; i++) if (sz[i] > 0 && sz[i] < min) min = sz[i];\n\n\t\tans = 0;\n\t\tmemset(mk, 0, m);\n\t\tfor (i = 0; i < m; i++) if (sz[i] == min) dfs(i, 1);\n\t\tprintf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n\tint a;\n\tint b;\n} thread;\n\nthread rope[100];\nint n;\n\nvoid search(int now,int *pf,int path,int *maxpath){\n\tint j,pbf=0;\n\tif(pf[now]==0){\n\t\tpbf=1;\n\t\tpf[now]=1;\n\t\tpath++;\n\t\tif(*maxpath<path) *maxpath=path; //max check\n\t}\n\tfor(j=0;j<n;j++){\n\t\tif(rope[j].a==now || rope[j].b==now){//find string with i\n\t\t\tif(pf[(rope[j].b==now)?rope[j].a:rope[j].b]==0){\n\t\t\t\tsearch((rope[j].b==now)?rope[j].a:rope[j].b,pf,path,maxpath);\n\t\t\t}\n\t\t}\n\t}\n\tif(pbf==1){\n\t\tpf[now]=0;\n\t}\n}\n\nint main(){\n\tint i,a,b,maxpath,j,pf[100];\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\trope[i].a=a;\n\t\t\trope[i].b=b;\n\t\t}\n\t\tmaxpath=1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=0;j<100;j++){\n\t\t\t\tpf[j]=0;\n\t\t\t}\n\t\t\tsearch(i,pf,0,&maxpath);\n\t\t}\n\t\tprintf(\"%d\\n\",maxpath);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint neib[101][200];\nint used[101];\nint onceused[101];\nint rings[105];\nint dfs(int x){\n  int i;\n  used[x] = 1;\n  onceused[x] = 0;\n  int res = 1;\n  for(i = 0;i < rings[x];i++){\n    if(used[neib[x][i]] == 0){\n      int tmp = dfs(neib[x][i]);\n      res = max(res, 1 + tmp);\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    memset(rings, 0, sizeof(rings));\n    memset(neib, 0, sizeof(neib));\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      onceused[a] =onceused[b] = 1;\n      neib[a][rings[a]++] = b;\n      neib[b][rings[b]++] = a;\n    }\n\n    for(i = 1;;i++){\n      for(j = 1;j < 101 ;j++){\n\tif(rings[j] == i){\n\t  int tmp = dfs(j);\n\t  ans = max(ans,tmp);\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j < 101;j++){\n\tif(onceused[i] == 1){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n;\nint c[100][2];\n\nint chain(int e,int l,int done[]){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int done[100];\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0,done);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint neib[101][200];\nint used[101];\nint onceused[101];\nint rings[105];\nint dfs(int x){\n  int i;\n  used[x] = 1;\n  onceused[x] = 0;\n  int res = 1;\n  for(i = 1;i <= neib[x][0];i++){\n    if(used[neib[x][i]] == 0){\n      int tmp = dfs(neib[x][i]);\n      res = max(res, 1 + tmp);\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    memset(rings, 0, sizeof(rings));\n    memset(neib, 0, sizeof(neib));\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      onceused[a] =onceused[b] = 1;\n      neib[a][rings[a]++] = b;\n      neib[b][rings[b]++] = a;\n    }\n\n    for(i = 1;;i++){\n      for(j = 1;j < 101 ;j++){\n\tif(rings[j] == i){\n\t  int tmp = dfs(j);\n\t  ans = max(ans,tmp);\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j < 101;j++){\n\tif(onceused[i] == 1){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n,pf[101],connect[101][101],numb[101],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path;\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tmemset(numb,0,sizeof(numb));\n    \tmemset(connect,0,sizeof(connect));\n    \tmemset(pf,0,sizeof(pf));\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n        \tif(numb[i]>0) search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n;\nint c[100][2];\n\nint chain(int e,int l,int done[]){ /*done???????????°????????¨??¶??????????????????e??????????????????l???*/\n  int i;\n  int prol,nowl;\n  prol = nowl = l;\n  for(i=0;i<n;i++){\n    if(c[i][0]==e && done[c[i][1]-1]==0){\n      prol = chain(c[i][1],nowl+1,done);\n      done[c[i][1]-1] = 1;\n    }\n    if(c[i][1]==e && done[c[i][0]-1]==0){\n      prol = chain(c[i][0],nowl+1,done);\n      done[c[i][0]-1] = 1;\n    }\n    if(prol>l){\n      l = prol;\n    }\n  }\n  return l;\n}\n\nmain(){\n  int i;\n  int done[100];\n  int ans,preans;\n  while(scanf(\"%d\",&n)!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&c[i][0],&c[i][1]);\n    }\n    for(i=0;i<100;i++){\n      done[i]=0;\n    }\n    ans = 0;\n    for(i=1;i<=100;i++){\n      preans = chain(i,0,done);\n      if(preans>ans){\n        ans = preans;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_NODE 200\n\ntypedef struct {\n\tint dest_num;\n\tint dest[MAX_NODE];\n\tint pass_flag;\n} node_t;\n\nnode_t nodes[MAX_NODE];\n\nint get_depth(int start, int cur_depth)\n{\n\tint i;\n\n\tif(nodes[start].pass_flag) {\n\t\treturn cur_depth;\n\t} else {\n\t\tint max_depth = cur_depth + 1;\n\n\t\tnodes[start].pass_flag = 1;\n\n\t\tfor(i = 0; i < nodes[start].dest_num; i++) {\n\t\t\tint partial_depth = get_depth(nodes[start].dest[i], cur_depth + 1);\n\n\t\t\tif(partial_depth > max_depth) max_depth = partial_depth;\n\t\t}\n\n\t\tnodes[start].pass_flag = 0;\n\t\treturn max_depth;\n\t}\n}\n\nint main(void)\n{\n\twhile(1) {\n\t\tint i, str_num, src, dest;\n\n\t\tscanf(\"%d\", &str_num);\n\n\t\tif(str_num == 0) break;\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tnodes[i].dest_num = 0;\n\t\t}\n\n\t\tfor(i = 0; i < str_num; i++) {\n\t\t\tscanf(\"%d%d\", &src, &dest);\n\n\t\t\tnodes[src].dest[nodes[src].dest_num++] = dest;\n\t\t\tnodes[dest].dest[nodes[dest].dest_num++] = src;\n\t\t}\n\n\t\tint max_depth = 0;\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tnodes[i].pass_flag = 0;\n\t\t}\n\n\t\tfor(i = 0; i < MAX_NODE; i++) {\n\t\t\tint partial_depth;\n\n\t\t\tpartial_depth = get_depth(i, 0);\n\n\t\t\tif(max_depth < partial_depth) max_depth = partial_depth;\n\t\t}\n\n\t\tprintf(\"%d\\n\", max_depth);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pf[101],connect[101][100],numb[100],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path; //max check\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tfor(i=0;i<101;i++){\n    \t\tnumb[i]=0;\n    \t\tfor(j=0;j<100;j++){\n    \t\t\tconnect[i][j]=0;\n    \t\t}\n    \t}\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n            search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "//A0508\n//@kankichi573\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nchar adjoin[101][101];\nchar visit[101];\nchar nofhen;\nint ret;\n\nvoid solve(int node,int depth)\n{\n        int i;\n\n        for(i=1;i<=nofhen;i++)\n                if(adjoin[node][i] && visit[i]==0)\n                {\n                        visit[i]=1;\n                        solve(i,depth+1);\n                        visit[i]=0;\n                                                                        \n                }\n        ret=max(ret,depth);\n\n}\nmain()\n{\n        int i,from,to,n;\n\n\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                memset(adjoin,0,sizeof(adjoin));\n                nofhen=0;\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&from,&to);\n                        nofhen=max(nofhen,from);\n                        nofhen=max(nofhen,to);\n                        adjoin[from][to]=adjoin[to][from]=1;\n                }\n                ret=0;\n                for(i=1;i<=nofhen;i++)\n                {\n                        memset(visit,0,sizeof(visit));\n                        visit[i]=1;\n                        solve(i,1);\n                }\n                printf(\"%d\\n\", ret);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pf[101],connect[101][101],numb[101],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path;\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tfor(i=0;i<101;i++){\n    \t\tnumb[i]=0;\n    \t\tpf[i]=0;\n    \t\tfor(j=0;j<101;j++){\n    \t\t\tconnect[i][j]=0;\n    \t\t}\n    \t}\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n            search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pf[101],connect[101][101],numb[100],maxpath=1;\n \nvoid search(int now,int path){\n    int j;\n    pf[now]=1;\n    path++;\n    if(maxpath<path) maxpath=path; //max check\n    for(j=0;connect[now][j]>0;j++){\n        if(pf[connect[now][j]]==0){\n                search(connect[now][j],path);\n        }\n    }\n    pf[now]=0;\n}\n \nint main(){\n    int i,a,b,j;\n    scanf(\"%d\",&n);\n    while(n!=0){\n    \tfor(i=0;i<101;i++){\n    \t\tnumb[i]=0;\n    \t\tfor(j=0;j<101;j++){\n    \t\t\tconnect[i][j]=0;\n    \t\t}\n    \t}\n        for(i=0;i<n;i++){\n            scanf(\"%d %d\",&a,&b);\n            connect[a][numb[a]]=b;\n            connect[b][numb[b]]=a;\n            numb[a]++;\n            numb[b]++;\n        }\n        maxpath=1;\n        for(i=1;i<=100;i++){\n            search(i,0);\n        }\n        printf(\"%d\\n\",maxpath);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(x,y) ((x) > (y) ? (x) : (y))\n#define min(x,y) ((x) < (y) ? (x) : (y))\n\nint neib[101][200];\nint used[101];\nint onceused[101];\nint rings[105];\nint dfs(int x){\n  int i;\n  used[x] = 1;\n  onceused[x] = 0;\n  int res = 1;\n  for(i = 0;i <= rings[x];i++){\n    if(used[neib[x][i]] == 0){\n      int tmp = dfs(neib[x][i]);\n      res = max(res, 1 + tmp);\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\n\nint main(){\n  int i, j;\n  while(1){\n    int n, ans = 0;\n    memset(rings, 0, sizeof(rings));\n    memset(neib, 0, sizeof(neib));\n    memset(onceused, 0, sizeof(onceused));\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      onceused[a] =onceused[b] = 1;\n      neib[a][rings[a]++] = b;\n      neib[b][rings[b]++] = a;\n    }\n\n    for(i = 1;;i++){\n      for(j = 1;j < 101 ;j++){\n\tif(rings[j] == i){\n\t  int tmp = dfs(j);\n\t  ans = max(ans,tmp);\n\t}\n      }\n      int fin = 1;\n      for(j = 1;j < 101;j++){\n\tif(onceused[i] == 1){\n\t  fin = 0;\n\t  break;\n\t}\n      }\n      if(fin)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint adj[100][100];\nint vertex;\nint ans;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dfs(int v, int num, int *vis)\n{\n    int i;\n    int flag;\n    \n    flag = 0;\n    for (i = 0; i < vertex; i++){\n        if (adj[v][i] && vis[i] == 0){\n            adj[v][i] =  0;\n            vis[i] = 1;\n            dfs(i, num + 1, vis);\n            adj[v][i] = 1;\n            vis[i] = 0;\n          }\n    }\n    if (flag == 0){\n        ans = ans > num ? ans : num;\n    }\n    return;\n}\n\nint main(void)\n{\n    int vis[100];\n    int n;\n    int i, j;\n    int from, to;\n    int count[100], u[100], mc;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(count, 0, sizeof(count));\n        memset(adj, 0, sizeof(adj));\n        vertex = 0;\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &from, &to);\n            vertex = vertex < from ? from : vertex;\n            vertex = vertex < to ? to : vertex;\n            from--;\n            to--;\n            count[to]++;\n            adj[from][to] = adj[to][from] = 1;\n        }\n        \n        mc = 10000;\n        for (i = 0; i < vertex; i++){\n            if (count[i] != 0){\n                mc = count[i] < mc ? count[i] : mc;\n            }\n        }\n        ans = 0;\n        memset(u, 0, sizeof(u));\n        for (i = vertex - 1; i >= 0; i--){\n            if (count[i] == mc && u[count[i]] <= 10){\n                memset(vis, 0, sizeof(vis));\n                vis[i] = 1;\n                u[count[i]]++;\n                dfs(i, 1, vis);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nshort int map[101][101],len[101],done[101];\n\nint recur(int n,int cnt){\n  int i,ans=0;\n  done[n] = 1;\n  for(i=0; i<len[n]; i++)\n    if(!done[map[n][i]]){\n      int cnd = recur(map[n][i],cnt+1);\n      ans = ans>cnd?ans:cnd; \n    }\n  done[n] = 0;\n  return (ans==0)?cnt+1:ans;\n}\n\nint main(){\n  int n,i;\n  while(1){\n    int ans = 0;\n\n    for(i=0; i<101; i++)\n      len[i]=done[i]=0;\n\n    scanf(\"%d\",&n);\n    if(n==0) break;\n\n    for(i=0; i<n; i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      map[a][len[a]++] = b;\n      map[b][len[b]++] = a;\n    }\n\n    for(i=1; i<=100; i++)\n      if(len[i]!=0){\n\tint cnd = recur(i,0);\n\tans = ans>cnd?ans:cnd;\n      }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nclass Node{\n    val edges = mutableListOf<Node>()\n    var confirmed:Boolean = false\n    fun addEdge(node:Node):Unit{\n        edges.add(node)\n    }\n    fun recycle():Unit {\n        edges.removeAll({true})\n    }\n}\nfun maxLength(node:Node):Int {\n    if (node.confirmed) return 0\n    else{\n        node.confirmed = true\n        val res = node.edges.filter{!it.confirmed}.map{maxLength(it)}.max()?.let{it + 1} ?: 1\n        node.confirmed = false\n        return res\n    }\n}\nfun solve(num:Int):Unit {\n    var n = num\n    val nodes = Array(101, {Node()})\n    while(n != 0) {\n        nodes.forEach { it.recycle() }\n        for (i in 0 until n) {\n            val (a, b) = readLine()!!.split(' ').map(String::toInt)\n            nodes[a].addEdge(nodes[b])\n            nodes[b].addEdge(nodes[a])\n        }\n        var max = 0\n        for (i in 1..n) {\n            maxLength(nodes[i]).let {\n                if (it > max) max = it\n            }\n        }\n\n        println(max)\n        n = readLine()!!.toInt()\n    }\n}\nfun main(args:Array<String>):Unit{\n    solve(readLine()!!.toInt())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class Node{\n    val edges = mutableListOf<Node>()\n    var confirmed:Boolean = false\n    fun addEdge(node:Node):Unit{\n        edges.add(node)\n    }\n}\nfun maxLength(node:Node):Int {\n    if (node.confirmed) return 0\n    else{\n        node.confirmed = true\n        val res = node.edges.filter{!it.confirmed}.map{maxLength(it)}.max()?.let{it + 1} ?: 1\n        node.confirmed = false\n        return res\n    }\n}\nfun solve(n:Int):Unit {\n    val nodes = Array(101, {Node()})\n    for (i in 0 until n){\n        val (a, b) = readLine()!!.split(' ').map(String::toInt)\n        nodes[a].addEdge(nodes[b])\n        nodes[b].addEdge(nodes[a])\n    }\n    var max = 0\n    for (i in 1 .. n){\n        maxLength(nodes[i]).let{\n            if (it > max) max = it\n        }\n    }\n    println(max)\n    readLine()!!.toInt().let{\n        if (it != 0) solve(it)\n    }\n}\nfun main(args:Array<String>):Unit{\n    solve(readLine()!!.toInt())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "class Node{\n    val edges = mutableListOf<Node>()\n    var passed:Boolean = false\n    var confirmed:Boolean = false\n    fun addEdge(node:Node):Unit{\n        edges.add(node)\n    }\n}\nfun searchFirstPass(node:Node):Pair<Int, Node>{\n    if (node.passed) return Pair(0, node)\n    else {\n        node.passed = true\n        val res = node.edges.filter { !it.passed }.map{searchFirstPass(it)}.maxBy { (l, n) -> l }?.let { (l, n) -> Pair(l + 1, n) } ?: Pair(1, node)\n        node.passed = false\n        return res\n    }\n}\nfun searchSecondPass(node:Node):Int {\n    if (node.confirmed) return 0\n    else{\n        node.confirmed = true\n        val res = node.edges.filter{!it.confirmed}.map{searchSecondPass(it)}.max()?.let{it + 1} ?: 1\n        node.confirmed = false\n        return res\n    }\n}\nfun maxLength(node:Node):Int {\n    val (_, far) = searchFirstPass(node)\n    return searchSecondPass(far)\n}\nfun solve(n:Int):Unit {\n    val nodes = Array(101, {Node()})\n    for (i in 0 until n){\n        val (a, b) = readLine()!!.split(' ').map(String::toInt)\n        nodes[a].addEdge(nodes[b])\n        nodes[b].addEdge(nodes[a])\n    }\n    var max = 0\n    for (i in 1 .. n){\n        searchSecondPass(nodes[i]).let{\n            if (it > max) max = it\n        }\n    }\n    println(max)\n    readLine()!!.toInt().let{\n        if (it != 0) solve(it)\n    }\n}\nfun main(args:Array<String>):Unit{\n    solve(readLine()!!.toInt())\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int dfs(Map<Integer, List<Integer>> m, boolean[] visited, int cur, int l) {\n\t\tvisited[cur] = true;\n\t\tList<Integer> el = m.get(cur);\n\t\tif (el == null)\n\t\t\treturn l;\n\t\tint len = l;\n\t\tfor (int e : el) {\n\t\t\tif (!visited[e]) {\n\t\t\t\tlen = Math.max(len, dfs(m, visited, e, l + 1));\n\t\t\t}\n\t\t}\n\t\tvisited[cur] = false;\n\t\treturn len;\n\t}\n\n\tpublic static Map<Integer, List<Integer>> adjMap(int[][] edge) {\n\t\tMap<Integer, List<Integer>> m = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\tList<Integer> el = m.get(edge[i][0]);\n\t\t\tif (el == null)\n\t\t\t\tel = new LinkedList<Integer>();\n\t\t\tel.add(edge[i][1]);\n\t\t\tm.put(edge[i][0], el);\n\t\t}\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n * 2][2];\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i * 2 + 1][1] = p[i * 2][0] = s.nextInt();\n\t\t\t\tp[i * 2 + 1][0] = p[i * 2][1] = s.nextInt();\n\t\t\t\tif (p[i * 2][0] > max)\n\t\t\t\t\tmax = p[i * 2][0];\n\t\t\t\tif (p[i * 2][1] > max)\n\t\t\t\t\tmax = p[i * 2][1];\n\t\t\t}\n\n\t\t\tMap<Integer, List<Integer>> m = adjMap(p);\n\t\t\tboolean[] visited = new boolean[max + 1];\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\td = Math.max(d, dfs(m, visited, i, 1));\n\t\t\t}\n\t\t\tSystem.out.println(d);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tlists = new ArrayList[101];\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tlists[i] = new ArrayList<Integer>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tlists[from].add(to);\n\t\t\t\tlists[to].add(from);\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tif (lists[i].isEmpty())\n\t\t\t\t\tcontinue;\n\t\t\t\tb = new boolean[101];\n\t\t\t\tb[i] = true;\n\t\t\t\tslove(i, 1);\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int from, int step) {\n\n\t\tans = Math.max(ans, step);\n\t\tfor (int to : lists[from]) {\n\t\t\tif (b[to])\n\t\t\t\tcontinue;\n\t\t\tb[to] = true;\n\t\t\tslove(to, step + 1);\n\t\t\tb[to] = false;\n\t\t}\n\t}\n\n\tint ans;\n\tboolean[] b;\n\tList<Integer>[] lists;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int INF = 2 << 20;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tnode = new Node[101];\n\t\t\tfor(int i = 0; i < 101; i++) {\n\t\t\t\tnode[i] = new Node(i);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tnode[a].to.add(node[b]);\n\t\t\t\tnode[b].to.add(node[a]);\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tboolean[] tmp = new boolean[101];\n\t\t\tfor(int i = 1; i < 101; i++) {\n\t\t\t\tif(node[i].to.size() == 0) continue;\n\t\t\t\ttmp[i] = true;\n\t\t\t\tans = Math.max(ans,dfs(i,tmp,1));\n\t\t\t\ttmp[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int dfs(int now, boolean[] use, int count) {\n\t\tint ret = count;\n\t\tfor(int i = 0; i < node[now].to.size(); i++) {\n\t\t\tint tmp = node[now].to.get(i).id;\n\t\t\tif(use[tmp]) continue;\n\t\t\tuse[tmp] = true;\n\t\t\tret = Math.max(ret, dfs(tmp,use,count+1));\n\t\t\tuse[tmp] = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\t\tint id;\n\t\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\t\tNode(int a) {\n\t\t\t\tid = a;\n\t\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<ArrayList<Integer>> g;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tg.get(a).add(b);\n\t\t\t\tg.get(b).add(a);\n\t\t\t}\n\n\t\t\tHashSet<State> set = new HashSet<State>();\n\t\t\tArrayList<State> cur = new ArrayList<State>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tState st = new State().move(i);\n\t\t\t\tset.add(st);\n\t\t\t\tcur.add(st);\n\t\t\t}\n\t\t\tfor (int i = 0;; ++i) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tArrayList<State> next = new ArrayList<State>();\n\t\t\t\tfor (State st : cur) {\n\t\t\t\t\tfor (int n : g.get(st.pos())) {\n\t\t\t\t\t\tif (!st.used(n)) {\n\t\t\t\t\t\t\tState ns = st.move(n);\n\t\t\t\t\t\t\tif (!set.contains(ns)) {\n\t\t\t\t\t\t\t\tset.add(ns);\n\t\t\t\t\t\t\t\tnext.add(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class State {\n\n\t\tlong v1, v2;\n\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + (int) (v1 ^ (v1 >>> 32));\n\t\t\tresult = prime * result + (int) (v2 ^ (v2 >>> 32));\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj) return true;\n\t\t\tState other = (State) obj;\n\t\t\treturn this.v1 == other.v1 && this.v2 == other.v2;\n\t\t}\n\n\t\tboolean used(int v) {\n\t\t\tif (v < 64) {\n\t\t\t\treturn (v1 & (1L << v)) != 0;\n\t\t\t} else {\n\t\t\t\treturn (v2 & (1L << (v - 64))) != 0;\n\t\t\t}\n\t\t}\n\n\t\tState move(int v) {\n\t\t\tState ret = new State();\n\t\t\tret.v1 = this.v1;\n\t\t\tret.v2 = this.v2 & ((1L << 40) - 1);\n\t\t\tret.v2 |= ((long) v) << 40;\n\t\t\tif (v < 64) {\n\t\t\t\tret.v1 |= (1L << v);\n\t\t\t} else {\n\t\t\t\tret.v2 |= (1L << (v - 64));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint pos() {\n\t\t\treturn (int) (v2 >> 40);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t// Scanner scan = new Scanner(System.in);\n\t\tScanner scan = new Scanner(new File(\"c:\\\\0508-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tRing r = new Ring(n);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tr.add(x, y, i);\n\t\t\t}\n\n\t\t\tr.sort();\n\n\t\t\tint max = 0;\n\t\t\tfor (int x = r.elem(); x > 0; x = r.elem()) {\n\t\t\t\tint mm = r.maxRing(x);\n\t\t\t\tif (mm > max)\n\t\t\t\t\tmax = mm;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Ring {\n\tprivate int[] st;\n\tprivate int[] ed;\n\n\tpublic Ring(int n) {\n\t\tst = new int[n * 2];\n\t\ted = new int[n * 2];\n\t}\n\n\tprivate boolean[] used = new boolean[101];\n\n\tpublic int maxRing(int r) {\n\t\tused[r] = true;\n\t\tint len = 0;\n\t\tfor (int i = this.startPos(r); i < st.length; i++) {\n\t\t\tif (st[i] > r)\n\t\t\t\tbreak;\n\t\t\tif (st[i] < r)\n\t\t\t\tcontinue;\n\t\t\tif (used[ed[i]])\n\t\t\t\tcontinue;\n\t\t\tint le = this.maxRing(ed[i]);\n\t\t\tif (len < le)\n\t\t\t\tlen = le;\n\t\t}\n\t\tused[r] = false;\n\t\treturn len + 1;\n\t}\n\n\tprivate int startPos(int r) {\n\t\tint i = st.length / 2;\n\t\tfor (int m = i / 2; m > 2 && st[i] != r; m /= 2)\n\t\t\tif (st[i] < r)\n\t\t\t\ti += m;\n\t\t\telse\n\t\t\t\ti -= m;\n\n\t\tint j = i;\n\t\tfor (; j > 0 && st[j] >= r; j--)\n\t\t\t;\n\t\treturn j;\n\t}\n\n\tprivate int elemP = 0, elemV = -1;\n\n\tpublic int elem() {\n\t\tfor (; elemP < st.length; elemP++)\n\t\t\tif (st[elemP] != elemV) {\n\t\t\t\telemV = st[elemP];\n\t\t\t\treturn elemV;\n\t\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void sort() {\n\t\tfor (int i = 0; i < st.length; i++)\n\t\t\tfor (int j = st.length - 1; j > i; j--)\n\t\t\t\tif (st[j] < st[j - 1] || (st[j] == st[j - 1] && ed[j] < ed[j - 1])) {\n\t\t\t\t\tint tmp = st[j];\n\t\t\t\t\tst[j] = st[j - 1];\n\t\t\t\t\tst[j - 1] = tmp;\n\t\t\t\t\ttmp = ed[j];\n\t\t\t\t\ted[j] = ed[j - 1];\n\t\t\t\t\ted[j - 1] = tmp;\n\t\t\t\t}\n\t}\n\n\tpublic void add(int x, int y, int i) {\n\t\tst[i * 2] = x;\n\t\ted[i * 2] = y;\n\t\tst[i * 2 + 1] = y;\n\t\ted[i * 2 + 1] = x;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tint min = 150, max = 0;\n\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n\t\t\t\tmin = Math.min(min, e[i].size()); max = Math.max(max, e[i].size());\n\t\t\t}\n\t\t\tfor(int i=1;i<101;i++)if(u[i]&&e[i].size()<=min){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[i] = true;\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                                                    \n                \n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                                    String su=fin.readLine();\n                    int word1=su.indexOf(\" \");\n                    int word2=su.indexOf(\" \",word1+1);\n\n                    //  System.out.println(sub);                                                                                                                                  \n                    data[i][0]=Integer.parseInt(su.substring(0,word1));\n                    if(word2!=-1)data[i][1]=Integer.parseInt(su.substring(word1+1,word2));\n                    else data[i][1]=Integer.parseInt(su.substring(word1+1,su.length()));\n                                                                                                                                           \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                                                  \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}\n    }\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n            l.add(data[flll.get(i)][0]);\n            l.add(data[flll.get(i)][1]);\n        }\n\n        for(int i=0;i<l.size();i++){\n            int count=0;\n            for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n            }\n            if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                                                                                                                              \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                                                                                                                            \n            }                                                                                                                                                                                                                                                                                 \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRandom rand = new Random(1334259345907L);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tint[] a = new int[100];\n\t\t\tint id = 0;\n\t\t\tfor(int i=1;i<101;i++)if(!e[i].isEmpty())a[id++] = i;\n\t\t\t//開始点を全部試すとつらいからN/3個だけランダムにチョイスして絞るという迷走っぷり\n\t\t\tfor(int i=0;i<=id/3;i++){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tint s = rand.nextInt(id);\n\t\t\t\tv[a[s]] = true;\n\t\t\t\tdfs(a[s], 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int dfs(Map<Integer, List<Integer>> m, boolean[] visited, int cur, int l) {\n\t\tvisited[cur] = true;\n\t\tList<Integer> el = m.get(cur);\n\t\tif (el == null)\n\t\t\treturn l;\n\t\tint len = l;\n\t\tfor (int e : el) {\n\t\t\tif (!visited[e]) {\n\t\t\t\tlen = Math.max(len, dfs(m, visited, e, l + 1));\n\t\t\t}\n\t\t}\n\t\tvisited[cur] = false;\n\t\treturn len;\n\t}\n\n\tpublic static Map<Integer, List<Integer>> adjMap(int[][] edge) {\n\t\tMap<Integer, List<Integer>> m = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\tList<Integer> el = m.get(edge[i][0]);\n\t\t\tif (el == null)\n\t\t\t\tel = new LinkedList<Integer>();\n\t\t\tel.add(edge[i][1]);\n\t\t\tm.put(edge[i][0], el);\n\t\t}\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n * 2][2];\n\t\t\tint[] d = new int[101];\n\t\t\tArrays.fill(d, 0);\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i * 2 + 1][1] = p[i * 2][0] = s.nextInt();\n\t\t\t\tp[i * 2 + 1][0] = p[i * 2][1] = s.nextInt();\n\t\t\t\tif (p[i * 2][0] > max)\n\t\t\t\t\tmax = p[i * 2][0];\n\t\t\t\tif (p[i * 2][1] > max)\n\t\t\t\t\tmax = p[i * 2][1];\n\t\t\t\td[p[i * 2][0]]++;\n\t\t\t\td[p[i * 2][1]]++;\n\t\t\t}\n\t\t\t// 次数の少ない点が始点/終点足りうる\n\t\t\tint md = 10000;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tmd = Math.min(md, d[i]);\n\t\t\t}\n\t\t\tmd += 2;\n\n\t\t\tMap<Integer, List<Integer>> m = adjMap(p);\n\t\t\tboolean[] visited = new boolean[max + 1];\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tint l = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tif(md>d[i]){\n\t\t\t\t\tl = Math.max(l, dfs(m, visited, i, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(int key:Ring.ringList.keySet()){\n                ans = Math.max(ans,calc(Ring.ringList.get(key)));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        \n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            next.add(n);\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tRandom rand = new Random(1334259345907L);\n//\t\tSystem.out.println(T);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n//\t\t\tint min = 150, max = 0;\n//\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n//\t\t\t\tmin = Math.min(min, e[i].size()); max = Math.max(max, e[i].size());\n//\t\t\t}\n\t\t\tint[] a = new int[100];\n\t\t\tint id = 0;\n\t\t\tfor(int i=1;i<101;i++)if(!e[i].isEmpty())a[id++] = i;\n\t\t\tSet<Integer> U = new HashSet<Integer>();\n\t\t\tfor(int i=0;i<=id/3;i++){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tint s = rand.nextInt(id);\n\t\t\t\twhile(U.contains(s))s = rand.nextInt(id);\n\t\t\t\tv[a[s]] = true;\n\t\t\t\tdfs(a[s], 1);\n\t\t\t}\n//\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n//\t\t\t\tArrays.fill(v, false);\n//\t\t\t\tv[i] = true;\n//\t\t\t\tlong S = System.currentTimeMillis();\n//\t\t\t\tdfs(i, 1);\n//\t\t\t\tSystem.out.println(\"S:\"+i+\" Time:\"+(System.currentTimeMillis()-S)+\" ms.\" + \" RES:\"+res);\n//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic boolean[][] g;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new boolean[100][100];\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tg[a][b] = g[b][a] = true;\n\t\t\t}\n\t\t\tboolean[] visited = new boolean[100];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tdfs(i, visited, 1);\n\t\t\t\tvisited[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, boolean[] visited, int len) {\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tif (g[pos][i] && !visited[i]) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tdfs(i, visited, len + 1);\n\t\t\t\tvisited[i] = false;\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, len);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tint n, INF = 1<<29;\n\tSet<Integer>[] adj;\n\tboolean[] v;\n\tint[][] e;\n\tint[] deg;\n\n\tboolean dfs(int k, int d, int T, int pre){\n//\t\tSystem.out.println(\"K:\"+k+\" D:\"+d);\n\t\tif(d==T)return true;\n\t\tfor(int x:adj[k]){\n\t\t\tif(x!=pre&&T<=d+e[k][x])return true;\n\t\t\tif(!v[x]){\n\t\t\t\tv[x] = true;\n\t\t\t\tif(dfs(x, d+1+e[k][x], T, k))return true;\n\t\t\t\tv[x] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tadj = new Set[101];\n\t\t\tfor(int i=1;i<101;i++)adj[i]=new HashSet<Integer>();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\te = new int[101][101];\n\t\t\tdeg = new int[101];\n\t\t\tfor(int[]a:e)Arrays.fill(a, -1);\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tset.add(a); set.add(b);\n\t\t\t\te[a][b] = e[b][a] = 0;\n\t\t\t\tadj[a].add(b); adj[b].add(a);\n\t\t\t}\n\t\t\tint N = set.size();\n\t\t\tfor(int i=1;i<101;i++)deg[i]=adj[i].size();\n\t\t\tfor(int i=1;i<101;i++)if(deg[i]==2){\n//\t\t\t\tSystem.out.println(\"I:\"+i);\n\t\t\t\tint[] t = new int[2];\n\t\t\t\tint id = 0;\n\t\t\t\tfor(int x:adj[i])t[id++]=x;\n//\t\t\t\tSystem.out.println(t[0]+\" \"+t[1]);\n\t\t\t\tint j = t[0], k = t[1];\n//\t\t\t\tSystem.out.println(\"E:\"+e[j][k]);\n\t\t\t\tif(e[j][k]!=-1)continue;\n\t\t\t\tdeg[i] = 0;\n\t\t\t\t//\t\t\t\tif(adj[j]==null)System.out.println(\"J:\"+j);\n\t\t\t\t//\t\t\t\tif(adj[k]==null)System.out.println(\"K:\"+k);\n\t\t\t\tadj[j].remove(i); adj[k].remove(i);\n\t\t\t\tadj[j].add(k); adj[k].add(j);\n\t\t\t\te[j][k] = e[k][j] = e[i][j]+e[i][k]+1;\n\t\t\t\tset.remove(i);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tv = new boolean[101];\n\t\t\tint s = 0;\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\twhile(s<101&&!set.contains(s))s++;\n\t\t\t\tif(s==101)break;\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[s] = true;\n//\t\t\t\tSystem.out.println(\"R: \"+i+\" Start:\"+s);\n\t\t\t\tif(dfs(s, 1, i, -1)){\n\t\t\t\t\tres = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts++; i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n  public void addEdge(int a, int b) {\n    if(! nodes.containsKey(a)) nodes.put(a, new Node());\n    if(! nodes.containsKey(b)) nodes.put(b, new Node());\n\n    nodes.get(a).addEdge(nodes.get(b));\n    nodes.get(b).addEdge(nodes.get(a));\n  }\n\n  public int findLongestChain() {\n    int max = 0;\n    for(Node n : nodes.values()) {\n      int d = n.dfs();\n      if(d > max) max = d;\n    }\n    return max;\n  }\n\n  private Map<Integer, Node> nodes = new HashMap<Integer, Node>();\n}\n\nclass Node {\n  public void addEdge(Node n) {\n    edges.add(n);\n  }\n\n  public int dfs() {\n    return dfs(new HashSet<Node>());\n  }\n\n  private int dfs(Set<Node> visited) {\n    if(memo.containsKey(visited)) return memo.get(visited);\n\n    Set<Node> ns = new HashSet<Node>(visited);\n    ns.add(this);\n\n    int max = 0;\n\n    for(Node e : edges) {\n      if(! visited.contains(e)) {\n        int n = e.dfs(ns);\n        if(n > max) max = n;\n      }\n    }\n\n    max++;\n    memo.put(visited, max);\n    return max;\n  }\n\n  private Set<Node> edges = new HashSet<Node>();\n  private Map<Set<Node>, Integer> memo = new HashMap<Set<Node>, Integer>();\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      if(n == 0) break;\n\n      Graph g = new Graph();\n\n      for(int i = 0; i < n; i++) {\n        g.addEdge(sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(g.findLongestChain());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                          \n                int sub=0;\n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                    sub=Integer.parseInt(fin.readLine());\n                    //  System.out.println(sub);                                                                                                                                  \n                    data[i][0]=(sub-(sub%10))/10;\n                    data[i][1]=sub%10;\n                    //System.out.println(\"\"+data[i][0]+\"\"+data[i][1]);                                                                                                            \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                        \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}}\npublic class Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n\t    l.add(data[flll.get(i)][0]);\n\t    l.add(data[flll.get(i)][1]);\n        }\n\t\n        for(int i=0;i<l.size();i++){\n\t    int count=0;\n\t    for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n\t    }\n    if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                  \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                \n            }                                                                                                                                                                     \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(int key:Ring.getSeachRing()){\n                ans = Math.max(ans,calc(Ring.ringList.get(key)));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            next.add(n);\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n        \n        public static ArrayList<Ring> getSeachRing(){\n            ArrayList<Ring> ret = new ArrayList<Ring>();\n            for(Ring ring:ringList){\n                if(ring.next.size()<=2){\n                    ret.add(ring);\n                }\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<ArrayList<Integer>> g;\n\tstatic int ans;\n\tstatic final int memoN = 10;\n\tstatic HashSet<State> searched = new HashSet<State>();\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tsearched.clear();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tif (!g.get(a).contains(b)) g.get(a).add(b);\n\t\t\t\tif (!g.get(b).contains(a)) g.get(b).add(a);\n\t\t\t}\n\t\t\tState st = new State();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tst.move(i);\n\t\t\t\tdfs(i, st, 1);\n\t\t\t\tst.back(0);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, State st, int len) {\n\t\tif (len == memoN) {\n\t\t\tif (searched.contains(st)) return;\n\t\t\tsearched.add(st.clone());\n\t\t}\n\t\tint prev = st.pos();\n\t\tfor (int n : g.get(pos)) {\n\t\t\tif (!st.used(n)) {\n\t\t\t\tst.move(n);\n\t\t\t\tdfs(n, st, len + 1);\n\t\t\t\tst.back(prev);\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, len);\n\t}\n\n\tstatic class State {\n\n\t\tlong v1, v2;\n\n\t\tpublic State clone() {\n\t\t\tState st = new State();\n\t\t\tst.v1 = v1;\n\t\t\tst.v2 = v2;\n\t\t\treturn st;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + (int) (v1 ^ (v1 >>> 32));\n\t\t\tresult = prime * result + (int) (v2 ^ (v2 >>> 32));\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj) return true;\n\t\t\tState other = (State) obj;\n\t\t\treturn this.v1 == other.v1 && this.v2 == other.v2;\n\t\t}\n\n\t\tboolean used(int v) {\n\t\t\tif (v < 64) {\n\t\t\t\treturn (v1 & (1L << v)) != 0;\n\t\t\t} else {\n\t\t\t\treturn (v2 & (1L << (v - 64))) != 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid move(int v) {\n\t\t\tv2 &= ((1L << 40) - 1);\n\t\t\tv2 |= ((long) v) << 40;\n\t\t\tif (v < 64) {\n\t\t\t\tv1 |= (1L << v);\n\t\t\t} else {\n\t\t\t\tv2 |= (1L << (v - 64));\n\t\t\t}\n\t\t}\n\n\t\tvoid back(int v) {\n\t\t\tint clear = pos();\n\t\t\tv2 &= ((1L << 40) - 1);\n\t\t\tv2 |= ((long) v) << 40;\n\t\t\tif (clear < 64) {\n\t\t\t\tv1 ^= (1L << clear);\n\t\t\t} else {\n\t\t\t\tv2 ^= (1L << (clear - 64));\n\t\t\t}\n\t\t}\n\n\t\tint pos() {\n\t\t\treturn (int) (v2 >> 40);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<ArrayList<Integer>> g;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tg.get(a).add(b);\n\t\t\t\tg.get(b).add(a);\n\t\t\t}\n\n\t\t\tHashSet<State> set = new HashSet<State>();\n\t\t\tArrayList<State> cur = new ArrayList<State>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tState st = new State().move(i);\n\t\t\t\tcur.add(st);\n\t\t\t}\n\t\t\tfor (int i = 0;; ++i) {\n\t\t\t\tif (cur.isEmpty()) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tset.clear();\n\t\t\t\tArrayList<State> next = new ArrayList<State>();\n\t\t\t\tfor (State st : cur) {\n\t\t\t\t\tfor (int n : g.get(st.pos())) {\n\t\t\t\t\t\tif (!st.used(n)) {\n\t\t\t\t\t\t\tState ns = st.move(n);\n\t\t\t\t\t\t\tif (!set.contains(ns)) {\n\t\t\t\t\t\t\t\tset.add(ns);\n\t\t\t\t\t\t\t\tnext.add(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class State {\n\n\t\tlong v1, v2;\n\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + (int) (v1 ^ (v1 >>> 32));\n\t\t\tresult = prime * result + (int) (v2 ^ (v2 >>> 32));\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj) return true;\n\t\t\tState other = (State) obj;\n\t\t\treturn this.v1 == other.v1 && this.v2 == other.v2;\n\t\t}\n\n\t\tboolean used(int v) {\n\t\t\tif (v < 64) {\n\t\t\t\treturn (v1 & (1L << v)) != 0;\n\t\t\t} else {\n\t\t\t\treturn (v2 & (1L << (v - 64))) != 0;\n\t\t\t}\n\t\t}\n\n\t\tState move(int v) {\n\t\t\tState ret = new State();\n\t\t\tret.v1 = this.v1;\n\t\t\tret.v2 = this.v2 & ((1L << 40) - 1);\n\t\t\tret.v2 |= ((long) v) << 40;\n\t\t\tif (v < 64) {\n\t\t\t\tret.v1 |= (1L << v);\n\t\t\t} else {\n\t\t\t\tret.v2 |= (1L << (v - 64));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint pos() {\n\t\t\treturn (int) (v2 >> 40);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n  public void addEdge(int a, int b) {\n    if(! nodes.containsKey(a)) nodes.put(a, new Node());\n    if(! nodes.containsKey(b)) nodes.put(b, new Node());\n\n    nodes.get(a).addEdge(nodes.get(b));\n    nodes.get(b).addEdge(nodes.get(a));\n  }\n\n  public int findLongestChain() {\n    int max = 0;\n    for(Node n : nodes.values()) {\n      int d = n.dfs();\n      if(d > max) max = d;\n    }\n    return max;\n  }\n\n  private Map<Integer, Node> nodes = new HashMap<Integer, Node>();\n}\n\nclass Node {\n  public void addEdge(Node n) {\n    edges.add(n);\n  }\n\n  public int dfs() {\n    return dfs(new HashSet<Node>());\n  }\n\n  private int dfs(Set<Node> visited) {\n    Set<Node> ns = new HashSet<Node>(visited);\n    ns.add(this);\n\n    int max = 0;\n\n    for(Node e : edges) {\n      if(! visited.contains(e)) {\n        int n = e.dfs(ns);\n        if(n > max) max = n;\n      }\n    }\n\n    return max + 1;\n  }\n\n  private Set<Node> edges = new HashSet<Node>();\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      if(n == 0) break;\n\n      Graph g = new Graph();\n\n      for(int i = 0; i < n; i++) {\n        g.addEdge(sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(g.findLongestChain());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int[] dfs(int[][] edge, int root) {\n\t\tMap<Integer, ArrayDeque<Integer>> m = new HashMap<Integer, ArrayDeque<Integer>>();\n\t\tint max = 0;\n\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\tArrayDeque<Integer> el = m.get(edge[i][0]);\n\t\t\tif (el == null)\n\t\t\t\tel = new ArrayDeque<Integer>();\n\t\t\tel.addLast(i);\n\t\t\tm.put(edge[i][0], el);\n\t\t\tif (edge[i][0] > max)\n\t\t\t\tmax = edge[i][0];\n\t\t\tif (edge[i][1] > max)\n\t\t\t\tmax = edge[i][1];\n\t\t}\n\t\tint[] r = new int[max + 1];\n\t\tArrays.fill(r, -1);\n\t\tArrayDeque<Integer> ad = new ArrayDeque<Integer>();\n\t\tad.addLast(root);\n\t\tr[root] = 1;\n\t\twhile (!ad.isEmpty()) {\n\t\t\tInteger n = ad.getLast();\n\t\t\tArrayDeque<Integer> el = m.get(n);\n\t\t\tboolean found = false;\n\t\t\twhile (el != null && !el.isEmpty()) {\n\t\t\t\tint adj = edge[el.pollFirst()][1];\n\t\t\t\tif (r[adj] == -1) {\n\t\t\t\t\tad.addLast(adj);\n\t\t\t\t\tr[adj] = r[n] + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tad.pollLast();\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n * 2][2];\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i * 2 + 1][1] = p[i * 2][0] = s.nextInt();\n\t\t\t\tp[i * 2 + 1][0] = p[i * 2][1] = s.nextInt();\n\t\t\t\tif (p[i * 2][0] > max)\n\t\t\t\t\tmax = p[i * 2][0];\n\t\t\t\tif (p[i * 2][1] > max)\n\t\t\t\t\tmax = p[i * 2][1];\n\t\t\t}\n\t\t\tint d = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tint[] r = dfs(p, i);\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tif (d < r[j]) {\n\t\t\t\t\t\td = r[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(d);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<ArrayList<Integer>> g;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tg.get(a).add(b);\n\t\t\t\tg.get(b).add(a);\n\t\t\t}\n\t\t\tboolean[] visited = new boolean[100];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tdfs(i, visited, 1);\n\t\t\t\tvisited[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, boolean[] visited, int len) {\n\t\tfor (int n : g.get(pos)) {\n\t\t\tif (!visited[n]) {\n\t\t\t\tvisited[n] = true;\n\t\t\t\tdfs(n, visited, len + 1);\n\t\t\t\tvisited[n] = false;\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, len);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint mapping[] = new int [10000];\n\t\twhile(true){\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(line[0]);\n\t\t\tif(n==0){break;}\n\n\t\t\tfor (int i=0; i<n; i++){\n\t\t\t\tString nodeline[] = br.readLine().split(\" \");\n\t\t\t\tint node1 = Integer.parseInt(nodeline[0]) -1;\n\t\t\t\tint node2 = Integer.parseInt(nodeline[1]) -1;\n\t\t\t\tmapping[node1*100+node2]++;\n\t\t\t\tmapping[node2*100+node1]++;\n\t\t\t}\n\n\t\t\tint answer = 0;\n\t\t\tfor (int i=0; i<100; i++){\n\t\t\t\tanswer = Math.max(answer, run(mapping,i,-1,0));\n\t\t\t}\n\t\t\t System.out.println(answer);\n\t\t}\n\t}\n\n\n\tstatic int run(int[] maparray, int now, int prev, int length){\n\n\t\tif(prev!=-1){\n\t\t\tmaparray[now*100+prev]--;\n\t\t\tmaparray[prev*100+now]--;\n\t\t}\n\n\t\tint lengmax = length;\n\t\tfor (int i=0; i<100; i++){\n\t\t\tif(maparray[now*100+i]!=0){\n\t\t\t\tlengmax =  Math.max(run(maparray, i, now, length+1),lengmax);\n\t\t\t}\n\t\t}\n\n\t\tif(prev!=-1){\n\t\t\tmaparray[now*100+prev]++;\n\t\t\tmaparray[prev*100+now]++;\n\t\t}\n\t\treturn lengmax;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tes = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tes[i][0] = sc.nextInt()-1; es[i][1] = sc.nextInt()-1;\n\t\t\t}\n\t\t\t\n\t\t\tused = new boolean[n]; add = new boolean[100]; max = 0;\n\t\t\tfor(int i=0;i<100;i++) { add[i] = true; dfs(i, 1); add[i] = false;}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tboolean[] used;\n\tboolean[] add;\n\tint max = 0;\n\tvoid dfs(int p, int num) {\n\t\tmax = max(max, num);\n\t\tfor(int i=0;i<n;i++) if(!used[i] && ( es[i][0] == p || es[i][1] == p ) ) {\n\t\t\tif(add[es[i][0]]^add[es[i][1]]) {\n\t\t\t\tint tmp = es[i][0] == p? es[i][1]: es[i][0];\n\t\t\t\tused[i] = true;\n\t\t\t\tadd[tmp] = true;\n\t\t\t\tdfs(tmp, num+1);\n\t\t\t\tused[i] = false;\n\t\t\t\tadd[tmp] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(Ring ring:Ring.getSeachRing()){\n                ans = Math.max(ans,calc(ring));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            next.add(n);\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n        \n        public static ArrayList<Ring> getSeachRing(){\n            ArrayList<Ring> ret = new ArrayList<Ring>();\n            for(int idx:ringList.keySet()){\n                Ring ring = ringList.get(idx);\n                if(ring.next.size()<=2){\n                    ret.add(ring);\n                }\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                                                    \n                \n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                                    String su=fin.readLine();\n                    int word1=su.indexOf(\" \");\n                    int word2=su.indexOf(\" \",word1+1);\n\n                    //  System.out.println(sub);                                                                                                                                  \n                    data[i][0]=Integer.parseInt(su.substring(0,word1));\n                    if(word2!=-1)data[i][1]=Integer.parseInt(su.substring(word1+1,word2));\n                    else data[i][1]=Integer.parseInt(su.substring(word1+1,su.length()));\n                                                                                                                                           \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                                                  \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}\n    }\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n            l.add(data[flll.get(i)][0]);\n            l.add(data[flll.get(i)][1]);\n        }\n\n        for(int i=0;i<l.size();i++){\n            int count=0;\n            for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n            }\n            if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size()+1;\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                                                                                                                              \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                                                                                                                            \n            }                                                                                                                                                                                                                                                                                 \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<ArrayList<Integer>> g;\n\tstatic int ans;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tg = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tif (!g.get(a).contains(b)) g.get(a).add(b);\n\t\t\t\tif (!g.get(b).contains(a)) g.get(b).add(a);\n\t\t\t}\n\t\t\tboolean[] visited = new boolean[100];\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tdfs(i, visited, 1);\n\t\t\t\tvisited[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, boolean[] visited, int len) {\n\t\tfor (int n : g.get(pos)) {\n\t\t\tif (!visited[n]) {\n\t\t\t\tvisited[n] = true;\n\t\t\t\tdfs(n, visited, len + 1);\n\t\t\t\tvisited[n] = false;\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, len);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint[][] a;\n\tint len, n;\n\tLinkedList<Integer> stack;\n\t\n\tvoid loop(){\n\t\tlen = Math.max(len, stack.size());\n\t\tint pre = stack.getFirst();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a[i][0]==pre && stack.contains(a[i][1])==false){\n\t\t\t\tstack.push(a[i][1]);\n\t\t\t\tloop();\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tif(a[i][1]==pre && stack.contains(a[i][0])==false){\n\t\t\t\tstack.push(a[i][0]);\n\t\t\t\tloop();\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\ta = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i][0] = sc.nextInt();\n\t\t\t\ta[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> memo = new ArrayList<Integer>();\n\t\t\tstack = new LinkedList<Integer>();\n\t\t\tlen = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(memo.contains(a[i][j])==false){\n\t\t\t\t\t\tmemo.add(a[i][j]);\n\t\t\t\t\t\tstack.push(a[i][j]);\n\t\t\t\t\t\tloop();\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(len);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            for(int idx:Ring.ringList.keySet()){\n                Ring ring = Ring.ringList.get(idx);\n                ring.next = null;\n                ring = null;\n            }\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(Ring ring:Ring.getSeachRing()){\n                ans = Math.max(ans,calc(ring));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n            route = null;\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            next.add(n);\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n        \n        public static ArrayList<Ring> getSeachRing(){\n            ArrayList<Ring> ret = new ArrayList<Ring>();\n            for(int idx:ringList.keySet()){\n                Ring ring = ringList.get(idx);\n                if(ring.next.size()<=2){\n                    ret.add(ring);\n                }\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tb = new boolean[101];\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tlists = new ArrayList[101];\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tlists[i] = new ArrayList<Integer>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tlists[from].add(to);\n\t\t\t\tlists[to].add(from);\n\t\t\t}\n\t\t\tans = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tif (lists[i].isEmpty())\n\t\t\t\t\tcontinue;\n\t\t\t\tb[i] = true;\n\t\t\t\tslove(i, 1);\n\t\t\t\tb[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int from, int step) {\n\n\t\tans = Math.max(ans, step);\n\t\tfor (int to : lists[from]) {\n\t\t\tif (b[to])\n\t\t\t\tcontinue;\n\t\t\tb[to] = true;\n\t\t\tslove(to, step + 1);\n\t\t\tb[to] = false;\n\t\t}\n\t}\n\n\tint ans;\n\tboolean[] b;\n\tList<Integer>[] lists;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tint n, INF = 1<<29;\n\tSet<Integer>[] adj;\n\tboolean[] v;\n\tint[][] e;\n\tint[] deg;\n\n\tboolean dfs(int k, int d, int T, int pre){\n//\t\tSystem.out.println(\"K:\"+k+\" D:\"+d);\n\t\tif(d==T)return true;\n\t\tfor(int x:adj[k]){\n\t\t\tif(x!=pre&&T<=d+e[k][x])return true;\n\t\t\tif(!v[x]){\n\t\t\t\tv[x] = true;\n\t\t\t\tif(dfs(x, d+1+e[k][x], T, k))return true;\n\t\t\t\tv[x] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tint f(int k){\n\t\tint res = 0;\n\t\tfor(int x:adj[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tres = f(x); break;\n\t\t}\n\t\treturn res+1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tadj = new Set[101];\n\t\t\tfor(int i=1;i<101;i++)adj[i]=new HashSet<Integer>();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\te = new int[101][101];\n\t\t\tdeg = new int[101];\n\t\t\tfor(int[]a:e)Arrays.fill(a, -1);\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tset.add(a); set.add(b);\n\t\t\t\te[a][b] = e[b][a] = 0;\n\t\t\t\tadj[a].add(b); adj[b].add(a);\n\t\t\t}\n\t\t\tint M = 0;\n\t\t\tv = new boolean[101];\n\t\t\tfor(int s:set){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[s] = true;\n\t\t\t\tM = Math.max(M, f(s));\n\t\t\t}\n\t\t\tint N = set.size();\n\t\t\tfor(int i=1;i<101;i++)deg[i]=adj[i].size();\n\t\t\tfor(int i=1;i<101;i++)if(deg[i]==2){\n//\t\t\t\tSystem.out.println(\"I:\"+i);\n\t\t\t\tint[] t = new int[2];\n\t\t\t\tint id = 0;\n\t\t\t\tfor(int x:adj[i])t[id++]=x;\n//\t\t\t\tSystem.out.println(t[0]+\" \"+t[1]);\n\t\t\t\tint j = t[0], k = t[1];\n//\t\t\t\tSystem.out.println(\"E:\"+e[j][k]);\n\t\t\t\tif(e[j][k]!=-1)continue;\n\t\t\t\tdeg[i] = 0;\n\t\t\t\t//\t\t\t\tif(adj[j]==null)System.out.println(\"J:\"+j);\n\t\t\t\t//\t\t\t\tif(adj[k]==null)System.out.println(\"K:\"+k);\n\t\t\t\tadj[j].remove(i); adj[k].remove(i);\n\t\t\t\tadj[j].add(k); adj[k].add(j);\n\t\t\t\te[j][k] = e[k][j] = e[i][j]+e[i][k]+1;\n\t\t\t\tset.remove(i);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=M;i<=N;i++){\n\t\t\t\twhile(s<101&&!set.contains(s))s++;\n\t\t\t\tif(s==101)break;\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[s] = true;\n//\t\t\t\tSystem.out.println(\"R: \"+i+\" Start:\"+s);\n\t\t\t\tif(dfs(s, 1, i, -1)){\n\t\t\t\t\tres = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts++; i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int[] dfs(int[][] edge, int root) {\n\t\tMap<Integer, ArrayDeque<Integer>> m = new HashMap<Integer, ArrayDeque<Integer>>();\n\t\tint max = 0;\n\t\tfor (int i = 0; i < edge.length; i++) {\n\t\t\tArrayDeque<Integer> el = m.get(edge[i][0]);\n\t\t\tif (el == null)\n\t\t\t\tel = new ArrayDeque<Integer>();\n\t\t\tel.addLast(i);\n\t\t\tm.put(edge[i][0], el);\n\t\t\tif (edge[i][0] > max)\n\t\t\t\tmax = edge[i][0];\n\t\t\tif (edge[i][1] > max)\n\t\t\t\tmax = edge[i][1];\n\t\t}\n\t\tint[] r = new int[max + 1];\n\t\tArrays.fill(r, -1);\n\t\tArrayDeque<Integer> ad = new ArrayDeque<Integer>();\n\t\tad.addLast(root);\n\t\twhile (!ad.isEmpty()) {\n\t\t\tInteger n = ad.getLast();\n\t\t\tif (r[n] == -1)\n\t\t\t\tr[n] = ad.size();\n\t\t\tArrayDeque<Integer> el = m.get(n);\n\t\t\tboolean found = false;\n\t\t\twhile (el != null && !el.isEmpty()) {\n\t\t\t\tint nn = edge[el.pollFirst()][1];\n\t\t\t\tif (r[nn] == -1) {\n\t\t\t\t\tad.addLast(nn);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tad.pollLast();\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n * 2][2];\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i * 2 + 1][1] = p[i * 2][0] = s.nextInt();\n\t\t\t\tp[i * 2 + 1][0] = p[i * 2][1] = s.nextInt();\n\t\t\t\tif (p[i * 2][0] > max)\n\t\t\t\t\tmax = p[i * 2][0];\n\t\t\t\tif (p[i * 2][1] > max)\n\t\t\t\t\tmax = p[i * 2][1];\n\t\t\t}\n\t\t\tint d = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tint[] r = dfs(p, i);\n\t\t\t\tfor (int j = 1; j <= max; j++) {\n\t\t\t\t\tif (d < r[j]) {\n\t\t\t\t\t\td = r[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(d);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass StringwithRing{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                                                    \n                int sub=0;\n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                    sub=Integer.parseInt(fin.readLine());\n                    //  System.out.println(sub);                                                                                                                                                            \n                    data[i][0]=(sub-(sub%10))/10;\n                    data[i][1]=sub%10;\n                    //System.out.println(\"\"+data[i][0]+\"\"+data[i][1]);                                                                                                                                      \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                                                  \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}\n    }\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n            l.add(data[flll.get(i)][0]);\n            l.add(data[flll.get(i)][1]);\n        }\n\n        for(int i=0;i<l.size();i++){\n            int count=0;\n            for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n            }\n            if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                                                                                                                              \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                                                                                                                            \n            }                                                                                                                                                                                                                                                                                 \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n//\t\t\tfor(int i=1;i<101;i++)if(u[i]&&e[i].size()<5){\n\t\t\t\tArrays.fill(v, false);\n//\t\t\t\tv[i] = true;\n//\t\t\t\tdfs(i, 1);\n//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic public void main(String[] argv) {\n\t\ttry{\n//\t\t\tFileWriter fw = new FileWriter(\"output.txt\");\n//\t\t\tBufferedWriter bw = new BufferedWriter(fw);\n//\t\t\tPrintWriter pw = new PrintWriter(bw, true);\n\t\t\t\n//\t\t\tFileReader fr = new FileReader(\"input.txt\");\n//\t\t\tBufferedReader br = new BufferedReader( fr );\n\t\t\t\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\n//\t\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n//\t\t\tPrintWriter pw = new PrintWriter(bw, true);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tString buf = br.readLine();\n\t\t\t\tint n;\n\t\t\t\tn = Integer.valueOf(buf);\n\t\t\t\tif(n == 0) break;\n\t\t\t\t\n\t\t\t\tStringTokenizer st;\n\t\t\t\tLinkedList<Node> list = new LinkedList<Node>();\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tst = new StringTokenizer(buf);\n\t\t\t\t\tNode node = new Node();\n\t\t\t\t\tnode.e_1 = Integer.valueOf(st.nextToken());\n\t\t\t\t\tnode.e_2 = Integer.valueOf(st.nextToken());\n\t\t\t\t\tlist.offer(node);\n\t\t\t\t}\n\t\t\t\tint max_count = 0;\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tint count = solve(list, i+1);\n\t\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max_count);\n\t\t\t}\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic int solve(LinkedList<Node> list, int root) {\n\t\tint max_count = 1;\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tNode node = list.poll();\n\t\t\tif(root == node.e_1) {\n\t\t\t\tLinkedList<Node> removed = removeNode(list, root);\n\t\t\t\tint count = 1 + solve(removed, node.e_2);\n\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t} else if (root == node.e_2) {\n\t\t\t\tLinkedList<Node> removed = removeNode(list, root);\n\t\t\t\tint count = 1 + solve(removed, node.e_1);\n\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t}\n\t\t\tlist.offer(node);\n\t\t}\n\t\treturn max_count;\n\t}\n\t\n\tstatic LinkedList<Node> copy(LinkedList<Node> list) {\n\t\treturn new LinkedList<Node>(list);\n\t}\n\t\n\tstatic LinkedList<Node> removeNode(LinkedList<Node> list, int element) {\n\t\tLinkedList<Node> cloned = copy(list);\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tNode node = cloned.poll();\n\t\t\tif(!(node.e_1 == element || node.e_2 == element)) cloned.offer(node);\n\t\t}\n\t\treturn cloned;\n\t}\n}\n\nclass Node {\n\tpublic int e_1;\n\tpublic int e_2;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tlists = new ArrayList[101];\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tlists[i] = new ArrayList<Integer>();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tlists[from].add(to);\n\t\t\t\tlists[to].add(from);\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tif (lists[i].isEmpty())\n\t\t\t\t\tcontinue;\n\t\t\t\tb = new boolean[101];\n\t\t\t\tslove(i, 1);\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int from, int step) {\n\t\tif (b[from])\n\t\t\treturn;\n\t\tb[from] = true;\n\t\tans = Math.max(ans, step);\n\t\tfor (int to : lists[from]) {\n\t\t\tslove(to, step + 1);\n\t\t}\n\t}\n\n\tint ans;\n\tboolean[] b;\n\tList<Integer>[] lists;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n  public void addEdge(int a, int b) {\n    if(! nodes.containsKey(a)) nodes.put(a, new Node());\n    if(! nodes.containsKey(b)) nodes.put(b, new Node());\n\n    nodes.get(a).addEdge(nodes.get(b));\n    nodes.get(b).addEdge(nodes.get(a));\n  }\n\n  public int findLongestChain() {\n    int max = 0;\n    for(Node n : searchStartNodes()) {\n      int d = n.dfs();\n      if(d > max) max = d;\n    }\n    return max;\n  }\n\n  private Set<Node> searchStartNodes() {\n    Collection<Node> ns = nodes.values();\n    Set<Node> lst = new HashSet<Node>(ns);\n\n    for(Node n : ns) {\n      if(lst.contains(n)) {\n        int rank = n.edges.size();\n        for(Node s : n.edges) {\n          if(lst.contains(s) && s.edges.size() <= rank) {\n            lst.remove(n);\n            break;\n          }\n        }\n      }\n    }\n\n    return lst;\n  }\n\n  private Map<Integer, Node> nodes = new HashMap<Integer, Node>();\n}\n\nclass Node {\n  public void addEdge(Node n) {\n    edges.add(n);\n  }\n\n  public int dfs() {\n    return dfs(new HashSet<Node>());\n  }\n\n  private int dfs(Set<Node> visited) {\n    int max = 0;\n    visited.add(this);\n\n    for(Node e : edges) {\n      if(! visited.contains(e)) {\n        int n = e.dfs(visited);\n        if(n > max) max = n;\n      }\n    }\n\n    visited.remove(this);\n\n    max++;\n    return max;\n  }\n\n  Set<Node> edges = new HashSet<Node>();\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      if(n == 0) break;\n\n      Graph g = new Graph();\n\n      for(int i = 0; i < n; i++) {\n        g.addEdge(sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(g.findLongestChain());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0508-input.txt\"));\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tRing r = new Ring(n);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tr.add(x, y, i);\n\t\t\t}\n\n\t\t\tr.sort();\n\n\t\t\tint max = 0;\n\t\t\tfor (int x = r.elem(); x > 0; x = r.elem()) {\n\t\t\t\tint mm = r.maxRing(x);\n\t\t\t\tif (mm > max)\n\t\t\t\t\tmax = mm;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Ring {\n\tprivate int[] st;\n\tprivate int[] ed;\n\n\tpublic Ring(int n) {\n\t\tst = new int[n * 2];\n\t\ted = new int[n * 2];\n\t}\n\n\tprivate boolean[] used = new boolean[101];\n\n\tpublic int maxRing(int r) {\n\t\tused[r] = true;\n\t\tint len = 0;\n\t\tfor (int i = this.startPos(r); i < st.length; i++) {\n\t\t\tif (st[i] > r)\n\t\t\t\tbreak;\n\t\t\tif (st[i] < r)\n\t\t\t\tcontinue;\n\t\t\tif (used[ed[i]])\n\t\t\t\tcontinue;\n\t\t\tint le = this.maxRing(ed[i]);\n\t\t\tif (len < le)\n\t\t\t\tlen = le;\n\t\t}\n\t\tused[r] = false;\n\t\treturn len + 1;\n\t}\n\n\tprivate int startPos(int r) {\n\t\tint i = st.length / 2;\n\t\tfor (int m = i / 2; m > 2 && st[i] != r; m /= 2)\n\t\t\tif (st[i] < r)\n\t\t\t\ti += m;\n\t\t\telse\n\t\t\t\ti -= m;\n\n\t\tint j = i;\n\t\tfor (; j > 0 && st[j] >= r; j--)\n\t\t\t;\n\t\treturn j;\n\t}\n\n\tprivate int elemP = 0, elemV = -1;\n\n\tpublic int elem() {\n\t\tfor (; elemP < st.length; elemP++)\n\t\t\tif (st[elemP] != elemV) {\n\t\t\t\telemV = st[elemP];\n\t\t\t\treturn elemV;\n\t\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void sort() {\n\t\tfor (int i = 0; i < st.length; i++)\n\t\t\tfor (int j = st.length - 1; j > i; j--)\n\t\t\t\tif (st[j] < st[j - 1] || (st[j] == st[j - 1] && ed[j] < ed[j - 1])) {\n\t\t\t\t\tint tmp = st[j];\n\t\t\t\t\tst[j] = st[j - 1];\n\t\t\t\t\tst[j - 1] = tmp;\n\t\t\t\t\ttmp = ed[j];\n\t\t\t\t\ted[j] = ed[j - 1];\n\t\t\t\t\ted[j - 1] = tmp;\n\t\t\t\t}\n\t}\n\n\tpublic void add(int x, int y, int i) {\n\t\tst[i * 2] = x;\n\t\ted[i * 2] = y;\n\t\tst[i * 2 + 1] = y;\n\t\ted[i * 2 + 1] = x;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tint n;\n\tList<Integer>[] adj;\n\tboolean[] v;\n\n\tboolean dfs(int k, int d, int T){\n\t\tif(d==T)return true;\n\t\tfor(int x:adj[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tif(dfs(x, d+1, T))return true;\n\t\t\tv[x] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tadj = new List[101];\n\t\t\tfor(int i=1;i<101;i++)adj[i]=new ArrayList<Integer>();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tset.add(a); set.add(b);\n\t\t\t\tadj[a].add(b); adj[b].add(a);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tv = new boolean[101];\n\t\t\tint s = 0;\n\t\t\tfor(int i=1;i<=set.size();i++){\n\t\t\t\twhile(s<101&&!set.contains(s))s++;\n\t\t\t\tif(s==101)break;\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[s] = true;\n\t\t\t\tif(dfs(s, 1, i)){\n\t\t\t\t\tres = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts++; i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tint n;\n\tList<Integer>[] adj;\n\tboolean[] v;\n\n\tboolean dfs(int k, int d, int T){\n\t\tif(d==T)return true;\n\t\tfor(int x:adj[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tif(dfs(x, d+1, T))return true;\n\t\t\tv[x] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tadj = new List[101];\n\t\t\tfor(int i=1;i<101;i++)adj[i]=new ArrayList<Integer>();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tset.add(a); set.add(b);\n\t\t\t\tadj[a].add(b); adj[b].add(a);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tv = new boolean[101];\n\t\t\tfor(int i=1;i<=set.size();i++){\n\t\t\t\tboolean ok = false;\n\t\t\t\tfor(int s:set){\n\t\t\t\t\tArrays.fill(v, false);\n\t\t\t\t\tv[s] = true;\n\t\t\t\t\tif(dfs(s, 1, i)){\n\t\t\t\t\t\tok = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)break;\n\t\t\t\tres = i;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\n//import java.io.*;\n//import java.util.*;\n\npublic class Main {\n\tstatic public void main(String[] argv) {\n\t\ttry{\n//\t\t\tFileWriter fw = new FileWriter(\"output.txt\");\n//\t\t\tBufferedWriter bw = new BufferedWriter(fw);\n//\t\t\tPrintWriter pw = new PrintWriter(bw, true);\n\t\t\t\n//\t\t\tFileReader fr = new FileReader(\"input.txt\");\n//\t\t\tBufferedReader br = new BufferedReader( fr );\n\t\t\t\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\n//\t\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n//\t\t\tPrintWriter pw = new PrintWriter(bw, true);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tString buf = br.readLine();\n\t\t\t\tint n;\n\t\t\t\tn = Integer.valueOf(buf);\n\t\t\t\tif(n == 0) break;\n\t\t\t\t\n\t\t\t\tStringTokenizer st;\n\t\t\t\tLinkedList<Node> list = new LinkedList<Node>();\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tst = new StringTokenizer(buf);\n\t\t\t\t\tNode node = new Node();\n\t\t\t\t\tnode.e_1 = Integer.valueOf(st.nextToken());\n\t\t\t\t\tnode.e_2 = Integer.valueOf(st.nextToken());\n\t\t\t\t\tlist.offer(node);\n\t\t\t\t}\n\t\t\t\tint max_count = 0;\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tint count = solve(list, i+1);\n\t\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max_count);\n\t\t\t}\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic int solve(LinkedList<Node> list, int root) {\n\t\tint max_count = 1;\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tNode node = list.poll();\n\t\t\tif(root == node.e_1) {\n\t\t\t\tLinkedList<Node> removed = removeNode(list, root);\n\t\t\t\tint count = 1 + solve(removed, node.e_2);\n\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t} else if (root == node.e_2) {\n\t\t\t\tLinkedList<Node> removed = removeNode(list, root);\n\t\t\t\tint count = 1 + solve(removed, node.e_1);\n\t\t\t\tif(count > max_count) max_count = count;\n\t\t\t}\n\t\t\tlist.offer(node);\n\t\t}\n\t\treturn max_count;\n\t}\n\t\n\tstatic LinkedList<Node> copy(LinkedList<Node> list) {\n\t\treturn new LinkedList<Node>(list);\n\t}\n\t\n\tstatic LinkedList<Node> removeNode(LinkedList<Node> list, int element) {\n\t\tLinkedList<Node> cloned = copy(list);\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tNode node = cloned.poll();\n\t\t\tif(!(node.e_1 == element || node.e_2 == element)) cloned.offer(node);\n\t\t}\n\t\treturn cloned;\n\t}\n}\n\nclass Node {\n\tpublic int e_1;\n\tpublic int e_2;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRandom rand = new Random(1334259345907L);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tint[] a = new int[100];\n\t\t\tint id = 0;\n\t\t\tfor(int i=1;i<101;i++)if(!e[i].isEmpty())a[id++] = i;\n\t\t\tSet<Integer> U = new HashSet<Integer>();\n\t\t\tfor(int i=0;i<=id/3;i++){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tint s = rand.nextInt(id);\n\t\t\t\twhile(U.contains(s))s = rand.nextInt(id);\n\t\t\t\tv[a[s]] = true;\n\t\t\t\tdfs(a[s], 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tRing r = new Ring(n);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tr.add(x, y, i);\n\t\t\t}\n\n\t\t\tr.sort();\n\n\t\t\tint max = 0;\n\t\t\tfor (int x = r.elem(); x > 0; x = r.elem()) {\n\t\t\t\tint m = r.maxRing(x);\n\t\t\t\tif (m > max)\n\t\t\t\t\tmax = x;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Ring {\n\tprivate int[] st;\n\tprivate int[] ed;\n\n\tpublic Ring(int n) {\n\t\tst = new int[n * 2];\n\t\ted = new int[n * 2];\n\t}\n\n\tprivate int[] used = new int[100];\n\tprivate int usedC = 0;\n\n\tpublic int maxRing(int r) {\n\t\tused[usedC++] = r;\n\t\t// this.print();\n\t\tint len = 0;\n\t\tfor (int i = 0; i < st.length; i++) {\n\t\t\tif (st[i] > r)\n\t\t\t\tbreak;\n\t\t\tif (st[i] < r)\n\t\t\t\tcontinue;\n\t\t\tif (this.isUsed(ed[i]))\n\t\t\t\tcontinue;\n\t\t\tint le = this.maxRing(ed[i]);\n\t\t\tif (len < le)\n\t\t\t\tlen = le;\n\t\t}\n\t\tusedC--;\n\t\treturn len + 1;\n\t}\n\n\tprivate boolean isUsed(int r) {\n\t\tfor (int i = 0; i < usedC; i++)\n\t\t\tif (used[i] == r)\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int elemP = 0, elemV = -1;\n\n\tpublic int elem() {\n\t\tfor (; elemP < st.length; elemP++)\n\t\t\tif (st[elemP] != elemV) {\n\t\t\t\telemV = st[elemP];\n\t\t\t\treturn elemV;\n\t\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void sort() {\n\t\tfor (int i = 0; i < st.length; i++)\n\t\t\tfor (int j = st.length - 1; j > i; j--)\n\t\t\t\tif (st[j] < st[j - 1] || (st[j] == st[j - 1] && ed[j] < ed[j - 1])) {\n\t\t\t\t\tint tmp = st[j];\n\t\t\t\t\tst[j] = st[j - 1];\n\t\t\t\t\tst[j - 1] = tmp;\n\t\t\t\t\ttmp = ed[j];\n\t\t\t\t\ted[j] = ed[j - 1];\n\t\t\t\t\ted[j - 1] = tmp;\n\t\t\t\t}\n\t}\n\n\tpublic void add(int x, int y, int i) {\n\t\tst[i * 2] = x;\n\t\ted[i * 2] = y;\n\t\tst[i * 2 + 1] = y;\n\t\ted[i * 2 + 1] = x;\n\t}\n\n\tpublic void print() {\n\t\tfor (int i = 0; i < usedC; i++)\n\t\t\tSystem.out.print(used[i] + \" \");\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[i] = true;\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tfor(int i=1;i<101;i++)if(u[i]&&e[i].size()<5){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[i] = true;\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int INF = 2 << 20;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tnode = new Node[101];\n\t\t\tfor(int i = 0; i < 101; i++) {\n\t\t\t\tnode[i] = new Node(i);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tnode[a].to.add(node[b]);\n\t\t\t\tnode[b].to.add(node[a]);\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 1; i < 101; i++) {\n\t\t\t\tif(node[i].to.size() == 0) continue;\n\t\t\t\tboolean[] tmp = new boolean[101];\n\t\t\t\ttmp[i] = true;\n\t\t\t\tans = Math.max(ans,dfs(i,tmp,1));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int dfs(int now, boolean[] use, int count) {\n\t\tint ret = count;\n\t\tfor(int i = 0; i < node[now].to.size(); i++) {\n\t\t\tint tmp = node[now].to.get(i).id;\n\t\t\tif(use[tmp]) continue;\n\t\t\tuse[tmp] = true;\n\t\t\tret = Math.max(ret, dfs(tmp,use,count+1));\n\t\t\tuse[tmp] = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\t\tint id;\n\t\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\t\tNode(int a) {\n\t\t\t\tid = a;\n\t\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tstatic int[][] input;\n\tstatic int cnt;\n\tpublic static void main(String[] args) {\n\t\tint result = 0;\n\t\tScanner s = new Scanner(System.in);\n\t\tcnt = Integer.parseInt(s.nextLine());\n\t\tinput = new int[cnt][2];\n\t\tfor(int i=0 ; i<cnt ; i++) {\n\t\t\tString[] array = s.nextLine().split(\" \");\n\t\t\tinput[i][0] = Integer.parseInt(array[0]);\n\t\t\tinput[i][1] = Integer.parseInt(array[1]);\n\t\t}\n\t\tfor(int i=0 ; i<cnt ; i++) {\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tlist.add(input[i][0]);list.add(input[i][1]);\n\t\t\tresult = Math.max(solve(list,i+1), result);\n\t\t}\n\t\tSystem.out.println(result + 2);\n\t}\n\n\tpublic static int solve(List<Integer> list, int c) {\n\t\tif(c==cnt)\n\t\t\treturn 0;\n\t\tif((list.contains(input[c][0]) && !list.contains(input[c][1]))) {\n\t\t\tlist.add(input[c][1]);\n\t\t\treturn solve(list, c+1) + 1;\n\t\t}else if((!list.contains(input[c][0]) && list.contains(input[c][1]))) {\n\t\t\tlist.add(input[c][0]);\n\t\t\treturn solve(list, c+1) + 1;\n\t\t}else\n\t\t\treturn solve(list, c+1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n  public void addEdge(int a, int b) {\n    if(! nodes.containsKey(a)) nodes.put(a, new Node());\n    if(! nodes.containsKey(b)) nodes.put(b, new Node());\n\n    nodes.get(a).addEdge(nodes.get(b));\n    nodes.get(b).addEdge(nodes.get(a));\n  }\n\n  public int findLongestChain() {\n    int max = 0;\n    for(Node n : searchStartNodes()) {\n      int d = n.dfs();\n      if(d > max) max = d;\n    }\n    return max;\n  }\n\n  private Set<Node> searchStartNodes() {\n    Collection<Node> ns = nodes.values();\n    Set<Node> lst = new HashSet<Node>(ns);\n\n    // 周囲のノードのうちエッジの数が極小のもののみを対象とする\n    for(Node n : ns) {\n      if(lst.contains(n)) {\n        int rank = n.edges.size();\n        for(Node s : n.edges) {\n          if(lst.contains(s) && s.edges.size() <= rank) {\n            lst.remove(n);\n            break;\n          }\n        }\n      }\n    }\n\n    Set<Node> snodes = new HashSet<Node>();\n\n    // 対等なノードは1つのみで良い\n    for(Node n1 : lst) {\n      boolean contains = false;\n      for(Node n2 : snodes) {\n        if(n1.edges.equals(n2.edges)) {\n          contains = true;\n          break;\n        }\n      }\n      if(! contains) snodes.add(n1);\n    }\n\n    return snodes;\n  }\n\n  private Map<Integer, Node> nodes = new HashMap<Integer, Node>();\n}\n\nclass Node {\n  public void addEdge(Node n) {\n    edges.add(n);\n  }\n\n  public int dfs() {\n    return dfs(new HashSet<Node>());\n  }\n\n  private int dfs(Set<Node> visited) {\n    int max = 0;\n    visited.add(this);\n\n    for(Node e : getNeighbors(visited)) {\n      if(! visited.contains(e)) {\n        int n = e.dfs(visited);\n        if(n > max) max = n;\n      }\n    }\n\n    visited.remove(this);\n\n    max++;\n    return max;\n  }\n\n  private Set<Node> getNeighbors(Set<Node> visited) {\n    Set<Node> nodes = new HashSet<Node>();\n\n    // 対等なノードは1つのみで良い\n    for(Node n1 : edges) {\n      if(visited.contains(n1)) continue;\n\n      boolean contains = false;\n      for(Node n2 : nodes) {\n        if(n1.edges.equals(n2.edges)) {\n          contains = true;\n          break;\n        }\n      }\n      if(! contains) nodes.add(n1);\n    }\n\n    return nodes;\n  }\n\n  Set<Node> edges = new HashSet<Node>();\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      if(n == 0) break;\n\n      Graph g = new Graph();\n\n      for(int i = 0; i < n; i++) {\n        g.addEdge(sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(g.findLongestChain());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int dfs(int[][] m, boolean[] visited, int cur, int l) {\n\t\tvisited[cur] = true;\n\t\tint len = l;\n\t\tfor (int e : m[cur]) {\n\t\t\tif (!visited[e]) {\n\t\t\t\tlen = Math.max(len, dfs(m, visited, e, l + 1));\n\t\t\t}\n\t\t}\n\t\tvisited[cur] = false;\n\t\treturn len;\n\t}\n\n\tpublic static int[][] getAdjMap(int max, int[][] uedge) {\n\t\tint[][] m = new int[max + 1][];\n\t\tint[] p = new int[max + 1];\n\t\tfor (int[] ue : uedge) {\n\t\t\tp[ue[0]]++;\n\t\t\tp[ue[1]]++;\n\t\t}\n\t\tfor (int i = 1; i <= max; i++)\n\t\t\tm[i] = new int[p[i]];\n\t\tfor (int i = 0; i < uedge.length; i++) {\n\t\t\tm[uedge[i][0]][--p[uedge[i][0]]] = uedge[i][1];\n\t\t\tm[uedge[i][1]][--p[uedge[i][1]]] = uedge[i][0];// counter edge\n\t\t}\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n * 2][2];\n\t\t\tint[] d = new int[101];\n\t\t\tArrays.fill(d, 0);\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i * 2 + 1][1] = p[i * 2][0] = s.nextInt();\n\t\t\t\tp[i * 2 + 1][0] = p[i * 2][1] = s.nextInt();\n\t\t\t\tif (p[i * 2][0] > max)\n\t\t\t\t\tmax = p[i * 2][0];\n\t\t\t\tif (p[i * 2][1] > max)\n\t\t\t\t\tmax = p[i * 2][1];\n\t\t\t\td[p[i * 2][0]]++;\n\t\t\t\td[p[i * 2][1]]++;\n\t\t\t}\n\t\t\t// 次数の少ない点が始点/終点足りうる\n\t\t\tint md = 10000;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tmd = Math.min(md, d[i]);\n\t\t\t}\n\t\t\tmd += 2;\n\n\t\t\tint[][] m = getAdjMap(max, p);\n\t\t\tboolean[] visited = new boolean[max + 1];\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tint l = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tif (md > d[i]) {\n\t\t\t\t\tl = Math.max(l, dfs(m, visited, i, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                                                    \n                int sub=0;\n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                    sub=Integer.parseInt(fin.readLine());\n                    //  System.out.println(sub);                                                                                                                                                            \n                    data[i][0]=(sub-(sub%10))/10;\n                    data[i][1]=sub%10;\n                    //System.out.println(\"\"+data[i][0]+\"\"+data[i][1]);                                                                                                                                      \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                                                  \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}\n    }\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n            l.add(data[flll.get(i)][0]);\n            l.add(data[flll.get(i)][1]);\n        }\n\n        for(int i=0;i<l.size();i++){\n            int count=0;\n            for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n            }\n            if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                                                                                                                              \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                                                                                                                            \n            }                                                                                                                                                                                                                                                                                 \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate int[][] thread;\n\tprivate boolean[] used;\n\tprivate static int sum_ = 0;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\twhile (n != 0) {\n\t\t\tthread = new int[n][2];\n\t\t\tused = new boolean[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tthread[i][0] = scan.nextInt();\n\t\t\t\tthread[i][1] = scan.nextInt();\n\t\t\t\tthis.used[i] = false;\n\t\t\t}\n\t\t\tsum_ = 0;\n\t\t\tcomb(n);\n\t\t\t\n\t\t\tSystem.out.println(sum_);\n\t\t\tn = scan.nextInt();\n\t\t}\n\t}\n\t\n\tprivate void comb(int n){\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tinitUsed(n);\n\t\t\t\tthis.used[i] = true;\n\t\t\t\t//System.out.print(this.thread[i][0]+\":\"+this.thread[i][1]+\" \"+1+\"→\");\n\t\t\t\tseekComb(this.thread[i][j], n, 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void seekComb(int ringNum, int n, int count){\n\t\tboolean [] stuck = new boolean[n];\n\t\tfor (int p = 0; p < n; p++) {\n\t\t\tfor (int q = 0; q < 2; q++) {\n\t\t\t\tif (!this.used[p] && this.thread[p][q] == ringNum) {\n\t\t\t\t\tthis.used[p] = true;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\tif (i != p && this.thread[i][j] == this.thread[p][q] && !this.used[i]) {\n\t\t\t\t\t\t\t\tthis.used[i] = true;\n\t\t\t\t\t\t\t\tstuck[i] = true;\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tstuck[i] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tif (q == 0) {\n\t\t\t\t\t\t//System.out.print(this.thread[p][0]+\"-\"+this.thread[p][1]+\":\"+count+\"→\");\n\t\t\t\t\t\tseekComb(this.thread[p][1], n, count);\n\t\t\t\t\t\tsum_ = Math.max(sum_, count);\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}else {\n\t\t\t\t\t\t//System.out.print(this.thread[p][1]+\"-\"+this.thread[p][0]+\":\"+count+\"→\");\n\t\t\t\t\t\tseekComb(this.thread[p][0], n, count);\n\t\t\t\t\t\tsum_ = Math.max(sum_, count);\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (stuck[i]) {\n\t\t\t\t\t\t\tthis.used[i] = false;\n\t\t\t\t\t\t\tstuck[i] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println();\n\t\t\n\t}\n\t\n\tprivate void initUsed(int n){\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tthis.used[i] = false;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tRandom rand = new Random(1334259171148L);\n//\t\tSystem.out.println(T);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n//\t\t\tint min = 150, max = 0;\n//\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n//\t\t\t\tmin = Math.min(min, e[i].size()); max = Math.max(max, e[i].size());\n//\t\t\t}\n\t\t\tint[] a = new int[100];\n\t\t\tint id = 0;\n\t\t\tfor(int i=1;i<101;i++)if(!e[i].isEmpty())a[id++] = i;\n\t\t\tSet<Integer> U = new HashSet<Integer>();\n\t\t\tfor(int i=0;i<id/2;i++){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tint s = rand.nextInt(id);\n\t\t\t\twhile(U.contains(s))s = rand.nextInt(id);\n\t\t\t\tv[a[s]] = true;\n\t\t\t\tdfs(a[s], 1);\n\t\t\t}\n//\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n//\t\t\t\tArrays.fill(v, false);\n//\t\t\t\tv[i] = true;\n//\t\t\t\tlong S = System.currentTimeMillis();\n//\t\t\t\tdfs(i, 1);\n//\t\t\t\tSystem.out.println(\"S:\"+i+\" Time:\"+(System.currentTimeMillis()-S)+\" ms.\" + \" RES:\"+res);\n//\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            for(int idx:Ring.ringList.keySet()){\n                Ring ring = Ring.ringList.get(idx);\n                ring.next = null;\n                ring = null;\n            }\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(Ring ring:Ring.getSeachRing()){\n                ans = Math.max(ans,calc(ring));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            next.add(n);\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n        \n        public static ArrayList<Ring> getSeachRing(){\n            ArrayList<Ring> ret = new ArrayList<Ring>();\n            for(int idx:ringList.keySet()){\n                Ring ring = ringList.get(idx);\n                if(ring.next.size()<=2){\n                    ret.add(ring);\n                }\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int INF = 2 << 20;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tnode = new Node[101];\n\t\t\tfor(int i = 0; i < 101; i++) {\n\t\t\t\tnode[i] = new Node(i);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tnode[a].to.add(node[b]);\n\t\t\t\tnode[b].to.add(node[a]);\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tboolean[] tmp = new boolean[101];\n\t\t\tfor(int i = 1; i < 101; i++) {\n\t\t\t\tif(node[i].to.size() == 0) continue;\n\t\t\t\ttmp[i] = true;\n\t\t\t\tans = Math.max(ans,dfs(i,tmp,1));\n\t\t\t\ttmp[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int dfs(int now, boolean[] use, int count) {\n\t\tfor(int i = 0; i < node[now].to.size(); i++) {\n\t\t\tint tmp = node[now].to.get(i).id;\n\t\t\tif(use[tmp]) continue;\n\t\t\tuse[tmp] = true;\n\t\t\tcount = Math.max(count, dfs(tmp,use,count+1));\n\t\t\tuse[tmp] = false;\n\t\t}\n\t\treturn count;\n\t}\n\tstatic class Node {\n\t\t\tint id;\n\t\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\t\tNode(int a) {\n\t\t\t\tid = a;\n\t\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[i] = true;\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n  public void addEdge(int a, int b) {\n    if(! nodes.containsKey(a)) nodes.put(a, new Node());\n    if(! nodes.containsKey(b)) nodes.put(b, new Node());\n\n    nodes.get(a).addEdge(nodes.get(b));\n    nodes.get(b).addEdge(nodes.get(a));\n  }\n\n  public int findLongestChain() {\n    int s = nodes.size();\n    int max = 0;\n    for(Node n : nodes.values()) {\n      int d = n.dfs(s);\n      if(d > max) max = d;\n    }\n    return max;\n  }\n\n  private Map<Integer, Node> nodes = new HashMap<Integer, Node>();\n}\n\nclass Node {\n  public void addEdge(Node n) {\n    edges.add(n);\n  }\n\n  public int dfs(int s) {\n    return dfs(new HashSet<Node>(), s - 1);\n  }\n\n  private int dfs(Set<Node> visited, int rest) {\n    Set<Node> ns = new HashSet<Node>(visited);\n    ns.add(this);\n\n    int max = 0;\n\n    for(Node e : edges) {\n      if(! visited.contains(e)) {\n        int n = e.dfs(ns, rest - 1);\n        if(n > max) max = n;\n        if(max == rest) break;\n      }\n    }\n\n    max++;\n    return max;\n  }\n\n  private Set<Node> edges = new HashSet<Node>();\n}\n\npublic class Main {\n  private Scanner sc = new Scanner(System.in);\n\n  public void run() {\n    while(sc.hasNextInt()) {\n      int n = sc.nextInt();\n      if(n == 0) break;\n\n      Graph g = new Graph();\n\n      for(int i = 0; i < n; i++) {\n        g.addEdge(sc.nextInt(), sc.nextInt());\n      }\n\n      System.out.println(g.findLongestChain());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//String With Rings\npublic class Main{\n\n\tList<Integer>[] e;\n\tint res;\n\tboolean[] v;\n\t\n\tvoid dfs(int k, int d){\n\t\tres = Math.max(res, d);\n\t\tfor(int x:e[k])if(!v[x]){\n\t\t\tv[x] = true;\n\t\t\tdfs(x, d+1);\n\t\t\tv[x] = false;\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\te = new List[101];\n\t\t\tfor(int i=1;i<101;i++)e[i]=new ArrayList<Integer>();\n\t\t\tboolean[] u = new boolean[101];\n\t\t\twhile(n--!=0){\n\t\t\t\tint a = sc.nextInt(), b = sc.nextInt();\n\t\t\t\tu[a] = u[b] = true;\n\t\t\t\te[a].add(b); e[b].add(a);\n\t\t\t}\n\t\t\tv = new boolean[101];\n\t\t\tres = 0;\n\t\t\tint min = 150, max = 0;\n\t\t\tfor(int i=1;i<101;i++)if(u[i]){\n\t\t\t\tmin = Math.min(min, e[i].size()); max = Math.max(max, e[i].size());\n\t\t\t}\n\t\t\tfor(int i=1;i<101;i++)if(u[i]&&e[i].size()<=(min+max)/2){\n\t\t\t\tArrays.fill(v, false);\n\t\t\t\tv[i] = true;\n\t\t\t\tdfs(i, 1);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tes = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tes[i][0] = sc.nextInt()-1; es[i][1] = sc.nextInt()-1;\n\t\t\t}\n\t\t\t\n\t\t\tused = new boolean[n]; add = new boolean[100]; max = 0;\n\t\t\tvisited = new HashSet<String>();\n\t\t\tfor(int i=0;i<100;i++) { add[i] = true; dfs(i, 1); add[i] = false; }\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tString getCode() {\n\t\tString ret = \"\";\n\t\tfor(int i=0;i<100;i++) ret += add[i]? 1: 0;\n\t\treturn ret;\n\t}\n\t\n\tHashSet<String> visited;\n\tboolean[] used;\n\tboolean[] add;\n\tint max = 0;\n\tvoid dfs(int p, int num) {\n\t\tmax = max(max, num);\n\t\tif(visited.contains(getCode())) return;\n\t\tvisited.add(getCode());\n\t\tfor(int i=0;i<n;i++) if(!used[i] && ( es[i][0] == p || es[i][1] == p ) ) {\n\t\t\tif(add[es[i][0]]^add[es[i][1]]) {\n\t\t\t\tint tmp = es[i][0] == p? es[i][1]: es[i][0];\n\t\t\t\tused[i] = true;\n\t\t\t\tadd[tmp] = true;\n\t\t\t\tdfs(tmp, num+1);\n\t\t\t\tused[i] = false;\n\t\t\t\tadd[tmp] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                          \n                int sub=0;\n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                    sub=Integer.parseInt(fin.readLine());\n                    //  System.out.println(sub);                                                                                                                                  \n                    data[i][0]=(sub-(sub%10))/10;\n                    data[i][1]=sub%10;\n                    //System.out.println(\"\"+data[i][0]+\"\"+data[i][1]);                                                                                                            \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                        \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n}}\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n\t    l.add(data[flll.get(i)][0]);\n\t    l.add(data[flll.get(i)][1]);\n        }\n\t\n        for(int i=0;i<l.size();i++){\n\t    int count=0;\n\t    for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n\t    }\n    if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                  \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                \n            }                                                                                                                                                                     \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int dfs(int[][] m, boolean[] visited, int cur, int l) {\n\t\tvisited[cur] = true;\n\t\tint len = l;\n\t\tfor (int e : m[cur]) {\n\t\t\tif (!visited[e]) {\n\t\t\t\tlen = Math.max(len, dfs(m, visited, e, l + 1));\n\t\t\t}\n\t\t}\n\t\tvisited[cur] = false;\n\t\treturn len;\n\t}\n\n\tpublic static int[][] getAdjMap(int max, int[][] uedge) {\n\t\tint[][] m = new int[max + 1][];\n\t\tint[] p = new int[max + 1];\n\t\tfor (int[] ue : uedge) {\n\t\t\tp[ue[0]]++;\n\t\t\tp[ue[1]]++;\n\t\t}\n\t\tfor (int i = 1; i <= max; i++)\n\t\t\tm[i] = new int[p[i]];\n\t\tfor (int i = 0; i < uedge.length; i++) {\n\t\t\tm[uedge[i][0]][--p[uedge[i][0]]] = uedge[i][1];\n\t\t\tm[uedge[i][1]][--p[uedge[i][1]]] = uedge[i][0];// counter edge\n\t\t}\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (s.hasNextInt()) {\n\t\t\tint n = s.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] p = new int[n][2];\n\t\t\tint[] d = new int[101];\n\t\t\tArrays.fill(d, 0);\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i][0] = s.nextInt();\n\t\t\t\tp[i][1] = s.nextInt();\n\t\t\t\tif (p[i][0] > max)max = p[i][0];\n\t\t\t\tif (p[i][1] > max)max = p[i][1];\n\t\t\t\td[p[i][0]]++;\n\t\t\t\td[p[i][1]]++;\n\t\t\t}\n\t\t\t// 次数の少ない点が始点/終点足りうる\n\t\t\tint md = 10000;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tmd = Math.min(md, d[i]);\n\t\t\t}\n\t\t\tmd += 2;\n\n\t\t\tint[][] m = getAdjMap(max, p);\n\t\t\tboolean[] visited = new boolean[max + 1];\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tint l = 0;\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tif (md >= d[i]) {\n\t\t\t\t\tl = Math.max(l, dfs(m, visited, i, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tes = new int[n][2];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tes[i][0] = sc.nextInt()-1; es[i][1] = sc.nextInt()-1;\n\t\t\t}\n\t\t\t\n\t\t\tused = new boolean[n]; add = new boolean[100]; max = 0;\n\t\t\tvisited = new HashSet<String>(); tmp = new ArrayList<String>();\n\t\t\tfor(int i=0;i<100;i++) { add[i] = true; dfs(i, 1); add[i] = false; }\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tString getCode() {\n\t\tString ret = \"\";\n\t\tfor(int i=0;i<100;i++) ret += add[i]? 1: 0;\n\t\treturn ret;\n\t}\n\t\n\tint MAX = 5000;\n\tHashSet<String> visited;\n\tArrayList<String> tmp;\n\tboolean[] used;\n\tboolean[] add;\n\tint max = 0;\n\tRandom rnd = new Random(System.currentTimeMillis());\n\tvoid dfs(int p, int num) {\n\t\tmax = max(max, num);\n\t\tif(visited.contains(getCode())) return;\n\t\tif(visited.size() == MAX) {\n\t\t\tint r = rnd.nextInt(MAX);\n\t\t\tvisited.remove(tmp.remove(r));\n\t\t\tvisited.add(getCode());\n\t\t}\n\t\tfor(int i=0;i<n;i++) if(!used[i] && ( es[i][0] == p || es[i][1] == p ) ) {\n\t\t\tif(add[es[i][0]]^add[es[i][1]]) {\n\t\t\t\tint tmp = es[i][0] == p? es[i][1]: es[i][0];\n\t\t\t\tused[i] = true;\n\t\t\t\tadd[tmp] = true;\n\t\t\t\tdfs(tmp, num+1);\n\t\t\t\tused[i] = false;\n\t\t\t\tadd[tmp] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        while(true){\n            Ring.ringList = new HashMap<Integer,Ring>(); \n            int n = Integer.parseInt(line);\n            if(n==0){\n                break;\n            }\n            \n            for(int i=0;i<n;i++){\n                String[] lines = br.readLine().split(\" \");\n                Ring a = Ring.getRing(Integer.parseInt(lines[0]));\n                Ring b = Ring.getRing(Integer.parseInt(lines[1]));\n                a.addNext(b);\n                b.addNext(a);\n            }\n            \n            int ans = 0;\n            for(Ring ring:Ring.getSeachRing()){\n                ans = Math.max(ans,calc(ring));\n            }\n            \n            System.out.println(ans);\n            line = br.readLine();\n        }\n    }\n    \n    private static int calc(Ring start){\n        int max = 0;\n        Route route = new Route();\n        route.use(start);\n\n        Stack<Route> stack = new Stack<Route>();\n        stack.push(route);\n        while(!stack.isEmpty()){\n            route = stack.pop();\n            max = Math.max(max,route.cnt);\n            ArrayList<Ring> next = route.lastLing.getNext();\n            for(Ring ring:next){\n                if(route.isUsable(ring)){\n                    Route n_route = route.clone();\n                    n_route.use(ring);\n                    stack.push(n_route);\n                }\n            }\n        }\n        return max;\n    }\n    \n    private static class Route{\n        int cnt = 0;\n        HashMap<Integer,Boolean> used = new HashMap<Integer,Boolean>();\n        public Ring lastLing;\n        public boolean isUsable(Ring ring){\n            return !used.containsKey(ring.idx);\n        }\n        public void use(Ring ring){\n            used.put(ring.idx,true);\n            lastLing = ring;\n            cnt++;\n        }\n        public Route clone(){\n            Route route = new Route();\n            route.cnt = this.cnt;\n            route.lastLing = this.lastLing;\n            for(int idx:this.used.keySet()){\n                route.used.put(idx,true);\n            }\n            return route;\n        }\n    }\n    \n    \n    private static class Ring{\n        static HashMap<Integer,Ring> ringList = new HashMap<Integer,Ring>();\n        public int idx;\n        public ArrayList<Ring> next = new ArrayList<Ring>();\n        public Ring(int idx){\n            this.idx = idx;\n        }\n        public void addNext(Ring n){\n            if(next.indexOf(n)==-1){\n                next.add(n);\n            }\n        }\n        public ArrayList<Ring> getNext(){\n            return next;\n        }\n        public static Ring getRing(int idx){\n            Ring ret;\n            if(ringList.containsKey(idx)){\n                ret = ringList.get(idx);\n            }else{\n                ret = new Ring(idx);\n                ringList.put(idx,ret);\n            }\n            return ret;\n        }\n        \n        public static ArrayList<Ring> getSeachRing(){\n            ArrayList<Ring> ret = new ArrayList<Ring>();\n            for(int idx:ringList.keySet()){\n                Ring ring = ringList.get(idx);\n                if(ring.next.size()<=2){\n                    ret.add(ring);\n                }\n            }\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass StringwithRing{\n    public static void main(String[] args){\n        ArrayList<Integer> result=new ArrayList<Integer>();\n        try{\n            BufferedReader fin=new BufferedReader(new FileReader(\"input.txt\"));\n            while(true){\n\n                String sc=fin.readLine();\n                int n=Integer.parseInt(sc);\n                if(n==0)break;\n                //System.out.println(n);                                                                                                                                                                    \n                int sub=0;\n                int[][] data=new int[n][2];\n                Reflexive r=new Reflexive();\n                r.getmax(1);\n                for(int i=0;i<n;i++){\n                    sub=Integer.parseInt(fin.readLine());\n                    //  System.out.println(sub);                                                                                                                                                            \n                    data[i][0]=(sub-(sub%10))/10;\n                    data[i][1]=sub%10;\n                    //System.out.println(\"\"+data[i][0]+\"\"+data[i][1]);                                                                                                                                      \n                }\n\n                for(int i=0;i<n;i++){\n\n                    ArrayList<Integer> l=new ArrayList<Integer>();\n                    l.add(i);\n                    r.ref(n,l,data[i][0],data[i][1],data,i);\n                    r.ref(n,l,data[i][1],data[i][0],data,i);\n\n                }\n                result.add(r.getmax());\n                //System.out.println(\"      \"+r.getmax());                                                                                                                                                  \n            }\n            fin.close();\n\n        }catch(Exception e){\n            System.out.println(e);\n        }\n        try{\n            PrintWriter fout=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            for(int i=0;i<result.size();i++){\n                fout.println(result.get(i));\n            }\n            fout.close();\n        }catch(Exception e){\n            System.exit(1);\n        }\n\n    }\nclass Reflexive{\n    private int max=0;\n    public int ref(int num,ArrayList<Integer> flll,int front,int rear,int[][] data,int now){\n\n        if(num==max||front==rear)return 0;\n        for(int i=0;i<num;i++){\n            if(now==i||flll.indexOf(i)!=-1)continue;\n            if(front==data[i][1]){\n\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][1]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][0],data,now);\n                flll.remove(flll.indexOf(i));\n\n            }\n            if(front==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,rear,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n            if(rear==data[i][0]){\n                flll.add(i);\n                maxjd(flll,data,front,rear);\n                ref(num,flll,front,data[i][1],data,now);\n                flll.remove(flll.indexOf(i));\n            }\n\n        }\n        return 0;\n    }\n    public int maxjd(ArrayList<Integer> flll,int[][] data,int front,int rear){\n        ArrayList<Integer> l=new ArrayList<Integer>();\n        for(int i=0;i<flll.size();i++){\n            l.add(data[flll.get(i)][0]);\n            l.add(data[flll.get(i)][1]);\n        }\n\n        for(int i=0;i<l.size();i++){\n            int count=0;\n            for(int j=0;j<l.size();j++){\n                if(i!=j&&l.get(i)==l.get(j))count++;\n            }\n            if(count>=2&&front==l.get(i))return 0;\n            if(count>=2&&rear==l.get(i))return 0;\n        }\n\n        if(flll.size()>max){\n            max=flll.size();\n            /*      for(int i=0;i<l.size();i++){                                                                                                                                                                                                                                              \n                System.out.print(\"\"+l.get(i)+\" \");                                                                                                                                                                                                                                            \n            }                                                                                                                                                                                                                                                                                 \n            System.out.println(\"\");*/\n        }\n        return 0;\n    }\n    public void getmax(int x){\n        max=x;\n    }\n    public int getmax(){\n        return max;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int INF = 2 << 20;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tnode = new Node[101];\n\t\t\tfor(int i = 0; i < 101; i++) {\n\t\t\t\tnode[i] = new Node(i);\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tnode[a].to.add(node[b]);\n\t\t\t\tnode[b].to.add(node[a]);\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tboolean[] tmp = new boolean[101];\n\t\t\tfor(int i = 1; i < 101; i++) {\n\t\t\t\tif(node[i].to.size() == 0) continue;\n\t\t\t\ttmp[i] = true;\n\t\t\t\tans = Math.max(ans,dfs(i,tmp,1));\n\t\t\t\ttmp[i] = false;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int dfs(int now, boolean[] use, int count) {\n\t\tint ret = count;\n\t\tfor(int i = 0; i < node[now].to.size(); i++) {\n\t\t\tint tmp = node[now].to.get(i).id;\n\t\t\tif(use[tmp]) continue;\n\t\t\tuse[tmp] = true;\n\t\t\tret = Math.max(count, dfs(tmp,use,count+1));\n\t\t\tuse[tmp] = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\t\tint id;\n\t\t\tArrayList<Node> to = new ArrayList<Node>();\n\t\t\tNode(int a) {\n\t\t\t\tid = a;\n\t\t\t}\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tString s=\"\";\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint Max=1;\n\t\tforeach(int strt in V){\n\t\t\tQueue<State> Q=new Queue<State>();\n\t\t\tState s=new State(strt);\n\t\t\tQ.Enqueue(s);\n\t\t\twhile(Q.Count>0){\n\t\t\t\tvar now=Q.Dequeue();\n//Console.Write(\"last={0}:\",now.V);foreach(var k in now.H)Console.Write(\"{0} \",k);Console.WriteLine();\n\t\t\t\tforeach(var nxt in E[now.V]){\n\t\t\t\t\tif(now.H.Contains(nxt)==false){\n\t\t\t\t\t\tvar ns=now.Clone();\n\t\t\t\t\t\tMax=Math.Max(Max,ns.Set(nxt));\n\t\t\t\t\t\tQ.Enqueue(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(Max);\n\t}\n\t\n\t\n\tint N;\n\tList<int>[] E;\n\tHashSet<int> V;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tE=new List<int>[101];\n\t\tV=new HashSet<int>();\n\t\tfor(int i=0;i<101;i++)E[i]=new List<int>();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tV.Add(d[0]);\n\t\t\tV.Add(d[1]);\n\t\t\tE[d[0]].Add(d[1]);\n\t\t\tE[d[1]].Add(d[0]);\n\t\t}\n\t}\n\t\n\tclass State{\n\t\tpublic int V;\n\t\tpublic HashSet<int> H;\n\t\tpublic State(int x){\n\t\t\tV=x;\n\t\t\tH=new HashSet<int>();\n\t\t\tH.Add(x);\n\t\t}\n\t\tpublic int Set(int x){\n\t\t\tH.Add(x);\n\t\t\tV=x;\n\t\t\treturn H.Count;\n\t\t}\n\t\tpublic State Clone(){\n\t\t\tvar ret=new State(this.V);\n\t\t\tforeach(var k in this.H)ret.H.Add(k);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Hello{\n    public static void Main(){\n        // Here your code !\n        int CordNum = int.Parse(Console.ReadLine());        \n        List<Chain> Chains = new List<Chain>();\n        \n        int MaxChainLength = 0;\n        //bool CanCombine = false;\n        for(int i = 0; i < CordNum; i++){\n            //CanCombine = false;\n            string[] Rings = Console.ReadLine().Split(' ');\n            int Ring1 = int.Parse(Rings[0]);\n            int Ring2 = int.Parse(Rings[1]);\n            \n            for(int ItemIdx = 0; ItemIdx < Chains.Count; ItemIdx++){\n                if(Chains[ItemIdx].AddCode(Ring1, Ring2)){\n                    MaxChainLength = MaxChainLength < Chains[ItemIdx].Length ?\n                                     Chains[ItemIdx].Length :\n                                     MaxChainLength ;\n                }\n            }\n            Chains.Add(new Chain(Ring1, Ring2));\n        }\n        \n        System.Console.WriteLine(MaxChainLength);\n    }\n}\n\n\npublic class Chain{\n    public List<int> Rings;\n    public int Length{get;set;}\n    public Chain(int Ring1, int Ring2){\n        Rings = new List<int>();\n        Rings.Add(Ring1);\n        Rings.Add(Ring2);\n        Length = Rings.Count;\n    }\n    public bool AddCode(int Ring1, int Ring2){\n        if(Rings.Contains(Ring1) || Rings.Contains(Ring2)){\n            Rings.Add(Ring1);\n            Rings.Add(Ring2);\n            Length = Rings.Distinct().ToArray().Length;\n            return true;\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nclass TEST{\n\tstatic void Main(){\n\t\tStopwatch sw=new Stopwatch();\n\t\tsw.Start();\n\t\t\n\t\tString s=\"\";\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t\t\n\t\tsw.Stop();\n\t\tConsole.Error.WriteLine(sw.ElapsedMilliseconds);\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tMax=0;\n\t\tforeach(var v in V){\n\t\t\tused=new bool[101];\n\t\t\tused[v]=true;\n\t\t\tcnt=1;\n\t\t\tforeach(var nxt in E[v]){\n\t\t\t\tif(!used[nxt]){\n\t\t\t\t\tused[nxt]=true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tMax=Math.Max(cnt,Max);\n\t\t\t\t\tdfs(nxt);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tused[nxt]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Max);\n\t}\n\t\n\t\n\tint Max;\n\tint cnt;\n\tbool[] used;\n\t\n\tvoid dfs(int now){\n\t\tforeach(var nxt in E[now]){\n\t\t\tif(!used[nxt]){\n\t\t\t\tused[nxt]=true;\n\t\t\t\tcnt++;\n\t\t\t\tMax=Math.Max(cnt,Max);\n\t\t\t\tdfs(nxt);\n\t\t\t\tcnt--;\n\t\t\t\tused[nxt]=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tList<int>[] E;\n\tHashSet<int> V;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tE=new List<int>[101];\n\t\tV=new HashSet<int>();\n\t\tfor(int i=0;i<101;i++)E[i]=new List<int>();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tV.Add(d[0]);\n\t\t\tV.Add(d[1]);\n\t\t\tE[d[0]].Add(d[1]);\n\t\t\tE[d[1]].Add(d[0]);\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nclass TEST{\n\tstatic void Main(){\n\t\tStopwatch sw=new Stopwatch();\n\t\tsw.Start();\n\t\t\n\t\tString s=\"\";\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t\t\n\t\tsw.Stop();\n\t\t//Console.Error.WriteLine(sw.ElapsedMilliseconds);\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tused=new bool[101];\n\t\tMax=0;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tif(Count[i]==0)continue;\n\t\t\tused[i]=true;\n\t\t\tcnt=1;\n\t\t\tfor(int j=0;j<Count[i];j++){\n\t\t\t\tif(used[ARR[i][j]])continue;\n\t\t\t\tused[ARR[i][j]]=true;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt>Max)Max=cnt;\n\t\t\t\tdfs(ARR[i][j]);\n\t\t\t\tcnt--;\n\t\t\t\tused[ARR[i][j]]=false;\n\t\t\t}\n\t\t\tcnt--;\n\t\t\tused[i]=false;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Max);\n\t}\n\t\n\t\n\tint Max;\n\tint cnt;\n\tbool[] used;\n\t\n\tvoid dfs(int now){\n\t\tint jj=0;\n\t\tfor(jj=0;jj<Count[now];jj++){\n\t\t\tif(used[ARR[now][jj]])continue;\n\t\t\tused[ARR[now][jj]]=true;\n\t\t\tcnt++;\n\t\t\tif(cnt>Max)Max=cnt;\n\t\t\tdfs(ARR[now][jj]);\n\t\t\tcnt--;\n\t\t\tused[ARR[now][jj]]=false;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint[][] ARR;\n\tint[] Count;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tARR=new int[101][];\n\t\tfor(int i=0;i<101;i++)ARR[i]=new int[101];\n\t\tCount=new int[101];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tCount[d[0]]++;\n\t\t\tARR[d[0]][Count[d[0]]-1]=d[1];\n\t\t\tCount[d[1]]++;\n\t\t\tARR[d[1]][Count[d[1]]-1]=d[0];\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nclass TEST{\n\tstatic void Main(){\n\t\tStopwatch sw=new Stopwatch();\n\t\tsw.Start();\n\t\t\n\t\tString s=\"\";\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t\t\n\t\tsw.Stop();\n\t\tConsole.Error.WriteLine(sw.ElapsedMilliseconds);\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tused=new bool[101];\n\t\tMax=0;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tif(Count[i]==0)continue;\n\t\t\tused[i]=true;\n\t\t\tcnt=1;\n\t\t\tfor(int j=0;j<Count[i];j++){\n\t\t\t\tif(used[ARR[i][j]])continue;\n\t\t\t\tused[ARR[i][j]]=true;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt>Max)Max=cnt;\n\t\t\t\tdfs(ARR[i][j]);\n\t\t\t\tcnt--;\n\t\t\t\tused[ARR[i][j]]=false;\n\t\t\t}\n\t\t\tcnt--;\n\t\t\tused[i]=false;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Max);\n\t}\n\t\n\t\n\tint Max;\n\tint cnt;\n\tbool[] used;\n\t\n\tvoid dfs(int now){\n\t\tint jj=0;\n\t\tfor(jj=0;jj<Count[now];jj++){\n\t\t\tif(used[ARR[now][jj]])continue;\n\t\t\tused[ARR[now][jj]]=true;\n\t\t\tcnt++;\n\t\t\tif(cnt>Max)Max=cnt;\n\t\t\tdfs(ARR[now][jj]);\n\t\t\tcnt--;\n\t\t\tused[ARR[now][jj]]=false;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint[][] ARR;\n\tint[] Count;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tARR=new int[101][];\n\t\tfor(int i=0;i<101;i++)ARR[i]=new int[101];\n\t\tCount=new int[101];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tCount[d[0]]++;\n\t\t\tARR[d[0]][Count[d[0]]-1]=d[1];\n\t\t\tCount[d[1]]++;\n\t\t\tARR[d[1]][Count[d[1]]-1]=d[0];\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nclass TEST{\n\tstatic void Main(){\n\t\tStopwatch sw=new Stopwatch();\n\t\tsw.Start();\n\t\t\n\t\tString s=\"\";\n\t\tList<int> Ns=new List<int>();\n\t\tList<List<String>> Ins=new List<List<String>>();\n\t\t\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tNs.Add(n);\n\t\t\tIns.Add(new List<String>());\n\t\t\tfor(int i=0;i<n;i++)Ins[Ins.Count-1].Add(rs());\n\t\t}\n\t\t\n\t\tint[] Ans=new int[Ins.Count];\n\t\tParallel.For(0,Ns.Count,i=>{\n\t\t\tAns[i]=new Sol(Ns[i],Ins[i]).Solve();\n\t\t});\n\t\t\n\t\tfor(int i=0;i<Ins.Count;i++)Console.WriteLine(Ans[i]);\n\t\t\n\t\t\n\t\tsw.Stop();\n\t\tConsole.Error.WriteLine(sw.ElapsedMilliseconds);\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic int Solve(){\n\t\t\n\t\tMax=0;\n\t\tforeach(var v in V){\n\t\t\tused=new bool[101];\n\t\t\tused[v]=true;\n\t\t\tcnt=1;\n\t\t\tforeach(var nxt in E[v]){\n\t\t\t\tif(!used[nxt]){\n\t\t\t\t\tused[nxt]=true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tMax=Math.Max(cnt,Max);\n\t\t\t\t\tdfs(nxt);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tused[nxt]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Max;\n\t}\n\t\n\t\n\tint Max;\n\tint cnt;\n\tbool[] used;\n\t\n\tvoid dfs(int now){\n\t\tforeach(var nxt in E[now]){\n\t\t\tif(!used[nxt]){\n\t\t\t\tused[nxt]=true;\n\t\t\t\tcnt++;\n\t\t\t\tMax=Math.Max(cnt,Max);\n\t\t\t\tdfs(nxt);\n\t\t\t\tcnt--;\n\t\t\t\tused[nxt]=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tList<int>[] E;\n\tHashSet<int> V;\n\tpublic Sol(int n,List<String> sin){\n\t\tN=n;\n\t\tE=new List<int>[101];\n\t\tV=new HashSet<int>();\n\t\tfor(int i=0;i<101;i++)E[i]=new List<int>();\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=Array.ConvertAll(sin[i].Split(' '),e=>int.Parse(e));\n\t\t\tV.Add(d[0]);\n\t\t\tV.Add(d[1]);\n\t\t\tE[d[0]].Add(d[1]);\n\t\t\tE[d[1]].Add(d[0]);\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nclass TEST{\n\tstatic void Main(){\n\t\tStopwatch sw=new Stopwatch();\n\t\tsw.Start();\n\t\t\n\t\tString s=\"\";\n\t\twhile(!String.IsNullOrEmpty(s=rs())){\n\t\t\tint n=int.Parse(s);\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t\t\n\t\tsw.Stop();\n\t\t//Console.Error.WriteLine(sw.ElapsedMilliseconds);\n\t}\n\tstatic String rs(){return Console.ReadLine();}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tused=new bool[101];\n\t\tMax=0;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tif(Count[i]==0)continue;\n\t\t\tused[i]=true;\n\t\t\tcnt=1;\n\t\t\tfor(int j=0;j<Count[i];j++){\n\t\t\t\tif(used[ARR[i][j]])continue;\n\t\t\t\tused[ARR[i][j]]=true;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt>Max)Max=cnt;\n\t\t\t\tdfs(ARR[i][j]);\n\t\t\t\tcnt--;\n\t\t\t\tused[ARR[i][j]]=false;\n\t\t\t}\n\t\t\tcnt--;\n\t\t\tused[i]=false;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(Max);\n\t}\n\t\n\t\n\tint Max;\n\tint cnt;\n\tbool[] used;\n\t\n\tvoid dfs(int now){\n\t\tint jj=0;\n\t\tfor(jj=0;jj<Count[now];jj++){\n\t\t\tif(used[ARR[now][jj]])continue;\n\t\t\tused[ARR[now][jj]]=true;\n\t\t\tcnt++;\n\t\t\tif(cnt>Max)Max=cnt;\n\t\t\tdfs(ARR[now][jj]);\n\t\t\tcnt--;\n\t\t\tused[ARR[now][jj]]=false;\n\t\t}\n\t}\n\t\n\t\n\tint N;\n\tint[][] ARR;\n\tint[] Count;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tARR=new int[101][];\n\t\tfor(int i=0;i<101;i++)ARR[i]=new int[101];\n\t\tCount=new int[101];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tCount[d[0]]++;\n\t\t\tARR[d[0]][Count[d[0]]-1]=d[1];\n\t\t\tCount[d[1]]++;\n\t\t\tARR[d[1]][Count[d[1]]-1]=d[0];\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nloop {\n    n = gets.to_i\n    break if n == 0\n    chain = [nil, Set.new]\n    n.times {\n\ti, j = gets.split.map &:to_i\n\tends = set = ((1 << i-1) | (1 << j-1))\n\tchain[1] << [set, ends]\n    }\n\n    l = 2\n    loop {\n\tchain[l] = Set.new\n\tchain[l/2].each{|s1, e1|\n\t\tchain[(l+1)/2].each{|s2, e2|\n\t\t\ti = e1 & e2\n\t\t\tif i > 0 && (i-1) & i == 0 && i == s1 & s2\n\t\t\t    chain[l] << [s1 | s2, e1 ^ e2]\n\t\t\tend\n\t\t}\n\t}\n\tbreak if chain[l].empty?\n\tl += 1\n    }\n    p l\n}"
  },
  {
    "language": "Ruby",
    "code": "def solve(edge)\n  answer = 0\n  edge.each do |key, value|\n    answer = [answer, bfs(edge, key)].max\n  end\n  answer\nend\n\ndef bfs(edge, vertex)\n  result = 0\n  visited = Hash.new\n  q = Array.new.unshift([vertex, [vertex]])\n  until q.empty? do\n    u, used = q.shift\n    next if visited[used]\n    visited[used] = true\n    result = [result, used.size].max\n    edge[u].each do |v|\n      next if used.include?(v)\n      q.unshift([v, used+[v]])\n    end\n  end\n  result\nend\n\nuntil (n=gets.to_i)==0 do\n  edge = Hash.new {|h,k|h[k]=Array.new}\n  n.times do\n    i, j = gets.split.map{|e|e.to_i-1}\n    edge[i].push(j)\n    edge[j].push(i)\n  end\n  p solve(edge)\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(i, yet, hop)\n  $r[i].each do |t|\n    if yet[i][t]\n      yet[i][t] = yet[t][i] = false\n      if hop[t] != -1\n        $ret = hop[i] + 1 if $ret < hop[i] + 1\n      else\n        hop[t] = hop[i] + 1\n        dfs(t, yet, hop)\n      end\n    end\n  end\nend\nwhile n = gets.to_i\n  break if n == 0\n  g = 101.times.map{ [false] * 101 }\n  $r = 101.times.map{ [] }\n  m = 0\n  n.times do\n    a, b = gets.split.map(&:to_i)\n    g[a][b] = g[b][a] = true\n    $r[a] << b\n    $r[b] << a\n    m = [a, b, m].max\n  end\n  ans = 0\n  (1..m).each do |i|\n    yet = g.map{ |a| a.dup }\n    hop = [-1] * (m + 1)\n    hop[i] = 0\n    $ret = 0\n    dfs(i, yet, hop)\n    ans = $ret if ans < $ret\n  end\n  p ans\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;h[a]<<b;h[b]<<a}\nret=1\n(1..100).each{|i|\n  GC.start\n  if h[i]!=[]\n    u=[[i,0]]\n    while u!=[]\n      j,k=u[-1]\n      while 1\n        if !(l=h[j][k])\n          u.pop\n          break\n        elsif u.assoc l\n          ret = u.size if ret<u.size\n          k+=1\n        else\n          u[-1][1]=k+1\n          u<<[l,0]\n          break\n        end\n      end\n    end\n  end\n}\n\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n,e\ne.include?(n)&&0||h[n].map{|a|1+f(h,a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);h[a]<<b;h[b]<<a}\np (1..100).map{|i|f h,i,[]}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n,e\ne.include?(n)&&0||h[n].map{|a|1+f(h,a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;h[a]<<b;h[b]<<a}\nret=1\n(1..100).map{|i|\ns=[[i,0]]\nu=[i]\nwhile(s!=[])\nj,k=s.pop\nl=h[j][k]\nif !l\n  u.pop\nelsif u.include? l\n    s<<[j,k+1]\n  ret = [ret,u.size].max\nelse\n    s<<[j,k+1]\n    u<<l\n    s<<[l,0]\nend\nend\n}\n\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;h[a]<<b;h[b]<<a}\nret=1\n(1..100).each{|i|\nif h[i]!=[]\ns=[0]\nu=[i]\nwhile(s!=[])\nj=u[-1]\nk=s[-1]\nwhile 1\nl=h[j][k]\nif !l\n  s.pop\n  u.pop\n  break\nelsif u.include? l\n  ret = u.size if ret<u.size\n  k+=1\nelse\n  s[-1]=k+1\n  u<<l\n  s<<0\n  break\nend\nend\nend\nend\n}\n\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|1+f(a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);$h[a]<<b;$h[b]<<a}\nputs (1..100).map{|i|f i,[]}\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|f(a,e+[n])}||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);exit if a>100||b>100;$h[a]<<b;$h[b]<<a}\np (1..100).map{|i|f i,[]}\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(edge)\n  answer = 0\n  edge.each do |key, value|\n    @memo = Hash.new\n    answer = [answer, dfs(edge, key, Array.new)].max\n  end\n  answer\nend\n\ndef dfs(edge, vertex, visited)\n  return @memo[visited] if @memo[visited]\n  visited[vertex] = true\n  result = visited.count(true)\n  edge[vertex].each do |v|\n    next if visited[v]\n    result = [result, dfs(edge, v, visited.dup)].max\n  end\n  @memo[visited] = result\nend\n\nuntil (n=gets.to_i)==0 do\n  edge = Hash.new {|h,k|h[k]=Array.new}\n  n.times do\n    i, j = gets.split.map{|e|e.to_i-1}\n    edge[i].push(j)\n    edge[j].push(i)\n  end\n  p solve(edge)\nend"
  },
  {
    "language": "Ruby",
    "code": "$edge=([0]*101).map{[0]}\n$size=[0]*101\n$used=[false]*101\ndef rec idx\nret=1\n$size[idx].times{|i|\ni-=1\nif !$used[$edge[idx][i]]\n$used[$edge[idx][i]]=true\nret=[ret,rec($edge[idx][i])+1].max\n$used[$edge[idx][i]]=false\nend\n}\nret\nend\nwhile(n=gets.to_i)>0\nn.times{\na,b=gets.split.map &:to_i\na-=1\nb-=1\n$edge[a][$size[a]+=1]=b\n$edge[b][$size[b]+=1]=a\n}\nret=0\n100.times{|i|\ni-=1\n$used[i]=true\nret=[ret,rec(i)].max\n$used[i]=false\n}\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nh=([0]*101).map.with_index{|n,i|[[i]]}\nn.times{\na,b=gets.split.map &:to_i\nh[a].push(*h[b].map{|l|l.include?(a)?[a]:[a]+l})\nh[b].push(*h[a].map{|l|l.include?(b)?[b]:[b]+l})\n}\np h.map{|i|i.map{|l|l.size}.max}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|1+f(a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\nend"
  },
  {
    "language": "Ruby",
    "code": "def link(link,c)\n  cand = c[link[-1]] - link\n  \n  if cand.empty?\n    size = link.size\n  else\n    si = []\n    for i in 0..cand.size-1\n      si += [link(link+[cand[i]],c)]\n    end\n    size = si.max\n  end\n  \n  size\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0  \n  c = Array.new(101){[]}\n  for i in 0..n-1\n    str = gets.split(\" \").map{|s| s.to_i}\n    c[str[0]] << str[1]\n    c[str[1]] << str[0]\n  end\n  c.map!{|arr| arr.uniq}\n\n  l = []\n  for t in 0..c.size-1\n    puts t\n    l << link([t],c) unless c[t].empty?  \n  end\n\n  puts l.max"
  },
  {
    "language": "Ruby",
    "code": "def f h,n,e\ne.include?(n)&&0||h[n].map{|a|1+f(h,a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;h[a]<<b;h[b]<<a}\nret=1\n(1..100).each{|i|\ns=[[i,0]]\nu=[i]\nwhile(s!=[])\nj,k=s.pop\nl=h[j][k]\nif !l\n  u.pop\nelsif u.include? l\n  s<<[j,k+1]\n  ret = [ret,u.size].max\nelse\n  s<<[j,k+1]\n  u<<l\n  s<<[l,0]\nend\nend\n}\n\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|f(a,e+[n])}||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);$h[a]<<b;$h[b]<<a}\nputs (1..100).map{|i|f i,[]}\nend"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\n\t\t@bits = 1\n\t\t(n-1).times {\n\t\t\t@bits = (@bits << @n + 1) | 1\n\t\t}\n\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\t\t@select_mask = (0..@n-1).map{|i| @ones << i}\n\n\t\t@pos = {}\n\t\tx = 1\n\t\t@n.times {|i|\n\t\t\t@pos[x] = i\n\t\t\tx = (x << 1) | 1\n\t\t}\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\t\t@select_mask[i] |= (@ones << j)\n\tend\n\n\tdef node_size\n\t\t@n\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\t@bits -= (@bits & @select_mask[i])\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\n\tdef deg_zero?(i)\n\t\ttmp = subbits(i)\n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef deg_one?(i)\n\t\ttmp = subbits(i)\n\t\ttmp &= (tmp - 1) \n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef subbits(i)\n\t\t(@bits >> i * @n) & ((1 << @n) - 1)\n\tend\n\n\tdef opposite(i)\n\t\ttmp = subbits(i)\n\t\ttmp -= (1 << i)\n\t\t@pos[(tmp ^ (tmp - 1))]\n\tend\nend\n\ndef search(g, i)\n\treturn 1 if g.deg_zero?(i)\n\tmax = 0\n\tg2 = g.dup\n\tg2.del_node(i)\n\tb = g.subbits(i)\n\t(0..g.node_size-1).each{|j|\n\t\tnext if j == i || b[j] == 0\n\t\tm = search(g2, j)\n\t\tmax = m if m > max\n\t}\n\tmax + 1\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tg = GraphBits.new(n)\n\tn.times {\n\t\ti, j = gets.split.map &:to_i\n\t\tg.add_edge(i-1, j-1)\n\t\tg.add_edge(j-1, i-1)\n\t}\n\n\tp (0..n-1).map{|i| search(g, i)}.max\n}"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\nreturn 0 if e.include?(n)\n$h[n].map{|a|f(a,e+[n])}||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);exit if a>100||b>100;$h[a]<<b;$h[b]<<a}\np (1..100).map{|i|f i,[]}\nend"
  },
  {
    "language": "Ruby",
    "code": "def link(link,c)\n  cand = c[link[-1]] - link\n  \n  if cand.empty?\n    size = link.size\n  else\n    si = []\n    for i in 0..cand.size-1\n      si += [link(link+[cand[i]],c)]\n    end\n    size = si.max\n  end\n  \n  size\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0  \n  c = Array.new(101){[]}\n  for i in 0..n-1\n    str = gets.split(\" \").map{|s| s.to_i}\n    c[str[0]] << str[1]\n    c[str[1]] << str[0]\n  end\n  c.map!{|arr| arr.uniq}\n  puts c.inspect\n  puts\"running...\"\n\n  l = []\n  for t in 0..c.size-1\n    puts t\n    l << link([t],c) unless c[t].empty?  \n  end\n\n  puts l.max"
  },
  {
    "language": "Ruby",
    "code": "def solve(edge)\n  answer = 0\n  edge.each do |key, value|\n    answer = [answer, bfs(edge, key)].max\n  end\n  answer\nend\n\ndef bfs(edge, vertex)\n  result = 0\n  visited = Hash.new\n  q = Array.new.unshift([vertex, [vertex]])\n  until q.empty? do\n    u, used = q.shift\n    next if visited[used]\n    visited[used] = true\n    result = [result, used.size].max\n    edge[u].each do |v|\n      next if used.include?(v)\n      q.unshift([v, (used+[v]).sort])\n    end\n  end\n  result\nend\n\nuntil (n=gets.to_i)==0 do\n  edge = Hash.new {|h,k|h[k]=Array.new}\n  n.times do\n    i, j = gets.split.map{|e|e.to_i-1}\n    edge[i].push(j)\n    edge[j].push(i)\n  end\n  p solve(edge)\nend"
  },
  {
    "language": "Ruby",
    "code": "def link(link,c)\n  cand = c[link[-1]] - link\n  \n  if cand.empty?\n    size = link.size\n  else\n    si = []\n    for i in 0..cand.size-1\n      si += [link(link+[cand[i]],c)]\n    end\n    size = si.max\n  end\n  \n  size\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0  \n  c = Array.new(101){[]}\n  for i in 0..n-1\n    str = gets.split(\" \").map{|s| s.to_i}\n    c[str[0]] << str[1]\n    c[str[1]] << str[0]\n  end\n  c.map!{|arr| arr.uniq}\n\n  l = []\n  for t in 0..c.size-1\n    puts t\n    l << link([t],c) unless c[t].empty?  \n  end\n\n  puts l.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(edge)\n  answer = 0\n  edge.each do |key, value|\n    answer = [answer, dfs(edge, key, Array.new)].max\n  end\n  answer\nend\n\ndef dfs(edge, vertex, visited)\n  visited[vertex] = true\n  result = visited.count(true)\n  edge[vertex].each do |v|\n    next if visited[v]\n    result = [result, dfs(edge, v, visited.dup)].max\n  end\n  result\nend\n\nuntil (n=gets.to_i)==0 do\n  edge = Hash.new {|h,k|h[k]=Array.new}\n  n.times do\n    i, j = gets.split.map{|e|e.to_i-1}\n    edge[i].push(j)\n    edge[j].push(i)\n  end\n  p solve(edge)\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|1+f(a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=(gets||\"0 0\").split.map(&:to_i);$h[a]<<b;$h[b]<<a}\nputs (1..100).map{|i|f i,[]}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def link(link,c)\n  cand = c[link[-1]][1] - link\n\n  if cand.empty?\n    size = link.size\n  else\n    size = 0\n    for i in 0..cand.size-1\n      size = [link(link+[cand[i]],c),size].max\n    end\n  end\n  \n  size\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0\n\n  str = Array.new(n){gets.split(\" \").map{|s| s.to_i}}\n  c = []\n  for i in 0..n-1\n    ri = str[i]\n    c[ri[0]].nil? ? c[ri[0]] = [ri[1]] : c[ri[0]] << ri[1]\n    c[ri[1]].nil? ? c[ri[1]] = [ri[0]] : c[ri[1]] << ri[0]\n  end\n\n  c = c.map.with_index{|arr,id| arr = [id,arr.uniq.sort] unless arr.nil?}\n\n  l = 0\n  for t in 0..c.size-1\n    l = [link([c[t][0]],c),l].max unless c[t].nil?  \n  end\n\n  puts l\nend"
  },
  {
    "language": "Ruby",
    "code": "class Graph\n  Infinity = 1000000000\n  attr_accessor :size, :cost\n  def initialize(size, adjacentMatrix=Array.new(n){Array.new(n)})\n    @size = size\n    @cost = adjacentMatrix.map(&:dup)\n  end\n  def Dijkstra(from)\n    distance = Array.new(@size, Infinity)\n    distance[from] = 0\n    unused = (0...@size).to_a\n    until unused.empty? do\n      current = unused.sort!{|a,b| distance[a]<=>distance[b]}.shift\n      break if distance[current] == Infinity\n      unused.each do |v|\n        next unless @cost[current][v]\n        distance[v] = [distance[v], distance[current]+@cost[current][v]].min\n      end\n    end\n    distance.min\n  end\nend\nuntil (n=gets.to_i)==0 do\n  adj = Array.new(100) {Array.new(100)}\n  n.times do\n    i, j = gets.split.map(&:to_i)\n    i -= 1\n    j -= 1\n    adj[i][j] = adj[j][i] = -1\n  end\n  answer = 0\n  g = Graph.new(100,adj)\n  100.times do |i|\n    answer = [answer, -g.Dijkstra(i)+1].max\n  end\n  p answer\nend"
  },
  {
    "language": "Ruby",
    "code": "class Himo\n  attr_accessor :id, :es\n  def initialize(id, es)\n    @id = id\n    @es = es\n  end\n  def the_other_side(e)\n    if e == @es[0]\n      @es[1]\n    elsif e == @es[1]\n      @es[0]\n    else\n      puts \"error\"\n    end\n  end\n  def to_s\n    \"#{@id}, [#{@es[0]},#{@es[1]}]\"\n  end\nend\n\ndef rec(m, himos, len)\n  if himos[m].nil? || himos[m].empty?\n    return len\n  else\n    max_len = 0\n      himos[m].each do |himo|\n        l = himo.the_other_side(m)\n        himos_copy = himos.dup\n        puts \"error2\" unless himos_copy.delete(m)\n        new_len = rec(l, himos_copy, len+1)\n        max_len = new_len > max_len ? new_len : max_len\n      end\n    return max_len\n  end\n\nend\n\nwhile (n = gets.to_i) != 0 do\n  himos = {}\n  es_nums = []\n  0.upto(n-1) do |i|\n    es = gets.split(\" \").map(&:to_i)\n    es.each do |num|\n        himos[num] = [] if himos[num].nil?\n        himos[num] << Himo.new(i, es)\n    end\n  end\n  lens = []\n  himos.each_key {|m| lens << rec(m, himos, 0)}\n  puts lens.max\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nh=([0]*101).map.with_index{|n,i|[[i]]}\nn.times{\na,b=gets.split.map &:to_i\nh[a].push(*h[b].map{|l|l.include?(a)?[a]:[a]+l}).uniq!\nh[b].push(*h[a].map{|l|l.include?(b)?[b]:[b]+l}).uniq!\n}\np h.map{|i|i.map{|l|l.size}.max}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|1+f(a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);$h[a]<<b;$h[b]<<a}\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nh=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;h[a]<<b;h[b]<<a}\nret=1\n(1..100).each{|i|\n  if h[i]!=[]\n    u=[[i,0]]\n    while u!=[]\n      j,k=u[-1]\n      while 1\n        if !(l=h[j][k])\n          u.pop\n          break\n        elsif u.assoc l\n          ret = u.size if ret<u.size\n          k+=1\n        else\n          u[-1][1]=k+1\n          u<<[l,0]\n          break\n        end\n      end\n    end\n  end\n}\n\np ret\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  n = gets.strip.to_i\n  break if n == 0\n\n  rn = 0\n  rids = {}\n  redges = []\n\n  n.times do\n    a, b = gets.strip.split(' ').map{|s| s.to_i}\n    if rids[a].nil?\n      rids[a] = rn\n      rn += 1\n    end\n    if rids[b].nil?\n      rids[b] = rn\n      rn += 1\n    end\n    redges << [rids[a], rids[b]]\n  end\n  #p rn\n  #p redges\n\n  edges = rn.times.map{[]}\n  nbrs = rn.times.map{[]}\n\n  for re in redges\n    a, b = re\n    edges[a][b] = edges[b][a] = 1\n    nbrs[a] << b\n    nbrs[b] << a\n  end\n  #p edges\n  #p nbrs\n\n  max_cl = 0\n\n  for st in (0...rn)\n    dists = rn.times.map{{}}\n    dists[st][1 << st] = 1\n\n    q = [[st, 1 << st]]\n\n    while ! q.empty?\n      r0, bits0 = q.shift\n\n      for r1 in nbrs[r0]\n        b1 = 1 << r1\n        if (bits0 & b1) == 0\n          bits1 = bits0 | b1\n          d1 = dists[r1][bits1] = dists[r0][bits0] + 1\n          q << [r1, bits1]\n          max_cl = d1 if max_cl < d1\n        end\n      end\n    end\n  end\n\n  puts max_cl\nend"
  },
  {
    "language": "Ruby",
    "code": "class Graph\n  Infinity = 1000000000\n  attr_accessor :size, :cost\n  def initialize(size, adjacentMatrix=Array.new(n){Array.new(n)})\n    @size = size\n    @cost = adjacentMatrix.map(&:dup)\n  end\n  def Dijkstra2(from)\n    distance = Array.new(@size, -Infinity)\n    distance[from] = 0\n    unused = (0...@size).to_a\n    until unused.empty? do\n      current = unused.sort!{|a,b| distance[a]<=>distance[b]}.pop\n      break if distance[current] == -Infinity\n      unused.each do |v|\n        next unless @cost[current][v]\n        distance[v] = [distance[v], distance[current]+@cost[current][v]].max\n      end\n    end\n    distance.max\n  end\nend\n\nMax = 1000000000\nuntil (n=gets.to_i)==0 do\n  adj = Array.new(100) {Array.new(100)}\n  n.times do\n    i, j = gets.split.map(&:to_i)\n    i -= 1\n    j -= 1\n    adj[i][j] = adj[j][i] = 1\n  end\n  answer = 0\n  g = Graph.new(100,adj)\n  100.times do |i|\n    answer = [answer, g.Dijkstra2(i)+1].max\n  end\n  p answer\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|1+f(a,e+[n])}.max||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map &:to_i;$h[a]<<b;$h[b]<<a}\nputs (1..100).map{|i|f i,[]}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef max_chain(r0, visited)\n  max_cl = 1\n\n  for r1 in $nbrs[r0]\n    if ! visited[r1]\n      visited[r1] = true\n      cl = 1 + max_chain(r1, visited)\n      visited[r1] = false\n\n      max_cl = cl if max_cl < cl\n    end\n  end\n\n  max_cl\nend\n\n### main\n\nloop do\n  n = gets.strip.to_i\n  break if n == 0\n\n  $rn = 0\n  rids = {}\n  redges = []\n\n  n.times do\n    a, b = gets.strip.split(' ').map{|s| s.to_i}\n    if rids[a].nil?\n      rids[a] = $rn\n      $rn += 1\n    end\n    if rids[b].nil?\n      rids[b] = $rn\n      $rn += 1\n    end\n    redges << [rids[a], rids[b]]\n  end\n  #p rn\n  #p redges\n\n  $edges = $rn.times.map{[]}\n  $nbrs = $rn.times.map{[]}\n\n  for re in redges\n    a, b = re\n    $edges[a][b] = $edges[b][a] = 1\n    $nbrs[a] << b\n    $nbrs[b] << a\n  end\n  #p $edges\n  #p $nbrs\n\n  max_cl = 0\n\n  for st in (0...$rn)\n    visited = $rn.times.map{false}\n    visited[st] = true\n\n    cl = max_chain(st, visited)\n    max_cl = cl if max_cl < cl\n  end\n\n  puts max_cl\nend"
  },
  {
    "language": "Ruby",
    "code": "def f n,e\ne.include?(n)&&0||$h[n].map{|a|f(a,e+[n])}||0\nend\nwhile(n=gets.to_i)>0\n$h=([0]*101).map{[]}\nn.times{a,b=gets.split.map(&:to_i);$h[a]<<b;$h[b]<<a}\np (1..100).map{|i|f i,[]}\nend"
  },
  {
    "language": "OCaml",
    "code": "type graph = Graph of int * bool array array\n\nlet create_graph strings =\n  let n = List.length strings in\n  let graph = Array.make_matrix (n + 1) (n + 1) false in\n  List.iter\n    (fun (i, j) ->\n     graph.(i).(j) <- true;\n     graph.(j).(i) <- true)\n    strings;\n  Graph (n, graph)\n\nlet iota ?(init=0) ?(step=1) n =\n  let rec iota i n acc =\n    if n = 0 then List.rev acc\n    else iota (i + step) (pred n) (i :: acc) in\n  iota init n []\n\nlet neighbors (Graph (n, graph)) i =\n  let neighbors = ref [] in\n  for j = n downto 1 do\n    if graph.(i).(j) && i <> j then\n      neighbors := j :: !neighbors\n  done;\n  !neighbors\n\nmodule IntSet = Set.Make (\n                    struct\n                      type t = int\n                      let compare (x : int) y = compare x y\n                    end\n                  )\n\nlet longest_chain_length (Graph (n, graph) as g) =\n  let rec longest_chain_length i visited =\n    let visited = IntSet.add i visited in\n    let neighbors =\n      List.filter (fun j -> not @@ IntSet.mem j visited) (neighbors g i) in\n    if neighbors = [] then 0\n    else\n      let subchain_lengths =\n        List.map (fun j -> longest_chain_length j visited) neighbors in\n      1 + List.fold_left max 0 subchain_lengths in\n  1 + (List.fold_left max 0\n       @@ List.map (fun i -> longest_chain_length i IntSet.empty)\n                   (iota ~init:1 n))\n\nlet solve strings = longest_chain_length @@ create_graph strings\n\nlet read_lines n =\n  let rec read_lines n acc =\n    if n = 0 then List.rev acc\n    else read_lines (pred n) ((read_line ()) :: acc) in\n  read_lines n []\n\nlet rec loop () =\n  let n = int_of_string @@ read_line () in\n  if n = 0 then ()\n  else\n    let input = List.map\n                  (fun line -> Scanf.sscanf line \"%d %d\" (fun i j -> (i, j)))\n                  (read_lines n) in\n    print_endline @@ string_of_int @@ solve input;\n    loop ()\n\nlet () = loop ()"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n;\n    const N = 100;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] g = new int[][N];\n        foreach (i; 0 .. n) {\n            int a, b; readf(\"%d %d\\n\", &a, &b);\n            a--; b--;\n            g[a] ~= b;\n            g[b] ~= a;\n        }\n        bool[] used = new bool[N];\n        int dfs(int c) {\n            int ret = 1;\n            foreach (next; g[c]) {\n                if (used[next]) continue;\n                used[next] = true;\n                ret = max(ret, dfs(next) + 1);\n                used[next] = false;\n            }\n            return ret;\n        }\n\n        int ans = 0;\n        foreach (i; 0 .. N) {\n            used[i] = true;\n            ans = max(ans, dfs(i));\n            used[i] = false;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] g = new int[][n];\n        foreach (i; 0 .. n) {\n            int a, b; readf(\"%d %d\\n\", &a, &b);\n            a--; b--;\n            g[a] ~= b;\n            g[b] ~= a;\n        }\n        bool[] used = new bool[n];\n        int dfs(int c) {\n            int ret = 0;\n            foreach (next; g[c]) {\n                if (used[next]) continue;\n                used[next] = true;\n                ret = max(ret, dfs(next) + 1);\n                used[next] = false;\n            }\n            return ret;\n        }\n        int ans = 0;\n        foreach (i; 0 .. n) {\n            used[] = false;\n            ans = max(ans, dfs(i));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n;\n    const N = 100;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] g = new int[][N];\n        foreach (i; 0 .. n) {\n            int a, b; readf(\"%d %d\\n\", &a, &b);\n            a--; b--;\n            g[a] ~= b;\n            g[b] ~= a;\n        }\n        bool[] used = new bool[N];\n        int dfs(int c) {\n            int ret = 0;\n            foreach (next; g[c]) {\n                if (used[next]) continue;\n                used[next] = true;\n                ret = max(ret, dfs(next) + 1);\n                used[next] = false;\n            }\n            return ret;\n        }\n        int ans = 0;\n        foreach (i; 0 .. N) {\n            used[] = false;\n            ans = max(ans, dfs(i));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int n;\n    const N = 100;\n    while (readf(\"%d\\n\", &n), n) {\n        int[][] g = new int[][N];\n        foreach (i; 0 .. n) {\n            int a, b; readf(\"%d %d\\n\", &a, &b);\n            a--; b--;\n            g[a] ~= b;\n            g[b] ~= a;\n        }\n\n        bool[] used = new bool[N];\n        int dfs(int c) {\n            int ret = 1;\n            foreach (next; g[c]) {\n                if (used[next]) continue;\n                used[next] = true;\n                ret = max(ret, dfs(next) + 1);\n                used[next] = false;\n            }\n            return ret;\n        }\n\n        bool[] p = new bool[N];\n        void initP() {\n            void dfs(int c, bool[] q) { // cと連結な頂点をqにマーク\n                q[c] = true;\n                foreach (next; g[c]) {\n                    if (q[next]) continue;\n                    dfs(next, q);\n                }\n            }\n            // 連結していないグラフそれぞれについて次数が最小の頂点をpにマーク\n            bool[] used2 = new bool[N];\n            foreach (i; 0 .. N) { \n                if (used2[i]) continue;\n                bool[] q = new bool[N];\n                dfs(i, q);\n                ulong m = N;\n                foreach (j; 0 .. N) {\n                    if (q[j]) {\n                        used2[j] = true;\n                        m = min(m, g[j].length);\n                    }\n                }\n                foreach (j; 0 .. N) {\n                    if (m == g[j].length) p[j] = true;\n                }\n            }\n        }\n\n        initP;\n        int ans = 0;\n        foreach (i; 0 .. N) {\n            if (p[i]) {\n                used[i] = true;\n                ans = max(ans, dfs(i));\n                used[i] = false;\n            }\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    for i in xrange(n):\n        buf = map(int , fp.readline()[:-1].split(\" \"))\n\n    print \"hoge\""
  },
  {
    "language": "Python",
    "code": "import sys\n\n#fp = open(\"input.txt\", \"r\")\nfp = sys.stdin\n\ndef deepcopy(li):\n    return [i for i in li]\n\ndef countLength(chain, start, prev):\n    node = chain[start][:]\n    if not node:\n        return 0\n    chain[start] = []\n    max_len = 0\n    for i in node:\n        if i == prev:\n            continue\n        cloned = deepcopy(chain)\n        length = countLength(cloned, i, start) + 1\n        if length > max_len:\n            max_len = length\n    return max_len\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    chain = [[] for i in xrange(n)]\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)\n\n    max_len = 0\n    for i in xrange(n):\n        cloned = deepcopy(chain)\n        length = countLength(cloned, i, -1)\n        if length > max_len:\n            max_len = length\n    print max_len"
  },
  {
    "language": "Python",
    "code": "import sys\n\n#fp = open(\"input.txt\", \"r\")\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    chain = [[] for i in xrange(n)]\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def dfs(start):\n        unvisited = [True] * (n + 1)\n        queue = [(start, 1)]\n        max_chain_len = 1\n        while queue:\n            ring, chain_len = queue.pop()\n            if unvisited[ring]:\n                unvisited[ring] = False\n                max_chain_len = max(max_chain_len, chain_len)\n                for r in adj_list[ring]:\n                    if unvisited[r]:\n                        queue.append((r, chain_len + 1))\n        return max_chain_len\n    \n    import sys\n    file_input = sys.stdin\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        adj_list = [[] for _ in range(n + 1)]\n        for _ in range(n):\n            a, b = map(int, file_input.readline().split())\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n        \n        max_len = 0\n        for s in range(1, n + 1):\n            max_len = max(max_len, dfs(s))\n        \n        print(max_len)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    hoge = [[] for i in xrange(n)]\n    for i in xrange(n):\n        fuga = map(int , fp.readline()[:-1].split(\" \"))\n        hoge[fuga[0]-1].append(fuga[1]-1)\n        hoge[fuga[1]-1].append(fuga[0]-1)\n    print 'hoge'"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n        self.ans = max(self.ans, temp)\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 0)\n    return self.ans\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))"
  },
  {
    "language": "Python",
    "code": "def foo(nw, visited):\n    last = visited[-1]\n    r = 0\n    for k in nw[last]:\n        if k not in visited:\n            v = foo(nw, visited + (k,))\n        else:\n            v = len(visited)\n        if r < v:\n            r = v\n    return r\n\n\ndef findlongetstpath(nw):\n    return max([foo(nw, (k,)) for k in nw.keys()])\n\n\ndef chunker(f):\n    while True:\n        line = f.readline()\n        line = line.strip()\n        dsize = int(line)\n        if dsize == 0:\n            raise StopIteration\n        network = {}\n        for i in range(dsize):\n            line = f.readline()\n            line = line.strip()\n            s, d = line.split()\n            rel = network.get(s, None)\n            if rel is None:\n                rel = set()\n            rel.add(d)\n            network[s] = rel\n            rel = network.get(d, None)\n            if rel is None:\n                rel = set()\n            rel.add(s)\n            network[d] = rel\n        yield network\n\nimport sys\nfor nw in chunker(sys.stdin):\n    print  findlongetstpath(nw)"
  },
  {
    "language": "Python",
    "code": "def connect(last):\n    global links, used\n    used[last] = 1\n    result = max([connect(ring) + 1 for ring in links[last] if not used[ring]], default=0)\n    used[last] = 0\n    return result\n\n\nused = [0] * 101\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    links = [set() for i in range(101)]\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        links[a].add(b)\n        links[b].add(a)\n\n    rings = set(i for i, l in enumerate(links) if l)\n\n    max_length = max([connect(ring) + 1 for ring in rings], default=2)\n\n    print(max_length)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    def dfs(ring, chain_len=1):\n        unchecked[ring] = False\n        unvisited[ring] = False\n        len_rec[ring] = max(len_rec[ring], chain_len)\n        for r in adj_list[ring]:\n            if unvisited[r]:\n                dfs(r, chain_len + 1)\n        unvisited[ring] = True\n    \n    import sys\n    file_input = sys.stdin\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        rings = []\n        adj_list = [[] for _ in range(101)]\n        for _ in range(n):\n            a, b = map(int, file_input.readline().split())\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n            rings.extend([a, b])\n        rings = set(rings)\n        \n        len_rec = [1] * 101\n        unchecked = [True] * 101\n        unvisited = [True] * 101\n        \n        for r in rings:\n            if unchecked[r]:\n                dfs(r)\n        dfs(len_rec.index(max(len_rec)))\n        \n        print(max(len_rec))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n        self.ans = self.ans if self.ans > temp else temp\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n    print(self.graph)\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))\n  del gc"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    chain = [[] for i in xrange(n)]\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)\n    print 'hoge'"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\n\ndef connect(history, last):\n    global links, chains\n    branched = False\n    for ring in links[last]:\n        if ring in history:\n            continue\n        history.append(ring)\n        connect(history, ring)\n        history.pop()\n        branched = True\n    if not branched:\n        chains.append(set(history))\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    links = {i: set() for i in range(1, 101)}\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        links[a].add(b)\n        links[b].add(a)\n\n    links = {i: link for i, link in links.items() if link}\n    rings = set(links.keys())\n\n    current_max = 0\n\n    while rings:\n        chains = []\n        first = rings.pop()\n        connect([first], first)\n        for chain1, chain2 in combinations(chains, 2):\n            if len(chain1 & chain2) == 1:\n                current = len(chain1) + len(chain2) - 1\n                current_max = max(current, current_max)\n            else:\n                current_max = max(current_max, len(chain1), len(chain2))\n\n        for chain in chains:\n            rings -= chain\n    print(current_max)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n        self.ans = self.ans if self.ans > temp else temp\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))\n  del gc"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\ndef foo(nw, visited):\n    last = visited[-1]\n    r = 0\n    for k in nw[last]:\n        if k not in visited:\n            v = foo(nw, visited + (k,))\n        else:\n            v = len(visited)\n        if r < v:\n            r = v\n    return r\n\ndef findlongetstpath(nw):\n    return max([foo(nw, (k,)) for k in nw.keys()])\n\ndef chunker(f):\n    while True:\n        line = f.readline()\n        line = line.strip()\n        dsize = int(line)\n        if dsize == 0:\n            raise StopIteration\n        network = {}\n        for i in range(dsize):\n            line = f.readline()\n            line = line.strip()\n            s, d = line.split()\n            rel = network.get(s, None)\n            if rel is None:\n                rel = set()\n            rel.add(d)\n            network[s] = rel\n            rel = network.get(d, None)\n            if rel is None:\n                rel = set()\n            rel.add(s)\n            network[d] = rel\n        yield network\n\nimport sys\nfor nw in chunker(sys.stdin):\n    print findlongetstpath(nw)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict                                              \n                                                                                 \n                                                                                 \nclass GraphChain():                                                              \n  def __init__(self):                                                            \n    self.graph = defaultdict(set)                                                \n    self.passed = defaultdict(bool)                                              \n    self.route = defaultdict(bool)                                               \n    self.ans = 0                                                                 \n                                                                                 \n  def dfs(self, left, count):                                                    \n    '''                                                                          \n      depth first search                                                         \n    '''                                                                          \n    for i in range(len(self.graph[left])):                                       \n      if self.passed[self.graph[left][i]] == False:                              \n        # mark passed point                                                      \n        self.passed[self.graph[left][i]] = True                                  \n                                                                                 \n        # if next route is more than two, this node is never become start point. \n        if len(self.graph[left]) > 2:                                            \n          self.route[self.graph[left][i]] = True                                 \n        temp = self.dfs(self.graph[left][i], count + 1)                          \n        self.ans = max(self.ans, temp)                                           \n                                                                                 \n        # delete mark of point.                                                  \n        self.passed[self.graph[left][i]] = False                                 \n                                                                                 \n    return count                                                                 \n                                                                                 \n  def get_string_pair(self, num):                                                \n    '''                                                                          \n      get string and make dictionary.                                            \n    '''                                                                          \n    self.graph = defaultdict(list)                                               \n    for i in range(num):                                                         \n      left, righ = [int(j) for j in input().strip().split()]                     \n      self.graph[left].append(righ)                                              \n      self.graph[righ].append(left)                                              \n                                                                                 \n    return self.graph                                                            \n                                                                                 \n  def count_chain(self, num):                                                    \n    '''                                                                          \n      main function of this problem.                                             \n    '''                                                                          \n    self.get_string_pair(num)                                                    \n                                                                                 \n    for key in sorted(self.graph.keys()):                                        \n      if self.route[key] == False:                                               \n        self.dfs(key, 0)                                                         \n    return self.ans                                                              \n                                                                                 \n                                                                                 \nwhile 1:                                                                         \n  gc = GraphChain()                                                              \n  x = int(input())                                                               \n  if x == 0:                                                                     \n    break                                                                        \n  print(gc.count_chain(x))                                                       "
  },
  {
    "language": "Python",
    "code": "import sys\n\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    cha = [[] for i in xrange(n)]\n    for i in xrange(n):\n        st = map(int , fp.readline()[:-1].split(\" \"))\n        cha[st[0]-1].append(st[1]-1)\n        cha[st[1]-1].append(st[0]-1)\n    print 'hoge'"
  },
  {
    "language": "Python",
    "code": "def connect(history, last):\n    global links, max_length\n    branched = False\n    for ring in links[last]:\n        if ring in history:\n            continue\n        history.append(ring)\n        connect(history, ring)\n        history.pop()\n        branched = True\n    if not branched:\n        max_length = max(max_length, len(history))\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    links = {i: set() for i in range(1, 101)}\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        links[a].add(b)\n        links[b].add(a)\n\n    links = {i: link for i, link in links.items() if link}\n    rings = set(links.keys())\n\n    max_length = 0\n\n    while rings:\n        start = rings.pop()\n        connect([start], start)\n    print(max_length)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfp = sys.stdin\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n    chain = []\n    for i in xrange(n):\n        chain.append([])\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)\n    print 'hoge'"
  },
  {
    "language": "Python",
    "code": "def connect(history, last):\n    global links, chains\n    branched = False\n    for ring in links[last]:\n        if ring in history:\n            continue\n        history.append(ring)\n        connect(history, ring)\n        history.pop()\n        branched = True\n    if not branched:\n        chains.append(set(history))\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    links = {i: set() for i in range(1, 101)}\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        links[a].add(b)\n        links[b].add(a)\n\n    links = {i: link for i, link in links.items() if link}\n    rings = set(links.keys())\n\n    current_max = 0\n\n    while rings:\n        chains = []\n        first = rings.pop()\n        connect([first], first)\n        for chain in chains:\n            current_max = max(current_max, len(chain))\n    print(current_max)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for i in range(len(self.graph[left])):\n      if self.passed[self.graph[left][i]] == False:\n        # mark passed point\n        self.passed[self.graph[left][i]] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[self.graph[left][i]] = True\n        temp = self.dfs(self.graph[left][i], count + 1)\n        self.ans = max(self.ans, temp)\n\n        # delete mark of point.\n        self.passed[self.graph[left][i]] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(list)\n    for i in range(num):\n      left, righ = [int(j) for j in input().strip().split()]\n      self.graph[left].append(righ)\n      self.graph[righ].append(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n#fp = open(\"input.txt\", \"r\")\nfp = sys.stdin\n\ndef deepcopy(li):\n    return [i for i in li]\n\ndef countLength(chain, start, prev):\n    node = chain[start][:]\n    if not node:\n        return 0\n    chain[start] = []\n    max_len = 0\n    for i in node:\n        if i == prev:\n            continue\n        cloned = deepcopy(chain)\n        length = countLength(cloned, i, start) + 1\n        if length > max_len:\n            max_len = length\n    return max_len\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    chain = [[] for i in xrange(n)]\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)\n\n    max_len = 0\n    for i in xrange(n):\n        cloned = deepcopy(chain)\n        #length = countLength(cloned, i, -1)\n        #if length > max_len:\n        #    max_len = length\n    print max_len"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict                                              \n                                                                                 \n                                                                                 \nclass GraphChain():                                                              \n  def __init__(self):                                                            \n    self.graph = defaultdict(set)                                                \n    self.passed = defaultdict(bool)                                              \n    self.route = defaultdict(bool)                                               \n    self.ans = 0                                                                 \n                                                                                 \n  def dfs(self, left, count):                                                    \n    '''                                                                          \n      depth first search                                                         \n    '''                                                                          \n    for i in range(len(self.graph[left])):                                       \n      if self.passed[self.graph[left][i]] == False:                              \n        # mark passed point                                                      \n        self.passed[self.graph[left][i]] = True                                  \n                                                                                 \n        # if next route is more than two, this node is never become start point. \n        if len(self.graph[left]) > 2:                                            \n          self.route[self.graph[left][i]] = True                                 \n        temp = self.dfs(self.graph[left][i], count + 1)                          \n        self.ans = max(self.ans, temp)                                           \n                                                                                 \n        # delete mark of point.                                                  \n        self.passed[self.graph[left][i]] = False                                 \n                                                                                 \n    return count                                                                 \n                                                                                 \n  def get_string_pair(self, num):                                                \n    '''                                                                          \n      get string and make dictionary.                                            \n    '''                                                                          \n    self.graph = defaultdict(list)                                               \n    for i in range(num):                                                         \n      left, righ = [int(j) for j in input().strip().split()]                     \n      self.graph[left].append(righ)                                              \n      self.graph[righ].append(left)                                              \n                                                                                 \n    return self.graph                                                            \n                                                                                 \n  def count_chain(self, num):                                                    \n    '''                                                                          \n      main function of this problem.                                             \n    '''                                                                          \n    self.get_string_pair(num)                                                    \n                                                                                 \n    for key in sorted(self.graph.keys()):                                        \n      if self.route[key] == False:                                               \n        self.dfs(key, 0)                                                         \n    return self.ans                                                              \n                                                                                 \n                                                                                 \nwhile 1:                                                                         \n  gc = GraphChain()                                                              \n  x = int(input())                                                               \n  if x == 0:                                                                     \n    break                                                                        \n  print(gc.count_chain(x))                                                       "
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\n#fp = open(\"input.txt\", \"r\")\nfp = sys.stdin\n\ndef countLength(chain, start, prev):\n    node = chain[start][:]\n    if not node:\n        return 0\n    chain[start] = []\n    max_len = 0\n    for i in node:\n        if i == prev:\n            continue\n        cloned = deepcopy(chain)\n        length = countLength(cloned, i, start) + 1\n        if length > max_len:\n            max_len = length\n    return max_len\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    chain = [[] for i in xrange(n)]\n    for i in xrange(n):\n        string = map(int , fp.readline()[:-1].split(\" \"))\n        chain[string[0]-1].append(string[1]-1)\n        chain[string[1]-1].append(string[0]-1)\n\n    max_len = 0\n    for i in xrange(n):\n        cloned = deepcopy(chain)\n        length = countLength(cloned, i, -1)\n        if length > max_len:\n            max_len = length\n    print max_len"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass GraphChain():\n  def __init__(self):\n    self.graph = defaultdict(set)\n    self.passed = defaultdict(bool)\n    self.route = defaultdict(bool)\n    self.ans = 0\n\n  def dfs(self, left, count):\n    '''\n      depth first search\n    '''\n    for point in self.graph[left]:\n      if self.passed[point] == False:\n        # mark passed point\n        self.passed[point] = True\n\n        # if next route is more than two, this node is never become start point.\n        if len(self.graph[left]) > 2:\n          self.route[point] = True\n        temp = self.dfs(point, count + 1)\n        self.ans = self.ans if self.ans > temp else temp\n\n        # delete mark of point.\n        self.passed[point] = False\n\n    return count\n\n  def get_string_pair(self, num):\n    '''\n      get string and make dictionary.\n    '''\n    self.graph = defaultdict(set)\n    for i in range(num):\n      left, righ = (int(j) for j in input().strip().split())\n      self.graph[left].add(righ)\n      self.graph[righ].add(left)\n\n    return self.graph\n\n  def count_chain(self, num):\n    '''\n      main function of this problem.\n    '''\n    self.get_string_pair(num)\n\n    for key in sorted(self.graph.keys()):\n      if self.route[key] == False:\n        self.dfs(key, 1)\n\n    return self.ans - 1\n\n\nwhile 1:\n  gc = GraphChain()\n  x = int(input())\n  if x == 0:\n    break\n  print(gc.count_chain(x))\n  del gc"
  },
  {
    "language": "Python",
    "code": "from queue import deque\n\n\ndef longest(i):\n    visited = (i,)\n    q = deque((r, visited) for r in links[i])\n    while q:\n        ring, visited = q.popleft()\n        for r in links[ring]:\n            if r not in visited:\n                q.append((r, visited + (ring,)))\n    return len(visited) + 1\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n\n    links = [set() for _ in range(n)]\n    for _ in range(n):\n        s, t = map(int, input().split())\n        s, t = s - 1, t - 1\n        links[s].add(t)\n        links[t].add(s)\n\n    print(max(longest(i) for i in range(n)))"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let n: usize = read();\n    \n    if n == 0 { break; }\n    \n    let mut adj: Vec<Vec<usize>> = vec![Vec::new();100];\n    let mut vt: Vec<bool> = vec![false;100];\n    \n    for _ in 0 .. n {\n      let ab:Vec<usize> = read_vec();\n      adj[ab[0]-1].push(ab[1]-1);\n      adj[ab[1]-1].push(ab[0]-1);\n    }\n\n    let ans = (0..100).map(|i| dfs(&adj, &mut vt, i)).max().unwrap();\n    \n    println!(\"{}\", ans);\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\nfn dfs(adj: &Vec<Vec<usize>>, vt: &mut Vec<bool>, i: usize) -> usize {\n  if vt[i] {\n    0\n  } else {\n    vt[i] = true;\n    let mut mxl: usize = 0;\n    for &j in &adj[i] {\n      let k = dfs(adj, vt, j);\n      if mxl < k { mxl = k; }\n    }\n    vt[i] = false;\n    mxl + 1\n  }\n}\n\n"
  }
]