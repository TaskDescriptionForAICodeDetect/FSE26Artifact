[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\n// Adjacency list representation of the tree\nint graph[MAX_N][MAX_N];\nint graphSize[MAX_N];\n\n// Function to compute distance between two nodes using BFS\nint computeDistance(int start, int end, int N) {\n    int dist[MAX_N];\n    bool visited[MAX_N];\n    \n    memset(dist, -1, sizeof(dist));\n    memset(visited, false, sizeof(visited));\n    \n    int queue[MAX_N], front = 0, rear = 0;\n    queue[rear++] = start;\n    dist[start] = 0;\n    visited[start] = true;\n    \n    while (front < rear) {\n        int current = queue[front++];\n        \n        if (current == end) return dist[current];\n        \n        for (int i = 0; i < graphSize[current]; i++) {\n            int neighbor = graph[current][i];\n            if (!visited[neighbor]) {\n                queue[rear++] = neighbor;\n                dist[neighbor] = dist[current] + 1;\n                visited[neighbor] = true;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n    \n    // Reset graph\n    memset(graphSize, 0, sizeof(graphSize));\n    \n    // Build tree\n    for (int i = 1; i < N; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][graphSize[u]++] = v;\n        graph[v][graphSize[v]++] = u;\n    }\n    \n    // Compute distance between Takahashi and Aoki\n    int distance = computeDistance(A, B, N);\n    \n    // Game strategy\n    int moves = (distance - 1) / 2;\n    \n    printf(\"%d\\n\", moves);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N + 1];\nint edge_count = 0;\n\nint dist_t[MAX_N + 1];\nint dist_a[MAX_N + 1];\nint queue[MAX_N];\nint front, rear;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid bfs(int start, int *dist) {\n    memset(dist, -1, sizeof(int) * (MAX_N + 1));\n    front = rear = 0;\n    queue[rear++] = start;\n    dist[start] = 0;\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, u, v;\n    scanf(\"%d %d %d\", &N, &u, &v);\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    bfs(u, dist_t);\n    bfs(v, dist_a);\n\n    int max_dist = 0;\n    for (int i = 1; i <= N; i++) {\n        if (dist_t[i] < dist_a[i] && dist_a[i] > max_dist) {\n            max_dist = dist_a[i];\n        }\n    }\n\n    printf(\"%d\\n\", max_dist - 1);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> distT, distA;\n\nvoid bfs(int start, vector<int>& dist) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, u, v;\n    cin >> N >> u >> v;\n    u--; v--;\n    adj.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    distT.assign(N, -1);\n    distA.assign(N, -1);\n    bfs(u, distT);\n    bfs(v, distA);\n\n    int ans = 0;\n    for (int i = 0; i < N; ++i) {\n        if (distT[i] < distA[i]) {\n            ans = max(ans, distA[i] - 1);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static List<Integer>[] adj;\n    static int[] distT;\n    static int[] distA;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int u = sc.nextInt() - 1;\n        int v = sc.nextInt() - 1;\n\n        adj = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj[a].add(b);\n            adj[b].add(a);\n        }\n\n        distT = new int[N];\n        distA = new int[N];\n        Arrays.fill(distT, -1);\n        Arrays.fill(distA, -1);\n\n        bfs(u, distT);\n        bfs(v, distA);\n\n        int max = 0;\n        for (int i = 0; i < N; i++) {\n            if (distT[i] < distA[i]) {\n                max = Math.max(max, distA[i] - 1);\n            }\n        }\n\n        System.out.println(max);\n    }\n\n    static void bfs(int start, int[] dist) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(start);\n        dist[start] = 0;\n\n        while (!q.isEmpty()) {\n            int current = q.poll();\n            for (int neighbor : adj[current]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[current] + 1;\n                    q.add(neighbor);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:41:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TreeGame {\n    static ArrayList<Integer>[] graph;\n    static int N, start, end;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        start = Integer.parseInt(st.nextToken()) - 1;\n        end = Integer.parseInt(st.nextToken()) - 1;\n        \n        graph = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        int[] distStart = bfs(start);\n        int[] distEnd = bfs(end);\n        \n        int result = (distEnd[start] + 1) / 2;\n        System.out.println(result);\n    }\n    \n    static int[] bfs(int source) {\n        int[] dist = new int[N];\n        Arrays.fill(dist, -1);\n        dist[source] = 0;\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(source);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            for (int neighbor : graph[current]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[current] + 1;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 22:41:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> graph[MAXN];\nint N, T, A;\n\nint dfs(int takahashi, int aoki, int parent) {\n    // If Takahashi and Aoki are at the same vertex, game ends\n    if (takahashi == aoki) return 0;\n    \n    int min_moves = INT_MAX;\n    \n    // Try all adjacent vertices for Aoki\n    for (int next_aoki : graph[aoki]) {\n        if (next_aoki == parent) continue;\n        \n        // Try all adjacent vertices for Takahashi\n        int best_takahashi_move = -1;\n        int max_distance = -1;\n        \n        for (int next_takahashi : graph[takahashi]) {\n            if (next_takahashi == parent) continue;\n            \n            int current_moves = dfs(next_takahashi, next_aoki, aoki) + 1;\n            \n            // Takahashi wants to maximize distance\n            if (current_moves > max_distance) {\n                max_distance = current_moves;\n                best_takahashi_move = next_takahashi;\n            }\n        }\n        \n        min_moves = min(min_moves, max_distance);\n    }\n    \n    return min_moves;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> N >> T >> A;\n    \n    // Build graph\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    int result = dfs(T, A, 0);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(f: int, n: int, adj: list):\n    dist = [-1] * n\n    queue = deque([f])\n    dist[f] = 0\n    while queue:\n        v = queue.popleft()\n        for u in adj[v]:\n            if dist[u] == -1:\n                dist[u] = dist[v] + 1\n                queue.append(u)\n    return dist\n\ndef game_on_tree(n: int, u: int, v: int, edges: list):\n    adj = [[] for _ in range(n)]\n    for a, b in edges:\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    \n    dist_from_u = bfs(u-1, n, adj)\n    dist_from_v = bfs(v-1, n, adj)\n\n    takahashi_max_dist = 0\n    for i in range(n):\n        if dist_from_u[i] < dist_from_v[i]:\n            takahashi_max_dist = max(takahashi_max_dist, dist_from_v[i])\n\n    return takahashi_max_dist - 1\n\n# Example Usage:\nn, u, v = 4, 1, 2\nedges = [(1, 2), (1, 3), (1, 4)]\nprint(game_on_tree(n, u, v, edges))  # Output: 2",
    "timestamp": "2025-08-13 12:05:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeGame {\n    static class Tree {\n        int N;\n        List<Integer>[] adjList;\n        \n        public Tree(int N) {\n            this.N = N;\n            adjList = new ArrayList[N];\n            for (int i = 0; i < N; i++) {\n                adjList[i] = new ArrayList<>();\n            }\n        }\n        \n        public void addEdge(int u, int v) {\n            adjList[u].add(v);\n            adjList[v].add(u);\n        }\n        \n        public int getDistance(int start, int end) {\n            Queue<Integer> queue = new LinkedList<>();\n            boolean[] visited = new boolean[N];\n            int[] distance = new int[N];\n            \n            queue.add(start);\n            visited[start] = true;\n            distance[start] = 0;\n            \n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                for (int neighbor : adjList[current]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        distance[neighbor] = distance[current] + 1;\n                        queue.add(neighbor);\n                    }\n                }\n            }\n            \n            return distance[end];\n        }\n    }\n\n    public static int aokiMoves(int N, int u, int v, int[][] edges) {\n        Tree tree = new Tree(N);\n        \n        for (int[] edge : edges) {\n            tree.addEdge(edge[0], edge[1]);\n        }\n        \n        int distance = tree.getDistance(u, v);\n        \n        return (distance - 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        int N = 7;\n        int[][] edges = { {0, 1}, {1, 2}, {1, 3}, {2, 4}, {2, 5}, {3, 6} };\n        int u = 0;\n        int v = 4;\n        \n        System.out.println(aokiMoves(N, u, v, edges)); // Output the number of moves\n    }\n}",
    "timestamp": "2025-08-13 12:05:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200005\n\ntypedef struct Edge {\n    int to;\n    struct Edge* next;\n} Edge;\n\nEdge* graph[MAX_N];\nint t_dist[MAX_N];\nint a_dist[MAX_N];\n\nvoid addEdge(int from, int to) {\n    Edge* edge = (Edge*)malloc(sizeof(Edge));\n    edge->to = to;\n    edge->next = graph[from];\n    graph[from] = edge;\n}\n\nvoid bfs(int start, int* dist) {\n    int queue[MAX_N], front = 0, back = 0;\n    int visited[MAX_N] = {0};\n    \n    queue[back++] = start;\n    dist[start] = 0;\n    visited[start] = 1;\n    \n    while (front < back) {\n        int u = queue[front++];\n        for (Edge* edge = graph[u]; edge; edge = edge->next) {\n            int v = edge->to;\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[back++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, U, V;\n    scanf(\"%d %d %d\", &N, &U, &V);\n    \n    for (int i = 0; i < N - 1; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        addEdge(A, B);\n        addEdge(B, A);\n    }\n    \n    memset(t_dist, -1, sizeof(t_dist));\n    memset(a_dist, -1, sizeof(a_dist));\n    \n    bfs(U, t_dist);\n    bfs(V, a_dist);\n\n    int max_moves = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        if (t_dist[i] < a_dist[i]) {\n            if (a_dist[i] - 1 > max_moves) {\n                max_moves = a_dist[i] - 1;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_moves);\n\n    // Free the allocated memory for edges\n    for (int i = 1; i <= N; i++) {\n        Edge* edge = graph[i];\n        while (edge) {\n            Edge* next = edge->next;\n            free(edge);\n            edge = next;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:05:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function treeGame(N, edges, T, A) {\n    // Create an adjacency list for the tree\n    const tree = Array.from({ length: N }, () => []);\n    for (const [u, v] of edges) {\n        tree[u].push(v);\n        tree[v].push(u);\n    }\n\n    // Function to calculate the distance between two nodes using BFS\n    function bfs(startNode) {\n        const distances = Array(N).fill(Infinity);\n        const queue = [startNode];\n        distances[startNode] = 0;\n\n        while (queue.length > 0) {\n            const node = queue.shift();\n            for (const neighbor of tree[node]) {\n                if (distances[neighbor] === Infinity) {\n                    distances[neighbor] = distances[node] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        }\n        return distances;\n    }\n\n    // Calculate distances from Takahashi's starting position\n    const distFromTakahashi = bfs(T);\n\n    // Calculate distances from Aoki's starting position\n    const distFromAoki = bfs(A);\n\n    // Find the farthest node from Takahashi within Aoki's reach\n    let maxDistance = 0;\n    for (let i = 0; i < N; i++) {\n        if (distFromAoki[i] <= distFromTakahashi[i]) {\n            maxDistance = Math.max(maxDistance, distFromAoki[i]);\n        }\n    }\n\n    return maxDistance;\n}\n\n// Example usage:\n// const N = 4;\n// const edges = [[0, 1], [1, 2], [1, 3]];\n// const T = 0, A = 3;\n// console.log(treeGame(N, edges, T, A)); // Output: expected number of moves",
    "timestamp": "2025-08-13 12:05:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, edges, start_takahashi, start_aoki):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Find shortest distance between vertices using BFS\n    def shortest_distance(start, end):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        \n        while queue:\n            node, dist = queue.popleft()\n            \n            if node == end:\n                return dist\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        \n        return -1\n    \n    # Initial game setup\n    takahashi_pos = start_takahashi\n    aoki_pos = start_aoki\n    total_dist = shortest_distance(takahashi_pos, aoki_pos)\n    \n    # If Takahashi is at Aoki's start, game is over\n    if total_dist == 0:\n        return 0\n    \n    # Determine number of moves Aoki will make\n    moves = (total_dist + 1) // 2\n    \n    return moves",
    "timestamp": "2025-08-13 12:05:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges, takahashiPos, aokiPos) {\n    // Create adjacency list representation of the tree\n    const graph = Array.from({ length: N + 1 }, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    // Calculate distances between nodes using BFS\n    function bfs(start) {\n        const distances = new Array(N + 1).fill(Infinity);\n        distances[start] = 0;\n        const queue = [start];\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            for (const neighbor of graph[current]) {\n                if (distances[neighbor] === Infinity) {\n                    distances[neighbor] = distances[current] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    const takahashiDistances = bfs(takahashiPos);\n    const aokiDistances = bfs(aokiPos);\n\n    // Find the minimum moves for Aoki\n    let minAokiMoves = Infinity;\n    for (let node = 1; node <= N; node++) {\n        if (takahashiDistances[node] < aokiDistances[node]) {\n            minAokiMoves = Math.min(minAokiMoves, aokiDistances[node] - 1);\n        }\n    }\n\n    return minAokiMoves;\n}",
    "timestamp": "2025-08-13 12:05:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    N, u, v = map(int, sys.stdin.readline().split())\n    u -= 1\n    v -= 1\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(int, sys.stdin.readline().split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    def bfs(start):\n        dist = [-1] * N\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if dist[y] == -1:\n                    dist[y] = dist[x] + 1\n                    q.append(y)\n        return dist\n    \n    dist_u = bfs(u)\n    dist_v = bfs(v)\n    \n    max_dist = 0\n    for i in range(N):\n        if dist_u[i] < dist_v[i]:\n            if dist_v[i] > max_dist:\n                max_dist = dist_v[i]\n    \n    print(max_dist - 1)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:06:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nfunction solve() {\n    const N = parseInt(input[0], 10);\n    const edges = [];\n    for (let i = 0; i < N - 1; i++) {\n        const [a, b] = input[i + 1].split(' ').map(x => parseInt(x, 10) - 1);\n        edges.push([a, b]);\n    }\n\n    const adj = Array.from({ length: N }, () => []);\n    for (const [a, b] of edges) {\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n\n    const [u, v] = input[N].split(' ').map(x => parseInt(x, 10) - 1);\n\n    const distT = new Array(N).fill(-1);\n    const distA = new Array(N).fill(-1);\n\n    function bfs(start, dist) {\n        const queue = [start];\n        dist[start] = 0;\n        while (queue.length > 0) {\n            const current = queue.shift();\n            for (const neighbor of adj[current]) {\n                if (dist[neighbor] === -1) {\n                    dist[neighbor] = dist[current] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n\n    bfs(u, distT);\n    bfs(v, distA);\n\n    let max = 0;\n    for (let i = 0; i < N; i++) {\n        if (distT[i] < distA[i]) {\n            if (distA[i] > max) {\n                max = distA[i];\n            }\n        }\n    }\n\n    console.log(max - 1);\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:06:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> depth, parent;\nint N, Takahashi, Aoki;\n\nvoid bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    depth[start] = 0;\n    parent[start] = -1;\n    \n    while (!q.empty()) {\n        int node = q.front(); q.pop();\n        for (int neighbor : adj[node]) {\n            if (depth[neighbor] == -1) {\n                depth[neighbor] = depth[node] + 1;\n                parent[neighbor] = node;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> Takahashi >> Aoki;\n    --Takahashi; --Aoki;\n    \n    adj.resize(N);\n    depth.resize(N, -1);\n    parent.resize(N, -1);\n\n    for (int i = 0; i < N-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    bfs(Aoki);\n\n    int maxDist = 0;\n    \n    queue<int> q;\n    q.push(Takahashi);\n    vector<int> takahashiDepth(N, -1);\n    takahashiDepth[Takahashi] = 0;\n\n    while (!q.empty()) {\n        int node = q.front(); q.pop();\n        for (int neighbor : adj[node]) {\n            if (takahashiDepth[neighbor] == -1) {\n                takahashiDepth[neighbor] = takahashiDepth[node] + 1;\n                q.push(neighbor);\n                \n                if (depth[neighbor] > takahashiDepth[neighbor]) {\n                    maxDist = max(maxDist, depth[neighbor]);\n                }\n            }\n        }\n    }\n\n    cout << maxDist << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:56"
  }
]